<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   12Writing Generic Code with Templates
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_006.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_008.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c12_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c12_1">
      <span aria-label="451" class="calibre17" epub:type="pagebreak" id="Page_451" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c12">
      </span>
      <span class="calibre">
       12
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Writing Generic Code with Templates
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c12-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c12-list-0001">
         <li class="calibre9" id="c12-li-0001">
          How to write class templates
         </li>
         <li class="calibre9" id="c12-li-0002">
          How the compiler processes templates
         </li>
         <li class="calibre9" id="c12-li-0003">
          How to organize template source code
         </li>
         <li class="calibre9" id="c12-li-0004">
          How to use non-type template parameters
         </li>
         <li class="calibre9" id="c12-li-0005">
          How to write templates of individual class member functions
         </li>
         <li class="calibre9" id="c12-li-0006">
          How to customize class templates for specific types
         </li>
         <li class="calibre9" id="c12-li-0007">
          How to combine templates and inheritance
         </li>
         <li class="calibre9" id="c12-li-0008">
          How to write alias templates
         </li>
         <li class="calibre9" id="c12-li-0009">
          How to write function templates
         </li>
         <li class="calibre9" id="c12-li-0010">
          How to make function templates friends of class templates
         </li>
         <li class="calibre9" id="c12-li-0011">
          How to use the abbreviated function template syntax
         </li>
         <li class="calibre9" id="c12-li-0012">
          How to use variable templates
         </li>
         <li class="calibre9" id="c12-li-0013">
          What concepts are
         </li>
         <li class="calibre9" id="c12-li-0014">
          How to use concepts to type constrain
          <code class="calibre21">
           auto
          </code>
         </li>
         <li class="calibre9" id="c12-li-0015">
          How to use concepts to specify requirements for template type parameters
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c12-para-0002">
      <span aria-label="452" class="calibre20" epub:type="pagebreak" id="Page_452" role="doc-pagebreak">
      </span>
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c12-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-141">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p class="calibre25" id="c12-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c12-para-0005">
      C++ provides language support not only for object-oriented programming but also for
      <i class="calibre18">
       generic programming
      </i>
      . As discussed in
      <a class="calibre5" href="c06.xhtml">
       Chapter 6
      </a>
      , “Designing for Reuse,” the goal of generic programming is to write reusable code. The fundamental tools for generic programming in C++ are
      <i class="calibre18">
       templates
      </i>
      . Although not strictly an object-oriented feature, templates can be combined with object-oriented programming for powerful results. Using existing templates, such as those provided by the Standard Library, e.g.,
      <code class="calibre21">
       std::vector
      </code>
      ,
      <code class="calibre21">
       unique_ptr
      </code>
      , and so on, is usually straightforward. However, many programmers consider writing their own templates to be the most difficult part of C++ and, for that reason, tend to avoid writing them. However, as a professional C++ programmer, you need to know how to write class and function templates.
     </p>
     <p class="calibre13" id="c12-para-0006">
      This chapter provides the coding details for fulfilling the design principle of generality discussed in
      <a class="calibre5" href="c06.xhtml">
       Chapter 6
      </a>
      , while
      <a class="calibre5" href="c26.xhtml">
       Chapter 26
      </a>
      , “Advanced Templates,” delves into some of the more advanced template features.
     </p>
    </section>
    <section aria-labelledby="head-2-142" class="calibre2">
     <span class="calibre" id="c12-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-142">
      OVERVIEW OF TEMPLATES
     </h2>
     <p class="calibre13" id="c12-para-0007">
      The main programming unit in the procedural paradigm is the
      <i class="calibre18">
       procedure
      </i>
      or
      <i class="calibre18">
       function
      </i>
      . Functions are useful primarily because they allow you to write algorithms that are independent of specific values and can thus be reused for many different values. For example, the
      <code class="calibre21">
       sqrt()
      </code>
      function in C++ calculates the square root of a value supplied by the caller. A square root function that calculates only the square root of one number, such as the number four, would not be particularly useful! The
      <code class="calibre21">
       sqrt()
      </code>
      function is written in terms of a
      <i class="calibre18">
       parameter
      </i>
      , which is a stand-in for whatever value the caller passes. Computer scientists say that functions
      <i class="calibre18">
       parameterize
      </i>
      values.
     </p>
     <p class="calibre13" id="c12-para-0008">
      The object-oriented programming paradigm adds the concept of
      <i class="calibre18">
       objects
      </i>
      , which group related data and behaviors, but it does not change the way functions and member functions parameterize values.
     </p>
     <p class="calibre13" id="c12-para-0009">
      Templates take the concept of parameterization a step further to allow you to parameterize on
      <i class="calibre18">
       types
      </i>
      as well as
      <i class="calibre18">
       values
      </i>
      . Types in C++ include primitives such as
      <code class="calibre21">
       int
      </code>
      and
      <code class="calibre21">
       double
      </code>
      , as well as user-defined classes such as
      <code class="calibre21">
       SpreadsheetCell
      </code>
      and
      <code class="calibre21">
       CherryTree
      </code>
      . With templates, you can write code that is independent not only of the values it will be given, but also of the types of those values. For example, instead of writing separate stack classes to store
      <code class="calibre21">
       int
      </code>
      s,
      <code class="calibre21">
       Car
      </code>
      s, and
      <code class="calibre21">
       SpreadsheetCell
      </code>
      s, you can write one stack class template definition that can be used for any of those types.
     </p>
     <p class="calibre13" id="c12-para-0010">
      Although templates are an amazing language feature, templates in C++ can be syntactically confusing, and thus, many programmers avoid
      <i class="calibre18">
       writing
      </i>
      templates themselves. However, every
      <i class="calibre18">
       professional
      </i>
      C++ programmer needs to know how to write them, and every programmer at least needs to know how to
      <i class="calibre18">
       use
      </i>
      templates, because they are widely used by libraries, such as the C++ Standard Library.
     </p>
     <p class="calibre13" id="c12-para-0011">
      This chapter teaches you about template support in C++ with an emphasis on the aspects that arise in the Standard Library. Along the way, you will learn about some nifty features that you can employ in your programs aside from using the Standard Library.
     </p>
    </section>
    <span aria-label="453" class="calibre20" epub:type="pagebreak" id="Page_453" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-143" class="calibre2">
     <span class="calibre" id="c12-sec-0005">
     </span>
     <h2 class="calibre6" id="head-2-143">
      CLASS TEMPLATES
     </h2>
     <p class="calibre13" id="c12-para-0012">
      A
      <i class="calibre18">
       class template
      </i>
      defines a
      <i class="calibre18">
       blueprint
      </i>
      (= template) for a family of class definitions where the types of some of the variables, return types of member functions, and/or parameters to member functions are specified as template type parameters. Class templates are like construction blueprints. They allow the compiler to build (also known as
      <i class="calibre18">
       instantiate
      </i>
      ) concrete class definitions by replacing template type parameters with concrete types.
     </p>
     <p class="calibre13" id="c12-para-0013">
      Class templates are useful primarily for containers, or data structures, that store objects. You already used class templates often earlier in this book, e.g.,
      <code class="calibre21">
       std::vector
      </code>
      ,
      <code class="calibre21">
       unique_ptr
      </code>
      ,
      <code class="calibre21">
       string
      </code>
      , and so on. This section discusses how to write your own class templates by using a running example of a
      <code class="calibre21">
       Grid
      </code>
      container. To keep the examples reasonable in length and simple enough to illustrate specific points, different sections of the chapter add features to the
      <code class="calibre21">
       Grid
      </code>
      container that are not used in subsequent sections.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-263">
       Writing a Class Template
      </h3>
      <p class="calibre13" id="c12-para-0014">
       Suppose that you want a generic game board class that you can use as a chessboard, checkers board, tic-tac-toe board, or any other two-dimensional game board. To make it general-purpose, you should be able to store chess pieces, checkers pieces, tic-tac-toe pieces, or any type of game piece.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0007">
       </span>
       <h4 class="calibre29" id="head-4-217">
        Coding Without Templates
       </h4>
       <p class="calibre13">
        Without templates, the best approach to build a generic game board is to employ polymorphism to store generic
        <code class="calibre21">
         GamePiece
        </code>
        objects. Then, you could let the pieces for each game inherit from the
        <code class="calibre21">
         GamePiece
        </code>
        class. For example, in a chess game,
        <code class="calibre21">
         ChessPiece
        </code>
        would be a derived class of
        <code class="calibre21">
         GamePiece
        </code>
        . Through polymorphism, the
        <code class="calibre21">
         GameBoard
        </code>
        , written to store
        <code class="calibre21">
         GamePiece
        </code>
        s, could also store
        <code class="calibre21">
         ChessPiece
        </code>
        s. Because it should be possible to copy a
        <code class="calibre21">
         GameBoard
        </code>
        , the
        <code class="calibre21">
         GameBoard
        </code>
        needs to be able to copy
        <code class="calibre21">
         GamePiece
        </code>
        s. This implementation employs polymorphism, so one solution is to add a pure virtual
        <code class="calibre21">
         clone()
        </code>
        member function to the
        <code class="calibre21">
         GamePiece
        </code>
        base class, which derived classes must implement to return a copy of a concrete
        <code class="calibre21">
         GamePiece
        </code>
        . Here is the basic
        <code class="calibre21">
         GamePiece
        </code>
        interface:
       </p>
       <pre class="calibre26" id="c12-code-0001"><code class="calibre21">export class GamePiece</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜GamePiece() = default;</code>
<code class="calibre21">        virtual std::unique_ptr&lt;GamePiece&gt; clone() const = 0;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <code class="calibre21">
         GamePiece
        </code>
        is an abstract base class. Concrete classes, such as
        <code class="calibre21">
         ChessPiece
        </code>
        , derive from it and implement the
        <code class="calibre21">
         clone()
        </code>
        member function:
       </p>
       <pre class="calibre26" id="c12-code-0002"><code class="calibre21">class ChessPiece : public GamePiece</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        std::unique_ptr&lt;GamePiece&gt; clone() const override</code>
<code class="calibre21">        {</code>
<code class="calibre21">            <span class="color">// Call the copy constructor to copy this instance</span></code>
<code class="calibre21">            return std::make_unique&lt;ChessPiece&gt;(*this);</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="454" class="calibre20" epub:type="pagebreak" id="Page_454" role="doc-pagebreak">
        </span>
        A
        <code class="calibre21">
         GameBoard
        </code>
        represents a two-dimensional grid, so one option to store the
        <code class="calibre21">
         GamePiece
        </code>
        s in
        <code class="calibre21">
         GameBoard
        </code>
        could be a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         vector
        </code>
        s of
        <code class="calibre21">
         unique_ptr
        </code>
        s. However, that's not an optimal representation of the data, as the data will be fragmented in memory. It's better to store a linearized representation of the
        <code class="calibre21">
         GamePiece
        </code>
        s as a single
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         unique_ptr
        </code>
        s. Converting a two-dimensional coordinate, say
        <code class="calibre21">
         (x,y)
        </code>
        , to a one-dimensional location in the linearized representation is easily done using the formula
        <code class="calibre21">
         x+y*width
        </code>
        .
       </p>
       <pre class="calibre26" id="c12-code-0003"><code class="calibre21">export class GameBoard</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit GameBoard(std::size_t width = DefaultWidth,</code>
<code class="calibre21">            std::size_t height = DefaultHeight);</code>
<code class="calibre21">        GameBoard(const GameBoard&amp; src);   <span class="color">// copy constructor</span></code>
<code class="calibre21">        virtual ˜GameBoard() = default;    <span class="color">// virtual defaulted destructor</span></code>
<code class="calibre21">        GameBoard&amp; operator=(const GameBoard&amp; rhs); <span class="color">// assignment operator</span></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a move constructor and move assignment operator.</span></code>
<code class="calibre21">        GameBoard(GameBoard&amp;&amp; src) = default;</code>
<code class="calibre21">        GameBoard&amp; operator=(GameBoard&amp;&amp; src) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::unique_ptr&lt;GamePiece&gt;&amp; at(std::size_t x, std::size_t y);</code>
<code class="calibre21">        const std::unique_ptr&lt;GamePiece&gt;&amp; at(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::size_t getHeight() const { return m_height; }</code>
<code class="calibre21">        std::size_t getWidth() const { return m_width; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        static constexpr std::size_t DefaultWidth { 10 };</code>
<code class="calibre21">        static constexpr std::size_t DefaultHeight { 10 };</code>
<code class="calibre21"> </code>
<code class="calibre21">        void swap(GameBoard&amp; other) noexcept;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void verifyCoordinate(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::vector&lt;std::unique_ptr&lt;GamePiece&gt;&gt; m_cells; </code>
<code class="calibre21">        std::size_t m_width { 0 }, m_height { 0 };</code>
<code class="calibre21">};</code>
<code class="calibre21">export void swap(GameBoard&amp; first, GameBoard&amp; second) noexcept;</code></pre>
       <p class="calibre13">
        In this implementation,
        <code class="calibre21">
         at()
        </code>
        returns a reference to the game piece at a given location instead of a copy of the piece.
        <code class="calibre21">
         GameBoard
        </code>
        serves as an abstraction of a two-dimensional array, so it should provide array access semantics by returning a reference to the actual object at any location, not a copy of the object. Client code should not store this reference for future use because it might become invalid, for example when the
        <code class="calibre21">
         m_cells vector
        </code>
        needs to be resized. Instead, client code shall call
        <code class="calibre21">
         at()
        </code>
        right before using the returned reference. This follows the design philosophy of the Standard Library
        <code class="calibre21">
         vector
        </code>
        class.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c12-para-0019">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            This implementation provides two versions of
           </i>
           <code class="calibre21">
            at()
           </code>
           <i class="calibre18">
            ; one returns a reference-to-non-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            while the other returns a reference-to-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        <span aria-label="455" class="calibre20" epub:type="pagebreak" id="Page_455" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c12-para-0020">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Starting with C++23, it is possible to provide a multidimensional subscripting operator for the
           </i>
           <code class="calibre21">
            GameBoard
           </code>
           <i class="calibre18">
            class. By providing such an operator, clients can write
           </i>
           <code class="calibre21">
            myGameBoard[x,y]
           </code>
           <i class="calibre18">
            instead of
           </i>
           <code class="calibre21">
            myGameBoard.at(x,y)
           </code>
           <i class="calibre18">
            to get access to a piece at location
           </i>
           <code class="calibre21">
            (x,y)
           </code>
           <i class="calibre18">
            . This operator is discussed in
           </i>
           <a class="calibre5" href="c15.xhtml">
            <i class="calibre18">
             Chapter
            </i>
            15
           </a>
           <i class="calibre18">
            , “Overloading C++ Operators.”
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Here are the member function definitions. Note that this implementation uses the copy-and-swap idiom for the assignment operator, and Scott Meyers’
        <code class="calibre21">
         const_cast()
        </code>
        pattern to avoid code duplication, both of which are discussed in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        , “Mastering Classes and Objects.”
       </p>
       <pre class="calibre26" id="c12-code-0004"><code class="calibre21">GameBoard::GameBoard(size_t width, size_t height)</code>
<code class="calibre21">    : m_width { width }, m_height { height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_cells.resize(m_width * m_height);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">GameBoard::GameBoard(const GameBoard&amp; src)</code>
<code class="calibre21">    : GameBoard { src.m_width, src.m_height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// The ctor-initializer of this constructor delegates first to the</span></code>
<code class="calibre21">    <span class="color">// non-copy constructor to allocate the proper amount of memory.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// The next step is to copy the data.</span></code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_cells.size(); ++i) {</code>
<code class="calibre21">        if (src.m_cells[i]) {</code>
<code class="calibre21">            m_cells[i] = src.m_cells[i]-&gt;clone();</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void GameBoard::verifyCoordinate(size_t x, size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x&gt;= m_width) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("x ({}) must be less than width ({}).", x, m_width) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    if (y&gt;= m_height) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("y ({}) must be less than height ({}).", y, m_height) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void GameBoard::swap(GameBoard&amp; other) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::swap(m_width, other.m_width);</code>
<code class="calibre21">    std::swap(m_height, other.m_height);</code>
<code class="calibre21">    std::swap(m_cells, other.m_cells);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="456" class="calibre20" epub:type="pagebreak" id="Page_456" role="doc-pagebreak"></span><code class="calibre21">void swap(GameBoard&amp; first, GameBoard&amp; second) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    first.swap(second);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">GameBoard&amp; GameBoard::operator=(const GameBoard&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Copy-and-swap idiom</span></code>
<code class="calibre21">    GameBoard temp { rhs }; <span class="color">// Do all the work in a temporary instance.</span></code>
<code class="calibre21">    swap(temp);             <span class="color">// Commit the work with only non-throwing operations.</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">const unique_ptr&lt;GamePiece&gt;&amp; GameBoard::at(size_t x, size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x + y * m_width];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">unique_ptr&lt;GamePiece&gt;&amp; GameBoard::at(size_t x, size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return const_cast&lt;unique_ptr&lt;GamePiece&gt;&amp;&gt;(as_const(*this).at(x, y));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        This
        <code class="calibre21">
         GameBoard
        </code>
        class works pretty well:
       </p>
       <pre class="calibre26" id="c12-code-0005"><code class="calibre21">GameBoard chessBoard { 8, 8 };</code>
<code class="calibre21">auto pawn { std::make_unique&lt;ChessPiece&gt;() };</code>
<code class="calibre21">chessBoard.at(0, 0) = std::move(pawn);</code>
<code class="calibre21">chessBoard.at(0, 1) = std::make_unique&lt;ChessPiece&gt;();</code>
<code class="calibre21">chessBoard.at(0, 1) = nullptr;</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0010">
       </span>
       <h4 class="calibre29" id="head-4-218">
        A Template Grid Class
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         GameBoard
        </code>
        class in the previous section is nice but insufficient. One problem is that you cannot use
        <code class="calibre21">
         GameBoard
        </code>
        to store elements by value; it always stores pointers. Another, more serious issue is related to type safety. Each cell in a
        <code class="calibre21">
         GameBoard
        </code>
        stores a
        <code class="calibre21">
         unique_ptr&lt;GamePiece&gt;
        </code>
        . Even if you are storing
        <code class="calibre21">
         ChessPiece
        </code>
        s, when you use
        <code class="calibre21">
         at()
        </code>
        to request a certain piece, you will get back a
        <code class="calibre21">
         unique_ptr&lt;GamePiece&gt;
        </code>
        . This means you have to downcast the retrieved
        <code class="calibre21">
         GamePiece
        </code>
        to a
        <code class="calibre21">
         ChessPiece
        </code>
        to be able to make use of
        <code class="calibre21">
         ChessPiece
        </code>
        's specific functionality. Additionally, nothing stops you from mixing all kinds of different
        <code class="calibre21">
         GamePiece
        </code>
        -derived objects in a
        <code class="calibre21">
         GameBoard
        </code>
        . For example, suppose there is not only a
        <code class="calibre21">
         ChessPiece
        </code>
        but also a
        <code class="calibre21">
         TicTacToePiece
        </code>
        :
       </p>
       <pre class="calibre26" id="c12-code-0006"><code class="calibre21">class TicTacToePiece : public GamePiece</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        std::unique_ptr&lt;GamePiece&gt; clone() const override</code>
<code class="calibre21">        {</code>
<code class="calibre21">            <span class="color">// Call the copy constructor to copy this instance</span></code>
<code class="calibre21">            return std::make_unique&lt;TicTacToePiece&gt;(*this);</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="457" class="calibre20" epub:type="pagebreak" id="Page_457" role="doc-pagebreak">
        </span>
        With the polymorphic solution from the previous section, nothing stops you from storing tic-tac-toe pieces and chess pieces on a single game board:
       </p>
       <pre class="calibre26" id="c12-code-0007"><code class="calibre21">GameBoard gameBoard { 8, 8 };</code>
<code class="calibre21">gameBoard.at(0, 0) = std::make_unique&lt;<b class="calibre14">ChessPiece</b>&gt;();</code>
<code class="calibre21">gameBoard.at(0, 1) = std::make_unique&lt;<b class="calibre14">TicTacToePiece</b>&gt;();</code></pre>
       <p class="calibre13" id="c12-para-0025">
        The big problem with this is that you somehow need to remember what is stored at a certain location so that you can perform the correct downcast when you call
        <code class="calibre21">
         at()
        </code>
        .
       </p>
       <p class="calibre13" id="c12-para-0026">
        Another shortcoming of
        <code class="calibre21">
         GameBoard
        </code>
        is that it cannot be used to store primitive types, such as
        <code class="calibre21">
         int
        </code>
        or
        <code class="calibre21">
         double
        </code>
        , because the type stored in a cell must derive from
        <code class="calibre21">
         GamePiece
        </code>
        .
       </p>
       <p class="calibre13" id="c12-para-0027">
        It would be nice if you could write a generic
        <code class="calibre21">
         Grid
        </code>
        class that you could use for storing
        <code class="calibre21">
         ChessPiece
        </code>
        s,
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s,
        <code class="calibre21">
         int
        </code>
        s,
        <code class="calibre21">
         double
        </code>
        s, and so on. In C++, you can do this by writing a
        <i class="calibre18">
         class template
        </i>
        , which is a blueprint for class definitions. In a class template, not all types are known yet. Clients then
        <i class="calibre18">
         instantiate
        </i>
        the template by specifying the types they want to use. This is called
        <i class="calibre18">
         generic programming
        </i>
        . The biggest advantage of generic programming is type safety. The types used in instantiated class definitions and their member functions are concrete types, and not abstract base class types, as is the case with the polymorphic solution from the previous section.
       </p>
       <p class="calibre13" id="c12-para-0028">
        Let's start by looking at how such a
        <code class="calibre21">
         Grid
        </code>
        class template definition can be written.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0011">
        </span>
        <h5 class="calibre35" id="head-5-77">
         The Grid Class Template Definition
        </h5>
        <p class="calibre13">
         To understand class templates, it is helpful to examine the syntax. The following example shows how you can modify the
         <code class="calibre21">
          GameBoard
         </code>
         class to make a parametrized
         <code class="calibre21">
          Grid
         </code>
         class template. The syntax is explained in detail following the code. Note that the name has changed from
         <code class="calibre21">
          GameBoard
         </code>
         to
         <code class="calibre21">
          Grid
         </code>
         . A
         <code class="calibre21">
          Grid
         </code>
         should also be usable with primitive types such as
         <code class="calibre21">
          int
         </code>
         and
         <code class="calibre21">
          double
         </code>
         . That's why I opted to implement this solution using value semantics without polymorphism, compared to the polymorphic pointer semantics used in the
         <code class="calibre21">
          GameBoard
         </code>
         implementation. The
         <code class="calibre21">
          m_cells
         </code>
         container stores actual objects, instead of pointers. A downside of using value semantics compared to pointer semantics is that you cannot have a true empty cell; that is, a cell must always contain some value. With pointer semantics, an empty cell stores
         <code class="calibre21">
          nullptr
         </code>
         . Luckily,
         <code class="calibre21">
          std::optional
         </code>
         , introduced in
         <a class="calibre5" href="c01_split_000.xhtml">
          Chapter 1
         </a>
         , “A Crash Course in C++ and the Standard Library,” comes to the rescue here. It allows you to use value semantics, while still having a way to represent empty cells.
        </p>
        <pre class="calibre26" id="c12-code-0008"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Grid(std::size_t width = DefaultWidth,</code>
<code class="calibre21">            std::size_t height = DefaultHeight);</code>
<code class="calibre21">        virtual ˜Grid() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a copy constructor and copy assignment operator.</span></code>
<code class="calibre21">        Grid(const Grid&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(const Grid&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a move constructor and move assignment operator.</span></code>
<code class="calibre21">        Grid(Grid&amp;&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(Grid&amp;&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<span aria-label="458" class="calibre20" epub:type="pagebreak" id="Page_458" role="doc-pagebreak"></span><code class="calibre21">        std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y);</code>
<code class="calibre21">        const std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::size_t getHeight() const { return m_height; }</code>
<code class="calibre21">        std::size_t getWidth() const { return m_width; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        static constexpr std::size_t DefaultWidth { 10 };</code>
<code class="calibre21">        static constexpr std::size_t DefaultHeight { 10 };</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void verifyCoordinate(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::vector&lt;std::optional&lt;T&gt;&gt; m_cells;</code>
<code class="calibre21">        std::size_t m_width { 0 }, m_height { 0 };</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Now that you've seen the full class template definition, take another look at it, starting with the first line.
        </p>
        <pre class="calibre26" id="c12-code-0009"><code class="calibre21">export template &lt;typename T&gt;</code></pre>
        <p class="calibre13">
         This first line says that the following class definition is a template on one type,
         <code class="calibre21">
          T
         </code>
         , and that it's being exported from the module. The “
         <code class="calibre21">
          template &lt;typename T&gt;
         </code>
         ” part is called the
         <i class="calibre18">
          template header
         </i>
         . Both
         <code class="calibre21">
          template
         </code>
         and
         <code class="calibre21">
          typename
         </code>
         are keywords in C++. As discussed earlier, templates “parameterize” types in the same way that functions “parameterize” values. Just as you use parameter names in functions to represent the arguments that the caller will pass, you use
         <i class="calibre18">
          template type parameter
         </i>
         names (such as
         <code class="calibre21">
          T
         </code>
         ) in templates to represent the types that the caller will pass as
         <i class="calibre18">
          template type arguments
         </i>
         . There's nothing special about the name
         <code class="calibre21">
          T
         </code>
         —you can use whatever name you want. Traditionally, when a single type is used, it is called
         <code class="calibre21">
          T
         </code>
         , but that's just a historical convention, like calling the integer that indexes an array
         <code class="calibre21">
          i
         </code>
         or
         <code class="calibre21">
          j
         </code>
         . The template specifier holds for the entire statement, which in this case is the class template definition.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c12-para-0032">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             For historical reasons, you can use the keyword
            </i>
            <code class="calibre21">
             class
            </code>
            <i class="calibre18">
             instead of
            </i>
            <code class="calibre21">
             typename
            </code>
            <i class="calibre18">
             to specify template type parameters. Thus, many books and existing programs use syntax like this:
            </i>
            <code class="calibre21">
             template &lt;class T&gt;
            </code>
            <i class="calibre18">
             . However, the use of the word class in this context is confusing because it implies that the type must be a class, which is not true. The type can be a class, a struct, a union, a primitive type of the language like
            </i>
            <code class="calibre21">
             int
            </code>
            <i class="calibre18">
             or
            </i>
            <code class="calibre21">
             double
            </code>
            <i class="calibre18">
             , and so on. To avoid such confusion, this book uses
            </i>
            <code class="calibre21">
             typename
            </code>
            <i class="calibre18">
             .
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         In the earlier
         <code class="calibre21">
          GameBoard
         </code>
         class, the
         <code class="calibre21">
          m_cells
         </code>
         data member is a
         <code class="calibre21">
          vector
         </code>
         of
         <i class="calibre18">
          pointers
         </i>
         , which requires special code for copying—thus the need for a copy constructor and copy assignment operator. In the
         <code class="calibre21">
          Grid
         </code>
         class,
         <code class="calibre21">
          m_cells
         </code>
         is a
         <code class="calibre21">
          vector
         </code>
         of optional
         <i class="calibre18">
          values
         </i>
         , so the compiler-generated copy constructor and assignment operator are fine. However, as explained in
         <a class="calibre5" href="c08.xhtml">
          Chapter 8
         </a>
         , “Gaining Proficiency with Classes and Objects,” once you have a user-declared destructor, it's deprecated for the compiler to implicitly generate a copy constructor or copy assignment operator, so the
         <code class="calibre21">
          Grid
         </code>
         class template explicitly defaults them. It also explicitly defaults the move constructor and move assignment operator. Here is the explicitly defaulted copy assignment operator:
        </p>
        <pre class="calibre26" id="c12-code-0010"><code class="calibre21">Grid&amp; operator=(const Grid&amp; rhs) = default;</code></pre>
        <p class="calibre13">
         <span aria-label="459" class="calibre20" epub:type="pagebreak" id="Page_459" role="doc-pagebreak">
         </span>
         As you can see, the type of the
         <code class="calibre21">
          rhs
         </code>
         parameter is no longer a
         <code class="calibre21">
          const GameBoard&amp;
         </code>
         , but a
         <code class="calibre21">
          const Grid&amp;
         </code>
         . Within a class definition, the compiler interprets
         <code class="calibre21">
          Grid
         </code>
         as
         <code class="calibre21">
          Grid&lt;T&gt;
         </code>
         where needed, but if you want, you can explicitly use
         <code class="calibre21">
          Grid&lt;T&gt;
         </code>
         :
        </p>
        <pre class="calibre26" id="c12-code-0011"><code class="calibre21">Grid<b class="calibre14">&lt;T&gt;</b>&amp; operator=(const Grid<b class="calibre14">&lt;T&gt;</b>&amp; rhs) = default;</code></pre>
        <p class="calibre13" id="c12-para-0035">
         However, outside a class definition you must use
         <code class="calibre21">
          Grid&lt;T&gt;
         </code>
         . When you write a class template, what you used to think of as the class name (
         <code class="calibre21">
          Grid
         </code>
         ) is actually the
         <i class="calibre18">
          template name
         </i>
         . When you want to talk about actual
         <code class="calibre21">
          Grid
         </code>
         classes or types, you have to use the
         <i class="calibre18">
          template ID
         </i>
         , i.e.,
         <code class="calibre21">
          Grid&lt;T&gt;
         </code>
         , which are
         <i class="calibre18">
          instantiations
         </i>
         of the
         <code class="calibre21">
          Grid
         </code>
         class template for a certain type, such as
         <code class="calibre21">
          int
         </code>
         ,
         <code class="calibre21">
          SpreadsheetCell
         </code>
         , or
         <code class="calibre21">
          ChessPiece
         </code>
         .
        </p>
        <p class="calibre13">
         Because
         <code class="calibre21">
          m_cells
         </code>
         is not storing pointers anymore, but optional values, the
         <code class="calibre21">
          at()
         </code>
         member functions now return
         <code class="calibre21">
          optional&lt;T&gt;
         </code>
         s instead of
         <code class="calibre21">
          unique_ptr
         </code>
         s, that is,
         <code class="calibre21">
          optional
         </code>
         s that can either have a value of type
         <code class="calibre21">
          T
         </code>
         , or be empty:
        </p>
        <pre class="calibre26" id="c12-code-0012"><code class="calibre21">std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y);</code>
<code class="calibre21">const std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y) const;</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0013">
        </span>
        <h5 class="calibre35" id="head-5-78">
         The Grid Class Template Member Function Definitions
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          template &lt;typename T&gt;
         </code>
         template header must precede each member function definition for the
         <code class="calibre21">
          Grid
         </code>
         class template. The constructor looks like this:
        </p>
        <pre class="calibre26" id="c12-code-0013"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">Grid&lt;T&gt;::Grid(std::size_t width, std::size_t height)</code>
<code class="calibre21">    : m_width { width }, m_height { height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_cells.resize(m_width * m_height);</code>
<code class="calibre21">}</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c12-para-0039">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Member function definitions of class templates need to be visible to any client code using the class template. This places some restrictions on where such member function definitions can be placed. Usually, they are simply put in the same file as the class template definition itself. Some ways around this restriction are discussed later in this chapter
            </i>
            .
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         Note that the name before the
         <code class="calibre21">
          ::
         </code>
         is
         <code class="calibre21">
          Grid&lt;T&gt;
         </code>
         , not
         <code class="calibre21">
          Grid
         </code>
         . The body of the constructor is identical to the
         <code class="calibre21">
          GameBoard
         </code>
         constructor. The rest of the member function definitions are also similar to their equivalents in the
         <code class="calibre21">
          GameBoard
         </code>
         class with the exception of the appropriate template header and
         <code class="calibre21">
          Grid&lt;T&gt;
         </code>
         syntax changes:
        </p>
        <pre class="calibre26" id="c12-code-0014"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void Grid&lt;T&gt;::verifyCoordinate(std::size_t x, std::size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x&gt;= m_width) {</code>
<code class="calibre21">        throw std::out_of_range {</code>
<code class="calibre21">            std::format("x ({}) must be less than width ({}).", x, m_width) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    if (y&gt;= m_height) {</code>
<code class="calibre21">        throw std::out_of_range {</code>
<span aria-label="460" class="calibre20" epub:type="pagebreak" id="Page_460" role="doc-pagebreak"></span><code class="calibre21">            std::format("y ({}) must be less than height ({}).", y, m_height) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">const std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::at(std::size_t x, std::size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x + y * m_width];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::at(std::size_t x, std::size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return const_cast&lt;std::optional&lt;T&gt;&amp;&gt;(std::as_const(*this).at(x, y));</code>
<code class="calibre21">}</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c12-para-0042">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             If an implementation of a class template member function needs a default value for a certain template type parameter, for example
            </i>
            <code class="calibre21">
             T
            </code>
            <i class="calibre18">
             , then you can use the
            </i>
            <code class="calibre21">
             T{}
            </code>
            <i class="calibre18">
             syntax.
            </i>
            <code class="calibre21">
             T{}
            </code>
            <i class="calibre18">
             calls the default constructor for the object if
            </i>
            <code class="calibre21">
             T
            </code>
            <i class="calibre18">
             is a class type, or generates zero if
            </i>
            <code class="calibre21">
             T
            </code>
            <i class="calibre18">
             is a primitive type. This syntax is called the zero-initialization syntax. It's a good way to provide a reasonable default value for a variable whose type you don't know yet.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-219">
        Using the Grid Template
       </h4>
       <p class="calibre13">
        When you want to create
        <code class="calibre21">
         Grid
        </code>
        objects, you cannot use
        <code class="calibre21">
         Grid
        </code>
        alone as a type; you must specify the type that is to be stored in that
        <code class="calibre21">
         Grid
        </code>
        . Creating concrete instances of class templates for specific types is called
        <i class="calibre18">
         template instantiation
        </i>
        . Here is an example:
       </p>
       <pre class="calibre26" id="c12-code-0015"><code class="calibre21">Grid&lt;int&gt; myIntGrid; <span class="color">// Declares a grid that stores ints,</span></code>
<code class="calibre21">                     <span class="color">// using default arguments for the constructor.</span></code>
<code class="calibre21">Grid&lt;double&gt; myDoubleGrid { 11, 11 }; <span class="color">// Declares an 11x11 Grid of doubles.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">myIntGrid.at(0, 0) = 10;</code>
<code class="calibre21">int x { myIntGrid.at(0, 0).value_or(0) };</code>
<code class="calibre21"> </code>
<code class="calibre21">Grid&lt;int&gt; grid2 { myIntGrid };  <span class="color">// Copy constructor</span></code>
<code class="calibre21">Grid&lt;int&gt; anotherIntGrid;</code>
<code class="calibre21">anotherIntGrid = grid2;         <span class="color">// Assignment operator</span></code></pre>
       <p class="calibre13" id="c12-para-0044">
        Note that the type of
        <code class="calibre21">
         myIntGrid
        </code>
        ,
        <code class="calibre21">
         grid2
        </code>
        , and
        <code class="calibre21">
         anotherIntGrid
        </code>
        is
        <code class="calibre21">
         Grid&lt;int&gt;
        </code>
        . You cannot store
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s or
        <code class="calibre21">
         ChessPiece
        </code>
        s in these grids; the compiler will generate an error if you try to do so.
       </p>
       <p class="calibre13" id="c12-para-0045">
        Note also the use of
        <code class="calibre21">
         value_or()
        </code>
        . The
        <code class="calibre21">
         at()
        </code>
        member functions return an
        <code class="calibre21">
         optional
        </code>
        reference, which can contain a value or not.
        <code class="calibre21">
         value_or()
        </code>
        returns the value inside the
        <code class="calibre21">
         optional
        </code>
        if there is a value; otherwise, it returns the argument given to
        <code class="calibre21">
         value_or()
        </code>
        .
       </p>
       <p class="calibre13">
        <span aria-label="461" class="calibre20" epub:type="pagebreak" id="Page_461" role="doc-pagebreak">
        </span>
        The type specification is important; neither of the following two lines compiles:
       </p>
       <pre class="calibre26" id="c12-code-0016"><code class="calibre21">Grid test;   <span class="color">// WILL NOT COMPILE</span></code>
<code class="calibre21">Grid&lt;&gt; test; <span class="color">// WILL NOT COMPILE</span></code></pre>
       <p class="calibre13" id="c12-para-0047">
        The first line causes the compiler to produce an error like “use of class template requires template argument list.” The second line causes an error like “too few template arguments.”
       </p>
       <p class="calibre13">
        If you want to declare a function that takes a
        <code class="calibre21">
         Grid
        </code>
        object, you must specify the type stored in that grid as part of the
        <code class="calibre21">
         Grid
        </code>
        type:
       </p>
       <pre class="calibre26" id="c12-code-0017"><code class="calibre21">void processIntGrid(Grid&lt;int&gt;&amp; grid) { <span class="color">/* Body omitted for brevity */</span> }</code></pre>
       <p class="calibre13" id="c12-para-0049">
        Alternatively, you can use function templates, discussed later in this chapter, to write a function parametrized on the type of the elements in the grid.
       </p>
       <p class="calibre13">
        The
        <code class="calibre21">
         Grid
        </code>
        class template can store more than just
        <code class="calibre21">
         int
        </code>
        s. For example, you can instantiate a
        <code class="calibre21">
         Grid
        </code>
        that stores
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s:
       </p>
       <pre class="calibre26" id="c12-code-0018"><code class="calibre21">Grid&lt;SpreadsheetCell&gt; mySpreadsheet;</code>
<code class="calibre21">SpreadsheetCell myCell { 1.234 };</code>
<code class="calibre21">mySpreadsheet.at(3, 4) = myCell;</code></pre>
       <p class="calibre13">
        You can store pointer types as well:
       </p>
       <pre class="calibre26" id="c12-code-0019"><code class="calibre21">Grid&lt;const char*&gt; myStringGrid;</code>
<code class="calibre21">myStringGrid.at(2, 2) = "hello";</code></pre>
       <p class="calibre13">
        The type specified can even be another template type:
       </p>
       <pre class="calibre26" id="c12-code-0020"><code class="calibre21">Grid&lt;vector&lt;int&gt;&gt; gridOfVectors;</code>
<code class="calibre21">vector&lt;int&gt; myVector { 1, 2, 3, 4 };</code>
<code class="calibre21">gridOfVectors.at(5, 6) = myVector;</code></pre>
       <p class="calibre13">
        You can also dynamically allocate
        <code class="calibre21">
         Grid
        </code>
        objects on the free store:
       </p>
       <pre class="calibre26" id="c12-code-0021"><code class="calibre21">auto myGridOnFreeStore { make_unique&lt;Grid&lt;int&gt;&gt;(2, 2) }; <span class="color">// 2x2 Grid on free store.</span></code>
<code class="calibre21">myGridOnFreeStore-&gt;at(0, 0) = 10;</code>
<code class="calibre21">int x { myGridOnFreeStore-&gt;at(0, 0).value_or(0) };</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-264">
       How the Compiler Processes Templates
      </h3>
      <p class="calibre13" id="c12-para-0054">
       To understand the intricacies of templates, you need to learn how the compiler processes template code. When the compiler encounters class template member function definitions, it performs syntax checking, but doesn't actually compile the templates. It can't compile template definitions because it doesn't know for which types they will be used. It's impossible for a compiler to generate code for something like
       <code class="calibre21">
        x = y
       </code>
       without knowing the types of
       <code class="calibre21">
        x
       </code>
       and
       <code class="calibre21">
        y
       </code>
       . This syntax-checking step is the first step in the
       <i class="calibre18">
        two-phase name lookup
       </i>
       process.
      </p>
      <p class="calibre13" id="c12-para-0055">
       The second step in the two-phase name lookup process happens when the compiler encounters an instantiation of the template, such as
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       . At that moment, the compiler writes code for an
       <code class="calibre21">
        int
       </code>
       version of the
       <code class="calibre21">
        Grid
       </code>
       template by replacing each
       <code class="calibre21">
        T
       </code>
       in the class template definition with
       <code class="calibre21">
        int
       </code>
       . When the compiler encounters a different instantiation of the template, such as
       <code class="calibre21">
        Grid&lt;SpreadsheetCell&gt;
       </code>
       , it writes another version of the
       <code class="calibre21">
        Grid
       </code>
       class for
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s. The compiler just writes the code
       <span aria-label="462" class="calibre20" epub:type="pagebreak" id="Page_462" role="doc-pagebreak">
       </span>
       that you would write if you didn't have template support in the language and had to write separate classes for each element type. There's no magic here; templates just automate an annoying process. If you don't instantiate a class template for any types in your program, then the class template member function definitions are never compiled.
      </p>
      <p class="calibre13" id="c12-para-0056">
       This instantiation process explains why you need to use the
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       syntax in various places in your definition. When the compiler instantiates the template for a particular type, such as
       <code class="calibre21">
        int
       </code>
       , it replaces
       <code class="calibre21">
        T
       </code>
       with
       <code class="calibre21">
        int
       </code>
       , so that
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       is the type.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0018">
       </span>
       <h4 class="calibre29" id="head-4-220">
        Selective/Implicit Instantiation
       </h4>
       <p class="calibre13">
        For
        <i class="calibre18">
         implicit class template instantiations
        </i>
        such as the following:
       </p>
       <pre class="calibre26" id="c12-code-0022"><code class="calibre21">Grid&lt;int&gt; myIntGrid;</code></pre>
       <p class="calibre13">
        the compiler always generates code for all
        <code class="calibre21">
         virtual
        </code>
        member functions of the class template. However, for non-
        <code class="calibre21">
         virtual
        </code>
        member functions, the compiler generates code only for those non-
        <code class="calibre21">
         virtual
        </code>
        member functions that are actually called. For example, given the earlier
        <code class="calibre21">
         Grid
        </code>
        class template, suppose that you write this code (and only this code) in
        <code class="calibre21">
         main()
        </code>
        :
       </p>
       <pre class="calibre26" id="c12-code-0023"><code class="calibre21">Grid&lt;int&gt; myIntGrid;</code>
<code class="calibre21">myIntGrid.at(0, 0) = 10;</code></pre>
       <p class="calibre13" id="c12-para-0059">
        The compiler generates only the zero-argument constructor, the destructor, and the non-
        <code class="calibre21">
         const at()
        </code>
        member function for an
        <code class="calibre21">
         int
        </code>
        version of
        <code class="calibre21">
         Grid
        </code>
        . It does not generate other member functions like the copy constructor, the assignment operator, or
        <code class="calibre21">
         getHeight()
        </code>
        . This is called
        <i class="calibre18">
         selective instantiation
        </i>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0019">
       </span>
       <h4 class="calibre29" id="head-4-221">
        Explicit Instantiation
       </h4>
       <p class="calibre13">
        The danger exists that there are compilation errors in some class template member functions that go unnoticed with implicit instantiations. Unused member functions of class templates can contain syntax errors, as these will not be compiled. This makes it hard to test all code for syntax errors. You can force the compiler to generate code for all member functions,
        <code class="calibre21">
         virtual
        </code>
        and non-
        <code class="calibre21">
         virtual
        </code>
        , by using
        <i class="calibre18">
         explicit template instantiations
        </i>
        . Here's an example:
       </p>
       <pre class="calibre26" id="c12-code-0024"><code class="calibre21">template class Grid&lt;string&gt;;</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c12-para-0062">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Explicit template instantiations help with finding errors, as they force all your class template member functions to be compiled even when unused
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c12-para-0063">
        When using explicit template instantiations, don't just try to instantiate the class template with basic types like
        <code class="calibre21">
         int
        </code>
        , but try it with more complicated types like
        <code class="calibre21">
         string
        </code>
        , if those are accepted by the class template.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0021">
       </span>
       <h4 class="calibre29" id="head-4-222">
        Template Requirements on Types
       </h4>
       <p class="calibre13" id="c12-para-0064">
        When you write code that is independent of types, you must assume certain things about those types. For example, in the
        <code class="calibre21">
         Grid
        </code>
        class template, you assume that the element type (represented by
        <code class="calibre21">
         T
        </code>
        ) is destructible, copy/move constructible, and copy/move assignable.
       </p>
       <p class="calibre13" id="c12-para-0065">
        <span aria-label="463" class="calibre20" epub:type="pagebreak" id="Page_463" role="doc-pagebreak">
        </span>
        When the compiler attempts to instantiate a template with types that do not support all the operations used by class template member functions that are called, the code will not compile, and the error messages will often be quite obscure. However, even if the types you want to use don't support the operations required by all the member functions of the class template, you can exploit selective instantiation to use some member functions but not others.
       </p>
       <p class="calibre13" id="c12-para-0066">
        You can use
        <i class="calibre18">
         concepts
        </i>
        to write requirements for template parameters that the compiler can interpret and validate. The compiler can generate more readable errors if the template arguments passed to instantiate a template do not satisfy these requirements. Concepts are discussed later in this chapter.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0022">
      </span>
      <h3 class="calibre27" id="head-3-265">
       Distributing Template Code Between Files
      </h3>
      <p class="calibre13" id="c12-para-0067">
       With class templates, both the class template definition and the member function definitions must be available to the compiler from any source file that uses them. There are several mechanisms to accomplish this.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0023">
       </span>
       <h4 class="calibre29" id="head-4-223">
        Member Function Definitions in Same File as Class Template Definition
       </h4>
       <p class="calibre13" id="c12-para-0068">
        You can place the member function definitions directly in the module interface file where you define the class template itself. When you import this module in another source file where you use the template, the compiler will have access to all the code it needs. This mechanism is used for the previous
        <code class="calibre21">
         Grid
        </code>
        implementation.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0024">
       </span>
       <h4 class="calibre29" id="head-4-224">
        Member Function Definitions in Separate File
       </h4>
       <p class="calibre13">
        Alternatively, you can place the class template member function definitions in a separate module interface partition file. You then also need to put the class template definition in its own module interface partition. For example, the primary module interface file for the
        <code class="calibre21">
         Grid
        </code>
        class template could look like this:
       </p>
       <pre class="calibre26" id="c12-code-0025"><code class="calibre21">export module grid;</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">export import :definition;</b></code>
<code class="calibre21"><b class="calibre14">export import :implementation;</b></code></pre>
       <p class="calibre13">
        This imports and exports two module interface partitions:
        <code class="calibre21">
         definition
        </code>
        and
        <code class="calibre21">
         implementation
        </code>
        . The class template definition is defined in the
        <code class="calibre21">
         definition
        </code>
        partition:
       </p>
       <pre class="calibre26" id="c12-code-0026"><code class="calibre21"><b class="calibre14">export module grid:definition;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">export template &lt;typename T&gt; class Grid { … };</code></pre>
       <p class="calibre13">
        The implementations of the member functions are in the
        <code class="calibre21">
         implementation
        </code>
        partition, which also needs to import the
        <code class="calibre21">
         definition
        </code>
        partition because it needs the
        <code class="calibre21">
         Grid
        </code>
        class template definition:
       </p>
       <pre class="calibre26" id="c12-code-0027"><code class="calibre21"><b class="calibre14">export module grid:implementation;</b></code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">import :definition;</b></code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<span aria-label="464" class="calibre20" epub:type="pagebreak" id="Page_464" role="doc-pagebreak"></span><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">Grid&lt;T&gt;::Grid(std::size_t width, std::size_t height)</code>
<code class="calibre21">    : m_width { width }, m_height { height }</code>
<code class="calibre21">{ <span class="color">/* … */</span> }</code>
<code class="calibre21"><span class="color">// Remainder omitted for brevity.</span></code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0025">
      </span>
      <h3 class="calibre27" id="head-3-266">
       Template Parameters
      </h3>
      <p class="calibre13">
       In the
       <code class="calibre21">
        Grid
       </code>
       example, the
       <code class="calibre21">
        Grid
       </code>
       class template has one
       <i class="calibre18">
        template parameter
       </i>
       : the type that is stored in the grid. When you write the class template, you specify the parameter list inside the angle brackets, like this:
      </p>
      <pre class="calibre26" id="c12-code-0028"><code class="calibre21">template &lt;typename T&gt;</code></pre>
      <p class="calibre13" id="c12-para-0073">
       This parameter list is similar to the parameter list of functions. As with functions, you can write a class template with as many template parameters as you want. Additionally, these parameters don't have to be types, and they can have default values.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0026">
       </span>
       <h4 class="calibre29" id="head-4-225">
        Non-type Template Parameters
       </h4>
       <p class="calibre13" id="c12-para-0074">
        Non-type template parameters are “normal” parameters such as
        <code class="calibre21">
         int
        </code>
        s and pointers—the kind of parameters which you're familiar with from functions. However, non-type template parameters can only be integral types (
        <code class="calibre21">
         char
        </code>
        ,
        <code class="calibre21">
         int
        </code>
        ,
        <code class="calibre21">
         long
        </code>
        , and so on), enumerations, pointers, references,
        <code class="calibre21">
         std::nullptr_t
        </code>
        ,
        <code class="calibre21">
         auto
        </code>
        ,
        <code class="calibre21">
         auto&amp;
        </code>
        ,
        <code class="calibre21">
         auto*
        </code>
        , floating-point types, and class types. The latter, however, come with a lot of limitations, not further discussed in this text. Remember that templates are instantiated at compile time; hence, arguments for non-type template parameters are evaluated at compile time. That means such arguments must be literals or compile-time constants.
       </p>
       <p class="calibre13">
        In the
        <code class="calibre21">
         Grid
        </code>
        class template, you could use non-type template parameters to specify the height and width of the grid instead of specifying them in the constructor. The principal advantage of using non-type template parameters instead of constructor parameters is that the values are known before the code is compiled. Recall that the compiler generates code for template instantiations by substituting the template parameters before compiling. Thus, you can use a normal two-dimensional array in the following implementation instead of a linearized representation using a
        <code class="calibre21">
         vector
        </code>
        that is dynamically resized. Here is the new class template definition with the changes highlighted:
       </p>
       <pre class="calibre26" id="c12-code-0029"><code class="calibre21"><b class="calibre14">export template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</b></code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Grid() = default;</b></code>
<code class="calibre21">        virtual ˜Grid() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a copy constructor and copy assignment operator.</span></code>
<code class="calibre21">        Grid(const Grid&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(const Grid&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a move constructor and move assignment operator.</span></code>
<code class="calibre21">        Grid(Grid&amp;&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(Grid&amp;&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y);</code>
<span aria-label="465" class="calibre20" epub:type="pagebreak" id="Page_465" role="doc-pagebreak"></span><code class="calibre21">        const std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">std::size_t getHeight() const { return HEIGHT; }</b></code>
<code class="calibre21">        <b class="calibre14">std::size_t getWidth() const { return WIDTH; }</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void verifyCoordinate(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">std::optional&lt;T&gt; m_cells[WIDTH][HEIGHT];</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        The template parameter list now has three parameters: the type of objects stored in the grid, and the width and height of the grid. The width and height are used to create a two-dimensional array to store the objects. Here are the class template member function definitions:
       </p>
       <pre class="calibre26" id="c12-code-0030"><code class="calibre21"><b class="calibre14">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</b></code>
<code class="calibre21"><b class="calibre14">void Grid&lt;T, WIDTH, HEIGHT&gt;::verifyCoordinate(std::size_t x, std::size_t y) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">if (x &gt;= WIDTH) {</b></code>
<code class="calibre21">        throw std::out_of_range {</code>
<code class="calibre21">            std::format("x ({}) must be less than width ({}).", x, <b class="calibre14">WIDTH</b>) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <b class="calibre14">if (y &gt;= HEIGHT) {</b></code>
<code class="calibre21">        throw std::out_of_range {</code>
<code class="calibre21">            std::format("y ({}) must be less than height ({}).", y, <b class="calibre14">HEIGHT</b>) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</b></code>
<code class="calibre21"><b class="calibre14">const std::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(</b></code>
<code class="calibre21">    <b class="calibre14">std::size_t x, std::size_t y) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</b></code>
<code class="calibre21"><b class="calibre14">std::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(std::size_t x, std::size_t y)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return const_cast&lt;std::optional&lt;T&gt;&amp;&gt;(std::as_const(*this).at(x, y));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c12-para-0077">
        Note that wherever you previously specified
        <code class="calibre21">
         Grid&lt;T&gt;
        </code>
        you must now specify
        <code class="calibre21">
         Grid&lt;T,WIDTH,HEIGHT&gt;
        </code>
        to specify the three template parameters.
       </p>
       <p class="calibre13">
        You can instantiate this template and use it as follows:
       </p>
       <pre class="calibre26" id="c12-code-0031"><code class="calibre21">Grid&lt;int, 10, 10&gt; myGrid;</code>
<code class="calibre21">Grid&lt;int, 10, 10&gt; anotherGrid;</code>
<code class="calibre21">myGrid.at(2, 3) = 42;</code>
<code class="calibre21">anotherGrid = myGrid;</code>
<code class="calibre21">println("{}", anotherGrid.at(2, 3).value_or(0));</code></pre>
       <p class="calibre13">
        <span aria-label="466" class="calibre20" epub:type="pagebreak" id="Page_466" role="doc-pagebreak">
        </span>
        This code seems great, but unfortunately, there are more restrictions than you might initially expect. First, you can't use a non-constant integer to specify the height or width. The following code doesn't compile:
       </p>
       <pre class="calibre26" id="c12-code-0032"><code class="calibre21">size_t height { 10 };</code>
<code class="calibre21">Grid&lt;int, 10, height&gt; testGrid; <span class="color">// DOES NOT COMPILE</span></code></pre>
       <p class="calibre13">
        If you define
        <code class="calibre21">
         height
        </code>
        as a constant, it compiles:
       </p>
       <pre class="calibre26" id="c12-code-0033"><code class="calibre21">const size_t height { 10 };</code>
<code class="calibre21">Grid&lt;int, 10, height&gt; testGrid; <span class="color">// Compiles and works</span></code></pre>
       <p class="calibre13">
        <code class="calibre21">
         constexpr
        </code>
        functions with the correct return type also work. For example, if you have a
        <code class="calibre21">
         constexpr
        </code>
        function returning a
        <code class="calibre21">
         size_t
        </code>
        , you can use it to initialize the height template parameter:
       </p>
       <pre class="calibre26" id="c12-code-0034"><code class="calibre21">constexpr size_t getHeight() { return 10; }</code>
<code class="calibre21">…</code>
<code class="calibre21">Grid&lt;double, 2, getHeight()&gt; myDoubleGrid;</code></pre>
       <p class="calibre13">
        A second restriction might be more significant. Now that the width and height are template parameters, they are part of the type of each grid. That means
        <code class="calibre21">
         Grid&lt;int,10,10&gt;
        </code>
        and
        <code class="calibre21">
         Grid&lt;int,10,11&gt;
        </code>
        are two different types. You can't assign an object of one type to an object of the other, and variables of one type can't be passed to functions that expect variables of another type.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c12-para-0083">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Non-type template parameters become part of the type specification of instantiated objects
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0028">
       </span>
       <h4 class="calibre29" id="head-4-226">
        Default Values for Template Parameters
       </h4>
       <p class="calibre13">
        If you continue the approach of making height and width template parameters, you might want to provide defaults for the height and width non-type template parameters just as you did previously in the constructor of the
        <code class="calibre21">
         Grid&lt;T&gt;
        </code>
        class template. C++ allows you to provide defaults for template parameters with a similar syntax. While you are at it, you could also provide a default for the
        <code class="calibre21">
         T
        </code>
        type parameter. Here is the class definition:
       </p>
       <pre class="calibre26" id="c12-code-0035"><code class="calibre21"><b class="calibre14">export template &lt;typename T = int, std::size_t WIDTH = 10, std::size_t HEIGHT = 10&gt;</b></code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Remainder is identical to the previous version</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        You don't specify the default values for
        <code class="calibre21">
         T
        </code>
        ,
        <code class="calibre21">
         WIDTH
        </code>
        , and
        <code class="calibre21">
         HEIGHT
        </code>
        in the template header for the member function definitions. For example, here is the implementation of
        <code class="calibre21">
         at()
        </code>
        :
       </p>
       <pre class="calibre26" id="c12-code-0036"><code class="calibre21">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</code>
<code class="calibre21">const std::optional&lt;T&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::at(</code>
<code class="calibre21">    std::size_t x, std::size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="467" class="calibre20" epub:type="pagebreak" id="Page_467" role="doc-pagebreak">
        </span>
        With these changes, you can instantiate a
        <code class="calibre21">
         Grid
        </code>
        without any template parameters, with only the element type, the element type and the width, or the element type, width, and height:
       </p>
       <pre class="calibre26" id="c12-code-0037"><code class="calibre21">Grid&lt;&gt; myIntGrid;</code>
<code class="calibre21">Grid&lt;int&gt; myGrid;</code>
<code class="calibre21">Grid&lt;int, 5&gt; anotherGrid;</code>
<code class="calibre21">Grid&lt;int, 5, 5&gt; aFourthGrid;</code></pre>
       <p class="calibre13">
        Note that if you don't specify any class template parameters, you still need to specify an empty set of angle brackets. For example, the following does not compile!
       </p>
       <pre class="calibre26" id="c12-code-0038"><code class="calibre21">Grid myIntGrid;</code></pre>
       <p class="calibre13" id="c12-para-0088">
        The rules for default arguments in class template parameter lists are the same as for functions; that is, you can provide defaults for parameters in order starting from the right.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0029">
       </span>
       <h4 class="calibre29" id="head-4-227">
        Class Template Argument Deduction
       </h4>
       <p class="calibre13" id="c12-para-0089">
        With class template argument deduction, the compiler can automatically deduce the template type parameters from the arguments passed to a class template constructor.
       </p>
       <p class="calibre13">
        For example, the Standard Library has a class template called
        <code class="calibre21">
         std::pair
        </code>
        , defined in
        <code class="calibre21">
         &lt;utility&gt;
        </code>
        and introduced in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        . A
        <code class="calibre21">
         pair
        </code>
        stores exactly two values of two possibly different types, which you normally would have to specify as the template type parameters. Here's an example:
       </p>
       <pre class="calibre26" id="c12-code-0039"><code class="calibre21">pair&lt;int, double&gt; pair1 { 1, 2.3 };</code></pre>
       <p class="calibre13">
        To avoid having to write the template type parameters explicitly, a helper function template called
        <code class="calibre21">
         std::make_pair()
        </code>
        is available. Details of writing your own function templates are discussed later in this chapter. Function templates have always supported the automatic deduction of template type parameters based on the arguments passed to the function template. Thus,
        <code class="calibre21">
         make_pair()
        </code>
        is capable of automatically deducing the template type parameters based on the values passed to it. For example, the compiler deduces
        <code class="calibre21">
         pair&lt;int, double&gt;
        </code>
        for the following call:
       </p>
       <pre class="calibre26" id="c12-code-0040"><code class="calibre21">auto pair2 { make_pair(1, 2.3) };</code></pre>
       <p class="calibre13">
        With class template argument deduction (CTAD), such helper function templates are no longer necessary. The compiler now automatically deduces the template type parameters based on the arguments passed to a constructor. For the
        <code class="calibre21">
         pair
        </code>
        class template, you can simply write the following code:
       </p>
       <pre class="calibre26" id="c12-code-0041"><code class="calibre21">pair pair3 { 1, 2.3 };  <span class="color">// pair3 has type pair&lt;int, double&gt;</span></code></pre>
       <p class="calibre13" id="c12-para-0093">
        Of course, this works only when all template type parameters of a class template either have default values or are used as parameters in the constructor so that they can be deduced.
       </p>
       <p class="calibre13">
        Note that an initializer is required for CTAD to work. The following is illegal:
       </p>
       <pre class="calibre26" id="c12-code-0042"><code class="calibre21">pair pair4;</code></pre>
       <p class="calibre13">
        A lot of the Standard Library classes support CTAD, for example,
        <code class="calibre21">
         vector
        </code>
        ,
        <code class="calibre21">
         array
        </code>
        , and so on.
        <span aria-label="468" class="calibre20" epub:type="pagebreak" id="Page_468" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c12-para-0096">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            This type deduction is disabled for
           </i>
           <code class="calibre21">
            std::unique_ptr
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            shared_ptr
           </code>
           <i class="calibre18">
            . You pass a
           </i>
           <code class="calibre21">
            T*
           </code>
           <i class="calibre18">
            to their constructors, which means that the compiler would have to choose between deducing
           </i>
           <code class="calibre21">
            &lt;T&gt;
           </code>
           <i class="calibre18">
            or
           </i>
           <code class="calibre21">
            &lt;T[]&gt;
           </code>
           <i class="calibre18">
            , a dangerous choice to get wrong. So, just remember that for
           </i>
           <code class="calibre21">
            unique_ptr
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            shared_ptr
           </code>
           <i class="calibre18">
            , you need to keep using
           </i>
           <code class="calibre21">
            make_unique()
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            make_shared()
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0031">
        </span>
        <h5 class="calibre35" id="head-5-79">
         User-Defined Deduction Guides
        </h5>
        <p class="calibre13" id="c12-para-0097">
         You can also write your own user-defined
         <i class="calibre18">
          deduction guides
         </i>
         to help the compiler. These allow you to write rules for how the template type parameters have to be deduced. The following is an example demonstrating their use.
        </p>
        <p class="calibre13">
         Suppose you have this
         <code class="calibre21">
          SpreadsheetCell
         </code>
         class template:
        </p>
        <pre class="calibre26" id="c12-code-0043"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit SpreadsheetCell(T t) : m_content { move(t) } { }</code>
<code class="calibre21">        const T&amp; getContent() const { return m_content; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        T m_content;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Thanks to CTAD, you can create a
         <code class="calibre21">
          SpreadsheetCell
         </code>
         with an
         <code class="calibre21">
          std::string
         </code>
         type. The deduced type is
         <code class="calibre21">
          SpreadsheetCell&lt;string&gt;
         </code>
         :
        </p>
        <pre class="calibre26" id="c12-code-0044"><code class="calibre21">string myString { "Hello World!" };</code>
<code class="calibre21">SpreadsheetCell cell { myString };</code></pre>
        <p class="calibre13">
         However, if you pass a
         <code class="calibre21">
          const char*
         </code>
         to the
         <code class="calibre21">
          SpreadsheetCell
         </code>
         constructor, then type
         <code class="calibre21">
          T
         </code>
         is deduced as
         <code class="calibre21">
          const char*
         </code>
         , which is not what you want! You can create the following user-defined deduction guide to make sure
         <code class="calibre21">
          T
         </code>
         is deduced as
         <code class="calibre21">
          std::string
         </code>
         when passing a
         <code class="calibre21">
          const char*
         </code>
         as argument to the constructor:
        </p>
        <pre class="calibre26" id="c12-code-0045"><code class="calibre21">SpreadsheetCell(const char*) -&gt; SpreadsheetCell&lt;std::string&gt;;</code></pre>
        <p class="calibre13" id="c12-para-0101">
         This guide has to be defined outside the class definition but inside the same namespace as the
         <code class="calibre21">
          SpreadsheetCell
         </code>
         class.
        </p>
        <p class="calibre13">
         The general syntax is as follows. The
         <code class="calibre21">
          explicit
         </code>
         keyword is optional and behaves the same as
         <code class="calibre21">
          explicit
         </code>
         for constructors. Such deduction guides are, more often than not, templates as well.
        </p>
        <pre class="calibre26" id="c12-code-0046"><code class="calibre21">template &lt;…&gt;</code>
<code class="calibre21">explicit <i class="calibre18">TemplateName</i>(<i class="calibre18">Parameters</i>) -&gt; <i class="calibre18">DeducedTemplate</i>&lt;…&gt;;</code></pre>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0032">
      </span>
      <h3 class="calibre27" id="head-3-267">
       Member Function Templates
      </h3>
      <p class="calibre13">
       C++ allows you to parametrize individual member functions of a class. Such member functions are called
       <i class="calibre18">
        member function templates
       </i>
       and can be inside a normal class or in a class template. When you
       <span aria-label="469" class="calibre20" epub:type="pagebreak" id="Page_469" role="doc-pagebreak">
       </span>
       write a member function template, you are actually writing many different versions of that member function for many different types. Member function templates are useful for assignment operators and copy constructors in class templates.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0104">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Virtual member functions and destructors cannot be member function templates
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Consider the original
       <code class="calibre21">
        Grid
       </code>
       template with only one template parameter: the element type. You can instantiate grids of many different types, such as
       <code class="calibre21">
        int
       </code>
       s and
       <code class="calibre21">
        double
       </code>
       s:
      </p>
      <pre class="calibre26" id="c12-code-0047"><code class="calibre21">Grid&lt;int&gt; myIntGrid;</code>
<code class="calibre21">Grid&lt;double&gt; myDoubleGrid;</code></pre>
      <p class="calibre13">
       However,
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       and
       <code class="calibre21">
        Grid&lt;double&gt;
       </code>
       are two different types. If you write a function that takes an object of type
       <code class="calibre21">
        Grid&lt;double&gt;
       </code>
       , you cannot pass a
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       . Even though you know that the elements of an
       <code class="calibre21">
        int
       </code>
       grid could be copied to the elements of a
       <code class="calibre21">
        double
       </code>
       grid, because
       <code class="calibre21">
        int
       </code>
       s can be converted into
       <code class="calibre21">
        double
       </code>
       s, you cannot assign an object of type
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       to one of type
       <code class="calibre21">
        Grid&lt;double&gt;
       </code>
       or construct a
       <code class="calibre21">
        Grid&lt;double&gt;
       </code>
       from a
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       . Neither of the following two lines compiles:
      </p>
      <pre class="calibre26" id="c12-code-0048"><code class="calibre21">myDoubleGrid = myIntGrid;                 <span class="color">// DOES NOT COMPILE</span></code>
<code class="calibre21">Grid&lt;double&gt; newDoubleGrid { myIntGrid }; <span class="color">// DOES NOT COMPILE</span></code></pre>
      <p class="calibre13">
       The problem is that the copy constructor and assignment operator for the
       <code class="calibre21">
        Grid
       </code>
       template are as follows:
      </p>
      <pre class="calibre26" id="c12-code-0049"><code class="calibre21">Grid(const Grid&amp; src);</code>
<code class="calibre21">Grid&amp; operator=(const Grid&amp; rhs);</code></pre>
      <p class="calibre13">
       which are equivalent to:
      </p>
      <pre class="calibre26" id="c12-code-0050"><code class="calibre21">Grid(const Grid&lt;T&gt;&amp; src);</code>
<code class="calibre21">Grid&lt;T&gt;&amp; operator=(const Grid&lt;T&gt;&amp; rhs);</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        Grid
       </code>
       copy constructor and
       <code class="calibre21">
        operator=
       </code>
       both take a reference to a
       <code class="calibre21">
        const Grid&lt;T&gt;
       </code>
       . When you instantiate a
       <code class="calibre21">
        Grid&lt;double&gt;
       </code>
       and try to call the copy constructor and
       <code class="calibre21">
        operator=
       </code>
       , the compiler generates member functions with these prototypes:
      </p>
      <pre class="calibre26" id="c12-code-0051"><code class="calibre21">Grid(const Grid&lt;double&gt;&amp; src);</code>
<code class="calibre21">Grid&lt;double&gt;&amp; operator=(const Grid&lt;double&gt;&amp; rhs);</code></pre>
      <p class="calibre13" id="c12-para-0110">
       There are no constructors or
       <code class="calibre21">
        operator=
       </code>
       that take a
       <code class="calibre21">
        Grid&lt;int&gt;
       </code>
       within the generated
       <code class="calibre21">
        Grid&lt;double&gt;
       </code>
       class.
      </p>
      <p class="calibre13">
       Luckily, you can rectify this oversight by adding parametrized versions of the copy constructor and assignment operator to the
       <code class="calibre21">
        Grid
       </code>
       class template to generate member functions that will convert from one grid type to another. Here is the new
       <code class="calibre21">
        Grid
       </code>
       class template definition:
      </p>
      <pre class="calibre26" id="c12-code-0052"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<span aria-label="470" class="calibre20" epub:type="pagebreak" id="Page_470" role="doc-pagebreak"></span><code class="calibre21">        <b class="calibre14">template &lt;typename E&gt;</b></code>
<code class="calibre21">        <b class="calibre14">Grid(const Grid&lt;E&gt;&amp; src);</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">template &lt;typename E&gt;</b></code>
<code class="calibre21">        <b class="calibre14">Grid&amp; operator=(const Grid&lt;E&gt;&amp; rhs);</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">void swap(Grid&amp; other) noexcept;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c12-para-0112">
       The original copy constructor and copy assignment operator cannot be removed. The compiler will not call these new parametrized copy constructor and parametrized copy assignment operator if
       <code class="calibre21">
        E
       </code>
       equals
       <code class="calibre21">
        T
       </code>
       .
      </p>
      <p class="calibre13">
       Examine the new parametrized copy constructor first:
      </p>
      <pre class="calibre26" id="c12-code-0053"><code class="calibre21">template &lt;typename E&gt;</code>
<code class="calibre21">Grid(const Grid&lt;E&gt;&amp; src);</code></pre>
      <p class="calibre13">
       You can see that there is another template header with a different typename,
       <code class="calibre21">
        E
       </code>
       (short for “element”). The class is parametrized on one type,
       <code class="calibre21">
        T
       </code>
       , and the new copy constructor is additionally parametrized on a different type,
       <code class="calibre21">
        E
       </code>
       . This twofold parametrization allows you to copy grids of one type to another. Here is the definition of the new copy constructor:
      </p>
      <pre class="calibre26" id="c12-code-0054"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;typename E&gt;</code>
<code class="calibre21">Grid&lt;T&gt;::Grid(const Grid&lt;E&gt;&amp; src)</code>
<code class="calibre21">    : Grid { src.getWidth(), src.getHeight() }</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// The ctor-initializer of this constructor delegates first to the</span></code>
<code class="calibre21">    <span class="color">// non-copy constructor to allocate the proper amount of memory.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// The next step is to copy the data.</span></code>
<code class="calibre21">    for (std::size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        for (std::size_t j { 0 }; j &lt; m_height; ++j) {</code>
<code class="calibre21">            at(i, j) = src.at(i, j);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       As you can see, you must declare the class template header (with the
       <code class="calibre21">
        T
       </code>
       parameter) before the member template header (with the
       <code class="calibre21">
        E
       </code>
       parameter). You can't combine them like this:
      </p>
      <pre class="calibre26" id="c12-code-0055"><code class="calibre21">template &lt;typename T, typename E&gt; <span class="color">// Wrong for nested template constructor!</span></code>
<code class="calibre21">Grid&lt;T&gt;::Grid(const Grid&lt;E&gt;&amp; src)</code></pre>
      <p class="calibre13" id="c12-para-0116">
       In addition to the extra template header before the constructor definition, note that you must use the public accessor member functions
       <code class="calibre21">
        getWidth()
       </code>
       ,
       <code class="calibre21">
        getHeight()
       </code>
       , and
       <code class="calibre21">
        at()
       </code>
       to access the elements of
       <code class="calibre21">
        src
       </code>
       . That's because the object you're copying to is of type
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       , and the object you're copying from is of type
       <code class="calibre21">
        Grid&lt;E&gt;
       </code>
       . They are not the same type, so you must use public member functions.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        swap()
       </code>
       member function is straightforward:
      </p>
      <pre class="calibre26" id="c12-code-0056"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void Grid&lt;T&gt;::swap(Grid&amp; other) noexcept</code>
<code class="calibre21">{</code>
<span aria-label="471" class="calibre20" epub:type="pagebreak" id="Page_471" role="doc-pagebreak"></span><code class="calibre21">    std::swap(m_width, other.m_width);</code>
<code class="calibre21">    std::swap(m_height, other.m_height);</code>
<code class="calibre21">    std::swap(m_cells, other.m_cells);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The parametrized assignment operator takes a
       <code class="calibre21">
        const Grid&lt;E&gt;&amp;
       </code>
       but returns a
       <code class="calibre21">
        Grid&lt;T&gt;&amp;
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0057"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;typename E&gt;</code>
<code class="calibre21">Grid&lt;T&gt;&amp; Grid&lt;T&gt;::operator=(const Grid&lt;E&gt;&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Copy-and-swap idiom</span></code>
<code class="calibre21">    Grid&lt;T&gt; temp { rhs }; <span class="color">// Do all the work in a temporary instance.</span></code>
<code class="calibre21">    swap(temp); <span class="color">// Commit the work with only non-throwing operations.</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c12-para-0119">
       The implementation of this assignment operator uses the copy-and-swap idiom introduced in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       . The
       <code class="calibre21">
        swap()
       </code>
       member function can only swap
       <code class="calibre21">
        Grid
       </code>
       s of the same type, but that's OK because this parametrized assignment operator first converts a given
       <code class="calibre21">
        Grid&lt;E&gt;
       </code>
       to a
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       called
       <code class="calibre21">
        temp
       </code>
       using the parametrized copy constructor. Afterward, it uses the
       <code class="calibre21">
        swap()
       </code>
       member function to swap this temporary
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       with
       <code class="calibre21">
        this
       </code>
       , which is also of type
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0034">
       </span>
       <h4 class="calibre29" id="head-4-228">
        Member Function Templates with Non-type Template Parameters
       </h4>
       <p class="calibre13">
        A major problem with the earlier
        <code class="calibre21">
         Grid
        </code>
        class template with integer template parameters for
        <code class="calibre21">
         HEIGHT
        </code>
        and
        <code class="calibre21">
         WIDTH
        </code>
        is that the height and width become part of the types. This restriction prevents you from assigning a grid with one height and width to a grid with a different height and width. In some cases, however, it's desirable to assign or copy a grid of one size to a grid of a different size. Instead of making the destination object a perfect clone of the source object, you would copy only those elements from the source array that fit in the destination array, padding the destination array with default values if the source array is smaller in either dimension. With member function templates for the assignment operator and copy constructor, you can do exactly that, thus allowing assignment and copying of different-sized grids. Here is the class definition:
       </p>
       <pre class="calibre26" id="c12-code-0058"><code class="calibre21">export template &lt;typename T, std::size_t WIDTH = 10, std::size_t HEIGHT = 10&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Grid() = default;</code>
<code class="calibre21">        virtual ˜Grid() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a copy constructor and assignment operator.</span></code>
<code class="calibre21">        Grid(const Grid&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(const Grid&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a move constructor and move assignment operator.</span></code>
<code class="calibre21">        Grid(Grid&amp;&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(Grid&amp;&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">template &lt;typename E, std::size_t WIDTH2, std::size_t HEIGHT2&gt;</b></code>
<code class="calibre21">        <b class="calibre14">Grid(const Grid&lt;E, WIDTH2, HEIGHT2&gt;&amp; src);</b></code>
<code class="calibre21"> </code>
<span aria-label="472" class="calibre20" epub:type="pagebreak" id="Page_472" role="doc-pagebreak"></span><code class="calibre21">        <b class="calibre14">template &lt;typename E, std::size_t WIDTH2, std::size_t HEIGHT2&gt;</b></code>
<code class="calibre21">        <b class="calibre14">Grid&amp; operator=(const Grid&lt;E, WIDTH2, HEIGHT2&gt;&amp; rhs);</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">void swap(Grid&amp; other) noexcept;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y);</code>
<code class="calibre21">        const std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::size_t getHeight() const { return HEIGHT; }</code>
<code class="calibre21">        std::size_t getWidth() const { return WIDTH; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void verifyCoordinate(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::optional&lt;T&gt; m_cells[WIDTH][HEIGHT];</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c12-para-0121">
        This new definition includes member function templates for the copy constructor and assignment operator, plus a helper member function
        <code class="calibre21">
         swap()
        </code>
        . Note that the non-parametrized copy constructor and assignment operator are explicitly defaulted (because of the user-declared destructor). They simply copy or assign
        <code class="calibre21">
         m_cells
        </code>
        from the source to the destination, which is exactly the semantics you want for two grids of the same size.
       </p>
       <p class="calibre13">
        Here is the parametrized copy constructor:
       </p>
       <pre class="calibre26" id="c12-code-0059"><code class="calibre21">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</code>
<code class="calibre21">template &lt;typename E, std::size_t WIDTH2, std::size_t HEIGHT2&gt;</code>
<code class="calibre21">Grid&lt;T, WIDTH, HEIGHT&gt;::Grid(const Grid&lt;E, WIDTH2, HEIGHT2&gt;&amp; src)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (std::size_t i { 0 }; i &lt; WIDTH; ++i) {</code>
<code class="calibre21">        for (std::size_t j { 0 }; j &lt; HEIGHT; ++j) {</code>
<code class="calibre21">            if (i &lt; WIDTH2 &amp;&amp; j &lt; HEIGHT2) {</code>
<code class="calibre21">                m_cells[i][j] = src.at(i, j);</code>
<code class="calibre21">            } else {</code>
<code class="calibre21">                m_cells[i][j].reset();</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c12-para-0123">
        Note that this copy constructor copies only
        <code class="calibre21">
         WIDTH
        </code>
        and
        <code class="calibre21">
         HEIGHT
        </code>
        elements in the x and y dimensions, respectively, from
        <code class="calibre21">
         src
        </code>
        , even if
        <code class="calibre21">
         src
        </code>
        is bigger than that. If
        <code class="calibre21">
         src
        </code>
        is smaller in either dimension, the
        <code class="calibre21">
         std::optional
        </code>
        objects in the extra spots are reset using the
        <code class="calibre21">
         reset()
        </code>
        member function.
       </p>
       <p class="calibre13">
        Here are the implementations of
        <code class="calibre21">
         swap()
        </code>
        and
        <code class="calibre21">
         operator=
        </code>
        :
       </p>
       <pre class="calibre26" id="c12-code-0060"><code class="calibre21">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</code>
<code class="calibre21">void Grid&lt;T, WIDTH, HEIGHT&gt;::swap(Grid&amp; other) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::swap(m_cells, other.m_cells);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T, std::size_t WIDTH, std::size_t HEIGHT&gt;</code>
<code class="calibre21">template &lt;typename E, std::size_t WIDTH2, std::size_t HEIGHT2&gt;</code>
<code class="calibre21">Grid&lt;T, WIDTH, HEIGHT&gt;&amp; Grid&lt;T, WIDTH, HEIGHT&gt;::operator=(</code>
<span aria-label="473" class="calibre20" epub:type="pagebreak" id="Page_473" role="doc-pagebreak"></span><code class="calibre21">    const Grid&lt;E, WIDTH2, HEIGHT2&gt;&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Copy-and-swap idiom</span></code>
<code class="calibre21">    Grid&lt;T, WIDTH, HEIGHT&gt; temp { rhs }; <span class="color">// Do all the work in a temp instance.</span></code>
<code class="calibre21">    swap(temp); <span class="color">// Commit the work with only non-throwing operations.</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0035">
       </span>
       <h4 class="calibre29" id="head-4-229">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        Using Member Function Templates with Explicit Object Parameters to Avoid Code Duplication
       </h4>
       <p class="calibre13">
        Our running example of the
        <code class="calibre21">
         Grid
        </code>
        class template with a single template type parameter
        <code class="calibre21">
         T
        </code>
        contains two overloads of an
        <code class="calibre21">
         at()
        </code>
        member function,
        <code class="calibre21">
         const
        </code>
        and non-
        <code class="calibre21">
         const
        </code>
        . As a reminder:
       </p>
       <pre class="calibre26" id="c12-code-0061"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y);</code>
<code class="calibre21">        const std::optional&lt;T&gt;&amp; at(std::size_t x, std::size_t y) const;</code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Their implementations use Scott Meyers’
        <code class="calibre21">
         const_cast()
        </code>
        pattern to avoid code duplication:
       </p>
       <pre class="calibre26" id="c12-code-0062"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">const std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::at(std::size_t x, std::size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x + y * m_width];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::at(std::size_t x, std::size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return const_cast&lt;std::optional&lt;T&gt;&amp;&gt;(std::as_const(*this).at(x, y));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Although there is no code duplication, you still need to define both the
        <code class="calibre21">
         const
        </code>
        and non-
        <code class="calibre21">
         const
        </code>
        overloads explicitly. Starting with C++23, you can use an
        <i class="calibre18">
         explicit object parameter
        </i>
        (see
        <a class="calibre5" href="c08.xhtml">
         Chapter 8
        </a>
        ) to avoid having to provide the two overloads explicitly. The trick is to turn the
        <code class="calibre21">
         at()
        </code>
        member function into a member function template where the type of the explicit object parameter
        <code class="calibre21">
         self
        </code>
        is itself a template type parameter,
        <code class="calibre21">
         Self
        </code>
        , and thus deduced automatically. This feature is called
        <i class="calibre18">
         deducing this
        </i>
        . Here is such a declaration:
       </p>
       <pre class="calibre26" id="c12-code-0063"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        template &lt;typename Self&gt;</code>
<code class="calibre21">        auto&amp;&amp; at(this Self&amp;&amp; self, std::size_t x, std::size_t y);</code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="474" class="calibre20" epub:type="pagebreak" id="Page_474" role="doc-pagebreak">
        </span>
        The implementation uses a
        <i class="calibre18">
         forwarding reference
        </i>
        ,
        <code class="calibre21">
         Self&amp;&amp;
        </code>
        ; see the following note. Such a forwarding reference can bind to
        <code class="calibre21">
         Grid&lt;T&gt;&amp;
        </code>
        ,
        <code class="calibre21">
         const Grid&lt;T&gt;&amp;
        </code>
        , and
        <code class="calibre21">
         Grid&lt;T&gt;&amp;&amp;
        </code>
        .
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c12-para-0130">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            A reference of type
           </i>
           <code class="calibre21">
            Self&amp;&amp;
           </code>
           <i class="calibre18">
            is only a forwarding reference when it is used as a parameter for a function or member function template with
           </i>
           <code class="calibre21">
            Self
           </code>
           <i class="calibre18">
            as one of its template type parameters. If a class member function has a
           </i>
           <code class="calibre21">
            Self&amp;&amp;
           </code>
           <i class="calibre18">
            parameter, but with
           </i>
           <code class="calibre21">
            Self
           </code>
           <i class="calibre18">
            a template type parameter of the class and not of the member function itself, then that
           </i>
           <code class="calibre21">
            Self&amp;&amp;
           </code>
           <i class="calibre18">
            is not a forwarding reference, but just an rvalue reference. That's because at the time the compiler starts processing that member function with a
           </i>
           <code class="calibre21">
            Self&amp;&amp;
           </code>
           <i class="calibre18">
            parameter, the class template parameter
           </i>
           <code class="calibre21">
            Self
           </code>
           <i class="calibre18">
            has already been resolved to a concrete type, for example
           </i>
           <code class="calibre21">
            int
           </code>
           <i class="calibre18">
            , and at that time, that member function parameter type has already been replaced with
           </i>
           <code class="calibre21">
            int&amp;&amp;
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Here is the implementation. Remember from
        <a class="calibre5" href="c08.xhtml">
         Chapter 8
        </a>
        that in the body of a member function using an explicit object parameter, you need to use the explicit object parameter,
        <code class="calibre21">
         self
        </code>
        in this case, to get access to the object; there is no
        <code class="calibre21">
         this
        </code>
        pointer.
       </p>
       <pre class="calibre26" id="c12-code-0064"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;typename Self&gt;</code>
<code class="calibre21">auto&amp;&amp; Grid&lt;T&gt;::at(this Self&amp;&amp; self, std::size_t x, std::size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    self.verifyCoordinate(x, y);</code>
<code class="calibre21">    return std::forward_like&lt;Self&gt;(self.m_cells[x + y * self.m_width]);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The implementation uses
        <code class="calibre21">
         std::forward_like&lt;Self&gt;(x)
        </code>
        introduced in C++23. This returns a reference to
        <code class="calibre21">
         x
        </code>
        with similar properties as
        <code class="calibre21">
         Self&amp;&amp;
        </code>
        . Thus, since the type of the elements of
        <code class="calibre21">
         m_cells
        </code>
        is
        <code class="calibre21">
         optional&lt;T&gt;
        </code>
        , the following holds:
       </p>
       <ul class="check" id="c12-list-0002">
        <li class="calibre9" id="c12-li-0016">
         If
         <code class="calibre21">
          Self&amp;&amp;
         </code>
         is bound to a
         <code class="calibre21">
          Grid&lt;T&gt;&amp;
         </code>
         , the return type will be an
         <code class="calibre21">
          optional&lt;T&gt;&amp;
         </code>
         .
        </li>
        <li class="calibre9" id="c12-li-0017">
         If
         <code class="calibre21">
          Self&amp;&amp;
         </code>
         is bound to a
         <code class="calibre21">
          const Grid&lt;T&gt;&amp;
         </code>
         , the return type will be a
         <code class="calibre21">
          const optional&lt;T&gt;&amp;
         </code>
         .
        </li>
        <li class="calibre9" id="c12-li-0018">
         If
         <code class="calibre21">
          Self&amp;&amp;
         </code>
         is bound to a
         <code class="calibre21">
          Grid&lt;T&gt;&amp;&amp;
         </code>
         , the return type will be an
         <code class="calibre21">
          optional&lt;T&gt;&amp;&amp;
         </code>
         .
        </li>
       </ul>
       <p class="calibre13" id="c12-para-0133">
        To summarize, with a combination of member function templates, explicit object parameters, forwarding references, and
        <code class="calibre21">
         forward_like()
        </code>
        , it becomes possible to declare and define just a single member function template that provides both
        <code class="calibre21">
         const
        </code>
        and non-
        <code class="calibre21">
         const
        </code>
        instantiations.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0037">
      </span>
      <h3 class="calibre27" id="head-3-268">
       Class Template Specialization
      </h3>
      <p class="calibre13" id="c12-para-0134">
       You can provide alternate implementations of class templates for specific types. For example, you might decide that the
       <code class="calibre21">
        Grid
       </code>
       behavior for
       <code class="calibre21">
        const char*
       </code>
       s (C-style strings) doesn't make sense. A
       <code class="calibre21">
        Grid&lt;const char*&gt;
       </code>
       will store its elements in a
       <code class="calibre21">
        vector&lt;optional&lt;const char*&gt;&gt;
       </code>
       . The copy constructor and assignment operator will perform shallow copies of this
       <code class="calibre21">
        const char*
       </code>
       pointer type. For
       <code class="calibre21">
        const char*
       </code>
       s, it makes more sense to do a deep copy of strings. The easiest solution for this is to write an alternative implementation specifically for
       <code class="calibre21">
        const char*
       </code>
       s, which converts them to C++
       <code class="calibre21">
        string
       </code>
       s and stores them in a
       <code class="calibre21">
        vector&lt;optional&lt;string&gt;&gt;
       </code>
       .
      </p>
      <p class="calibre13">
       <span aria-label="475" class="calibre20" epub:type="pagebreak" id="Page_475" role="doc-pagebreak">
       </span>
       Alternate implementations of templates are called
       <i class="calibre18">
        template specializations
       </i>
       . You might find the syntax to be a little weird at first. When you write a class template specialization, you must specify that it's based on a template and that you are writing a version of the template for a particular type. Here is the syntax for a
       <code class="calibre21">
        const char*
       </code>
       specialization for
       <code class="calibre21">
        Grid
       </code>
       . For this implementation, the original
       <code class="calibre21">
        Grid
       </code>
       class template is moved to a module interface partition called
       <code class="calibre21">
        main
       </code>
       , while the specialization is in a module interface partition called
       <code class="calibre21">
        string
       </code>
       .
      </p>
      <pre class="calibre26" id="c12-code-0065"><code class="calibre21"><b class="calibre14">export module grid:string;</b></code>
<code class="calibre21">import std;</code>
<code class="calibre21"><span class="color">// When the template specialization is used, the original template must be</span></code>
<code class="calibre21"><span class="color">// visible too.</span></code>
<code class="calibre21"><b class="calibre14">import :main;</b></code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">export template &lt;&gt;</b></code>
<code class="calibre21"><b class="calibre14">class Grid&lt;const char*&gt;</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Grid(std::size_t width = DefaultWidth,</code>
<code class="calibre21">            std::size_t height = DefaultHeight);</code>
<code class="calibre21">        virtual ˜Grid() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a copy constructor and assignment operator.</span></code>
<code class="calibre21">        Grid(const Grid&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(const Grid&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default a move constructor and assignment operator.</span></code>
<code class="calibre21">        Grid(Grid&amp;&amp; src) = default;</code>
<code class="calibre21">        Grid&amp; operator=(Grid&amp;&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">std::optional&lt;std::string&gt;&amp; at(std::size_t x, std::size_t y);</b></code>
<code class="calibre21">        <b class="calibre14">const std::optional&lt;std::string&gt;&amp; at(std::size_t x, std::size_t y) const;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        std::size_t getHeight() const { return m_height; }</code>
<code class="calibre21">        std::size_t getWidth() const { return m_width; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        static constexpr std::size_t DefaultWidth { 10 };</code>
<code class="calibre21">        static constexpr std::size_t DefaultHeight { 10 };</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void verifyCoordinate(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">std::vector&lt;std::optional&lt;std::string&gt;&gt; m_cells;</b></code>
<code class="calibre21">        std::size_t m_width { 0 }, m_height { 0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Note that you don't refer to any type variable, such as
       <code class="calibre21">
        T
       </code>
       , in the specialization: you work directly with
       <code class="calibre21">
        const char*
       </code>
       s and
       <code class="calibre21">
        string
       </code>
       s. One obvious question at this point is why this class still has a template header. That is, what good is the following syntax?
      </p>
      <pre class="calibre26" id="c12-code-0066"><code class="calibre21">template &lt;&gt;</code>
<code class="calibre21">class Grid&lt;const char*&gt;</code></pre>
      <p class="calibre13">
       This syntax tells the compiler that this class is a
       <code class="calibre21">
        const char*
       </code>
       specialization of the
       <code class="calibre21">
        Grid
       </code>
       class template. Suppose that you didn't use that syntax and just tried to write this:
      </p>
      <pre class="calibre26" id="c12-code-0067"><code class="calibre21">class Grid</code></pre>
      <p class="calibre13" id="c12-para-0138">
       <span aria-label="476" class="calibre20" epub:type="pagebreak" id="Page_476" role="doc-pagebreak">
       </span>
       The compiler wouldn't let you do that because there is already a class template named
       <code class="calibre21">
        Grid
       </code>
       (the original class template). Only by specializing it can you reuse the name. The main benefit of specializations is that they can be invisible to the user. When a user creates a
       <code class="calibre21">
        Grid
       </code>
       of
       <code class="calibre21">
        int
       </code>
       s or
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s, the compiler generates code from the original
       <code class="calibre21">
        Grid
       </code>
       template. When the user creates a
       <code class="calibre21">
        Grid
       </code>
       of
       <code class="calibre21">
        const char*
       </code>
       s, the compiler uses the
       <code class="calibre21">
        const char*
       </code>
       specialization. This can all be “behind the scenes.”
      </p>
      <p class="calibre13">
       The primary module interface file simply imports and exports both module interface partitions:
      </p>
      <pre class="calibre26" id="c12-code-0068"><code class="calibre21">export module grid;</code>
<code class="calibre21"> </code>
<code class="calibre21">export import :main;</code>
<code class="calibre21">export import :string;</code></pre>
      <p class="calibre13">
       The specialization can be tested as follows:
      </p>
      <pre class="calibre26" id="c12-code-0069"><code class="calibre21">Grid&lt;int&gt; myIntGrid;                    <span class="color">// Uses original Grid template.</span></code>
<code class="calibre21">Grid&lt;const char*&gt; stringGrid1 { 2, 2 }; <span class="color">// Uses const char* specialization.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">const char* dummy { "dummy" };</code>
<code class="calibre21">stringGrid1.at(0, 0) = "hello";</code>
<code class="calibre21">stringGrid1.at(0, 1) = dummy;</code>
<code class="calibre21">stringGrid1.at(1, 0) = dummy;</code>
<code class="calibre21">stringGrid1.at(1, 1) = "there";</code>
<code class="calibre21"> </code>
<code class="calibre21">Grid&lt;const char*&gt; stringGrid2 { stringGrid1 };</code></pre>
      <p class="calibre13">
       When you specialize a class template, you don't “inherit” any code; specializations are not like derivations. You must rewrite the entire implementation of the class. There is no requirement that you provide member functions with the same names or behavior. As an example, the
       <code class="calibre21">
        const char*
       </code>
       specialization of
       <code class="calibre21">
        Grid
       </code>
       implements the
       <code class="calibre21">
        at()
       </code>
       member functions by returning an
       <code class="calibre21">
        optional&lt;string&gt;
       </code>
       , not an
       <code class="calibre21">
        optional&lt;const char*&gt;
       </code>
       . As a matter of fact, you could write a completely different class with no relation to the original. Of course, that would abuse the template specialization ability, and you shouldn't do it without good reason. Here are the implementations for the member functions of the
       <code class="calibre21">
        const char*
       </code>
       specialization. Unlike in the class template definition, you do not repeat the template header,
       <code class="calibre21">
        template&lt;&gt;
       </code>
       , before each member function definition.
      </p>
      <pre class="calibre26" id="c12-code-0070"><code class="calibre21"><b class="calibre14">Grid&lt;const char*&gt;::Grid(std::size_t width, std::size_t height)</b></code>
<code class="calibre21">    : m_width { width }, m_height { height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_cells.resize(m_width * m_height);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">void Grid&lt;const char*&gt;::verifyCoordinate(std::size_t x, std::size_t y) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x&gt;= m_width) {</code>
<code class="calibre21">        throw std::out_of_range {</code>
<code class="calibre21">            std::format("x ({}) must be less than width ({}).", x, m_width) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    if (y&gt;= m_height) {</code>
<code class="calibre21">        throw std::out_of_range {</code>
<code class="calibre21">            std::format("y ({}) must be less than height ({}).", y, m_height) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<span aria-label="477" class="calibre20" epub:type="pagebreak" id="Page_477" role="doc-pagebreak"></span><code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">const std::optional&lt;std::string&gt;&amp; Grid&lt;const char*&gt;::at(</b></code>
<code class="calibre21">    <b class="calibre14">std::size_t x, std::size_t y) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x + y * m_width];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">std::optional&lt;std::string&gt;&amp; Grid&lt;const char*&gt;::at(std::size_t x, std::size_t y)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">return const_cast&lt;std::optional&lt;std::string&gt;&amp;&gt;(</b></code>
<code class="calibre21">        <b class="calibre14">std::as_const(*this).at(x, y));</b></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c12-para-0142">
       This section discussed how to use class template specialization to write a special implementation for a class template, with all template type parameters replaced with specific types. This is called
       <i class="calibre18">
        full template specialization
       </i>
       . Such a full class template specialization is no longer a class template itself but a class definition.
       <a class="calibre5" href="c26.xhtml">
        Chapter 26
       </a>
       , “Advanced Templates,” continues the discussion of class template specialization with a more advanced feature called
       <i class="calibre18">
        partial specialization
       </i>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0038">
      </span>
      <h3 class="calibre27" id="head-3-269">
       Deriving from Class Templates
      </h3>
      <p class="calibre13">
       You can inherit from class templates. If the derived class inherits from the template itself, it must be a template as well. Alternatively, you can derive from a specific instantiation of the class template, in which case your derived class does not need to be a template. As an example of the former, suppose you decide that the generic
       <code class="calibre21">
        Grid
       </code>
       class doesn't provide enough functionality to use as a game board. Specifically, you would like to add a
       <code class="calibre21">
        move()
       </code>
       member function to the game board that moves a piece from one location on the board to another. Here is the class definition for the
       <code class="calibre21">
        GameBoard
       </code>
       template:
      </p>
      <pre class="calibre26" id="c12-code-0071"><code class="calibre21">import grid;</code>
<code class="calibre21"> </code>
<code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class GameBoard : public Grid&lt;T&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Inherit constructors from Grid&lt;T&gt;.</span></code>
<code class="calibre21">        using Grid&lt;T&gt;::Grid;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void move(std::size_t xSrc, std::size_t ySrc,</code>
<code class="calibre21">            std::size_t xDest, std::size_t yDest);</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c12-para-0144">
       This
       <code class="calibre21">
        GameBoard
       </code>
       template derives from the
       <code class="calibre21">
        Grid
       </code>
       template and thereby inherits all its functionality. You don't need to rewrite
       <code class="calibre21">
        at()
       </code>
       ,
       <code class="calibre21">
        getHeight()
       </code>
       , or any of the other member functions. You also don't need to add a copy constructor,
       <code class="calibre21">
        operator=
       </code>
       , or destructor, because you don't have any dynamically allocated memory in
       <code class="calibre21">
        GameBoard
       </code>
       . Additionally,
       <code class="calibre21">
        GameBoard
       </code>
       explicitly inherits the constructors from the base class,
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       . Inheriting constructors from base classes is explained in
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       , “Discovering Inheritance Techniques.”
      </p>
      <p class="calibre13" id="c12-para-0145">
       The inheritance syntax looks normal, except that the base class is
       <code class="calibre21">
        Grid&lt;T&gt;
       </code>
       , not
       <code class="calibre21">
        Grid
       </code>
       . The reason for this syntax is that the
       <code class="calibre21">
        GameBoard
       </code>
       template doesn't really derive from the generic
       <code class="calibre21">
        Grid
       </code>
       template.
       <span aria-label="478" class="calibre20" epub:type="pagebreak" id="Page_478" role="doc-pagebreak">
       </span>
       Rather, each instantiation of the
       <code class="calibre21">
        GameBoard
       </code>
       template for a specific type derives from the
       <code class="calibre21">
        Grid
       </code>
       instantiation for that same type. For example, if you instantiate a
       <code class="calibre21">
        GameBoard
       </code>
       with a
       <code class="calibre21">
        ChessPiece
       </code>
       type, then the compiler generates code for a
       <code class="calibre21">
        Grid&lt;ChessPiece&gt;
       </code>
       as well. The
       <code class="calibre21">
        : public Grid&lt;T&gt;
       </code>
       syntax says that this class inherits from whatever
       <code class="calibre21">
        Grid
       </code>
       instantiation makes sense for the
       <code class="calibre21">
        T
       </code>
       type parameter.
      </p>
      <p class="calibre13">
       Here is the implementation of the
       <code class="calibre21">
        move()
       </code>
       member function:
      </p>
      <pre class="calibre26" id="c12-code-0072"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void GameBoard&lt;T&gt;::move(std::size_t xSrc, std::size_t ySrc,</code>
<code class="calibre21">    std::size_t xDest, std::size_t yDest)</code>
<code class="calibre21">{</code>
<code class="calibre21">    Grid&lt;T&gt;::at(xDest, yDest) = std::move(Grid&lt;T&gt;::at(xSrc, ySrc));</code>
<code class="calibre21">    Grid&lt;T&gt;::at(xSrc, ySrc).reset();  <span class="color">// Reset source cell</span></code>
<code class="calibre21">    <span class="color">// Or:</span></code>
<code class="calibre21">    <span class="color">// this-&gt;at(xDest, yDest) = std::move(this-&gt;at(xSrc, ySrc));</span></code>
<code class="calibre21">    <span class="color">// this-&gt;at(xSrc, ySrc).reset();</span></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0148">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Although some compilers don't enforce it, the C++ name lookup rules require you to use the
          </i>
          <code class="calibre21">
           this
          </code>
          <i class="calibre18">
           pointer or
          </i>
          <code class="calibre21">
           Grid&lt;T&gt;::
          </code>
          <i class="calibre18">
           to refer to data members and member functions in a base class template. Hence, we use
          </i>
          <code class="calibre21">
           Grid&lt;T&gt;::at()
          </code>
          <i class="calibre18">
           instead of just
          </i>
          <code class="calibre21">
           at()
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       You can use the
       <code class="calibre21">
        GameBoard
       </code>
       template as follows:
      </p>
      <pre class="calibre26" id="c12-code-0073"><code class="calibre21">GameBoard&lt;ChessPiece&gt; chessboard { 8, 8 };</code>
<code class="calibre21">ChessPiece pawn;</code>
<code class="calibre21">chessBoard.at(0, 0) = pawn;</code>
<code class="calibre21">chessBoard.move(0, 0, 0, 1);</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0151">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Of course, if you want to override member functions from
          </i>
          <code class="calibre21">
           Grid
          </code>
          <i class="calibre18">
           , you will have to mark them
          </i>
          <code class="calibre21">
           virtual
          </code>
          <i class="calibre18">
           in the
          </i>
          <code class="calibre21">
           Grid
          </code>
          <i class="calibre18">
           class template.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-270">
       Inheritance vs. Specialization
      </h3>
      <p class="calibre13">
       Some programmers find the distinction between template inheritance and template specialization confusing. The following table summarizes the differences:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
         </th>
         <th class="left" scope="col">
          INHERITANCE
         </th>
         <th class="left" scope="col">
          SPECIALIZATION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="bgcolor">
          <b class="calibre14">
           Reuses code?
          </b>
         </td>
         <td class="bgcolor">
          <b class="calibre14">
           Yes:
          </b>
          Derived classes contain all base class data members and member functions.
         </td>
         <td class="bgcolor">
          <b class="calibre14">
           No:
          </b>
          You must rewrite all required code in the specialization.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <b class="calibre14">
           Reuses name?
          </b>
         </td>
         <td class="bgcolor">
          <b class="calibre14">
           No:
          </b>
          The derived class name must be different from the base class name.
         </td>
         <td class="bgcolor">
          <b class="calibre14">
           Yes:
          </b>
          The specialization must have the same name as the original.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <b class="calibre14">
           Supports polymorphism?
          </b>
         </td>
         <td class="bgcolor">
          <b class="calibre14">
           Yes:
          </b>
          Objects of the derived class can stand in for objects of the base class.
         </td>
         <td class="bgcolor">
          <b class="calibre14">
           No:
          </b>
          Each instantiation of a template for a type is a different type.
          <span aria-label="479" class="calibre20" epub:type="pagebreak" id="Page_479" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0154">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Use inheritance for extending implementations and for polymorphism. Use specialization for customizing implementations for particular types
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-271">
       Alias Templates
      </h3>
      <p class="calibre13">
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       introduces the concept of type aliases and
       <code class="calibre21">
        typedef
       </code>
       s. They allow you to give other names to specific types. To refresh your memory, you could, for example, write the following type alias to give a second name to type
       <code class="calibre21">
        int
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0074"><code class="calibre21">using MyInt = int;</code></pre>
      <p class="calibre13">
       Similarly, you can use a type alias to give another name to a class template. Suppose you have the following class template:
      </p>
      <pre class="calibre26" id="c12-code-0075"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21">class MyClassTemplate { <span class="color">/* … */</span> };</code></pre>
      <p class="calibre13">
       You can define the following type alias in which you specify both class template type parameters:
      </p>
      <pre class="calibre26" id="c12-code-0076"><code class="calibre21">using OtherName = MyClassTemplate&lt;int, double&gt;;</code></pre>
      <p class="calibre13" id="c12-para-0158">
       A
       <code class="calibre21">
        typedef
       </code>
       can also be used instead of such a type alias.
      </p>
      <p class="calibre13">
       Additionally, it's also possible to specify only some of the types and keep the other types as template type parameters. This is called an
       <i class="calibre18">
        alias template
       </i>
       . Here's an example:
      </p>
      <pre class="calibre26" id="c12-code-0077"><code class="calibre21">template &lt;typename T1&gt;</code>
<code class="calibre21">using OtherName = MyClassTemplate&lt;T1, double&gt;;</code></pre>
      <p class="calibre13" id="c12-para-0160">
       This is something you cannot do with a
       <code class="calibre21">
        typedef
       </code>
       .
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-144" class="calibre2">
     <span class="calibre" id="c12-sec-0044">
     </span>
     <h2 class="calibre6" id="head-2-144">
      FUNCTION TEMPLATES
     </h2>
     <p class="calibre13">
      You can also write templates for stand-alone functions. The syntax is similar to the syntax for class templates. For example, you could write the following generic function to find a value in an array and return its index:
     </p>
     <pre class="calibre26" id="c12-code-0078"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">optional&lt;size_t&gt; Find(const T&amp; value, const T* arr, size_t size)</code>
<code class="calibre21">{</code>
<span aria-label="480" class="calibre20" epub:type="pagebreak" id="Page_480" role="doc-pagebreak"></span><code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">        if (arr[i] == value) {</code>
<code class="calibre21">            return i; <span class="color">// Found it; return the index.</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return {}; <span class="color">// Failed to find it; return empty optional.</span></code>
<code class="calibre21">}</code></pre>
     <p class="calibre13" id="c12-para-0162">
      The
      <code class="calibre21">
       Find()
      </code>
      function template can work on arrays of any type. For example, you could use it to find the index of an
      <code class="calibre21">
       int
      </code>
      in an array of
      <code class="calibre21">
       int
      </code>
      s or a
      <code class="calibre21">
       SpreadsheetCell
      </code>
      in an array of
      <code class="calibre21">
       SpreadsheetCell
      </code>
      s.
     </p>
     <p class="calibre13">
      You can call the function in two ways: explicitly specifying the template type parameter with angle brackets or omitting the type and letting the compiler
      <i class="calibre18">
       deduce
      </i>
      the type parameter from the arguments. Here are some examples:
     </p>
     <pre class="calibre26" id="c12-code-0079"><code class="calibre21">int myInt { 3 }, intArray[] {1, 2, 3, 4};</code>
<code class="calibre21">const size_t sizeIntArray { size(intArray) };</code>
<code class="calibre21"> </code>
<code class="calibre21">optional&lt;size_t&gt; res;</code>
<code class="calibre21">res = Find(myInt, intArray, sizeIntArray);      <span class="color">// calls Find&lt;int&gt; by deduction.</span></code>
<code class="calibre21">res = Find&lt;int&gt;(myInt, intArray, sizeIntArray); <span class="color">// calls Find&lt;int&gt; explicitly.</span></code>
<code class="calibre21">if (res) { println("{}", *res); }</code>
<code class="calibre21">else { println("Not found"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">double myDouble { 5.6 }, doubleArray[] {1.2, 3.4, 5.7, 7.5};</code>
<code class="calibre21">const size_t sizeDoubleArray { size(doubleArray) };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// calls Find&lt;double&gt; by deduction.</span></code>
<code class="calibre21">res = Find(myDouble, doubleArray, sizeDoubleArray);</code>
<code class="calibre21"><span class="color">// calls Find&lt;double&gt; explicitly.</span></code>
<code class="calibre21">res = Find&lt;double&gt;(myDouble, doubleArray, sizeDoubleArray);</code>
<code class="calibre21">if (res) { println("{}", *res); }</code>
<code class="calibre21">else { println("Not found"); }</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">//res = Find(myInt, doubleArray, sizeDoubleArray); // DOES NOT COMPILE!</span></code>
<code class="calibre21">                                      <span class="color">// Arguments are different types.</span></code>
<code class="calibre21"><span class="color">// calls Find&lt;double&gt; explicitly, even with myInt.</span></code>
<code class="calibre21">res = Find&lt;double&gt;(myInt, doubleArray, sizeDoubleArray);</code>
<code class="calibre21"> </code>
<code class="calibre21">SpreadsheetCell cell1 { 10 }</code>
<code class="calibre21">SpreadsheetCell cellArray[] { SpreadsheetCell { 4 }, SpreadsheetCell { 10 } };</code>
<code class="calibre21">const size_t sizeCellArray { size(cellArray) };</code>
<code class="calibre21"> </code>
<code class="calibre21">res = Find(cell1, cellArray, sizeCellArray);</code>
<code class="calibre21">res = Find&lt;SpreadsheetCell&gt;(cell1, cellArray, sizeCellArray);</code></pre>
     <p class="calibre13">
      The previous implementation of the
      <code class="calibre21">
       Find()
      </code>
      function template requires the size of the array as one of the parameters. Sometimes the compiler knows the exact size of an array, for example, for stack-based arrays. It would be nice to be able to call
      <code class="calibre21">
       Find()
      </code>
      with such arrays without the need to pass it the size of the array. This can be accomplished by adding the following function template. The implementation just forwards the call to the previous
      <code class="calibre21">
       Find()
      </code>
      function template. This also demonstrates that function templates can take non-type parameters, just like class templates.
     </p>
     <pre class="calibre26" id="c12-code-0080"><code class="calibre21">template &lt;typename T, size_t N&gt;</code>
<code class="calibre21">optional&lt;size_t&gt; Find(const T&amp; value, const T(&amp;arr)[N])</code>
<code class="calibre21">{</code>
<span aria-label="481" class="calibre20" epub:type="pagebreak" id="Page_481" role="doc-pagebreak"></span><code class="calibre21">    return Find(value, arr, N);</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      The syntax of this overload of
      <code class="calibre21">
       Find()
      </code>
      looks a bit strange, but its use is straightforward, as in this example:
     </p>
     <pre class="calibre26" id="c12-code-0081"><code class="calibre21">int myInt { 3 }, intArray[] {1, 2, 3, 4};</code>
<code class="calibre21">optional&lt;size_t&gt; res { Find(myInt, intArray) };</code></pre>
     <p class="calibre13" id="c12-para-0166">
      Like class template member function definitions, function template definitions (not just the prototypes) must be available to all source files that use them. Thus, you should put the definitions in module interface files and export them if more than one source file uses them.
     </p>
     <p class="calibre13">
      Finally, template parameters of function templates can have defaults, just like class templates.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c12-para-0168">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          The C++ Standard Library provides an
         </i>
         <code class="calibre21">
          std::find()
         </code>
         <i class="calibre18">
          function template that is more powerful than the
         </i>
         <code class="calibre21">
          Find()
         </code>
         <i class="calibre18">
          function template shown here. See
          <a class="calibre5" href="c20.xhtml">
           Chapter 20
          </a>
          , “Mastering Standard Library Algorithms,” for details.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-272">
       Function Overloads vs. Function Template
      </h3>
      <p class="calibre13" id="c12-para-0169">
       There are two options when you want to provide a function that can work with different data types: provide function overloads or provide a function template. How do you choose between those two options?
      </p>
      <p class="calibre13" id="c12-para-0170">
       When writing a function that should work with different data types and for which the body of the function is the same for all data types, provide a function template. If the body of the function is different for every data type, provide function overloads.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-273">
       Function Template Overloading
      </h3>
      <p class="calibre13" id="c12-para-0171">
       In theory, the C++ language allows you to write function template specializations, just as you can write class template specializations. However, you rarely want to do this because such function template specializations do not participate in overload resolution and hence might behave unexpectedly.
      </p>
      <p class="calibre13">
       Instead, you can overload function templates with either non-template functions or other function templates. For example, you might want to write a
       <code class="calibre21">
        Find()
       </code>
       overload for
       <code class="calibre21">
        const char*
       </code>
       C-style strings that compares them with
       <code class="calibre21">
        strcmp()
       </code>
       (see
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       , “Working with Strings and String Views”) instead of
       <code class="calibre21">
        operator==
       </code>
       , as
       <code class="calibre21">
        ==
       </code>
       would only compare pointers, not the actual strings. Here is such an overload:
      </p>
      <pre class="calibre26" id="c12-code-0082"><code class="calibre21">optional&lt;size_t&gt; Find(const char* value, const char** arr, size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">        if (strcmp(arr[i], value) == 0) {</code>
<code class="calibre21">            return i; <span class="color">// Found it; return the index.</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return {}; <span class="color">// Failed to find it; return empty optional.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <span aria-label="482" class="calibre20" epub:type="pagebreak" id="Page_482" role="doc-pagebreak">
       </span>
       This function overload can be used as follows:
      </p>
      <pre class="calibre26" id="c12-code-0083"><code class="calibre21"><span class="color">// Using an array for word to make sure no literal pooling happens, see <a class="calibre5" href="c02.xhtml">Chapter 2</a>.</span></code>
<code class="calibre21">const char word[] { "two" };</code>
<code class="calibre21">const char* words[] { "one", "two", "three", "four" };</code>
<code class="calibre21">const size_t sizeWords { size(words) };</code>
<code class="calibre21">optional&lt;size_t&gt; res { Find(word, words, sizeWords) }; <span class="color">// Calls non-template Find.</span></code>
<code class="calibre21">if (res) { println("{}", *res); }</code>
<code class="calibre21">else { println("Not found"); }</code></pre>
      <p class="calibre13" id="c12-para-0174">
       The call to
       <code class="calibre21">
        Find()
       </code>
       correctly finds the string “two” at index 1.
      </p>
      <p class="calibre13">
       If you do explicitly specify the template type parameter as follows, then the function template will be called with
       <code class="calibre21">
        T=const char*
       </code>
       , and not the overload for
       <code class="calibre21">
        const char*
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0084"><code class="calibre21">res = Find&lt;const char*&gt;(word, words, sizeWords);</code></pre>
      <p class="calibre13" id="c12-para-0176">
       This call of
       <code class="calibre21">
        Find()
       </code>
       does not find any matches, as it doesn't compare the actual strings, but just pointers.
      </p>
      <p class="calibre13" id="c12-para-0177">
       When the overload resolution process of the compiler results in two possible candidates, one being a function template, the other being a non-template function, then the compiler always prefers to use the non-template function.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0048">
      </span>
      <h3 class="calibre27" id="head-3-274">
       Function Templates as Friends of Class Templates
      </h3>
      <p class="calibre13">
       Function templates are useful when you want to overload operators in a class template. For example, you might want to overload the addition operator (
       <code class="calibre21">
        operator+
       </code>
       ) for the
       <code class="calibre21">
        Grid
       </code>
       class template to be able to add two grids together. The result will be a
       <code class="calibre21">
        Grid
       </code>
       with the same size as the smallest
       <code class="calibre21">
        Grid
       </code>
       of the two operands. Corresponding cells are added together only if both cells contain an actual value. Suppose you want to make your
       <code class="calibre21">
        operator+
       </code>
       a stand-alone function template. The definition, which should go in the
       <code class="calibre21">
        Grid.cppm
       </code>
       module interface file, looks as follows. The implementation uses
       <code class="calibre21">
        std::min()
       </code>
       , defined in
       <code class="calibre21">
        &lt;algorithm&gt;
       </code>
       , to return the minimum value of two given arguments:
      </p>
      <pre class="calibre26" id="c12-code-0085"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">Grid&lt;T&gt; operator+(const Grid&lt;T&gt;&amp; lhs, const Grid&lt;T&gt;&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::size_t minWidth { std::min(lhs.m_width, rhs.m_width) };</code>
<code class="calibre21">    std::size_t minHeight { std::min(lhs.m_height, rhs.m_height) };</code>
<code class="calibre21"> </code>
<code class="calibre21">    Grid&lt;T&gt; result { minWidth, minHeight };</code>
<code class="calibre21">    for (std::size_t y { 0 }; y &lt; minHeight; ++y) {</code>
<code class="calibre21">        for (std::size_t x { 0 }; x &lt; minWidth; ++x) {</code>
<code class="calibre21">            const auto&amp; leftElement { lhs.at(x, y) };</code>
<code class="calibre21">            const auto&amp; rightElement { rhs.at(x, y) };</code>
<code class="calibre21">            if (leftElement.has_value() &amp;&amp; rightElement.has_value()) {</code>
<code class="calibre21">                result.at(x, y) = leftElement.value() + rightElement.value();</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return result;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c12-para-0179">
       <span aria-label="483" class="calibre20" epub:type="pagebreak" id="Page_483" role="doc-pagebreak">
       </span>
       To query whether an
       <code class="calibre21">
        optional
       </code>
       contains an actual value, you use the
       <code class="calibre21">
        has_value()
       </code>
       member function, while
       <code class="calibre21">
        value()
       </code>
       is used to retrieve this value.
      </p>
      <p class="calibre13">
       This function template works on any
       <code class="calibre21">
        Grid
       </code>
       , as long as there is an addition operator for the type of elements stored in the grid. The only problem with this implementation is that it accesses
       <code class="calibre21">
        private
       </code>
       members
       <code class="calibre21">
        m_width
       </code>
       and
       <code class="calibre21">
        m_height
       </code>
       of the
       <code class="calibre21">
        Grid
       </code>
       class. The obvious solution is to use the
       <code class="calibre21">
        public getWidth()
       </code>
       and
       <code class="calibre21">
        getHeight()
       </code>
       member functions, but let's see how you can make a function template a friend of a class template. For this example, you can make the operator a
       <code class="calibre21">
        friend
       </code>
       of the
       <code class="calibre21">
        Grid
       </code>
       class template. However, both
       <code class="calibre21">
        Grid
       </code>
       and the
       <code class="calibre21">
        operator+
       </code>
       are templates. What you really want is for each instantiation of
       <code class="calibre21">
        operator+
       </code>
       for a particular type
       <code class="calibre21">
        T
       </code>
       to be a friend of the
       <code class="calibre21">
        Grid
       </code>
       template instantiation for that same type. The syntax looks like this:
      </p>
      <pre class="calibre26" id="c12-code-0086"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">friend Grid operator+&lt;T&gt;(const Grid&amp; lhs, const Grid&amp; rhs);</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c12-para-0181">
       This friend declaration is tricky: you're saying that, for an instance of the class template with type
       <code class="calibre21">
        T
       </code>
       , the
       <code class="calibre21">
        T
       </code>
       instantiation of
       <code class="calibre21">
        operator+
       </code>
       is a
       <code class="calibre21">
        friend
       </code>
       . In other words, there is a one-to-one mapping of friends between the class instantiations and the function instantiations. Note particularly the explicit template specification
       <code class="calibre21">
        &lt;T&gt;
       </code>
       on
       <code class="calibre21">
        operator+
       </code>
       . This syntax tells the compiler that
       <code class="calibre21">
        operator+
       </code>
       is itself a template.
      </p>
      <p class="calibre13">
       This friend
       <code class="calibre21">
        operator+
       </code>
       can be tested as follows. The following code first defines two helper function templates:
       <code class="calibre21">
        fillGrid()
       </code>
       , which fills any
       <code class="calibre21">
        Grid
       </code>
       with increasing numbers, and
       <code class="calibre21">
        printGrid()
       </code>
       , which prints any
       <code class="calibre21">
        Grid
       </code>
       to the console.
      </p>
      <pre class="calibre26" id="c12-code-0087"><code class="calibre21">template &lt;typename T&gt; void fillGrid(Grid&lt;T&gt;&amp; grid)</code>
<code class="calibre21">{</code>
<code class="calibre21">    T index { 0 };</code>
<code class="calibre21">    for (size_t y { 0 }; y &lt; grid.getHeight(); ++y) {</code>
<code class="calibre21">        for (size_t x { 0 }; x &lt; grid.getWidth(); ++x) {</code>
<code class="calibre21">            grid.at(x, y) = ++index;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; void printGrid(const Grid&lt;T&gt;&amp; grid)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t y { 0 }; y &lt; grid.getHeight(); ++y) {</code>
<code class="calibre21">        for (size_t x { 0 }; x &lt; grid.getWidth(); ++x) {</code>
<code class="calibre21">            const auto&amp; element { grid.at(x, y) };</code>
<code class="calibre21">            if (element.has_value()) { print("{}\t", element.value()); }</code>
<code class="calibre21">            else { print("n/a\t"); }</code>
<code class="calibre21">        }</code>
<code class="calibre21">        println("");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="484" class="calibre20" epub:type="pagebreak" id="Page_484" role="doc-pagebreak"></span><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Grid&lt;int&gt; grid1 { 2, 2 };</code>
<code class="calibre21">    Grid&lt;int&gt; grid2 { 3, 3 };</code>
<code class="calibre21">    fillGrid(grid1);   println("grid1:");     printGrid(grid1);</code>
<code class="calibre21">    fillGrid(grid2);   println("\ngrid2:");   printGrid(grid2);</code>
<code class="calibre21">    <b class="calibre14">auto result { grid1 + grid2 };</b></code>
<code class="calibre21">    println("\ngrid1 + grid2:");   printGrid(result);</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0049">
      </span>
      <h3 class="calibre27" id="head-3-275">
       More on Template Type Parameter Deduction
      </h3>
      <p class="calibre13" id="c12-para-0183">
       The compiler deduces the type of function template parameters based on the arguments passed to the function template. Template parameters that cannot be deduced have to be specified explicitly.
      </p>
      <p class="calibre13">
       For example, the following
       <code class="calibre21">
        add()
       </code>
       function template requires three template parameters: the type of the return value and the types of the two operands:
      </p>
      <pre class="calibre26" id="c12-code-0088"><code class="calibre21">template &lt;typename RetType, typename T1, typename T2&gt;</code>
<code class="calibre21">RetType add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13">
       You can call this function template specifying all three parameters as follows:
      </p>
      <pre class="calibre26" id="c12-code-0089"><code class="calibre21">auto result { add&lt;long long, int, int&gt;(1, 2) };</code></pre>
      <p class="calibre13">
       However, because the template parameters
       <code class="calibre21">
        T1
       </code>
       and
       <code class="calibre21">
        T2
       </code>
       are parameters to the function, the compiler can deduce those two parameters, so you can call
       <code class="calibre21">
        add()
       </code>
       by only specifying the type for the return value:
      </p>
      <pre class="calibre26" id="c12-code-0090"><code class="calibre21">auto result { add&lt;long long&gt;(1, 2) };</code></pre>
      <p class="calibre13">
       This works only when the parameters to deduce are last in the list of parameters. Suppose the function template is defined as follows:
      </p>
      <pre class="calibre26" id="c12-code-0091"><code class="calibre21"><b class="calibre14">template &lt;typename T1, typename RetType, typename T2&gt;</b></code>
<code class="calibre21">RetType add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13">
       You have to specify
       <code class="calibre21">
        RetType
       </code>
       , because the compiler cannot deduce that type. However, because
       <code class="calibre21">
        RetType
       </code>
       is the second parameter, you have to explicitly specify
       <code class="calibre21">
        T1
       </code>
       as well:
      </p>
      <pre class="calibre26" id="c12-code-0092"><code class="calibre21">auto result { add&lt;int, long long&gt;(1, 2) };</code></pre>
      <p class="calibre13">
       You can also provide a default value for the return type template parameter so that you can call
       <code class="calibre21">
        add()
       </code>
       without specifying any types:
      </p>
      <pre class="calibre26" id="c12-code-0093"><code class="calibre21"><b class="calibre14">template &lt;typename RetType = long long, typename T1, typename T2&gt;</b></code>
<code class="calibre21">RetType add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code>
<code class="calibre21">…</code>
<code class="calibre21"><b class="calibre14">auto result { add(1, 2) };</b></code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0050">
      </span>
      <h3 class="calibre27" id="head-3-276">
       Return Type of Function Templates
      </h3>
      <p class="calibre13">
       Continuing the example of the
       <code class="calibre21">
        add()
       </code>
       function template, wouldn't it be nice to let the compiler deduce the type of the return value? It would; however, the return type depends on the template type parameters, so how can you do this? For example, take the following function template:
      </p>
      <pre class="calibre26" id="c12-code-0094"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21"><i class="calibre18">RetType</i> add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13" id="c12-para-0191">
       <span aria-label="485" class="calibre20" epub:type="pagebreak" id="Page_485" role="doc-pagebreak">
       </span>
       In this example,
       <i class="calibre18">
        RetType
       </i>
       should be the type of the expression
       <code class="calibre21">
        t1+t2
       </code>
       , but you don't know this because you don't know what
       <code class="calibre21">
        T1
       </code>
       and
       <code class="calibre21">
        T2
       </code>
       are.
      </p>
      <p class="calibre13">
       As discussed in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       , since C++14 you can ask the compiler to automatically deduce the return type for a function. So you can simply write
       <code class="calibre21">
        add()
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c12-code-0095"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21"><b class="calibre14">auto</b> add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13" id="c12-para-0193">
       However, using
       <code class="calibre21">
        auto
       </code>
       to deduce the type of an expression strips away reference and
       <code class="calibre21">
        const
       </code>
       qualifiers, while
       <code class="calibre21">
        decltype
       </code>
       does not strip those. This stripping is fine for the
       <code class="calibre21">
        add()
       </code>
       function template because
       <code class="calibre21">
        operator+
       </code>
       usually returns a new object anyway, but this stripping might not be desirable for certain other function templates, so let's see how you can avoid it.
      </p>
      <p class="calibre13">
       Before continuing with the function template examples, however, let's first look at the differences between
       <code class="calibre21">
        auto
       </code>
       and
       <code class="calibre21">
        decltype
       </code>
       using a non-template example. Suppose you have the following function:
      </p>
      <pre class="calibre26" id="c12-code-0096"><code class="calibre21">const std::string message { "Test" };</code>
<code class="calibre21"> </code>
<code class="calibre21">const std::string&amp; getString() { return message; }</code></pre>
      <p class="calibre13">
       You can call
       <code class="calibre21">
        getString()
       </code>
       and store the result in a variable with the type specified as
       <code class="calibre21">
        auto
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c12-code-0097"><code class="calibre21">auto s1 { getString() };</code></pre>
      <p class="calibre13">
       Because
       <code class="calibre21">
        auto
       </code>
       strips reference and
       <code class="calibre21">
        const
       </code>
       qualifiers,
       <code class="calibre21">
        s1
       </code>
       is of type
       <code class="calibre21">
        string
       </code>
       , and thus a
       <i class="calibre18">
        copy
       </i>
       is made. If you want a reference-to-
       <code class="calibre21">
        const
       </code>
       , you can explicitly make it a reference and mark it
       <code class="calibre21">
        const
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c12-code-0098"><code class="calibre21">const auto&amp; s2 { getString() };</code></pre>
      <p class="calibre13">
       An alternative solution is to use
       <code class="calibre21">
        decltype
       </code>
       , which does not strip anything:
      </p>
      <pre class="calibre26" id="c12-code-0099"><code class="calibre21">decltype(getString()) s3 { getString() };</code></pre>
      <p class="calibre13">
       In this case,
       <code class="calibre21">
        s3
       </code>
       is of type
       <code class="calibre21">
        const string&amp;
       </code>
       ; however, there is code duplication because you need to specify
       <code class="calibre21">
        getString()
       </code>
       twice, which can be cumbersome when
       <code class="calibre21">
        getString()
       </code>
       is a more complicated expression. This is solved with
       <code class="calibre21">
        decltype(auto)
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0100"><code class="calibre21">decltype(auto) s4 { getString() };</code></pre>
      <p class="calibre13" id="c12-para-0199">
       <code class="calibre21">
        s4
       </code>
       is also of type
       <code class="calibre21">
        const string&amp;
       </code>
       .
      </p>
      <p class="calibre13">
       So, with this knowledge, we can write our
       <code class="calibre21">
        add()
       </code>
       function template using
       <code class="calibre21">
        decltype(auto)
       </code>
       to avoid stripping any
       <code class="calibre21">
        const
       </code>
       and reference qualifiers:
      </p>
      <pre class="calibre26" id="c12-code-0101"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21"><b class="calibre14">decltype(auto)</b> add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13">
       Before C++14—that is, before function return type deduction and
       <code class="calibre21">
        decltype(auto)
       </code>
       were supported—the problem was solved using
       <code class="calibre21">
        decltype(
       </code>
       <i class="calibre18">
        expression
       </i>
       <code class="calibre21">
        )
       </code>
       , introduced with C++11. For example, you would think you could write the following:
      </p>
      <pre class="calibre26" id="c12-code-0102"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21"><b class="calibre14">decltype(t1+t2)</b> add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13" id="c12-para-0202">
       <span aria-label="486" class="calibre20" epub:type="pagebreak" id="Page_486" role="doc-pagebreak">
       </span>
       However, this is wrong. You are using
       <code class="calibre21">
        t1
       </code>
       and
       <code class="calibre21">
        t2
       </code>
       in the beginning of the prototype line, but these are not yet known.
       <code class="calibre21">
        t1
       </code>
       and
       <code class="calibre21">
        t2
       </code>
       become known once the semantic analyzer reaches the end of the parameter list.
      </p>
      <p class="calibre13">
       This problem used to be solved with the
       <i class="calibre18">
        alternative function syntax
       </i>
       . Note that with this syntax,
       <code class="calibre21">
        auto
       </code>
       is used at the beginning of the prototype line, and the actual return type is specified after the parameter list (
       <i class="calibre18">
        trailing return type
       </i>
       ); thus, the names of the parameters (and their types, and consequently, the type
       <code class="calibre21">
        t1+t2
       </code>
       ) are known:
      </p>
      <pre class="calibre26" id="c12-code-0103"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21"><b class="calibre14">auto</b> add(const T1&amp; t1, const T2&amp; t2) <b class="calibre14">-&gt; decltype(t1+t2)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return t1 + t2;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Another option is to use
       <code class="calibre21">
        std::declval&lt;&gt;()
       </code>
       , which returns an rvalue reference to the type you requested. This is not a fully constructed object, as no constructor gets called! You cannot use the object at run time. You should only use it, for example, in combination with
       <code class="calibre21">
        decltype()
       </code>
       . It comes in handy in generic code and when you need to create an object of some unknown type. In that case, you can't call any sensible constructor as you don't know what constructors the unknown type supports. Let's look at an example. The earlier
       <code class="calibre21">
        add()
       </code>
       code snippet with an explicit return type of
       <code class="calibre21">
        decltype(t1+t2)
       </code>
       at the beginning of the prototype line doesn't compile because the names
       <code class="calibre21">
        t1
       </code>
       and
       <code class="calibre21">
        t2
       </code>
       are not yet known at that time. To remedy this, you can use
       <code class="calibre21">
        declval&lt;&gt;()
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c12-code-0104"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21"><b class="calibre14">decltype(std::declval&lt;T1&gt;() + std::declval&lt;T2&gt;())</b> add(const T1&amp; t1, const T2&amp; t2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return t1 + t2;</code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0206">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Now that C++ supports
          </i>
          <code class="calibre21">
           auto
          </code>
          <i class="calibre18">
           return type deduction and
          </i>
          <code class="calibre21">
           decltype(auto)
          </code>
          <i class="calibre18">
           , it is recommended to use one of these mechanisms, instead of the alternative function syntax or
          </i>
          <code class="calibre21">
           declval&lt;&gt;()
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0052">
      </span>
      <h3 class="calibre27" id="head-3-277">
       Abbreviated Function Template Syntax
      </h3>
      <p class="calibre13">
       The
       <i class="calibre18">
        abbreviated function template syntax
       </i>
       makes writing function templates easier. Let's take another look at the
       <code class="calibre21">
        add()
       </code>
       function template from the previous section:
      </p>
      <pre class="calibre26" id="c12-code-0105"><code class="calibre21">template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21">decltype(auto) add(const T1&amp; t1, const T2&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13">
       Looking at this, it's a rather verbose syntax to specify a simple function template. With the abbreviated function template syntax, this can be written more elegantly as follows:
      </p>
      <pre class="calibre26" id="c12-code-0106"><code class="calibre21">decltype(auto) add(const <b class="calibre14">auto</b>&amp; t1, const <b class="calibre14">auto</b>&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13" id="c12-para-0209">
       With this syntax, there is no template header,
       <code class="calibre21">
        template&lt;&gt;
       </code>
       , anymore to specify template parameters. Instead, where previously the implementation used
       <code class="calibre21">
        T1
       </code>
       and
       <code class="calibre21">
        T2
       </code>
       as types for the parameters of the function, they are now specified as
       <code class="calibre21">
        auto
       </code>
       . This abbreviated syntax is just syntactical sugar; the compiler
       <span aria-label="487" class="calibre20" epub:type="pagebreak" id="Page_487" role="doc-pagebreak">
       </span>
       automatically translates this abbreviated implementation to the longer original code. Basically, every function parameter that is specified as
       <code class="calibre21">
        auto
       </code>
       becomes a template type parameter.
      </p>
      <p class="calibre13">
       There are two caveats that you have to keep in mind. First, each parameter specified as
       <code class="calibre21">
        auto
       </code>
       becomes a different template type parameter. Suppose you have a function template like this:
      </p>
      <pre class="calibre26" id="c12-code-0107"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">decltype(auto) add(const T&amp; t1, const T&amp; t2) { return t1 + t2; }</code></pre>
      <p class="calibre13" id="c12-para-0211">
       This version has only a single template type parameter, and both parameters to the function,
       <code class="calibre21">
        t1
       </code>
       and
       <code class="calibre21">
        t2
       </code>
       , are of type
       <code class="calibre21">
        const T&amp;
       </code>
       . For such a function template, you cannot use the abbreviated syntax, as that would be translated to a function template having two different template type parameters.
      </p>
      <p class="calibre13" id="c12-para-0212">
       A second issue is that you cannot use the deduced types explicitly in the implementation of the function template, as these automatically deduced types have no name. If you need this, you either need to keep using the longer function template syntax or use
       <code class="calibre21">
        decltype()
       </code>
       to figure out the type.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-145" class="calibre2">
     <span class="calibre" id="c12-sec-0053">
     </span>
     <h2 class="calibre6" id="head-2-145">
      VARIABLE TEMPLATES
     </h2>
     <p class="calibre13">
      In addition to class templates, class member function templates, and function templates, C++ supports
      <i class="calibre18">
       variable templates
      </i>
      . The syntax is as follows:
     </p>
     <pre class="calibre26" id="c12-code-0108"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">constexpr T pi { T { 3.141592653589793238462643383279502884 } };</code></pre>
     <p class="calibre13">
      This is a variable template for the value of π. To get the value of
      <code class="calibre21">
       pi
      </code>
      in a certain type, you use the following syntax:
     </p>
     <pre class="calibre26" id="c12-code-0109"><code class="calibre21">float piFloat { pi&lt;float&gt; };</code>
<code class="calibre21">auto piLongDouble { pi&lt;long double&gt; };</code></pre>
     <p class="calibre13">
      You will always get the closest value of
      <code class="calibre21">
       pi
      </code>
      representable in the requested type. Just like other types of templates, variable templates can also be specialized.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c12-para-0216">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          The C++ Standard Library includes
         </i>
         <code class="calibre21">
          &lt;numbers&gt;
         </code>
         <i class="calibre18">
          , which defines a selection of commonly used mathematical constants, including π:
         </i>
         <code class="calibre21">
          std::numbers::pi
         </code>
         <i class="calibre18">
          .
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-146" class="calibre2">
     <span class="calibre" id="c12-sec-0055">
     </span>
     <h2 class="calibre6" id="head-2-146">
      CONCEPTS
     </h2>
     <p class="calibre13" id="c12-para-0217">
      <i class="calibre18">
       Concepts
      </i>
      are named requirements used to constrain template arguments of class and function templates. These are written as predicates and evaluated at compile time to verify template arguments passed to a template. The main goal of concepts is to make template-related compiler errors more human readable. Everybody has encountered the situation where the compiler spews out hundreds or even thousands of lines of errors when you provide the wrong argument for a class or function template. It's not always easy to dig through those compiler errors to find the root cause.
     </p>
     <p class="calibre13" id="c12-para-0218">
      The reason why the compiler generates that many errors is that the compiler just blindly instantiates templates with the template arguments you provide. Once a template is instantiated, it is compiled,
      <span aria-label="488" class="calibre20" epub:type="pagebreak" id="Page_488" role="doc-pagebreak">
      </span>
      and only then is the compiler able to find out if the provided template type arguments do not support certain operations required deep down in the template implementation. This can be far away from the place where you instantiated a template, hence the myriad of errors. With concepts, the compiler can verify that provided template arguments satisfy certain constraints before it even starts instantiating a template.
     </p>
     <p class="calibre13">
      Concepts allow the compiler to output readable error messages if certain type constraints are not satisfied. As such, to get meaningful semantical errors, it's recommended to write concepts to model semantic requirements. Avoid concepts that validate only for syntactic aspects without any semantic meaning, such as a concept that just checks if a type supports
      <code class="calibre21">
       operator+
      </code>
      . Such a concept would check only for syntax, not semantics. An
      <code class="calibre21">
       std::string
      </code>
      supports
      <code class="calibre21">
       operator+
      </code>
      , but obviously, it has a completely different meaning compared to
      <code class="calibre21">
       operator+
      </code>
      for integers. On the other hand, concepts such as sortable and swappable are good examples of concepts modeling some semantic meaning.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c12-para-0220">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          When writing concepts, make sure they model semantics and not just syntax
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c12-para-0221">
      Let's start by looking at the syntax to write concepts.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0057">
      </span>
      <h3 class="calibre27" id="head-3-278">
       Syntax
      </h3>
      <p class="calibre13">
       The syntax of a
       <i class="calibre18">
        concept definition
       </i>
       , a template for a named set of
       <i class="calibre18">
        constraints
       </i>
       , is as follows:
      </p>
      <pre class="calibre26" id="c12-code-0110"><code class="calibre21">template &lt;parameter-list&gt;</code>
<code class="calibre21">concept concept-name = constraints-expression;</code></pre>
      <p class="calibre13" id="c12-para-0223">
       It starts with a familiar template header,
       <code class="calibre21">
        template&lt;&gt;
       </code>
       , but unlike class and function templates, concepts are never instantiated. Next, a new keyword,
       <code class="calibre21">
        concept
       </code>
       , is used followed by the name of the concept. You can use any name you want. The
       <code class="calibre21">
        constraints-expression
       </code>
       can be any constant expression, that is, any expression that can be evaluated at compile time. The
       <i class="calibre18">
        constraints expression
       </i>
       must result in a Boolean value (exactly
       <code class="calibre21">
        bool
       </code>
       as the compiler will not insert any type conversions). This can also be a conjunction,
       <code class="calibre21">
        &amp;&amp;
       </code>
       , or disjunction,
       <code class="calibre21">
        ||
       </code>
       , of constant expressions. The constraints are never evaluated at run time. Constraints expressions are discussed in detail in the next section.
      </p>
      <p class="calibre13">
       A
       <i class="calibre18">
        concept expression
       </i>
       has the following syntax:
      </p>
      <pre class="calibre26" id="c12-code-0111"><code class="calibre21">concept-name&lt;argument-list&gt;</code></pre>
      <p class="calibre13" id="c12-para-0225">
       Concept expressions evaluate to either
       <code class="calibre21">
        true
       </code>
       or
       <code class="calibre21">
        false
       </code>
       . If it evaluates to
       <code class="calibre21">
        true
       </code>
       , then it is said that the given template arguments
       <i class="calibre18">
        model the concept
       </i>
       . The next section gives an example.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0058">
      </span>
      <h3 class="calibre27" id="head-3-279">
       Constraints Expression
      </h3>
      <p class="calibre13">
       Constant expressions that evaluate to a Boolean can directly be used as constraints for a concept definition. It must evaluate exactly to a Boolean without any type conversions. Here's an example:
      </p>
      <pre class="calibre26" id="c12-code-0112"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept Big = sizeof(T)&gt; 4;</code></pre>
      <p class="calibre13">
       <span aria-label="489" class="calibre20" epub:type="pagebreak" id="Page_489" role="doc-pagebreak">
       </span>
       Based on this concept, the concept expressions
       <code class="calibre21">
        Big&lt;char&gt;
       </code>
       and
       <code class="calibre21">
        Big&lt;short&gt;
       </code>
       usually evaluate to
       <code class="calibre21">
        false
       </code>
       , while concept expressions like
       <code class="calibre21">
        Big&lt;long double&gt;
       </code>
       will usually evaluate to
       <code class="calibre21">
        true
       </code>
       . A concept expression evaluates to a Boolean value at compile time that can be verified using a
       <i class="calibre18">
        static assertion
       </i>
       . A static assertion uses
       <code class="calibre21">
        static_assert()
       </code>
       and allows certain conditions to be asserted at compile time. An assertion is something that needs to be
       <code class="calibre21">
        true
       </code>
       . If an assertion is
       <code class="calibre21">
        false
       </code>
       , the compiler issues an error.
       <a class="calibre5" href="c26.xhtml">
        Chapter 26
       </a>
       discusses static assertions in a bit more detail, but their use with concept expressions is straightforward. The following code asserts that
       <code class="calibre21">
        Big&lt;char&gt;
       </code>
       and
       <code class="calibre21">
        Big&lt;short&gt;
       </code>
       indeed evaluate to
       <code class="calibre21">
        false
       </code>
       , and that
       <code class="calibre21">
        Big&lt;long double&gt;
       </code>
       evaluates to
       <code class="calibre21">
        true
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0113"><code class="calibre21">static_assert(!Big&lt;char&gt;);</code>
<code class="calibre21">static_assert(!Big&lt;short&gt;);</code>
<code class="calibre21">static_assert(Big&lt;long double&gt;);</code></pre>
      <p class="calibre13">
       When compiling this, there shouldn't be any compilation errors. However, if you remove the exclamation point in the first line, then the compiler will issue an error similar to the following:
      </p>
      <pre class="calibre26" id="c12-code-0114"><code class="calibre21">error C2607: static assertion failed</code>
<code class="calibre21">01_Big.cpp(4,15): message : the concept 'Big&lt;char&gt;' evaluated to false</code>
<code class="calibre21">01_Big.cpp(2,25): message : the constraint was not satisfied</code></pre>
      <p class="calibre13" id="c12-para-0229">
       Together with the introduction of concepts, a new type of constant expression is introduced called a
       <i class="calibre18">
        requires expression
       </i>
       , used to define the syntactical requirements of concepts, and explained next.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0059">
       </span>
       <h4 class="calibre29" id="head-4-230">
        Requires Expressions
       </h4>
       <p class="calibre13">
        A requires expression has the following syntax:
       </p>
       <pre class="calibre26" id="c12-code-0115"><code class="calibre21">requires (parameter-list) { requirements; }</code></pre>
       <p class="calibre13" id="c12-para-0231">
        The
        <code class="calibre21">
         (parameter-list)
        </code>
        is optional and is syntactically similar to the parameter list of functions, except that default argument values are not allowed. The parameter list of a requires expression is used to introduce named variables that are local to the body of the requires expression. The body of a requires expression cannot have regular variable declarations.
       </p>
       <p class="calibre13" id="c12-para-0232">
        The
        <code class="calibre21">
         requirements
        </code>
        is a sequence of requirements. Each requirement must end with a semicolon.
       </p>
       <p class="calibre13" id="c12-para-0233">
        There are four types of requirements: simple, type, compound, and nested requirements, all discussed in the upcoming sections.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0060">
        </span>
        <h5 class="calibre35" id="head-5-80">
         Simple Requirements
        </h5>
        <p class="calibre13" id="c12-para-0234">
         A
         <i class="calibre18">
          simple requirement
         </i>
         is an arbitrary expression statement, not starting with
         <code class="calibre21">
          requires
         </code>
         . Variable declarations, loops, conditional statements, and so on are not allowed. This expression statement is never evaluated; the compiler simply validates that it compiles.
        </p>
        <p class="calibre13">
         For example, the following concept definition specifies that a type
         <code class="calibre21">
          T
         </code>
         must be incrementable; that is, type
         <code class="calibre21">
          T
         </code>
         must support the post- and prefix
         <code class="calibre21">
          ++
         </code>
         operator. Remember, you cannot define local variables in the body of a requires expression; instead, you define those as parameters,
         <code class="calibre21">
          x
         </code>
         in this example.
        </p>
        <pre class="calibre26" id="c12-code-0116"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept Incrementable = requires(T x) { x++; ++x; };</code></pre>
       </section>
       <span aria-label="490" class="calibre20" epub:type="pagebreak" id="Page_490" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0061">
        </span>
        <h5 class="calibre35" id="head-5-81">
         Type Requirements
        </h5>
        <p class="calibre13">
         A
         <i class="calibre18">
          type requirement
         </i>
         verifies that a certain type is valid. It starts with the keyword
         <code class="calibre21">
          typename
         </code>
         , followed by the type to check. For example, the following concept requires that a certain type
         <code class="calibre21">
          T
         </code>
         has a
         <code class="calibre21">
          value_type
         </code>
         member:
        </p>
        <pre class="calibre26" id="c12-code-0117"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept C = requires { typename T::value_type; };</code></pre>
        <p class="calibre13">
         A type requirement can also be used to verify that a certain template can be instantiated with a given type. Here's an example:
        </p>
        <pre class="calibre26" id="c12-code-0118"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept C = requires { typename SomeTemplate&lt;T&gt;; };</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0062">
        </span>
        <h5 class="calibre35" id="head-5-82">
         Compound Requirements
        </h5>
        <p class="calibre13">
         A compound requirement can be used to verify that something does not throw any exceptions and/or to verify that a certain function returns a certain type. The syntax is as follows:
        </p>
        <pre class="calibre26" id="c12-code-0119"><code class="calibre21">{ expression } noexcept -&gt; type-constraint;</code></pre>
        <p class="calibre13" id="c12-para-0239">
         Both the
         <code class="calibre21">
          noexcept
         </code>
         and
         <code class="calibre21">
          -&gt;type-constraint
         </code>
         are optional. There is no semicolon after
         <code class="calibre21">
          expression
         </code>
         inside the curly brackets, but there is a semicolon at the end of the compound requirement.
        </p>
        <p class="calibre13">
         Let's look at an example. The following concept requires that a given type has a non-throwing destructor and non-throwing
         <code class="calibre21">
          swap()
         </code>
         member function:
        </p>
        <pre class="calibre26" id="c12-code-0120"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept C = requires (T x, T y) {</code>
<code class="calibre21">    { x.˜T()} noexcept;</code>
<code class="calibre21">    { x.swap(y) } noexcept;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         The
         <code class="calibre21">
          type-constraint
         </code>
         can be any
         <i class="calibre18">
          type constraint
         </i>
         . A type constraint is simply the name of a concept with zero or more template type arguments. The type of the expression on the left of the arrow is automatically passed as the first template type argument to the type constraint. Hence, a type constraint always has one less argument than the number of template type parameters of the corresponding concept definition. For example, a type constraint for a concept definition with a single template type does not require any template arguments; you can either specify empty brackets,
         <code class="calibre21">
          &lt;&gt;
         </code>
         , or omit them. This might sound tricky, but an example will make this clear. The following concept validates that a given type has a member function called
         <code class="calibre21">
          size()
         </code>
         returning a type that is convertible to a
         <code class="calibre21">
          size_t
         </code>
         . It also validates that
         <code class="calibre21">
          size()
         </code>
         is marked as
         <code class="calibre21">
          const
         </code>
         because the parameter
         <code class="calibre21">
          x
         </code>
         is of type
         <code class="calibre21">
          const T
         </code>
         .
        </p>
        <pre class="calibre26" id="c12-code-0121"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept C = requires (const T x) {</code>
<code class="calibre21">    { x.size() } -&gt; convertible_to&lt;size_t&gt;;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c12-para-0242">
         <code class="calibre21">
          std::convertible_to&lt;From, To&gt;
         </code>
         is a concept predefined by the Standard Library in
         <code class="calibre21">
          &lt;concepts&gt;
         </code>
         and has two template type parameters. The type of the expression on the left of the arrow is automatically passed as the first template type argument to the
         <code class="calibre21">
          convertible_to
         </code>
         type constraint. As such, you only need to specify the
         <code class="calibre21">
          To
         </code>
         template type argument,
         <code class="calibre21">
          size_t
         </code>
         in this case.
        </p>
        <p class="calibre13">
         <span aria-label="491" class="calibre20" epub:type="pagebreak" id="Page_491" role="doc-pagebreak">
         </span>
         Here is another example. The following concept requires that instances of a type
         <code class="calibre21">
          T
         </code>
         are comparable:
        </p>
        <pre class="calibre26" id="c12-code-0122"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept Comparable = requires(const T a, const T b) {</code>
<code class="calibre21">    { a == b } -&gt; convertible_to&lt;bool&gt;;</code>
<code class="calibre21">    { a &lt; b } -&gt; convertible_to&lt;bool&gt;;</code>
<code class="calibre21">    <span class="color">// … similar for the other comparison operators …</span></code>
<code class="calibre21">};</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c12-para-0245">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Remember, the
            </i>
            <code class="calibre21">
             type-constraint
            </code>
            <i class="calibre18">
             in a compound requirement must be a
             <b class="calibre14">
              type constraint
             </b>
             , never a type. The following, for instance, will not compile:
            </i>
           </p>
           <pre class="calibre26" id="c12-code-0123"><code class="calibre21">{ a == b } -&gt; bool;</code></pre>
           <p class="calibre25" id="c12-para-0247">
            <i class="calibre18">
             Instead, a correct type constraint could be the following:
            </i>
           </p>
           <pre class="calibre26" id="c12-code-0124"><code class="calibre21">{ a == b } -&gt; convertible_to&lt;bool&gt;;</code></pre>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c12-sec-0065">
        </span>
        <h5 class="calibre35" id="head-5-83">
         Nested Requirements
        </h5>
        <p class="calibre13">
         A requires expression can have
         <i class="calibre18">
          nested requirements
         </i>
         . For example, the following is a concept that requires a type to support the pre- and postfix increment and decrement operations. Additionally, the requires expression has a nested requirement to verify that the size of the type is 4 bytes.
        </p>
        <pre class="calibre26" id="c12-code-0125"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept C = requires (T t) {</code>
<code class="calibre21">    ++t; --t; t++; t--;</code>
<code class="calibre21">    <b class="calibre14">requires sizeof(t) == 4;</b></code>
<code class="calibre21">};</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0066">
       </span>
       <h4 class="calibre29" id="head-4-231">
        Combining Concept Expressions
       </h4>
       <p class="calibre13">
        Existing concept expressions can be combined using conjunctions (
        <code class="calibre21">
         &amp;&amp;
        </code>
        ) and disjunctions (
        <code class="calibre21">
         ||
        </code>
        ). For example, suppose you have a
        <code class="calibre21">
         Decrementable
        </code>
        concept, similar to
        <code class="calibre21">
         Incrementable
        </code>
        ; the following example shows a concept that requires a type to be both incrementable and decrementable:
       </p>
       <pre class="calibre26" id="c12-code-0126"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept IncrementableAndDecrementable = Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt;;</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0067">
      </span>
      <h3 class="calibre27" id="head-3-280">
       Predefined Standard Concepts
      </h3>
      <p class="calibre13">
       The Standard Library defines a whole collection of predefined concepts, more than 100 of them, divided into a number of categories. The following list gives just a few example concepts of each category, all defined in
       <code class="calibre21">
        &lt;concepts&gt;
       </code>
       and in the
       <code class="calibre21">
        std
       </code>
       namespace:
      </p>
      <ul class="none" id="c12-list-0003">
       <li class="calibre9" id="c12-li-0019">
        <b class="calibre14">
         Core language concepts:
        </b>
        <code class="calibre21">
         same_as
        </code>
        ,
        <code class="calibre21">
         derived_from
        </code>
        ,
        <code class="calibre21">
         convertible_to
        </code>
        ,
        <code class="calibre21">
         integral
        </code>
        ,
        <code class="calibre21">
         floating_point
        </code>
        ,
        <code class="calibre21">
         copy_constructible
        </code>
        , and so on
       </li>
       <li class="calibre9" id="c12-li-0020">
        <b class="calibre14">
         Comparison concepts:
        </b>
        <code class="calibre21">
         equality_comparable
        </code>
        ,
        <code class="calibre21">
         totally_ordered
        </code>
        , and so on
       </li>
       <li class="calibre9" id="c12-li-0021">
        <b class="calibre14">
         Object concepts:
        </b>
        <code class="calibre21">
         movable
        </code>
        ,
        <code class="calibre21">
         copyable
        </code>
        , and so on
       </li>
       <li class="calibre9" id="c12-li-0022">
        <b class="calibre14">
         Callable concepts:
        </b>
        <code class="calibre21">
         invocable
        </code>
        ,
        <code class="calibre21">
         predicate
        </code>
        , and so on
       </li>
      </ul>
      <p class="calibre13" id="c12-para-0252">
       <span aria-label="492" class="calibre20" epub:type="pagebreak" id="Page_492" role="doc-pagebreak">
       </span>
       Additionally,
       <code class="calibre21">
        &lt;iterator&gt;
       </code>
       defines iterator-related concepts such as
       <code class="calibre21">
        random_access_iterator
       </code>
       ,
       <code class="calibre21">
        forward_iterator
       </code>
       ,
       <code class="calibre21">
        incrementable
       </code>
       ,
       <code class="calibre21">
        indirectly_copyable
       </code>
       ,
       <code class="calibre21">
        indirectly_swappable
       </code>
       , and so on. A concept such as
       <code class="calibre21">
        indirectly_copyable
       </code>
       is not meant to verify that a given iterator itself is copyable, but rather that the elements pointed to by a given iterator are copyable, hence the “indirectly” part of the name. Finally,
       <code class="calibre21">
        &lt;iterator&gt;
       </code>
       also defines algorithm requirements such as
       <code class="calibre21">
        mergeable
       </code>
       ,
       <code class="calibre21">
        sortable
       </code>
       ,
       <code class="calibre21">
        permutable
       </code>
       , and so on.
      </p>
      <p class="calibre13" id="c12-para-0253">
       The C++ ranges library also provides a number of standard concepts.
       <a class="calibre5" href="c17.xhtml">
        Chapter 17
       </a>
       , “Understanding Iterators and the Ranges Library,” discusses iterators and ranges in detail, while
       <a class="calibre5" href="c20.xhtml">
        Chapter 20
       </a>
       goes deeper into the algorithms provided by the Standard Library. Consult your favorite Standard Library reference for a full list of available standard concepts.
      </p>
      <p class="calibre13">
       If any of these standard concepts is what you need, you can use them directly without having to implement your own. For example, the following concept requires that a type
       <code class="calibre21">
        T
       </code>
       is derived from class
       <code class="calibre21">
        Foo
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0127"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept IsDerivedFromFoo = derived_from&lt;T, Foo&gt;;</code></pre>
      <p class="calibre13">
       The following concept requires that type
       <code class="calibre21">
        T
       </code>
       is convertible to
       <code class="calibre21">
        bool
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0128"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept IsConvertibleToBool = convertible_to&lt;T, bool&gt;;</code></pre>
      <p class="calibre13" id="c12-para-0256">
       More concrete examples follow in the upcoming sections.
      </p>
      <p class="calibre13">
       Of course, these standard concepts can also be combined into more specific concepts. The following concept, for example, requires a type
       <code class="calibre21">
        T
       </code>
       to be both default and copy constructible:
      </p>
      <pre class="calibre26" id="c12-code-0129"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">concept DefaultAndCopyConstructible =</code>
<code class="calibre21">    default_initializable&lt;T&gt; &amp;&amp; copy_constructible&lt;T&gt;;</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0259">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Writing semantically complete and correct concepts is not always easy. If possible, use the available standard concepts or combinations of them to constrain your types
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0069">
      </span>
      <h3 class="calibre27" id="head-3-281">
       Type-Constrained auto
      </h3>
      <p class="calibre13" id="c12-para-0260">
       Type constraints can be used to constrain variables defined with
       <code class="calibre21">
        auto
       </code>
       type deduction, to constrain return types when using function return type deduction, to constrain parameters in abbreviated function templates and generic lambda expressions, and so on. Using type constraints with
       <code class="calibre21">
        auto
       </code>
       type deduction makes the code more self-documenting. It also results in better error messages if the constraints get violated at some point, as the error then points to the variable definition instead of to some unsupported operation later in the code.
      </p>
      <p class="calibre13">
       For example, the following compiles without errors because the deduced type is
       <code class="calibre21">
        int
       </code>
       , which models the
       <code class="calibre21">
        Incrementable
       </code>
       concept:
      </p>
      <pre class="calibre26" id="c12-code-0130"><code class="calibre21">Incrementable auto value1 { 1 };</code></pre>
      <p class="calibre13">
       <span aria-label="493" class="calibre20" epub:type="pagebreak" id="Page_493" role="doc-pagebreak">
       </span>
       However, the following causes a compilation error stating that the constraints are not satisfied. The deduced type is
       <code class="calibre21">
        std::string
       </code>
       , due to the use of the standard literal
       <code class="calibre21">
        s
       </code>
       , and
       <code class="calibre21">
        string
       </code>
       does not model
       <code class="calibre21">
        Incrementable
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0131"><code class="calibre21">Incrementable auto value { "abc"s };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0070">
      </span>
      <h3 class="calibre27" id="head-3-282">
       Type Constraints and Function Templates
      </h3>
      <p class="calibre13">
       There are several syntactically different ways to use type constraints with function templates. A first syntax is to use a
       <i class="calibre18">
        requires clause
       </i>
       as follows:
      </p>
      <pre class="calibre26" id="c12-code-0132"><code class="calibre21">template &lt;typename T&gt; <b class="calibre14">requires constraints-expression</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        constraints-expression
       </code>
       can be any constant expression, or a conjunction and disjunction of constant expressions, resulting in a Boolean type, just as the
       <code class="calibre21">
        constraints-expression
       </code>
       of a concept definition. For example, the constraints expression can be a concept expression:
      </p>
      <pre class="calibre26" id="c12-code-0133"><code class="calibre21">template &lt;typename T&gt; requires <b class="calibre14">Incrementable&lt;T&gt;</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       or a predefined standard concept:
      </p>
      <pre class="calibre26" id="c12-code-0134"><code class="calibre21">template &lt;typename T&gt; requires <b class="calibre14">convertible_to&lt;T, bool&gt;</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       or a requires expression (note the two
       <code class="calibre21">
        requires
       </code>
       keywords):
      </p>
      <pre class="calibre26" id="c12-code-0135"><code class="calibre21">template &lt;typename T&gt; requires <b class="calibre14">requires(T x) { x++; ++x; }</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       or any constant expression resulting in a Boolean:
      </p>
      <pre class="calibre26" id="c12-code-0136"><code class="calibre21">template &lt;typename T&gt; requires <b class="calibre14">(sizeof(T) == 4)</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       or a combination of conjunctions and disjunctions:
      </p>
      <pre class="calibre26" id="c12-code-0137"><code class="calibre21">template &lt;typename T&gt; requires <b class="calibre14">Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt;</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       or a type trait (see
       <a class="calibre5" href="c26.xhtml">
        Chapter 26
       </a>
       ):
      </p>
      <pre class="calibre26" id="c12-code-0138"><code class="calibre21">template &lt;typename T&gt; requires <b class="calibre14">is_arithmetic_v&lt;T&gt;</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       The requires clause can also be specified after the function header, called a
       <i class="calibre18">
        trailing requires clause
       </i>
       :
      </p>
      <pre class="calibre26" id="c12-code-0139"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void process(const T&amp; t) <b class="calibre14">requires Incrementable&lt;T&gt;;</b></code></pre>
      <p class="calibre13">
       Another syntax is to use the familiar
       <code class="calibre21">
        template&lt;&gt;
       </code>
       syntax, but instead of using
       <code class="calibre21">
        typename
       </code>
       (or
       <code class="calibre21">
        class
       </code>
       ), you use a type constraint. Here are two examples:
      </p>
      <pre class="calibre26" id="c12-code-0140"><code class="calibre21">template &lt;convertible_to&lt;bool&gt; T&gt;</code>
<code class="calibre21">void process(const T&amp; t);</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;Incrementable T&gt;</code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       <span aria-label="494" class="calibre20" epub:type="pagebreak" id="Page_494" role="doc-pagebreak">
       </span>
       These are type constraints as discussed in the section on compound requirements, so they require one less template type parameter than usual. Concretely:
      </p>
      <pre class="calibre26" id="c12-code-0141"><code class="calibre21">template &lt;<b class="calibre14">convertible_to&lt;bool&gt; T</b>&gt;</code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       is entirely analogous to:
      </p>
      <pre class="calibre26" id="c12-code-0142"><code class="calibre21">template &lt;typename T&gt; <b class="calibre14">requires convertible_to&lt;T, bool&gt;</b></code>
<code class="calibre21">void process(const T&amp; t);</code></pre>
      <p class="calibre13">
       Yet another, more elegant, syntax to use type constraints combines the abbreviated function template syntax, discussed earlier in this chapter, and type constraints, resulting in the following nice and compact syntax. Mind you, even though there is no template header,
       <code class="calibre21">
        template&lt;&gt;
       </code>
       , don't be fooled:
       <code class="calibre21">
        process()
       </code>
       is still a function template.
      </p>
      <pre class="calibre26" id="c12-code-0143"><code class="calibre21">void process(const Incrementable auto&amp; t);</code></pre>
      <p class="calibre13">
       Compilation errors when requirements are violated are pretty readable. Calling
       <code class="calibre21">
        process()
       </code>
       with an integer argument works as expected. Calling it with an
       <code class="calibre21">
        std::string
       </code>
       , for instance, results in an error complaining about unsatisfied constraints. As an example, the Clang compiler produces the following errors. On first sight, it might still look a bit verbose, but it's surprisingly readable.
      </p>
      <pre class="calibre26" id="c12-code-0144"><code class="calibre21">&lt;source&gt;:17:2: error: no matching function for call to 'process'</code>
<code class="calibre21">        process(str);</code>
<code class="calibre21">        ^˜˜˜˜˜˜</code>
<code class="calibre21">&lt;source&gt;:9:6: note: candidate template ignored: constraints not satisfied [with T = std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;]</code>
<code class="calibre21">void process(const T&amp; t)</code>
<code class="calibre21">     ^</code>
<code class="calibre21">&lt;source&gt;:8:11: note: because 'std::__cxx11::<b class="calibre14">basic_string</b>&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;' <b class="calibre14">does not satisfy 'Incrementable'</b></code>
<code class="calibre21">template &lt;Incrementable T&gt;</code>
<code class="calibre21">          ^</code>
<code class="calibre21">&lt;source&gt;:6:42: note: because 'x++' would be invalid: cannot increment value of type 'std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;'</code>
<code class="calibre21">concept Incrementable = requires(T x) { x++; ++x; };</code></pre>
      <p class="calibre13">
       You are free to use whatever syntax suits you best, but in certain cases, you don't have a choice but to use the trailing requires clause syntax:
      </p>
      <ul class="check" id="c12-list-0004">
       <li class="calibre9" id="c12-li-0023">
        When the constraint uses parameter names of the function, the trailing requires clause syntax must be used; otherwise, the function template's parameter names are not yet in scope.
       </li>
       <li class="calibre9" id="c12-li-0024">
        To constrain a member function of a class template that is defined directly in the class template's body, the trailing requires clause syntax is required because such a member function doesn't have a template header.
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c12-para-0277">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           With the introduction of type constraints, unconstrained template type parameters for function and class templates should be a thing of the past. Every template type inevitably needs to satisfy certain constraints directly related to what you do with that type in the implementation. Hence, you should put a type constraint on it so the compiler can verify it at compile time
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <span aria-label="495" class="calibre20" epub:type="pagebreak" id="Page_495" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c12-sec-0072">
       </span>
       <h4 class="calibre29" id="head-4-232">
        Constraint Subsumption
       </h4>
       <p class="calibre13">
        You can overload a function template with different type constraints. The compiler always uses the template with the most specific constraints; the more specific constraints
        <i class="calibre18">
         subsume
        </i>
        /
        <i class="calibre18">
         imply
        </i>
        the lesser constraints. Here's an example:
       </p>
       <pre class="calibre26" id="c12-code-0145"><code class="calibre21">template &lt;typename T&gt; requires integral&lt;T&gt;</code>
<code class="calibre21">void process(const T&amp; t) { println("integral&lt;T&gt;"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; requires (integral&lt;T&gt; &amp;&amp; sizeof(T) == 4)</code>
<code class="calibre21">void process(const T&amp; t) { println("integral&lt;T&gt; &amp;&amp; sizeof(T) == 4"); }</code></pre>
       <p class="calibre13">
        Suppose you have the following calls to
        <code class="calibre21">
         process()
        </code>
        :
       </p>
       <pre class="calibre26" id="c12-code-0146"><code class="calibre21">process(int { 1 });</code>
<code class="calibre21">process(short { 2 });</code></pre>
       <p class="calibre13">
        Then the output is as follows on a typical system where an
        <code class="calibre21">
         int
        </code>
        has 32 bits and a
        <code class="calibre21">
         short
        </code>
        has 16 bits:
       </p>
       <pre class="calibre26" id="c12-code-0147"><code class="calibre21">integral&lt;T&gt; &amp;&amp; sizeof(T) == 4</code>
<code class="calibre21">integral&lt;T&gt;</code></pre>
       <p class="calibre13" id="c12-para-0281">
        The compiler resolves any subsumption by first normalizing the constraints expressions. During normalization of a constraints expression, all concept expressions are recursively expanded to their definitions until the result is a single constant expression consisting of conjunctions and disjunctions of constant Boolean expressions. A normalized constraints expression then subsumes another one if the compiler can prove that it implies the other one. Only conjunctions and disjunctions are taken into account to prove any subsumption, never negations.
       </p>
       <p class="calibre13" id="c12-para-0282">
        This subsumption reasoning is done only at the syntactical level, not semantically. For example,
        <code class="calibre21">
         sizeof(T)&gt;4
        </code>
        is semantically more specific than
        <code class="calibre21">
         sizeof(T)&gt;=4
        </code>
        , but syntactically the former will not subsume the latter.
       </p>
       <p class="calibre13" id="c12-para-0283">
        One caveat, though, is that type traits, such as the
        <code class="calibre21">
         std::is_arithmetic
        </code>
        trait used earlier, are not expanded during normalization. Hence, if there is a predefined concept and a type trait available, you should use the concept and not the type trait. For example, use the
        <code class="calibre21">
         std::integral
        </code>
        concept instead of the
        <code class="calibre21">
         std::is_integral
        </code>
        type trait.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0073">
      </span>
      <h3 class="calibre27" id="head-3-283">
       Type Constraints and Class Templates
      </h3>
      <p class="calibre13">
       All type constraints examples up to now are using function templates. Type constraints can also be used with class templates, using a similar syntax. As an example, let's revisit the
       <code class="calibre21">
        GameBoard
       </code>
       class template from earlier in this chapter. The following is a new definition for it, requiring its template type parameter to be a derived class of
       <code class="calibre21">
        GamePiece
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0148"><code class="calibre21"><b class="calibre14">template &lt;std::derived_from&lt;GamePiece&gt; T&gt;</b></code>
<code class="calibre21">class GameBoard : public Grid&lt;T&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Inherit constructors from Grid&lt;T&gt;.</span></code>
<code class="calibre21">        using Grid&lt;T&gt;::Grid;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void move(std::size_t xSrc, std::size_t ySrc,</code>
<code class="calibre21">            std::size_t xDest, std::size_t yDest);</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="496" class="calibre20" epub:type="pagebreak" id="Page_496" role="doc-pagebreak">
       </span>
       The member function implementations need to be updated as well. Here's an example:
      </p>
      <pre class="calibre26" id="c12-code-0149"><code class="calibre21"><b class="calibre14">template &lt;std::derived_from&lt;GamePiece&gt; T&gt;</b></code>
<code class="calibre21">void GameBoard&lt;T&gt;::move(std::size_t xSrc, std::size_t ySrc,</code>
<code class="calibre21">    std::size_t xDest, std::size_t yDest) { <span class="color">/*…*/</span> }</code></pre>
      <p class="calibre13">
       Alternatively, you can also use a requires clause as follows:
      </p>
      <pre class="calibre26" id="c12-code-0150"><code class="calibre21"><b class="calibre14">template &lt;typename T&gt; requires std::derived_from&lt;T, GamePiece&gt;</b></code>
<code class="calibre21">class GameBoard : public Grid&lt;T&gt; { <span class="color">/*…*/</span> };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0074">
      </span>
      <h3 class="calibre27" id="head-3-284">
       Type Constraints and Class Member Functions
      </h3>
      <p class="calibre13">
       It's possible to put additional constraints on specific member functions of a class template. For example, the
       <code class="calibre21">
        move()
       </code>
       member function of the
       <code class="calibre21">
        GameBoard
       </code>
       class template could be further constrained to require that type
       <code class="calibre21">
        T
       </code>
       is moveable:
      </p>
      <pre class="calibre26" id="c12-code-0151"><code class="calibre21">template &lt;std::derived_from&lt;GamePiece&gt; T&gt;</code>
<code class="calibre21">class GameBoard : public Grid&lt;T&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Inherit constructors from Grid&lt;T&gt;.</span></code>
<code class="calibre21">        using Grid&lt;T&gt;::Grid;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void move(std::size_t xSrc, std::size_t ySrc,</code>
<code class="calibre21">            std::size_t xDest, std::size_t yDest) <b class="calibre14">requires std::movable&lt;T&gt;;</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Such a requires clause also needs to be repeated on the member function definition:
      </p>
      <pre class="calibre26" id="c12-code-0152"><code class="calibre21">template &lt;std::derived_from&lt;GamePiece&gt; T&gt;</code>
<code class="calibre21">void GameBoard&lt;T&gt;::move(std::size_t xSrc, std::size_t ySrc,</code>
<code class="calibre21">    std::size_t xDest, std::size_t yDest) <b class="calibre14">requires std::movable&lt;T&gt;</b></code>
<code class="calibre21">{ <span class="color">/*…*/</span> }</code></pre>
      <p class="calibre13" id="c12-para-0289">
       Remember that, thanks to selective instantiation discussed earlier in this chapter, you can still use this
       <code class="calibre21">
        GameBoard
       </code>
       class template with non-movable types, as long as you never call
       <code class="calibre21">
        move()
       </code>
       on it.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0075">
      </span>
      <h3 class="calibre27" id="head-3-285">
       Constraint-Based Class Template Specialization and Function Template Overloading
      </h3>
      <p class="calibre13" id="c12-para-0290">
       As described earlier in this chapter, you can write specializations for class templates and overloads for function templates to have a different implementation for certain types. It's also possible to write a specialization or overload for a collection of types satisfying certain constraints.
      </p>
      <p class="calibre13">
       Let's take one more look at the
       <code class="calibre21">
        Find()
       </code>
       function template from earlier in this chapter. To refresh your memory:
      </p>
      <pre class="calibre26" id="c12-code-0153"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">optional&lt;size_t&gt; Find(const T&amp; value, const T* arr, size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">        if (arr[i] == value) {</code>
<span aria-label="497" class="calibre20" epub:type="pagebreak" id="Page_497" role="doc-pagebreak"></span><code class="calibre21">            return i; <span class="color">// Found it; return the index.</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return {}; <span class="color">// Failed to find it; return empty optional.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This implementation uses the
       <code class="calibre21">
        ==
       </code>
       operator to compare values. It's usually not advisable to compare floating-point types for equality using
       <code class="calibre21">
        ==
       </code>
       , but instead to use an
       <i class="calibre18">
        epsilon test
       </i>
       . The following overload of
       <code class="calibre21">
        Find()
       </code>
       for floating-point types uses an epsilon test implemented in an
       <code class="calibre21">
        AreEqual()
       </code>
       helper function instead of
       <code class="calibre21">
        operator==
       </code>
       :
      </p>
      <pre class="calibre26" id="c12-code-0154"><code class="calibre21"><b class="calibre14">template &lt;std::floating_point T&gt;</b></code>
<code class="calibre21">optional&lt;size_t&gt; Find(const T&amp; value, const T* arr, size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">        <b class="calibre14">if (AreEqual(arr[i], value)) {</b></code>
<code class="calibre21">            return i; <span class="color">// Found it; return the index.</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return {}; <span class="color">// Failed to find it; return empty optional.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        AreEqual()
       </code>
       is defined as follows, also using a type constraint. A detailed discussion of the mathematics behind the epsilon test logic is outside the scope of this book and not important for this discussion.
      </p>
      <pre class="calibre26" id="c12-code-0155"><code class="calibre21"><b class="calibre14">template &lt;std::floating_point T&gt;</b></code>
<code class="calibre21">bool AreEqual(T x, T y, int precision = 2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Scale the machine epsilon to the magnitude of the given values and</span> </code>
<code class="calibre21">    <span class="color">// multiply by the required precision.</span></code>
<code class="calibre21">    return fabs(x - y) &lt;= numeric_limits&lt;T&gt;::epsilon() * fabs(x + y) * precision</code>
<code class="calibre21">        || fabs(x - y) &lt; numeric_limits&lt;T&gt;::min(); <span class="color">// The result is subnormal.</span></code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c12-sec-0076">
      </span>
      <h3 class="calibre27" id="head-3-286">
       Best Practices
      </h3>
      <p class="calibre13">
       As this section shows, concepts are a powerful mechanism to constrain types. They provide for a lot of flexibility. Always keep the following in mind:
      </p>
      <ul class="check" id="c12-list-0005">
       <li class="calibre9" id="c12-li-0025">
        Prefer using predefined Standard Library concepts or combinations of them over writing your own, because writing your own complete and correct concepts is difficult and time-consuming.
       </li>
       <li class="calibre9" id="c12-li-0026">
        When you do write your own concepts, make sure they model semantic requirements, not just syntactical requirements. For example, if your code technically only requires
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;
        </code>
        , don't write a concept that only requires the availability of those two operators, because that would be a syntactical constraint. Instead, require the type to be orderable—that's a semantic constraint.
       </li>
       <li class="calibre9" id="c12-li-0027">
        By using proper semantic type requirements up front, you are less likely to have to add more requirements later. For example, if your class template is constrained with a concept that just requires
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;
        </code>
        , then it could be that you might have to add a requirement in
        <span aria-label="498" class="calibre20" epub:type="pagebreak" id="Page_498" role="doc-pagebreak">
        </span>
        the future for
        <code class="calibre21">
         operator&gt;
        </code>
        . In doing so, you'll break existing code. If you would have used a proper concept from the start modeling orderability, you won't be breaking existing code.
       </li>
       <li class="calibre9" id="c12-li-0028">
        If a parameter of a requires expression is not meant to be modified, mark the parameter as
        <code class="calibre21">
         const
        </code>
        to capture that requirement.
       </li>
       <li class="calibre9" id="c12-li-0029">
        When writing new class or function templates, try to put proper type constraints on all template type parameters. Unconstrained template type parameters should be a thing of the past.
       </li>
       <li class="calibre9" id="c12-li-0030">
        Remember that you can use type constraints with
        <code class="calibre21">
         auto
        </code>
        type deduction.
       </li>
      </ul>
     </section>
    </section>
    <section aria-labelledby="head-2-147" class="calibre2">
     <span class="calibre" id="c12-sec-0077">
     </span>
     <h2 class="calibre6" id="head-2-147">
      SUMMARY
     </h2>
     <p class="calibre13" id="c12-para-0295">
      This chapter started a discussion on using templates for generic programming. You saw the syntax on how to write templates and examples where templates are really useful. It explained how to write class templates, class member function templates, and how to use template parameters. It further discussed how to use class template specialization to write special implementations of a template where the template parameters are replaced with specific arguments.
     </p>
     <p class="calibre13" id="c12-para-0296">
      You also learned about variable templates, function templates, and the elegant abbreviated function template syntax. The chapter finished with a discussion of concepts, allowing you to put constraints on template parameters.
     </p>
     <p class="calibre13" id="c12-para-0297">
      <a class="calibre5" href="c26.xhtml">
       Chapter 26
      </a>
      continues the discussion on templates with some more advanced features such as class template partial specializations, variadic templates, and metaprogramming.
     </p>
    </section>
    <section aria-labelledby="head-2-148" class="calibre2">
     <span class="calibre" id="c12-sec-0078">
     </span>
     <h2 class="calibre6" id="head-2-148">
      EXERCISES
     </h2>
     <p class="calibre13" id="c12-para-0298">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c12-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c12-ex-0001">
        <b class="calibre14">
         Exercise 12-1:
        </b>
        Write a
        <code class="calibre21">
         KeyValuePair
        </code>
        class template with two template type parameters:
        <code class="calibre21">
         Key
        </code>
        and
        <code class="calibre21">
         Value
        </code>
        . The class should have two private data members to store a key and a value. Provide a constructor accepting a key and a value, and add appropriate getters and setters. Test your class by creating a few instantiations in your
        <code class="calibre21">
         main()
        </code>
        function and try class template argument deduction.
       </li>
       <li class="calibre9" id="c12-ex-0002">
        <b class="calibre14">
         Exercise 12-2:
        </b>
        The
        <code class="calibre21">
         KeyValuePair
        </code>
        class template from Exercise 12-1 supports all kind of data types for both its key and value template type parameters. For example, the following instantiates the class template with
        <code class="calibre21">
         std::string
        </code>
        as the type for both the key and the value:
        <pre class="calibre26" id="c12-code-0156"><code class="calibre21">KeyValuePair&lt;std::string, std::string&gt; kv { "John Doe", "New York" };</code></pre>
        <p class="listpara" id="c12-para-0309">
         However, using
         <code class="calibre21">
          const char*
         </code>
         as template type arguments results in data members of type
         <code class="calibre21">
          const char*
         </code>
         , which is not what we want.
        </p>
        <p class="listpara" id="c12-para-0307">
         Write a class template specialization for
         <code class="calibre21">
          const char*
         </code>
         keys and values that converts the given strings to
         <code class="calibre21">
          std::string
         </code>
         s.
        </p>
       </li>
       <li class="calibre9" id="c12-ex-0003">
        <span aria-label="499" class="calibre20" epub:type="pagebreak" id="Page_499" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Exercise 12-3:
        </b>
        Take your solution from Exercise 12-1 and make the appropriate changes to only allow integer types as the type of the key and only floating-point types as the type of the value.
       </li>
       <li class="calibre9" id="c12-ex-0004">
        <b class="calibre14">
         Exercise 12-4:
        </b>
        Write a function template called
        <code class="calibre21">
         concat()
        </code>
        with two template type parameters and two function parameters
        <code class="calibre21">
         t1
        </code>
        and
        <code class="calibre21">
         t2
        </code>
        . The function first converts
        <code class="calibre21">
         t1
        </code>
        and
        <code class="calibre21">
         t2
        </code>
        to a string and then returns the concatenation of those two strings. For this exercise, focus only on types for which
        <code class="calibre21">
         std::to_string()
        </code>
        is supported. Create and use a proper concept to make sure users of the function template don't try to use it with unsupported types. Try to write your function template without using the
        <code class="calibre21">
         template
        </code>
        keyword.
       </li>
       <li class="calibre9" id="c12-ex-0005">
        <b class="calibre14">
         Exercise 12-5:
        </b>
        The
        <code class="calibre21">
         concat()
        </code>
        function template from Exercise 12-4 only works with types that are supported by
        <code class="calibre21">
         std::to_string()
        </code>
        . In this exercise, modify your solution to make it also work with strings, and any combinations.
       </li>
       <li class="calibre9" id="c12-ex-0006">
        <b class="calibre14">
         Exercise 12-6:
        </b>
        Take the original
        <code class="calibre21">
         Find()
        </code>
        function template from earlier in this chapter and add an appropriate constraint on the type
        <code class="calibre21">
         T
        </code>
        .
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
