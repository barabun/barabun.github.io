<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   3
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_006.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_008.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="_idContainer057">
    <h1 class="chapter-number" id="_idParaDest-55">
     <a id="_idTextAnchor055">
     </a>
     3
    </h1>
    <h1 id="_idParaDest-56">
     <a id="_idTextAnchor056">
     </a>
     States and Animations with Qt and QML
    </h1>
    <p>
     Qt provides an easy way to animate widgets or any other objects that inherit the
     <strong class="source-inline">
      QObject
     </strong>
     class through its powerful animation framework. The animation can be used either on its own or together with the
     <strong class="bold">
      state machine framework
     </strong>
     , which allows different animations to be played based on the current active state of the widget. Qt’s animation framework also supports grouped animation, which allows you to move more than one graphics item simultaneously or move them in sequence, one after
     <span class="No-Break">
      the other.
     </span>
    </p>
    <p>
     In this chapter, we’re going to cover the following
     <span class="No-Break">
      main topics:
     </span>
    </p>
    <ul>
     <li>
      Property animation
      <span class="No-Break">
       in Qt
      </span>
     </li>
     <li>
      Using easing curves to control
      <span class="No-Break">
       property animation
      </span>
     </li>
     <li>
      Creating an
      <span class="No-Break">
       animation group
      </span>
     </li>
     <li>
      Creating a nested
      <span class="No-Break">
       animation group
      </span>
     </li>
     <li>
      State machines
      <span class="No-Break">
       in Qt
      </span>
     </li>
     <li>
      States, transitions, and animations
      <span class="No-Break">
       in QML
      </span>
     </li>
     <li>
      Animating widget properties
      <span class="No-Break">
       using animators
      </span>
     </li>
     <li>
      <span class="No-Break">
       Sprite animation
      </span>
     </li>
    </ul>
    <h1 id="_idParaDest-57">
     <a id="_idTextAnchor057">
     </a>
     Technical requirements
    </h1>
    <p>
     The technical requirements for this chapter include
     <strong class="bold">
      Qt 6.6.1 MinGW 64-bit
     </strong>
     ,
     <strong class="bold">
      Qt Creator 12.0.2
     </strong>
     , and Windows 11. All the code used in this chapter can be downloaded from the following GitHub repository
     <span class="No-Break">
      at
     </span>
     <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03">
      <span class="No-Break">
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <h1 id="_idParaDest-58">
     <a id="_idTextAnchor058">
     </a>
     Property animation in Qt
    </h1>
    <p>
     In this example, we will learn how to animate our
     <strong class="bold">
      Graphical User Interface
     </strong>
     (
     <strong class="bold">
      GUI
     </strong>
     ) elements using Qt’s
     <strong class="source-inline">
      property animation
     </strong>
     class, a
     <a id="_idIndexMarker174">
     </a>
     part of its powerful animation
     <a id="_idIndexMarker175">
     </a>
     framework that
     <a id="_idIndexMarker176">
     </a>
     allows us to create fluid-looking animations with
     <span class="No-Break">
      minimal effort.
     </span>
    </p>
    <h2 id="_idParaDest-59">
     <a id="_idTextAnchor059">
     </a>
     How to do it…
    </h2>
    <p>
     In the following example, we will create a new widget project and animate the push button by changing
     <span class="No-Break">
      its properties:
     </span>
    </p>
    <ol>
     <li>
      Let’s create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project. After that, open up
      <strong class="source-inline">
       mainwindow.ui
      </strong>
      with Qt Designer and place a button on the main window, as
      <span class="No-Break">
       shown here:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer049">
      <img alt="Figure 3.1 – Dragging and dropping a push button to the UI canvas" src="../images\image/B20976_03_001.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.1 – Dragging and dropping a push button to the UI canvas
    </p>
    <ol>
     <li value="2">
      Open up
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      and add the following line of code at the beginning of the
      <span class="No-Break">
       source code:
      </span>
      <pre class="source-code">
#include &lt;QPropertyAnimation&gt;</pre>
     </li>
     <li>
      After that, open up
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      and add the following code to
      <span class="No-Break">
       the constructor:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(10000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
animation-&gt;start();</pre>
     </li>
    </ol>
    <h2 id="_idParaDest-60">
     <a id="_idTextAnchor060">
     </a>
     How it works…
    </h2>
    <p>
     One of the more
     <a id="_idIndexMarker177">
     </a>
     common methods of animating a GUI element is through the property animation class provided by Qt, known as the
     <strong class="source-inline">
      QPropertyAnimation
     </strong>
     class. This class is part of the animation framework and it makes use of the timer system in Qt to change the properties of a GUI element over a
     <span class="No-Break">
      given duration.
     </span>
    </p>
    <p>
     What we are trying to
     <a id="_idIndexMarker178">
     </a>
     accomplish here is animating the button from one position to another while, at the same time, enlarging the button size along the way. By including the
     <strong class="source-inline">
      QPropertyAnimation
     </strong>
     header in our source code in
     <em class="italic">
      step 2
     </em>
     , we will be able to access the
     <strong class="source-inline">
      QPropertyAnimation
     </strong>
     class provided by Qt and make use of
     <span class="No-Break">
      its functionalities.
     </span>
    </p>
    <p>
     The code in
     <em class="italic">
      step 3
     </em>
     basically creates a new
     <em class="italic">
      property animation
     </em>
     and applies it to the
     <strong class="bold">
      push button
     </strong>
     we just created in Qt Designer. We specifically request that the
     <strong class="source-inline">
      property animation
     </strong>
     class changes the geometry properties of the
     <em class="italic">
      push button
     </em>
     and sets its duration to 3,000 milliseconds (
     <span class="No-Break">
      3 seconds).
     </span>
    </p>
    <p>
     Then, the start value of the animation is set to the initial geometry of the
     <em class="italic">
      push button
     </em>
     because, obviously, we want it to start from where we initially placed the button in Qt Designer. The
     <strong class="source-inline">
      end
     </strong>
     value is then set to what we want it to become; in this case, we will move the button to a new position at
     <strong class="source-inline">
      x: 200
     </strong>
     and
     <strong class="source-inline">
      y: 200
     </strong>
     while changing its size to
     <strong class="source-inline">
      width: 100
     </strong>
     and
     <strong class="source-inline">
      height: 50
     </strong>
     along
     <span class="No-Break">
      the way.
     </span>
    </p>
    <p>
     After that, call
     <strong class="source-inline">
      animation
     </strong>
     |
     <strong class="source-inline">
      start()
     </strong>
     to start the animation. Compile and run the project. You should see the
     <a id="_idIndexMarker179">
     </a>
     button start to move slowly across the main window while expanding in size a bit
     <a id="_idIndexMarker180">
     </a>
     at a time until it reaches its destination. You can change the animation duration and the target position and scale by altering the values in the preceding code. It is really that simple to animate a GUI element using Qt’s property
     <span class="No-Break">
      animation system!
     </span>
    </p>
    <h2 id="_idParaDest-61">
     <a id="_idTextAnchor061">
     </a>
     There’s more…
    </h2>
    <p>
     Qt provides us with several different sub-systems to create animations for our GUI, including the timer, timeline, animation framework, state machine framework, and graphics
     <span class="No-Break">
      view framework:
     </span>
    </p>
    <ul>
     <li>
      <strong class="bold">
       Timer
      </strong>
      : Qt provides us with
      <em class="italic">
       repetitive and single-shot timers
      </em>
      . When the timeout value is
      <a id="_idIndexMarker181">
      </a>
      reached, an
      <strong class="source-inline">
       event callback
      </strong>
      function will be triggered through Qt’s
      <em class="italic">
       signal-and-slot
      </em>
      mechanism. You can make use of a timer to change the properties (color, position, scale, and so on) of your GUI element within a given interval to create
      <span class="No-Break">
       an animation.
      </span>
     </li>
     <li>
      <strong class="bold">
       Timeline
      </strong>
      : The
      <em class="italic">
       Timeline
      </em>
      calls a slot periodically to animate a GUI element. It is quite similar to a
      <em class="italic">
       repetitive timer
      </em>
      , but instead of doing the same thing all of the time when the slot is triggered, the timeline provides a value to the slot to indicate its current
      <a id="_idIndexMarker182">
      </a>
      frame index so that you can do different things (such as offset to a different space of the sprite sheet) based on the
      <span class="No-Break">
       given value.
      </span>
     </li>
     <li>
      <strong class="bold">
       Animation framework
      </strong>
      : The
      <em class="italic">
       animation framework
      </em>
      makes animating a GUI element easy by allowing
      <a id="_idIndexMarker183">
      </a>
      its properties to be animated. The animations are controlled by using
      <em class="italic">
       easing curves
      </em>
      . Easing curves describe a function that controls what the speed of the animation should be, resulting in different acceleration and deceleration patterns. The types of easing curves supported by Qt include linear, quadratic, cubic, quartic, sine, exponential, circular,
      <span class="No-Break">
       and elastic.
      </span>
     </li>
     <li>
      <strong class="bold">
       State machine framework
      </strong>
      : Qt provides us with classes for creating and executing state graphs, which
      <a id="_idIndexMarker184">
      </a>
      allow each GUI element to move from one state to another when triggered by signals. The
      <em class="italic">
       state graph
      </em>
      in the
      <em class="italic">
       state machine framework
      </em>
      is hierarchical, which means every state can also be nested inside of
      <span class="No-Break">
       other states.
      </span>
     </li>
     <li>
      <strong class="bold">
       Graphics view framework
      </strong>
      : The
      <em class="italic">
       graphics view framework
      </em>
      is a powerful graphics engine for visualizing
      <a id="_idIndexMarker185">
      </a>
      and interacting with a large number of
      <a id="_idIndexMarker186">
      </a>
      custom-made 2D graphical
      <a id="_idIndexMarker187">
      </a>
      items. You can use the graphics view framework to draw your GUI and have them animated in a totally manual way if you are an
      <span class="No-Break">
       experienced programmer.
      </span>
     </li>
    </ul>
    <p>
     By making use of all of the powerful features we’ve mentioned here, we’re able to create an intuitive and modern GUI with ease. In this chapter, we will look into the practical approaches to animating GUI elements
     <span class="No-Break">
      using Qt.
     </span>
    </p>
    <h1 id="_idParaDest-62">
     <a id="_idTextAnchor062">
     </a>
     Using easing curves to control property animation
    </h1>
    <p>
     In this example, we will learn how to
     <a id="_idIndexMarker188">
     </a>
     make our animation more interesting by utilizing
     <em class="italic">
      easing curves
     </em>
     . We will still use the previous source code, which
     <a id="_idIndexMarker189">
     </a>
     uses the property animation to animate a
     <span class="No-Break">
      push button.
     </span>
    </p>
    <h2 id="_idParaDest-63">
     <a id="_idTextAnchor063">
     </a>
     How to do it…
    </h2>
    <p>
     In the following example, we will learn how to add an
     <em class="italic">
      easing curve
     </em>
     to
     <span class="No-Break">
      our animation:
     </span>
    </p>
    <ol>
     <li>
      Define an easing curve and add it to the property animation before calling the
      <span class="No-Break">
       <strong class="source-inline">
        start()
       </strong>
      </span>
      <span class="No-Break">
       function:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</pre>
     </li>
     <li>
      Call the
      <strong class="source-inline">
       setLoopCount()
      </strong>
      function
      <a id="_idIndexMarker190">
      </a>
      to set how many
      <a id="_idIndexMarker191">
      </a>
      loops you want it to
      <span class="No-Break">
       repeat for:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(EasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;setLoopCount(2);
animation-&gt;start();</pre>
     </li>
     <li>
      Call
      <strong class="source-inline">
       setAmplitude()
      </strong>
      ,
      <strong class="source-inline">
       setOvershoot()
      </strong>
      , and
      <strong class="source-inline">
       setPeriod()
      </strong>
      before applying the easing curve to
      <span class="No-Break">
       the animation:
      </span>
      <pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</pre>
     </li>
    </ol>
    <p>
     It’s really that easy to
     <a id="_idIndexMarker192">
     </a>
     animate a widget or any object in Qt 6 using the built-in
     <span class="No-Break">
      easing curves.
     </span>
    </p>
    <h2 id="_idParaDest-64">
     <a id="_idTextAnchor064">
     </a>
     How it works...
    </h2>
    <p>
     To let an easing curve control the
     <a id="_idIndexMarker193">
     </a>
     animation, all you need to do is define an easing curve and add it to the property animation before calling the
     <strong class="source-inline">
      start()
     </strong>
     function. You can also try several other types of easing curves and see which one suits you best. Here is
     <span class="No-Break">
      an example:
     </span>
    </p>
    <pre class="source-code">
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);</pre>
    <p>
     If you want the animation to loop after it has finished playing, you can call the
     <strong class="source-inline">
      setLoopCount()
     </strong>
     function to set how many loops you want it to repeat for or set the value to
     <strong class="source-inline">
      -1
     </strong>
     for an
     <span class="No-Break">
      infinite loop:
     </span>
    </p>
    <pre class="source-code">
animation-&gt;setLoopCount(-1);</pre>
    <p>
     There are several parameters that you can set to refine the easing curve before applying it to the property animation. These parameters include
     <strong class="bold">
      amplitude
     </strong>
     ,
     <strong class="bold">
      overshoot
     </strong>
     ,
     <span class="No-Break">
      and
     </span>
     <span class="No-Break">
      <strong class="bold">
       period
      </strong>
     </span>
     <span class="No-Break">
      :
     </span>
    </p>
    <ul>
     <li>
      <strong class="bold">
       Amplitude
      </strong>
      : The higher the
      <em class="italic">
       amplitude
      </em>
      , the higher the bounce or elastic spring effect that will be applied to
      <span class="No-Break">
       the
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker194">
       </a>
      </span>
      <span class="No-Break">
       animation.
      </span>
     </li>
     <li>
      <strong class="bold">
       Overshoot
      </strong>
      : Some curve functions
      <a id="_idIndexMarker195">
      </a>
      will produce an
      <em class="italic">
       overshoot
      </em>
      (exceeding its final value) curve due to a damping effect. By adjusting the overshoot value, we are able to increase or decrease
      <span class="No-Break">
       this effect.
      </span>
     </li>
     <li>
      <strong class="bold">
       Period
      </strong>
      : Setting a small
      <a id="_idIndexMarker196">
      </a>
      period value will give a high frequency to the curve. A large
      <em class="italic">
       period
      </em>
      will give it a
      <span class="No-Break">
       small frequency.
      </span>
     </li>
    </ul>
    <p>
     These parameters, however, are not applicable to all curve types. Please refer to the Qt documentation to see which parameter is applicable to which
     <span class="No-Break">
      curve type.
     </span>
    </p>
    <h2 id="_idParaDest-65">
     <a id="_idTextAnchor065">
     </a>
     There’s more...
    </h2>
    <p>
     While the property
     <a id="_idIndexMarker197">
     </a>
     animation works perfectly fine, sometimes it feels a little boring to look at a GUI element being animated at a constant speed. We can make the animation look more interesting by adding an
     <strong class="bold">
      easing curve
     </strong>
     to
     <a id="_idIndexMarker198">
     </a>
     control the motion. There are many types of  easing curves that you can use in Qt, and here are some
     <span class="No-Break">
      of them:
     </span>
    </p>
    <div>
     <div class="IMG---Figure" id="_idContainer050">
      <img alt="Figure 3.2 – Different types of easing curves supported by Qt 6" src="../images\image/B20976_03_002.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.2 – Different types of easing curves supported by Qt 6
    </p>
    <p>
     As you can see from the
     <a id="_idIndexMarker199">
     </a>
     preceding diagram, each easing curve produces a different
     <em class="italic">
      ease-in and
     </em>
     <span class="No-Break">
      <em class="italic">
       ease-out
      </em>
     </span>
     <span class="No-Break">
      effect.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     For the full list of easing curves available in Qt, please refer to the Qt documentation
     <span class="No-Break">
      at
     </span>
     <a href="http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum">
      <span class="No-Break">
       http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <h1 id="_idParaDest-66">
     <a id="_idTextAnchor066">
     </a>
     Creating an animation group
    </h1>
    <p>
     In this example, we will
     <a id="_idIndexMarker200">
     </a>
     learn how to use an
     <em class="italic">
      animation group
     </em>
     to manage the states of the animations contained in
     <span class="No-Break">
      the group.
     </span>
    </p>
    <h2 id="_idParaDest-67">
     <a id="_idTextAnchor067">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s create an
     <em class="italic">
      animation group
     </em>
     by following
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      We will use the previous example but, this time, we will add two more push buttons to the main window, as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer051">
      <img alt="Figure 3.3 – Adding three push buttons to the main window" src="../images\image/B20976_03_003.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.3 – Adding three push buttons to the main window
    </p>
    <ol>
     <li value="2">
      Define the
      <em class="italic">
       animation
      </em>
      for each of the push buttons in the main
      <span class="No-Break">
       window’s constructor:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 200, 100, 50));</pre>
     </li>
     <li>
      Create an
      <em class="italic">
       easing curve
      </em>
      and
      <a id="_idIndexMarker201">
      </a>
      apply the same curve to all
      <span class="No-Break">
       three animations:
      </span>
      <pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);</pre>
     </li>
     <li>
      Once you have applied the easing curve to all three animations, we will then create an
      <em class="italic">
       animation group
      </em>
      and add all three animations to
      <span class="No-Break">
       the group:
      </span>
      <pre class="source-code">
QParallelAnimationGroup *group = new QParallelAnimationGroup;
group-&gt;addAnimation(animation1);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation3);</pre>
     </li>
     <li>
      Call the
      <strong class="source-inline">
       start()
      </strong>
      function
      <a id="_idIndexMarker202">
      </a>
      from the animation group we
      <span class="No-Break">
       just created:
      </span>
      <pre class="source-code">
group-&gt;start();</pre>
     </li>
    </ol>
    <h2 id="_idParaDest-68">
     <a id="_idTextAnchor068">
     </a>
     How it works…
    </h2>
    <p>
     Qt allows us to create multiple animations and group them into an animation group. A group is usually responsible for managing the state of its animations (that is, it decides when to start, stop, resume, and pause them). Currently, Qt provides two types of classes for animation groups:
     <strong class="source-inline">
      QParallelAnimationGroup
     </strong>
     <span class="No-Break">
      and
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       QSequentialAnimationGroup
      </strong>
     </span>
     <span class="No-Break">
      :
     </span>
    </p>
    <ul>
     <li>
      <strong class="source-inline">
       QParallelAnimationGroup
      </strong>
      : As its name implies, a
      <em class="italic">
       parallel animation group
      </em>
      runs all of the animations in its group at the same time. The group is deemed finished when the longest-lasting animation has
      <span class="No-Break">
       finished running.
      </span>
     </li>
     <li>
      <strong class="source-inline">
       QSequentialAnimationGroup
      </strong>
      : A
      <em class="italic">
       sequential animation group
      </em>
      runs its animations in sequence, meaning it will only run a single animation at a time and only play the next animation when the current one
      <span class="No-Break">
       has finished.
      </span>
     </li>
    </ul>
    <h2 id="_idParaDest-69">
     <a id="_idTextAnchor069">
     </a>
     There’s more…
    </h2>
    <p>
     Since we are using an animation group now, we no longer call the
     <strong class="source-inline">
      start()
     </strong>
     function from the individual animation. Instead, we will be calling the
     <strong class="source-inline">
      start()
     </strong>
     function from the  animation group we just created. If you compile and run the example now, you will see all three buttons being played at the same
     <a id="_idIndexMarker203">
     </a>
     time. This is because we are using the
     <strong class="bold">
      parallel
     </strong>
     <strong class="bold">
      animation group
     </strong>
     . You can replace it with a
     <strong class="bold">
      sequential animation group
     </strong>
     and run
     <a id="_idIndexMarker204">
     </a>
     the
     <span class="No-Break">
      example again:
     </span>
    </p>
    <pre class="source-code">
QSequentialAnimationGroup *group = new QSequentialAnimationGroup;</pre>
    <p>
     This time, only a single button will play its animation at a time, while the other buttons will wait patiently for their turn to come. The priority is set based on which animation is added to the animation group first. You can change the animation sequence by simply rearranging the
     <a id="_idIndexMarker205">
     </a>
     sequence of an animation that’s being added to the group. For example, if we want button
     <strong class="source-inline">
      3
     </strong>
     to start the animation first, followed by button
     <strong class="source-inline">
      2
     </strong>
     , and then button
     <strong class="source-inline">
      1
     </strong>
     , the code will look
     <span class="No-Break">
      like this:
     </span>
    </p>
    <pre class="source-code">
group-&gt;addAnimation(animation3);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation1);</pre>
    <p>
     Since property animations and animation groups are both inherited from the
     <strong class="source-inline">
      QAbstractAnimator
     </strong>
     class, it means that you can also add an animation group to another animation group to form a more complex, nested
     <span class="No-Break">
      animation group.
     </span>
    </p>
    <h1 id="_idParaDest-70">
     <a id="_idTextAnchor070">
     </a>
     Creating a nested animation group
    </h1>
    <p>
     One good example of using a
     <strong class="bold">
      nested animation group
     </strong>
     is when you have several
     <strong class="bold">
      parallel
     </strong>
     animation groups and
     <a id="_idIndexMarker206">
     </a>
     you want to play the groups in
     <span class="No-Break">
      sequential order.
     </span>
    </p>
    <h2 id="_idParaDest-71">
     <a id="_idTextAnchor071">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s follow these steps to create a
     <strong class="bold">
      nested animation group
     </strong>
     to play different animation groups in a
     <span class="No-Break">
      sequential order:
     </span>
    </p>
    <ol>
     <li>
      We will use the UI from the previous example and add a few more buttons to the main window,
      <span class="No-Break">
       like so:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer052">
      <img alt="Figure 3.4 – We need even more buttons this time around" src="../images\image/B20976_03_004.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.4 – We need even more buttons this time around
    </p>
    <ol>
     <li value="2">
      Create all of the animations
      <a id="_idIndexMarker207">
      </a>
      for the buttons and then create an easing curve and apply it to all of
      <span class="No-Break">
       the animations:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 50, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 50, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 50, 100, 50));</pre>
     </li>
     <li>
      Next, apply the
      <span class="No-Break">
       following
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker208">
       </a>
      </span>
      <span class="No-Break">
       code:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation4 = new
QPropertyAnimation(ui-&gt;pushButton_4, "geometry");
animation4-&gt;setDuration(3000);
animation4-&gt;setStartValue(ui-&gt;pushButton_4-&gt;geometry());
animation4-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation5 = new
QPropertyAnimation(ui-&gt;pushButton_5, "geometry");
animation5-&gt;setDuration(3000);
animation5-&gt;setStartValue(ui-&gt;pushButton_5-&gt;geometry());
animation5-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation6 = new
QPropertyAnimation(ui-&gt;pushButton_6, "geometry");
animation6-&gt;setDuration(3000);
animation6-&gt;setStartValue(ui-&gt;pushButton_6-&gt;geometry());
animation6-&gt;setEndValue(QRect(250, 200, 100, 50));</pre>
     </li>
     <li>
      Then, apply the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);
animation4-&gt;setEasingCurve(curve);
animation5-&gt;setEasingCurve(curve);
animation6-&gt;setEasingCurve(curve);</pre>
     </li>
     <li>
      Create two
      <strong class="bold">
       animation groups
      </strong>
      , one
      <a id="_idIndexMarker209">
      </a>
      for the buttons in the upper column and another one for the
      <span class="No-Break">
       lower column:
      </span>
      <pre class="source-code">
QParallelAnimationGroup *group1 = new QParallelAnimationGroup;
group1-&gt;addAnimation(animation1);
group1-&gt;addAnimation(animation2);
group1-&gt;addAnimation(animation3);
QParallelAnimationGroup *group2 = new QParallelAnimationGroup;
group2-&gt;addAnimation(animation4);
group2-&gt;addAnimation(animation5);
group2-&gt;addAnimation(animation6);</pre>
     </li>
     <li>
      We will create yet another
      <strong class="bold">
       animation group
      </strong>
      , which will be used to store the two animation groups we
      <span class="No-Break">
       created previously:
      </span>
      <pre class="source-code">
QSequentialAnimationGroup *groupAll = new
QSequentialAnimationGroup;
groupAll-&gt;addAnimation(group1);
groupAll-&gt;addAnimation(group2);
groupAll-&gt;start();</pre>
     </li>
    </ol>
    <p>
     A Nested animation group allows you to set up a more complex widget animation by combining different types of
     <a id="_idIndexMarker210">
     </a>
     animations and executing them at your
     <span class="No-Break">
      desired orders.
     </span>
    </p>
    <h2 id="_idParaDest-72">
     <a id="_idTextAnchor072">
     </a>
     How it works…
    </h2>
    <p>
     What we are trying to do here is play the animation of the buttons in the upper column first, followed by the buttons in the lower column. Since both of the animation groups are
     <strong class="bold">
      parallel animation groups
     </strong>
     , the
     <a id="_idIndexMarker211">
     </a>
     buttons belonging to the respective groups will be animated at the same time when the
     <strong class="source-inline">
      start()
     </strong>
     function
     <span class="No-Break">
      is called.
     </span>
    </p>
    <p>
     This time, however, the group is a
     <strong class="bold">
      sequential animation group
     </strong>
     , which means only a single parallel animation group will
     <a id="_idIndexMarker212">
     </a>
     be played at a time, followed by the other when the first one is finished. Animation groups are a very handy system that allows us to create very complex GUI animations with simple coding. Qt will handle the difficult part for us so that we don’t
     <span class="No-Break">
      have to.
     </span>
    </p>
    <h1 id="_idParaDest-73">
     <a id="_idTextAnchor073">
     </a>
     State machines in Qt 6
    </h1>
    <p>
     A
     <strong class="bold">
      state machine
     </strong>
     can be used for
     <a id="_idIndexMarker213">
     </a>
     many purposes but, in this chapter, we will only cover topics
     <a id="_idIndexMarker214">
     </a>
     related
     <span class="No-Break">
      to animation.
     </span>
    </p>
    <h2 id="_idParaDest-74">
     <a id="_idTextAnchor074">
     </a>
     How to do it…
    </h2>
    <p>
     A
     <strong class="bold">
      State machine
     </strong>
     is not that hard to achieve in Qt at all. Let’s get started by following
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      We will set up a new user interface for our example program, which looks
      <span class="No-Break">
       like this:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer053">
      <img alt="Figure 3.5 – Setting up the GUI for our state machine experiment" src="../images\image/B20976_03_005.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.5 – Setting up the GUI for our state machine experiment
    </p>
    <ol>
     <li value="2">
      We will include
      <a id="_idIndexMarker215">
      </a>
      some headers in our
      <span class="No-Break">
       source code:
      </span>
      <pre class="source-code">
#include &lt;QStateMachine&gt;
#include &lt;QPropertyAnimation&gt;
#include &lt;QEventTransition&gt;</pre>
     </li>
     <li>
      In our main window’s constructor, add
      <a id="_idIndexMarker216">
      </a>
      the following code to create a
      <em class="italic">
       new state machine
      </em>
      and two
      <em class="italic">
       states
      </em>
      , which we will be
      <span class="No-Break">
       using later:
      </span>
      <pre class="source-code">
QStateMachine *machine = new QStateMachine(this);
QState *s1 = new QState();
QState *s2 = new QState();</pre>
     </li>
     <li>
      We will define what we should do
      <a id="_idIndexMarker217">
      </a>
      within each state, which, in this case, will be to change the
      <a id="_idIndexMarker218">
      </a>
      label’s
      <em class="italic">
       text
      </em>
      and the button’s
      <em class="italic">
       position
      </em>
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <em class="italic">
        size
       </em>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
QState *s1 = new QState();
s1-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 1");
s1-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(50, 200,
100, 50));
QState *s2 = new QState();
s2-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 2");
s2-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(200, 50,
140, 100));</pre>
     </li>
     <li>
      Once you are done with that, let’s proceed by adding
      <strong class="source-inline">
       event transition
      </strong>
      classes to our
      <span class="No-Break">
       source code:
      </span>
      <pre class="source-code">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
s2-&gt;addTransition(t2);</pre>
     </li>
     <li>
      Add all of the states we have just created to the state machine and define state 1 as the
      <strong class="bold">
       initial state
      </strong>
      . Then, call
      <strong class="source-inline">
       machine-&gt;start()
      </strong>
      to run the
      <span class="No-Break">
       state machine:
      </span>
      <pre class="source-code">
machine-&gt;addState(s1);
machine-&gt;addState(s2);
machine-&gt;setInitialState(s1);
machine-&gt;start();</pre>
     </li>
     <li>
      If you run the example
      <a id="_idIndexMarker219">
      </a>
      program now, you will notice that everything works fine, except
      <a id="_idIndexMarker220">
      </a>
      the button is not going through a smooth transition and it simply jumps instantly to the position and size we set previously. This is because we have not used a
      <strong class="bold">
       property animation
      </strong>
      to create a
      <span class="No-Break">
       smooth transition.
      </span>
     </li>
     <li>
      Go back to the event transition step and add the following lines
      <span class="No-Break">
       of code:
      </span>
      <pre class="source-code">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s2-&gt;addTransition(t2);</pre>
     </li>
     <li>
      You can also add an
      <a id="_idIndexMarker221">
      </a>
      easing curve to the animation to make it look
      <span class="No-Break">
       more interesting:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(animation);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(animation);
s2-&gt;addTransition(t2);</pre>
     </li>
    </ol>
    <h2 id="_idParaDest-75">
     <a id="_idTextAnchor075">
     </a>
     How it works…
    </h2>
    <p>
     There are two push buttons
     <a id="_idIndexMarker222">
     </a>
     and a label on the main window layout. The button in the top-left corner will trigger the state change when pressed, while the label in the top-right corner will change its text to show which state we are currently in. the button below will animate according to the current state. The
     <strong class="source-inline">
      QEventTransition
     </strong>
     classes define what will trigger the transition between one state
     <span class="No-Break">
      and another.
     </span>
    </p>
    <p>
     In our case, we want the state to change from state 1 to state 2 when the
     <strong class="bold">
      changeState
     </strong>
     button (the one in the upper-left) is clicked. After that, we also want to change from state 2 back to state 1
     <a id="_idIndexMarker223">
     </a>
     when the same button is pressed again. This can be achieved by creating another
     <a id="_idIndexMarker224">
     </a>
     event transition class and setting the target state back to state 1. Then, add these transitions to their respective states. Instead of just assigning the properties directly to the widgets, we tell Qt to use the property animation class to smoothly interpolate the properties toward the target values. It is that simple! There is no need to set the start value and end value because we have already called the
     <strong class="source-inline">
      assignProperty()
     </strong>
     function, which has automatically assigned the
     <span class="No-Break">
      end value.
     </span>
    </p>
    <h2 id="_idParaDest-76">
     <a id="_idTextAnchor076">
     </a>
     There’s more…
    </h2>
    <p>
     The
     <strong class="bold">
      state machine framework
     </strong>
     in Qt
     <a id="_idIndexMarker225">
     </a>
     provides classes for creating and executing state graphs. Qt’s event system is used to drive the state machines, where transitions between states can be triggered by using
     <em class="italic">
      signals
     </em>
     , and then the
     <em class="italic">
      slots
     </em>
     on the other end will be invoked by the signals to perform an action, such as playing
     <span class="No-Break">
      an animation.
     </span>
    </p>
    <p>
     Once you understand the basics of state machines, you can use them to do other things as well. The state graph in the state machine framework is hierarchical. Just like the animation group in the previous section, states can also be nested inside of
     <span class="No-Break">
      other states:
     </span>
    </p>
    <div>
     <div class="IMG---Figure" id="_idContainer054">
      <img alt="Figure 3.6 – Nested state machines explained visually" src="../images\image/B20976_03_006.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.6 – Nested state machines explained visually
    </p>
    <p>
     You can combine nested state machines and animations to create a very sophisticated GUI for
     <span class="No-Break">
      your application.
     </span>
    </p>
    <h1 id="_idParaDest-77">
     <a id="_idTextAnchor077">
     </a>
     States, transitions, and animations in QML
    </h1>
    <p>
     If you prefer to work with QML instead of C++, Qt also provides similar features in Qt Quick that allow you to easily
     <a id="_idIndexMarker226">
     </a>
     animate a GUI element with minimal lines of code. In this example, we will learn how to achieve this
     <span class="No-Break">
      with QML.
     </span>
    </p>
    <h2 id="_idParaDest-78">
     <a id="_idTextAnchor078">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s get started by following these steps to create a window that continuously changes its
     <span class="No-Break">
      background color:
     </span>
    </p>
    <ol>
     <li>
      We will create a new
      <strong class="bold">
       Qt Quick Application
      </strong>
      project and set up our user interface,
      <span class="No-Break">
       like so:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer055">
      <img alt="Figure 3.7 – A joyful application that constantly changes its background color" src="../images\image/B20976_03_007.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.7 – A joyful application that constantly changes its background color
    </p>
    <ol>
     <li value="2">
      Here is what
      <a id="_idIndexMarker227">
      </a>
      my
      <strong class="source-inline">
       main.qml
      </strong>
      file
      <span class="No-Break">
       looks like:
      </span>
      <pre class="source-code">
import QtQuick
import QtQuick.Window
Window {
    visible: true
    width: 480;
    height: 320;
    Rectangle {
        id: background;
        anchors.fill: parent;
        color: "blue";
    }
    Text {
        text: qsTr("Hello World");
        anchors.centerIn: parent;
        color: "white";
        font.pointSize: 15;
    }
}</pre>
     </li>
     <li>
      Add the
      <em class="italic">
       color animation
      </em>
      to
      <a id="_idIndexMarker228">
      </a>
      the
      <span class="No-Break">
       <strong class="source-inline">
        Rectangle
       </strong>
      </span>
      <span class="No-Break">
       object:
      </span>
      <pre class="source-code">
Rectangle {
    id: background;
    anchors.fill: parent;
    color: "blue";
    SequentialAnimation on color {
        ColorAnimation { to: "yellow"; duration: 1000 }
        ColorAnimation { to: "red"; duration: 1000 }
        ColorAnimation { to: "blue"; duration: 1000 }
        loops: Animation.Infinite;
    }
}</pre>
     </li>
     <li>
      Add a
      <em class="italic">
       number animation
      </em>
      to the
      <span class="No-Break">
       <strong class="source-inline">
        text
       </strong>
      </span>
      <span class="No-Break">
       object:
      </span>
      <pre class="source-code">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
}</pre>
     </li>
     <li>
      Add
      <a id="_idIndexMarker229">
      </a>
      another
      <em class="italic">
       number animation
      </em>
      <span class="No-Break">
       to it:
      </span>
      <pre class="source-code">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
    NumberAnimation on rotation {
        from: 0;
        to: 360;
        duration: 2000;
        loops: Animation.Infinite;
    }
}</pre>
     </li>
     <li>
      Define two
      <em class="italic">
       states
      </em>
      , one called the
      <strong class="source-inline">
       PRESSED
      </strong>
      state and another called the
      <strong class="source-inline">
       RELEASED
      </strong>
      state. Then, set
      <a id="_idIndexMarker230">
      </a>
      the default state
      <span class="No-Break">
       to
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        RELEASED
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
Rectangle {
    id: background;
    anchors.fill: parent;
    state: "RELEASED";
    states: [
    State {
        name: "PRESSED"
        PropertyChanges { target: background; color: "blue"}
    },
    State {
        name: "RELEASED"
        PropertyChanges { target: background; color: "red"}
    }
    ]
}</pre>
     </li>
     <li>
      After that, create a mouse area within the
      <strong class="source-inline">
       Rectangle
      </strong>
      object so that we can click
      <span class="No-Break">
       on it:
      </span>
      <pre class="source-code">
MouseArea {
    anchors.fill: parent;
    onPressed: background.state = "PRESSED";
    onReleased: background.state = "RELEASED";
}</pre>
     </li>
     <li>
      Add some transitions to
      <a id="_idIndexMarker231">
      </a>
      the
      <span class="No-Break">
       <strong class="source-inline">
        Rectangle
       </strong>
      </span>
      <span class="No-Break">
       object:
      </span>
      <pre class="source-code">
transitions: [
    Transition {
        from: "PRESSED"
        to: "RELEASED"
        ColorAnimation { target: background; duration: 200}
    },
    Transition {
        from: "RELEASED"
        to: "PRESSED"
        ColorAnimation { target: background; duration: 200}
}
]</pre>
     </li>
    </ol>
    <h2 id="_idParaDest-79">
     <a id="_idTextAnchor079">
     </a>
     How it works…
    </h2>
    <p>
     The main window consists of a blue rectangle and static text that says
     <strong class="bold">
      Hello World
     </strong>
     . We want the background color to change from blue to yellow, then to red, and back to blue in a loop. This can be easily achieved by using the
     <em class="italic">
      color animation
     </em>
     type in QML. What we are doing in
     <em class="italic">
      step 3
     </em>
     is basically
     <a id="_idIndexMarker232">
     </a>
     creating a
     <em class="italic">
      sequential animation group
     </em>
     within the
     <strong class="source-inline">
      Rectangle
     </strong>
     object, then creating three different
     <em class="italic">
      color animations
     </em>
     within the group, which will change the color of the object every 1,000 milliseconds (1 second). We also set the animations to
     <span class="No-Break">
      loop infinitely.
     </span>
    </p>
    <p>
     In
     <em class="italic">
      step 4
     </em>
     , we want to use the
     <em class="italic">
      number animation
     </em>
     to animate the alpha value of the static text. We created another
     <em class="italic">
      sequential animation group
     </em>
     within the
     <strong class="source-inline">
      Text
     </strong>
     object and created two
     <em class="italic">
      number animations
     </em>
     to animate the alpha value from
     <strong class="source-inline">
      0
     </strong>
     to
     <strong class="source-inline">
      1
     </strong>
     and back. Then, we set the animations to
     <span class="No-Break">
      loop infinitely.
     </span>
    </p>
    <p>
     Then, in
     <em class="italic">
      step 5
     </em>
     , we rotate the
     <strong class="source-inline">
      Hello World
     </strong>
     text by adding another
     <strong class="bold">
      number animation
     </strong>
     to it. In
     <em class="italic">
      step 6
     </em>
     , we wanted to make the
     <strong class="source-inline">
      Rectangle
     </strong>
     object change from one color to another when we clicked on it. When the mouse is released, the
     <strong class="source-inline">
      Rectangle
     </strong>
     object will change back to its initial color. To achieve that, we first need to define the two states, one called the
     <strong class="source-inline">
      PRESSED
     </strong>
     state and another called the
     <strong class="source-inline">
      RELEASED
     </strong>
     state. Then, we set the default state
     <span class="No-Break">
      to
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       RELEASED
      </strong>
     </span>
     <span class="No-Break">
      .
     </span>
    </p>
    <p>
     Now, when you compile and run the example, the background will instantly change color to blue when pressed and change back to red when the mouse is released. That works great, and we can further enhance it by giving it a little transition when switching color. This can be easily achieved by adding transitions to the
     <span class="No-Break">
      <strong class="source-inline">
       Rectangle
      </strong>
     </span>
     <span class="No-Break">
      object.
     </span>
    </p>
    <h2 id="_idParaDest-80">
     <a id="_idTextAnchor080">
     </a>
     There’s more…
    </h2>
    <p>
     In QML, there are eight different types of property animation you can use, and these are
     <span class="No-Break">
      as follows:
     </span>
    </p>
    <ul>
     <li>
      <strong class="bold">
       Anchor animation
      </strong>
      : Animates
      <a id="_idIndexMarker233">
      </a>
      changes in
      <span class="No-Break">
       anchor
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker234">
       </a>
      </span>
      <span class="No-Break">
       values
      </span>
     </li>
     <li>
      <strong class="bold">
       Color animation
      </strong>
      : Animates
      <a id="_idIndexMarker235">
      </a>
      changes
      <a id="_idIndexMarker236">
      </a>
      in
      <span class="No-Break">
       color values
      </span>
     </li>
     <li>
      <strong class="bold">
       Number animation
      </strong>
      : Animates
      <a id="_idIndexMarker237">
      </a>
      changes in
      <span class="No-Break">
       qreal-type
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker238">
       </a>
      </span>
      <span class="No-Break">
       values
      </span>
     </li>
     <li>
      <strong class="bold">
       Parent animation
      </strong>
      : Animates
      <a id="_idIndexMarker239">
      </a>
      changes
      <a id="_idIndexMarker240">
      </a>
      in
      <span class="No-Break">
       parent values
      </span>
     </li>
     <li>
      <strong class="bold">
       Path animation
      </strong>
      : Animates
      <a id="_idIndexMarker241">
      </a>
      an item
      <a id="_idIndexMarker242">
      </a>
      along
      <span class="No-Break">
       a path
      </span>
     </li>
     <li>
      <strong class="bold">
       Property animation
      </strong>
      : Animates
      <a id="_idIndexMarker243">
      </a>
      changes in
      <span class="No-Break">
       property values
      </span>
     </li>
     <li>
      <strong class="bold">
       Rotation animation
      </strong>
      : Animates
      <a id="_idIndexMarker244">
      </a>
      changes
      <a id="_idIndexMarker245">
      </a>
      in
      <span class="No-Break">
       rotation values
      </span>
     </li>
     <li>
      <strong class="bold">
       Vector3d animation
      </strong>
      : Animates
      <a id="_idIndexMarker246">
      </a>
      changes in
      <span class="No-Break">
       QVector3D
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker247">
       </a>
      </span>
      <span class="No-Break">
       values
      </span>
     </li>
    </ul>
    <p>
     Just like the C++ version, these animations can also be grouped together in an animation group to play the animations in sequence or parallel. You can also control the animations using easing curves and determine when to play these animations using state machines, just like we
     <a id="_idIndexMarker248">
     </a>
     did in the
     <span class="No-Break">
      previous section.
     </span>
    </p>
    <h1 id="_idParaDest-81">
     <a id="_idTextAnchor081">
     </a>
     Animating widget properties using animators
    </h1>
    <p>
     In this recipe, we will learn how to
     <a id="_idIndexMarker249">
     </a>
     animate the properties of our GUI
     <a id="_idIndexMarker250">
     </a>
     widgets using the animator feature that’s provided
     <span class="No-Break">
      by QML.
     </span>
    </p>
    <h2 id="_idParaDest-82">
     <a id="_idTextAnchor082">
     </a>
     How to do it…
    </h2>
    <p>
     Animating QML objects is really easy if you perform the
     <span class="No-Break">
      following steps:
     </span>
    </p>
    <ol>
     <li>
      Create a
      <strong class="source-inline">
       Rectangle
      </strong>
      object and add a
      <em class="italic">
       scale animator
      </em>
      <span class="No-Break">
       to it:
      </span>
      <pre class="source-code">
Rectangle {
    id: myBox;
    width: 50;
    height: 50;
    anchors.horizontalCenter: parent.horizontalCenter;
    anchors.verticalCenter: parent.verticalCenter;
    color: "blue";
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
        running: true;
    }
}</pre>
     </li>
     <li>
      Add a
      <em class="italic">
       rotation animator
      </em>
      and set
      <a id="_idIndexMarker251">
      </a>
      the
      <strong class="source-inline">
       running
      </strong>
      value in the parallel animation group, but not in any of
      <a id="_idIndexMarker252">
      </a>
      the
      <span class="No-Break">
       individual animators:
      </span>
      <pre class="source-code">
ParallelAnimation {
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
    }
    RotationAnimator {
        target: myBox;
        from: 0;
        to: 360;
        duration: 1000;
    }
    running: true;
}</pre>
     </li>
     <li>
      Add an
      <em class="italic">
       easing curve
      </em>
      to
      <a id="_idIndexMarker253">
      </a>
      the
      <span class="No-Break">
       <em class="italic">
        scale animator
       </em>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
ScaleAnimator {
    target: myBox;
    from: 5;
    to: 1;
    duration: 2000;
    easing.type: Easing.InOutElastic;
    easing.amplitude: 2.0;
    easing.period: 1.5;
    running: true;
}</pre>
     </li>
    </ol>
    <h2 id="_idParaDest-83">
     <a id="_idTextAnchor083">
     </a>
     How it works…
    </h2>
    <p>
     The
     <em class="italic">
      animator
     </em>
     type can be used just like any other
     <em class="italic">
      animation
     </em>
     type. We want to scale a rectangle from a size of
     <strong class="source-inline">
      5
     </strong>
     to a size
     <a id="_idIndexMarker254">
     </a>
     of
     <strong class="source-inline">
      1
     </strong>
     within 2,000 milliseconds (2 seconds). We created a blue
     <strong class="source-inline">
      Rectangle
     </strong>
     object and added a
     <em class="italic">
      scale animator
     </em>
     to it. We set the
     <strong class="source-inline">
      initial
     </strong>
     value to
     <strong class="source-inline">
      5
     </strong>
     and the
     <strong class="source-inline">
      final
     </strong>
     value to
     <strong class="source-inline">
      1
     </strong>
     . Then, we set the animation
     <strong class="source-inline">
      duration
     </strong>
     to
     <strong class="source-inline">
      2000
     </strong>
     and set the
     <strong class="source-inline">
      running
     </strong>
     value to
     <strong class="source-inline">
      true
     </strong>
     so that it will be played when the
     <span class="No-Break">
      program starts.
     </span>
    </p>
    <p>
     Just like the animation types, animators can also be put into
     <a id="_idIndexMarker255">
     </a>
     groups (that is,
     <strong class="bold">
      parallel
     </strong>
     <strong class="bold">
      animation groups
     </strong>
     or
     <strong class="bold">
      sequential animation groups
     </strong>
     ). An animation group will also be treated as an animator by QtQuick and
     <a id="_idIndexMarker256">
     </a>
     be run on the scene graph’s rendering thread whenever possible. In step 2, we want to group two different animators into a
     <strong class="bold">
      parallel animation group
     </strong>
     so that they run together at the
     <span class="No-Break">
      same time.
     </span>
    </p>
    <p>
     We will keep the
     <strong class="bold">
      scale animator
     </strong>
     we created previously and add another
     <strong class="bold">
      rotation animator
     </strong>
     to rotate the
     <strong class="bold">
      Rectangle
     </strong>
     object. This time, set the
     <strong class="source-inline">
      running
     </strong>
     value in the parallel animation group, but not in any of the
     <span class="No-Break">
      individual animators.
     </span>
    </p>
    <p>
     Just like the C++ version, QML also supports
     <strong class="bold">
      easing curves
     </strong>
     , and they can be easily applied to any of the animations or
     <span class="No-Break">
      animator types.
     </span>
    </p>
    <h2 id="_idParaDest-84">
     <a id="_idTextAnchor084">
     </a>
     There’s more…
    </h2>
    <p>
     There is something called an
     <em class="italic">
      animator
     </em>
     in QML, which
     <a id="_idIndexMarker257">
     </a>
     is different from the usual
     <em class="italic">
      animation
     </em>
     type, even though there is
     <a id="_idIndexMarker258">
     </a>
     some similarity between them. Unlike regular animation types, animator types
     <a id="_idIndexMarker259">
     </a>
     are directly operated on Qt Quick’s
     <strong class="bold">
      scene graph
     </strong>
     , rather than
     <a id="_idIndexMarker260">
     </a>
     the QML objects and their properties. The value of the QML property will not be changed while the animation is running, as it will only change once the animation is finished. The benefit of using the animator type is that it operates directly
     <a id="_idIndexMarker261">
     </a>
     on the scene graph’s rendering thread, which means its performance will be slightly better than running on the
     <span class="No-Break">
      <strong class="bold">
       UI thread
      </strong>
     </span>
     <span class="No-Break">
      .
     </span>
    </p>
    <h1 id="_idParaDest-85">
     <a id="_idTextAnchor085">
     </a>
     Sprite animation
    </h1>
    <p>
     In this example, we will learn how
     <a id="_idIndexMarker262">
     </a>
     to create a
     <strong class="bold">
      sprite animation
     </strong>
     <span class="No-Break">
      in
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker263">
      </a>
     </span>
     <span class="No-Break">
      QML.
     </span>
    </p>
    <h2 id="_idParaDest-86">
     <a id="_idTextAnchor086">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s make a horse run across our application window by following
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      We will need to add our sprite sheet to Qt’s
      <em class="italic">
       resource system
      </em>
      so that it can be used in the program. Open up
      <strong class="source-inline">
       qml.qrc
      </strong>
      and click the
      <strong class="bold">
       Add
      </strong>
      |
      <strong class="bold">
       Add Files
      </strong>
      buttons. Select your sprite sheet image and save the resource file by pressing
      <em class="italic">
       Ctrl
      </em>
      +
      <span class="No-Break">
       <em class="italic">
        S
       </em>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      Create a new empty window
      <span class="No-Break">
       in
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        main.qml
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true
    width: 420
    height: 380
    Rectangle {
        anchors.fill: parent
        color: "white"
    }
}</pre>
     </li>
     <li>
      Once you are done
      <a id="_idIndexMarker264">
      </a>
      with that, we will start creating
      <a id="_idIndexMarker265">
      </a>
      an
      <strong class="source-inline">
       AnimatedSprite
      </strong>
      object
      <span class="No-Break">
       in QML:
      </span>
      <pre class="source-code">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true;
    width: 420;
    height: 380;
    Rectangle {
        anchors.fill: parent;
        color: "white";
     }</pre>
     </li>
     <li>
      Then, set
      <span class="No-Break">
       the following:
      </span>
      <pre class="source-code">
     AnimatedSprite {
         id: sprite;
        width: 128;
        height: 128;
        anchors.centerIn: parent;
         source: "qrc:///horse_1.png";
         frameCount: 11;
         frameWidth: 128;
         frameHeight: 128;
         frameRate: 25;
         loops: Animation.Infinite;
         running: true;
     }
}</pre>
     </li>
     <li>
      Add a
      <em class="italic">
       mouse area
      </em>
      to
      <a id="_idIndexMarker266">
      </a>
      the window and check for the
      <span class="No-Break">
       <strong class="source-inline">
        onClicked
       </strong>
      </span>
      <span class="No-Break">
       event:
      </span>
      <pre class="source-code">
MouseArea {
    anchors.fill: parent;
    onClicked: {
        if (sprite.paused)
            sprite.resume();
        else
            sprite.pause();
    }
}</pre>
     </li>
     <li>
      If you compile and run
      <a id="_idIndexMarker267">
      </a>
      the example program now, you will see a little pony running in the middle of the window.
      <span class="No-Break">
       How fun:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer056">
      <img alt="Figure 3.8 – A horse running across the application window" src="../images\image/B20976_03_008.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 3.8 – A horse running across the application window
    </p>
    <ol>
     <li value="7">
      Next, we want to try and do
      <a id="_idIndexMarker268">
      </a>
      something cool. We will make the horse run
      <a id="_idIndexMarker269">
      </a>
      across the window and loop infinitely while playing its running animation! First, we need to remove
      <strong class="source-inline">
       anchors.centerIn: parent
      </strong>
      from QML and replace it with
      <strong class="source-inline">
       x
      </strong>
      and
      <span class="No-Break">
       <strong class="source-inline">
        y
       </strong>
      </span>
      <span class="No-Break">
       values:
      </span>
      <pre class="source-code">
AnimatedSprite {
    id: sprite;
     width: 128;
     height: 128;
     <strong class="bold">x: -128;</strong>
<strong class="bold">     y: parent.height / 2;</strong>
     source: "qrc:///horse_1.png";
     frameCount: 11;
     frameWidth: 128;
     frameHeight: 128;
     frameRate: 25;
     loops: Animation.Infinite;
     running: true;
}</pre>
     </li>
     <li>
      Add a
      <em class="italic">
       number animation
      </em>
      to the sprite
      <a id="_idIndexMarker270">
      </a>
      object and set its properties,
      <span class="No-Break">
       as
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker271">
       </a>
      </span>
      <span class="No-Break">
       follows:
      </span>
      <pre class="source-code">
NumberAnimation {
    target: sprite;
    property: "x";
     from: -128;
     to: 512;
     duration: 3000;
     loops: Animation.Infinite;
     running: true;
}</pre>
     </li>
     <li>
      If you compile and run the example program now, you will see the pony go crazy and start running across
      <span class="No-Break">
       the window!
      </span>
     </li>
    </ol>
    <h2 id="_idParaDest-87">
     <a id="_idTextAnchor087">
     </a>
     How it works…
    </h2>
    <p>
     In this recipe, we place the animated sprite object in the middle of the window and set its image source to the sprite sheet that we have just added to the project resource. Then, we count how many frames there are in the sprite sheet that belong to the running animation, which in this case is 11 frames. We also inform Qt of the dimensions of each frame of the animation, which in this case are
     <strong class="source-inline">
      128 x 128
     </strong>
     . After that, we set the frame rate to
     <strong class="source-inline">
      25
     </strong>
     to get a decent speed and then set it to loop infinitely. We then set the
     <strong class="source-inline">
      running
     </strong>
     value to
     <strong class="source-inline">
      true
     </strong>
     so that
     <a id="_idIndexMarker272">
     </a>
     the animation will play by default when the program
     <span class="No-Break">
      starts running.
     </span>
    </p>
    <p>
     Then, in
     <em class="italic">
      step 4
     </em>
     , we want to be
     <a id="_idIndexMarker273">
     </a>
     able to pause the animation and resume it by clicking on the window. We simply check whether the sprite is currently paused when clicking on the mouse area. If the sprite animation is paused, then the animation resumes; otherwise, the animation
     <span class="No-Break">
      is paused.
     </span>
    </p>
    <p>
     In
     <em class="italic">
      step 6
     </em>
     , we replace
     <strong class="source-inline">
      anchors.centerIn
     </strong>
     with
     <strong class="source-inline">
      x
     </strong>
     and
     <strong class="source-inline">
      y
     </strong>
     values so that the animated sprite object is not anchored to the center of the window, which would make it impossible to move around. Then, we create a
     <em class="italic">
      number animation
     </em>
     within the animated sprite to animate its
     <strong class="source-inline">
      x
     </strong>
     property. We set the
     <strong class="source-inline">
      start
     </strong>
     value to somewhere outside the window on the left side, and we set the
     <strong class="source-inline">
      end
     </strong>
     value to somewhere outside the window on the right side. After that, we set the
     <strong class="source-inline">
      duration
     </strong>
     to 3,000 milliseconds (3 seconds) and make it
     <span class="No-Break">
      loop infinitely.
     </span>
    </p>
    <p>
     Lastly, we also set the
     <strong class="source-inline">
      running
     </strong>
     value to
     <strong class="source-inline">
      true
     </strong>
     so that it plays the animation by default when the program
     <span class="No-Break">
      starts running.
     </span>
    </p>
    <h2 id="_idParaDest-88">
     <a id="_idTextAnchor088">
     </a>
     There’s more…
    </h2>
    <p>
     Sprite animation is used extensively, especially in game development. Sprites are used for character animation, particle animation, and even GUI animation. A sprite sheet consists of many images combined into one, which can then be chopped down and displayed on the screen, one at a time. The transitions between different images (or sprites) from the sprite sheet creates the illusion of animation, which we usually refer to as a sprite animation. A Sprite animation can be easily achieved in QML using the
     <span class="No-Break">
      <strong class="source-inline">
       AnimatedSprite
      </strong>
     </span>
     <span class="No-Break">
      type.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     In this example program, I am using a free
     <a id="_idIndexMarker274">
     </a>
     and open source image that was created by
     <strong class="bold">
      bluecarrot16
     </strong>
     under the
     <em class="italic">
      CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY 3.0
     </em>
     license. The image can be obtained legally
     <span class="No-Break">
      at
     </span>
     <a href="http://opengameart.org/content/lpc-horse">
      <span class="No-Break">
       http://opengameart.org/content/lpc-horse
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
