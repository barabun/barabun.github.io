<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   22Date and Time Utilities
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_032.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_034.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c22_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c22_1">
      <span aria-label="861" epub:type="pagebreak" id="Page_861" role="doc-pagebreak">
      </span>
      <span id="c22">
      </span>
      <span class="chapterNumber">
       22
      </span>
      <br/>
      <span class="chapterTitle">
       Date and Time Utilities
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c22-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c22-list-0001">
         <li id="c22-li-0001">
          How to work with compile-time rational numbers
         </li>
         <li id="c22-li-0002">
          How to work with time
         </li>
         <li id="c22-li-0003">
          How to work with dates and calendars
         </li>
         <li id="c22-li-0004">
          How to convert time points between different time zones
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c22-fea-0001">
        </span>
        <h3 id="head-2-226">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c22-sec-0003">
        </span>
        <p id="c22-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <a href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p>
      This chapter discusses the time-related functionality provided by the C++ Standard Library, known collectively as the
      <i>
       chrono library
      </i>
      . It is a collection of classes and functions to work with time and dates. The library consists of the following components:
     </p>
     <ul class="check1" id="c22-list-0002">
      <li id="c22-li-0005">
       Durations
      </li>
      <li id="c22-li-0006">
       Clocks
      </li>
      <li id="c22-li-0007">
       Time points
      </li>
      <li id="c22-li-0008">
       Dates
      </li>
      <li id="c22-li-0009">
       Time zones
      </li>
     </ul>
     <p id="c22-para-0006">
      Everything is defined in
      <code>
       &lt;chrono&gt;
      </code>
      in the
      <code>
       std::chrono
      </code>
      namespace. However, before we can start the discussion of each of these chrono library components, we need a small digression to look at the compile-time rational number support available in C++, as this is heavily used by the chrono library.
     </p>
    </section>
    <span aria-label="862" epub:type="pagebreak" id="Page_862" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-227">
     <span id="c22-sec-0004">
     </span>
     <h2 id="head-2-227">
      COMPILE-TIME RATIONAL NUMBERS
     </h2>
     <p>
      The Ratio library allows you to exactly represent any finite rational number that you can use at compile time. Everything is defined in
      <code>
       &lt;ratio&gt;
      </code>
      and is in the
      <code>
       std
      </code>
      namespace. The numerator and denominator of a rational number are represented as compile-time constants of type
      <code>
       std::intmax_t
      </code>
      , which is a signed integer type with the maximum width supported by a compiler. Because of the compile-time nature of these rational numbers, using them might look a bit different than what you are used to. You cannot define a
      <code>
       ratio
      </code>
      object the same way as you define normal objects, and you cannot call member functions on it. Instead,
      <code>
       ratio
      </code>
      is a class template, and a specific instantiation of the
      <code>
       ratio
      </code>
      class template represents one specific rational number. To name such specific instantiations, you can use type aliases. For example, the following defines a compile-time rational number representing the fraction 1/60:
     </p>
     <pre id="c22-code-0001"><code>using r1 = ratio&lt;1, 60&gt;;</code></pre>
     <p>
      The numerator (
      <code>
       num
      </code>
      ) and denominator (
      <code>
       den
      </code>
      ) of the
      <code>
       r1
      </code>
      rational number are compile-time constants and can be accessed as follows:
     </p>
     <pre id="c22-code-0002"><code>intmax_t num { r1::num };</code>
<code>intmax_t den { r1::den };</code></pre>
     <p>
      Remember that a
      <code>
       ratio
      </code>
      represents a
      <i>
       compile-time rational number
      </i>
      , which means that the numerator and denominator need to be known at compile time. The following generates a compilation error:
     </p>
     <pre id="c22-code-0003"><code>intmax_t n { 1 };          <span class="color3">// Numerator</span></code>
<code>intmax_t d { 60 };         <span class="color3">// Denominator</span></code>
<code>using r1 = ratio&lt;n, d&gt;;    <span class="color3">// Error</span></code></pre>
     <p>
      Making
      <code>
       n
      </code>
      and
      <code>
       d
      </code>
      constants works fine:
     </p>
     <pre id="c22-code-0004"><code>const intmax_t n { 1 };    <span class="color3">// Numerator</span></code>
<code>const intmax_t d { 60 };   <span class="color3">// Denominator</span></code>
<code>using r1 = ratio&lt;n, d&gt;;    <span class="color3">// Ok</span></code></pre>
     <p>
      Rational numbers are always normalized. For a rational number
      <code>
       ratio&lt;n, d&gt;
      </code>
      , the greatest common divisor,
      <code>
       gcd
      </code>
      , is calculated, and the numerator,
      <code>
       num
      </code>
      , and denominator,
      <code>
       den
      </code>
      , are then defined as follows:
     </p>
     <ul class="check1" id="c22-list-0003">
      <li id="c22-li-0010">
       <code>
        num = sign(n)*sign(d)*abs(n)/gcd
       </code>
      </li>
      <li id="c22-li-0011">
       <code>
        den = abs(d)/gcd
       </code>
      </li>
     </ul>
     <p>
      The library supports adding, subtracting, multiplying, and dividing rational numbers. However, you cannot use the standard arithmetic operators because all these operations are again not happening on objects but on types, i.e., instantiations of the
      <code>
       ratio
      </code>
      class template, at compile time. Instead, you need to use specific arithmetic
      <code>
       ratio
      </code>
      class templates. The following arithmetic class templates are available:
      <code>
       ratio_add
      </code>
      ,
      <code>
       ratio_subtract
      </code>
      ,
      <code>
       ratio_multiply
      </code>
      , and
      <code>
       ratio_divide
      </code>
      , which perform addition, subtraction, multiplication, and division, respectively. These templates calculate the result as a new
      <code>
       ratio
      </code>
      type. This type can be accessed with the embedded type alias called
      <code>
       type
      </code>
      . For example, the following code first defines two
      <code>
       ratio
      </code>
      s, one representing 1/60 and the other representing 1/30. The
      <code>
       ratio_add
      </code>
      template adds those two rational numbers together to produce the
      <code>
       result
      </code>
      rational number, which, after normalization, is 1/20:
     </p>
     <pre id="c22-code-0005"><code>using r1 = ratio&lt;1, 60&gt;;</code>
<span aria-label="863" epub:type="pagebreak" id="Page_863" role="doc-pagebreak"></span><code>using r2 = ratio&lt;1, 30&gt;;</code>
<code>using result = ratio_add&lt;r1, r2&gt;::type;</code></pre>
     <p>
      The standard also defines a number of
      <code>
       ratio
      </code>
      comparison class templates:
      <code>
       ratio_equal
      </code>
      ,
      <code>
       ratio_not_equal
      </code>
      ,
      <code>
       ratio_less
      </code>
      ,
      <code>
       ratio_less_equal
      </code>
      ,
      <code>
       ratio_greater
      </code>
      , and
      <code>
       ratio_greater_equal
      </code>
      . Just like the arithmetic
      <code>
       ratio
      </code>
      class templates, the
      <code>
       ratio
      </code>
      comparison class templates are all evaluated at compile time, again not on objects but on
      <code>
       ratio
      </code>
      types. These comparison templates define a new type that is an
      <code>
       std::bool_constant
      </code>
      , representing the result.
      <code>
       bool_constant
      </code>
      is an
      <code>
       std::integral_constant
      </code>
      , a
      <code>
       struct
      </code>
      template that stores a type and a compile-time constant value. For example,
      <code>
       integral_constant&lt;int, 15&gt;
      </code>
      stores an integer with value 15.
      <code>
       bool_constant
      </code>
      is an
      <code>
       integral_constant
      </code>
      with type
      <code>
       bool
      </code>
      . For instance,
      <code>
       bool_constant&lt;true&gt;
      </code>
      is
      <code>
       integral_constant&lt;bool, true&gt;
      </code>
      , which stores a Boolean with value
      <code>
       true
      </code>
      . The result of the
      <code>
       ratio
      </code>
      comparison templates is either
      <code>
       bool_constant&lt;true&gt;
      </code>
      or
      <code>
       bool_constant&lt;false&gt;
      </code>
      . The value associated with a
      <code>
       bool_constant
      </code>
      or an
      <code>
       integral_constant
      </code>
      can be accessed using the
      <code>
       value
      </code>
      data member. The following example demonstrates the use of
      <code>
       ratio_less
      </code>
      :
     </p>
     <pre id="c22-code-0006"><code>using r1 = ratio&lt;1, 60&gt;;</code>
<code>using r2 = ratio&lt;1, 30&gt;;</code>
<code>using res = ratio_less&lt;r2, r1&gt;;</code>
<code>println("{}", res::value); <span class="color3">// false</span></code></pre>
     <p>
      The following code snippet combines everything just covered. Because
      <code>
       ratio
      </code>
      s are not objects but types, you cannot do something like
      <code>
       println("{}", r1)
      </code>
      ; you need to get the numerator and denominator and print them separately.
     </p>
     <pre id="c22-code-0007"><code><span class="color3">// Define a compile-time rational number.</span></code>
<code>using r1 = ratio&lt;1, 60&gt;;</code>
<code></code>
<code><span class="color3">// Get numerator and denominator.</span></code>
<code>intmax_t num { r1::num };</code>
<code>intmax_t den { r1::den };</code>
<code>println("1) r1 = {}/{}", num, den);</code>
<code></code>
<code><span class="color3">// Add two rational numbers.</span></code>
<code>using r2 = ratio&lt;1, 30&gt;;</code>
<code>println("2) r2 = {}/{}", r2::num, r2::den);</code>
<code>using result = ratio_add&lt;r1, r2&gt;::type;</code>
<code>println("3) sum = {}/{}", result::num, result::den);</code>
<code></code>
<code><span class="color3">// Compare two rational numbers.</span></code>
<code>using res = ratio_less&lt;r2, r1&gt;;</code>
<code>println("4) r2 &lt; r1: {}", res::value);</code></pre>
     <p>
      The output is as follows:
     </p>
     <pre id="c22-code-0008"><code>1) r1 = 1/60</code>
<code>2) r2 = 1/30</code>
<code>3) sum = 1/20</code>
<code>4) r2 &lt; r1: false</code></pre>
     <p>
      The library provides a number of SI (
      <i>
       Système International
      </i>
      ) type aliases for your convenience. They are as follows:
     </p>
     <pre id="c22-code-0009"><code>using yocto = ratio&lt;1, 1'000'000'000'000'000'000'000'000&gt;; <span class="color3">// *</span></code>
<code>using zepto = ratio&lt;1, 1'000'000'000'000'000'000'000&gt;;     <span class="color3">// *</span></code>
<code>using atto  = ratio&lt;1, 1'000'000'000'000'000'000&gt;;</code>
<code>using femto = ratio&lt;1, 1'000'000'000'000'000&gt;;</code>
<span aria-label="864" epub:type="pagebreak" id="Page_864" role="doc-pagebreak"></span><code>using pico  = ratio&lt;1, 1'000'000'000'000&gt;;</code>
<code>using nano  = ratio&lt;1, 1'000'000'000&gt;;</code>
<code>using micro = ratio&lt;1, 1'000'000&gt;;</code>
<code>using milli = ratio&lt;1, 1'000&gt;;</code>
<code>using centi = ratio&lt;1, 100&gt;;</code>
<code>using deci  = ratio&lt;1, 10&gt;;</code>
<code>using deca  = ratio&lt;10, 1&gt;;</code>
<code>using hecto = ratio&lt;100, 1&gt;;</code>
<code>using kilo  = ratio&lt;1'000, 1&gt;;</code>
<code>using mega  = ratio&lt;1'000'000, 1&gt;;</code>
<code>using giga  = ratio&lt;1'000'000'000, 1&gt;;</code>
<code>using tera  = ratio&lt;1'000'000'000'000, 1&gt;;</code>
<code>using peta  = ratio&lt;1'000'000'000'000'000, 1&gt;;</code>
<code>using exa   = ratio&lt;1'000'000'000'000'000'000, 1&gt;;</code>
<code>using zetta = ratio&lt;1'000'000'000'000'000'000'000, 1&gt;;     <span class="color3">// *</span></code>
<code>using yotta = ratio&lt;1'000'000'000'000'000'000'000'000, 1&gt;; <span class="color3">// *</span></code></pre>
     <p id="c22-para-0017">
      The SI units with an asterisk at the end are defined only if your compiler can represent the constant numerator and denominator values for those type aliases as an
      <code>
       intmax_t
      </code>
      . An example of how to use these predefined SI units is given during the discussion of
      <code>
       duration
      </code>
      s in the next section.
     </p>
    </section>
    <section aria-labelledby="head-2-228">
     <span id="c22-sec-0005">
     </span>
     <h2 id="head-2-228">
      DURATION
     </h2>
     <p>
      A
      <i>
       duration
      </i>
      is an interval between two points in time. It is represented by the
      <code>
       duration
      </code>
      class template, which stores a number of
      <i>
       ticks
      </i>
      and a
      <i>
       tick period
      </i>
      . The tick period is the time in seconds between two ticks and is represented as a compile-time
      <code>
       ratio
      </code>
      constant, which means it could be a fraction of a second. Ratios are discussed in the previous section. The
      <code>
       duration
      </code>
      template accepts two template type parameters and is defined as follows:
     </p>
     <pre id="c22-code-0010"><code>template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration {…}</code></pre>
     <p id="c22-para-0019">
      The first template parameter,
      <code>
       Rep
      </code>
      , is the type of variable storing the number of ticks and should be an arithmetic type, for example
      <code>
       long
      </code>
      ,
      <code>
       double
      </code>
      , and so on. The second template parameter,
      <code>
       Period
      </code>
      , is the rational constant representing the period of a tick. If you don't specify the tick period, the default value
      <code>
       ratio&lt;1&gt;
      </code>
      is used, which represents a tick period of one second.
     </p>
     <p id="c22-para-0020">
      Three constructors are provided: the default constructor; one that accepts a single value, the number of ticks; and one that accepts another
      <code>
       duration
      </code>
      . The latter constructor can be used to convert from one
      <code>
       duration
      </code>
      to another
      <code>
       duration
      </code>
      , for example, from minutes to seconds. An example is given later in this section.
     </p>
     <p id="c22-para-0021">
      Durations support arithmetic operations such as
      <code>
       +
      </code>
      ,
      <code>
       -
      </code>
      ,
      <code>
       *
      </code>
      ,
      <code>
       /
      </code>
      ,
      <code>
       %
      </code>
      ,
      <code>
       ++
      </code>
      ,
      <code>
       --
      </code>
      ,
      <code>
       +=
      </code>
      ,
      <code>
       -=
      </code>
      ,
      <code>
       *=
      </code>
      ,
      <code>
       /=
      </code>
      , and
      <code>
       %=
      </code>
      , and they support the comparison operators
      <code>
       ==
      </code>
      and
      <code>
       &lt;=&gt;
      </code>
      . The class also contains the member functions shown in the following table:
     </p>
     <table border="1">
      <thead>
       <tr>
        <th class="left bgcolor2" scope="col">
         MEMBER FUNCTION
        </th>
        <th class="left bgcolor2" scope="col">
         DESCRIPTION
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          Rep count() const
         </span>
        </td>
        <td class="left bgcolor3">
         Returns the
         <span class="forecolor1">
          duration
         </span>
         value as the number of ticks. The return type is the type specified as the first template type parameter for the
         <code>
          duration
         </code>
         template.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          static duration zero()
         </span>
        </td>
        <td class="left bgcolor3">
         Returns a
         <span class="forecolor1">
          duration
         </span>
         with a duration value equivalent to zero.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          static duration min()
         </span>
         <code>
          static duration max()
         </code>
        </td>
        <td class="left bgcolor3">
         Returns a
         <span class="forecolor1">
          duration
         </span>
         with the minimum/maximum possible duration value representable by the type specified as the first template type parameter for the
         <code>
          duration
         </code>
         template.
         <span aria-label="865" epub:type="pagebreak" id="Page_865" role="doc-pagebreak">
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <p id="c22-para-0024">
      The library supports
      <code>
       floor()
      </code>
      ,
      <code>
       ceil()
      </code>
      ,
      <code>
       round()
      </code>
      , and
      <code>
       abs()
      </code>
      operations on
      <code>
       duration
      </code>
      s that behave just as they behave with numerical data.
     </p>
     <p>
      Let's now see how
      <code>
       duration
      </code>
      s can be defined. A
      <code>
       duration
      </code>
      where each tick is one second can be defined as follows:
     </p>
     <pre id="c22-code-0011"><code>duration&lt;long&gt; d1;</code></pre>
     <p>
      Because
      <code>
       ratio&lt;1&gt;
      </code>
      is the default tick period, this is the same as writing:
     </p>
     <pre id="c22-code-0012"><code>duration&lt;long, ratio&lt;1&gt;&gt; d1;</code></pre>
     <p>
      The next statement defines a
      <code>
       duration
      </code>
      in minutes (tick period = 60 seconds):
     </p>
     <pre id="c22-code-0013"><code>duration&lt;long, ratio&lt;60&gt;&gt; d2;</code></pre>
     <p>
      Here is a
      <code>
       duration
      </code>
      where each tick period is a sixtieth of a second:
     </p>
     <pre id="c22-code-0014"><code>duration&lt;double, ratio&lt;1, 60&gt;&gt; d3;</code></pre>
     <p>
      As you saw earlier in this chapter,
      <code>
       &lt;ratio&gt;
      </code>
      defines a number of SI rational constants. These predefined constants come in handy for defining tick periods. For example, the next statement defines a
      <code>
       duration
      </code>
      where each tick period is one millisecond:
     </p>
     <pre id="c22-code-0015"><code>duration&lt;long long, milli&gt; d4;</code></pre>
     <section>
      <span id="c22-sec-0006">
      </span>
      <h3 id="head-3-461">
       Examples and Converting Durations
      </h3>
      <p>
       Let's see
       <code>
        duration
       </code>
       s in action. The following example demonstrates several aspects of
       <code>
        duration
       </code>
       s. It shows you how to define them, how to perform arithmetic operations on them, how to print them to the screen, and how to convert one
       <code>
        duration
       </code>
       to another
       <code>
        duration
       </code>
       with a different tick period:
      </p>
      <pre id="c22-code-0016"><code><span class="color3">// Specify a duration where each tick is 60 seconds.</span></code>
<code>duration&lt;long, ratio&lt;60&gt;&gt; d1 { 123 };</code>
<code>println("{} ({})", d1, d1.count());</code>
<code></code>
<code><span class="color3">// Specify a duration represented by a double with each tick</span></code>
<code><span class="color3">// equal to 1 second and assign the largest possible duration to it.</span></code>
<code>auto d2 { duration&lt;double&gt;::max() };</code>
<code>println("{}", d2);</code>
<code></code>
<code><span class="color3">// Define 2 durations:</span></code>
<code><span class="color3">// For the first duration, each tick is 1 minute.</span></code>
<code><span class="color3">// For the second duration, each tick is 1 second.</span></code>
<code>duration&lt;long, ratio&lt;60&gt;&gt; d3 { 10 };  <span class="color3">// = 10 minutes</span></code>
<code>duration&lt;long, ratio&lt;1&gt;&gt; d4 { 14 };   <span class="color3">// = 14 seconds</span></code>
<code></code>
<code><span class="color3">// Compare both durations.</span></code>
<code>if (d3 &gt; d4) { println("d3 &gt; d4"); }</code>
<code>else { println("d3 &lt;= d4"); }</code>
<code></code>
<span aria-label="866" epub:type="pagebreak" id="Page_866" role="doc-pagebreak"></span><code><span class="color3">// Increment d4 with 1 resulting in 15 seconds.</span></code>
<code>++d4;</code>
<code></code>
<code><span class="color3">// Multiply d4 by 2 resulting in 30 seconds.</span></code>
<code>d4 *= 2;</code>
<code></code>
<code><span class="color3">// Add both durations and store as minutes.</span></code>
<code>duration&lt;double, ratio&lt;60&gt;&gt; d5 { d3 + d4 };</code>
<code></code>
<code><span class="color3">// Add both durations and store as seconds.</span></code>
<code>duration&lt;long, ratio&lt;1&gt;&gt; d6 { d3 + d4 };</code>
<code>println("{} + {} = {} or {}", d3, d4, d5, d6);</code>
<code></code>
<code><span class="color3">// Create a duration of 30 seconds.</span></code>
<code>duration&lt;long&gt; d7 { 30 };</code>
<code></code>
<code><span class="color3">// Convert the seconds of d7 to minutes.</span></code>
<code>duration&lt;double, ratio&lt;60&gt;&gt; d8 { d7 };</code>
<code>println("{} = {}", d7, d8);</code>
<code>println("{} seconds = {} minutes", d7.count(), d8.count());</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c22-code-0017"><code>123min (123)</code>
<code>1.79769e+308s</code>
<code>d3 &gt; d4</code>
<code>10min + 30s = 10.5min or 630s</code>
<code>30s = 0.5min</code>
<code>30 seconds = 0.5 minutes</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c22-para-0033">
          <b>
           NOTE
          </b>
          <i>
           The second line in the output represents the largest possible
          </i>
          <code>
           duration
          </code>
          <i>
           with type
          </i>
          <code>
           double
          </code>
          <i>
           . The exact value might be different depending on your compiler.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       Pay special attention to the following two lines of code:
      </p>
      <pre id="c22-code-0018"><code>duration&lt;double, ratio&lt;60&gt;&gt; d5 { d3 + d4 };</code>
<code>duration&lt;long, ratio&lt;1&gt;&gt; d6 { d3 + d4 };</code></pre>
      <p id="c22-para-0035">
       They both calculate
       <code>
        d3+d4
       </code>
       , with
       <code>
        d3
       </code>
       given in minutes and
       <code>
        d4
       </code>
       in seconds, but the first statement stores it as a floating-point value representing minutes, while the second statement stores the result as an integral value representing seconds. Conversion from minutes to seconds, or vice versa, happens automatically.
      </p>
      <p>
       The following two lines from the example demonstrate how to explicitly convert between different units of time:
      </p>
      <pre id="c22-code-0019"><code>duration&lt;long&gt; d7 { 30 };               <span class="color3">// seconds</span></code>
<code>duration&lt;double, ratio&lt;60&gt;&gt; d8 { d7 };  <span class="color3">// minutes</span></code></pre>
      <p>
       The first statement defines a
       <code>
        duration
       </code>
       representing 30 seconds. The second statement converts these 30 seconds into minutes, resulting in 0.5 minutes. Converting in this direction can result in a non-integral value and thus requires you to use a
       <code>
        duration
       </code>
       represented by a floating-point type; otherwise, you will get some cryptic compilation errors. The following statements, for example, do not compile because
       <code>
        d8
       </code>
       is using
       <code>
        long
       </code>
       instead of a floating-point type:
      </p>
      <pre id="c22-code-0020"><code>duration&lt;long&gt; d7 { 30 };               <span class="color3">// seconds</span></code>
<code><b>duration&lt;long, ratio&lt;60&gt;&gt; d8 { d7 };</b>    <span class="color3">// minutes   // Error!</span></code></pre>
      <p>
       <span aria-label="867" epub:type="pagebreak" id="Page_867" role="doc-pagebreak">
       </span>
       You can, however, force this conversion by using
       <code>
        duration_cast()
       </code>
       :
      </p>
      <pre id="c22-code-0021"><code>duration&lt;long&gt; d7 { 30 };               <span class="color3">// seconds</span></code>
<code><b>auto d8 { duration_cast&lt;duration&lt;long, ratio&lt;60&gt;&gt;&gt;(d7) };</b> <span class="color3">// minutes</span></code></pre>
      <p id="c22-para-0039">
       In this case,
       <code>
        d8
       </code>
       will be 0 minutes, because integer division is used to convert 30 seconds to minutes.
      </p>
      <p>
       Converting in the other direction does not require floating-point types if the source is an integral type, because the result is always an integral value if you started with an integral value. For example, the following statements convert ten minutes into seconds, both represented by the integral type
       <code>
        long
       </code>
       :
      </p>
      <pre id="c22-code-0022"><code>duration&lt;long, ratio&lt;60&gt;&gt; d9 { 10 };    <span class="color3">// minutes</span></code>
<code>duration&lt;long&gt; d10 { d9 };              <span class="color3">// seconds</span></code></pre>
     </section>
     <section>
      <span id="c22-sec-0008">
      </span>
      <h3 id="head-3-462">
       Predefined Durations
      </h3>
      <p>
       The library provides the following standard
       <code>
        duration
       </code>
       types in the
       <code>
        std::chrono
       </code>
       namespace:
      </p>
      <pre id="c22-code-0023"><code>using nanoseconds  = duration&lt;<i>X 64 bits</i>, nano&gt;;</code>
<code>using microseconds = duration&lt;<i>X 55 bits</i>, micro&gt;;</code>
<code>using milliseconds = duration&lt;<i>X 45 bits</i>, milli&gt;;</code>
<code>using seconds      = duration&lt;<i>X 35 bits</i>&gt;;</code>
<code>using minutes      = duration&lt;<i>X 29 bits</i>, ratio&lt;60&gt;&gt;;</code>
<code>using hours        = duration&lt;<i>X 23 bits</i>, ratio&lt;3'600&gt;&gt;;</code>
<code>using days   = duration&lt;<i>X 25 bits</i>, ratio_multiply&lt;ratio&lt;24&gt;, hours::period&gt;&gt;;</code>
<code>using weeks  = duration&lt;<i>X 22 bits</i>, ratio_multiply&lt;ratio&lt;7&gt;, days::period&gt;&gt;;</code>
<code>using years  = duration&lt;<i>X 17 bits</i>,</code>
<code>               ratio_multiply&lt;ratio&lt;146'097, 400&gt;, days::period&gt;&gt;;</code>
<code>using months = duration&lt;<i>X 20 bits</i>, ratio_divide&lt;years::period, ratio&lt;12&gt;&gt;&gt;;</code></pre>
      <p>
       The exact type of
       <i>
        X
       </i>
       depends on your compiler, but the C++ standard requires it to be a signed integer type of at least the specified size. The preceding type aliases make use of the predefined SI
       <code>
        ratio
       </code>
       type aliases that are described earlier in this chapter. With these predefined types, instead of writing this:
      </p>
      <pre id="c22-code-0024"><code>duration&lt;long, ratio&lt;60&gt;&gt; d9 { 10 };    <span class="color3">// minutes</span></code></pre>
      <p>
       you can simply write this:
      </p>
      <pre id="c22-code-0025"><code>minutes d9 { 10 };                      <span class="color3">// minutes</span></code></pre>
      <p>
       The following code is another example of how to use these predefined durations. The code first defines a variable
       <code>
        t
       </code>
       , which is the result of 1 hour + 23 minutes + 45 seconds. The
       <code>
        auto
       </code>
       keyword is used to let the compiler automatically figure out the exact type of
       <code>
        t
       </code>
       . The second statement uses the constructor of the predefined
       <code>
        seconds
       </code>
       duration to convert the value of
       <code>
        t
       </code>
       to seconds and writes the result to the console:
      </p>
      <pre id="c22-code-0026"><code>auto t { hours { 1 } + minutes { 23 } + seconds { 45 } };</code>
<code>println("{}", seconds { t });</code></pre>
      <p>
       Because the standard requires that the predefined durations use integer types, there can be compilation errors if a conversion
       <i>
        could
       </i>
       end up with a non-integral value. While integer division normally truncates, in the case of durations, which are implemented with
       <code>
        ratio
       </code>
       types, the compiler declares any computation that
       <i>
        could
       </i>
       result in a non-zero remainder as a compile-time error. For example, the following code does not compile because converting 90 seconds to minutes results in 1.5 minutes:
      </p>
      <pre id="c22-code-0027"><code>seconds s { 90 };</code>
<code>minutes m { s };</code></pre>
      <p>
       <span aria-label="868" epub:type="pagebreak" id="Page_868" role="doc-pagebreak">
       </span>
       However, the following code does not compile either, even though 60 seconds is exactly 1 minute. It is flagged as a compile-time error because converting from seconds to minutes
       <i>
        could
       </i>
       result in non-integral values:
      </p>
      <pre id="c22-code-0028"><code>seconds s { 60 };</code>
<code>minutes m { s };</code></pre>
      <p>
       Converting in the other direction works perfectly fine because the
       <code>
        minutes
       </code>
       duration uses an integral type, and converting it to
       <code>
        seconds
       </code>
       always results in an integral value:
      </p>
      <pre id="c22-code-0029"><code>minutes m { 2 };</code>
<code>seconds s { m };</code></pre>
     </section>
     <section>
      <span id="c22-sec-0009">
      </span>
      <h3 id="head-3-463">
       Standard Literals
      </h3>
      <p>
       You can use the standard literals
       <code>
        h
       </code>
       ,
       <code>
        min
       </code>
       ,
       <code>
        s
       </code>
       ,
       <code>
        ms
       </code>
       ,
       <code>
        us
       </code>
       , and
       <code>
        ns
       </code>
       for creating durations. Technically, these are defined in the
       <code>
        std::literals::chrono_literals
       </code>
       namespace, but just as for the standard string literals discussed in
       <a href="c02.xhtml">
        Chapter 2
       </a>
       , “Working with Strings and String Views,” the
       <code>
        chrono_literals
       </code>
       namespace is an inline namespace. So, you can make the chrono literals available with any of the following using directives:
      </p>
      <pre id="c22-code-0030"><code>using namespace std;</code>
<code>using namespace std::literals;</code>
<code>using namespace std::chrono_literals;</code>
<code>using namespace std::literals::chrono_literals;</code></pre>
      <p>
       Additionally, the literals are also made available in the
       <code>
        std::chrono
       </code>
       namespace. Here is an example:
      </p>
      <pre id="c22-code-0031"><code>using namespace std::chrono;</code>
<code><span class="color3">// …</span></code>
<code>auto myDuration { 42min };    <span class="color3">// 42 minutes</span></code></pre>
     </section>
     <section>
      <span id="c22-sec-0010">
      </span>
      <h3 id="head-3-464">
       hh_mm_ss
      </h3>
      <p id="c22-para-0050">
       The chrono library provides the
       <code>
        hh_mm_ss
       </code>
       class template, which accepts a
       <code>
        Duration
       </code>
       and splits the given duration into hours, minutes, seconds, and subseconds. It has getters
       <code>
        hours()
       </code>
       ,
       <code>
        minutes()
       </code>
       ,
       <code>
        seconds()
       </code>
       , and
       <code>
        subseconds()
       </code>
       to retrieve the data, always returning non-negative values. The
       <code>
        is_negative()
       </code>
       member function returns
       <code>
        true
       </code>
       if the duration is a negative duration,
       <code>
        false
       </code>
       otherwise. You'll use the
       <code>
        hh_mm_ss
       </code>
       class template in one of the exercises at the end of this chapter.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-229">
     <span id="c22-sec-0011">
     </span>
     <h2 id="head-2-229">
      CLOCK
     </h2>
     <p id="c22-para-0051">
      A
      <code>
       clock
      </code>
      is a class consisting of a
      <code>
       time_point
      </code>
      and a
      <code>
       duration
      </code>
      . The
      <code>
       time_point
      </code>
      type is discussed in detail in the next section, but those details are not required to understand how
      <code>
       clock
      </code>
      s work. However,
      <code>
       time_point
      </code>
      s themselves depend on
      <code>
       clock
      </code>
      s, so it's important to know the details of
      <code>
       clock
      </code>
      s first.
     </p>
     <p id="c22-para-0052">
      The standard defines several
      <code>
       clock
      </code>
      s, which are described in the following table. The
      <i>
       epoch
      </i>
      of a clock is the time at which the clock starts counting.
     </p>
     <p>
      <span aria-label="869" epub:type="pagebreak" id="Page_869" role="doc-pagebreak">
      </span>
     </p>
     <table border="1">
      <thead>
       <tr>
        <th class="left bgcolor2" scope="col">
         CLOCK
        </th>
        <th class="left bgcolor2" scope="col">
         DESCRIPTION
        </th>
        <th class="left bgcolor2" scope="col">
         EPOCH
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          system_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Represents the UTC wall clock time from the system-wide real-time clock.
        </td>
        <td class="left bgcolor3">
         1970-01-01 00:00:00
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          steady_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Guarantees its
         <span class="forecolor1">
          time_point
         </span>
         never decreases, which is not guaranteed for
         <code>
          system_clock
         </code>
         because the system clock can be adjusted at any time. In fact, this clock is not required to be related to wall clock time; e.g., it could be the time since the start of the operating system.
        </td>
        <td class="left bgcolor3">
         Unspecified
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          high_resolution_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Has the shortest possible tick period. Depending on your compiler, it is possible for this clock to be a synonym for
         <span class="forecolor1">
          steady_clock
         </span>
         or
         <code>
          system_clock
         </code>
         .
        </td>
        <td class="left bgcolor3">
         Unspecified
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          utc_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Represents the Coordinated Universal Time (UTC) wall clock time.
        </td>
        <td class="left bgcolor3">
         1970-01-01 00:00:00
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          tai_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Represents International Atomic Time (TAI), using a weighted average of several atomic clocks.
        </td>
        <td class="left bgcolor3">
         1958-01-01 00:00:00
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          gps_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Represents Global Position System (GPS) time, i.e., the time maintained by the atomic clocks of GPS satellites.
        </td>
        <td class="left bgcolor3">
         1980-01-06 00:00:00
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          file_clock
         </span>
        </td>
        <td class="left bgcolor3">
         Represents file time. It's an alias for
         <span class="forecolor1">
          std::filesystem::file_time_type
         </span>
         .
        </td>
        <td class="left bgcolor3">
         Unspecified, but typically 1970-01-01 on Unix, and 1601-01-01 on Windows.
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      The
      <code>
       utc_clock
      </code>
      is the only clock that tracks leap seconds, which are seconds that are occasionally added to or subtracted from UTC time to correct for any mismatch between UTC time and true solar time. The other clocks don't track leap seconds, while for
      <code>
       file_clock
      </code>
      it's unspecified.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c22-para-0056">
         <b>
          NOTE
         </b>
         <i>
          The use of the
         </i>
         <code>
          high_resolution_clock
         </code>
         <i>
          is discouraged because its implementation is not consistent between different compilers. For some compilers, it might be an alias for
         </i>
         <code>
          steady_clock
         </code>
         <i>
          , while for others it might be an alias for
         </i>
         <code>
          system_clock
         </code>
         <i>
          . Hence, for some compilers, the
         </i>
         <code>
          high_resolution_clock
         </code>
         <i>
          can go backwards, and for others it doesn't.
         </i>
        </p>
        <p id="c22-para-0057">
         <i>
          Instead, it's recommended to use
         </i>
         <code>
          system_clock
         </code>
         <i>
          to work with wall clock time and
         </i>
         <code>
          steady_clock
         </code>
         <i>
          to measure durations.
         </i>
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c22-para-0058">
      <span aria-label="870" epub:type="pagebreak" id="Page_870" role="doc-pagebreak">
      </span>
      Every
      <code>
       clock
      </code>
      has a static
      <code>
       now()
      </code>
      member function to get the current time as a
      <code>
       time_point
      </code>
      , and an
      <code>
       is_steady()
      </code>
      member function returning
      <code>
       true
      </code>
      if the clock is steady, i.e., never goes backwards,
      <code>
       false
      </code>
      otherwise.
     </p>
     <p id="c22-para-0059">
      The
      <code>
       system_clock
      </code>
      also defines two static helper member functions for converting
      <code>
       time_point
      </code>
      s to and from the
      <code>
       time_t
      </code>
      C-style time representation. The first one is called
      <code>
       to_time_t()
      </code>
      , and it converts a given
      <code>
       time_point
      </code>
      to a
      <code>
       time_t
      </code>
      ; the second one,
      <code>
       from_time_t()
      </code>
      , performs the opposite conversion. The
      <code>
       time_t
      </code>
      type is defined in
      <code>
       &lt;ctime&gt;
      </code>
      .
     </p>
     <section>
      <span id="c22-sec-0013">
      </span>
      <h3 id="head-3-465">
       Printing Current Time
      </h3>
      <p>
       The following example demonstrates how to get the current UTC time and print it to the console in a human-readable format:
      </p>
      <pre id="c22-code-0032"><code><span class="color3">// Set the global locale to the user's local (see <a href="c21.xhtml">Chapter 21</a>).</span></code>
<code>locale::global(locale { "" });</code>
<code><span class="color3">// Print the current UTC time.</span></code>
<code>println("UTC: {:L}", system_clock::now());</code>
<code>println("UTC: {:L%c}", system_clock::now());</code></pre>
      <p>
       This code snippet first sets the global
       <code>
        locale
       </code>
       to the user's
       <code>
        locale
       </code>
       ; see
       <a href="c21.xhtml">
        Chapter 21
       </a>
       , “String Localization and Regular Expressions.” This makes sure everything is printed according to the user's preferences. The
       <code>
        println()
       </code>
       statements use the
       <code>
        L
       </code>
       format specifier to format the date and time according to the configured global
       <code>
        locale
       </code>
       . The effect of the
       <code>
        %c
       </code>
       format specifier is also demonstrated. There are many more format specifiers supported. Consult a Standard Library reference to learn more about them. Here is sample output from the previous code snippet:
      </p>
      <pre id="c22-code-0033"><code>UTC: 2023-07-19 11:38:44,5521944</code>
<code>UTC: 2023-07-19 11:38:44</code></pre>
     </section>
     <section>
      <span id="c22-sec-0014">
      </span>
      <h3 id="head-3-466">
       Execution Timing
      </h3>
      <p>
       To time how long it takes for a piece of code to execute, you want to use a clock that is guaranteed not to go backwards. Hence, you should use a
       <code>
        steady_clock
       </code>
       . The following code snippet gives an example. The actual type of the variables
       <code>
        start
       </code>
       and
       <code>
        end
       </code>
       is
       <code>
        steady_clock::time_point
       </code>
       , and the actual type of
       <code>
        diff
       </code>
       is a
       <code>
        duration
       </code>
       .
      </p>
      <pre id="c22-code-0034"><code><span class="color3">// Get the start time.</span></code>
<code>auto start { steady_clock::now() };</code>
<code><span class="color3">// Execute code that you want to time.</span></code>
<code>const int numberOfIterations { 10'000'000 };</code>
<code>double d { 0 };</code>
<code>for (int i { 0 }; i &lt; numberOfIterations; ++i) { d += sqrt(abs(sin(i) * cos(i))); }</code>
<code><span class="color3">// Get the end time and calculate the difference.</span></code>
<code>auto end { steady_clock::now() };</code>
<code>auto diff { end - start };</code>
<code><span class="color3">// Use the calculated result, otherwise the compiler might</span></code>
<code><span class="color3">// optimize away the entire loop!</span></code>
<code>println("d = {}", d);</code>
<span aria-label="871" epub:type="pagebreak" id="Page_871" role="doc-pagebreak"></span><code><span class="color3">// Convert the difference into milliseconds and output to the console.</span></code>
<code>println("Total: {}", duration&lt;double, milli&gt; { diff });</code>
<code><span class="color3">// Use duration_cast() if you don't need fractional milliseconds.</span></code>
<code>println("Total: {}", duration_cast&lt;milliseconds&gt;(diff));</code>
<code><span class="color3">// Print the time per iteration in nanoseconds.</span></code>
<code>println("{} per iteration", duration&lt;double, nano&gt; { diff / numberOfIterations });</code></pre>
      <p>
       Here is the output running on my test system:
      </p>
      <pre id="c22-code-0035"><code>d = 5393526.082683575</code>
<code>Total: 78.7931ms</code>
<code>Total: 78ms</code>
<code>7ns per iteration</code></pre>
      <p id="c22-para-0064">
       The loop in this example is performing some arithmetic operations with
       <code>
        sqrt()
       </code>
       ,
       <code>
        abs()
       </code>
       ,
       <code>
        sin()
       </code>
       , and
       <code>
        cos()
       </code>
       to make sure the loop doesn't end too fast. If you get really small values for the difference in milliseconds on your system, those values will not be accurate, and you should increase the number of iterations of the loop to make it last longer. Small timings will not be accurate because while timers often have a resolution in milliseconds, on most operating systems, this timer is updated infrequently, for example, every 10 ms or 15 ms. This induces a phenomenon called
       <i>
        gating error
       </i>
       , where any event that occurs in less than one timer tick appears to take place in zero units of time, and any event between one and two timer ticks appears to take place in one timer unit. For example, on a system with a 15 ms timer update, a loop that takes 44 ms will appear to take only 30 ms. When using such timers to time computations, it is important to make sure that the entire computation takes place across a fairly large number of basic timer tick units so that these errors are minimized.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-230">
     <span id="c22-sec-0015">
     </span>
     <h2 id="head-2-230">
      TIME POINT
     </h2>
     <p id="c22-para-0065">
      A point in time is represented by the
      <code>
       time_point
      </code>
      class and stored as a
      <code>
       duration
      </code>
      relative to an
      <i>
       epoch
      </i>
      , representing the beginning of time. A
      <code>
       time_point
      </code>
      is always associated with a certain
      <code>
       clock
      </code>
      , and the epoch is the origin of this associated
      <code>
       clock
      </code>
      . For example, the epoch for the classic Unix/Linux time is January 1, 1970, and durations are measured in seconds. The epoch for Windows is January 1, 1601, and durations are measured in 100-nanosecond units. Other operating systems have different epoch dates and duration units.
     </p>
     <p id="c22-para-0066">
      The
      <code>
       time_point
      </code>
      class has a function called
      <code>
       time_since:epoch()
      </code>
      , which returns a
      <code>
       duration
      </code>
      representing the time between the epoch of the associated
      <code>
       clock
      </code>
      and the stored point in time.
     </p>
     <p>
      Arithmetic operations of
      <code>
       time_point
      </code>
      s and
      <code>
       duration
      </code>
      s that make sense are supported. The following table lists those operations.
      <code>
       tp
      </code>
      is a
      <code>
       time_point
      </code>
      , and
      <code>
       d
      </code>
      is a
      <code>
       duration
      </code>
      :
     </p>
     <table border="1">
      <tbody>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          tp + d = tp
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          tp – d = tp
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          d + tp = tp
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          tp – tp = d
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          tp += d
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          tp -= d
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <p id="c22-para-0069">
      An example of an operation that is not supported is
      <code>
       tp+tp
      </code>
      .
     </p>
     <p id="c22-para-0070">
      <span aria-label="872" epub:type="pagebreak" id="Page_872" role="doc-pagebreak">
      </span>
      Comparison operators
      <code>
       ==
      </code>
      and
      <code>
       &lt;=&gt;
      </code>
      to compare two time points are supported. Two static member functions are provided:
      <code>
       min()
      </code>
      and
      <code>
       max()
      </code>
      returning the smallest and largest possible point in time, respectively.
     </p>
     <p>
      The
      <code>
       time_point
      </code>
      class has three constructors:
     </p>
     <ul class="check1" id="c22-list-0004">
      <li id="c22-li-0012">
       <b>
        <code>
         time_point():
        </code>
       </b>
       Constructs a
       <code>
        time_point
       </code>
       initialized with
       <code>
        duration::zero()
       </code>
       . The resulting
       <code>
        time_point
       </code>
       represents the epoch of the associated
       <code>
        clock
       </code>
       .
      </li>
      <li id="c22-li-0013">
       <code>
        time_point(const duration&amp; d):
       </code>
       Constructs a
       <code>
        time_point
       </code>
       initialized with the given
       <code>
        duration
       </code>
       . The resulting
       <code>
        time_point
       </code>
       represents
       <code>
        epoch + d
       </code>
       .
      </li>
      <li id="c22-li-0014">
       <code>
        template&lt;class Duration2&gt; time_point(const time_point&lt;clock, Duration2&gt;&amp; t):
       </code>
       Constructs a
       <code>
        time_point
       </code>
       initialized with
       <code>
        t.time_since:epoch()
       </code>
       .
      </li>
     </ul>
     <p>
      Each
      <code>
       time_point
      </code>
      is associated with a
      <code>
       clock
      </code>
      . To create a
      <code>
       time_point
      </code>
      , you specify the
      <code>
       clock
      </code>
      as the template parameter:
     </p>
     <pre id="c22-code-0036"><code>time_point&lt;steady_clock&gt; tp1;</code></pre>
     <p>
      Each
      <code>
       clock
      </code>
      also knows its
      <code>
       time_point
      </code>
      type, so you can also write it as follows:
     </p>
     <pre id="c22-code-0037"><code>steady_clock::time_point tp1;</code></pre>
     <p>
      The following code snippet demonstrates some operations with
      <code>
       time_point
      </code>
      s:
     </p>
     <pre id="c22-code-0038"><code><span class="color3">// Create a time_point representing the epoch of the associated steady clock.</span></code>
<code>time_point&lt;steady_clock&gt; tp1;</code>
<code><span class="color3">// Add 10 minutes to the time_point.</span></code>
<code>tp1 += minutes { 10 };</code>
<code><span class="color3">// Store the duration between epoch and time_point.</span></code>
<code>auto d1 { tp1.time_since:epoch() };</code>
<code><span class="color3">// Convert the duration to seconds and output to the console.</span></code>
<code>duration&lt;double&gt; d2 { d1 };</code>
<code>println("{}", d2);</code></pre>
     <p>
      The output is as follows:
     </p>
     <pre id="c22-code-0039"><code>600s</code></pre>
     <p>
      Converting
      <code>
       time_point
      </code>
      s can be done implicitly or explicitly, similar to
      <code>
       duration
      </code>
      conversions. Here is an example of an implicit conversion. The output is
      <code>
       42000ms
      </code>
      :
     </p>
     <pre id="c22-code-0040"><code>time_point&lt;steady_clock, seconds&gt; tpSeconds { 42s };</code>
<code><span class="color3">// Convert seconds to milliseconds implicitly.</span></code>
<code>time_point&lt;steady_clock, milliseconds&gt; tpMilliseconds { tpSeconds };</code>
<code>println("{}", tpMilliseconds.time_since:epoch());</code></pre>
     <p>
      If the implicit conversion can result in a loss of data, then you need an explicit conversion using
      <code>
       time_point_cast()
      </code>
      , similar to using
      <code>
       duration_cast()
      </code>
      for explicit
      <code>
       duration
      </code>
      casts as discussed earlier in this chapter. The following example outputs
      <code>
       42000ms
      </code>
      , even though you start from 42,424ms:
     </p>
     <pre id="c22-code-0041"><code>time_point&lt;steady_clock, milliseconds&gt; tpMilliseconds { 42'424ms };</code>
<code><span class="color3">// Convert milliseconds to seconds explicitly.</span></code>
<code>time_point&lt;steady_clock, seconds&gt; tpSeconds {</code>
<code>    time_point_cast&lt;seconds&gt;(tpMilliseconds) };</code>
<code><span class="color3">// Or:</span></code>
<code><span class="color3">// auto tpSeconds { time_point_cast&lt;seconds&gt;(tpMilliseconds) };</span></code>
<code></code>
<span aria-label="873" epub:type="pagebreak" id="Page_873" role="doc-pagebreak"></span><code><span class="color3">// Convert seconds back to milliseconds and output the result.</span></code>
<code>milliseconds ms { tpSeconds.time_since:epoch() };</code>
<code>println("{}", ms);</code></pre>
     <p id="c22-para-0078">
      The library supports
      <code>
       floor()
      </code>
      ,
      <code>
       ceil()
      </code>
      , and
      <code>
       round()
      </code>
      operations for
      <code>
       time_point
      </code>
      s that behave just as they behave with numerical data.
     </p>
    </section>
    <section aria-labelledby="head-2-231">
     <span id="c22-sec-0016">
     </span>
     <h2 id="head-2-231">
      DATE
     </h2>
     <p id="c22-para-0079">
      The Standard Library supports working with calendar dates. At this moment, only the Gregorian calendar is supported, but if need be, you can always implement your own calendars that can interoperate with the rest of the
      <code>
       &lt;chrono&gt;
      </code>
      functionality, such as Coptic and Julian calendars.
     </p>
     <p id="c22-para-0080">
      The Standard Library provides quite a few classes and functions to work with dates (and time zones discussed in a later section). This text discusses the most important classes and functions. Consult a Standard Library reference (see
      <a href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography”) to get a complete overview of everything that's available.
     </p>
     <section>
      <span id="c22-sec-0017">
      </span>
      <h3 id="head-3-467">
       Creating Dates
      </h3>
      <p id="c22-para-0081">
       The following calendrical classes are available to create dates, all defined in
       <code>
        std::chrono
       </code>
       :
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          CLASS
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           year
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a year in the range [-32767, 32767]. A
          <span>
           year
          </span>
          has a member function called
          <code>
           is_leap()
          </code>
          returning
          <code>
           true
          </code>
          if a given
          <span>
           year
          </span>
          is a leap year,
          <code>
           false
          </code>
          otherwise.
          <code>
           min()
          </code>
          and
          <code>
           max()
          </code>
          static member functions return the minimum and maximum year, respectively.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           month
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a month in the range [1, 12]. Additionally, there are 12 named constants provided for the 12 months, for example:
          <span class="forecolor1">
           std::chrono::January
          </span>
          .
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           day
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a day in the range [1, 31].
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           weekday
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a day of the week in the range [0, 6], where 0 means Sunday. Additionally, there are seven named constants provided for the seven weekdays, for example:
          <span class="forecolor1">
           std::chrono::Sunday
          </span>
          .
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           weekday_indexed
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the first, second, third, fourth, or fifth weekday of a month. Can easily be constructed from a
          <span class="forecolor1">
           weekday
          </span>
          , for example:
          <code>
           Monday[2]
          </code>
          is the second Monday of a month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           weekday_last
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the last weekday of some month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           month_day
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a specific month and day.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           month_day_last
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the last day of a specific month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           month_weekday
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the
          <i>
           n
          </i>
          <sup>
           th
          </sup>
          weekday of a specific month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           month_weekday_last
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the last weekday of a specific month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           year_month
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a specific year and month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           year_month_day
          </span>
         </td>
         <td class="left bgcolor3">
          Represents a specific year, month, and day.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           year_month_day_last
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the last day of a specific year and month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           year_month_weekday
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the
          <i>
           n
          </i>
          <sup>
           th
          </sup>
          weekday of a specific year and month.
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           year_month_weekday_last
          </span>
         </td>
         <td class="left bgcolor3">
          Represents the last weekday of a specific year and month.
          <span aria-label="874" epub:type="pagebreak" id="Page_874" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       All of these classes have a member function called
       <code>
        ok()
       </code>
       that returns
       <code>
        true
       </code>
       if the given object is in a valid range,
       <code>
        false
       </code>
       otherwise. Two additional standard literals are provided in
       <code>
        std::literals::chrono_literals
       </code>
       :
       <code>
        y
       </code>
       to create years, and
       <code>
        d
       </code>
       to create days. Complete dates can be constructed using
       <code>
        operator/
       </code>
       to specify year, month, and day, in three orders: Y/M/D, M/D/Y, D/M/Y. Here are some examples to create dates:
      </p>
      <pre id="c22-code-0042"><code>year y1 { 2020 };</code>
<code>auto y2 { 2020y };</code>
<code></code>
<code>month m1 { 6 };</code>
<code>auto m2 { June };</code>
<code></code>
<code>day d1 { 22 };</code>
<code>auto d2 { 22d };</code>
<code></code>
<code><span class="color3">// Create a date for 2020-06-22.</span></code>
<code>year_month_day fulldate1 { 2020y, June, 22d };</code>
<code>auto fulldate2 { 2020y / June / 22d };</code>
<code>auto fulldate3 { 22d / June / 2020y };</code>
<code></code>
<code><span class="color3">// Create a date for the 3rd Monday of June 2020.</span></code>
<code>year_month_day fulldate4 { Monday[3] / June / 2020 };</code>
<code></code>
<code><span class="color3">// Create a month_day for June 22 of an unspecified year.</span></code>
<code>auto june22 { June / 22d };</code>
<code><span class="color3">// Create a year_month_day for June 22, 2020.</span></code>
<code>auto june22_2020 { 2020y / june22 };</code>
<code></code>
<code><span class="color3">// Create a month_day_last for the last day of a June of an unspecified year.</span></code>
<code>auto lastDayOfAJune { June / last };</code>
<code><span class="color3">// Create a year_month_day_last for the last day of June for the year 2020.</span></code>
<code>auto lastDayOfJune2020 { 2020y / lastDayOfAJune };</code>
<code></code>
<code><span class="color3">// Create a year_month_weekday_last for the last Monday of June 2020.</span></code>
<code>auto lastMondayOfJune2020 { 2020y / June / Monday[last] };</code></pre>
      <p>
       <code>
        sys_time
       </code>
       is a type alias for a
       <code>
        time_point
       </code>
       of a
       <code>
        system_clock
       </code>
       with a certain duration. It's defined as follows:
      </p>
      <pre id="c22-code-0043"><code>template &lt;typename Duration&gt;</code>
<code>using sys_time = std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt;;</code></pre>
      <p>
       <span aria-label="875" epub:type="pagebreak" id="Page_875" role="doc-pagebreak">
       </span>
       Based on the
       <code>
        sys_time
       </code>
       type alias, two additional type aliases are defined to represent a
       <code>
        sys_time
       </code>
       with a precision of seconds, and one with a precision of days:
      </p>
      <pre id="c22-code-0044"><code>using sys_seconds = sys_time&lt;std::chrono::seconds&gt;;</code>
<code>using sys_days = sys_time&lt;std::chrono::days&gt;;</code></pre>
      <p id="c22-para-0087">
       <code>
        sys_days
       </code>
       , for example, represents the number of days since the
       <code>
        system_clock
       </code>
       epoch, and hence, it's a
       <i>
        serial-based type
       </i>
       ; that is, it just contains a single number (days since epoch). On the other hand,
       <code>
        year_month_day
       </code>
       , for example, is a
       <i>
        field-based type
       </i>
       , it stores a year, a month, and a day in separate fields. When doing a lot of arithmetic with dates, a serial-based type will be more performant than a field-based type.
      </p>
      <p id="c22-para-0088">
       Similar type aliases exist to work with local time:
       <code>
        local_time
       </code>
       ,
       <code>
        local_seconds
       </code>
       , and
       <code>
        local_days
       </code>
       . These are demonstrated in a later section on time zones.
      </p>
      <p>
       You can create a
       <code>
        sys_days
       </code>
       representing today as follows.
       <code>
        floor()
       </code>
       is used to truncate a
       <code>
        time_point
       </code>
       to a precision of days:
      </p>
      <pre id="c22-code-0045"><code>auto today { floor&lt;days&gt;(system_clock::now()) };</code></pre>
      <p>
       <code>
        sys_days
       </code>
       can be used to convert a
       <code>
        year_month_day
       </code>
       to a
       <code>
        time_point
       </code>
       , for example:
      </p>
      <pre id="c22-code-0046"><code>system_clock::time_point t1 { sys_days { 2020y / June / 22d } };</code></pre>
      <p>
       The opposite conversion, converting a
       <code>
        time_point
       </code>
       to a
       <code>
        year_month_day
       </code>
       , can be done with a
       <code>
        year_month_day
       </code>
       constructor. The following code snippet gives two examples:
      </p>
      <pre id="c22-code-0047"><code>year_month_day yearmonthday { floor&lt;days&gt;(t1) };</code>
<code>year_month_day today2 { floor&lt;days&gt;(system_clock::now()) };</code></pre>
      <p>
       A complete date including a time can be build up as well. Here's an example:
      </p>
      <pre id="c22-code-0048"><code><span class="color3">// Full date with time: 2020-06-22 09:35:10 UTC.</span></code>
<code>auto t2 { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code></pre>
     </section>
     <section>
      <span id="c22-sec-0018">
      </span>
      <h3 id="head-3-468">
       Printing Dates
      </h3>
      <p>
       Dates can be written to streams using the familiar insertion operator:
      </p>
      <pre id="c22-code-0049"><code>cout &lt;&lt; yearmonthday &lt;&lt; endl;</code></pre>
      <p>
       Printing and formatting dates are also supported. The
       <code>
        L
       </code>
       format specifier formats the output according to the current global
       <code>
        locale
       </code>
       .
      </p>
      <pre id="c22-code-0050"><code>println("{:L}", yearmonthday);</code></pre>
      <p>
       Keep in mind that the output might sometimes be unexpected. For example,
       <code>
        lastMondayOfJune2020
       </code>
       is defined earlier as follows:
      </p>
      <pre id="c22-code-0051"><code><span class="color3">// Create a year_month_weekday_last for the last Monday of June 2020.</span></code>
<code>auto lastMondayOfJune2020 { 2020y / June / Monday[last] };</code></pre>
      <p>
       When you print this, the output is “2020/Jun/Mon[last]”:
      </p>
      <pre id="c22-code-0052"><code>println("{:L}", lastMondayOfJune2020);     <span class="color3">// 2020/Jun/Mon[last]</span></code></pre>
      <p>
       <span aria-label="876" epub:type="pagebreak" id="Page_876" role="doc-pagebreak">
       </span>
       If you want to output the exact date, “2020-06-29,” then you need to convert the
       <code>
        year_month_weekday_last
       </code>
       to a
       <code>
        year_month_day
       </code>
       and then output the result:
      </p>
      <pre id="c22-code-0053"><code>year_month_day lastMondayOfJune2020YMD { sys_days { lastMondayOfJune2020 } };</code>
<code>println("{:L}", lastMondayOfJune2020YMD);  <span class="color3">// 2020-06-29</span></code></pre>
      <p id="c22-para-0098">
       If a date is invalid, printing will insert an error. For example, the string “is not a valid date” is appended to an invalid
       <code>
        year_month_day
       </code>
       .
      </p>
      <p>
       Using the
       <code>
        L
       </code>
       format specifier, names of days and months are correctly localized according to the current global
       <code>
        locale
       </code>
       . For example, the following code snippet first sets the global locale to Dutch, nl-NL, and then uses the
       <code>
        L
       </code>
       format specifier to print
       <code>
        Monday
       </code>
       in Dutch. The
       <code>
        %A
       </code>
       format specifier causes the full name to be printed instead of the abbreviated name. Consult your favorite Standard Library reference for a full list of all supported date format specifiers.
      </p>
      <pre id="c22-code-0054"><code>locale::global(locale { "nl-NL" });</code>
<code>println("Monday in Dutch is {:L%A}", Monday);</code></pre>
      <p>
       The output is:
      </p>
      <pre id="c22-code-0055"><code>Monday in Dutch is maandag</code></pre>
     </section>
     <section>
      <span id="c22-sec-0019">
      </span>
      <h3 id="head-3-469">
       Arithmetic with Dates
      </h3>
      <p>
       You can perform arithmetic with dates. Here's an example:
      </p>
      <pre id="c22-code-0056"><code><span class="color3">// Full date with time: 2020-06-22 09:35:10 UTC.</span></code>
<code>auto t2 { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code>
<code>auto t3 { t2 + days { 5 } };    <span class="color3">// Add 5 days to t2.</span></code>
<code>auto t4 { t3 + years { 1 } };   <span class="color3">// Add 1 year to t3.</span></code></pre>
      <p>
       Be careful, though, as the result might not always be as expected. For example:
      </p>
      <pre id="c22-code-0057"><code>auto t5 { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code>
<code>auto t6 { t5 + years { 1 } };   <span class="color3">// Add 1 year to t5</span></code>
<code>println("t5 = {:L}", t5);</code>
<code>println("t6 = {:L}", t6);</code></pre>
      <p>
       The result is as follows:
      </p>
      <pre id="c22-code-0058"><code>t5 = 2020-06-22 09:35:10</code>
<code>t6 = 2021-06-22 <b>15:24:22</b></code></pre>
      <p id="c22-para-0104">
       In looking at the results, you can see that the year is updated, but you can also see that the time has changed. The issue here is that we are working with a serial type:
       <code>
        sys_days
       </code>
       is a
       <code>
        time_point
       </code>
       , which is a serial type. Adding 1 year to such a serial type does not add 86,400 * 365 = 31,536,000 seconds. Instead, the standard mandates that adding 1 year must add 1
       <b>
        average year
       </b>
       to keep leap years into account, and hence, it must add 86,400 * ((365 * 400) + 97) / 400 = 31,556,952 seconds.
      </p>
      <p>
       If you need to add exactly 1 year, then it's best to use a field-based type instead, for example:
      </p>
      <pre id="c22-code-0059"><code><span class="color3">// Split t5 into days and remaining seconds.</span></code>
<code>sys_days t5_days { time_point_cast&lt;days&gt;(t5) };</code>
<code>seconds t5_seconds { t5 - t5_days };</code>
<code><span class="color3">// Convert the t5_days serial type to field-based type.</span></code>
<code>year_month_day t5_ymd { t5_days };</code>
<span aria-label="877" epub:type="pagebreak" id="Page_877" role="doc-pagebreak"></span><code><span class="color3">// Add 1 year.</span></code>
<code>year_month_day t7_ymd { t5_ymd + years { 1 } };</code>
<code><span class="color3">// Convert back to a serial type.</span></code>
<code>auto t7 { sys_days { t7_ymd } + t5_seconds };</code>
<code>println("t7 = {:L}", t7);</code></pre>
      <p>
       This results in:
      </p>
      <pre id="c22-code-0060"><code>t7 = 2021-06-22 <b>09:35:10</b></code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-232">
     <span id="c22-sec-0020">
     </span>
     <h2 id="head-2-232">
      TIME ZONE
     </h2>
     <p id="c22-para-0107">
      To facilitate working with time zones, the C++ Standard Library contains a copy of the Internet Assigned Numbers Authority (IANA) time zone database (
      <code>
       <a href="http://www.iana.org/time-zones">
        www.iana.org/time-zones
       </a>
      </code>
      ). You can get access to this database by calling
      <code>
       std::chrono::get_tzdb()
      </code>
      , which returns a reference-to-
      <code>
       const
      </code>
      to a single existing instance of type
      <code>
       std::chrono::tzdb
      </code>
      . This database gives access to all known time zones through a public
      <code>
       vector
      </code>
      called
      <code>
       zones
      </code>
      . Each entry in this
      <code>
       vector
      </code>
      is a
      <code>
       time_zone
      </code>
      , which has a name, accessible with
      <code>
       name()
      </code>
      , and member functions
      <code>
       to_sys()
      </code>
      and
      <code>
       to_local()
      </code>
      to convert a
      <code>
       local_time
      </code>
      to a
      <code>
       sys_time
      </code>
      , and vice versa. Due to daylight saving time, it could be that a conversion from
      <code>
       local_time
      </code>
      to
      <code>
       sys_time
      </code>
      is either ambiguous or nonexistent. In such cases, the conversion throws an exception of type
      <code>
       ambiguous_local_time
      </code>
      or
      <code>
       nonexistent_local_time
      </code>
      , respectively.
     </p>
     <p>
      Here is a code snippet listing all available time zones:
     </p>
     <pre id="c22-code-0061"><code>const auto&amp; database { get_tzdb() };</code>
<code>for (const auto&amp; timezone : database.zones) {</code>
<code>    println("{}", timezone.name());</code>
<code>}</code></pre>
     <p>
      The
      <code>
       std::chrono::locate_zone()
      </code>
      function can be used to retrieve a
      <code>
       time_zone
      </code>
      based on its name and throws a
      <code>
       runtime_error
      </code>
      exception if the requested time zone cannot be found in the database. The
      <code>
       current_zone()
      </code>
      function can be used to get the current time zone. For example:
     </p>
     <pre id="c22-code-0062"><code>auto* brussels { locate_zone("Europe/Brussels") };</code>
<code>auto* gmt { locate_zone("GMT") };</code>
<code>auto* current { current_zone() };</code></pre>
     <p>
      <code>
       time_zone
      </code>
      instances can be used to convert times between different zones:
     </p>
     <pre id="c22-code-0063"><code><span class="color3">// Convert current time (UTC), to time in Brussels, and time in current zone.</span></code>
<code>auto nowUTC { system_clock::now() };                 <span class="color3">// In UTC.</span></code>
<code>auto nowInBrussels { brussels-&gt;to_local(nowUTC) };   <span class="color3">// In Brussels' time zone.</span></code>
<code>auto nowInCurrentZone { current-&gt;to_local(nowUTC) }; <span class="color3">// In current time zone.</span></code>
<code>println("Now UTC:        {:L%c}", nowUTC);</code>
<code>println("Now Brussels:   {:L%c}", nowInBrussels);</code>
<code>println("Now in current: {:L%c}", nowInCurrentZone);</code>
<code></code>
<code><span class="color3">// Construct a UTC time. (2020-06-22 09:35:10 UTC)</span></code>
<code>auto t { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code>
<code><span class="color3">// Convert UTC time to Brussels' local time.</span></code>
<code>auto converted { brussels-&gt;to_local(t) };</code>
<code>println("Converted: {:L}", converted);</code></pre>
     <p>
      The
      <code>
       zoned_time
      </code>
      class is used to represent a
      <code>
       time_point
      </code>
      in a specific
      <code>
       time_zone
      </code>
      . The following snippet constructs a specific time in the Brussels' time zone and then converts it to New York time:
     </p>
     <pre id="c22-code-0064"><span aria-label="878" epub:type="pagebreak" id="Page_878" role="doc-pagebreak"></span><code><span class="color3">// Construct a local time in the Brussels' time zone.</span></code>
<code>zoned_time&lt;hours&gt; brusselsTime{ brussels, local_days { 2020y / June / 22d } + 9h };</code>
<code><span class="color3">// Convert to New York time.</span></code>
<code>zoned_time&lt;hours&gt; newYorkTime { "America/New_York", brusselsTime };</code>
<code>println("Brussels: {:L}", brusselsTime.get_local_time());</code>
<code>println("New York: {:L}", newYorkTime.get_local_time());</code></pre>
    </section>
    <section aria-labelledby="head-2-233">
     <span id="c22-sec-0021">
     </span>
     <h2 id="head-2-233">
      SUMMARY
     </h2>
     <p id="c22-para-0112">
      This chapter discussed how to use the
      <code>
       ratio
      </code>
      class template to define and work with compile-time rational numbers. You also learned how to work with durations, clocks, time points, dates, and time zones provided by the C++ Standard Library through the chrono library.
     </p>
     <p id="c22-para-0113">
      The next chapter focusses on the functionality provided by the Standard Library to generate random numbers.
     </p>
    </section>
    <section aria-labelledby="head-2-234">
     <span id="c22-sec-0022">
     </span>
     <h2 id="head-2-234">
      EXERCISES
     </h2>
     <p id="c22-para-0114">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c22-exsec-0001">
      </span>
      <ol class="none">
       <li id="c22-ex-0001">
        <b>
         Exercise 22-1:
        </b>
        Let's play a bit with durations. Create a duration,
        <code>
         d1
        </code>
        , with a precision of seconds, initialized to 42 seconds. Create a second duration,
        <code>
         d2
        </code>
        , with a precision of minutes, initialized to 1.5 minutes. Calculate the sum of
        <code>
         d1
        </code>
        and
        <code>
         d2
        </code>
        . Write out the result to the standard output, once expressed in seconds, once expressed in minutes.
       </li>
       <li id="c22-ex-0002">
        <b>
         Exercise 22-2:
        </b>
        Ask the user to enter a date as yyyy-mm-dd, for example, 2020-06-22. Use a regular expression (see
        <a href="c21.xhtml">
         Chapter 21
        </a>
        ) to extract the year, month, and day components, and finally, use
        <code>
         year_month_day
        </code>
        to validate the date.
       </li>
       <li id="c22-ex-0003">
        <b>
         Exercise 22-3:
        </b>
        Write a
        <code>
         getNumberOfDaysBetweenDates()
        </code>
        function that calculates the number of days between two given dates. Test your implementation in your
        <code>
         main()
        </code>
        function.
       </li>
       <li id="c22-ex-0004">
        <b>
         Exercise 22-4:
        </b>
        Write a program that prints out the day of the week of June 22, 2020.
       </li>
       <li id="c22-ex-0005">
        <b>
         Exercise 22-5:
        </b>
        Construct a UTC time. Convert this time to the local time in Tokyo, Japan. Further convert the resulting time to New York time. And finally convert the resulting time to GMT. Verify that the original UTC time and the final GMT time are equal. Tip: The time zone identifier for Tokyo is Asia/Tokyo, for New York it is America/New_York, and for GMT it is GMT.
       </li>
       <li id="c22-ex-0006">
        <b>
         Exercise 22-6:
        </b>
        Write a
        <code>
         getDurationSinceMidnight()
        </code>
        function that returns the duration between midnight and the current local time in seconds. Use your function to print out the number of seconds since midnight to the standard output console. Finally, use the
        <code>
         hh_mm_ss
        </code>
        class to convert the duration returned by your function to hours, minutes, and seconds, and print the result on standard output.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
