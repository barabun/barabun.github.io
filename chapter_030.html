<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   18Standard Library Containers
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_029.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_031.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c18_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c18_1">
      <span aria-label="683" class="calibre17" epub:type="pagebreak" id="Page_683" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c18">
      </span>
      <span class="calibre">
       18
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Standard Library Containers
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c18-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c18-list-0001">
         <li class="calibre9" id="c18-li-0001">
          Containers overview: requirements on elements and general error handling
         </li>
         <li class="calibre9" id="c18-li-0002">
          Sequential containers:
          <code class="calibre21">
           vector
          </code>
          ,
          <code class="calibre21">
           deque
          </code>
          ,
          <code class="calibre21">
           list
          </code>
          ,
          <code class="calibre21">
           forward_list
          </code>
          , and
          <code class="calibre21">
           array
          </code>
         </li>
         <li class="calibre9" id="c18-li-0003">
          Sequential views: span and mdspan
         </li>
         <li class="calibre9" id="c18-li-0004">
          Container adapters:
          <code class="calibre21">
           queue
          </code>
          ,
          <code class="calibre21">
           priority_queue
          </code>
          , and
          <code class="calibre21">
           stack
          </code>
         </li>
         <li class="calibre9" id="c18-li-0005">
          The
          <code class="calibre21">
           pair
          </code>
          utility class template
         </li>
         <li class="calibre9" id="c18-li-0006">
          Associative containers:
          <code class="calibre21">
           map
          </code>
          ,
          <code class="calibre21">
           multimap
          </code>
          ,
          <code class="calibre21">
           set
          </code>
          , and
          <code class="calibre21">
           multiset
          </code>
         </li>
         <li class="calibre9" id="c18-li-0007">
          Unordered associative containers or hash tables:
          <code class="calibre21">
           unordered_map
          </code>
          ,
          <code class="calibre21">
           unordered_multimap
          </code>
          ,
          <code class="calibre21">
           unordered_set
          </code>
          , and
          <code class="calibre21">
           unordered_multiset
          </code>
         </li>
         <li class="calibre9" id="c18-li-0008">
          Flat associative container adapters:
          <code class="calibre21">
           flat_map
          </code>
          ,
          <code class="calibre21">
           flat_multimap
          </code>
          ,
          <code class="calibre21">
           flat_set
          </code>
          , and
          <code class="calibre21">
           flat_multiset
          </code>
         </li>
         <li class="calibre9" id="c18-li-0009">
          Other containers: standard C-style arrays,
          <code class="calibre21">
           string
          </code>
          s, streams, and
          <code class="calibre21">
           bitset
          </code>
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c18-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-197">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c18-sec-0003">
        </span>
        <p class="calibre25" id="c18-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <code class="calibre21">
           <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c18-para-0005">
      This chapter of the Standard Library deep-dive chapters covers the available containers. It explains the different containers, their categories, and what the trade-offs are between them.
      <span aria-label="684" class="calibre20" epub:type="pagebreak" id="Page_684" role="doc-pagebreak">
      </span>
      Some containers are discussed in much more detail compared to others. Once you know how to work with a container of each category, you will have no problems using any of the other containers from the same category. Consult your favorite Standard Library Reference for a complete reference of all member functions of all containers.
     </p>
    </section>
    <section aria-labelledby="head-2-198" class="calibre2">
     <span class="calibre" id="c18-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-198">
      CONTAINERS OVERVIEW
     </h2>
     <p class="calibre13" id="c18-para-0006">
      Containers in the Standard Library are generic data structures that are useful for storing collections of data. You should rarely need to use a standard C-style array, write a linked list, or design a stack when you use the Standard Library. The containers are implemented as class templates, so you can instantiate them for any type that meets certain basic conditions outlined in the next section. Most of the Standard Library containers, except for
      <code class="calibre21">
       array
      </code>
      and
      <code class="calibre21">
       bitset
      </code>
      , are flexible in size and automatically grow or shrink to accommodate more or fewer elements. This is a huge benefit compared to the old, C-style arrays, which had a fixed size. Because of the fixed-size nature of C-style arrays, they are more vulnerable to overruns, which in the simplest cases merely cause the program to crash because data has been corrupted, but in the worst cases allow certain kinds of security attacks. By using Standard Library containers, you ensure that your programs will be less vulnerable to these kinds of problems.
     </p>
     <p class="calibre13" id="c18-para-0007">
      <a class="calibre5" href="c16.xhtml">
       Chapter 16
      </a>
      , “Overview of the C++ Standard Library,” gives a high-level overview of the different containers, container adapters, and sequential views provided by the Standard Library. The following table summarizes them.
     </p>
     <table border="1" class="calibre31">
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="left1">
         <ul class="check5" id="c18-list-0002">
          <li class="calibre9" id="c18-li-0010">
           <b class="calibre14">
            Sequential containers
           </b>
           <ul class="check6">
            <li class="calibre9" id="c18-li-0011">
             <code class="calibre21">
              vector
             </code>
             (dynamic array)
            </li>
            <li class="calibre9" id="c18-li-0012">
             <code class="calibre21">
              deque
             </code>
            </li>
            <li class="calibre9" id="c18-li-0013">
             <code class="calibre21">
              list
             </code>
            </li>
            <li class="calibre9" id="c18-li-0014">
             <code class="calibre21">
              forward_list
             </code>
            </li>
            <li class="calibre9" id="c18-li-0015">
             <code class="calibre21">
              array
             </code>
            </li>
           </ul>
          </li>
          <li class="calibre9" id="c18-li-0016">
           <b class="calibre14">
            Sequential views
           </b>
           <ul class="check6">
            <li class="calibre9" id="c18-li-0017">
             <code class="calibre21">
              span
             </code>
            </li>
            <li class="calibre9" id="c18-li-0018">
             <code class="calibre21">
              mdspan
             </code>
            </li>
           </ul>
          </li>
          <li class="calibre9" id="c18-li-0019">
           <b class="calibre14">
            Container adapters
           </b>
           <ul class="check6">
            <li class="calibre9" id="c18-li-0020">
             <code class="calibre21">
              queue
             </code>
            </li>
            <li class="calibre9" id="c18-li-0021">
             <code class="calibre21">
              priority_queue
             </code>
            </li>
            <li class="calibre9" id="c18-li-0022">
             <code class="calibre21">
              stack
             </code>
            </li>
           </ul>
          </li>
         </ul>
        </td>
        <td class="left1">
         <ul class="check5" id="c18-list-0003">
          <li class="calibre9" id="c18-li-0023">
           <b class="calibre14">
            Ordered associative containers
           </b>
           <ul class="check6">
            <li class="calibre9" id="c18-li-0024">
             <code class="calibre21">
              map / multimap
             </code>
            </li>
            <li class="calibre9" id="c18-li-0025">
             <code class="calibre21">
              set / multiset
             </code>
            </li>
           </ul>
          </li>
          <li class="calibre9" id="c18-li-0026">
           <b class="calibre14">
            Unordered associative containers or hash tables
           </b>
           <ul class="check6">
            <li class="calibre9" id="c18-li-0027">
             <code class="calibre21">
              unordered_map / unordered_multimap
             </code>
            </li>
            <li class="calibre9" id="c18-li-0028">
             <code class="calibre21">
              unordered_set / unordered_multiset
             </code>
            </li>
           </ul>
          </li>
          <li class="calibre9" id="c18-li-0029">
           <b class="calibre14">
            Flat set and flat map associative container adapters
           </b>
           <ul class="check6">
            <li class="calibre9" id="c18-li-0030">
             <code class="calibre21">
              flat_map / flat_multimap
             </code>
            </li>
            <li class="calibre9" id="c18-li-0031">
             <code class="calibre21">
              flat_set / flat_multiset
             </code>
            </li>
           </ul>
          </li>
         </ul>
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13" id="c18-para-0010">
      Additionally, C++
      <code class="calibre21">
       string
      </code>
      s and streams can also be used as Standard Library containers to a certain degree, and
      <code class="calibre21">
       bitset
      </code>
      can be used to store a fixed number of bits.
     </p>
     <p class="calibre13" id="c18-para-0011">
      <span aria-label="685" class="calibre20" epub:type="pagebreak" id="Page_685" role="doc-pagebreak">
      </span>
      Everything in the Standard Library is in the
      <code class="calibre21">
       std
      </code>
      namespace. As always, the examples in this book usually use the blanket
      <code class="calibre21">
       using namespace std;
      </code>
      directive in source files (never use this in header files!), but you can be more selective in your own programs about which symbols from
      <code class="calibre21">
       std
      </code>
      to use.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-398">
       Requirements on Elements
      </h3>
      <p class="calibre13" id="c18-para-0012">
       Standard Library containers use value semantics on elements. That is, they store a copy of elements that they are given, assign to elements with the assignment operator, and destroy elements with the destructor. Thus, when you write classes that you intend to use with the Standard Library, you need to make sure they are copyable. When requesting an element from the container, a reference to the stored copy is returned.
      </p>
      <p class="calibre13" id="c18-para-0013">
       If you prefer reference semantics, you can store pointers to elements instead of the elements themselves. When the containers copy a pointer, the result still refers to the same element. An alternative is to store
       <code class="calibre21">
        std::reference:wrapper
       </code>
       s in the container. A
       <code class="calibre21">
        reference:wrapper
       </code>
       basically exists to make references copyable and can be created using the
       <code class="calibre21">
        std::ref()
       </code>
       and
       <code class="calibre21">
        cref()
       </code>
       helper functions. The
       <code class="calibre21">
        reference:wrapper
       </code>
       class template, and the
       <code class="calibre21">
        ref()
       </code>
       and
       <code class="calibre21">
        cref()
       </code>
       function templates are defined in
       <code class="calibre21">
        &lt;functional&gt;
       </code>
       . An example of this is given in the section “
       <a class="calibre5" href="c18_split_000.xhtml#c18-sec-0034">
        Storing References in a vector
       </a>
       ” later in this chapter.
      </p>
      <p class="calibre13">
       It is possible to store move-only types, i.e., non-copyable types, in a container, but when doing so, some operations on the container might not compile. An example of a move-only type is
       <code class="calibre21">
        std::unique_ptr
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0015">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           If you need to store pointers in containers, if possible, use
          </i>
          <code class="calibre21">
           unique_ptr
          </code>
          <i class="calibre18">
           s if the container becomes the owner of the pointed-to objects, or use
          </i>
          <code class="calibre21">
           shared_ptr
          </code>
          <i class="calibre18">
           s if the container shares ownership with other owners. Do not use the old and removed
          </i>
          <code class="calibre21">
           auto_ptr
          </code>
          <i class="calibre18">
           class in containers because it does not implement copying correctly.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       One of the template type parameters for Standard Library containers is an allocator. The container uses this allocator to allocate and deallocate memory for elements. The allocator type parameter has a default value, so you can almost always just ignore it. For example, the
       <code class="calibre21">
        vector
       </code>
       class template looks as follows:
      </p>
      <pre class="calibre26" id="c18-code-0001"><code class="calibre21">template &lt;typename T, <b class="calibre14">typename Allocator = std::allocator&lt;T&gt;</b>&gt; class vector;</code></pre>
      <p class="calibre13">
       Some containers, such as a
       <code class="calibre21">
        map
       </code>
       , additionally accept a comparator as one of the template type parameters. This comparator is used to order elements. It has a default value as well, so you don't always have to specify it. This default is to compare elements using
       <code class="calibre21">
        operator&lt;
       </code>
       . The
       <code class="calibre21">
        map
       </code>
       class template looks like this:
      </p>
      <pre class="calibre26" id="c18-code-0002"><code class="calibre21">template &lt;typename Key, typename T, <b class="calibre14">typename Compare = std::less&lt;Key&gt;</b>,</code>
<code class="calibre21">    typename Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt; class map;</code></pre>
      <p class="calibre13" id="c18-para-0018">
       Both the allocator and the comparator template type parameters are discussed in detail later in this chapter.
      </p>
      <p class="calibre13" id="c18-para-0019">
       <span aria-label="686" class="calibre20" epub:type="pagebreak" id="Page_686" role="doc-pagebreak">
       </span>
       The specific requirements on elements in containers using the default allocator and default comparator are shown in the following table:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          MEMBER FUNCTION
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
         <th class="left" colspan="4" scope="colgroup">
          NOTES
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          Copy Constructor
         </td>
         <td class="left1">
          Creates a new element that is “equal” to the old one, but that can safely be destructed without affecting the old one.
         </td>
         <td class="bgcolor" colspan="4">
          Used every time you insert an element, except when using an emplace member function (discussed later).
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Move Constructor
         </td>
         <td class="left1">
          Creates a new element by moving all content from the source element to the new element.
         </td>
         <td class="bgcolor" colspan="4">
          Used when the source element is an rvalue, and will be destroyed after the construction of the new element; also used when a
          <code class="calibre21">
           vector
          </code>
          grows in size. The move constructor should be
          <code class="calibre21">
           noexcept
          </code>
          ; otherwise, it won't be used!
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Assignment Operator
         </td>
         <td class="left1">
          Replaces the contents of an element with a copy of the source element.
         </td>
         <td class="bgcolor" colspan="4">
          Used every time you modify an element.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Move Assignment Operator
         </td>
         <td class="left1">
          Replaces the contents of an element by moving all content from the source element.
         </td>
         <td class="bgcolor" colspan="4">
          Used when the source element is an rvalue and will be destroyed after the assignment operation. The move assignment operator should be
          <code class="calibre21">
           noexcept;
          </code>
          otherwise, it won't be used!
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Destructor
         </td>
         <td class="left1">
          Cleans up an element.
         </td>
         <td class="bgcolor" colspan="4">
          Used every time you remove an element, or when a
          <code class="calibre21">
           vector
          </code>
          grows in size.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Default Constructor
         </td>
         <td class="left1">
          Constructs an element without any arguments.
         </td>
         <td class="bgcolor" colspan="4">
          Required only for certain operations, such as the
          <code class="calibre21">
           vector::resize()
          </code>
          member function with one argument, and the
          <code class="calibre21">
           map::operator[]
          </code>
          access.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator==
          </code>
         </td>
         <td class="left1">
          Compares two elements for equality.
         </td>
         <td class="bgcolor" colspan="4">
          Required for keys in unordered associative containers, and for certain operations, such as
          <code class="calibre21">
           operator==
          </code>
          on two containers.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&lt;
          </code>
         </td>
         <td class="left1">
          Determines whether one element is less than another.
         </td>
         <td class="bgcolor" colspan="4">
          Required for keys in ordered associative containers and flat associative container adapters, and for certain operations, such as
          <code class="calibre21">
           operator&lt;
          </code>
          on two containers.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&gt;,
          </code>
          <code class="calibre21">
           &lt;=
          </code>
          ,
          <code class="calibre21">
           &gt;=
          </code>
          ,
          <code class="calibre21">
           !=
          </code>
         </td>
         <td class="left1">
          Compares two elements.
         </td>
         <td class="left1">
          Required when comparing two containers.
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” explains how to write these member functions.
       <span aria-label="687" class="calibre20" epub:type="pagebreak" id="Page_687" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0023">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           The Standard Library containers often move or copy elements. So, for best performance, make sure the type of objects stored in a container supports move semantics, see
           <a class="calibre5" href="c09.xhtml">
            Chapter 9
           </a>
           . If move semantics is not possible, make sure the copy constructor and copy assignment operator are as efficient as possible
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-399">
       Exceptions and Error Checking
      </h3>
      <p class="calibre13" id="c18-para-0024">
       The Standard Library containers provide limited error checking. Clients are expected to ensure that their uses are valid. However, some container member functions throw exceptions in certain conditions, such as out-of-bounds indexing. Of course, it is impossible to list exhaustively the exceptions that can be thrown from these member functions because they perform operations on user-specified types with unknown exception characteristics. This chapter mentions exceptions where appropriate. Consult a Standard Library Reference (see
       <a class="calibre5" href="b02.xhtml">
        Appendix B
       </a>
       , “Annotated Bibliography”) for a list of possible exceptions thrown from each member function.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-199" class="calibre2">
     <span class="calibre" id="c18-sec-0009">
     </span>
     <h2 class="calibre6" id="head-2-199">
      SEQUENTIAL CONTAINERS
     </h2>
     <p class="calibre13" id="c18-para-0025">
      <code class="calibre21">
       vector
      </code>
      ,
      <code class="calibre21">
       deque
      </code>
      ,
      <code class="calibre21">
       list
      </code>
      ,
      <code class="calibre21">
       forward_list
      </code>
      , and
      <code class="calibre21">
       array
      </code>
      are called
      <i class="calibre18">
       sequential containers
      </i>
      because they store a sequence of elements. The best way to learn about sequential containers is to jump in with an example of the
      <code class="calibre21">
       vector
      </code>
      container, which should be your default container anyway. The next section describes the
      <code class="calibre21">
       vector
      </code>
      container in detail, followed by briefer discussions of
      <code class="calibre21">
       deque
      </code>
      ,
      <code class="calibre21">
       list
      </code>
      ,
      <code class="calibre21">
       forward_list
      </code>
      , and
      <code class="calibre21">
       array
      </code>
      . Once you become familiar with the sequential containers, it's trivial to switch between them.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0010">
      </span>
      <h3 class="calibre27" id="head-3-400">
       vector
      </h3>
      <p class="calibre13" id="c18-para-0026">
       The Standard Library
       <code class="calibre21">
        vector
       </code>
       container is similar to a standard C-style array: the elements are stored in contiguous memory, each in its own “slot.” You can index into a
       <code class="calibre21">
        vector
       </code>
       , as well as add new elements to the back or insert them anywhere else. Inserting and deleting elements into and from a
       <code class="calibre21">
        vector
       </code>
       generally takes linear time, though these operations actually run in
       <i class="calibre18">
        amortized constant
       </i>
       time at the end of a
       <code class="calibre21">
        vector
       </code>
       , as explained in the section “
       <a class="calibre5" href="c18_split_000.xhtml#c18-sec-0042">
        The vector Memory Allocation Scheme
       </a>
       ,” later in this chapter. Random access of individual elements has a constant complexity; see
       <a class="calibre5" href="c04.xhtml">
        Chapter 4
       </a>
       , “Designing Professional C++ Programs,” for a discussion on algorithm complexity.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-279">
        vector Overview
       </h4>
       <p class="calibre13">
        <code class="calibre21">
         vector
        </code>
        is defined in
        <code class="calibre21">
         &lt;vector&gt;
        </code>
        as a class template with two type parameters: the element type to store and an
        <i class="calibre18">
         allocator
        </i>
        type:
       </p>
       <pre class="calibre26" id="c18-code-0003"><code class="calibre21">template &lt;typename T, typename Allocator = allocator&lt;T&gt;&gt; class vector;</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         Allocator
        </code>
        parameter specifies the type for a memory allocator object that the client can set in order to use custom memory allocation. This template parameter has a default value.
        <span aria-label="688" class="calibre20" epub:type="pagebreak" id="Page_688" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0029">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            The default value for the
           </i>
           <code class="calibre21">
            Allocator
           </code>
           <i class="calibre18">
            template type parameter is sufficient for most applications. This chapter always uses the default allocator.
            <a class="calibre5" href="c25.xhtml">
             Chapter 25
            </a>
            , “Customizing and Extending the Standard Library,” provides more details in case you are interested.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c18-para-0030">
        <code class="calibre21">
         std::vector
        </code>
        is
        <code class="calibre21">
         constexpr
        </code>
        (see
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        ), just as
        <code class="calibre21">
         std::string
        </code>
        . This means that
        <code class="calibre21">
         vector
        </code>
        can be used to perform operations at compile time and that it can be used in the implementation of
        <code class="calibre21">
         constexpr
        </code>
        functions and other
        <code class="calibre21">
         constexpr
        </code>
        classes.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0013">
        </span>
        <h5 class="calibre35" id="head-5-108">
         Fixed-Length vectors
        </h5>
        <p class="calibre13">
         One way to use a
         <code class="calibre21">
          vector
         </code>
         is as a fixed-length array.
         <code class="calibre21">
          vector
         </code>
         provides a constructor that allows you to specify the number of elements and provides an overloaded
         <code class="calibre21">
          operator[]
         </code>
         to access and modify those elements. The result of
         <code class="calibre21">
          operator[]
         </code>
         is undefined when used to access an element outside the
         <code class="calibre21">
          vector
         </code>
         bounds. This means that a compiler can decide how to behave in that case. For example, the default behavior of Microsoft Visual C++ is to give a run-time error message when your program is compiled in debug mode and to disable any bounds checking in release mode for performance reasons. You can change these default behaviors.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0032">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Like “real” array indexing,
            </i>
            <code class="calibre21">
             operator[]
            </code>
            <i class="calibre18">
             on a
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             does not provide bounds checking.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         In addition to using
         <code class="calibre21">
          operator[]
         </code>
         , you can access
         <code class="calibre21">
          vector
         </code>
         elements via
         <code class="calibre21">
          at()
         </code>
         ,
         <code class="calibre21">
          front()
         </code>
         , and
         <code class="calibre21">
          back()
         </code>
         . The
         <code class="calibre21">
          at()
         </code>
         member function is identical to
         <code class="calibre21">
          operator[]
         </code>
         , except that it performs bounds checking and throws an
         <code class="calibre21">
          out_of_range
         </code>
         exception if the index is out of bounds.
         <code class="calibre21">
          front()
         </code>
         and
         <code class="calibre21">
          back()
         </code>
         return references to the first and last elements of a
         <code class="calibre21">
          vector
         </code>
         , respectively. Calling
         <code class="calibre21">
          front()
         </code>
         or
         <code class="calibre21">
          back()
         </code>
         on an empty container triggers undefined behavior.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0034">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             All
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             element accesses have constant complexity.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         Here is a small example program to “normalize” test scores so that the highest score is set to 100, and all other scores are adjusted accordingly. The program creates a
         <code class="calibre21">
          vector
         </code>
         of ten
         <code class="calibre21">
          double
         </code>
         s, reads in ten values from the user, divides each value by the max score (times 100), and prints out the new values. To create the vector, parentheses, (10), are used and not uniform initialization, {10}, as the latter would create a vector of just one element with the value 10. For the sake of brevity, the program forsakes error checking.
        </p>
        <pre class="calibre26" id="c18-code-0004"><code class="calibre21">vector&lt;double&gt; doubleVector(10); <span class="color">// Create a vector of 10 doubles.</span></code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Initialize max to smallest number.</span></code>
<code class="calibre21">double max { -numeric_limits&lt;double&gt;::infinity() };</code>
<code class="calibre21"> </code>
<span aria-label="689" class="calibre20" epub:type="pagebreak" id="Page_689" role="doc-pagebreak"></span><code class="calibre21">for (size_t i { 0 }; i &lt; doubleVector.size(); ++i) {</code>
<code class="calibre21">    print("Enter score {}: ", i + 1);</code>
<code class="calibre21">    cin &gt;&gt; doubleVector[i];</code>
<code class="calibre21">    if (doubleVector[i]&gt; max) {</code>
<code class="calibre21">        max = doubleVector[i];</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">max /= 100.0;</code>
<code class="calibre21">for (auto&amp; element : doubleVector) {</code>
<code class="calibre21">    element /= max;</code>
<code class="calibre21">    print("{} ", element);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         As you can see from this example, you can use a
         <code class="calibre21">
          vector
         </code>
         just as you would use a standard C-style array. Note that the first
         <code class="calibre21">
          for
         </code>
         loop uses the
         <code class="calibre21">
          size()
         </code>
         member function to determine the number of elements in the container. This example also demonstrates the use of a range-based
         <code class="calibre21">
          for
         </code>
         loop with a
         <code class="calibre21">
          vector
         </code>
         . Here, the range-based
         <code class="calibre21">
          for
         </code>
         loop uses
         <code class="calibre21">
          auto&amp;
         </code>
         and not
         <code class="calibre21">
          auto
         </code>
         because a reference is required so that the actual elements can be modified in each iteration.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0037">
            <b class="calibre14">
             NOTE
            </b>
            <code class="calibre21">
             operator[]
            </code>
            <i class="calibre18">
             on a
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             normally returns a reference to the element, which can be used on the left-hand side of assignment statements. If
            </i>
            <code class="calibre21">
             operator[]
            </code>
            <i class="calibre18">
             is called on a
            </i>
            <code class="calibre21">
             const vector
            </code>
            <i class="calibre18">
             object, it returns a reference to a
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             element, which cannot be used as the target of an assignment. See
             <a class="calibre5" href="c15.xhtml">
              Chapter 15
             </a>
             , “Overloading C++ Operators,” for details on how this trick is implemented.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0017">
        </span>
        <h5 class="calibre35" id="head-5-109">
         Dynamic-Length vectors
        </h5>
        <p class="calibre13">
         The real power of a
         <code class="calibre21">
          vector
         </code>
         lies in its ability to grow dynamically. For example, consider the test score normalization program from the previous section with the additional requirement that it should handle any number of test scores. Here is the new version:
        </p>
        <pre class="calibre26" id="c18-code-0005"><code class="calibre21"><b class="calibre14">vector&lt;double&gt; doubleVector;</b> <span class="color">// Create a vector with zero elements.</span></code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Initialize max to smallest number.</span></code>
<code class="calibre21">double max { -numeric_limits&lt;double&gt;::infinity() };</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">for (size_t i { 1 }; true; ++i) {</b></code>
<code class="calibre21">    <b class="calibre14">double value;</b></code>
<code class="calibre21">    <b class="calibre14">print("Enter score {} (-1 to stop): ", i);</b></code>
<code class="calibre21">    <b class="calibre14">cin &gt;&gt; value;</b></code>
<code class="calibre21">    <b class="calibre14">if (value == -1) {</b></code>
<code class="calibre21">        <b class="calibre14">break;</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">    <b class="calibre14">doubleVector.push_back(value);</b></code>
<code class="calibre21">    <b class="calibre14">if (value &gt; max) {</b></code>
<code class="calibre21">        <b class="calibre14">max = value;</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="690" class="calibre20" epub:type="pagebreak" id="Page_690" role="doc-pagebreak"></span><code class="calibre21">max /= 100.0;</code>
<code class="calibre21">for (auto&amp; element : doubleVector) {</code>
<code class="calibre21">    element /= max;</code>
<code class="calibre21">    print("{} ", element);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c18-para-0039">
         This version of the program uses the default constructor to create a
         <code class="calibre21">
          vector
         </code>
         with zero elements. As each score is read, it's added to the end of the
         <code class="calibre21">
          vector
         </code>
         with the
         <code class="calibre21">
          push_back()
         </code>
         member function, which takes care of allocating space for the new element. The range-based
         <code class="calibre21">
          for
         </code>
         loop doesn't require any changes.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0018">
        </span>
        <h5 class="calibre35" id="head-5-110">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         Formatting and Printing Vectors
        </h5>
        <p class="calibre13">
         Starting with C++23,
         <code class="calibre21">
          std::format()
         </code>
         and the
         <code class="calibre21">
          print()
         </code>
         functions can be used to format and print entire containers with a single statement. This works for all Standard Library sequential containers, container adapters, and associative containers, and is introduced in
         <a class="calibre5" href="c02.xhtml">
          Chapter 2
         </a>
         , “Working with Strings and String Views.” Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0006"><code class="calibre21">vector values { 1.1, 2.2, 3.3 };</code>
<code class="calibre21">println("{}", values);   <span class="color">// Prints the following: [1.1, 2.2, 3.3]</span></code></pre>
        <p class="calibre13">
         You can specify the
         <code class="calibre21">
          n
         </code>
         format specifier to omit the surrounding square brackets:
        </p>
        <pre class="calibre26" id="c18-code-0007"><code class="calibre21">println("{:n}", values); <span class="color">// Prints the following: 1.1, 2.2, 3.3</span></code></pre>
        <p class="calibre13">
         If your compiler doesn't support this feature yet, you can use a range-based
         <code class="calibre21">
          for
         </code>
         loop to iterate over the elements of a
         <code class="calibre21">
          vector
         </code>
         and to print them, for example:
        </p>
        <pre class="calibre26" id="c18-code-0008"><code class="calibre21">for (const auto&amp; value : values) { std::cout &lt;&lt; value &lt;&lt; ", "; }</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0019">
       </span>
       <h4 class="calibre29" id="head-4-280">
        vector Details
       </h4>
       <p class="calibre13" id="c18-para-0044">
        Now that you've had a taste of
        <code class="calibre21">
         vector
        </code>
        s, it's time to delve into their details.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0020">
        </span>
        <h5 class="calibre35" id="head-5-111">
         Constructors and Destructors
        </h5>
        <p class="calibre13">
         The default constructor creates a
         <code class="calibre21">
          vector
         </code>
         with zero elements.
        </p>
        <pre class="calibre26" id="c18-code-0009"><code class="calibre21">vector&lt;int&gt; intVector; <span class="color">// Creates a vector of ints with zero elements</span></code></pre>
        <p class="calibre13">
         You can specify a number of elements and, optionally, a value for those elements, like this:
        </p>
        <pre class="calibre26" id="c18-code-0010"><code class="calibre21">vector&lt;int&gt; intVector(10, 100); <span class="color">// Creates vector of 10 ints with value 100</span></code></pre>
        <p class="calibre13" id="c18-para-0047">
         If you omit the default value, the new objects are zero-initialized.
         <i class="calibre18">
          Zero-initialization
         </i>
         constructs objects with the default constructor and initializes primitive integer types (such as
         <code class="calibre21">
          char
         </code>
         ,
         <code class="calibre21">
          int
         </code>
         , and so on) to zero, primitive floating-point types to 0.0, and pointer types to
         <code class="calibre21">
          nullptr
         </code>
         .
        </p>
        <p class="calibre13">
         You can create
         <code class="calibre21">
          vector
         </code>
         s of built-in classes like this:
        </p>
        <pre class="calibre26" id="c18-code-0011"><code class="calibre21">vector&lt;string&gt; stringVector(10, "hello");</code></pre>
        <p class="calibre13">
         User-defined classes can also be used as
         <code class="calibre21">
          vector
         </code>
         elements:
        </p>
        <pre class="calibre26" id="c18-code-0012"><code class="calibre21">class Element { };</code>
<code class="calibre21">…</code>
<code class="calibre21">vector&lt;Element&gt; elementVector;</code></pre>
        <p class="calibre13">
         <span aria-label="691" class="calibre20" epub:type="pagebreak" id="Page_691" role="doc-pagebreak">
         </span>
         A
         <code class="calibre21">
          vector
         </code>
         can be constructed with an
         <code class="calibre21">
          initializer_list
         </code>
         containing the initial elements:
        </p>
        <pre class="calibre26" id="c18-code-0013"><code class="calibre21">vector&lt;int&gt; intVector({ 1, 2, 3, 4, 5, 6 });</code></pre>
        <p class="calibre13">
         Uniform initialization
         <i class="calibre18">
          ,
         </i>
         as discussed in
         <a class="calibre5" href="c01_split_000.xhtml">
          Chapter 1
         </a>
         , “A Crash Course in C++ and the Standard Library,” works on most Standard Library containers, including
         <code class="calibre21">
          vector
         </code>
         . Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0014"><code class="calibre21">vector&lt;int&gt; intVector = { 1, 2, 3, 4, 5, 6 };</code>
<code class="calibre21">vector&lt;int&gt; intVector { 1, 2, 3, 4, 5, 6 };</code></pre>
        <p class="calibre13">
         Thanks to class template argument deduction (CTAD), you can omit the template type parameter. Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0015"><code class="calibre21">vector intVector { 1, 2, 3, 4, 5, 6 };</code></pre>
        <p class="calibre13">
         Be cautious with uniform initialization, though; usually, when calling a constructor of an object, the uniform initialization syntax can be used. Here's an example:
        </p>
        <pre class="calibre26" id="c18-code-0016"><code class="calibre21">string text { "Hello World." };</code></pre>
        <p class="calibre13">
         With
         <code class="calibre21">
          vector
         </code>
         you need be careful. For example, the following line of code calls a
         <code class="calibre21">
          vector
         </code>
         constructor to create a
         <code class="calibre21">
          vector
         </code>
         of 10 integers with value 100:
        </p>
        <pre class="calibre26" id="c18-code-0017"><code class="calibre21">vector&lt;int&gt; intVector(10, 100); <span class="color">// Creates vector of 10 ints with value 100</span></code></pre>
        <p class="calibre13">
         Using uniform initialization here instead as follows does not create a
         <code class="calibre21">
          vector
         </code>
         of 10 integers, but a
         <code class="calibre21">
          vector
         </code>
         with just two elements, initialized to 10 and 100:
        </p>
        <pre class="calibre26" id="c18-code-0018"><code class="calibre21">vector&lt;int&gt; intVector { 10, 100 }; <span class="color">// Creates vector with two elements: 10 and 100</span></code></pre>
        <p class="calibre13">
         You can allocate
         <code class="calibre21">
          vector
         </code>
         s on the free store as well:
        </p>
        <pre class="calibre26" id="c18-code-0019"><code class="calibre21">auto elementVector { make_unique&lt;vector&lt;Element&gt;&gt;(10) };</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0021">
        </span>
        <h5 class="calibre35" id="head-5-112">
         Copying and Assigning vectors
        </h5>
        <p class="calibre13" id="c18-para-0057">
         A
         <code class="calibre21">
          vector
         </code>
         stores copies of the objects, and its destructor calls the destructor for each of the objects. The copy constructor and assignment operator of the
         <code class="calibre21">
          vector
         </code>
         class perform deep copies of all the elements in the
         <code class="calibre21">
          vector
         </code>
         . Thus, for efficiency, you should pass
         <code class="calibre21">
          vector
         </code>
         s by reference-to-non-
         <code class="calibre21">
          const
         </code>
         or reference-to-
         <code class="calibre21">
          const
         </code>
         to functions, instead of by value.
        </p>
        <p class="calibre13">
         In addition to normal copying and assignment,
         <code class="calibre21">
          vector
         </code>
         provides an
         <code class="calibre21">
          assign()
         </code>
         member function that removes all the current elements and adds any number of new elements. This member function is useful if you want to reuse a
         <code class="calibre21">
          vector
         </code>
         . Here is a trivial example.
         <code class="calibre21">
          intVector
         </code>
         is created with 10 elements having the default value 0. Then
         <code class="calibre21">
          assign()
         </code>
         is used to remove all 10 elements and replace them with 5 elements with value 100:
        </p>
        <pre class="calibre26" id="c18-code-0020"><code class="calibre21">vector&lt;int&gt; intVector(10);</code>
<code class="calibre21">println("intVector: {:n}", intVector);  <span class="color">// 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span></code>
<code class="calibre21">…</code>
<code class="calibre21">intVector.assign(5, 100);</code>
<code class="calibre21">println("intVector: {:n}", intVector);  <span class="color">// 100, 100, 100, 100, 100</span></code></pre>
        <p class="calibre13">
         <code class="calibre21">
          assign()
         </code>
         can also accept an
         <code class="calibre21">
          initializer_list
         </code>
         as follows. After this statement,
         <code class="calibre21">
          intVector
         </code>
         has four elements with the given values:
        </p>
        <pre class="calibre26" id="c18-code-0021"><code class="calibre21">intVector.assign({ 1, 2, 3, 4 });</code>
<code class="calibre21">println("intVector: {:n}", intVector);  <span class="color">// 1, 2, 3, 4</span></code></pre>
        <p class="calibre13">
         <span aria-label="692" class="calibre20" epub:type="pagebreak" id="Page_692" role="doc-pagebreak">
         </span>
         <code class="calibre21">
          vector
         </code>
         provides a
         <code class="calibre21">
          swap()
         </code>
         member function that allows you to swap the contents of two
         <code class="calibre21">
          vector
         </code>
         s in constant time. Here is a simple example:
        </p>
        <pre class="calibre26" id="c18-code-0022"><code class="calibre21">vector&lt;int&gt; vectorOne(10);</code>
<code class="calibre21">vector&lt;int&gt; vectorTwo(5, 100);</code>
<code class="calibre21">println("vectorOne: {:n}", vectorOne);  <span class="color">// 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span></code>
<code class="calibre21">println("vectorTwo: {:n}", vectorTwo);  <span class="color">// 100, 100, 100, 100, 100</span></code>
<code class="calibre21"> </code>
<code class="calibre21">vectorOne.swap(vectorTwo);</code>
<code class="calibre21"> </code>
<code class="calibre21">println("vectorOne: {:n}", vectorOne);  <span class="color">// 100, 100, 100, 100, 100</span></code>
<code class="calibre21">println("vectorTwo: {:n}", vectorTwo);  <span class="color">// 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span></code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0022">
        </span>
        <h5 class="calibre35" id="head-5-113">
         Comparing vectors
        </h5>
        <p class="calibre13">
         The Standard Library provides the usual six overloaded comparison operators for
         <code class="calibre21">
          vector
         </code>
         s:
         <code class="calibre21">
          ==
         </code>
         ,
         <code class="calibre21">
          !=
         </code>
         ,
         <code class="calibre21">
          &lt;
         </code>
         ,
         <code class="calibre21">
          &gt;
         </code>
         ,
         <code class="calibre21">
          &lt;=
         </code>
         ,
         <code class="calibre21">
          &gt;=
         </code>
         . Two
         <code class="calibre21">
          vector
         </code>
         s are equal if they have the same number of elements and all the corresponding elements in the two
         <code class="calibre21">
          vector
         </code>
         s are equal to each other. Two
         <code class="calibre21">
          vector
         </code>
         s are compared lexicographically; that is, one
         <code class="calibre21">
          vector
         </code>
         is “less than” another if all elements
         <code class="calibre21">
          0
         </code>
         through
         <code class="calibre21">
          i–1
         </code>
         in the first
         <code class="calibre21">
          vector
         </code>
         are equal to elements
         <code class="calibre21">
          0
         </code>
         through
         <code class="calibre21">
          i-1
         </code>
         in the second
         <code class="calibre21">
          vector
         </code>
         , but element
         <code class="calibre21">
          i
         </code>
         in the first is less than element
         <code class="calibre21">
          i
         </code>
         in the second, where
         <code class="calibre21">
          i
         </code>
         must be in the range
         <code class="calibre21">
          0…n
         </code>
         and
         <code class="calibre21">
          n
         </code>
         must be less than the
         <code class="calibre21">
          size()
         </code>
         of the smallest of the two
         <code class="calibre21">
          vector
         </code>
         s.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0062">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Comparing two
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             s with
            </i>
            <code class="calibre21">
             operator==
            </code>
            <i class="calibre18">
             or
            </i>
            <code class="calibre21">
             !=
            </code>
            <i class="calibre18">
             requires the individual elements to be comparable with
            </i>
            <code class="calibre21">
             operator==
            </code>
            <i class="calibre18">
             . Comparing two
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             s with
            </i>
            <code class="calibre21">
             operator&lt;
            </code>
            <i class="calibre18">
             ,
            </i>
            <code class="calibre21">
             &gt;
            </code>
            <i class="calibre18">
             ,
            </i>
            <code class="calibre21">
             &lt;=
            </code>
            <i class="calibre18">
             ,
            </i>
            or
            <i class="calibre18">
            </i>
            <code class="calibre21">
             &gt;=
            </code>
            <i class="calibre18">
             requires the individual elements to be comparable with
            </i>
            <code class="calibre21">
             operator&lt;
            </code>
            <i class="calibre18">
             . If you intend to store objects of a custom class in a
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             , make sure to write those operators.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         Here is an example of a program that compares
         <code class="calibre21">
          vector
         </code>
         s of
         <code class="calibre21">
          int
         </code>
         s:
        </p>
        <pre class="calibre26" id="c18-code-0023"><code class="calibre21">vector&lt;int&gt; vectorOne(10);</code>
<code class="calibre21">vector&lt;int&gt; vectorTwo(10);</code>
<code class="calibre21"> </code>
<code class="calibre21">if (vectorOne == vectorTwo) { println("equal!"); }</code>
<code class="calibre21">else { println("not equal!"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">vectorOne[3] = 50;</code>
<code class="calibre21"> </code>
<code class="calibre21">if (vectorOne &lt; vectorTwo) { println("vectorOne is less than vectorTwo"); }</code>
<code class="calibre21">else { println("vectorOne is not less than vectorTwo"); }</code></pre>
        <p class="calibre13">
         The output of the program is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0024"><code class="calibre21">equal!</code>
<code class="calibre21">vectorOne is not less than vectorTwo</code></pre>
       </section>
       <span aria-label="693" class="calibre20" epub:type="pagebreak" id="Page_693" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0024">
        </span>
        <h5 class="calibre35" id="head-5-114">
         vector Iterators
        </h5>
        <p class="calibre13">
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         , “Understanding Iterators and the Ranges Library,” explains the concepts of container iterators. The discussion can get a bit abstract, so it's helpful to jump in and look at a code example. Here is the last
         <code class="calibre21">
          for
         </code>
         loop of the test score normalization program from earlier in this chapter:
        </p>
        <pre class="calibre26" id="c18-code-0025"><code class="calibre21">for (auto&amp; element : doubleVector) {</code>
<code class="calibre21">    element /= max;</code>
<code class="calibre21">    print("{} ", element);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         This loop can be written using iterators instead of a range-based
         <code class="calibre21">
          for
         </code>
         loop as follows:
        </p>
        <pre class="calibre26" id="c18-code-0026"><code class="calibre21">for (vector&lt;double&gt;::iterator iter { begin(doubleVector) };</code>
<code class="calibre21">    iter != end(doubleVector); ++iter) {</code>
<code class="calibre21">    *iter /= max;</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         First, take a look at the
         <code class="calibre21">
          for
         </code>
         loop initialization statement:
        </p>
        <pre class="calibre26" id="c18-code-0027"><code class="calibre21">vector&lt;double&gt;::iterator iter { begin(doubleVector) };</code></pre>
        <p class="calibre13">
         Recall that every container defines a type named
         <code class="calibre21">
          iterator
         </code>
         to represent iterators for that type of container.
         <code class="calibre21">
          begin()
         </code>
         returns an iterator of that type referring to the first element in the container. Thus, the initialization statement obtains in the variable
         <code class="calibre21">
          iter
         </code>
         an iterator referring to the first element of
         <code class="calibre21">
          doubleVector
         </code>
         . Next, look at the
         <code class="calibre21">
          for
         </code>
         loop comparison:
        </p>
        <pre class="calibre26" id="c18-code-0028"><code class="calibre21">iter != end(doubleVector);</code></pre>
        <p class="calibre13" id="c18-para-0069">
         This statement simply checks whether the iterator is past the end of the sequence of elements in the
         <code class="calibre21">
          vector
         </code>
         . When it reaches that point, the loop terminates. Always use
         <code class="calibre21">
          operator!=
         </code>
         in such statements and not
         <code class="calibre21">
          operator&lt;
         </code>
         as the latter is not supported by all types of iterators; see
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         for details.
        </p>
        <p class="calibre13">
         The increment statement,
         <code class="calibre21">
          ++iter
         </code>
         , increments the iterator to refer to the next element in the
         <code class="calibre21">
          vector
         </code>
         .
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0071">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Use pre-increment instead of post-increment when possible because pre-increment is at least as efficient and usually more efficient
            </i>
            .
            <code class="calibre21">
             iter++
            </code>
            <i class="calibre18">
             must return a new iterator object, while
            </i>
            <code class="calibre21">
             ++iter
            </code>
            <i class="calibre18">
             can simply return a reference to
            </i>
            <code class="calibre21">
             iter
            </code>
            <i class="calibre18">
             . See
             <a class="calibre5" href="c15.xhtml">
              Chapter 15
             </a>
             , “Overloading C++ Operators,” for details on implementing both versions of
            </i>
            <code class="calibre21">
             operator++
            </code>
            <i class="calibre18">
             .
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         The
         <code class="calibre21">
          for
         </code>
         loop body contains these two lines:
        </p>
        <pre class="calibre26" id="c18-code-0029"><code class="calibre21">*iter /= max;</code>
<code class="calibre21">print("{} ", *iter);</code></pre>
        <p class="calibre13" id="c18-para-0073">
         As you can see, your code can both access and modify the elements over which it iterates. The first line uses
         <code class="calibre21">
          operator*
         </code>
         to dereference
         <code class="calibre21">
          iter
         </code>
         to obtain the element to which it refers and assigns to that element. The second line dereferences
         <code class="calibre21">
          iter
         </code>
         again, but this time only to print the element to the standard output console.
        </p>
        <p class="calibre13">
         <span aria-label="694" class="calibre20" epub:type="pagebreak" id="Page_694" role="doc-pagebreak">
         </span>
         The preceding
         <code class="calibre21">
          for
         </code>
         loop using iterators can be simplified by using the
         <code class="calibre21">
          auto
         </code>
         keyword:
        </p>
        <pre class="calibre26" id="c18-code-0030"><code class="calibre21"><b class="calibre14">for (auto iter { begin(doubleVector) };</b></code>
<code class="calibre21">    iter != end(doubleVector); ++iter) {</code>
<code class="calibre21">    *iter /= max;</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c18-para-0075">
         With
         <code class="calibre21">
          auto
         </code>
         , the compiler automatically deduces the type of the variable
         <code class="calibre21">
          iter
         </code>
         based on the right-hand side of the initializer, which in this case is the result of the call to
         <code class="calibre21">
          begin()
         </code>
         .
        </p>
        <p class="calibre13">
         <code class="calibre21">
          vector
         </code>
         supports the following member functions to get iterators:
        </p>
        <ul class="check" id="c18-list-0004">
         <li class="calibre9" id="c18-li-0032">
          <code class="calibre21">
           begin()
          </code>
          and
          <code class="calibre21">
           end()
          </code>
          returning iterators referring to the first and one past the last element
         </li>
         <li class="calibre9" id="c18-li-0033">
          <code class="calibre21">
           rbegin()
          </code>
          and
          <code class="calibre21">
           rend()
          </code>
          returning reverse iterators referring to the last and one before the first element
         </li>
         <li class="calibre9" id="c18-li-0034">
          <code class="calibre21">
           cbegin()
          </code>
          ,
          <code class="calibre21">
           cend()
          </code>
          ,
          <code class="calibre21">
           crbegin()
          </code>
          , and
          <code class="calibre21">
           crend()
          </code>
          returning
          <code class="calibre21">
           const
          </code>
          iterators
         </li>
        </ul>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0077">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             If you need to iterate over all elements in a container, it's recommended to use a range-based
            </i>
            <code class="calibre21">
             for
            </code>
            <i class="calibre18">
             loop instead of iterators as the former is easier to read and write, as well as being less error-prone. Use iterators only when you need to iterate over a subrange or when you need an iterator in the body of the loop.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0027">
         </span>
         <h6 class="calibre35" id="head-6-1">
          Accessing Fields of Object Elements
         </h6>
         <p class="calibre13">
          If the elements of your container are objects, you can use the
          <code class="calibre21">
           -&gt;
          </code>
          operator on iterators to call member functions or access data members of those objects. For example, the following program creates a
          <code class="calibre21">
           vector
          </code>
          of 10
          <code class="calibre21">
           string
          </code>
          s, then iterates over all of them appending a new
          <code class="calibre21">
           string
          </code>
          to each one:
         </p>
         <pre class="calibre26" id="c18-code-0031"><code class="calibre21">vector&lt;string&gt; stringVector(10, "hello");</code>
<code class="calibre21">for (auto it { begin(stringVector) }; it != end(stringVector); ++it) {</code>
<code class="calibre21">    it-&gt;append(" there");</code>
<code class="calibre21">}</code></pre>
         <p class="calibre13">
          Often, using a range-based
          <code class="calibre21">
           for
          </code>
          loop results in more elegant code, as in this example:
         </p>
         <pre class="calibre26" id="c18-code-0032"><code class="calibre21">for (auto&amp; str : stringVector) {</code>
<code class="calibre21">    str.append(" there");</code>
<code class="calibre21">}</code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0028">
         </span>
         <h6 class="calibre35" id="head-6-2">
          const_iterator
         </h6>
         <p class="calibre13">
          The normal
          <code class="calibre21">
           iterator
          </code>
          is read/write. However, if you call
          <code class="calibre21">
           begin()
          </code>
          or
          <code class="calibre21">
           end()
          </code>
          on a
          <code class="calibre21">
           const
          </code>
          object, or you call
          <code class="calibre21">
           cbegin()
          </code>
          or
          <code class="calibre21">
           cend()
          </code>
          , you receive a
          <code class="calibre21">
           const_iterator
          </code>
          . A
          <code class="calibre21">
           const_iterator
          </code>
          is read-only; you cannot modify the element it refers to. An
          <code class="calibre21">
           iterator
          </code>
          can always be converted to a
          <code class="calibre21">
           const_iterator
          </code>
          , so it's always safe to write something like this:
         </p>
         <pre class="calibre26" id="c18-code-0033"><code class="calibre21">vector&lt;<i class="calibre18">type</i>&gt;::const_iterator it { begin(myVector) };</code></pre>
         <p class="calibre13">
          <span aria-label="695" class="calibre20" epub:type="pagebreak" id="Page_695" role="doc-pagebreak">
          </span>
          However, a
          <code class="calibre21">
           const_iterator
          </code>
          cannot be converted to an
          <code class="calibre21">
           iterator
          </code>
          . If
          <code class="calibre21">
           myVector
          </code>
          is
          <code class="calibre21">
           const
          </code>
          , the following line doesn't compile:
         </p>
         <pre class="calibre26" id="c18-code-0034"><code class="calibre21">vector&lt;<i class="calibre18">type</i>&gt;::iterator it { begin(myVector) };</code></pre>
         <section class="calibre2">
          <aside class="calibre23">
           <div class="top">
            <hr class="calibre24"/>
           </div>
           <section class="feature">
            <p class="calibre25" id="c18-para-0083">
             <b class="calibre14">
              NOTE
             </b>
             <i class="calibre18">
              If you do not need to modify the elements of a
             </i>
             <code class="calibre21">
              vector
             </code>
             <i class="calibre18">
              , you should use a
             </i>
             <code class="calibre21">
              const_iterator
             </code>
             <i class="calibre18">
              . This rule makes it easier to guarantee correctness of your code and helps the compiler to perform better optimizations
             </i>
             .
            </p>
            <div class="top">
             <hr class="calibre24"/>
            </div>
           </section>
          </aside>
         </section>
         <p class="calibre13">
          When using the
          <code class="calibre21">
           auto
          </code>
          keyword, using
          <code class="calibre21">
           const_iterator
          </code>
          s looks a bit different. Suppose you write the following code:
         </p>
         <pre class="calibre26" id="c18-code-0035"><code class="calibre21">vector&lt;string&gt; stringVector(10, "hello");</code>
<code class="calibre21">for (auto iter { begin(stringVector) }; iter != end(stringVector); ++iter) {</code>
<code class="calibre21">    println("{}", *iter);</code>
<code class="calibre21">}</code></pre>
         <p class="calibre13">
          Because of the
          <code class="calibre21">
           auto
          </code>
          keyword, the compiler deduces the type of the
          <code class="calibre21">
           iter
          </code>
          variable automatically and makes it a normal
          <code class="calibre21">
           iterator
          </code>
          because
          <code class="calibre21">
           stringVector
          </code>
          is not
          <code class="calibre21">
           const
          </code>
          . If you want a read-only
          <code class="calibre21">
           const_iterator
          </code>
          in combination with using
          <code class="calibre21">
           auto
          </code>
          , then you need to use
          <code class="calibre21">
           cbegin()
          </code>
          and
          <code class="calibre21">
           cend()
          </code>
          instead of
          <code class="calibre21">
           begin()
          </code>
          and
          <code class="calibre21">
           end()
          </code>
          as follows:
         </p>
         <pre class="calibre26" id="c18-code-0036"><code class="calibre21"><b class="calibre14">for (auto iter { cbegin(stringVector) }; iter != cend(stringVector); ++iter) {</b></code>
<code class="calibre21">    println("{}", *iter);</code>
<code class="calibre21">}</code></pre>
         <p class="calibre13" id="c18-para-0086">
          Now the compiler uses
          <code class="calibre21">
           const_iterator
          </code>
          as type for the variable
          <code class="calibre21">
           iter
          </code>
          because that's what
          <code class="calibre21">
           cbegin()
          </code>
          returns.
         </p>
         <p class="calibre13">
          A range-based
          <code class="calibre21">
           for
          </code>
          loop can also be forced to use
          <code class="calibre21">
           const
          </code>
          iterators as follows:
         </p>
         <pre class="calibre26" id="c18-code-0037"><code class="calibre21">for (<b class="calibre14">const auto&amp;</b> element : stringVector) {</code>
<code class="calibre21">    println("{}", element);</code>
<code class="calibre21">}</code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0030">
         </span>
         <h6 class="calibre35" id="head-6-3">
          Iterator Safety
         </h6>
         <p class="calibre13">
          Generally, iterators are about as safe as pointers—that is, extremely unsafe. For example, you can write code like this:
         </p>
         <pre class="calibre26" id="c18-code-0038"><code class="calibre21">vector&lt;int&gt; intVector;</code>
<code class="calibre21">auto iter { end(intVector) };</code>
<code class="calibre21">*iter = 10; <span class="color">// Bug! Iter doesn't refer to a valid element.</span></code></pre>
         <p class="calibre13" id="c18-para-0089">
          Recall that the iterator returned by
          <code class="calibre21">
           end()
          </code>
          is one element past the end of a
          <code class="calibre21">
           vector
          </code>
          , not an iterator referring to the last element! Trying to dereference it results in undefined behavior. Iterators are not required to perform any verification.
         </p>
         <p class="calibre13">
          Another problem can occur if you use mismatched iterators. For example, the following
          <code class="calibre21">
           for
          </code>
          loop initializes
          <code class="calibre21">
           iter
          </code>
          with an iterator from
          <code class="calibre21">
           vectorTwo
          </code>
          and tries to compare it to the end iterator of
          <code class="calibre21">
           vectorOne
          </code>
          . Needless to say, this loop will not do what you intended and may never terminate. Dereferencing the iterator in the loop will likely produce undefined results.
         </p>
         <pre class="calibre26" id="c18-code-0039"><span aria-label="696" class="calibre20" epub:type="pagebreak" id="Page_696" role="doc-pagebreak"></span><code class="calibre21">vector&lt;int&gt; vectorOne(10);</code>
<code class="calibre21">vector&lt;int&gt; vectorTwo(10);</code>
<code class="calibre21"><span class="color">// BUG! Possible infinite loop.</span></code>
<code class="calibre21">for (auto iter { begin(<b class="calibre14">vectorTwo</b>) }; iter != end(<b class="calibre14">vectorOne</b>); ++iter) { <span class="color">/* … */</span> }</code></pre>
         <section class="calibre2">
          <aside class="calibre23">
           <div class="top">
            <hr class="calibre24"/>
           </div>
           <section class="feature">
            <p class="calibre25" id="c18-para-0092">
             <b class="calibre14">
              NOTE
             </b>
             <i class="calibre18">
              Microsoft Visual C++, by default, gives an assertion error at run time for both of the preceding problems when running a debug build of your program. By default, no verification of iterators is performed for release builds. You can enable it for release builds as well, but it has a performance penalty
             </i>
             .
            </p>
            <div class="top">
             <hr class="calibre24"/>
            </div>
           </section>
          </aside>
         </section>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0032">
         </span>
         <h6 class="calibre35" id="head-6-4">
          Other Iterator Operations
         </h6>
         <p class="calibre13">
          The
          <code class="calibre21">
           vector
          </code>
          iterator is random access, which means you can move it backward and forward, and jump around. For example, the following code eventually changes the fifth element (index
          <code class="calibre21">
           4
          </code>
          ) to the value
          <code class="calibre21">
           4
          </code>
          :
         </p>
         <pre class="calibre26" id="c18-code-0040"><code class="calibre21">vector&lt;int&gt; intVector(10);</code>
<code class="calibre21">auto it { begin(intVector) };</code>
<code class="calibre21">it += 5;</code>
<code class="calibre21">--it;</code>
<code class="calibre21">*it = 4;</code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0033">
         </span>
         <h6 class="calibre35" id="head-6-5">
          Iterators vs. Indexing
         </h6>
         <p class="calibre13">
          Given that you can write a
          <code class="calibre21">
           for
          </code>
          loop that uses a simple index variable and the
          <code class="calibre21">
           size()
          </code>
          member function to iterate over the elements of a
          <code class="calibre21">
           vector
          </code>
          , why should you bother using iterators? That's a valid question, for which there are three main answers:
         </p>
         <ul class="check" id="c18-list-0005">
          <li class="calibre9" id="c18-li-0035">
           Iterators allow you to insert and delete elements and sequences of elements at any point in the container. See the section “
           <a class="calibre5" href="c18_split_000.xhtml#c18-sec-0035">
            Adding and Removing Elements
           </a>
           ” later in this chapter.
          </li>
          <li class="calibre9" id="c18-li-0036">
           Iterators allow you to use the Standard Library algorithms, which are discussed in
           <a class="calibre5" href="c20.xhtml">
            Chapter 20
           </a>
           , “Mastering Standard Library Algorithms.”
          </li>
          <li class="calibre9" id="c18-li-0037">
           Using an iterator to access each element sequentially is often more efficient than indexing the container to retrieve each element individually. This generalization is not true for
           <code class="calibre21">
            vector
           </code>
           s, but applies to
           <code class="calibre21">
            list
           </code>
           s,
           <code class="calibre21">
            map
           </code>
           s, and
           <code class="calibre21">
            set
           </code>
           s.
          </li>
         </ul>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0034">
        </span>
        <h5 class="calibre35" id="head-5-115">
         Storing References in a vector
        </h5>
        <p class="calibre13">
         As mentioned earlier in this chapter, it is possible to store references in a container, such as a
         <code class="calibre21">
          vector
         </code>
         . To do this, you store
         <code class="calibre21">
          std::reference:wrapper
         </code>
         s in the container. The
         <code class="calibre21">
          std::ref()
         </code>
         and
         <code class="calibre21">
          cref()
         </code>
         function templates are used to create non-
         <code class="calibre21">
          const
         </code>
         and
         <code class="calibre21">
          const reference:wrapper
         </code>
         instances. The
         <code class="calibre21">
          get()
         </code>
         member function is used to get access to the object wrapped by a
         <code class="calibre21">
          reference:wrapper
         </code>
         . All this is defined in
         <code class="calibre21">
          &lt;functional&gt;
         </code>
         . Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0041"><code class="calibre21">string str1 { "Hello" };</code>
<code class="calibre21">string str2 { "World" };</code>
<code class="calibre21"> </code>
<span aria-label="697" class="calibre20" epub:type="pagebreak" id="Page_697" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Create a vector of references to strings.</span></code>
<code class="calibre21">vector&lt;reference:wrapper&lt;string&gt;&gt; vec { ref(str1) };</code>
<code class="calibre21">vec.push_back(ref(str2));  <span class="color">// push_back() works as well.</span></code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Modify the string referred to by the second reference in the vector.</span></code>
<code class="calibre21">vec[1].get() += "!";</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// The end result is that str2 is modified.</span></code>
<code class="calibre21">println("{} {}", str1, str2);</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0035">
        </span>
        <h5 class="calibre35" id="head-5-116">
         Adding and Removing Elements
        </h5>
        <p class="calibre13">
         As you already know, you can append an element to a
         <code class="calibre21">
          vector
         </code>
         with the
         <code class="calibre21">
          push_back()
         </code>
         member function. The
         <code class="calibre21">
          vector
         </code>
         provides a corresponding remove member function called
         <code class="calibre21">
          pop_back()
         </code>
         .
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0097">
            <b class="calibre14">
             WARNING
            </b>
            <code class="calibre21">
             pop_back()
            </code>
            <i class="calibre18">
             does not return the element that is removed. If you want that element, you must first retrieve it with
            </i>
            <code class="calibre21">
             back()
            </code>
            <i class="calibre18">
             .
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         You can also insert elements at any point in the
         <code class="calibre21">
          vector
         </code>
         with the
         <code class="calibre21">
          insert()
         </code>
         member function, which adds one or more elements to a position specified by an iterator, shifting all subsequent elements down to make room for the new ones. There are five different overloads of
         <code class="calibre21">
          insert()
         </code>
         that do the following:
        </p>
        <ul class="check" id="c18-list-0006">
         <li class="calibre9" id="c18-li-0038">
          Insert a single element.
         </li>
         <li class="calibre9" id="c18-li-0039">
          Insert
          <i class="calibre18">
           n
          </i>
          copies of a single element.
         </li>
         <li class="calibre9" id="c18-li-0040">
          Insert elements from an iterator range. Recall that the iterator range is half-open, such that it includes the element referred to by the starting iterator but not the one referred to by the ending iterator.
         </li>
         <li class="calibre9" id="c18-li-0041">
          Insert a single element by moving the given element to a
          <code class="calibre21">
           vector
          </code>
          using move semantics.
         </li>
         <li class="calibre9" id="c18-li-0042">
          Insert a list of elements into a
          <code class="calibre21">
           vector
          </code>
          where the list of elements is given as an
          <code class="calibre21">
           initializer_list
          </code>
          .
          <section class="calibre2">
           <aside class="calibre23">
            <div class="top">
             <hr class="calibre24"/>
            </div>
            <section class="feature">
             <p class="calibre25" id="c18-para-0100">
              <b class="calibre14">
               NOTE
              </b>
              <i class="calibre18">
               There are overloads of
              </i>
              <code class="calibre21">
               push_back()
              </code>
              <i class="calibre18">
               and
              </i>
              <code class="calibre21">
               insert()
              </code>
              <i class="calibre18">
               that take an lvalue or an rvalue as a parameter. Both overloads allocate memory as needed to store the new elements. The lvalue overloads store copies of the given elements, while the rvalue overloads use move semantics to move ownership of the given elements to the
              </i>
              <code class="calibre21">
               vector
              </code>
              <i class="calibre18">
               instead of copying them.
              </i>
             </p>
             <div class="top">
              <hr class="calibre24"/>
             </div>
            </section>
           </aside>
          </section>
         </li>
        </ul>
        <p class="calibre13" id="c18-para-0102">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         C++23 adds the following member functions:
         <code class="calibre21">
          assign_range()
         </code>
         to replace all elements in a
         <code class="calibre21">
          vector
         </code>
         with the elements of a given range,
         <code class="calibre21">
          insert_range()
         </code>
         to insert all elements of a given range into a
         <code class="calibre21">
          vector
         </code>
         at a given position, and
         <code class="calibre21">
          append_range()
         </code>
         to append all elements of a given range to the end of a
         <code class="calibre21">
          vector
         </code>
         .
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         discusses ranges in detail.
        </p>
        <p class="calibre13" id="c18-para-0103">
         <span aria-label="698" class="calibre20" epub:type="pagebreak" id="Page_698" role="doc-pagebreak">
         </span>
         You can remove elements from any point in a
         <code class="calibre21">
          vector
         </code>
         with
         <code class="calibre21">
          erase()
         </code>
         , and you can remove all elements with
         <code class="calibre21">
          clear()
         </code>
         . There are two overloads of
         <code class="calibre21">
          erase()
         </code>
         : one accepting a single iterator to remove a single element, and one accepting two iterators specifying a range of elements to remove.
        </p>
        <p class="calibre13">
         Let's look at an example program that demonstrates some of the member functions for adding and removing elements. The following code snippet demonstrates
         <code class="calibre21">
          clear()
         </code>
         ,
         <code class="calibre21">
          push_back()
         </code>
         ,
         <code class="calibre21">
          pop_back()
         </code>
         , the C++23
         <code class="calibre21">
          append_range()
         </code>
         , the two-argument version of
         <code class="calibre21">
          erase()
         </code>
         , and the following overloads of
         <code class="calibre21">
          insert()
         </code>
         :
        </p>
        <ul class="check" id="c18-list-0007">
         <li class="calibre9" id="c18-li-0043">
          <b class="calibre14">
           <code class="calibre21">
            insert(const_iterator pos, const T&amp; x)
           </code>
           :
          </b>
          The value
          <code class="calibre21">
           x
          </code>
          is inserted at position
          <code class="calibre21">
           pos
          </code>
          .
         </li>
         <li class="calibre9" id="c18-li-0044">
          <b class="calibre14">
           <code class="calibre21">
            insert(const_iterator pos, size_type n, const T&amp; x)
           </code>
           :
          </b>
          The value
          <code class="calibre21">
           x
          </code>
          is inserted
          <code class="calibre21">
           n
          </code>
          times at position
          <code class="calibre21">
           pos
          </code>
          .
         </li>
         <li class="calibre9" id="c18-li-0045">
          <b class="calibre14">
           <code class="calibre21">
            insert(const_iterator pos, InputIterator first, InputIterator last)
           </code>
           :
          </b>
          The elements in the range
          <code class="calibre21">
           [first, last)
          </code>
          are inserted at position
          <code class="calibre21">
           pos
          </code>
          .
         </li>
        </ul>
        <p class="calibre13">
         Here is the code snippet:
        </p>
        <pre class="calibre26" id="c18-code-0042"><code class="calibre21">vector vectorOne { 1, 2, 3, 5 };</code>
<code class="calibre21">vector&lt;int&gt; vectorTwo;</code>
<code class="calibre21">println("{:n}", vectorOne);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Oops, we forgot to add 4. Insert it in the correct place.</span></code>
<code class="calibre21">vectorOne.insert(cbegin(vectorOne) + 3, 4);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Add elements 6 through 10 to vectorTwo.</span></code>
<code class="calibre21">for (int i { 6 }; i &lt;= 10; ++i) {</code>
<code class="calibre21">    vectorTwo.push_back(i);</code>
<code class="calibre21">}</code>
<code class="calibre21">println("{:n}", vectorOne);</code>
<code class="calibre21">println("{:n}", vectorTwo);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Add all elements from vectorTwo to the end of vectorOne.</span></code>
<code class="calibre21">vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));</code>
<code class="calibre21">println("{:n}", vectorOne);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Add all vectorTwo elements to the end of vectorOne using C++23 append_range().</span></code>
<code class="calibre21"><span class="color">// Note how much clearer this is compared to the previous call to insert().</span></code>
<code class="calibre21">vectorOne.append_range(vectorTwo);</code>
<code class="calibre21">println("{:n}", vectorOne);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Now erase the numbers 2 through 5 in vectorOne.</span></code>
<code class="calibre21">vectorOne.erase(cbegin(vectorOne) + 1, cbegin(vectorOne) + 5);</code>
<code class="calibre21">println("{:n}", vectorOne);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Clear vectorTwo entirely.</span></code>
<code class="calibre21">vectorTwo.clear();</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// And add 10 copies of the value 100.</span></code>
<code class="calibre21">vectorTwo.insert(cbegin(vectorTwo), 10, 100);</code>
<code class="calibre21">println("{:n}", vectorTwo);</code>
<code class="calibre21"> </code>
<span aria-label="699" class="calibre20" epub:type="pagebreak" id="Page_699" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Decide we only want 9 elements.</span></code>
<code class="calibre21">vectorTwo.pop_back();</code>
<code class="calibre21">println("{:n}", vectorTwo);</code></pre>
        <p class="calibre13">
         The output of the program is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0043"><code class="calibre21">1, 2, 3, 5</code>
<code class="calibre21">1, 2, 3, 4, 5</code>
<code class="calibre21">6, 7, 8, 9, 10</code>
<code class="calibre21">1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10</code>
<code class="calibre21">1, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10</code>
<code class="calibre21">100, 100, 100, 100, 100, 100, 100, 100, 100, 100</code>
<code class="calibre21">100, 100, 100, 100, 100, 100, 100, 100, 100</code></pre>
        <p class="calibre13">
         Recall that iterator pairs represent half-open ranges, and
         <code class="calibre21">
          insert()
         </code>
         adds elements before the element referred to by a given iterator position. Thus, you can insert the entire contents of
         <code class="calibre21">
          vectorTwo
         </code>
         at the end of
         <code class="calibre21">
          vectorOne
         </code>
         , like this:
        </p>
        <pre class="calibre26" id="c18-code-0044"><code class="calibre21">vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0109">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Member functions such as
            </i>
            <code class="calibre21">
             insert()
            </code>
            <i class="calibre18">
             and
            </i>
            <code class="calibre21">
             erase()
            </code>
            <i class="calibre18">
             that take a common iterator range as argument assume that the beginning and ending iterators refer to elements in the same container and that the end iterator refers to an element at or past the begin iterator. The member functions will not work correctly if these preconditions are not met!
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13" id="c18-para-0110">
         If you want to remove all elements satisfying a condition, one solution would be to write a loop iterating over all the elements and erasing every element that matches the condition. However, this solution has quadratic complexity, which is bad for performance. This quadratic complexity can be avoided by using the
         <i class="calibre18">
          remove-erase-idiom
         </i>
         , which has a linear complexity. The remove-erase-idiom is discussed in
         <a class="calibre5" href="c20.xhtml">
          Chapter 20
         </a>
         .
        </p>
        <p class="calibre13">
         Starting with C++20, however, there is a more elegant solution in the form of the
         <code class="calibre21">
          std::erase()
         </code>
         and
         <code class="calibre21">
          std::erase_if()
         </code>
         non-member functions, defined for all Standard Library containers. The former is demonstrated in the following code snippet:
        </p>
        <pre class="calibre26" id="c18-code-0045"><code class="calibre21">vector values { 1, 2, 3, 2, 1, 2, 4, 5 };</code>
<code class="calibre21">println("{:n}", values);</code>
<code class="calibre21"> </code>
<code class="calibre21">erase(values, 2);  <span class="color">// Removes all values equal to 2.</span></code>
<code class="calibre21">println("{:n}", values);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0046"><code class="calibre21">1, 2, 3, 2, 1, 2, 4, 5</code>
<code class="calibre21">1, 3, 1, 4, 5</code></pre>
        <p class="calibre13" id="c18-para-0113">
         <code class="calibre21">
          erase_if()
         </code>
         works similarly, but instead of passing a value as second argument, a predicate is passed that returns
         <code class="calibre21">
          true
         </code>
         for elements that should be removed, and
         <code class="calibre21">
          false
         </code>
         for elements that should be kept.
         <span aria-label="700" class="calibre20" epub:type="pagebreak" id="Page_700" role="doc-pagebreak">
         </span>
         The predicate can take the form of a function pointer, a function object, or a lambda expression, all of which are discussed in detail in
         <a class="calibre5" href="c19.xhtml">
          Chapter 19
         </a>
         , “Function Pointers, Function Objects, and Lambda Expressions.”
        </p>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0039">
         </span>
         <h6 class="calibre35" id="head-6-6">
          Move Semantics
         </h6>
         <p class="calibre13">
          Adding elements to a
          <code class="calibre21">
           vector
          </code>
          can make use of move semantics to improve performance in certain situations. For example, suppose you have the following
          <code class="calibre21">
           vector
          </code>
          of
          <code class="calibre21">
           string
          </code>
          s:
         </p>
         <pre class="calibre26" id="c18-code-0047"><code class="calibre21">vector&lt;string&gt; vec;</code></pre>
         <p class="calibre13">
          You can add an element to this
          <code class="calibre21">
           vector
          </code>
          as follows:
         </p>
         <pre class="calibre26" id="c18-code-0048"><code class="calibre21">string myElement(5, 'a');  <span class="color">// Constructs the string "aaaaa"</span></code>
<code class="calibre21">vec.push_back(myElement);</code></pre>
         <p class="calibre13" id="c18-para-0116">
          However, because
          <code class="calibre21">
           myElement
          </code>
          is not a temporary object,
          <code class="calibre21">
           push_back()
          </code>
          makes a copy of
          <code class="calibre21">
           myElement
          </code>
          and puts it into the
          <code class="calibre21">
           vector
          </code>
          .
         </p>
         <p class="calibre13">
          The
          <code class="calibre21">
           vector
          </code>
          class also defines a
          <code class="calibre21">
           push_back(T&amp;&amp;)
          </code>
          , which is the move equivalent of
          <code class="calibre21">
           push_back(const T&amp;)
          </code>
          . So, copying can be avoided if you call
          <code class="calibre21">
           push_back()
          </code>
          as follows:
         </p>
         <pre class="calibre26" id="c18-code-0049"><code class="calibre21">vec.push_back(move(myElement));</code></pre>
         <p class="calibre13">
          This statement explicitly says that
          <code class="calibre21">
           myElement
          </code>
          should be moved into the
          <code class="calibre21">
           vector
          </code>
          . Note that after this call,
          <code class="calibre21">
           myElement
          </code>
          is in a valid but otherwise indeterminate state. You should not use
          <code class="calibre21">
           myElement
          </code>
          anymore, unless you first bring it back to a determinate state, for example by calling
          <code class="calibre21">
           clear()
          </code>
          on it! You can also call
          <code class="calibre21">
           push_back()
          </code>
          as follows:
         </p>
         <pre class="calibre26" id="c18-code-0050"><code class="calibre21">vec.push_back(string(5, 'a'));</code></pre>
         <p class="calibre13" id="c18-para-0119">
          This call to
          <code class="calibre21">
           push_back()
          </code>
          triggers a call to the move overload because the call to the
          <code class="calibre21">
           string
          </code>
          constructor results in a temporary object. The
          <code class="calibre21">
           push_back()
          </code>
          member function moves this temporary
          <code class="calibre21">
           string
          </code>
          object into the
          <code class="calibre21">
           vector
          </code>
          , avoiding any copying.
         </p>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0040">
         </span>
         <h6 class="calibre35" id="head-6-7">
          Emplace Operations
         </h6>
         <p class="calibre13">
          C++ supports
          <i class="calibre18">
           emplace operations
          </i>
          on most Standard Library containers, including
          <code class="calibre21">
           vector
          </code>
          . Emplace means “to put into place.” An example is the
          <code class="calibre21">
           emplace:back()
          </code>
          member function of
          <code class="calibre21">
           vector
          </code>
          , which does not copy or move anything. Instead, it makes space in the container and constructs the object
          <i class="calibre18">
           in place
          </i>
          , as in this example:
         </p>
         <pre class="calibre26" id="c18-code-0051"><code class="calibre21">vec.emplace:back(5, 'a');</code></pre>
         <p class="calibre13">
          The emplace member functions take a variable number of arguments as a variadic template. Variadic templates are discussed in
          <a class="calibre5" href="c26.xhtml">
           Chapter 26
          </a>
          , “Advanced Templates,” but those details are not required to understand how to use
          <code class="calibre21">
           emplace:back()
          </code>
          . Basically, the arguments passed to
          <code class="calibre21">
           emplace:back()
          </code>
          are forwarded to a constructor of the type stored in the
          <code class="calibre21">
           vector
          </code>
          . The difference in performance between
          <code class="calibre21">
           emplace:back()
          </code>
          and
          <code class="calibre21">
           push_back()
          </code>
          using move semantics depends on how your specific compiler implements these operations. In most situations, you can pick the one based on the syntax that you prefer:
         </p>
         <pre class="calibre26" id="c18-code-0052"><code class="calibre21">vec.push_back(string(5, 'a'));</code>
<code class="calibre21"><span class="color">// Or</span></code>
<code class="calibre21">vec.emplace:back(5, 'a');</code></pre>
         <p class="calibre13" id="c18-para-0122">
          <span aria-label="701" class="calibre20" epub:type="pagebreak" id="Page_701" role="doc-pagebreak">
          </span>
          The
          <code class="calibre21">
           emplace:back()
          </code>
          member function returns a reference to the inserted element. There is also an
          <code class="calibre21">
           emplace()
          </code>
          member function that constructs an object in place at a specific position in the
          <code class="calibre21">
           vector
          </code>
          and returns an iterator to the inserted element.
         </p>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0041">
         </span>
         <h6 class="calibre35" id="head-6-8">
          Algorithmic Complexity and Iterator Invalidation
         </h6>
         <p class="calibre13" id="c18-para-0123">
          Inserting or erasing elements in a
          <code class="calibre21">
           vector
          </code>
          causes all subsequent elements to shift up or down to make room for, or fill in the holes left by, the affected elements. Thus, these operations take linear complexity. Furthermore, all iterators referring to the insertion or removal point or subsequent positions are invalid following the action. The iterators are not “magically” moved to keep up with the elements that are shifted up or down in the
          <code class="calibre21">
           vector
          </code>
          —that's up to you.
         </p>
         <p class="calibre13" id="c18-para-0124">
          Also keep in mind that an internal
          <code class="calibre21">
           vector
          </code>
          reallocation can cause invalidation of all iterators referring to elements in the
          <code class="calibre21">
           vector
          </code>
          , not just those referring to elements past the point of insertion or deletion. See the next section for details.
         </p>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0042">
        </span>
        <h5 class="calibre35" id="head-5-117">
         The vector Memory Allocation Scheme
        </h5>
        <p class="calibre13" id="c18-para-0125">
         A
         <code class="calibre21">
          vector
         </code>
         allocates memory automatically to store the elements that you insert. Recall that the
         <code class="calibre21">
          vector
         </code>
         requirements dictate that the elements must be in contiguous memory, like in standard C-style arrays. Because it's impossible to request to add memory to the end of a current chunk of memory, every time a
         <code class="calibre21">
          vector
         </code>
         allocates more memory, it must allocate a new, larger chunk in a separate memory location and copy/move all the elements to the new chunk. This process is time-consuming, so
         <code class="calibre21">
          vector
         </code>
         implementations attempt to avoid it by allocating more space than needed when they have to perform a reallocation. That way, they can avoid reallocating memory every time you insert an element.
        </p>
        <p class="calibre13">
         One obvious question at this point is why you, as a client of
         <code class="calibre21">
          vector
         </code>
         , care how it manages its memory internally. You might think that the principle of abstraction should allow you to disregard the internals of the
         <code class="calibre21">
          vector
         </code>
         memory allocation scheme. Unfortunately, there are two reasons why you need to understand how it works:
        </p>
        <ul class="check" id="c18-list-0008">
         <li class="calibre9" id="c18-li-0046">
          <b class="calibre14">
           Efficiency:
          </b>
          The
          <code class="calibre21">
           vector
          </code>
          allocation scheme can guarantee that an element insertion runs in
          <i class="calibre18">
           amortized constant time
          </i>
          : most of the time the operation is constant, but once in a while (if it requires a reallocation), it's linear. If you are worried about efficiency, you can control when a
          <code class="calibre21">
           vector
          </code>
          performs reallocations.
         </li>
         <li class="calibre9" id="c18-li-0047">
          <b class="calibre14">
           Iterator invalidations:
          </b>
          A reallocation invalidates all iterators referring to elements in a
          <code class="calibre21">
           vector
          </code>
          .
         </li>
        </ul>
        <p class="calibre13">
         Thus, the
         <code class="calibre21">
          vector
         </code>
         interface allows you to query and control the
         <code class="calibre21">
          vector
         </code>
         reallocations, both explained in the upcoming subsections.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0128">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             If you don't control the reallocations explicitly, you should assume that all insertions cause a reallocation and thus invalidate all iterators
            </i>
            .
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <span aria-label="702" class="calibre20" epub:type="pagebreak" id="Page_702" role="doc-pagebreak">
        </span>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0044">
         </span>
         <h6 class="calibre35" id="head-6-9">
          Size and Capacity
         </h6>
         <p class="calibre13">
          <code class="calibre21">
           vector
          </code>
          provides two member functions for obtaining information about its size:
          <code class="calibre21">
           size()
          </code>
          and
          <code class="calibre21">
           capacity()
          </code>
          . The
          <code class="calibre21">
           size()
          </code>
          member function returns the number of elements in a
          <code class="calibre21">
           vector
          </code>
          , while
          <code class="calibre21">
           capacity()
          </code>
          returns the number of elements that it can hold without a reallocation. Thus, the number of elements that you can insert without causing a reallocation is
          <code class="calibre21">
           capacity() – size()
          </code>
          .
         </p>
         <section class="calibre2">
          <aside class="calibre23">
           <div class="top">
            <hr class="calibre24"/>
           </div>
           <section class="feature">
            <p class="calibre25" id="c18-para-0130">
             <b class="calibre14">
              NOTE
             </b>
             <i class="calibre18">
              You can query whether a
             </i>
             <code class="calibre21">
              vector
             </code>
             <i class="calibre18">
              is empty with the
             </i>
             <code class="calibre21">
              empty()
             </code>
             <i class="calibre18">
              member function. A
             </i>
             <code class="calibre21">
              vector
             </code>
             <i class="calibre18">
              can be empty but have nonzero capacity.
             </i>
            </p>
            <div class="top">
             <hr class="calibre24"/>
            </div>
           </section>
          </aside>
         </section>
         <p class="calibre13">
          There are also non-member
          <code class="calibre21">
           std::size()
          </code>
          and
          <code class="calibre21">
           std::empty()
          </code>
          global functions, which can be used with all containers. They can also be used with statically allocated C-style arrays not accessed through pointers, and with
          <code class="calibre21">
           initializer_list
          </code>
          s. Here is an example of using them with a
          <code class="calibre21">
           vector
          </code>
          :
         </p>
         <pre class="calibre26" id="c18-code-0053"><code class="calibre21">vector vec { 1, 2, 3 };</code>
<code class="calibre21">println("{}", size(vec));  <span class="color">// 3</span></code>
<code class="calibre21">println("{}", empty(vec)); <span class="color">// false</span></code></pre>
         <p class="calibre13">
          Additionally,
          <code class="calibre21">
           std::ssize()
          </code>
          , a global non-member helper function, returns the size as a signed integral type. Here's an example:
         </p>
         <pre class="calibre26" id="c18-code-0054"><code class="calibre21">auto s1 { size(vec) };   <span class="color">// Type is size_t (unsigned)</span></code>
<code class="calibre21">auto s2 { ssize(vec) };  <span class="color">// Type is long long (signed)</span></code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0046">
         </span>
         <h6 class="calibre35" id="head-6-10">
          Reserving Capacity
         </h6>
         <p class="calibre13" id="c18-para-0133">
          If you don't care about efficiency or iterator invalidations, there is never a need to control the
          <code class="calibre21">
           vector
          </code>
          memory allocation explicitly. However, if you want to make your program as efficient as possible or you want to guarantee that iterators will not be invalidated, you can force a
          <code class="calibre21">
           vector
          </code>
          to preallocate enough space to hold all of its elements. Of course, you need to know how many elements it will hold, which is sometimes impossible to predict.
         </p>
         <p class="calibre13">
          One way to preallocate space is to call
          <code class="calibre21">
           reserve()
          </code>
          , which allocates enough memory to hold the specified number of elements. The upcoming round-robin class example shows the
          <code class="calibre21">
           reserve()
          </code>
          member function in action.
         </p>
         <section class="calibre2">
          <aside class="calibre23">
           <div class="top">
            <hr class="calibre24"/>
           </div>
           <section class="feature">
            <p class="calibre25" id="c18-para-0135">
             <b class="calibre14">
              WARNING
             </b>
             <i class="calibre18">
              Reserving space for elements changes the capacity, but not the size. That is, it doesn't actually create elements. Don't access elements past a
             </i>
             <code class="calibre21">
              vector
             </code>
             <i class="calibre18">
              '
             </i>
             s
             <i class="calibre18">
              size
             </i>
             .
            </p>
            <div class="top">
             <hr class="calibre24"/>
            </div>
           </section>
          </aside>
         </section>
         <p class="calibre13" id="c18-para-0136">
          Another way to preallocate space is to specify, in the constructor, or with the
          <code class="calibre21">
           resize()
          </code>
          or
          <code class="calibre21">
           assign()
          </code>
          member function, how many elements you want a
          <code class="calibre21">
           vector
          </code>
          to store. This member function actually creates a
          <code class="calibre21">
           vector
          </code>
          of that size (and probably of that capacity).
         </p>
        </section>
        <span aria-label="703" class="calibre20" epub:type="pagebreak" id="Page_703" role="doc-pagebreak">
        </span>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0048">
         </span>
         <h6 class="calibre35" id="head-6-11">
          Reclaiming All Memory
         </h6>
         <p class="calibre13" id="c18-para-0137">
          A
          <code class="calibre21">
           vector
          </code>
          automatically allocates more memory if needed; however, it will never release any memory, unless the
          <code class="calibre21">
           vector
          </code>
          is destroyed. Removing elements from a
          <code class="calibre21">
           vector
          </code>
          decreases the size of the
          <code class="calibre21">
           vector
          </code>
          , but never its capacity. How then can you reclaim its memory?
         </p>
         <p class="calibre13" id="c18-para-0138">
          One option is to use the
          <code class="calibre21">
           shrink_to_fit()
          </code>
          member function, which requests a
          <code class="calibre21">
           vector
          </code>
          to reduce its capacity to its size. However, it's just a request, and a Standard Library implementation is allowed to ignore this request.
         </p>
         <p class="calibre13">
          Reclaiming
          <b class="calibre14">
           all
          </b>
          memory of a
          <code class="calibre21">
           vector
          </code>
          can be done using the following trick: swap the
          <code class="calibre21">
           vector
          </code>
          with an empty one. The following code snippet shows how memory of a
          <code class="calibre21">
           vector
          </code>
          called
          <code class="calibre21">
           values
          </code>
          can be reclaimed with a single statement. The third line of code constructs a temporary empty default-constructed
          <code class="calibre21">
           vector
          </code>
          of the same type as
          <code class="calibre21">
           values
          </code>
          and swaps this with
          <code class="calibre21">
           values
          </code>
          . All memory that was allocated for
          <code class="calibre21">
           values
          </code>
          now belongs to this temporary
          <code class="calibre21">
           vector
          </code>
          , which is automatically destroyed at the end of that statement freeing all its memory. The end result is that all memory that was allocated for
          <code class="calibre21">
           values
          </code>
          is reclaimed, and
          <code class="calibre21">
           values
          </code>
          is left with a capacity of zero.
         </p>
         <pre class="calibre26" id="c18-code-0055"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21"><span class="color">// Populate values …</span></code>
<code class="calibre21">vector&lt;int&gt;().swap(values);</code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0049">
         </span>
         <h6 class="calibre35" id="head-6-12">
          Directly Accessing the Data
         </h6>
         <p class="calibre13" id="c18-para-0140">
          A
          <code class="calibre21">
           vector
          </code>
          stores its data contiguously in memory. You can get a pointer to this block of memory with the
          <code class="calibre21">
           data()
          </code>
          member function.
         </p>
         <p class="calibre13">
          There is also a non-member
          <code class="calibre21">
           std::data()
          </code>
          function that can be used to get a pointer to the data. It works for the
          <code class="calibre21">
           array
          </code>
          and
          <code class="calibre21">
           vector
          </code>
          containers,
          <code class="calibre21">
           string
          </code>
          s, statically allocated C-style arrays not accessed through pointers, and
          <code class="calibre21">
           initializer_list
          </code>
          s. Here is an example for a
          <code class="calibre21">
           vector
          </code>
          :
         </p>
         <pre class="calibre26" id="c18-code-0056"><code class="calibre21">vector vec { 1, 2, 3 };</code>
<code class="calibre21">int* data1 { vec.data() };</code>
<code class="calibre21">int* data2 { data(vec) };</code></pre>
         <p class="calibre13" id="c18-para-0142">
          Another way to get access to the memory block of a
          <code class="calibre21">
           vector
          </code>
          is by taking the address of the first element, as in:
          <code class="calibre21">
           &amp;vec[0]
          </code>
          . You might find this kind of code in legacy code bases, but it is not safe for empty
          <code class="calibre21">
           vector
          </code>
          s; as such, I recommend not to use it and instead use
          <code class="calibre21">
           data()
          </code>
          .
         </p>
        </section>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0050">
       </span>
       <h4 class="calibre29" id="head-4-281">
        Move Semantics
       </h4>
       <p class="calibre13">
        All Standard Library containers support move semantics by including a move constructor and move assignment operator. See
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        for details on move semantics. Standard Library containers can be returned from functions
        <i class="calibre18">
         by value
        </i>
        without performance penalty. Take a look at the following function:
       </p>
       <pre class="calibre26" id="c18-code-0057"><code class="calibre21">vector&lt;int&gt; createVectorOfSize(size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;int&gt; vec(size);</code>
<code class="calibre21">    for (int contents { 0 }; auto&amp; i : vec) { i = contents++; }</code>
<code class="calibre21">    return vec;</code>
<code class="calibre21">}</code>
<code class="calibre21">…</code>
<code class="calibre21">vector&lt;int&gt; myVector;</code>
<code class="calibre21">myVector = createVectorOfSize(123);</code></pre>
       <p class="calibre13" id="c18-para-0144">
        <span aria-label="704" class="calibre20" epub:type="pagebreak" id="Page_704" role="doc-pagebreak">
        </span>
        Without move semantics, assigning the result of
        <code class="calibre21">
         createVectorOfSize()
        </code>
        to
        <code class="calibre21">
         myVector
        </code>
        might call the copy assignment operator. With the move semantics support in the Standard Library containers, copying of the
        <code class="calibre21">
         vector
        </code>
        is avoided. Instead, the assignment to
        <code class="calibre21">
         myVector
        </code>
        triggers a call to the move assignment operator.
       </p>
       <p class="calibre13" id="c18-para-0145">
        Keep in mind, though, that for move semantics to work properly with Standard Library containers, the move constructor and move assignment operator of the type stored in the container must be marked as
        <code class="calibre21">
         noexcept
        </code>
        ! Why are these move member functions not allowed to throw any exceptions? Imagine that they are allowed to throw exceptions. Now, when adding, for example, new elements to a
        <code class="calibre21">
         vector
        </code>
        , it might be that the capacity of the
        <code class="calibre21">
         vector
        </code>
        is not sufficient and that it needs to allocate a bigger block of memory. Subsequently, the
        <code class="calibre21">
         vector
        </code>
        must either copy or move all the data from the original memory block to the new one. If this would be done using a move member function that can potentially throw, then it might happen that an exception gets thrown when part of the data has already been moved to the new memory block. What can we do then? Not much. To avoid these kinds of problems, Standard Library containers will only use move member functions if they guarantee not to throw any exceptions. If they are not marked
        <code class="calibre21">
         noexcept
        </code>
        , the copy member functions will be used instead to guarantee strong exception safety.
       </p>
       <p class="calibre13" id="c18-para-0146">
        When implementing your own Standard Library–like containers, there is a useful helper function available called
        <code class="calibre21">
         std::move_if_noexcept()
        </code>
        , defined in
        <code class="calibre21">
         &lt;utility&gt;
        </code>
        . This can be used to call either the move constructor or the copy constructor depending on whether the move constructor is
        <code class="calibre21">
         noexcept
        </code>
        . In itself,
        <code class="calibre21">
         move_if_noexcept()
        </code>
        doesn't do much. It accepts a reference as a parameter and converts it to either an rvalue reference if the move constructor is
        <code class="calibre21">
         noexcept
        </code>
        or to a reference-to-
        <code class="calibre21">
         const
        </code>
        otherwise, but this simple trick allows you to call the correct constructor with a single call.
       </p>
       <p class="calibre13" id="c18-para-0147">
        The Standard Library does not provide a similar helper function to call the move assignment operator or copy assignment operator depending on whether the former is
        <code class="calibre21">
         noexcept
        </code>
        . Implementing one yourself is not too complicated, but requires some template metaprogramming techniques and type traits to inspect properties of types. Both topics are discussed in
        <a class="calibre5" href="c26.xhtml">
         Chapter 26
        </a>
        , which also gives an example of implementing your own
        <code class="calibre21">
         move_assign_if_noexcept()
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0051">
       </span>
       <h4 class="calibre29" id="head-4-282">
        vector Example: A Round-Robin Class
       </h4>
       <p class="calibre13" id="c18-para-0148">
        A common problem in computer science is distributing requests among a finite list of resources. For example, a simple operating system could keep a list of processes and assign a time slice (such as 100ms) to each process to let the process perform some of its work. After the time slice is finished, the OS suspends the process, and the next process in the list is given a time slice to perform some of its work. One of the simplest algorithmic solutions to this problem is
        <i class="calibre18">
         round-robin scheduling
        </i>
        . When the time slice of the last process is finished, the scheduler starts over again with the first process. For example, in the case of three processes, the first-time slice would go to the first process, the second slice to the second process, the third slice to the third process, and the fourth slice back to the first process. The cycle would continue in this way indefinitely.
       </p>
       <p class="calibre13">
        Suppose that you decide to write a generic round-robin scheduling class that can be used with any type of resource. The class should support adding and removing resources and should support cycling through the resources to obtain the next one. You could use a
        <code class="calibre21">
         vector
        </code>
        directly, but it's often helpful to write a wrapper class that provides more directly the functionality you need for your specific application. The following example shows a
        <code class="calibre21">
         RoundRobin
        </code>
        class template with comments explaining the code.
        <span aria-label="705" class="calibre20" epub:type="pagebreak" id="Page_705" role="doc-pagebreak">
        </span>
        First, here is the class definition, exported from a module called
        <code class="calibre21">
         round_robin
        </code>
        :
       </p>
       <pre class="calibre26" id="c18-code-0058"><code class="calibre21">export module round_robin;</code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Class template RoundRobin</span></code>
<code class="calibre21"><span class="color">// Provides simple round-robin semantics for a list of elements.</span></code>
<code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class RoundRobin final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Client can give a hint as to the number of expected elements for</span></code>
<code class="calibre21">        <span class="color">// increased efficiency.</span></code>
<code class="calibre21">        explicit RoundRobin(std::size_t numExpected = 0);</code>
<code class="calibre21">        <span class="color">// Prevent copy construction and copy assignment</span></code>
<code class="calibre21">        RoundRobin(const RoundRobin&amp; src) = delete;</code>
<code class="calibre21">        RoundRobin&amp; operator=(const RoundRobin&amp; rhs) = delete;</code>
<code class="calibre21">        <span class="color">// Explicitly default a move constructor and move assignment operator</span></code>
<code class="calibre21">        RoundRobin(RoundRobin&amp;&amp; src) noexcept = default;</code>
<code class="calibre21">        RoundRobin&amp; operator=(RoundRobin&amp;&amp; rhs) noexcept = default;</code>
<code class="calibre21">        <span class="color">// Appends element to the end of the list. May be called</span></code>
<code class="calibre21">        <span class="color">// between calls to getNext().</span></code>
<code class="calibre21">        void add(const T&amp; element);</code>
<code class="calibre21">        <span class="color">// Removes the first (and only the first) element</span></code>
<code class="calibre21">        <span class="color">// in the list that is equal (with operator==) to element.</span></code>
<code class="calibre21">        <span class="color">// May be called between calls to getNext().</span></code>
<code class="calibre21">        void remove(const T&amp; element);</code>
<code class="calibre21">        <span class="color">// Returns the next element in the list, starting with the first,</span></code>
<code class="calibre21">        <span class="color">// and cycling back to the first when the end of the list is</span></code>
<code class="calibre21">        <span class="color">// reached, taking into account elements that are added or removed.</span></code>
<code class="calibre21">        T&amp; getNext();</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::vector&lt;T&gt; m_elements;</code>
<code class="calibre21">        typename std::vector&lt;T&gt;::iterator m_nextElement;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c18-para-0150">
        As you can see, the public interface is straightforward: only three member functions plus the constructor. The resources are stored in a
        <code class="calibre21">
         vector
        </code>
        called
        <code class="calibre21">
         m_elements
        </code>
        . The iterator
        <code class="calibre21">
         m_nextElement
        </code>
        always refers to the element that will be returned with the next call to
        <code class="calibre21">
         getNext()
        </code>
        . If
        <code class="calibre21">
         getNext()
        </code>
        hasn't been called yet,
        <code class="calibre21">
         m_nextElement
        </code>
        is equal to
        <code class="calibre21">
         begin(m_elements)
        </code>
        . Note the use of the
        <code class="calibre21">
         typename
        </code>
        keyword in front of the line declaring
        <code class="calibre21">
         m_nextElement
        </code>
        . So far, you've only seen that keyword used to specify template type parameters, but there is another use for it. You must specify
        <code class="calibre21">
         typename
        </code>
        explicitly whenever you access a type based on one or more template parameters. In this case, the template parameter
        <code class="calibre21">
         T
        </code>
        is used to access the
        <code class="calibre21">
         iterator
        </code>
        type. Thus, you must specify
        <code class="calibre21">
         typename
        </code>
        .
       </p>
       <p class="calibre13" id="c18-para-0151">
        The class also prevents copy construction and copy assignment because of the
        <code class="calibre21">
         m_nextElement
        </code>
        data member. To make copy construction and copy assignment work, you would have to implement an assignment operator and copy constructor and make sure
        <code class="calibre21">
         m_nextElement
        </code>
        is valid in the destination object.
       </p>
       <p class="calibre13">
        The implementation of the
        <code class="calibre21">
         RoundRobin
        </code>
        class follows with comments explaining the code. Note the use of
        <code class="calibre21">
         reserve()
        </code>
        in the constructor, and the extensive use of iterators in
        <code class="calibre21">
         add()
        </code>
        ,
        <code class="calibre21">
         remove()
        </code>
        , and
        <span aria-label="706" class="calibre20" epub:type="pagebreak" id="Page_706" role="doc-pagebreak">
        </span>
        <code class="calibre21">
         getNext()
        </code>
        . The trickiest aspect is handling
        <code class="calibre21">
         m_nextElement
        </code>
        in the
        <code class="calibre21">
         add()
        </code>
        and
        <code class="calibre21">
         remove()
        </code>
        member functions.
       </p>
       <pre class="calibre26" id="c18-code-0059"><code class="calibre21">template &lt;typename T&gt; RoundRobin&lt;T&gt;::RoundRobin(std::size_t numExpected)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// If the client gave a guideline, reserve that much space.</span></code>
<code class="calibre21">    m_elements.reserve(numExpected);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Initialize m_nextElement even though it isn't used until</span></code>
<code class="calibre21">    <span class="color">// there's at least one element.</span></code>
<code class="calibre21">    m_nextElement = begin(m_elements);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Always add the new element at the end.</span></code>
<code class="calibre21">template &lt;typename T&gt; void RoundRobin&lt;T&gt;::add(const T&amp; element)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Even though we add the element at the end, the vector could</span></code>
<code class="calibre21">    <span class="color">// reallocate and invalidate the m_nextElement iterator with</span></code>
<code class="calibre21">    <span class="color">// the push_back() call. Take advantage of the random-access</span></code>
<code class="calibre21">    <span class="color">// iterator features to save our spot.</span></code>
<code class="calibre21">    <span class="color">// Note: ptrdiff_t is a type capable of storing the difference</span></code>
<code class="calibre21">    <span class="color">//       between two random-access iterators.</span></code>
<code class="calibre21">    std::ptrdiff_t pos { m_nextElement - begin(m_elements) };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Add the element.</span></code>
<code class="calibre21">    m_elements.push_back(element);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Reset our iterator to make sure it is valid.</span></code>
<code class="calibre21">    m_nextElement = begin(m_elements) + pos;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; void RoundRobin&lt;T&gt;::remove(const T&amp; element)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto it { begin(m_elements) }; it != end(m_elements); ++it) {</code>
<code class="calibre21">        if (*it == element) {</code>
<code class="calibre21">            <span class="color">// Removing an element invalidates the m_nextElement iterator</span></code>
<code class="calibre21">            <span class="color">// if it refers to an element past the point of the removal.</span></code>
<code class="calibre21">            <span class="color">// Take advantage of the random-access features of the iterator</span></code>
<code class="calibre21">            <span class="color">// to track the position of the current element after removal.</span></code>
<code class="calibre21">            std::ptrdiff_t newPos;</code>
<code class="calibre21"> </code>
<code class="calibre21">            if (m_nextElement == end(m_elements) - 1 &amp;&amp;</code>
<code class="calibre21">                m_nextElement == it) {</code>
<code class="calibre21">                <span class="color">// m_nextElement refers to the last element in the list,</span></code>
<code class="calibre21">                <span class="color">// and we are removing that last element, so wrap back to</span></code>
<code class="calibre21">                <span class="color">// the beginning.</span></code>
<code class="calibre21">                newPos = 0;</code>
<code class="calibre21">            } else if (m_nextElement &lt;= it) {</code>
<code class="calibre21">                <span class="color">// Otherwise, if m_nextElement is before or at the one</span></code>
<code class="calibre21">                <span class="color">// we're removing, the new position is the same as before.</span></code>
<code class="calibre21">                newPos = m_nextElement - begin(m_elements);</code>
<code class="calibre21">            } else {</code>
<code class="calibre21">                <span class="color">// Otherwise, it's one less than before.</span></code>
<code class="calibre21">                newPos = m_nextElement - begin(m_elements) - 1;</code>
<code class="calibre21">            }</code>
<code class="calibre21"> </code>
<span aria-label="707" class="calibre20" epub:type="pagebreak" id="Page_707" role="doc-pagebreak"></span><code class="calibre21">            <span class="color">// Erase the element (and ignore the return value).</span></code>
<code class="calibre21">            m_elements.erase(it);</code>
<code class="calibre21"> </code>
<code class="calibre21">            <span class="color">// Now reset our iterator to make sure it is valid.</span></code>
<code class="calibre21">            m_nextElement = begin(m_elements) + newPos;</code>
<code class="calibre21"> </code>
<code class="calibre21">            return;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; T&amp; RoundRobin&lt;T&gt;::getNext()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// First, make sure there are elements.</span></code>
<code class="calibre21">    if (m_elements.empty()) {</code>
<code class="calibre21">        throw std::out_of_range { "No elements in the list" };</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Store the current element which we need to return.</span></code>
<code class="calibre21">    auto&amp; toReturn { *m_nextElement };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Increment the iterator modulo the number of elements.</span></code>
<code class="calibre21">    ++m_nextElement;</code>
<code class="calibre21">    if (m_nextElement == end(m_elements)) { m_nextElement = begin(m_elements); }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Return a reference to the element.</span></code>
<code class="calibre21">    return toReturn;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Here's a simple implementation of a scheduler that uses the
        <code class="calibre21">
         RoundRobin
        </code>
        class template, with comments explaining the code:
       </p>
       <pre class="calibre26" id="c18-code-0060"><code class="calibre21"><span class="color">// Basic Process class.</span></code>
<code class="calibre21">class Process final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Constructor accepting the name of the process.</span></code>
<code class="calibre21">        explicit Process(string name) : m_name { move(name) } {}</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Lets a process perform its work for the duration of a time slice.</span></code>
<code class="calibre21">        void doWorkDuringTimeSlice()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            println("Process {} performing work during time slice.", m_name);</code>
<code class="calibre21">            <span class="color">// Actual implementation omitted.</span></code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Needed for the RoundRobin::remove() member function to work.</span></code>
<code class="calibre21">        bool operator==(const Process&amp;) const = default; <span class="color">// = default since C++20.</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_name;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<span aria-label="708" class="calibre20" epub:type="pagebreak" id="Page_708" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Basic round-robin based process scheduler.</span></code>
<code class="calibre21">class Scheduler final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Constructor takes a vector of processes.</span></code>
<code class="calibre21">        explicit Scheduler(const vector&lt;Process&gt;&amp; processes)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            <span class="color">// Add the processes.</span></code>
<code class="calibre21">            for (auto&amp; process : processes) { m_processes.add(process); }</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Selects the next process using a round-robin scheduling algorithm</span></code>
<code class="calibre21">        <span class="color">// and allows it to perform some work during this time slice.</span></code>
<code class="calibre21">        void scheduleTimeSlice()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            try {</code>
<code class="calibre21">                m_processes.getNext().doWorkDuringTimeSlice();</code>
<code class="calibre21">            } catch (const out_of_range&amp;) {</code>
<code class="calibre21">                println(cerr, "No more processes to schedule.");</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Removes the given process from the list of processes.</span></code>
<code class="calibre21">        void removeProcess(const Process&amp; process)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_processes.remove(process);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        RoundRobin&lt;Process&gt; m_processes;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector processes { Process { "1" }, Process { "2" }, Process { "3" } };</code>
<code class="calibre21"> </code>
<code class="calibre21">    Scheduler scheduler { processes };</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; 4; ++i) { scheduler.scheduleTimeSlice(); }</code>
<code class="calibre21"> </code>
<code class="calibre21">    scheduler.removeProcess(processes[1]);</code>
<code class="calibre21">    println("Removed second process");</code>
<code class="calibre21"> </code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; 4; ++i) { scheduler.scheduleTimeSlice(); }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output should be as follows:
       </p>
       <pre class="calibre26" id="c18-code-0061"><code class="calibre21">Process 1 performing work during time slice.</code>
<code class="calibre21">Process 2 performing work during time slice.</code>
<code class="calibre21">Process 3 performing work during time slice.</code>
<code class="calibre21">Process 1 performing work during time slice.</code>
<code class="calibre21">Removed second process</code>
<code class="calibre21">Process 3 performing work during time slice.</code>
<code class="calibre21">Process 1 performing work during time slice.</code>
<code class="calibre21">Process 3 performing work during time slice.</code>
<code class="calibre21">Process 1 performing work during time slice.</code></pre>
      </section>
     </section>
     <span aria-label="709" class="calibre20" epub:type="pagebreak" id="Page_709" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0052">
      </span>
      <h3 class="calibre27" id="head-3-401">
       The vector&lt;bool&gt; Specialization
      </h3>
      <p class="calibre13">
       The C++ standard requires a partial specialization of
       <code class="calibre21">
        vector
       </code>
       for
       <code class="calibre21">
        bool
       </code>
       s, with the intention that it optimizes space allocation by “packing” the Boolean values. Recall that a
       <code class="calibre21">
        bool
       </code>
       is either
       <code class="calibre21">
        true
       </code>
       or
       <code class="calibre21">
        false
       </code>
       and thus could be represented by a single bit, which can take on exactly two values. C++ does not have a native type that stores exactly one bit. Some compilers represent a Boolean value with a type the same size as a
       <code class="calibre21">
        char
       </code>
       ; other compilers use an
       <code class="calibre21">
        int
       </code>
       . The
       <code class="calibre21">
        vector
       </code>
       &lt;
       <code class="calibre21">
        bool
       </code>
       &gt; specialization is supposed to store the “array of
       <code class="calibre21">
        bool
       </code>
       s” in single bits, thus saving space.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0156">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           You can think of the
          </i>
          <code class="calibre21">
           vector&lt;bool&gt;
          </code>
          <i class="calibre18">
           as a bit-field instead of a
          </i>
          <code class="calibre21">
           vector
          </code>
          <i class="calibre18">
           . The
          </i>
          <code class="calibre21">
           bitset
          </code>
          <i class="calibre18">
           container described later in this chapter provides a more full-featured bit-field implementation than does
          </i>
          <code class="calibre21">
           vector&lt;bool&gt;
          </code>
          <i class="calibre18">
           . However, the benefit of
          </i>
          <code class="calibre21">
           vector&lt;bool&gt;
          </code>
          <i class="calibre18">
           is that it can change size dynamically.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c18-para-0157">
       In a half-hearted attempt to provide some bit-field routines for
       <code class="calibre21">
        vector&lt;bool&gt;
       </code>
       , there is one additional member function called
       <code class="calibre21">
        flip()
       </code>
       that complements bits; that is,
       <code class="calibre21">
        true
       </code>
       becomes
       <code class="calibre21">
        false
       </code>
       , and
       <code class="calibre21">
        false
       </code>
       becomes
       <code class="calibre21">
        true
       </code>
       , similar to the logical NOT operator. This member function can be called either on the container—in which case it complements all the elements in the container—or on a single reference returned from
       <code class="calibre21">
        operator[]
       </code>
       or a similar member function, in which case it complements that single element.
      </p>
      <p class="calibre13">
       At this point, you should be wondering how you can call a member function on a reference to
       <code class="calibre21">
        bool
       </code>
       . The answer is that you can't. The
       <code class="calibre21">
        vector&lt;bool&gt;
       </code>
       specialization actually defines a class called
       <code class="calibre21">
        reference
       </code>
       that serves as a proxy for the underlying
       <code class="calibre21">
        bool
       </code>
       (or bit). When you call
       <code class="calibre21">
        operator[]
       </code>
       ,
       <code class="calibre21">
        at()
       </code>
       , or a similar member function, then
       <code class="calibre21">
        vector&lt;bool&gt;
       </code>
       returns a
       <code class="calibre21">
        reference
       </code>
       object, which is a proxy for the real
       <code class="calibre21">
        bool
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0159">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           The fact that references returned from
          </i>
          <code class="calibre21">
           vector&lt;bool&gt;
          </code>
          <i class="calibre18">
           are really proxies means that you can't take their addresses to obtain pointers to the actual elements in the container.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c18-para-0160">
       In practice, the little amount of space saved by packing
       <code class="calibre21">
        bool
       </code>
       s hardly seems worth the extra effort. Even worse, accessing and modifying elements in a
       <code class="calibre21">
        vector&lt;bool&gt;
       </code>
       is much slower than, for example, in a
       <code class="calibre21">
        vector&lt;int&gt;
       </code>
       . Many C++ experts recommend avoiding
       <code class="calibre21">
        vector&lt;bool&gt;
       </code>
       in favor of the
       <code class="calibre21">
        bitset
       </code>
       . If you do need a dynamically sized bit field, then just use something like
       <code class="calibre21">
        vector&lt;std::int_fast8_t&gt;
       </code>
       or
       <code class="calibre21">
        vector&lt;unsigned char&gt;
       </code>
       . The
       <code class="calibre21">
        std::int_fast8_t
       </code>
       type is defined in
       <code class="calibre21">
        &lt;cstdint&gt;
       </code>
       . It is a signed integer type for which the compiler has to use the fastest integer type it has that is at least 8 bits.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0055">
      </span>
      <h3 class="calibre27" id="head-3-402">
       deque
      </h3>
      <p class="calibre13">
       <code class="calibre21">
        deque
       </code>
       (abbreviation for
       <i class="calibre18">
        double-ended queue
       </i>
       ) is almost identical to
       <code class="calibre21">
        vector
       </code>
       , but is used far less frequently. It is defined in
       <code class="calibre21">
        &lt;deque&gt;
       </code>
       . The principal differences are as follows:
       <span aria-label="710" class="calibre20" epub:type="pagebreak" id="Page_710" role="doc-pagebreak">
       </span>
      </p>
      <ul class="check" id="c18-list-0009">
       <li class="calibre9" id="c18-li-0048">
        Elements are not stored contiguously in memory.
       </li>
       <li class="calibre9" id="c18-li-0049">
        A
        <code class="calibre21">
         deque
        </code>
        supports true constant-time insertion and removal of elements at both the front and the back (a
        <code class="calibre21">
         vector
        </code>
        supports amortized constant time at just the back).
       </li>
       <li class="calibre9" id="c18-li-0050">
        A
        <code class="calibre21">
         deque
        </code>
        provides the following member functions that
        <code class="calibre21">
         vector
        </code>
        omits:
        <ul class="check3" id="c18-list-0010">
         <li class="calibre9" id="c18-li-0051">
          <code class="calibre21">
           push_front()
          </code>
          : Inserts an element at the beginning.
         </li>
         <li class="calibre9" id="c18-li-0052">
          <code class="calibre21">
           pop_front()
          </code>
          : Removes the first element.
         </li>
         <li class="calibre9" id="c18-li-0053">
          <code class="calibre21">
           emplace:front()
          </code>
          : Creates a new element in-place at the beginning and returns a reference to the inserted element.
         </li>
         <li class="calibre9" id="c18-li-0054">
          <code class="calibre21">
           prepend_range()
          </code>
          : Adds all elements of a given range to the beginning of a
          <code class="calibre21">
           deque
          </code>
          . Available since C++23.
         </li>
        </ul>
       </li>
       <li class="calibre9" id="c18-li-0055">
        A
        <code class="calibre21">
         deque
        </code>
        never moves its elements to a bigger array (as
        <code class="calibre21">
         vector
        </code>
        does) when inserting elements at the front or at the back. This also means that a
        <code class="calibre21">
         deque
        </code>
        does not invalidate any iterators in such cases.
       </li>
       <li class="calibre9" id="c18-li-0056">
        A
        <code class="calibre21">
         deque
        </code>
        does not expose its memory management scheme via
        <code class="calibre21">
         reserve()
        </code>
        or
        <code class="calibre21">
         capacity()
        </code>
        .
       </li>
      </ul>
      <p class="calibre13" id="c18-para-0163">
       <code class="calibre21">
        deque
       </code>
       s are rarely used, as opposed to
       <code class="calibre21">
        vector
       </code>
       s, so they are not further discussed. Consult a Standard Library Reference for a detailed list of all supported member functions.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0056">
      </span>
      <h3 class="calibre27" id="head-3-403">
       list
      </h3>
      <p class="calibre13" id="c18-para-0164">
       The Standard Library
       <code class="calibre21">
        list
       </code>
       class template, defined in
       <code class="calibre21">
        &lt;list&gt;
       </code>
       , is a standard doubly linked list. It supports constant-time insertion and deletion of elements at any point in the list but provides slow (linear) time access to individual elements. In fact, the list does not even provide random-access operations like
       <code class="calibre21">
        operator[]
       </code>
       . Only through iterators can you access individual elements.
      </p>
      <p class="calibre13" id="c18-para-0165">
       Most of the
       <code class="calibre21">
        list
       </code>
       operations are identical to those of
       <code class="calibre21">
        vector
       </code>
       , including the constructors, destructor, copying operations, assignment operations, and comparison operations. This section focuses on those member functions that differ from those of
       <code class="calibre21">
        vector
       </code>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0057">
       </span>
       <h4 class="calibre29" id="head-4-283">
        Accessing Elements
       </h4>
       <p class="calibre13" id="c18-para-0166">
        The only member functions provided by a
        <code class="calibre21">
         list
        </code>
        to access elements are
        <code class="calibre21">
         front()
        </code>
        and
        <code class="calibre21">
         back()
        </code>
        , both of which run in constant time. These member functions return a reference to the first and last elements in a
        <code class="calibre21">
         list
        </code>
        . All other element access must be performed through iterators.
       </p>
       <p class="calibre13">
        Just as
        <code class="calibre21">
         vector
        </code>
        ,
        <code class="calibre21">
         list
        </code>
        supports
        <code class="calibre21">
         begin()
        </code>
        ,
        <code class="calibre21">
         end()
        </code>
        ,
        <code class="calibre21">
         rbegin()
        </code>
        ,
        <code class="calibre21">
         rend()
        </code>
        ,
        <code class="calibre21">
         cbegin()
        </code>
        ,
        <code class="calibre21">
         cend()
        </code>
        ,
        <code class="calibre21">
         crbegin()
        </code>
        , and
        <code class="calibre21">
         crend()
        </code>
        .
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0168">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Lists do not provide random access to elements
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <span aria-label="711" class="calibre20" epub:type="pagebreak" id="Page_711" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0059">
       </span>
       <h4 class="calibre29" id="head-4-284">
        Iterators
       </h4>
       <p class="calibre13" id="c18-para-0169">
        A
        <code class="calibre21">
         list
        </code>
        iterator is bidirectional, not random access like a
        <code class="calibre21">
         vector
        </code>
        iterator. That means that you cannot add and subtract
        <code class="calibre21">
         list
        </code>
        iterators from each other or perform other pointer arithmetic on them. For example, if
        <code class="calibre21">
         p
        </code>
        is a
        <code class="calibre21">
         list
        </code>
        iterator, you can traverse through the elements of the
        <code class="calibre21">
         list
        </code>
        by doing
        <code class="calibre21">
         ++p
        </code>
        or
        <code class="calibre21">
         --p
        </code>
        , but you cannot use the addition or subtraction operator;
        <code class="calibre21">
         p+n
        </code>
        and
        <code class="calibre21">
         p-n
        </code>
        do not work.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0060">
       </span>
       <h4 class="calibre29" id="head-4-285">
        Adding and Removing Elements
       </h4>
       <p class="calibre13" id="c18-para-0170">
        A
        <code class="calibre21">
         list
        </code>
        supports the same add and remove element member functions as a
        <code class="calibre21">
         vector
        </code>
        , including
        <code class="calibre21">
         push_back()
        </code>
        ,
        <code class="calibre21">
         pop_back()
        </code>
        ,
        <code class="calibre21">
         emplace()
        </code>
        ,
        <code class="calibre21">
         emplace:back()
        </code>
        , the five forms of
        <code class="calibre21">
         insert()
        </code>
        ,
        <code class="calibre21">
         assign_range()
        </code>
        ,
        <code class="calibre21">
         insert_range()
        </code>
        ,
        <code class="calibre21">
         append_range()
        </code>
        , the two forms of
        <code class="calibre21">
         erase()
        </code>
        , and
        <code class="calibre21">
         clear()
        </code>
        . Like a
        <code class="calibre21">
         deque
        </code>
        , it also provides
        <code class="calibre21">
         push_front()
        </code>
        ,
        <code class="calibre21">
         emplace:front()
        </code>
        ,
        <code class="calibre21">
         pop_front()
        </code>
        , and
        <code class="calibre21">
         prepend_range()
        </code>
        . Member functions adding or removing a single element run in constant time, once you've found the correct position, while member functions adding or removing multiple elements run in linear time. Thus, a
        <code class="calibre21">
         list
        </code>
        could be appropriate for applications that perform many insertions and deletions from the data structure, but do not need quick index-based element access. But even then, a
        <code class="calibre21">
         vector
        </code>
        might still be faster. Use a performance profiler to make sure.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0061">
       </span>
       <h4 class="calibre29" id="head-4-286">
        list Size
       </h4>
       <p class="calibre13" id="c18-para-0171">
        Like
        <code class="calibre21">
         deque
        </code>
        s, and unlike
        <code class="calibre21">
         vector
        </code>
        s,
        <code class="calibre21">
         list
        </code>
        s do not expose their underlying memory model. Consequently, they support
        <code class="calibre21">
         size()
        </code>
        ,
        <code class="calibre21">
         empty()
        </code>
        , and
        <code class="calibre21">
         resize()
        </code>
        , but not
        <code class="calibre21">
         reserve()
        </code>
        or
        <code class="calibre21">
         capacity()
        </code>
        . Note that the
        <code class="calibre21">
         size()
        </code>
        member function on a
        <code class="calibre21">
         list
        </code>
        has constant complexity.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0062">
       </span>
       <h4 class="calibre29" id="head-4-287">
        Special list Operations
       </h4>
       <p class="calibre13" id="c18-para-0172">
        A
        <code class="calibre21">
         list
        </code>
        provides several special operations that exploit its quick element insertion and deletion. This section provides an overview of some of these operations with examples. Consult a Standard Library Reference for a thorough reference of all the member functions.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0063">
        </span>
        <h5 class="calibre35" id="head-5-118">
         Splicing
        </h5>
        <p class="calibre13">
         The linked-list characteristics of a
         <code class="calibre21">
          list
         </code>
         allow it to
         <i class="calibre18">
          splice
         </i>
         , or insert, an entire
         <code class="calibre21">
          list
         </code>
         at any position in another
         <code class="calibre21">
          list
         </code>
         in constant time. The simplest version of this member function works as follows:
        </p>
        <pre class="calibre26" id="c18-code-0062"><code class="calibre21"><span class="color">// Store the a words in the main dictionary.</span></code>
<code class="calibre21">list&lt;string&gt; dictionary { "aardvark", "ambulance" };</code>
<code class="calibre21"><span class="color">// Store the b words.</span></code>
<code class="calibre21">list&lt;string&gt; bWords { "bathos", "balderdash" };</code>
<code class="calibre21"><span class="color">// Add the c words to the main dictionary.</span></code>
<code class="calibre21">dictionary.push_back("canticle");</code>
<code class="calibre21">dictionary.push_back("consumerism");</code>
<code class="calibre21"><span class="color">// Splice the b words into the main dictionary.</span></code>
<code class="calibre21">if (!bWords.empty()) {</code>
<code class="calibre21">    <span class="color">// Get an iterator to the last b word.</span></code>
<code class="calibre21">    auto iterLastB { --(cend(bWords)) };</code>
<code class="calibre21">    <span class="color">// Iterate up to the spot where we want to insert b words.</span></code>
<code class="calibre21">    auto it { cbegin(dictionary) };</code>
<code class="calibre21">    for (; it != cend(dictionary); ++it) {</code>
<code class="calibre21">        if (*it &gt; *iterLastB) { break; }</code>
<code class="calibre21">    }</code>
<span aria-label="712" class="calibre20" epub:type="pagebreak" id="Page_712" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// Add in the b words. This action removes the elements from bWords.</span></code>
<code class="calibre21">    dictionary.splice(it, bWords);</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Print out the dictionary.</span></code>
<code class="calibre21">println("{:n:}", dictionary);</code></pre>
        <p class="calibre13">
         The result from running this program looks like this:
        </p>
        <pre class="calibre26" id="c18-code-0063"><code class="calibre21">aardvark, ambulance, bathos, balderdash, canticle, consumerism</code></pre>
        <p class="calibre13">
         There are also two other overloads of
         <code class="calibre21">
          splice()
         </code>
         : one that inserts a single element from another
         <code class="calibre21">
          list
         </code>
         and one that inserts a range from another
         <code class="calibre21">
          list
         </code>
         . Additionally, all overloads of
         <code class="calibre21">
          splice()
         </code>
         are available with either a normal reference or an rvalue reference to the source
         <code class="calibre21">
          list
         </code>
         .
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0176">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Splicing is destructive to the
            </i>
            <code class="calibre21">
             list
            </code>
            <i class="calibre18">
             passed as an argument, i.e., it removes the spliced elements from one
            </i>
            <code class="calibre21">
             list
            </code>
            <i class="calibre18">
             to insert them into the other.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0065">
        </span>
        <h5 class="calibre35" id="head-5-119">
         More Efficient Versions of Algorithms
        </h5>
        <p class="calibre13">
         In addition to
         <code class="calibre21">
          splice()
         </code>
         , a
         <code class="calibre21">
          list
         </code>
         provides special implementations of several of the generic Standard Library algorithms. The generic forms are covered in
         <a class="calibre5" href="c20.xhtml">
          Chapter 20
         </a>
         . Here, only the specific versions provided by
         <code class="calibre21">
          list
         </code>
         are discussed.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0178">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             When you have a choice, use the
            </i>
            <code class="calibre21">
             list
            </code>
            <i class="calibre18">
             -specific member functions rather than the generic Standard Library algorithms because the former are more efficient. Sometimes you don't have a choice, and you must use the
            </i>
            <code class="calibre21">
             list
            </code>
            <i class="calibre18">
             -specific member functions; for example, the generic
            </i>
            <code class="calibre21">
             std::sort()
            </code>
            <i class="calibre18">
             algorithm requires random-access iterators, which a
            </i>
            <code class="calibre21">
             list
            </code>
            <i class="calibre18">
             does not provide.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13" id="c18-para-0179">
         The following table summarizes the algorithms for which
         <code class="calibre21">
          list
         </code>
         provides special implementations as member functions. See
         <a class="calibre5" href="c20.xhtml">
          Chapter 20
         </a>
         for more details on the algorithms.
        </p>
        <table border="1" class="calibre31">
         <thead class="calibre32">
          <tr class="calibre33">
           <th class="left" scope="col">
            MEMBER FUNCTION
           </th>
           <th class="left" scope="col">
            DESCRIPTION
           </th>
          </tr>
         </thead>
         <tbody class="calibre34">
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             remove()
            </code>
            <br class="calibre12"/>
            <code class="calibre21">
             remove_if()
            </code>
           </td>
           <td class="left1">
            Removes all elements matching certain criteria from a
            <code class="calibre21">
             list
            </code>
            and returns the number of removed elements.
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             unique()
            </code>
           </td>
           <td class="left1">
            Removes duplicate consecutive elements from a
            <code class="calibre21">
             list
            </code>
            , based on
            <code class="calibre21">
             operator==
            </code>
            or a user-supplied binary predicate, and returns the number of removed elements.
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             merge()
            </code>
           </td>
           <td class="left1">
            Merges two
            <code class="calibre21">
             lists
            </code>
            . Both
            <code class="calibre21">
             list
            </code>
            s must be sorted according to
            <code class="calibre21">
             operator&lt;
            </code>
            or a user-defined comparator. Like
            <code class="calibre21">
             splice()
            </code>
            ,
            <code class="calibre21">
             merge()
            </code>
            is destructive to the
            <code class="calibre21">
             list
            </code>
            passed as an argument.
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             sort()
            </code>
           </td>
           <td class="left1">
            Performs a stable sort on elements in a
            <code class="calibre21">
             list
            </code>
            .
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             reverse()
            </code>
           </td>
           <td class="left1">
            Reverses the order of the elements in a
            <code class="calibre21">
             list
            </code>
            .
            <span aria-label="713" class="calibre20" epub:type="pagebreak" id="Page_713" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0067">
       </span>
       <h4 class="calibre29" id="head-4-288">
        list Example: Determining Enrollment
       </h4>
       <p class="calibre13" id="c18-para-0184">
        Suppose that you are writing a computer registration system for a university. One feature you might provide is the ability to generate a complete list of enrolled students in the university from lists of the students in each class. For the sake of this example, assume that you must write only a single function that takes a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         list
        </code>
        s of student names (as
        <code class="calibre21">
         string
        </code>
        s), plus a
        <code class="calibre21">
         list
        </code>
        of students that have been dropped from their courses because they failed to pay tuition. This function should generate a complete
        <code class="calibre21">
         list
        </code>
        of all the students in all the courses, without any duplicates, and without those students who have been dropped. Note that students might be in more than one course.
       </p>
       <p class="calibre13">
        Here is the code for this function, with comments explaining the code. With the power of Standard Library
        <code class="calibre21">
         list
        </code>
        s, the function is practically shorter than its written description! Note that the Standard Library allows you to “nest” containers: in this case, you can use a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         list
        </code>
        s.
       </p>
       <pre class="calibre26" id="c18-code-0064"><code class="calibre21"><span class="color">// courseStudents is a vector of lists, one for each course. The lists</span></code>
<code class="calibre21"><span class="color">// contain the students enrolled in those courses. They are not sorted.</span></code>
<code class="calibre21"><span class="color">//</span></code>
<code class="calibre21"><span class="color">// droppedStudents is a list of students who failed to pay their</span></code>
<code class="calibre21"><span class="color">// tuition and so were dropped from their courses.</span></code>
<code class="calibre21"><span class="color">//</span></code>
<code class="calibre21"><span class="color">// The function returns a list of every enrolled (non-dropped) student in</span></code>
<code class="calibre21"><span class="color">// all the courses.</span></code>
<code class="calibre21">list&lt;string&gt; getTotalEnrollment(const vector 
&lt;list&lt;string&gt;&gt;&amp; courseStudents,</code>
<code class="calibre21">                                const list&lt;string&gt;&amp; droppedStudents)</code>
<code class="calibre21">{</code>
<code class="calibre21">    list&lt;string&gt; allStudents;</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Concatenate all the course lists onto the master list</span></code>
<code class="calibre21">    for (auto&amp; lst : courseStudents) {</code>
<code class="calibre21">        allStudents.append_range(lst);</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Sort the master list</span></code>
<code class="calibre21">    allStudents.sort();</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Remove duplicate student names (those who are in multiple courses).</span></code>
<code class="calibre21">    allStudents.unique();</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Remove students who are on the dropped list.</span></code>
<code class="calibre21">    <span class="color">// Iterate through the dropped list, calling remove on the</span></code>
<code class="calibre21">    <span class="color">// master list for each student in the dropped list.</span></code>
<code class="calibre21">    for (auto&amp; str : droppedStudents) {</code>
<code class="calibre21">        allStudents.remove(str);</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// done!</span></code>
<code class="calibre21">    return allStudents;</code>
<code class="calibre21">}</code></pre>
       <span aria-label="714" class="calibre20" epub:type="pagebreak" id="Page_714" role="doc-pagebreak">
       </span>
       <span aria-label="715" class="calibre20" epub:type="pagebreak" id="Page_715" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0187">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            This example demonstrates the use of the
           </i>
           <code class="calibre21">
            list
           </code>
           <i class="calibre18">
            -specific algorithms. As stated several times before, often a
           </i>
           <code class="calibre21">
            vector
           </code>
           <i class="calibre18">
            is faster than a
           </i>
           <code class="calibre21">
            list
           </code>
           <i class="calibre18">
            . So, the recommended solution to the student enrollment problem would be to only use
           </i>
           <code class="calibre21">
            vector
           </code>
           <i class="calibre18">
            s and to combine these with generic Standard Library algorithms, but those are discussed in
            <a class="calibre5" href="c20.xhtml">
             Chapter 20
            </a>
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0069">
      </span>
      <h3 class="calibre27" id="head-3-404">
       forward_list
      </h3>
      <p class="calibre13" id="c18-para-0188">
       A
       <code class="calibre21">
        forward_list
       </code>
       , defined in
       <code class="calibre21">
        &lt;forward_list&gt;
       </code>
       , is similar to a
       <code class="calibre21">
        list
       </code>
       except that it is a singly linked list, while
       <code class="calibre21">
        list
       </code>
       is a doubly linked list. This means that
       <code class="calibre21">
        forward_list
       </code>
       supports only forward iteration, and because of this, ranges need to be specified differently compared to a
       <code class="calibre21">
        list
       </code>
       . If you want to modify any list, you need access to the element before the first element of interest. Because a
       <code class="calibre21">
        forward_list
       </code>
       does not have an iterator that supports going backward, there is no easy way to get to the preceding element. For this reason, ranges that will be modified—for example, ranges supplied to
       <code class="calibre21">
        erase()
       </code>
       and
       <code class="calibre21">
        splice()
       </code>
       —must be open at the beginning. The
       <code class="calibre21">
        begin()
       </code>
       function that was discussed earlier returns an iterator to the first element and thus can only be used to construct a range that is closed at the beginning. The
       <code class="calibre21">
        forward_list
       </code>
       class therefore provides a
       <code class="calibre21">
        before_begin()
       </code>
       member function, which returns an iterator that points to an imaginary element before the beginning of the list. You cannot dereference this iterator as it points to invalid data. However, incrementing this iterator by 1 makes it the same as the iterator returned by
       <code class="calibre21">
        begin()
       </code>
       ; as a result, it can be used to make a range that is open at the beginning.
      </p>
      <p class="calibre13" id="c18-para-0189">
       Constructors and assignment operators are similar between a
       <code class="calibre21">
        list
       </code>
       and a
       <code class="calibre21">
        forward_list
       </code>
       . The C++ standard requires that
       <code class="calibre21">
        forward_list
       </code>
       minimizes its memory use. That's the reason why there is no
       <code class="calibre21">
        size()
       </code>
       member function, because by not providing it, there is no need to store the size of the list. Additionally, a
       <code class="calibre21">
        list
       </code>
       has to store a pointer to the previous and the next element in the list, while a
       <code class="calibre21">
        forward_list
       </code>
       only needs to store a pointer to the next element, further reducing memory use. For example, each element in a
       <code class="calibre21">
        list&lt;int&gt;
       </code>
       on a 64-bit system requires 20 bytes (two 64-bit pointers, 16 bytes, and the
       <code class="calibre21">
        int
       </code>
       itself, 4 bytes). A
       <code class="calibre21">
        forward_list&lt;int&gt;
       </code>
       requires only 12 bytes (one 64-bit pointer, 8 bytes, and the
       <code class="calibre21">
        int
       </code>
       , 4 bytes) per element.
      </p>
      <p class="calibre13" id="c18-para-0190">
       The following table sums up the differences between a
       <code class="calibre21">
        list
       </code>
       and a
       <code class="calibre21">
        forward_list
       </code>
       . A filled box (
       <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
       ) means the container supports that operation, while an empty box (
       <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
       ) means the operation is not supported.
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          OPERATION
         </th>
         <th class="left" scope="col">
          list
         </th>
         <th class="left" scope="col">
          forward_list
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           append_range()
          </span>
          (C++23)
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           assign()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           assign_range()
          </span>
          (C++23)
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           back()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           before_begin()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           begin()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           cbefore_begin()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           cbegin()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           cend()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           clear()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           crbegin()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           crend()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           emplace()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           emplace:after()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           emplace:back()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           emplace:front()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           empty()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           end()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           erase()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           erase_after()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           front()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           insert()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           insert_after()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           insert_range()
          </span>
          (C++23)
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           insert_range_after()
          </span>
          (C++23)
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           iterator / const_iterator
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           max_size()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           merge()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           pop_back()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           pop_front()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           prepend_range()
          </span>
          (C++23)
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           push_back()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           push_front()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           rbegin()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           remove()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           remove_if()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           rend()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           resize()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           reverse()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           reverse_iterator / const_reverse_iterator
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           size()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           sort()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           splice()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           splice:after()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           swap()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="calibre40">
          <span class="calibre21">
           unique()
          </span>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
         </td>
         <td class="bgcolor">
          <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          <span aria-label="716" class="calibre20" epub:type="pagebreak" id="Page_716" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       The following example demonstrates the use of
       <code class="calibre21">
        forward_list
       </code>
       s:
      </p>
      <pre class="calibre26" id="c18-code-0065"><code class="calibre21"><span class="color">// Create 3 forward lists using an initializer_list</span></code>
<code class="calibre21"><span class="color">// to initialize their elements (uniform initialization).</span></code>
<code class="calibre21">forward_list&lt;int&gt; list1 { 5, 6 };</code>
<code class="calibre21">forward_list list2 { 1, 2, 3, 4 };  <span class="color">// CTAD is supported.</span></code>
<code class="calibre21">forward_list list3 { 7, 8, 9 };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Insert list2 at the front of list1 using splice.</span></code>
<code class="calibre21">list1.splice:after(list1.before_begin(), list2);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Add number 0 at the beginning of the list1.</span></code>
<code class="calibre21">list1.push_front(0);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Insert list3 at the end of list1.</span></code>
<code class="calibre21"><span class="color">// For this, we first need an iterator to the last element.</span></code>
<code class="calibre21">auto iter { list1.before_begin() };</code>
<code class="calibre21">auto iterTemp { iter };</code>
<code class="calibre21">while (++iterTemp != end(list1)) { ++iter; }</code>
<code class="calibre21">list1.insert_after(iter, cbegin(list3), cend(list3));</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Output the contents of list1.</span></code>
<code class="calibre21">println("{:n}", list1);</code></pre>
      <p class="calibre13">
       <span aria-label="717" class="calibre20" epub:type="pagebreak" id="Page_717" role="doc-pagebreak">
       </span>
       To insert
       <code class="calibre21">
        list3
       </code>
       at the end of
       <code class="calibre21">
        list1
       </code>
       , you need an iterator to the last element of
       <code class="calibre21">
        list1
       </code>
       . However, because this is a
       <code class="calibre21">
        forward_list
       </code>
       , you cannot use
       <code class="calibre21">
        --end(list1)
       </code>
       , so you need to iterate over the list from the beginning and stop at the last element. The output is as follows:
      </p>
      <pre class="calibre26" id="c18-code-0066"><code class="calibre21">0, 1, 2, 3, 4, 5, 6, 7, 8, 9</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0070">
      </span>
      <h3 class="calibre27" id="head-3-405">
       array
      </h3>
      <p class="calibre13" id="c18-para-0194">
       An
       <code class="calibre21">
        array
       </code>
       , defined in
       <code class="calibre21">
        &lt;array&gt;
       </code>
       , is similar to a
       <code class="calibre21">
        vector
       </code>
       except that it is of a fixed size; it cannot grow or shrink in size. The purpose of a fixed size is to allow an
       <code class="calibre21">
        array
       </code>
       to be allocated on the stack, rather than always demanding access to the free store as
       <code class="calibre21">
        vector
       </code>
       does.
      </p>
      <p class="calibre13" id="c18-para-0195">
       For
       <code class="calibre21">
        array
       </code>
       s containing primitive types (integers, floating-point numbers, characters, Booleans, and so on), initialization of elements is different compared to how they are initialized for containers such as
       <code class="calibre21">
        vector
       </code>
       ,
       <code class="calibre21">
        list
       </code>
       , and so on. If no initialization values are given to an
       <code class="calibre21">
        array
       </code>
       when it is created, then the
       <code class="calibre21">
        array
       </code>
       elements will be uninitialized, i.e., contain garbage. For other containers, such as
       <code class="calibre21">
        vector
       </code>
       and
       <code class="calibre21">
        list
       </code>
       , elements are always initialized, either with given values or using zero initialization. As such,
       <code class="calibre21">
        array
       </code>
       s behave virtually identical to C-style arrays.
      </p>
      <p class="calibre13">
       Just like
       <code class="calibre21">
        vector
       </code>
       s,
       <code class="calibre21">
        array
       </code>
       s support random-access iterators, and elements are stored in contiguous memory. An
       <code class="calibre21">
        array
       </code>
       has support for
       <code class="calibre21">
        front()
       </code>
       ,
       <code class="calibre21">
        back()
       </code>
       ,
       <code class="calibre21">
        at()
       </code>
       , and
       <code class="calibre21">
        operator[]
       </code>
       . It also supports a
       <code class="calibre21">
        fill()
       </code>
       member function to fill the
       <code class="calibre21">
        array
       </code>
       with a specific element. Because it is fixed in size, it does not support
       <code class="calibre21">
        push_back()
       </code>
       ,
       <code class="calibre21">
        pop_back()
       </code>
       ,
       <code class="calibre21">
        insert()
       </code>
       ,
       <code class="calibre21">
        erase()
       </code>
       ,
       <code class="calibre21">
        clear()
       </code>
       ,
       <code class="calibre21">
        resize()
       </code>
       ,
       <code class="calibre21">
        reserve()
       </code>
       ,
       <code class="calibre21">
        capacity()
       </code>
       , or any of the range-based member functions. A disadvantage compared to a
       <code class="calibre21">
        vector
       </code>
       is that the
       <code class="calibre21">
        swap()
       </code>
       member function of an
       <code class="calibre21">
        array
       </code>
       runs in linear time, while it has constant complexity for a
       <code class="calibre21">
        vector
       </code>
       . An
       <code class="calibre21">
        array
       </code>
       can also not be moved in constant time, while a
       <code class="calibre21">
        vector
       </code>
       can. An
       <code class="calibre21">
        array
       </code>
       has a
       <code class="calibre21">
        size()
       </code>
       member function, which is a clear advantage over C-style arrays. The following example demonstrates how to use the
       <code class="calibre21">
        array
       </code>
       class. Note that the
       <code class="calibre21">
        array
       </code>
       declaration requires two template parameters: the first specifies the type of the elements, and the second specifies the fixed number of elements in the
       <code class="calibre21">
        array
       </code>
       .
      </p>
      <pre class="calibre26" id="c18-code-0067"><code class="calibre21"><span class="color">// Create an array of 3 integers and initialize them</span></code>
<code class="calibre21"><span class="color">// with the given initializer_list using uniform initialization.</span></code>
<code class="calibre21">array&lt;int, 3&gt; arr { 9, 8, 7 };</code>
<code class="calibre21"><span class="color">// Output the size of the array.</span></code>
<code class="calibre21">println("Array size = {}", arr.size()); <span class="color">// or std::size(arr)</span></code>
<code class="calibre21"><span class="color">// Output the contents using C++23's support for formatting ranges.</span></code>
<code class="calibre21">println("{:n}", arr);</code>
<code class="calibre21"><span class="color">// Output the contents again using a range-based for loop.</span></code>
<code class="calibre21">for (const auto&amp; i : arr) { print("{} ", i); }</code>
<code class="calibre21">println("");</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Performing arr.fill(3)…");</code>
<code class="calibre21"><span class="color">// Use the fill member function to change the contents of the array.</span></code>
<code class="calibre21">arr.fill(3);</code>
<code class="calibre21"><span class="color">// Output the contents of the array using iterators.</span></code>
<code class="calibre21">for (auto iter { cbegin(arr) }; iter != cend(arr); ++iter) {</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <span aria-label="718" class="calibre20" epub:type="pagebreak" id="Page_718" role="doc-pagebreak">
       </span>
       The output is as follows:
      </p>
      <pre class="calibre26" id="c18-code-0068"><code class="calibre21">Array size = 3</code>
<code class="calibre21">9, 8, 7</code>
<code class="calibre21">9 8 7</code>
<code class="calibre21">Performing arr.fill(3)…</code>
<code class="calibre21">3 3 3</code></pre>
      <p class="calibre13">
       You can use the
       <code class="calibre21">
        std::get&lt;n&gt;()
       </code>
       function template to retrieve an element from an
       <code class="calibre21">
        std::array
       </code>
       at the given index
       <i class="calibre18">
        n
       </i>
       . The index has to be a constant expression, so it cannot, for example, be a loop variable. The benefit of using
       <code class="calibre21">
        std::get&lt;n&gt;()
       </code>
       is that the compiler checks at compile time that the given index is valid; otherwise, it results in a compilation error, as in this example:
      </p>
      <pre class="calibre26" id="c18-code-0069"><code class="calibre21">array myArray { 11, 22, 33 };  // std::array supports CTAD.</code>
<code class="calibre21">println("{}", std::get&lt;1&gt;(myArray));</code>
<code class="calibre21">println("{}", std::get&lt;10&gt;(myArray));  <span class="color">// BUG! Compilation error!</span></code></pre>
      <p class="calibre13">
       <code class="calibre21">
        std::to_array()
       </code>
       , defined in
       <code class="calibre21">
        &lt;array&gt;
       </code>
       , converts a given C-style array to an
       <code class="calibre21">
        std::array
       </code>
       , using copy-initialization of the elements. The function works only for one-dimensional arrays. Here is a quick example:
      </p>
      <pre class="calibre26" id="c18-code-0070"><code class="calibre21">auto arr1 { to_array({ 11, 22, 33 }) }; <span class="color">// Type is array&lt;int, 3&gt;</span></code>
<code class="calibre21"> </code>
<code class="calibre21">double carray[] { 9, 8, 7, 6 };</code>
<code class="calibre21">auto arr2 { to_array(carray) };         <span class="color">// Type is array&lt;double, 4&gt;</span></code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-200" class="calibre2">
     <span class="calibre" id="c18-sec-0071">
     </span>
     <h2 class="calibre6" id="head-2-200">
      SEQUENTIAL VIEWS
     </h2>
     <p class="calibre13" id="c18-para-0200">
      The C++ Standard Library provides two
      <i class="calibre18">
       sequential views
      </i>
      :
      <code class="calibre21">
       std::span
      </code>
      and
      <code class="calibre21">
       std::mdspan
      </code>
      . The latter is new in C++23. A
      <code class="calibre21">
       span
      </code>
      provides a one-dimensional, non-owning view over a contiguous sequence of data. An
      <code class="calibre21">
       mdspan
      </code>
      generalizes this concept and allows the creation of multidimensional, non-owning views over a contiguous sequence of data.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0072">
      </span>
      <h3 class="calibre27" id="head-3-406">
       span
      </h3>
      <p class="calibre13">
       Suppose you have this function to print the contents of a
       <code class="calibre21">
        vector
       </code>
       :
      </p>
      <pre class="calibre26" id="c18-code-0071"><code class="calibre21">void print(const vector&lt;int&gt;&amp; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (const auto&amp; value : values) { print("{} ", value); }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Suppose further that you also want to print the contents of C-style arrays. One option is to overload the
       <code class="calibre21">
        print()
       </code>
       function to accept a pointer to the first element of the array, and the number of elements to print:
      </p>
      <pre class="calibre26" id="c18-code-0072"><code class="calibre21">void print(const int values[], size_t count)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; count; ++i) { print("{} ", values[i]); }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c18-para-0203">
       <span aria-label="719" class="calibre20" epub:type="pagebreak" id="Page_719" role="doc-pagebreak">
       </span>
       If you also want to print
       <code class="calibre21">
        std::array
       </code>
       s, you could provide a third overload, but what would the function parameter type be? For an
       <code class="calibre21">
        std::array
       </code>
       , you have to specify the type and the number of elements in the
       <code class="calibre21">
        array
       </code>
       as template parameters. You see, it's getting complicated.
      </p>
      <p class="calibre13">
       <code class="calibre21">
        std::span
       </code>
       , defined in
       <code class="calibre21">
        &lt;span&gt;
       </code>
       , comes to the rescue here, as it allows you to write a single function that works with
       <code class="calibre21">
        vector
       </code>
       s, C-style arrays, and
       <code class="calibre21">
        std::array
       </code>
       s of any size. Here is a single implementation of
       <code class="calibre21">
        print()
       </code>
       using
       <code class="calibre21">
        span
       </code>
       :
      </p>
      <pre class="calibre26" id="c18-code-0073"><code class="calibre21">void print(span&lt;int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (const auto&amp; value : values) { print("{} ", value); }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c18-para-0205">
       Note that, just as with
       <code class="calibre21">
        string_view
       </code>
       from
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       , a
       <code class="calibre21">
        span
       </code>
       is cheap to copy; it basically just contains a pointer to the first element in a sequence and a number of elements. A
       <code class="calibre21">
        span
       </code>
       never copies data! As such, it is usually passed by value.
      </p>
      <p class="calibre13" id="c18-para-0206">
       There are several constructors for creating a
       <code class="calibre21">
        span
       </code>
       . For example, one can be created to include all elements of a given
       <code class="calibre21">
        vector
       </code>
       ,
       <code class="calibre21">
        std::array
       </code>
       , or C-style array. A
       <code class="calibre21">
        span
       </code>
       can also be created to include only part of a container, by passing the address of the first element and the number of elements you want to include in the
       <code class="calibre21">
        span
       </code>
       .
      </p>
      <p class="calibre13" id="c18-para-0207">
       A subview can be created from an existing
       <code class="calibre21">
        span
       </code>
       using the
       <code class="calibre21">
        subspan()
       </code>
       member function. Its first argument is the offset into the
       <code class="calibre21">
        span
       </code>
       , and the second argument is the number of elements to include in the subview. There are also two additional member functions called
       <code class="calibre21">
        first()
       </code>
       and
       <code class="calibre21">
        last()
       </code>
       returning subviews of a
       <code class="calibre21">
        span
       </code>
       containing the first
       <i class="calibre18">
        n
       </i>
       elements or the last
       <i class="calibre18">
        n
       </i>
       elements respectively.
      </p>
      <p class="calibre13" id="c18-para-0208">
       A
       <code class="calibre21">
        span
       </code>
       has a couple of member functions that are similar to
       <code class="calibre21">
        vector
       </code>
       and
       <code class="calibre21">
        array
       </code>
       :
       <code class="calibre21">
        begin()
       </code>
       ,
       <code class="calibre21">
        end()
       </code>
       ,
       <code class="calibre21">
        rbegin()
       </code>
       ,
       <code class="calibre21">
        rend()
       </code>
       ,
       <code class="calibre21">
        front()
       </code>
       ,
       <code class="calibre21">
        back()
       </code>
       ,
       <code class="calibre21">
        operator[]
       </code>
       ,
       <code class="calibre21">
        data()
       </code>
       ,
       <code class="calibre21">
        size()
       </code>
       , and
       <code class="calibre21">
        empty()
       </code>
       .
      </p>
      <p class="calibre13">
       The following code snippet demonstrates a few ways to call the
       <code class="calibre21">
        print(span)
       </code>
       function:
      </p>
      <pre class="calibre26" id="c18-code-0074"><code class="calibre21">vector v { 11, 22, 33, 44, 55, 66 };</code>
<code class="calibre21"><span class="color">// Pass the whole vector, implicitly converted to a span.</span></code>
<code class="calibre21">print(v);</code>
<code class="calibre21"><span class="color">// Pass an explicitly created span.</span></code>
<code class="calibre21">span mySpan { v };</code>
<code class="calibre21">print(mySpan);</code>
<code class="calibre21"><span class="color">// Create a subview and pass that.</span></code>
<code class="calibre21">span subspan { mySpan.subspan(2, 3) };</code>
<code class="calibre21">print(subspan);</code>
<code class="calibre21"><span class="color">// Pass a subview created in-line.</span></code>
<code class="calibre21">print({ v.data() + 2, 3 });</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Pass an std::array.</span></code>
<code class="calibre21">array&lt;int, 5&gt; arr { 5, 4, 3, 2, 1 };</code>
<code class="calibre21">print(arr);</code>
<code class="calibre21">print({ arr.data() + 2, 3 });</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Pass a C-style array.</span></code>
<code class="calibre21">int carr[] { 9, 8, 7, 6, 5 };</code>
<code class="calibre21">print(carr);            <span class="color">// The entire C-style array.</span></code>
<code class="calibre21">print({ carr + 2, 3 }); <span class="color">// A subview of the C-style array.</span></code></pre>
      <p class="calibre13">
       <span aria-label="720" class="calibre20" epub:type="pagebreak" id="Page_720" role="doc-pagebreak">
       </span>
       The output is as follows:
      </p>
      <pre class="calibre26" id="c18-code-0075"><code class="calibre21">11 22 33 44 55 66</code>
<code class="calibre21">11 22 33 44 55 66</code>
<code class="calibre21">33 44 55</code>
<code class="calibre21">33 44 55</code>
<code class="calibre21">5 4 3 2 1</code>
<code class="calibre21">3 2 1</code>
<code class="calibre21">9 8 7 6 5</code>
<code class="calibre21">7 6 5</code></pre>
      <p class="calibre13">
       Unlike
       <code class="calibre21">
        string_view
       </code>
       that provides a read-only view of a
       <code class="calibre21">
        string
       </code>
       , a
       <code class="calibre21">
        span
       </code>
       can provide read/write access to the underlying elements. Remember that a
       <code class="calibre21">
        span
       </code>
       just contains a pointer to the first element in a sequence and the number of elements; that is, a
       <code class="calibre21">
        span
       </code>
       never copies data! As such, modifying an element in a
       <code class="calibre21">
        span
       </code>
       actually modifies the element in the underlying sequence. If this is not desired, a
       <code class="calibre21">
        span
       </code>
       of
       <code class="calibre21">
        const
       </code>
       elements can be created. For example, the
       <code class="calibre21">
        print()
       </code>
       function has no reason to modify any of the elements in a given
       <code class="calibre21">
        span
       </code>
       . We can prevent such modifications as follows:
      </p>
      <pre class="calibre26" id="c18-code-0076"><code class="calibre21">void print(span&lt;<b class="calibre14">const int</b>&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (const auto&amp; value : values) { print("{} ", value); }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0213">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           When writing a function accepting a
          </i>
          <code class="calibre21">
           const vector&lt;T&gt;&amp;
          </code>
          <i class="calibre18">
           , consider accepting a
          </i>
          <code class="calibre21">
           span&lt;const T&gt;
          </code>
          <i class="calibre18">
           instead, so the function can work with views and subviews of data sequences coming from
           <code class="calibre21">
            vector
           </code>
           s,
           <code class="calibre21">
            array
           </code>
           s, C-style arrays and more. If the function accepts a
          </i>
          <code class="calibre21">
           vector&lt;T&gt;&amp;
          </code>
          <i class="calibre18">
           , consider accepting a
          </i>
          <code class="calibre21">
           span&lt;T&gt;
          </code>
          <i class="calibre18">
           , unless the function needs to add or remove elements from the
          </i>
          <code class="calibre21">
           vector
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0074">
      </span>
      <h3 class="calibre27" id="head-3-407">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       mdspan
      </h3>
      <p class="calibre13">
       <code class="calibre21">
        std::mdspan
       </code>
       , defined in
       <code class="calibre21">
        &lt;mdspan&gt;
       </code>
       , is similar to
       <code class="calibre21">
        std::span
       </code>
       but allows you to create multidimensional views over a contiguous sequence of data. Just as
       <code class="calibre21">
        span
       </code>
       , an
       <code class="calibre21">
        mdspan
       </code>
       doesn't own the data, so it is cheap to copy. An
       <code class="calibre21">
        mdspan
       </code>
       has four template type parameters:
      </p>
      <ul class="check" id="c18-list-0011">
       <li class="calibre9" id="c18-li-0057">
        <b class="calibre14">
         <code class="calibre21">
          ElementType
         </code>
         :
        </b>
        The type of the underlying elements.
       </li>
       <li class="calibre9" id="c18-li-0058">
        <b class="calibre14">
         <code class="calibre21">
          Extents
         </code>
         :
        </b>
        The number of dimensions and their size, a specialization of
        <code class="calibre21">
         std::extents
        </code>
        .
       </li>
       <li class="calibre9" id="c18-li-0059">
        <b class="calibre14">
         <code class="calibre21">
          LayoutPolicy
         </code>
         :
        </b>
        A policy specifying how to convert a multidimensional index to a one-dimensional index into the underlying contiguous sequence of data. You can implement whichever layout policy you need, such as tiled layout, Hilbert curve, and so on. The following standard policies are available:
        <ul class="check3" id="c18-list-0012">
         <li class="calibre9" id="c18-li-0060">
          <b class="calibre14">
           <code class="calibre21">
            layout_right
           </code>
           :
          </b>
          Row-major multidimensional array layout, where the rightmost extent has stride 1. This is the default policy.
         </li>
         <li class="calibre9" id="c18-li-0061">
          <span aria-label="721" class="calibre20" epub:type="pagebreak" id="Page_721" role="doc-pagebreak">
          </span>
          <b class="calibre14">
           <code class="calibre21">
            layout_left
           </code>
           :
          </b>
          Column-major multidimensional array layout, where the leftmost extent has stride 1.
         </li>
         <li class="calibre9" id="c18-li-0062">
          <b class="calibre14">
           <code class="calibre21">
            layout_stride
           </code>
           :
          </b>
          A layout mapping with user-defined strides.
         </li>
        </ul>
       </li>
       <li class="calibre9" id="c18-li-0063">
        <b class="calibre14">
         <code class="calibre21">
          AccessorPolicy
         </code>
         :
        </b>
        A policy specifying how to convert the one-dimensional index into the underlying contiguous sequence of data into a reference to the actual element at that location. The default is
        <code class="calibre21">
         std::default_accessor
        </code>
        .
       </li>
      </ul>
      <p class="calibre13">
       There are numerous constructors available. One of them is a constructor accepting a pointer to the contiguous sequence of data as the first parameter, followed by one or more dimension extents. Such extents passed as constructor arguments are called
       <i class="calibre18">
        dynamic extents
       </i>
       . Data can be accessed using a multidimensional
       <code class="calibre21">
        operator[]
       </code>
       . The
       <code class="calibre21">
        size()
       </code>
       member function returns the number of elements in an
       <code class="calibre21">
        mdspan
       </code>
       , and
       <code class="calibre21">
        empty()
       </code>
       returns
       <code class="calibre21">
        true
       </code>
       if an
       <code class="calibre21">
        mdspan
       </code>
       is empty. The
       <code class="calibre21">
        stride(n)
       </code>
       member function can be used to query the stride of dimension
       <code class="calibre21">
        n
       </code>
       . The size of the dimensions can be queried using the
       <code class="calibre21">
        extents()
       </code>
       member function. It returns an
       <code class="calibre21">
        std::extents
       </code>
       instance on which you can call
       <code class="calibre21">
        extent(n)
       </code>
       to query the size of dimension
       <code class="calibre21">
        n
       </code>
       . Here is an example:
      </p>
      <pre class="calibre26" id="c18-code-0077"><code class="calibre21">template &lt;typename T&gt; void print2Dmdspan(const T&amp; mdSpan)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; mdSpan.extents().extent(0); ++i) {</code>
<code class="calibre21">        for (size_t j { 0 }; j &lt; mdSpan.extents().extent(1); ++j) {</code>
<code class="calibre21">             print("{} ", mdSpan[i, j]);</code>
<code class="calibre21">        }</code>
<code class="calibre21">        println("");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector data { 1, 2, 3, 4, 5, 6, 7, 8 };</code>
<code class="calibre21">    <span class="color">// View data as a 2D array of 2 rows with 4 integers each,</span></code>
<code class="calibre21">    <span class="color">// using the default row-major layout policy.</span></code>
<code class="calibre21">    mdspan data2D { data.data(), 2, 4 };</code>
<code class="calibre21">    print2Dmdspan(data2D);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c18-code-0078"><code class="calibre21">1 2 3 4</code>
<code class="calibre21">5 6 7 8</code></pre>
      <p class="calibre13">
       This code uses the default row-major layout policy. The following code snippet uses the column-major layout policy instead. Because the layout policy is the third template type parameter, you have to specify the first and second template type parameters as well. Instead of passing the size of each dimension as an argument to the constructor, the code now passes an
       <code class="calibre21">
        std::extents
       </code>
       as the second template type parameter:
      </p>
      <pre class="calibre26" id="c18-code-0079"><code class="calibre21">mdspan&lt;int, extents&lt;int, 2, 4&gt;, layout_left&gt; data2D { data.data() };</code></pre>
      <p class="calibre13">
       The output now is as follows:
      </p>
      <pre class="calibre26" id="c18-code-0080"><code class="calibre21">1 3 5 7</code>
<code class="calibre21">2 4 6 8</code></pre>
      <p class="calibre13">
       <span aria-label="722" class="calibre20" epub:type="pagebreak" id="Page_722" role="doc-pagebreak">
       </span>
       This
       <code class="calibre21">
        mdspan
       </code>
       definition specifies the extent of all dimensions as compile-time constants, i.e.,
       <i class="calibre18">
        static extents
       </i>
       . It is also possible to combine static and dynamic extents. The following example specifies the first dimension as a compile-time constant, and the second as a dynamic extent. You then must pass the size of all dynamic extents as arguments to the constructor.
      </p>
      <pre class="calibre26" id="c18-code-0081"><code class="calibre21">mdspan&lt;int, extents&lt;int, 2, dynamic_extent&gt;&gt; data2D { data.data(), 4 };</code></pre>
      <p class="calibre13">
       The output is again as follows:
      </p>
      <pre class="calibre26" id="c18-code-0082"><code class="calibre21">1 2 3 4</code>
<code class="calibre21">5 6 7 8</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-201" class="calibre2">
     <span class="calibre" id="c18-sec-0075">
     </span>
    </section>
   </section>
  </div>
 </body>
</html>
