<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   23Random Number Facilities
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_033.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_035.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c23_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c23_1">
      <span aria-label="879" epub:type="pagebreak" id="Page_879" role="doc-pagebreak">
      </span>
      <span id="c23">
      </span>
      <span class="chapterNumber">
       23
      </span>
      <br/>
      <span class="chapterTitle">
       Random Number Facilities
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c23-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c23-list-0001">
         <li id="c23-li-0001">
          The concepts of random number engines and engine adapters
         </li>
         <li id="c23-li-0002">
          How to generate random numbers
         </li>
         <li id="c23-li-0003">
          How to change the distribution of random numbers
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c23-fea-0001">
        </span>
        <h3 id="head-2-235">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c23-sec-0003">
        </span>
        <p id="c23-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <a href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c23-para-0005">
      This chapter discusses how to generate random numbers in C++. Generating good random numbers in software is a complex topic. This chapter does not discuss the complex mathematical formulas involved in generating the actual random numbers; however, it does explain how to generate random numbers using the functionality provided by the Standard Library.
     </p>
     <p id="c23-para-0006">
      The C++ random number generation library can generate random numbers by using different algorithms and distributions. The library is defined by
      <code>
       &lt;random&gt;
      </code>
      in the
      <code>
       std
      </code>
      namespace. It has three big components:
      <i>
       engines
      </i>
      ,
      <i>
       engine adapters
      </i>
      , and
      <i>
       distributions
      </i>
      . A random number
      <i>
       engine
      </i>
      is responsible for generating the actual random numbers and storing the state for generating subsequent random numbers. The
      <i>
       distribution
      </i>
      determines the range of the generated random numbers and how they are mathematically distributed within that range. A random number
      <i>
       engine adapter
      </i>
      modifies the results of a random number engine you associate it with.
     </p>
     <p id="c23-para-0007">
      Before delving into this C++ random number generation library, the old C-style mechanism of generating random numbers and its problems are briefly explained.
     </p>
    </section>
    <span aria-label="880" epub:type="pagebreak" id="Page_880" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-236">
     <span id="c23-sec-0004">
     </span>
     <h2 id="head-2-236">
      C-STYLE RANDOM NUMBER GENERATION
     </h2>
     <p>
      Before C++11, you could generate random numbers using the C-style
      <code>
       srand
      </code>
      (
      <code>
       )
      </code>
      and
      <code>
       rand()
      </code>
      functions. The
      <code>
       srand()
      </code>
      function had to be called once in your application and was used to initialize the random number generator, also called
      <i>
       seeding
      </i>
      . Usually, the current system time would be used as a seed.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c23-para-0009">
         <b>
          WARNING
         </b>
         <i>
          You need to make sure that you use a good-quality seed for your software-based random number generator. If you initialize the random number generator with the same seed every time, you will create the same sequence of random numbers every time. This is why the seed is usually the current system time
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p>
      Once the generator is initialized, random numbers could be generated with
      <code>
       rand()
      </code>
      . The following example shows how to use
      <code>
       srand()
      </code>
      and
      <code>
       rand()
      </code>
      . The
      <code>
       time()
      </code>
      function, defined in
      <code>
       &lt;ctime&gt;
      </code>
      , returns the system time, usually encoded as the number of seconds since the system's epoch. The epoch represents the beginning of time.
     </p>
     <pre id="c23-code-0001"><code>srand(static_cast&lt;unsigned int&gt;(time(nullptr)));</code>
<code>println("{}", rand());</code></pre>
     <p>
      A random number within a certain range could be generated with the following function:
     </p>
     <pre id="c23-code-0002"><code>int getRandom(int min, int max)</code>
<code>{</code>
<code>    return static_cast&lt;int&gt;(rand() % (max + 1UL - min)) + min;</code>
<code>}</code></pre>
     <p id="c23-para-0012">
      The old C-style
      <code>
       rand()
      </code>
      function generates random numbers in the range 0 to
      <code>
       RAND_MAX
      </code>
      , which is defined by the standard to be at least 32,767. You cannot generate random numbers larger than
      <code>
       RAND_MAX
      </code>
      . On some systems, for example GCC,
      <code>
       RAND_MAX
      </code>
      is 2,147,483,647, which equals the maximum value of a signed integer. To prevent arithmetic overflow on such systems, the formula in
      <code>
       getRandom()
      </code>
      uses
      <code>
       unsigned long
      </code>
      calculations, due to the use of
      <code>
       1UL
      </code>
      instead of just
      <code>
       1
      </code>
      .
     </p>
     <p>
      Additionally, the low-order bits of
      <code>
       rand()
      </code>
      are often not very random, which means that using the previous
      <code>
       getRandom()
      </code>
      function to generate a random number in a small range, such as 1 to 6, will not result in good randomness.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c23-para-0014">
         <b>
          NOTE
         </b>
         <i>
          Software-based random number generators can never generate truly random numbers. They are therefore called pseudorandom number generators (PRNGs) because they rely on mathematical formulas to give the impression of randomness
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c23-para-0015">
      Besides generating bad-quality random numbers, the old
      <code>
       srand()
      </code>
      and
      <code>
       rand()
      </code>
      functions don't offer much in terms of flexibility either. You cannot, for example, change the distribution of the generated random numbers. In conclusion, it's highly recommended to stop using
      <code>
       srand()
      </code>
      and
      <code>
       rand()
      </code>
      and start using the classes from
      <code>
       &lt;random&gt;
      </code>
      explained in the upcoming sections.
     </p>
    </section>
    <span aria-label="881" epub:type="pagebreak" id="Page_881" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-237">
     <span id="c23-sec-0007">
     </span>
     <h2 id="head-2-237">
      RANDOM NUMBER ENGINES
     </h2>
     <p id="c23-para-0016">
      The first component of the modern C++ random number generation library is a
      <i>
       random number engine
      </i>
      , responsible for generating the actual random numbers. As mentioned, everything is defined in
      <code>
       &lt;random&gt;
      </code>
      .
     </p>
     <p>
      The following random number engines are available:
     </p>
     <ul class="check1" id="c23-list-0002">
      <li id="c23-li-0004">
       <code>
        random_device
       </code>
      </li>
      <li id="c23-li-0005">
       <code>
        linear_congruential_engine
       </code>
      </li>
      <li id="c23-li-0006">
       <code>
        mersenne_twister_engine
       </code>
      </li>
      <li id="c23-li-0007">
       <code>
        subtract_with_carry_engine
       </code>
      </li>
     </ul>
     <p id="c23-para-0018">
      The
      <code>
       random_device
      </code>
      engine is not a software-based generator; it is a special engine that requires a piece of hardware attached to your computer that generates truly non-deterministic random numbers, for example, by using the laws of physics. A classic mechanism measures the decay of a radioactive isotope by counting alpha-particles-per-time-interval, but there are many other kinds of physics-based random-number generators, including measuring the “noise” of reverse-biased diodes (thus eliminating the concerns about radioactive sources in your computer). The details of these mechanisms fall outside the scope of this book. If no such device is attached to the computer,
      <code>
       random_device
      </code>
      is free to use one of the software algorithms. The choice of algorithm is up to the library designer. Luckily, most modern computers have proper support for a true
      <code>
       random_device
      </code>
      .
     </p>
     <p id="c23-para-0019">
      The quality of a random number generator is measured by its
      <i>
       entropy
      </i>
      . The
      <code>
       entropy()
      </code>
      member function of the
      <code>
       random_device
      </code>
      engine returns 0.0 if it is using a software-based pseudorandom number generator and returns a non-zero value if it is using a hardware device. The non-zero value is an estimate of the entropy of the hardware device.
     </p>
     <p>
      Using a
      <code>
       random_device
      </code>
      engine is straightforward:
     </p>
     <pre id="c23-code-0003"><code>random_device rnd;</code>
<code>println("Entropy: {}", rnd.entropy());</code>
<code>println("Min value: {}, Max value: {}", rnd.min(), rnd.max());</code>
<code>println("Random number: {}", rnd());</code></pre>
     <p>
      A possible output of this program could be as follows:
     </p>
     <pre id="c23-code-0004"><code>Entropy: 32</code>
<code>Min value: 0, Max value: 4294967295</code>
<code>Random number: 3590924439</code></pre>
     <p id="c23-para-0022">
      A
      <code>
       random_device
      </code>
      is much slower than a pseudorandom number engine. Therefore, if you need to generate a lot of random numbers, use a pseudorandom number engine and generate a seed for it with a
      <code>
       random_device
      </code>
      . This is demonstrated in the section “
      <a href="#c23-sec-0010">
       Generating Random Numbers
      </a>
      ” later in this chapter.
     </p>
     <p>
      Next to the
      <code>
       random_device
      </code>
      engine, there are three pseudorandom number engines:
     </p>
     <ul class="check1" id="c23-list-0003">
      <li id="c23-li-0008">
       <b>
        Linear congruential engine:
       </b>
       Requires a minimal amount of memory to store its state. The state is a single integer containing the last generated random number or the initial seed if no random number has been generated yet. The period of this engine depends on an algorithmic
       <span aria-label="882" epub:type="pagebreak" id="Page_882" role="doc-pagebreak">
       </span>
       parameter and can be up to 2
       <sup>
        64
       </sup>
       but is usually less. For this reason, the linear congruential engine should not be used when you need high-quality random numbers.
      </li>
      <li id="c23-li-0009">
       <b>
        Mersenne twister:
       </b>
       Of the three pseudorandom number engines, this one generates the highest quality of random numbers. The period of a Mersenne twister is a Mersenne prime, which is a prime number one less than a power of two. This period is much bigger than the period of a linear congruential engine. The memory required to store the state of a Mersenne twister also depends on its parameters but is much larger than the single integer state of the linear congruential engine. For example, the predefined Mersenne twister
       <code>
        mt19937
       </code>
       has a period of 2
       <sup>
        19937
       </sup>
       −1, while the state contains 625 integers or 2.5 kilobytes. It is also one of the fastest engines.
      </li>
      <li id="c23-li-0010">
       <b>
        Subtract with carry engine:
       </b>
       Requires a state of around 100 bytes; however, the quality of the generated random numbers is less than that of the numbers generated by the Mersenne twister, and it is also slower than the Mersenne twister.
      </li>
     </ul>
     <p id="c23-para-0024">
      The mathematical details of the engines and of the quality of random numbers fall outside the scope of this book. If you want to know more about these topics, you can consult a reference from the “Random Numbers” section in
      <a href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography.”
     </p>
     <p>
      The
      <code>
       random_device
      </code>
      engine is easy to use and doesn't require any parameters. However, creating an instance of one of the three pseudorandom number generators requires you to specify a number of mathematical parameters, which can be daunting. The selection of parameters greatly influences the quality of the generated random numbers. For example, the definition of the
      <code>
       mersenne_twister_engine
      </code>
      class template looks like this:
     </p>
     <pre id="c23-code-0005"><code>template&lt;class UIntType, size_t w, size_t n, size_t m, size_t r,</code>
<code>         UIntType a, size_t u, UIntType d, size_t s,</code>
<code>         UIntType b, size_t t, UIntType c, size_t l, UIntType f&gt;</code>
<code>    class mersenne_twister_engine {…}</code></pre>
     <p>
      It requires 14 parameters. The
      <code>
       linear_congruential_engine
      </code>
      and
      <code>
       subtract_with_carry_engine
      </code>
      class templates also require a number of such mathematical parameters. For this reason, the standard defines a couple of predefined engines. One example is the
      <code>
       mt19937
      </code>
      Mersenne twister, which is defined as follows:
     </p>
     <pre id="c23-code-0006"><code>using <b>mt19937</b> = mersenne_twister_engine&lt;uint_fast32_t, 32, 624, 397, 31,</code>
<code>    0x9908b0df, 11, 0xffffffff, 7, 0x9d2c5680, 15, 0xefc60000, 18,</code>
<code>    1812433253&gt;;</code></pre>
     <p id="c23-para-0027">
      These parameters are all magic, unless you understand the details of the Mersenne twister algorithm. In general, you do not want to modify any of these parameters unless you are an expert in the mathematics of pseudorandom number generators. Instead, I recommend using the predefined type aliases such as
      <code>
       mt19937
      </code>
      . A complete list of predefined engines is given in a later section.
     </p>
    </section>
    <section aria-labelledby="head-2-238">
     <span id="c23-sec-0008">
     </span>
     <h2 id="head-2-238">
      RANDOM NUMBER ENGINE ADAPTERS
     </h2>
     <p>
      A random number engine adapter modifies the result of a random number engine you associate it with, which is called the
      <i>
       base engine
      </i>
      . This is an example of the
      <i>
       adapter pattern
      </i>
      (see
      <a href="c33.xhtml">
       Chapter 33
      </a>
      , “Applying design patterns”). The following three adapter templates are defined:
     </p>
     <pre id="c23-code-0007"><code>template&lt;class Engine, size_t p, size_t r&gt; class <b>discard_block_engine</b> {…}</code>
<span aria-label="883" epub:type="pagebreak" id="Page_883" role="doc-pagebreak"></span><code>template&lt;class Engine, size_t w, class UIntT&gt; class <b>independent_bits_engine</b> {…}</code>
<code>template&lt;class Engine, size_t k&gt; class <b>shuffle_order_engine</b> {…}</code></pre>
     <p id="c23-para-0029">
      The
      <code>
       discard_block_engine
      </code>
      adapter generates random numbers by discarding some of the values generated by its base engine. It requires three parameters: the engine to adapt, the block size
      <i>
       p
      </i>
      , and the used block size
      <i>
       r
      </i>
      . The base engine is used to generate
      <i>
       p
      </i>
      random numbers. The adapter then discards
      <i>
       p
      </i>
      -
      <i>
       r
      </i>
      of those numbers and returns the remaining
      <i>
       r
      </i>
      numbers.
     </p>
     <p id="c23-para-0030">
      The
      <code>
       independent_bits_engine
      </code>
      adapter generates random numbers with a given number of bits
      <i>
       w
      </i>
      by combining several random numbers generated by the base engine.
     </p>
     <p id="c23-para-0031">
      The
      <code>
       shuffle_order_engine
      </code>
      adapter generates the same random numbers that are generated by the base engine but delivers them in a different order. The template parameter
      <code>
       k
      </code>
      is the size of an internal table used by the adapter. A random number is randomly selected from this table upon request, and then replaced with a new random number generated by the base engine.
     </p>
     <p id="c23-para-0032">
      Just as with random number engines, a number of predefined engine adapters are available. The next section gives an overview of the predefined engines and engine adapters.
     </p>
    </section>
    <section aria-labelledby="head-2-239">
     <span id="c23-sec-0009">
     </span>
     <h2 id="head-2-239">
      PREDEFINED ENGINES AND ENGINE ADAPTERS
     </h2>
     <p>
      As mentioned earlier, it is not recommended to specify your own parameters for pseudorandom number engines and engine adapters, but instead to use one of the standard ones. The C++ Standard Library defines the following predefined generators, all in
      <code>
       &lt;random&gt;
      </code>
      . They all have complicated template arguments, but it is not necessary to understand those arguments to be able to use them.
     </p>
     <table border="1">
      <thead>
       <tr>
        <th class="left bgcolor2" scope="col">
         PREDEFINED GENERATOR
        </th>
        <th class="left bgcolor2" scope="col">
         CLASS TEMPLATE
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          minstd_rand0
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          linear_congruential_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          minstd_rand
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          linear_congruential_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          mt19937
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          mersenne_twister_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          mt19937_64
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          mersenne_twister_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ranlux24_base
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          subtract_with_carry_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ranlux48_base
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          subtract_with_carry_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ranlux24
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          discard_block_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ranlux48
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          discard_block_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          knuth_b
         </span>
        </td>
        <td class="left bgcolor3">
         <span class="forecolor1">
          shuffle_order_engine
         </span>
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          default_random_engine
         </span>
        </td>
        <td class="left bgcolor3">
         <i>
          Implementation-defined
         </i>
        </td>
       </tr>
      </tbody>
     </table>
     <p id="c23-para-0034">
      The
      <code>
       default_random_engine
      </code>
      is compiler dependent.
     </p>
     <p id="c23-para-0035">
      The following section gives an example of how to use these predefined engines.
     </p>
    </section>
    <span aria-label="884" epub:type="pagebreak" id="Page_884" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-240">
     <span id="c23-sec-0010">
     </span>
     <h2 id="head-2-240">
      GENERATING RANDOM NUMBERS
     </h2>
     <p id="c23-para-0036">
      Before you can generate any random number, you first need to create an instance of an engine. If you use a software-based engine, you also need to define a distribution. A distribution is a mathematical formula describing how numbers are distributed within a certain range. The recommended way to create an engine is to use one of the predefined engines discussed in the previous section.
     </p>
     <p>
      The following example uses the predefined engine called
      <code>
       mt19937
      </code>
      , using a Mersenne twister engine. This is a software-based generator. Just as with the old
      <code>
       rand()
      </code>
      generator, a software-based engine must be initialized with a seed. The seed used with
      <code>
       srand()
      </code>
      was often the current time. In modern C++, it's recommended to use a
      <code>
       random_device
      </code>
      to generate a seed. Here is an example:
     </p>
     <pre id="c23-code-0008"><code>random_device seeder;</code>
<code>mt19937 engine { seeder() };</code></pre>
     <p>
      As mentioned earlier, most modern systems have a
      <code>
       random_device
      </code>
      implementation with proper entropy. If you are not sure that the
      <code>
       random_device
      </code>
      implementation on the system your code will be running on has proper entropy, then you can use a time-based seed as a fallback:
     </p>
     <pre id="c23-code-0009"><code>random_device seeder;</code>
<code>const auto seed { seeder.entropy() ? seeder() : time(nullptr) };</code>
<code>mt19937 engine { static_cast&lt;mt19937::result_type&gt;(seed) };</code></pre>
     <p>
      Next, a distribution is defined. This example uses a uniform integer distribution, for the range 1 to 99. Distributions are explained in detail in the next section, but this uniform distribution is easy enough to use for this example:
     </p>
     <pre id="c23-code-0010"><code>uniform_int_distribution&lt;int&gt; distribution { 1, 99 };</code></pre>
     <p>
      Once the engine and distribution are defined, random numbers can be generated by calling the function call operator of the distribution and passing the engine as an argument. For this example, this is written as
      <code>
       distribution(engine)
      </code>
      :
     </p>
     <pre id="c23-code-0011"><code>println("{}", distribution(engine));</code></pre>
     <p>
      As you can see, to generate a random number using a software-based engine, you always need to specify the engine and distribution. The
      <code>
       std::bind()
      </code>
      utility, introduced in
      <a href="c19.xhtml">
       Chapter 19
      </a>
      , “Function Pointers, Function Objects, and Lambda Expressions,” can be used to remove the need to specify both the distribution and the engine when generating a random number. The following example uses the same
      <code>
       mt19937
      </code>
      engine and uniform distribution as the previous example, but it defines
      <code>
       generator
      </code>
      by using
      <code>
       std::bind()
      </code>
      to bind
      <code>
       engine
      </code>
      as the first argument to
      <code>
       distribution()
      </code>
      . This way, you can call
      <code>
       generator()
      </code>
      without any arguments to generate a random number. The example then demonstrates the use of
      <code>
       generator()
      </code>
      in combination with the constrained
      <code>
       ranges::generate()
      </code>
      algorithm to fill a
      <code>
       vector
      </code>
      of ten elements with random numbers. The
      <code>
       generate()
      </code>
      algorithm is discussed in
      <a href="c20.xhtml">
       Chapter 20
      </a>
      , “Mastering Standard Library Algorithms.”
     </p>
     <pre id="c23-code-0012"><code>auto generator { bind(distribution, engine) };</code>
<code> </code>
<code>vector&lt;int&gt; values(10);</code>
<code>ranges::generate(values, generator);</code>
<code> </code>
<code>println("{:n}", values);</code></pre>
     <p>
      <span aria-label="885" epub:type="pagebreak" id="Page_885" role="doc-pagebreak">
      </span>
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c23-para-0043">
         <b>
          NOTE
         </b>
         <i>
          Remember that the
         </i>
         <code>
          generate()
         </code>
         <i>
          algorithm overwrites existing elements and does not insert new elements. This means you first need to size the
         </i>
         <code>
          vector
         </code>
         <i>
          to hold the number of elements you need and then call the
         </i>
         <code>
          generate()
         </code>
         <i>
          algorithm. The previous example sizes the
         </i>
         <code>
          vector
         </code>
         <i>
          by specifying the size as argument to the constructor.
         </i>
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p>
      Even though you don't know the exact type of
      <code>
       generator
      </code>
      , it's still possible to pass
      <code>
       generator
      </code>
      to another function that wants to use that generator. You have several options: use a parameter of type
      <code>
       std::function&lt;int()&gt;
      </code>
      or use a function template. The previous example can be adapted to generate random numbers in a function called
      <code>
       fillVector()
      </code>
      . Here is an implementation using
      <code>
       std::function
      </code>
      :
     </p>
     <pre id="c23-code-0013"><code>void fillVector(vector&lt;int&gt;&amp; values, const function&lt;int()&gt;&amp; generator)</code>
<code>{</code>
<code>    ranges::generate(values, generator);</code>
<code>}</code></pre>
     <p>
      Here is a constrained function template variant:
     </p>
     <pre id="c23-code-0014"><code>template &lt;invocable T&gt;</code>
<code>void fillVector(vector&lt;int&gt;&amp; values, const T&amp; generator)</code>
<code>{</code>
<code>    ranges::generate(values, generator);</code>
<code>}</code></pre>
     <p>
      This can be simplified using the abbreviated function template syntax:
     </p>
     <pre id="c23-code-0015"><code>void fillVector(vector&lt;int&gt;&amp; values, const auto&amp; generator)</code>
<code>{</code>
<code>    ranges::generate(values, generator);</code>
<code>}</code></pre>
     <p>
      Finally, this function can be used as follows:
     </p>
     <pre id="c23-code-0016"><code>vector&lt;int&gt; values(10);</code>
<code><b>fillVector(values, generator);</b></code></pre>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c23-para-0049">
         <b>
          WARNING
         </b>
         <i>
          The random number generators are not thread safe. If you need to generate random numbers in multiple threads, you should create a generator in each thread and not share one generator among multiple threads
         </i>
         .
         <a href="c27.xhtml">
          <i>
           Chapter
          </i>
          27
         </a>
         <i>
          , “Multithreaded Programming with C++,” introduces multithreading
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-241">
     <span id="c23-sec-0013">
     </span>
     <h2 id="head-2-241">
      RANDOM NUMBER DISTRIBUTIONS
     </h2>
     <p id="c23-para-0050">
      A distribution is a mathematical formula describing how numbers are distributed within a certain range. The random number generator library comes with the following distributions that can be used
      <span aria-label="886" epub:type="pagebreak" id="Page_886" role="doc-pagebreak">
      </span>
      with pseudorandom number engines to define the distribution of the generated random numbers. It's a compacted representation. The first line of each distribution is the name and class template parameters, if any. The next lines are a constructor for the distribution. Only one constructor for each distribution is shown to give you an idea of the class. Consult a Standard Library Reference (see
      <a href="b02.xhtml">
       Appendix B
      </a>
      ) for a detailed list of all constructors and member functions of each distribution.
     </p>
     <p>
      These are the available uniform distributions:
     </p>
     <pre id="c23-code-0017"><code>template&lt;class IntType = int&gt; class uniform_int_distribution</code>
<code>    <b>uniform_int_distribution</b>(IntType a = 0,</code>
<code>                             IntType b = numeric_limits&lt;IntType&gt;::max());</code>
<code>template&lt;class RealType = double&gt; class uniform_real_distribution</code>
<code>    <b>uniform_real_distribution</b>(RealType a = 0.0, RealType b = 1.0);</code></pre>
     <p>
      These are the available Bernoulli distributions (the first one generates random Boolean values, while the last three generate random non-negative integer values, all of them according to the discrete probability distribution):
     </p>
     <pre id="c23-code-0018"><code>class bernoulli_distribution</code>
<code>    <b>bernoulli_distribution</b>(double p = 0.5);</code>
<code>template&lt;class IntType = int&gt; class binomial_distribution</code>
<code>    <b>binomial_distribution</b>(IntType t = 1, double p = 0.5);</code>
<code>template&lt;class IntType = int&gt; class geometric_distribution</code>
<code>    <b>geometric_distribution</b>(double p = 0.5);</code>
<code>template&lt;class IntType = int&gt; class negative_binomial_distribution</code>
<code>    <b>negative_binomial_distribution</b>(IntType k = 1, double p = 0.5);</code></pre>
     <p>
      These are the available Poisson distributions (generate random non-negative integer values according to the discrete probability distribution):
     </p>
     <pre id="c23-code-0019"><code>template&lt;class IntType = int&gt; class poisson_distribution</code>
<code>    <b>poisson_distribution</b>(double mean = 1.0);</code>
<code>template&lt;class RealType = double&gt; class exponential_distribution</code>
<code>    <b>exponential_distribution</b>(RealType lambda = 1.0);</code>
<code>template&lt;class RealType = double&gt; class gamma_distribution</code>
<code>    <b>gamma_distribution</b>(RealType alpha = 1.0, RealType beta = 1.0);</code>
<code>template&lt;class RealType = double&gt; class weibull_distribution</code>
<code>    <b>weibull_distribution</b>(RealType a = 1.0, RealType b = 1.0);</code>
<code>template&lt;class RealType = double&gt; class extreme_value_distribution</code>
<code>    <b>extreme_value_distribution</b>(RealType a = 0.0, RealType b = 1.0);</code></pre>
     <p>
      These are the available normal distributions:
     </p>
     <pre id="c23-code-0020"><code>template&lt;class RealType = double&gt; class normal_distribution</code>
<code>    <b>normal_distribution</b>(RealType mean = 0.0, RealType stddev = 1.0);</code>
<code>template&lt;class RealType = double&gt; class lognormal_distribution</code>
<code>    <b>lognormal_distribution</b>(RealType m = 0.0, RealType s = 1.0);</code>
<code>template&lt;class RealType = double&gt; class chi_squared_distribution</code>
<code>    <b>chi_squared_distribution</b>(RealType n = 1);</code>
<code>template&lt;class RealType = double&gt; class cauchy_distribution</code>
<code>    <b>cauchy_distribution</b>(RealType a = 0.0, RealType b = 1.0);</code>
<code>template&lt;class RealType = double&gt; class fisher_f_distribution</code>
<code>    <b>fisher_f_distribution</b>(RealType m = 1, RealType n = 1);</code>
<code>template&lt;class RealType = double&gt; class student_t_distribution</code>
<code>    <b>student_t_distribution</b>(RealType n = 1);</code></pre>
     <p>
      <span aria-label="887" epub:type="pagebreak" id="Page_887" role="doc-pagebreak">
      </span>
      These are the available sampling distributions:
     </p>
     <pre id="c23-code-0021"><code>template&lt;class IntType = int&gt; class discrete_distribution</code>
<code>    <b>discrete_distribution</b>(initializer_list&lt;double&gt; wl);</code>
<code>template&lt;class RealType = double&gt; class piecewise_constant_distribution</code>
<code>    template&lt;class UnaryOperation&gt;</code>
<code>        <b>piecewise_constant_distribution</b>(initializer_list&lt;RealType&gt; bl,</code>
<code>            UnaryOperation fw);</code>
<code>template&lt;class RealType = double&gt; class piecewise_linear_distribution</code>
<code>    template&lt;class UnaryOperation&gt;</code>
<code>        <b>piecewise_linear_distribution</b>(initializer_list&lt;RealType&gt; bl,</code>
<code>            UnaryOperation fw);</code></pre>
     <p id="c23-para-0056">
      Each distribution requires a set of parameters. As before, explaining all these mathematical parameters is outside the scope of this book. The rest of this section includes a couple of examples to explain the impact of a distribution on the generated random numbers.
     </p>
     <p>
      Distributions are easiest to understand when you look at a graphical representation of them. The following code generates one million random numbers between 1 and 99 and keeps track of how many times a certain number is randomly generated in a histogram. The counters are stored in a
      <code>
       map
      </code>
      where the key is a number between 1 and 99, and the value associated with a key is the number of times that that key has been selected randomly. After the loop, the results are written to a semicolon-separated values file (CSV), which can be opened in a spreadsheet application.
     </p>
     <pre id="c23-code-0022"><code>const unsigned int Start { 1 };</code>
<code>const unsigned int End { 99 };</code>
<code>const unsigned int Iterations { 1'000'000 };</code>
<code> </code>
<code><span class="color3">// Uniform distributed Mersenne Twister.</span></code>
<code>random_device seeder;</code>
<code>mt19937 engine { seeder() };</code>
<code>uniform_int_distribution&lt;int&gt; distribution { Start, End };</code>
<code>auto generator { bind(distribution, engine) };</code>
<code>map&lt;int, int&gt; histogram;</code>
<code>for (unsigned int i { 0 }; i &lt; Iterations; ++i) {</code>
<code>    int randomNumber { generator() };</code>
<code>    <span class="color3">// Search map for a key=randomNumber. If found, add 1 to the value associated</span></code>
<code>    <span class="color3">// with that key. If not found, add the key to the map with value 1.</span></code>
<code>    ++(histogram[randomNumber]);</code>
<code>}</code>
<code> </code>
<code><span class="color3">// Write to a CSV file.</span></code>
<code>ofstream of { "res.csv" };</code>
<code>for (unsigned int i { Start }; i &lt;= End; ++i) {</code>
<code>    of &lt;&lt; i &lt;&lt; ";" &lt;&lt; histogram[i] &lt;&lt; endl;</code>
<code>}</code></pre>
     <p id="c23-para-0058">
      The resulting data can then be used to generate a graphical representation.
      <a href="#c23-fig-0001" id="R_c23-fig-0001">
       Figure 23.1
      </a>
      shows a graph of the generated histogram.
     </p>
     <p id="c23-para-0059">
      The horizontal axis represents the range in which random numbers are generated. The graph clearly shows that all numbers in the range 1 to 99 are randomly chosen around 10,000 times and that the distribution of the generated random numbers is uniform across the entire range.
     </p>
     <figure>
      <img alt="A line graph with a wavy line. The Y-axis ranges from 0 to 12,000 in increments of 2,000, and the X-axis varies from 1 to over 91 in increments of approximately 10 units. The signal appears to fluctuate around the 10,000 mark on the Y-axis throughout the entire range of the X-axis." class="center" src="../images\images/c23f001.png"/>
      <figcaption>
       <p>
        <span class="figureLabel">
         <a href="#R_c23-fig-0001" id="c23-fig-0001" role="doc-backlink">
          <b>
           FIGURE 23.1
          </b>
         </a>
        </span>
       </p>
      </figcaption>
     </figure>
     <p>
      <span aria-label="888" epub:type="pagebreak" id="Page_888" role="doc-pagebreak">
      </span>
      The example can be modified to generate random numbers according to a normal distribution instead of a uniform distribution. Only two small changes are required. First, you need to modify the creation of the distribution as follows:
     </p>
     <pre id="c23-code-0023"><code>normal_distribution&lt;double&gt; distribution { 50, 10 };</code></pre>
     <p>
      Because normal distributions use
      <code>
       double
      </code>
      s instead of integers, you also need to modify the call to
      <code>
       generator()
      </code>
      :
     </p>
     <pre id="c23-code-0024"><code>int randomNumber { static_cast&lt;int&gt;(generator()) };</code></pre>
     <p id="c23-para-0062">
      <a href="#c23-fig-0002" id="R_c23-fig-0002">
       Figure 23.2
      </a>
      shows a graphical representation of the random numbers generated according to this normal distribution.
     </p>
     <span aria-label="889" epub:type="pagebreak" id="Page_889" role="doc-pagebreak">
     </span>
     <figure>
      <img alt="A graph of random numbers is generated according to normal distribution. The X-axis is marked at intervals of 10 from 1 to 91, and the Y-axis is marked at intervals of 5000 from 0 to 45000. The signal starts at 0, increases to a peak at around the 51 mark, and then decreases back towards 0." class="center" src="../images\images/c23f002.png"/>
      <figcaption>
       <p>
        <span class="figureLabel">
         <a href="#R_c23-fig-0002" id="c23-fig-0002" role="doc-backlink">
          <b>
           FIGURE 23.2
          </b>
         </a>
        </span>
       </p>
      </figcaption>
     </figure>
     <p id="c23-para-0063">
      The graph clearly shows that most of the generated random numbers are around the center of the range. In this example, the value 50 is randomly chosen around 40,000 times, while values like 20 and 80 are chosen only around 500 times.
     </p>
    </section>
    <section aria-labelledby="head-2-242">
     <span id="c23-sec-0014">
     </span>
     <h2 id="head-2-242">
      SUMMARY
     </h2>
     <p id="c23-para-0064">
      In this chapter, you learned how to use the C++ random number generation library provided by the Standard Library to generate good-quality random numbers. You also saw how you can change the distribution of the generated numbers over a given range.
     </p>
     <p id="c23-para-0065">
      The next chapter is the last chapter of
      <a href="p03.xhtml">
       Part 3
      </a>
      of the book and introduces a number of additional vocabulary types that you will use often in your day-to-day coding.
     </p>
    </section>
    <section aria-labelledby="head-2-243">
     <span id="c23-sec-0015">
     </span>
     <h2 id="head-2-243">
      EXERCISES
     </h2>
     <p id="c23-para-0066">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c23-exsec-0001">
      </span>
      <ol class="none">
       <li id="c23-ex-0001">
        <b>
         Exercise 23-1:
        </b>
        Write a loop asking the user if dice should be thrown or not. If yes, throw a die twice using a uniform distribution and print the two numbers on the screen. If no, stop the program. Use the standard
        <code>
         mt19937
        </code>
        Mersenne twister engine. Do not create your random number generator directly in the function where you need it. Instead, write a function
        <code>
         createDiceValueGenerator()
        </code>
        that creates the correct random number generator object and returns it.
       </li>
       <li id="c23-ex-0002">
        <b>
         Exercise 23-2:
        </b>
        Modify your solution to Exercise 23-1 to use a
        <code>
         ranlux48
        </code>
        engine instead of the Mersenne twister.
       </li>
       <li id="c23-ex-0003">
        <b>
         Exercise 23-3:
        </b>
        Modify your solution to Exercise 23-1. Instead of directly using the
        <code>
         mt19937
        </code>
        Mersenne twister engine, adapt the engine with a
        <code>
         shuffle_order_engine
        </code>
        adapter.
       </li>
       <li id="c23-ex-0004">
        <b>
         Exercise 23-4:
        </b>
        Take the source code from earlier in this chapter used to generate histograms to make graphs of a distribution and experiment a bit with different distributions. Try to plot the graphs in a spreadsheet application to see the effects of a distribution. The code can be found in the downloadable source code archive in the folder
        <code>
         Ch23\01_Random
        </code>
        . You can take either the
        <code>
         07_uniform_int_distribution.cpp
        </code>
        or the
        <code>
         08_normal_distribution.cpp
        </code>
        file depending on whether your distribution uses integers or doubles.
        <p class="listPara1" id="c23-para-0071">
         <b>
          Bonus:
         </b>
         Besides exporting the data to a CSV file, draw the histogram on the standard output console using characters.
        </p>
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
