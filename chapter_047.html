<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   32Incorporating Design Techniques and Frameworks
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_046.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_048.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c32_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c32_1">
      <span aria-label="1155" class="calibre17" epub:type="pagebreak" id="Page_1155" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c32">
      </span>
      <span class="calibre">
       32
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Incorporating Design Techniques and Frameworks
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c32-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c32-list-0001">
         <li class="calibre9" id="c32-li-0001">
          An overview of C++ language features that are common, but for which you might have forgotten the syntax
         </li>
         <li class="calibre9" id="c32-li-0002">
          What RAII is and why it is a powerful concept
         </li>
         <li class="calibre9" id="c32-li-0003">
          What the double dispatch technique is and how to use it
         </li>
         <li class="calibre9" id="c32-li-0004">
          Various techniques to implement and use mixin classes
         </li>
         <li class="calibre9" id="c32-li-0005">
          What frameworks are
         </li>
         <li class="calibre9" id="c32-li-0006">
          The model-view-controller paradigm
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c32-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-317">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c32-sec-0003">
        </span>
        <p class="calibre25" id="c32-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c32-para-0005">
      One of the major themes of this book has been the adoption of reusable techniques and patterns. As a programmer, you tend to face similar problems repeatedly. With an arsenal of diverse approaches, you can save yourself time by applying the proper technique or pattern to a given problem.
     </p>
     <p class="calibre13" id="c32-para-0006">
      This chapter is about
      <i class="calibre18">
       design techniques
      </i>
      , while the next chapter is about
      <i class="calibre18">
       design patterns
      </i>
      . Both represent standard approaches for solving particular problems; however, design techniques are specific to C++, whereas design patterns are less language-specific. Often, a design technique
      <span aria-label="1156" class="calibre20" epub:type="pagebreak" id="Page_1156" role="doc-pagebreak">
      </span>
      aims to overcome an annoying feature or language deficiency. Other times, a design technique is a piece of code that you use in many different programs to solve a common C++ problem.
     </p>
     <p class="calibre13">
      Design techniques are C++ idioms that aren't necessarily built-in parts of the language but are nonetheless frequently used. The first part of this chapter covers the language features in C++ that are common, but for which you might have forgotten the syntax. This material is a review, but it is a useful reference tool when the syntax escapes you. The topics covered include the following:
     </p>
     <ul class="check" id="c32-list-0002">
      <li class="calibre9" id="c32-li-0007">
       Starting a class from scratch
      </li>
      <li class="calibre9" id="c32-li-0008">
       Extending a class by deriving from it
      </li>
      <li class="calibre9" id="c32-li-0009">
       Writing a lambda expression
      </li>
      <li class="calibre9" id="c32-li-0010">
       Implementing the copy-and-swap idiom
      </li>
      <li class="calibre9" id="c32-li-0011">
       Throwing and catching exceptions
      </li>
      <li class="calibre9" id="c32-li-0012">
       Defining a class template
      </li>
      <li class="calibre9" id="c32-li-0013">
       Constraining class and function template parameters
      </li>
      <li class="calibre9" id="c32-li-0014">
       Writing to a file
      </li>
      <li class="calibre9" id="c32-li-0015">
       Reading from a file
      </li>
     </ul>
     <p class="calibre13">
      The second part of this chapter focuses on higher-level techniques that build upon C++ language features. These techniques offer a better way to accomplish everyday programming tasks. Topics include the following:
     </p>
     <ul class="check" id="c32-list-0003">
      <li class="calibre9" id="c32-li-0016">
       Resource Acquisition Is Initialization (RAII)
      </li>
      <li class="calibre9" id="c32-li-0017">
       The double dispatch technique
      </li>
      <li class="calibre9" id="c32-li-0018">
       Mixin classes
      </li>
     </ul>
     <p class="calibre13" id="c32-para-0009">
      The chapter concludes with an introduction to frameworks, a coding technique that greatly eases the development of large applications.
     </p>
    </section>
    <section aria-labelledby="head-2-318" class="calibre2">
     <span class="calibre" id="c32-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-318">
      “I CAN NEVER REMEMBER HOW TO…”
     </h2>
     <p class="calibre13" id="c32-para-0010">
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library,” explains that the C++ standard specification is more than 2,000 pages long. The standard defines a lot of keywords and a very large number of language features. It is impossible to memorize it all. Even C++ experts need to look things up sometimes. With that in mind, this section presents examples of coding techniques that are used in almost all C++ programs. When you remember the concept but forgot the syntax, turn to the following sections for a refresher.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-566">
       …Write a Class
      </h3>
      <p class="calibre13">
       Don't remember how to get started? No problem—here is the definition of a
       <code class="calibre21">
        Simple
       </code>
       class defined in a module interface file:
      </p>
      <pre class="calibre26" id="c32-code-0001"><span aria-label="1157" class="calibre20" epub:type="pagebreak" id="Page_1157" role="doc-pagebreak"></span><code class="calibre21">export module simple;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// A simple class that illustrates class definition syntax.</span></code>
<code class="calibre21">export class Simple</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Simple();                              <span class="color">// Constructor</span></code>
<code class="calibre21">        virtual ~Simple() = default;           <span class="color">// Defaulted virtual destructor</span></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Disallow copy construction and copy assignment.</span></code>
<code class="calibre21">        Simple(const Simple&amp; src) = delete;</code>
<code class="calibre21">        Simple&amp; operator=(const Simple&amp; rhs) = delete;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Explicitly default move constructor and move assignment operator.</span></code>
<code class="calibre21">        Simple(Simple&amp;&amp; src) = default;</code>
<code class="calibre21">        Simple&amp; operator=(Simple&amp;&amp; rhs) = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        virtual void publicMemberFunction();   <span class="color">// Public member function</span></code>
<code class="calibre21">        int m_publicInteger;                   <span class="color">// Public data member</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    protected:</code>
<code class="calibre21">        virtual void protectedMemberFunction();<span class="color">// Protected member function</span></code>
<code class="calibre21">        int m_protectedInteger { 41 };         <span class="color">// Protected data member</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        virtual void privateMemberFunction();  <span class="color">// Private member function</span></code>
<code class="calibre21">        int m_privateInteger { 42 };           <span class="color">// Private data member</span></code>
<code class="calibre21">        static constexpr int Constant { 2 };   <span class="color">// Private constant</span></code>
<code class="calibre21">        static inline int ms_staticInt { 3 };  <span class="color">// Private static data member</span></code>
<code class="calibre21">};</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c32-para-0013">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           This class definition shows some things that are possible but not recommended. In your own class definitions, you should avoid having
          </i>
          <code class="calibre21">
           public
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           protected
          </code>
          <i class="calibre18">
           data members. A class should encapsulate its data; hence, you should make data members
          </i>
          <code class="calibre21">
           private
          </code>
          <i class="calibre18">
           and provide
          </i>
          <code class="calibre21">
           public
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           protected
          </code>
          <i class="calibre18">
           getter and setter member functions.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c32-para-0014">
       As explained in
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       , “Discovering Inheritance Techniques,” if your class is meant to be a base class for other classes, you must make at least your destructor
       <code class="calibre21">
        virtual
       </code>
       . It's allowed to leave the destructor non-
       <code class="calibre21">
        virtual
       </code>
       , but then I recommend to mark the class as
       <code class="calibre21">
        final
       </code>
       so that no other classes can derive from it. If you only want to make your destructor
       <code class="calibre21">
        virtual
       </code>
       but you don't need any code inside the destructor, then you can explicitly default it, as in the
       <code class="calibre21">
        Simple
       </code>
       class example.
      </p>
      <p class="calibre13" id="c32-para-0015">
       This example also demonstrates that you can explicitly delete or default special member functions. The copy constructor and copy assignment operator are deleted to prevent unintentional copying, while the move constructor and move assignment operator are explicitly defaulted.
      </p>
      <p class="calibre13">
       Next, here is the module implementation file:
      </p>
      <pre class="calibre26" id="c32-code-0002"><code class="calibre21">module simple;</code>
<code class="calibre21"> </code>
<code class="calibre21">Simple::Simple() : m_publicInteger { 40 }</code>
<span aria-label="1158" class="calibre20" epub:type="pagebreak" id="Page_1158" role="doc-pagebreak"></span><code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Implementation of constructor</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void Simple::publicMemberFunction() { <span class="color">/* Implementation */</span> }</code>
<code class="calibre21">void Simple::protectedMemberFunction() { <span class="color">/* Implementation */</span> }</code>
<code class="calibre21">void Simple::privateMemberFunction() { <span class="color">/* Implementation */</span> }</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c32-para-0018">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Class member function definitions can also appear directly in the module interface file as demonstrated in the next section. You are not required to split a class up into a module interface file and a module implementation file
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c32-para-0019">
       <a class="calibre5" href="c08.xhtml">
        Chapters 8
       </a>
       , “Gaining Proficiency with Classes and Objects,” and
       <a class="calibre5" href="c09.xhtml">
        9
       </a>
       , “Mastering Classes and Objects,” provide all the details for writing your own classes.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-567">
       …Derive from an Existing Class
      </h3>
      <p class="calibre13">
       To derive from an existing class, you declare a new class that is an extension of another class. Here is the definition for a class called
       <code class="calibre21">
        DerivedSimple
       </code>
       , deriving from
       <code class="calibre21">
        Simple
       </code>
       , and defined in a
       <code class="calibre21">
        derived_simple
       </code>
       module:
      </p>
      <pre class="calibre26" id="c32-code-0003"><code class="calibre21">export module derived_simple;</code>
<code class="calibre21"> </code>
<code class="calibre21">export import simple;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// A class derived from the Simple class.</span></code>
<code class="calibre21">export class DerivedSimple : public Simple</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        DerivedSimple() : Simple{} <span class="color">// Constructor</span></code>
<code class="calibre21">        { <span class="color">/* Implementation of constructor */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">        void publicMemberFunction() override <span class="color">// Overridden member function</span></code>
<code class="calibre21">        {</code>
<code class="calibre21">            <span class="color">// Implementation of overridden member function</span></code>
<code class="calibre21">            Simple::publicMemberFunction(); <span class="color">// Access the base class implementation</span></code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        virtual void anotherMemberFunction() <span class="color">// New member function</span></code>
<code class="calibre21">        { <span class="color">/* Implementation of new member function */</span> }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c32-para-0021">
       Consult
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       for details on inheritance techniques.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-568">
       …Write a Lambda Expression
      </h3>
      <p class="calibre13">
       Lambda expressions allow you to write small anonymous inline functions. They are especially powerful in combination with the C++ Standard Library algorithms. The following code snippet shows an example. It uses the
       <code class="calibre21">
        count_if()
       </code>
       algorithm and a lambda expression to count the number of even
       <span aria-label="1159" class="calibre20" epub:type="pagebreak" id="Page_1159" role="doc-pagebreak">
       </span>
       values in a
       <code class="calibre21">
        vector
       </code>
       . Additionally, the lambda expression captures the
       <code class="calibre21">
        callCount
       </code>
       variable by reference from its enclosing scope to keep track of the number of times it gets called.
      </p>
      <pre class="calibre26" id="c32-code-0004"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9 };</code>
<code class="calibre21">int callCount { 0 };</code>
<code class="calibre21">auto evenCount { ranges::count_if(values,</code>
<code class="calibre21">    [&amp;callCount](int value) {</code>
<code class="calibre21">        ++callCount;</code>
<code class="calibre21">        return value % 2 == 0;</code>
<code class="calibre21">    })</code>
<code class="calibre21">};</code>
<code class="calibre21">println("There are {} even elements in the vector.", evenCount);</code>
<code class="calibre21">println("Lambda was called {} times.", callCount);</code></pre>
      <p class="calibre13" id="c32-para-0023">
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       , “Function Pointers, Function Objects, and Lambda Expressions,” discusses lambda expressions in detail.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0010">
      </span>
      <h3 class="calibre27" id="head-3-569">
       …Use the Copy-and-Swap Idiom
      </h3>
      <p class="calibre13" id="c32-para-0024">
       The copy-and-swap idiom is discussed in detail in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       . It's an idiom to implement a possibly throwing operation on an object with a strong exception-safety guarantee, that is, all-or-nothing. You simply create a copy of the object, modify that copy (can be a complex algorithm, possibly throwing exceptions), and finally, when no exceptions have been thrown, swap the copy with the original object using a non-throwing
       <code class="calibre21">
        swap()
       </code>
       . An assignment operator is an example of an operation for which you can use the copy-and-swap idiom. Your assignment operator first makes a local copy of the source object and then swaps this copy with the current object using only a non-throwing
       <code class="calibre21">
        swap()
       </code>
       implementation.
      </p>
      <p class="calibre13">
       Here is a concise example of the copy-and-swap idiom used for a copy assignment operator. The class defines a copy constructor, a copy assignment operator, and a
       <code class="calibre21">
        swap()
       </code>
       member function marked as
       <code class="calibre21">
        noexcept
       </code>
       .
      </p>
      <pre class="calibre26" id="c32-code-0005"><code class="calibre21">export module copy_and_swap;</code>
<code class="calibre21"> </code>
<code class="calibre21">export class CopyAndSwap final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        CopyAndSwap() = default;</code>
<code class="calibre21">        ~CopyAndSwap();                                 <span class="color">// Destructor</span></code>
<code class="calibre21"> </code>
<code class="calibre21">        CopyAndSwap(const CopyAndSwap&amp; src);            <span class="color">// Copy constructor</span></code>
<code class="calibre21">        CopyAndSwap&amp; operator=(const CopyAndSwap&amp; rhs); <span class="color">// Copy assignment operator</span></code>
<code class="calibre21"> </code>
<code class="calibre21">        void swap(CopyAndSwap&amp; other) noexcept; <span class="color">// noexcept swap() member function</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Private data members…</span></code>
<code class="calibre21">};</code>
<code class="calibre21"><span class="color">// Standalone noexcept swap() function</span></code>
<code class="calibre21">export void swap(CopyAndSwap&amp; first, CopyAndSwap&amp; second) noexcept;</code></pre>
      <p class="calibre13">
       <span aria-label="1160" class="calibre20" epub:type="pagebreak" id="Page_1160" role="doc-pagebreak">
       </span>
       Here are the implementations:
      </p>
      <pre class="calibre26" id="c32-code-0006"><code class="calibre21">CopyAndSwap::~CopyAndSwap() { <span class="color">/* Implementation of destructor. */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">CopyAndSwap::CopyAndSwap(const CopyAndSwap&amp; src)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// This copy constructor can first delegate to a non-copy constructor</span></code>
<code class="calibre21">    <span class="color">// if any resource allocations have to be done. See the Spreadsheet</span></code>
<code class="calibre21">    <span class="color">// implementation in <a class="calibre5" href="c09.xhtml">Chapter 9</a> for an example.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Make a copy of all data members…</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void swap(CopyAndSwap&amp; first, CopyAndSwap&amp; second) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    first.swap(second);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CopyAndSwap::swap(CopyAndSwap&amp; other) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    using std::swap;</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Swap each data member, for example:</span></code>
<code class="calibre21">    <span class="color">// swap(m_data, other.m_data);</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">CopyAndSwap&amp; CopyAndSwap::operator=(const CopyAndSwap&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Copy-and-swap idiom.</span></code>
<code class="calibre21">    auto copy { rhs };  <span class="color">// Do all the work in a temporary instance.</span></code>
<code class="calibre21">    swap(copy);         <span class="color">// Commit the work with only non-throwing operations.</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c32-para-0027">
       Consult
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       for a more detailed discussion.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0011">
      </span>
      <h3 class="calibre27" id="head-3-570">
       …Throw and Catch Exceptions
      </h3>
      <p class="calibre13">
       If you've been working on a team that doesn't use exceptions (for shame!) or if you've gotten used to Java-style exceptions, the C++ syntax may escape you. Here's a refresher that uses the built-in exception class
       <code class="calibre21">
        std::runtime_error
       </code>
       . In most larger programs, you will write your own exception classes.
      </p>
      <pre class="calibre26" id="c32-code-0007"><code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">void throwIf(bool should)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (should) {</code>
<code class="calibre21">        throw runtime_error { "Here's my exception" };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<span aria-label="1161" class="calibre20" epub:type="pagebreak" id="Page_1161" role="doc-pagebreak"></span><code class="calibre21">        throwIf(false); <span class="color">// Doesn't throw.</span></code>
<code class="calibre21">        throwIf(true);  <span class="color">// Throws.</span></code>
<code class="calibre21">    } catch (const runtime_error&amp; e) {</code>
<code class="calibre21">        println(cerr, "Caught exception: {}", e.what());</code>
<code class="calibre21">        return 1;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c32-para-0029">
       <a class="calibre5" href="c14.xhtml">
        Chapter 14
       </a>
       , “Handling Errors,” discusses exceptions in more detail.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0012">
      </span>
      <h3 class="calibre27" id="head-3-571">
       …Write a Class Template
      </h3>
      <p class="calibre13">
       Template syntax can be confusing. The most forgotten piece of the template puzzle is that code that uses a class template needs to be able to see the class template definition as well as the member function implementations. The same holds for function templates. One technique to accomplish this is to simply put the class member function implementations directly in the interface file containing the class template definition. The following example demonstrates this and implements a class template that wraps a reference to an object and includes a getter. Here is the module interface file:
      </p>
      <pre class="calibre26" id="c32-code-0008"><code class="calibre21">export module simple_wrapper;</code>
<code class="calibre21"> </code>
<code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class SimpleWrapper</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit SimpleWrapper(T&amp; object) : m_object { object } { }</code>
<code class="calibre21">        T&amp; get() const { return m_object; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        T&amp; m_object;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The code can be tested as follows:
      </p>
      <pre class="calibre26" id="c32-code-0009"><code class="calibre21">import simple_wrapper;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Try wrapping an integer.</span></code>
<code class="calibre21">    int i { 7 };</code>
<code class="calibre21">    SimpleWrapper intWrapper { i };  <span class="color">// Using CTAD.</span></code>
<code class="calibre21">    <span class="color">// Or without class template argument deduction (CTAD).</span></code>
<code class="calibre21">    SimpleWrapper&lt;int&gt; intWrapper2 { i }; </code>
<code class="calibre21">    i = 2;</code>
<code class="calibre21">    println("wrapped value is {}", intWrapper.get());</code>
<code class="calibre21">    println("wrapped value is {}", intWrapper2.get());</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Try wrapping a string.</span></code>
<code class="calibre21">    string str { "test" };</code>
<code class="calibre21">    SimpleWrapper stringWrapper { str };</code>
<code class="calibre21">    str += "!";</code>
<code class="calibre21">    println("wrapped value is {}", stringWrapper.get());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c32-para-0032">
       <span aria-label="1162" class="calibre20" epub:type="pagebreak" id="Page_1162" role="doc-pagebreak">
       </span>
       Details about templates can be found in
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       , “Writing Generic Code with Templates,” and
       <a class="calibre5" href="c26.xhtml">
        Chapter 26
       </a>
       , “Advanced Templates.”
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0013">
      </span>
      <h3 class="calibre27" id="head-3-572">
       …Constrain Template Parameters
      </h3>
      <p class="calibre13">
       With concepts, you can put constraints on template parameters of class and function templates. For example, the following code snippet constrains the template type parameter
       <code class="calibre21">
        T
       </code>
       of the
       <code class="calibre21">
        SimpleWrapper
       </code>
       class template from the previous section to be either a floating-point or an integral type. Specifying a type for
       <code class="calibre21">
        T
       </code>
       that does not satisfy these constraints will cause a compilation error.
      </p>
      <pre class="calibre26" id="c32-code-0010"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">export template &lt;typename T&gt; requires (std::floating_point&lt;T&gt; || std::integral&lt;T&gt;)</code>
<code class="calibre21">class SimpleWrapper</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit SimpleWrapper(T&amp; object) : m_object { object } { }</code>
<code class="calibre21">        T&amp; get() const { return m_object; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        T&amp; m_object;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c32-para-0034">
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       explains concepts in detail.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0014">
      </span>
      <h3 class="calibre27" id="head-3-573">
       …Write to a File
      </h3>
      <p class="calibre13">
       The following program outputs a message to a file and then reopens the file and appends another message. Additional details can be found in
       <a class="calibre5" href="c13.xhtml">
        Chapter 13
       </a>
       , “Demystifying C++ I/O.”
      </p>
      <pre class="calibre26" id="c32-code-0011"><code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    ofstream outputFile { "FileWrite.out" };</code>
<code class="calibre21">    if (outputFile.fail()) {</code>
<code class="calibre21">        println(cerr, "Unable to open file for writing.");</code>
<code class="calibre21">        return 1;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    outputFile &lt;&lt; "Hello!" &lt;&lt; endl;</code>
<code class="calibre21">    outputFile.close();</code>
<code class="calibre21"> </code>
<code class="calibre21">    ofstream appendFile { "FileWrite.out", ios_base::app };</code>
<code class="calibre21">    if (appendFile.fail()) {</code>
<code class="calibre21">        println(cerr, "Unable to open file for appending.");</code>
<code class="calibre21">        return 2;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    appendFile &lt;&lt; "World!" &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0015">
      </span>
      <h3 class="calibre27" id="head-3-574">
       …Read from a File
      </h3>
      <p class="calibre13">
       Details for file input are discussed in
       <a class="calibre5" href="c13.xhtml">
        Chapter 13
       </a>
       . Here is a quick sample program for file reading basics. It reads the file written by the program in the previous section and outputs it one whitespace-separated token at a time.
      </p>
      <pre class="calibre26" id="c32-code-0012"><span aria-label="1163" class="calibre20" epub:type="pagebreak" id="Page_1163" role="doc-pagebreak"></span><code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputFile { "FileWrite.out" };</code>
<code class="calibre21">    if (inputFile.fail()) {</code>
<code class="calibre21">        println(cerr, "Unable to open file for reading.");</code>
<code class="calibre21">        return 1;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    string nextToken;</code>
<code class="calibre21">    while (inputFile &gt;&gt; nextToken) {</code>
<code class="calibre21">        println("Token: {}", nextToken);</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The following reads an entire text file with a single call to
       <code class="calibre21">
        getline()
       </code>
       . This doesn't work with binary files, as they might contain
       <code class="calibre21">
        \0
       </code>
       characters in their contents.
      </p>
      <pre class="calibre26" id="c32-code-0013"><code class="calibre21">string fileContents;</code>
<code class="calibre21">getline(inputFile, fileContents, '\0');</code>
<code class="calibre21">println("{}", fileContents);</code></pre>
      <p class="calibre13">
       An alternative is to use an
       <code class="calibre21">
        istreambuf_iterator
       </code>
       (see
       <a class="calibre5" href="c17.xhtml">
        Chapter 17
       </a>
       , “Understanding Iterators and the Ranges Library”):
      </p>
      <pre class="calibre26" id="c32-code-0014"><code class="calibre21">string fileContents {</code>
<code class="calibre21">    istreambuf_iterator&lt;char&gt; { inputFile },</code>
<code class="calibre21">    istreambuf_iterator&lt;char&gt; { }</code>
<code class="calibre21">};</code>
<code class="calibre21">println("{}", fileContents);</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-319" class="calibre2">
     <span class="calibre" id="c32-sec-0016">
     </span>
     <h2 class="calibre6" id="head-2-319">
      THERE MUST BE A BETTER WAY
     </h2>
     <p class="calibre13" id="c32-para-0039">
      As you read this paragraph, thousands of C++ programmers throughout the world are solving problems that have already been solved. Someone in a cubicle in San Jose is writing a smart pointer implementation from scratch that uses reference counting. A young programmer on a Mediterranean island is designing a class hierarchy that could benefit immensely from the use of mixin classes.
     </p>
     <p class="calibre13" id="c32-para-0040">
      As a professional C++ programmer, you ought to spend less of your time reinventing the wheel and more of your time adapting reusable concepts in new ways. This section gives some examples of general-purpose approaches that you can apply directly to your own programs or customize for your needs.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-575">
       Resource Acquisition Is Initialization
      </h3>
      <p class="calibre13" id="c32-para-0041">
       <i class="calibre18">
        Resource acquisition is initialization
       </i>
       (RAII) is a simple yet powerful concept. It is used to acquire ownership of some resources and to automatically free these acquired resources when an RAII instance goes out of scope. Both initialization and destruction happen at a deterministic point in time. Basically, the constructor of a new RAII instance
       <i class="calibre18">
        acquires ownership
       </i>
       of a certain resource and
       <i class="calibre18">
        initializes
       </i>
       the instance with that resource, which is why it's called
       <i class="calibre18">
        resource acquisition is initialization
       </i>
       . The destructor automatically frees the acquired resource when the RAII instance is destroyed.
      </p>
      <p class="calibre13">
       <span aria-label="1164" class="calibre20" epub:type="pagebreak" id="Page_1164" role="doc-pagebreak">
       </span>
       Here is an example of a
       <code class="calibre21">
        File
       </code>
       RAII class that safely wraps a C-style file handle (
       <code class="calibre21">
        std::FILE
       </code>
       ) and automatically closes the file when the RAII instance goes out of scope. The RAII class also provides
       <code class="calibre21">
        get()
       </code>
       ,
       <code class="calibre21">
        release()
       </code>
       , and
       <code class="calibre21">
        reset()
       </code>
       member functions that behave similarly to the same member functions on certain Standard Library classes, such as
       <code class="calibre21">
        std::unique_ptr
       </code>
       . RAII classes usually disallow copy construction and copy assignment; hence, this implementation deletes those members.
      </p>
      <pre class="calibre26" id="c32-code-0015"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">class File final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit File(std::FILE* file) : m_file { file } { }</code>
<code class="calibre21">        ~File() { reset(); }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Prevent copy construction and copy assignment.</span></code>
<code class="calibre21">        File(const File&amp; src) = delete;</code>
<code class="calibre21">        File&amp; operator=(const File&amp; rhs) = delete;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Allow move construction.</span></code>
<code class="calibre21">        File(File&amp;&amp; src) noexcept : m_file { std::exchange(src.m_file, nullptr) }</code>
<code class="calibre21">        {</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Allow move assignment.</span></code>
<code class="calibre21">        File&amp; operator=(File&amp;&amp; rhs) noexcept</code>
<code class="calibre21">        {</code>
<code class="calibre21">            if (this != &amp;rhs) {</code>
<code class="calibre21">                reset();</code>
<code class="calibre21">                m_file = std::exchange(rhs.m_file, nullptr);</code>
<code class="calibre21">            }</code>
<code class="calibre21">            return *this;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// get(), release(), and reset()</span></code>
<code class="calibre21">        std::FILE* get() const noexcept { return m_file; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        [[nodiscard]] std::FILE* release() noexcept</code>
<code class="calibre21">        {</code>
<code class="calibre21">            return std::exchange(m_file, nullptr);</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        void reset(std::FILE* file = nullptr) noexcept</code>
<code class="calibre21">        {</code>
<code class="calibre21">            if (m_file) { std::fclose(m_file); }</code>
<code class="calibre21">            m_file = file;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::FILE* m_file { nullptr };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       It can be used as follows:
      </p>
      <pre class="calibre26" id="c32-code-0016"><code class="calibre21">File myFile { std::fopen("input.txt", "r") };</code></pre>
      <p class="calibre13" id="c32-para-0044">
       <span aria-label="1165" class="calibre20" epub:type="pagebreak" id="Page_1165" role="doc-pagebreak">
       </span>
       As soon as the
       <code class="calibre21">
        myFile
       </code>
       instance goes out of scope, its destructor is called, and the file is automatically closed.
      </p>
      <p class="calibre13">
       There is one important pitfall with using RAII classes that you need to be aware of. You can accidentally write a statement that you think is properly creating an RAII instance within a certain scope, but that is instead creating a temporary object, which is immediately destroyed when that statement has finished executing. For example, the following statement correctly uses the
       <code class="calibre21">
        File
       </code>
       RAII class:
      </p>
      <pre class="calibre26" id="c32-code-0017"><code class="calibre21">File <b class="calibre14">myFile</b> { std::fopen("input.txt", "r") };</code></pre>
      <p class="calibre13">
       However, you could accidentally forget to give the RAII instance a name as follows:
      </p>
      <pre class="calibre26" id="c32-code-0018"><code class="calibre21">File { std::fopen("input.txt", "r") };</code></pre>
      <p class="calibre13">
       This statement creates a temporary
       <code class="calibre21">
        File
       </code>
       instance, which is immediately destroyed at the end of the statement. This does not trigger any warning or error from the compiler. To avoid this, you should mark the constructor of RAII classes with the
       <code class="calibre21">
        [[nodiscard]]
       </code>
       attribute. For example:
      </p>
      <pre class="calibre26" id="c32-code-0019"><code class="calibre21">[[nodiscard]] explicit File(std::FILE* file) : m_file{ file } { }</code></pre>
      <p class="calibre13">
       With this change, creating a
       <code class="calibre21">
        File
       </code>
       instance without giving it a name triggers a compiler warning such as the following:
      </p>
      <pre class="calibre26" id="c32-code-0020"><code class="calibre21">warning C4834: discarding return value of function with 'nodiscard' attribute </code></pre>
      <p class="calibre13">
       Of course, with the
       <code class="calibre21">
        File
       </code>
       RAII class, you probably will never forget to give it a name as you most likely will want to do something with the opened file. However, sometimes you need to create an instance of an RAII class in a certain scope, without having to directly interact any further with that created instance, e.g., mutex locks. Let's look at such an example using an RAII class from the Standard Library,
       <code class="calibre21">
        std::unique_lock
       </code>
       (see
       <a class="calibre5" href="c27.xhtml">
        Chapter 27
       </a>
       , “Multithreaded Programming with C++”). The following code snippet shows proper use of a
       <code class="calibre21">
        unique_lock
       </code>
       . I'm initially not using the uniform initialization syntax to initialize the
       <code class="calibre21">
        unique_lock
       </code>
       but will get back to this in the subsequent discussion.
      </p>
      <pre class="calibre26" id="c32-code-0021"><code class="calibre21">class Foo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setData()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            <b class="calibre14">unique_lock&lt;mutex&gt; lock(m_mutex);</b></code>
<code class="calibre21">            <span class="color">// …</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        mutex m_mutex;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c32-para-0050">
       The
       <code class="calibre21">
        setData()
       </code>
       member function uses the
       <code class="calibre21">
        unique_lock
       </code>
       RAII class to construct a local
       <code class="calibre21">
        lock
       </code>
       object that locks the
       <code class="calibre21">
        m_mutex
       </code>
       data member and automatically unlocks that mutex at the end of the function.
      </p>
      <p class="calibre13">
       However, because you do not directly use the
       <code class="calibre21">
        lock
       </code>
       variable after it has been defined, it is easy to make the following mistake:
      </p>
      <pre class="calibre26" id="c32-code-0022"><code class="calibre21">unique_lock&lt;mutex&gt;(m_mutex);</code></pre>
      <p class="calibre13">
       In this code, you accidentally forgot to give the
       <code class="calibre21">
        unique_lock
       </code>
       a name. This compiles, but it does not do what you intended it to do! It actually declares a local variable called
       <code class="calibre21">
        m_mutex
       </code>
       (hiding the
       <span aria-label="1166" class="calibre20" epub:type="pagebreak" id="Page_1166" role="doc-pagebreak">
       </span>
       <code class="calibre21">
        m_mutex
       </code>
       data member) and initializes it with a call to the
       <code class="calibre21">
        unique_lock
       </code>
       's default constructor. The result is that the
       <code class="calibre21">
        m_mutex
       </code>
       data member is
       <i class="calibre18">
        not
       </i>
       locked! The compiler will give a warning, though, if the warning level is set high enough. Something along the lines of:
      </p>
      <pre class="calibre26" id="c32-code-0023"><code class="calibre21">warning C4458: declaration of 'm_mutex' hides class member</code></pre>
      <p class="calibre13">
       If you use uniform initialization syntax as follows, the compiler doesn't generate the “hiding class member” warning, but it also does not do what you want. The following creates a temporary lock on
       <code class="calibre21">
        m_mutex
       </code>
       , but since it's temporary, the lock is immediately released at the end of this statement.
      </p>
      <pre class="calibre26" id="c32-code-0024"><code class="calibre21">unique_lock&lt;mutex&gt; { m_mutex };</code></pre>
      <p class="calibre13" id="c32-para-0054">
       Recently, some compilers actually do mark the
       <code class="calibre21">
        unique_lock
       </code>
       constructors with
       <code class="calibre21">
        [[nodiscard]]
       </code>
       , just as I recommended with the
       <code class="calibre21">
        File
       </code>
       RAII example. One such compiler is Visual C++ 2022. If you use such a compiler, the previous statement generates a warning about the fact that the return value of the constructor is discarded.
      </p>
      <p class="calibre13">
       Additionally, you could make a typo in the name passed as argument, for example as follows:
      </p>
      <pre class="calibre26" id="c32-code-0025"><code class="calibre21">unique_lock&lt;mutex&gt;(m);</code></pre>
      <p class="calibre13">
       Here you forgot to give a name for the lock, and you made a typo in the name of the argument. This code simply declares a local variable called
       <code class="calibre21">
        m
       </code>
       and initializes it with the default constructor of
       <code class="calibre21">
        unique_lock
       </code>
       . The compiler does not even generate a warning, unless maybe a warning that
       <code class="calibre21">
        m
       </code>
       is an unreferenced local variable. In this case, though, if you would use uniform initialization syntax as follows, then the compiler issues an error complaining about an undeclared identifier
       <code class="calibre21">
        m
       </code>
       :
      </p>
      <pre class="calibre26" id="c32-code-0026"><code class="calibre21">unique_lock&lt;mutex&gt; { m };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c32-para-0058">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Make sure you always name your RAII instances! Additionally, I recommend not to include a default constructor in an RAII class. That avoids some of the issues discussed here
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0019">
      </span>
      <h3 class="calibre27" id="head-3-576">
       Double Dispatch
      </h3>
      <p class="calibre13" id="c32-para-0059">
       <i class="calibre18">
        Double dispatch
       </i>
       is a technique that adds an extra dimension to the concept of polymorphism. As described in
       <a class="calibre5" href="c05.xhtml">
        Chapter 5
       </a>
       , “Designing with Classes,” polymorphism lets the program determine behavior based on types at run time. For example, you could have an
       <code class="calibre21">
        Animal
       </code>
       class with a
       <code class="calibre21">
        move()
       </code>
       member function. All
       <code class="calibre21">
        Animal
       </code>
       s move, but they differ in terms of
       <i class="calibre18">
        how
       </i>
       they move. The
       <code class="calibre21">
        move()
       </code>
       member function is defined for every derived class of
       <code class="calibre21">
        Animal
       </code>
       so that the appropriate member function can be called, or can be dispatched to, for the appropriate animal at run time without knowing the type of the animal at compile time.
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       explains how to use virtual member functions to implement this run-time polymorphism.
      </p>
      <p class="calibre13" id="c32-para-0060">
       Sometimes, however, you need a member function to behave according to the run-time type of two objects, instead of just one. For example, suppose you want to add a member function to the
       <code class="calibre21">
        Animal
       </code>
       class that returns
       <code class="calibre21">
        true
       </code>
       if the animal eats another animal, and
       <code class="calibre21">
        false
       </code>
       otherwise. The decision is based on two factors: the type of animal doing the eating and the type of animal being eaten. Unfortunately, C++ provides no language mechanism to choose a behavior based on the run-time type of more
       <span aria-label="1167" class="calibre20" epub:type="pagebreak" id="Page_1167" role="doc-pagebreak">
       </span>
       than one object. Virtual member functions alone are insufficient for modeling this scenario because they determine a member function, or behavior, depending on the run-time type of only the receiving object.
      </p>
      <p class="calibre13">
       Some object-oriented languages provide the ability to choose a member function at run time based on the run-time types of two or more objects. They call this feature
       <i class="calibre18">
        multimethods
       </i>
       . In C++ there is no core language feature to support multimethods, but you can use the
       <i class="calibre18">
        double dispatch
       </i>
       technique, which provides a way to make functions virtual for more than one object.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c32-para-0062">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Double dispatch is really a special case of multiple dispatch, in which a behavior is chosen depending on the run-time types of two or more objects. In practice, double dispatch, which chooses a behavior based on the run-time types of exactly two objects, is usually sufficient
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0021">
       </span>
       <h4 class="calibre29" id="head-4-435">
        Attempt #1: Brute Force
       </h4>
       <p class="calibre13">
        The most straightforward way to implement a member function whose behavior depends on the run-time types of two different objects is to take the perspective of one of the objects and use a series of
        <code class="calibre21">
         if
        </code>
        /
        <code class="calibre21">
         else
        </code>
        constructs to check the type of the other. For example, you could implement a member function called
        <code class="calibre21">
         eats()
        </code>
        in each class derived from
        <code class="calibre21">
         Animal
        </code>
        that takes the other animal as a parameter. The member function is declared pure virtual in the base class as follows:
       </p>
       <pre class="calibre26" id="c32-code-0027"><code class="calibre21">class Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual bool eats(const Animal&amp; prey) const = 0;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Each derived class implements the
        <code class="calibre21">
         eats()
        </code>
        member function and returns the appropriate value based on the type of the parameter. The implementation of
        <code class="calibre21">
         eats()
        </code>
        for several derived classes follows. Note that the
        <code class="calibre21">
         TRex
        </code>
        avoids any
        <code class="calibre21">
         if
        </code>
        statements because—according to the author—a T-rex, like any carnivorous dinosaur, eats anything.
       </p>
       <pre class="calibre26" id="c32-code-0028"><code class="calibre21">bool Bear::eats(const Animal&amp; prey) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (typeid(prey) == typeid(Fish)) { return true; }</code>
<code class="calibre21">    return false;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">bool Fish::eats(const Animal&amp; prey) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (typeid(prey) == typeid(Fish)) { return true; }</code>
<code class="calibre21">    return false;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">bool TRex::eats(const Animal&amp; prey) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="1168" class="calibre20" epub:type="pagebreak" id="Page_1168" role="doc-pagebreak">
        </span>
        This brute-force approach works, and it's probably the most straightforward technique for a small number of classes. However, there are several reasons why you might want to avoid this approach.
       </p>
       <ul class="check" id="c32-list-0004">
        <li class="calibre9" id="c32-li-0019">
         Object-oriented programming (OOP) purists often frown upon explicitly querying the type of an object because it implies a design that is lacking a proper object-oriented structure.
        </li>
        <li class="calibre9" id="c32-li-0020">
         As the number of types grows, such code can become messy and repetitive.
        </li>
        <li class="calibre9" id="c32-li-0021">
         This approach does not force derived classes to consider new types. For example, if you added a
         <code class="calibre21">
          Donkey
         </code>
         , the
         <code class="calibre21">
          Bear
         </code>
         class would continue to compile but would return
         <code class="calibre21">
          false
         </code>
         when told to eat a
         <code class="calibre21">
          Donkey
         </code>
         , even though everybody knows that bears eat donkeys. A bear would refuse to eat a donkey because there is no
         <code class="calibre21">
          else if
         </code>
         statement checking explicitly for
         <code class="calibre21">
          Donkey
         </code>
         s.
        </li>
       </ul>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0022">
       </span>
       <h4 class="calibre29" id="head-4-436">
        Attempt #2: Single Polymorphism with Overloading
       </h4>
       <p class="calibre13">
        You could attempt to use polymorphism with overloading to circumvent all of the cascading
        <code class="calibre21">
         if
        </code>
        /
        <code class="calibre21">
         else
        </code>
        constructs. Instead of giving each class a single
        <code class="calibre21">
         eats()
        </code>
        member function that takes an
        <code class="calibre21">
         Animal
        </code>
        reference, why not overload the member function for each derived class of
        <code class="calibre21">
         Animal
        </code>
        ? The base class definition would look like this:
       </p>
       <pre class="calibre26" id="c32-code-0029"><code class="calibre21">class Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual bool eats(const Bear&amp;) const = 0;</code>
<code class="calibre21">        virtual bool eats(const Fish&amp;) const = 0;</code>
<code class="calibre21">        virtual bool eats(const TRex&amp;) const = 0;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Because the member functions are pure virtual in the base class, each derived class is forced to implement the behavior for every other type of
        <code class="calibre21">
         Animal
        </code>
        . For example, the
        <code class="calibre21">
         Bear
        </code>
        class contains the following member functions:
       </p>
       <pre class="calibre26" id="c32-code-0030"><code class="calibre21">class Bear : public Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        bool eats(const Bear&amp;) const override { return false; }</code>
<code class="calibre21">        bool eats(const Fish&amp;) const override { return true; }</code>
<code class="calibre21">        bool eats(const TRex&amp;) const override { return false; }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        This approach initially appears to work, but it really solves only half of the problem. To call the proper
        <code class="calibre21">
         eats()
        </code>
        member function on an
        <code class="calibre21">
         Animal
        </code>
        , the compiler needs to know the compile-time type of the animal being eaten. A call such as the following will be successful because the compile-time types of both the animal that eats and the animal that is eaten are known:
       </p>
       <pre class="calibre26" id="c32-code-0031"><code class="calibre21">Bear myBear;</code>
<code class="calibre21">Fish myFish;</code>
<code class="calibre21">println("Bear eats fish? {}", myBear.eats(myFish));</code></pre>
       <p class="calibre13">
        The missing piece is that the solution is polymorphic in only one direction. You can access
        <code class="calibre21">
         myBear
        </code>
        through an
        <code class="calibre21">
         Animal
        </code>
        reference, and the correct member function will be called:
       </p>
       <pre class="calibre26" id="c32-code-0032"><code class="calibre21">Animal&amp; animalRef { myBear };</code>
<code class="calibre21">println("Bear eats fish? {}", animalRef.eats(myFish));</code></pre>
       <p class="calibre13">
        <span aria-label="1169" class="calibre20" epub:type="pagebreak" id="Page_1169" role="doc-pagebreak">
        </span>
        However, the reverse is not true. If you pass an
        <code class="calibre21">
         Animal
        </code>
        reference to the
        <code class="calibre21">
         eats()
        </code>
        member function, you will get a compilation error because there is no
        <code class="calibre21">
         eats()
        </code>
        member function that takes an
        <code class="calibre21">
         Animal
        </code>
        . The compiler cannot determine, at compile time, which version to call. The following example does not compile:
       </p>
       <pre class="calibre26" id="c32-code-0033"><code class="calibre21">Animal&amp; animalRef { myFish };</code>
<code class="calibre21">println("Bear eats fish? {}",</code>
<code class="calibre21">    myBear.eats(animalRef)); <span class="color">// BUG! No member function Bear::eats(Animal&amp;)</span></code></pre>
       <p class="calibre13" id="c32-para-0071">
        Because the compiler needs to know which overloaded version of the
        <code class="calibre21">
         eats()
        </code>
        member function is going to be called at compile time, this solution is not truly polymorphic. It would not work, for example, if you were iterating over an array of
        <code class="calibre21">
         Animal
        </code>
        references and passing each one to a call to
        <code class="calibre21">
         eats()
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0023">
       </span>
       <h4 class="calibre29" id="head-4-437">
        Attempt #3: Double Dispatch
       </h4>
       <p class="calibre13" id="c32-para-0072">
        The
        <i class="calibre18">
         double dispatch
        </i>
        technique is a truly polymorphic solution to the multiple-type problem. In C++, polymorphism is achieved by overriding member functions in derived classes. At run time, member functions are called based on the actual type of the object. The preceding single polymorphic attempt didn't work because it attempted to use polymorphism to determine which overloaded version of a member function to call instead of using it to determine on which class to call the member function.
       </p>
       <p class="calibre13">
        To begin, focus on a single derived class, perhaps the
        <code class="calibre21">
         Bear
        </code>
        class. The class needs a member function with the following declaration:
       </p>
       <pre class="calibre26" id="c32-code-0034"><code class="calibre21">bool eats(const Animal&amp; prey) const override;</code></pre>
       <p class="calibre13">
        The key to double dispatch is to determine the result based on a member function call on the argument. Suppose that the
        <code class="calibre21">
         Animal
        </code>
        class has a member function called
        <code class="calibre21">
         eatenBy()
        </code>
        , which takes an
        <code class="calibre21">
         Animal
        </code>
        reference as a parameter. This member function returns
        <code class="calibre21">
         true
        </code>
        if the current
        <code class="calibre21">
         Animal
        </code>
        gets eaten by the one passed in. With such a member function, the definition of
        <code class="calibre21">
         eats()
        </code>
        becomes simple:
       </p>
       <pre class="calibre26" id="c32-code-0035"><code class="calibre21">bool Bear::eats(const Animal&amp; prey) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return prey.eatenBy(*this);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c32-para-0075">
        At first, it looks like this solution adds another layer of member function calls to the single polymorphic member function. After all, each derived class still has to implement a version of
        <code class="calibre21">
         eatenBy()
        </code>
        for every derived class of
        <code class="calibre21">
         Animal
        </code>
        . However, there is a key difference. Polymorphism is occurring twice! When you call the
        <code class="calibre21">
         eats()
        </code>
        member function on an
        <code class="calibre21">
         Animal
        </code>
        , polymorphism determines whether you are calling
        <code class="calibre21">
         Bear::eats()
        </code>
        ,
        <code class="calibre21">
         Fish::eats()
        </code>
        , or one of the others. When you call
        <code class="calibre21">
         eatenBy()
        </code>
        , polymorphism again determines which class's version of the member function to call. It calls
        <code class="calibre21">
         eatenBy()
        </code>
        on the run-time type of the
        <code class="calibre21">
         prey
        </code>
        object. Note that the run-time type of
        <code class="calibre21">
         *this
        </code>
        is always the same as the compile-time type so that the compiler can call the correct overloaded version of
        <code class="calibre21">
         eatenBy()
        </code>
        for the argument (in this case
        <code class="calibre21">
         Bear
        </code>
        ).
       </p>
       <p class="calibre13">
        The following are the class definitions for the
        <code class="calibre21">
         Animal
        </code>
        hierarchy using double dispatch. The forward class declarations are necessary because the base class uses references to the derived classes. Note that each
        <code class="calibre21">
         Animal
        </code>
        -derived class implements the
        <code class="calibre21">
         eats()
        </code>
        member function in the same way, but it cannot be factored up into the base class. The reason is that if you attempt to do so, the compiler won't know
        <span aria-label="1170" class="calibre20" epub:type="pagebreak" id="Page_1170" role="doc-pagebreak">
        </span>
        which overloaded version of the
        <code class="calibre21">
         eatenBy()
        </code>
        member function to call because
        <code class="calibre21">
         *this
        </code>
        would be an
        <code class="calibre21">
         Animal
        </code>
        , not a particular derived class. Member function overload resolution is determined according to the compile-time type of the object, not its run-time type.
       </p>
       <pre class="calibre26" id="c32-code-0036"><code class="calibre21"><span class="color">// Forward declarations.</span></code>
<code class="calibre21">class Fish;</code>
<code class="calibre21">class Bear;</code>
<code class="calibre21">class TRex;</code>
<code class="calibre21"> </code>
<code class="calibre21">class Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual bool eats(const Animal&amp; prey) const = 0;</code>
<code class="calibre21"> </code>
<code class="calibre21">        virtual bool eatenBy(const Bear&amp;) const = 0;</code>
<code class="calibre21">        virtual bool eatenBy(const Fish&amp;) const = 0;</code>
<code class="calibre21">        virtual bool eatenBy(const TRex&amp;) const = 0;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Bear : public Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        bool eats(const Animal&amp; prey) const override{ return prey.eatenBy(*this); }</code>
<code class="calibre21"> </code>
<code class="calibre21">        bool eatenBy(const Bear&amp;) const override { return false; }</code>
<code class="calibre21">        bool eatenBy(const Fish&amp;) const override { return false; }</code>
<code class="calibre21">        bool eatenBy(const TRex&amp;) const override { return true; }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Fish : public Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        bool eats(const Animal&amp; prey) const override{ return prey.eatenBy(*this); }</code>
<code class="calibre21"> </code>
<code class="calibre21">        bool eatenBy(const Bear&amp;) const override { return true; }</code>
<code class="calibre21">        bool eatenBy(const Fish&amp;) const override { return true; }</code>
<code class="calibre21">        bool eatenBy(const TRex&amp;) const override { return true; }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class TRex : public Animal</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        bool eats(const Animal&amp; prey) const override{ return prey.eatenBy(*this); }</code>
<code class="calibre21"> </code>
<code class="calibre21">        bool eatenBy(const Bear&amp;) const override { return false; }</code>
<code class="calibre21">        bool eatenBy(const Fish&amp;) const override { return false; }</code>
<code class="calibre21">        bool eatenBy(const TRex&amp;) const override { return true; }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c32-para-0077">
        Double dispatch is a concept that takes a bit of getting used to. I suggest playing with this code to familiarize yourself with the concept and its implementation.
       </p>
      </section>
     </section>
     <span aria-label="1171" class="calibre20" epub:type="pagebreak" id="Page_1171" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0024">
      </span>
      <h3 class="calibre27" id="head-3-577">
       Mixin Classes
      </h3>
      <p class="calibre13">
       <a class="calibre5" href="c05.xhtml">
        Chapters 5
       </a>
       and
       <a class="calibre5" href="c06.xhtml">
        6
       </a>
       , “Designing for Reuse,” introduce mixin classes. They answer the question, “What else is this class able to do?” and the answer often ends with “-able.” Examples are
       <code class="calibre21">
        Clickable
       </code>
       ,
       <code class="calibre21">
        Drawable
       </code>
       ,
       <code class="calibre21">
        Printable
       </code>
       ,
       <code class="calibre21">
        Lovable
       </code>
       , and so on. Mixin classes are a way that you can add functionality to a class without committing to a full
       <i class="calibre18">
        is-a
       </i>
       relationship. There are several techniques to implement mixin classes in C++. This section looks at the following:
      </p>
      <ul class="check" id="c32-list-0005">
       <li class="calibre9" id="c32-li-0022">
        Using multiple inheritance
       </li>
       <li class="calibre9" id="c32-li-0023">
        Using class templates
       </li>
       <li class="calibre9" id="c32-li-0024">
        Using CRTP
       </li>
       <li class="calibre9" id="c32-li-0025">
        Using CRTP and “deducing
        <code class="calibre21">
         this
        </code>
        ”
       </li>
      </ul>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0025">
       </span>
       <h4 class="calibre29" id="head-4-438">
        Using Multiple Inheritance
       </h4>
       <p class="calibre13" id="c32-para-0079">
        This section examines how to design, implement, and use a mixin class using the multiple inheritance technique.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c32-sec-0026">
        </span>
        <h5 class="calibre35" id="head-5-189">
         Designing a Mixin Class
        </h5>
        <p class="calibre13" id="c32-para-0080">
         Mixin classes contain actual code that can be reused by other classes. A single mixin class implements a well-defined piece of functionality. For example, you might have a mixin class called
         <code class="calibre21">
          Playable
         </code>
         that is mixed into certain types of media objects. The mixin class could, for example, contain most of the code to communicate with the computer's sound drivers. By mixing in the class, the media object would get that functionality for free.
        </p>
        <p class="calibre13" id="c32-para-0081">
         When designing a mixin class, you need to consider what behavior you are adding and whether it belongs in the object hierarchy or in a separate class. Using the previous example, if all media classes are playable, the base class should derive from
         <code class="calibre21">
          Playable
         </code>
         instead of mixing the
         <code class="calibre21">
          Playable
         </code>
         class into all of the derived classes. If only certain media classes are playable and they are scattered throughout the hierarchy, a mixin class makes sense.
        </p>
        <p class="calibre13" id="c32-para-0082">
         One of the cases where mixin classes are particularly useful is when you have classes organized into a hierarchy on one axis, but they also contain similarities on another axis. For example, consider a war simulation game played on a grid. Each grid location can contain an
         <code class="calibre21">
          Item
         </code>
         with attack and defense capabilities and other characteristics. Some items, such as a
         <code class="calibre21">
          Castle
         </code>
         , are stationary. Others, such as a
         <code class="calibre21">
          Knight
         </code>
         or
         <code class="calibre21">
          FloatingCastle
         </code>
         , can move throughout the grid. When initially designing the object hierarchy, you might end up with something like
         <a class="calibre5" href="#c32-fig-0001" id="R_c32-fig-0001">
          Figure 32.1
         </a>
         , which organizes the classes according to their attack and defense capabilities.
        </p>
        <p class="calibre13" id="c32-para-0083">
         The hierarchy in
         <a class="calibre5" href="#c32-fig-0001">
          Figure 32.1
         </a>
         ignores the movement functionality that certain classes contain. Building your hierarchy around movement would result in a structure similar to
         <a class="calibre5" href="#c32-fig-0002" id="R_c32-fig-0002">
          Figure 32.2
         </a>
         .
        </p>
        <p class="calibre13" id="c32-para-0084">
         Of course, the design of
         <a class="calibre5" href="#c32-fig-0002">
          Figure 32.2
         </a>
         throws away all the organization of
         <a class="calibre5" href="#c32-fig-0001">
          Figure 32.1
         </a>
         . What's a good object-oriented programmer to do?
        </p>
        <p class="calibre13" id="c32-para-0085">
         Assuming that you go with the first hierarchy, organized around attackers and defenders, you need some way to work movement into the equation. One possibility is that, even though only a portion of the derived classes support movement, you
         <i class="calibre18">
          could
         </i>
         add a
         <code class="calibre21">
          move()
         </code>
         member function to the
         <code class="calibre21">
          Item
         </code>
         base class. The default implementation would do nothing, but certain derived classes would override
         <code class="calibre21">
          move()
         </code>
         to actually change their location on the grid.
        </p>
        <figure class="calibre36">
         <img alt="A hierarchy chart illustrates the top of the chart is an item. Under item, there are two categories. 1. Defender. 2. Attacker. The defender category branches into barrier and castle, with the castle further branching into a floating castle." class="center" src="images/c32f001.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c32-fig-0001" id="c32-fig-0001" role="doc-backlink">
             <b class="calibre14">
              FIGURE 32.1
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <figure class="calibre36">
         <img alt="A flowchart illustrates the top of the chart is an item. Under item, there are two categories such as nonmover and mover. The nonmover category branches into turret, castle, and barrier. The mover category branches include. 1. Knight. 2. Floatingcastle. 3. Superknight." class="center" src="images/c32f002.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c32-fig-0002" id="c32-fig-0002" role="doc-backlink">
             <b class="calibre14">
              FIGURE 32.2
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <p class="calibre13" id="c32-para-0086">
         <span aria-label="1172" class="calibre20" epub:type="pagebreak" id="Page_1172" role="doc-pagebreak">
         </span>
         Another approach is to write a
         <code class="calibre21">
          Movable
         </code>
         mixin class. The elegant hierarchy from
         <a class="calibre5" href="#c32-fig-0001">
          Figure 32.1
         </a>
         could be preserved, but certain classes in the hierarchy would derive from
         <code class="calibre21">
          Movable
         </code>
         in addition to their parent.
         <a class="calibre5" href="#c32-fig-0003" id="R_c32-fig-0003">
          Figure 32.3
         </a>
         shows this design.
        </p>
        <figure class="calibre36">
         <img alt="A flowchart illustrates the item. Under item, three categories. Include defender, movable, and attacker. The defender category branches into barrier, castle, and floating castle. The attacker category branches into a knight, a super knight, and a turret." class="center" src="images/c32f003.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c32-fig-0003" id="c32-fig-0003" role="doc-backlink">
             <b class="calibre14">
              FIGURE 32.3
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <p class="calibre13" id="c32-para-0087">
         Yet another approach is to flatten the hierarchy and don't use run time polymorphism at all. Instead, you can use static polymorphism and/or type-erasure whenever you need to deal polymorphically with a subset of your types. These approaches are not further discussed in this text.
        </p>
       </section>
       <span aria-label="1173" class="calibre20" epub:type="pagebreak" id="Page_1173" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c32-sec-0027">
        </span>
        <h5 class="calibre35" id="head-5-190">
         Implementing a Mixin Class
        </h5>
        <p class="calibre13">
         Writing a mixin class is no different from writing a normal class. In fact, it's usually much simpler. Using the earlier war simulation, the
         <code class="calibre21">
          Movable
         </code>
         mixin class might look as follows:
        </p>
        <pre class="calibre26" id="c32-code-0037"><code class="calibre21">class Movable</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual void move() { <span class="color">/* Implementation to move an item… */</span> }</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c32-para-0089">
         This
         <code class="calibre21">
          Movable
         </code>
         mixin class implements the actual code to move an item on the grid. It also provides a type for
         <code class="calibre21">
          Item
         </code>
         s that can be moved. This allows you to create, for example, an array of all movable items without knowing or caring what actual derived class of
         <code class="calibre21">
          Item
         </code>
         they belong to.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c32-sec-0028">
        </span>
        <h5 class="calibre35" id="head-5-191">
         Using a Mixin Class
        </h5>
        <p class="calibre13">
         The code for using a mixin class is syntactically equivalent to multiple inheritance. In addition to deriving from your parent class in the main hierarchy, you also derive from the mixin class. Here's an example:
        </p>
        <pre class="calibre26" id="c32-code-0038"><code class="calibre21">class FloatingCastle : public Castle, public Movable { <span class="color">/* … */</span> };</code></pre>
        <p class="calibre13" id="c32-para-0091">
         This
         <i class="calibre18">
          mixes in
         </i>
         the functionality provided by the
         <code class="calibre21">
          Movable
         </code>
         mixin class into the
         <code class="calibre21">
          FloatingCastle
         </code>
         class. Now you have a class that exists in the most logical place in the hierarchy, but still shares commonality with objects elsewhere in the hierarchy.
        </p>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0029">
       </span>
       <h4 class="calibre29" id="head-4-439">
        Using Class Templates
       </h4>
       <p class="calibre13" id="c32-para-0092">
        A second option to implement a mixin class in C++ is to make the mixin class itself a class template accepting a template type parameter and then deriving itself from that type.
       </p>
       <p class="calibre13">
        <a class="calibre5" href="c06.xhtml">
         Chapter 6
        </a>
        explains the mechanism for implementing a
        <code class="calibre21">
         SelfDrivable
        </code>
        mixin class template that can then be used to create self-drivable cars and trucks. Now that you are fluent in class templates (
        <a class="calibre5" href="c12.xhtml">
         Chapters 12
        </a>
        and
        <a class="calibre5" href="c26.xhtml">
         26
        </a>
        ), the
        <code class="calibre21">
         SelfDrivable
        </code>
        mixin example from
        <a class="calibre5" href="c06.xhtml">
         Chapter 6
        </a>
        should hold no surprises anymore. The mixin class is defined as follows:
       </p>
       <pre class="calibre26" id="c32-code-0039"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">class SelfDrivable : public T { <span class="color">/* … */</span> };</code></pre>
       <p class="calibre13">
        If you then have a
        <code class="calibre21">
         Car
        </code>
        and a
        <code class="calibre21">
         Truck
        </code>
        class, you can easily define a self-drivable car and truck as follows:
       </p>
       <pre class="calibre26" id="c32-code-0040"><code class="calibre21">SelfDrivable&lt;Car&gt; selfDrivingCar;</code>
<code class="calibre21">SelfDrivable&lt;Truck&gt; selfDrivingTruck;</code></pre>
       <p class="calibre13" id="c32-para-0095">
        This way, functionality can be added to existing classes,
        <code class="calibre21">
         Car
        </code>
        and
        <code class="calibre21">
         Truck
        </code>
        , without having to modify those classes at all.
       </p>
       <p class="calibre13">
        Here is a complete example:
       </p>
       <pre class="calibre26" id="c32-code-0041"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">class SelfDrivable : public T</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<span aria-label="1174" class="calibre20" epub:type="pagebreak" id="Page_1174" role="doc-pagebreak"></span><code class="calibre21">        void drive() { this-&gt;setSpeed(1.2); }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Car</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setSpeed(double speed) { println("Car speed set to {}.", speed); }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Truck</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setSpeed(double speed) { println("Truck speed set to {}.", speed); }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    SelfDrivable&lt;Car&gt; car;</code>
<code class="calibre21">    SelfDrivable&lt;Truck&gt; truck;</code>
<code class="calibre21">    car.drive();</code>
<code class="calibre21">    truck.drive();</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-440">
        Using CRTP
       </h4>
       <p class="calibre13" id="c32-para-0097">
        Another technique to implement a mixin class in C++ is to use the
        <i class="calibre18">
         curiously recurring template pattern
        </i>
        (CRTP).
       </p>
       <p class="calibre13">
        The mixin class itself is again a class template, but this time it accepts a template type parameter representing the type of a derived class and doesn't inherit itself from any other class. In the implementation a
        <code class="calibre21">
         static_cast()
        </code>
        is required to cast
        <code class="calibre21">
         this
        </code>
        to the type of the derived class.
       </p>
       <pre class="calibre26" id="c32-code-0042"><code class="calibre21">template &lt;typename Derived&gt;</code>
<code class="calibre21">class SelfDrivable</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void drive()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            auto&amp; self { static_cast&lt;Derived&amp;&gt;(*this) };</code>
<code class="calibre21">            self.setSpeed(1.2);</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Concrete classes, such as
        <code class="calibre21">
         Car
        </code>
        and
        <code class="calibre21">
         Truck
        </code>
        , then inherit from
        <code class="calibre21">
         SelfDrivable
        </code>
        and pass their own type as the template type argument for
        <code class="calibre21">
         SelfDrivable
        </code>
        .
       </p>
       <pre class="calibre26" id="c32-code-0043"><code class="calibre21">class Car <b class="calibre14">: public SelfDrivable&lt;Car&gt;</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setSpeed(double speed) { println("Car speed set to {}.", speed); }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Truck <b class="calibre14">: public SelfDrivable&lt;Truck&gt;</b></code>
<code class="calibre21">{<span aria-label="1175" class="calibre20" epub:type="pagebreak" id="Page_1175" role="doc-pagebreak"></span></code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setSpeed(double speed) { println("Truck speed set to {}.", speed); }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        These can be used as follows:
       </p>
       <pre class="calibre26" id="c32-code-0044"><code class="calibre21">Car car;</code>
<code class="calibre21">Truck truck;</code>
<code class="calibre21">car.drive();</code>
<code class="calibre21">truck.drive();</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c32-sec-0031">
       </span>
       <h4 class="calibre29" id="head-4-441">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        Using CRTP and Deducing this
       </h4>
       <p class="calibre13">
        The implementation of
        <code class="calibre21">
         SelfDrivable::drive()
        </code>
        in the previous CRTP example requires a
        <code class="calibre21">
         static_cast()
        </code>
        to get access to the correct derived type. Thanks to the C++23 “deducing
        <code class="calibre21">
         this
        </code>
        ” feature, the
        <code class="calibre21">
         SelfDrivable
        </code>
        class can be implemented more elegantly as follows using an explicit object parameter. In this implementation, the
        <code class="calibre21">
         SelfDrivable
        </code>
        mixin class is no longer a class template, but
        <code class="calibre21">
         SelfDrivable::drive()
        </code>
        is now a member function template. The parameter annotated with
        <code class="calibre21">
         this
        </code>
        is known as an explicit object parameter (see
        <a class="calibre5" href="c08.xhtml">
         Chapter 8
        </a>
        , “Gaining Proficiency with Classes and Objects”).
       </p>
       <pre class="calibre26" id="c32-code-0045"><code class="calibre21">class SelfDrivable</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void drive(<b class="calibre14">this auto&amp; self</b>) { self.setSpeed(1.2); }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <code class="calibre21">
         Car
        </code>
        and
        <code class="calibre21">
         Truck
        </code>
        then simply derive from
        <code class="calibre21">
         SelfDrivable
        </code>
        :
       </p>
       <pre class="calibre26" id="c32-code-0046"><code class="calibre21">class Car <b class="calibre14">: public SelfDrivable</b> { <span class="color">/* Same as before */</span> };</code>
<code class="calibre21">class Truck <b class="calibre14">: public SelfDrivable</b> { <span class="color">/* Same as before */</span> };</code></pre>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-320" class="calibre2">
     <span class="calibre" id="c32-sec-0032">
     </span>
     <h2 class="calibre6" id="head-2-320">
      OBJECT-ORIENTED FRAMEWORKS
     </h2>
     <p class="calibre13" id="c32-para-0104">
      When graphical operating systems first came on the scene in the 1980s, procedural programming was the norm. At the time, writing a GUI application usually involved manipulating complex data structures and passing them to OS-provided functions. For example, to draw a rectangle in a window, you might have had to populate a
      <code class="calibre21">
       Window
      </code>
      struct with the appropriate information and pass it to a
      <code class="calibre21">
       drawRect()
      </code>
      function.
     </p>
     <p class="calibre13" id="c32-para-0105">
      As object-oriented programming (OOP) grew in popularity, programmers looked for a way to apply the OOP paradigm to GUI development. The result is known as an
      <i class="calibre18">
       object-oriented framework
      </i>
      . In general, a framework is a set of classes that are used collectively to provide an object-oriented interface to some underlying functionality. By frameworks, programmers usually mean large class libraries that are used for general application development. However, a framework can really represent functionality of any size. If you write a suite of classes that provides database functionality for your application, those classes could be considered a framework.
     </p>
     <span aria-label="1176" class="calibre20" epub:type="pagebreak" id="Page_1176" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0033">
      </span>
      <h3 class="calibre27" id="head-3-578">
       Working with Frameworks
      </h3>
      <p class="calibre13" id="c32-para-0106">
       The defining characteristic of a framework is that it provides its own set of techniques and patterns. Frameworks usually require a bit of learning to get started with because they have their own mental model. Before you can work with a large application framework, such as the Microsoft Foundation Classes (MFC), you need to understand its view of the world.
      </p>
      <p class="calibre13" id="c32-para-0107">
       Frameworks vary greatly in their abstract ideas and in their actual implementation. Many frameworks are built on top of legacy procedural APIs, which may affect various aspects of their design. Other frameworks are written from the ground up with object-oriented design in mind. Some frameworks might ideologically oppose certain aspects of the C++ language. For example, a framework could consciously shun the notion of multiple inheritance.
      </p>
      <p class="calibre13" id="c32-para-0108">
       When you start working with a new framework, your first task is to find out what makes it tick. To what design principles does it subscribe? What mental model are its developers trying to convey? What aspects of the language does it use extensively? These are all vital questions, even though they may sound like things that you'll pick up along the way. If you fail to understand the design, model, or language features of the framework, you will quickly get into situations where you overstep the bounds of the framework.
      </p>
      <p class="calibre13" id="c32-para-0109">
       An understanding of the framework's design will also make it possible for you to extend it. For example, if the framework omits a feature, such as support for printing, you could write your own printing classes using the same model as the framework. By doing so, you retain a consistent model for your application, and you have code that can be reused by other applications.
      </p>
      <p class="calibre13" id="c32-para-0110">
       Additionally, a framework might use certain specific data types. For example, the MFC framework uses the
       <code class="calibre21">
        CString
       </code>
       data type to represent strings, instead of using the Standard Library
       <code class="calibre21">
        std::string
       </code>
       class. This does not mean you have to switch to the data types provided by the framework for your entire code base. Instead, you could convert the data types on the boundaries between the framework code and the rest of your code.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c32-sec-0034">
      </span>
      <h3 class="calibre27" id="head-3-579">
       The Model-View-Controller Paradigm
      </h3>
      <p class="calibre13" id="c32-para-0111">
       As I mentioned earlier, frameworks vary in their approaches to object-oriented design. One common paradigm is known as
       <i class="calibre18">
        model-view-controller
       </i>
       (MVC). This paradigm models the notion that many applications commonly deal with a set of data, one or more views on that data, and manipulation of the data.
      </p>
      <p class="calibre13">
       In MVC, a set of data is called the
       <i class="calibre18">
        model
       </i>
       . In a race car simulator, the model would keep track of various statistics, such as the current speed of the car and the amount of damage it has sustained. In practice, the model often takes the form of a class with many getters and setters. The class definition for the model of the race car might look as follows:
      </p>
      <pre class="calibre26" id="c32-code-0047"><code class="calibre21">class RaceCar</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        RaceCar();</code>
<code class="calibre21">        virtual ~RaceCar() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        virtual double getSpeed() const;</code>
<span aria-label="1177" class="calibre20" epub:type="pagebreak" id="Page_1177" role="doc-pagebreak"></span><code class="calibre21">        virtual void setSpeed(double speed);</code>
<code class="calibre21"> </code>
<code class="calibre21">        virtual double getDamageLevel() const;</code>
<code class="calibre21">        virtual void setDamageLevel(double damage);</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        double m_speed { 0.0 };</code>
<code class="calibre21">        double m_damageLevel { 0.0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c32-para-0113">
       A
       <i class="calibre18">
        view
       </i>
       is a particular visualization of the model. For example, there could be two views on a
       <code class="calibre21">
        RaceCar
       </code>
       . The first view could be a graphical view of the car, and the second could be a graph that shows the level of damage over time. The important point is that both views are operating on the same data—they are different ways of looking at the same information. This is one of the main advantages of the MVC paradigm: by keeping data separated from its display, you can keep your code more organized and easily create additional views.
      </p>
      <p class="calibre13" id="c32-para-0114">
       The final piece to the MVC paradigm is the
       <i class="calibre18">
        controller
       </i>
       . The controller is the piece of code that changes the model in response to some event. For example, when the driver of the race car simulator runs into a concrete barrier, the controller instructs the model to bump up the car's damage level and reduce its speed. The controller can also manipulate the view. For example, when the user scrolls a scrollbar in the user interface, the controller instructs the view to scroll its content.
      </p>
      <p class="calibre13" id="c32-para-0115">
       The three components of MVC interact in a feedback loop. Actions are handled by the controller, which adjusts the model and/or views. If the model changes, it notifies the views to update themselves.
       <a class="calibre5" href="#c32-fig-0004" id="R_c32-fig-0004">
        Figure 32.4
       </a>
       shows this interaction.
      </p>
      <figure class="calibre36">
       <img alt="A flowchart illustrates four main components. Include user, view, controller, and model. The user interacts with the view and controller. The view displays data to the user and updates the model. The controller manipulates both the view and the model." class="center" src="images/c32f004.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c32-fig-0004" id="c32-fig-0004" role="doc-backlink">
           <b class="calibre14">
            FIGURE 32.4
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c32-para-0116">
       The model-view-controller paradigm has gained widespread support within many popular frameworks. Even nontraditional applications, such as web applications, are moving in the direction of MVC because it enforces a clear separation between data, the manipulation of data, and the displaying of data.
      </p>
      <p class="calibre13" id="c32-para-0117">
       The MVC pattern has evolved into several different variants, such as model-view-presenter (MVP), model-view-adapter (MVA), model-view-viewmodel (MVVM), and so on.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-321" class="calibre2">
     <span class="calibre" id="c32-sec-0035">
     </span>
     <h2 class="calibre6" id="head-2-321">
      SUMMARY
     </h2>
     <p class="calibre13" id="c32-para-0118">
      In this chapter, you've read about some of the common techniques that professional C++ programmers use consistently in their projects. As you advance as a software developer, you will undoubtedly form your own collection of reusable classes and libraries. Discovering design techniques opens the
      <span aria-label="1178" class="calibre20" epub:type="pagebreak" id="Page_1178" role="doc-pagebreak">
      </span>
      door to developing and using
      <i class="calibre18">
       patterns
      </i>
      , which are higher-level reusable constructs. You will experience the many applications of patterns next in
      <a class="calibre5" href="c33.xhtml">
       Chapter 33
      </a>
      , “Applying Design Patterns.”
     </p>
    </section>
    <section aria-labelledby="head-2-322" class="calibre2">
     <span class="calibre" id="c32-sec-0036">
     </span>
     <h2 class="calibre6" id="head-2-322">
      EXERCISES
     </h2>
     <p class="calibre13" id="c32-para-0119">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c32-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c32-ex-0001">
        <b class="calibre14">
         Exercise 32-1:
        </b>
        Write an RAII class template,
        <code class="calibre21">
         Pointer&lt;T&gt;
        </code>
        , that can store a pointer to a
        <code class="calibre21">
         T
        </code>
        and automatically deletes the memory when such an RAII instance goes out of scope. Provide a
        <code class="calibre21">
         reset()
        </code>
        and
        <code class="calibre21">
         release()
        </code>
        member function, and an overloaded
        <code class="calibre21">
         operator*
        </code>
        .
       </li>
       <li class="calibre9" id="c32-ex-0002">
        <b class="calibre14">
         Exercise 32-2:
        </b>
        Modify your class template from Exercise 32-1 so that it throws an exception if the argument given to the constructor is
        <code class="calibre21">
         nullptr
        </code>
        .
       </li>
       <li class="calibre9" id="c32-ex-0003">
        <b class="calibre14">
         Exercise 32-3:
        </b>
        Take your solution from Exercise 32-2 and add a member function template called
        <code class="calibre21">
         assign()
        </code>
        with a template type parameter
        <code class="calibre21">
         E
        </code>
        . The function should accept an argument of type
        <code class="calibre21">
         E
        </code>
        and assign this argument to the data to which the wrapped pointer is pointing. Add a constraint to the member function template to make sure type
        <code class="calibre21">
         E
        </code>
        is in fact assignable to an lvalue of type
        <code class="calibre21">
         T
        </code>
        .
       </li>
       <li class="calibre9" id="c32-ex-0004">
        <b class="calibre14">
         Exercise 32-4:
        </b>
        Write a lambda expression returning the sum of two arguments. Both arguments must be of the same type. The lambda expression should work with all kind of data types, such as integral types, floating-point types, and even
        <code class="calibre21">
         std::string
        </code>
        s. Try out your lambda expression by calculating the sum of 11 and 22, 1.1 and 2.2, and “Hello ” and “world!”
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
