<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   10Discovering Inheritance Techniques
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_020.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_022.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c10_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c10_1">
      <span aria-label="357" class="calibre17" epub:type="pagebreak" id="Page_357" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c10">
      </span>
      <span class="calibre">
       10
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Discovering Inheritance Techniques
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c10-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c10-list-0001">
         <li class="calibre9" id="c10-li-0001">
          How to extend a class through inheritance
         </li>
         <li class="calibre9" id="c10-li-0002">
          How to employ inheritance to reuse code
         </li>
         <li class="calibre9" id="c10-li-0003">
          How to build interactions between base classes and derived classes
         </li>
         <li class="calibre9" id="c10-li-0004">
          How to use inheritance to achieve polymorphism
         </li>
         <li class="calibre9" id="c10-li-0005">
          How to work with multiple inheritance
         </li>
         <li class="calibre9" id="c10-li-0006">
          How to deal with unusual problems in inheritance
         </li>
         <li class="calibre9" id="c10-li-0007">
          How to cast one type to another type
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c10-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-121">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c10-sec-0003">
        </span>
        <p class="calibre25" id="c10-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c10-para-0005">
      Without inheritance, classes would simply be data structures with associated behaviors. That alone would be a powerful improvement over procedural languages, but inheritance adds an entirely new dimension. Through inheritance, you can build new classes based on existing ones. In this way, your classes become reusable and extensible components. This chapter teaches you the different ways to leverage the power of inheritance. You will learn about the specific syntax of inheritance as well as sophisticated techniques for making the most of inheritance.
     </p>
     <p class="calibre13" id="c10-para-0006">
      The portion of this chapter relating to polymorphism draws heavily on the spreadsheet example discussed in
      <a class="calibre5" href="c08.xhtml">
       Chapter 8
      </a>
      , “Gaining Proficiency with Classes and Objects,” and
      <a class="calibre5" href="c09.xhtml">
       Chapter 9
      </a>
      ,
      <span aria-label="358" class="calibre20" epub:type="pagebreak" id="Page_358" role="doc-pagebreak">
      </span>
      “Mastering Classes and Objects.” This chapter also refers to the object-oriented methodologies described in
      <a class="calibre5" href="c05.xhtml">
       Chapter 5
      </a>
      , “Designing with Classes.” If you have not read that chapter and are unfamiliar with the theories behind inheritance, you should review
      <a class="calibre5" href="c05.xhtml">
       Chapter 5
      </a>
      before continuing.
     </p>
    </section>
    <section aria-labelledby="head-2-122" class="calibre2">
     <span class="calibre" id="c10-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-122">
      BUILDING CLASSES WITH INHERITANCE
     </h2>
     <p class="calibre13">
      In
      <a class="calibre5" href="c05.xhtml">
       Chapter 5
      </a>
      , you learned that an
      <i class="calibre18">
       is-a
      </i>
      relationship recognizes the pattern that real-world objects tend to exist in hierarchies. In programming, that pattern becomes relevant when you need to write a class that builds on, or slightly changes, another class. One way to accomplish this aim is to copy code from one class and paste it into the other. By changing the relevant parts or amending the code, you can achieve the goal of creating a new class that is slightly different from the original. This approach, however, leaves an OOP programmer feeling sullen and highly annoyed for the following reasons:
     </p>
     <ul class="check" id="c10-list-0002">
      <li class="calibre9" id="c10-li-0008">
       A bug fix to the original class will not be reflected in the new class because the two classes contain completely separate code.
      </li>
      <li class="calibre9" id="c10-li-0009">
       The compiler does not know about any relationship between the two classes, so they are not polymorphic (see
       <a class="calibre5" href="c05.xhtml">
        Chapter 5
       </a>
       )—they are not just different variations on the same thing.
      </li>
      <li class="calibre9" id="c10-li-0010">
       This approach does not build a true is-a relationship. The new class is similar to the original because it has similar code, not because it really
       <i class="calibre18">
        is
       </i>
       the same type of object.
      </li>
      <li class="calibre9" id="c10-li-0011">
       The original code might not be obtainable. It may exist only in a precompiled binary format, so copying and pasting the code might be impossible.
      </li>
     </ul>
     <p class="calibre13" id="c10-para-0008">
      Not surprisingly, C++ provides built-in support for defining a true is-a relationship. The characteristics of C++ is-a relationships are described in the following section.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-206">
       Extending Classes
      </h3>
      <p class="calibre13" id="c10-para-0009">
       When you write a class definition in C++, you can tell the compiler that your class is
       <i class="calibre18">
        inheriting from, deriving from
       </i>
       , or
       <i class="calibre18">
        extending
       </i>
       an existing class. By doing so, your class automatically contains the data members and member functions of the original class, which is called the
       <i class="calibre18">
        parent class
       </i>
       ,
       <i class="calibre18">
        base class
       </i>
       , or
       <i class="calibre18">
        superclass
       </i>
       . Extending an existing class gives your class (which is now called a
       <i class="calibre18">
        child class
       </i>
       ,
       <i class="calibre18">
        derived class
       </i>
       , or
       <i class="calibre18">
        subclass
       </i>
       ) the ability to describe only the ways in which it is different from the parent class.
      </p>
      <p class="calibre13">
       To extend a class in C++, you specify the class you are extending when you write the class definition. To show the syntax for inheritance, two classes are used,
       <code class="calibre21">
        Base
       </code>
       and
       <code class="calibre21">
        Derived
       </code>
       . Don't worry—more interesting examples are coming later. To begin, consider the following definition for the
       <code class="calibre21">
        Base
       </code>
       class:
      </p>
      <pre class="calibre26" id="c10-code-0001"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void someFunction() {}</code>
<code class="calibre21">    protected:</code>
<code class="calibre21">        int m_protectedInt { 0 };</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_privateInt { 0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="359" class="calibre20" epub:type="pagebreak" id="Page_359" role="doc-pagebreak">
       </span>
       If you want to build a new class, called
       <code class="calibre21">
        Derived
       </code>
       , which inherits from
       <code class="calibre21">
        Base
       </code>
       , you use the following syntax:
      </p>
      <pre class="calibre26" id="c10-code-0002"><code class="calibre21">class Derived <b class="calibre14">: public Base</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void someOtherFunction() {}</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c10-para-0012">
       <code class="calibre21">
        Derived
       </code>
       is a full-fledged class that just happens to share the characteristics of the
       <code class="calibre21">
        Base
       </code>
       class. Don't worry about the word
       <code class="calibre21">
        public
       </code>
       for now—its meaning is explained later in this chapter.
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0001" id="R_c10-fig-0001">
        Figure 10.1
       </a>
       shows the simple relationship between
       <code class="calibre21">
        Derived
       </code>
       and
       <code class="calibre21">
        Base
       </code>
       . You can declare objects of type
       <code class="calibre21">
        Derived
       </code>
       just like any other object. You could even define a third class that inherits from
       <code class="calibre21">
        Derived
       </code>
       , forming a chain of classes, as shown in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0002" id="R_c10-fig-0002">
        Figure 10.2
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A flowchart of two boxes. The first box reads base. The second box reads derived." class="center" src="images/c10f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0001" id="c10-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <figure class="calibre36">
       <img alt="A flowchart of three boxes. The first box reads base. The second box reads derived. The third box reads derived derived." class="center" src="images/c10f002.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0002" id="c10-fig-0002" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.2
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c10-para-0013">
       <code class="calibre21">
        Derived
       </code>
       doesn't have to be the only derived class of
       <code class="calibre21">
        Base
       </code>
       . Additional classes can also inherit from
       <code class="calibre21">
        Base
       </code>
       , effectively becoming
       <i class="calibre18">
        siblings
       </i>
       to
       <code class="calibre21">
        Derived
       </code>
       , as shown in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0003" id="R_c10-fig-0003">
        Figure 10.3
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A flowchart of three boxes. The first box reads base. The second box reads derived. The third box reads derived 2." class="center" src="images/c10f003.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0003" id="c10-fig-0003" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.3
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c10-para-0014">
       Internally, a derived class contains an instance of the base class as a
       <i class="calibre18">
        subobject
       </i>
       . Graphically this can be represented as in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0004" id="R_c10-fig-0004">
        Figure 10.4
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A table of the header derived. The subtitle is base. It includes some functions, protected, private, and some other functions." class="center" src="images/c10f004.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0004" id="c10-fig-0004" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.4
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0006">
       </span>
       <h4 class="calibre29" id="head-4-191">
        A Client's View of Inheritance
       </h4>
       <p class="calibre13" id="c10-para-0015">
        To a client, or another part of your code, an object of type
        <code class="calibre21">
         Derived
        </code>
        is also an object of type
        <code class="calibre21">
         Base
        </code>
        because
        <code class="calibre21">
         Derived
        </code>
        inherits from
        <code class="calibre21">
         Base
        </code>
        . This means that all the
        <code class="calibre21">
         public
        </code>
        member functions and data members of
        <code class="calibre21">
         Base
        </code>
        <i class="calibre18">
         and
        </i>
        all the
        <code class="calibre21">
         public
        </code>
        member functions and data members of
        <code class="calibre21">
         Derived
        </code>
        are available.
       </p>
       <p class="calibre13">
        Code that uses the derived class does not need to know which class in your inheritance chain has defined a member function in order to call it. For example, the following code calls two member functions of a
        <code class="calibre21">
         Derived
        </code>
        object, even though one of the member functions is defined by the
        <code class="calibre21">
         Base
        </code>
        class:
       </p>
       <pre class="calibre26" id="c10-code-0003"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">myDerived.someFunction();</code>
<code class="calibre21">myDerived.someOtherFunction();</code></pre>
       <p class="calibre13" id="c10-para-0017">
        It is important to understand that inheritance works in only one direction. The
        <code class="calibre21">
         Derived
        </code>
        class has a clearly defined relationship to the
        <code class="calibre21">
         Base
        </code>
        class, but the
        <code class="calibre21">
         Base
        </code>
        class, as written, doesn't know anything about the
        <code class="calibre21">
         Derived
        </code>
        class. That means objects of type
        <code class="calibre21">
         Base
        </code>
        do not have access to member functions and data members of
        <code class="calibre21">
         Derived
        </code>
        because
        <code class="calibre21">
         Base
        </code>
        is
        <i class="calibre18">
         not
        </i>
        a
        <code class="calibre21">
         Derived
        </code>
        .
       </p>
       <p class="calibre13">
        The following code does not compile because the
        <code class="calibre21">
         Base
        </code>
        class does not contain a
        <code class="calibre21">
         public
        </code>
        member function called
        <code class="calibre21">
         someOtherFunction()
        </code>
        :
       </p>
       <pre class="calibre26" id="c10-code-0004"><code class="calibre21">Base myBase;</code>
<code class="calibre21">myBase.someOtherFunction();  <span class="color">// Error! Base doesn't have a someOtherFunction().</span></code></pre>
       <p class="calibre13">
        <span aria-label="360" class="calibre20" epub:type="pagebreak" id="Page_360" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0020">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            From the perspective of code using an object, the object belongs to its defined class as well as to any base classes
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c10-para-0021">
        A pointer or reference to a class type can refer to an object of the declared class type or any of its derived classes. This tricky subject is explained in detail later in this chapter. The concept to understand now is that a pointer to
        <code class="calibre21">
         Base
        </code>
        can actually be pointing to a
        <code class="calibre21">
         Derived
        </code>
        object. The same is true for a reference. The client can still access only the member functions and data members that exist in
        <code class="calibre21">
         Base
        </code>
        , but through this mechanism, any code that operates on a
        <code class="calibre21">
         Base
        </code>
        can also operate on a
        <code class="calibre21">
         Derived
        </code>
        .
       </p>
       <p class="calibre13">
        For example, the following code compiles and works just fine, even though it initially appears that there is a type mismatch:
       </p>
       <pre class="calibre26" id="c10-code-0005"><code class="calibre21">Base* base { new Derived {} }; <span class="color">// Create Derived, store in Base pointer.</span></code></pre>
       <p class="calibre13">
        However, you cannot call member functions from the
        <code class="calibre21">
         Derived
        </code>
        class through the
        <code class="calibre21">
         Base
        </code>
        pointer. The following does not work:
       </p>
       <pre class="calibre26" id="c10-code-0006"><code class="calibre21">base-&gt;someOtherFunction();</code></pre>
       <p class="calibre13" id="c10-para-0024">
        This is flagged as an error by the compiler because, although the object is of type
        <code class="calibre21">
         Derived
        </code>
        and therefore does have
        <code class="calibre21">
         someOtherFunction()
        </code>
        defined, the compiler can only think of it as type
        <code class="calibre21">
         Base
        </code>
        , which does not have
        <code class="calibre21">
         someOtherFunction()
        </code>
        defined.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0008">
       </span>
       <h4 class="calibre29" id="head-4-192">
        A Derived Class's View of Inheritance
       </h4>
       <p class="calibre13" id="c10-para-0025">
        To the derived class, nothing much has changed in terms of how it is written or how it behaves. You can still define member functions and data members on a derived class just as you would on a regular class. The previous definition of
        <code class="calibre21">
         Derived
        </code>
        declares a member function called
        <code class="calibre21">
         someOtherFunction()
        </code>
        . Thus, the
        <code class="calibre21">
         Derived
        </code>
        class augments the
        <code class="calibre21">
         Base
        </code>
        class by adding an additional member function.
       </p>
       <p class="calibre13">
        A derived class can access
        <code class="calibre21">
         public
        </code>
        and
        <code class="calibre21">
         protected
        </code>
        member functions and data members declared in its base class as though they were its own, because technically they are. For example, the implementation of
        <code class="calibre21">
         someOtherFunction()
        </code>
        on
        <code class="calibre21">
         Derived
        </code>
        could make use of the data member
        <code class="calibre21">
         m_protectedInt
        </code>
        , which is declared as part of
        <code class="calibre21">
         Base
        </code>
        . The following code shows this. Accessing a base class member is no different than if the member were declared as part of the derived class.
       </p>
       <pre class="calibre26" id="c10-code-0007"><code class="calibre21">void Derived::someOtherFunction()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("I can access base class data member m_protectedInt.");</code>
<code class="calibre21">    println("Its value is {}", m_protectedInt);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        If a class declares members as
        <code class="calibre21">
         protected
        </code>
        , derived classes have access to them. If they are declared as
        <code class="calibre21">
         private
        </code>
        , derived classes do not have access. The following implementation of
        <code class="calibre21">
         someOtherFunction()
        </code>
        does not compile because the derived class attempts to access a
        <code class="calibre21">
         private
        </code>
        data member from the base class:
       </p>
       <pre class="calibre26" id="c10-code-0008"><code class="calibre21">void Derived::someOtherFunction()</code>
<code class="calibre21">{</code>
<span aria-label="361" class="calibre20" epub:type="pagebreak" id="Page_361" role="doc-pagebreak"></span><code class="calibre21">    println("I can access base class data member m_protectedInt.");</code>
<code class="calibre21">    println("Its value is {}", m_protectedInt);</code>
<code class="calibre21">    <b class="calibre14">println("The value of m_privateInt is {}", m_privateInt);</b> <span class="color">// Error!</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c10-para-0028">
        The
        <code class="calibre21">
         private
        </code>
        access specifier gives you control over how a potential derived class could interact with your class.
       </p>
       <p class="calibre13">
        <a class="calibre5" href="c04.xhtml">
         Chapter 4
        </a>
        , “Designing Professional C++ Programs,” gives the following rule: all data members should be
        <code class="calibre21">
         private
        </code>
        ; provide
        <code class="calibre21">
         public
        </code>
        getters and setters if you want to provide access to data members from outside the class. This rule can now be extended to include the
        <code class="calibre21">
         protected
        </code>
        access specifier.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0030">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            All data members should be
           </i>
           <code class="calibre21">
            private
           </code>
           <i class="calibre18">
            . Provide
           </i>
           <code class="calibre21">
            public
           </code>
           <i class="calibre18">
            getters and setters if you want to provide access to data members from outside the class and provide
           </i>
           <code class="calibre21">
            protected
           </code>
           <i class="calibre18">
            getters and setters if you want only derived classes to access them.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        The reason to make data members
        <code class="calibre21">
         private
        </code>
        by default is that this provides the highest level of encapsulation. This means that you can change how you represent your data while keeping the
        <code class="calibre21">
         public
        </code>
        and
        <code class="calibre21">
         protected
        </code>
        interfaces unchanged. Additionally, without giving direct access to data members, you can easily add checks on the input data in your
        <code class="calibre21">
         public
        </code>
        and
        <code class="calibre21">
         protected
        </code>
        setters. Member functions should also be
        <code class="calibre21">
         private
        </code>
        by default. Only make those member functions
        <code class="calibre21">
         public
        </code>
        that are designed to be public and make member functions
        <code class="calibre21">
         protected
        </code>
        if you want only derived classes to have access to them.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0032">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            From the perspective of a derived class, all
           </i>
           <code class="calibre21">
            public
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            protected
           </code>
           <i class="calibre18">
            data members and member functions from the base class are available for use.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c10-para-0033">
        The following table summarizes the meaning of all three access specifiers:
       </p>
       <table border="1" class="calibre31">
        <thead class="calibre32">
         <tr class="calibre33">
          <th class="left" scope="col">
           ACCESS SPECIFIER
          </th>
          <th class="left" scope="col">
           MEANING
          </th>
          <th class="left" scope="col">
           WHEN TO USE
          </th>
         </tr>
        </thead>
        <tbody class="calibre34">
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            public
           </code>
          </td>
          <td class="left1">
           Any code can call a
           <code class="calibre21">
            public
           </code>
           member function or access a
           <code class="calibre21">
            public
           </code>
           data member of an object.
          </td>
          <td class="left1">
           Behaviors (member functions) that you want clients to use.
           <br class="calibre12"/>
           Access member functions (getters and setters) for
           <code class="calibre21">
            private
           </code>
           and
           <code class="calibre21">
            protected
           </code>
           data members.
          </td>
         </tr>
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            protected
           </code>
          </td>
          <td class="left1">
           Any member function of the class can call
           <code class="calibre21">
            protected
           </code>
           member functions and access
           <code class="calibre21">
            protected
           </code>
           data members. Member functions of derived classes can access
           <code class="calibre21">
            protected
           </code>
           members of a base class.
          </td>
          <td class="left1">
           “Helper” member functions that you do not want clients to use.
          </td>
         </tr>
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            private
           </code>
          </td>
          <td class="left1">
           Only member functions of the class can call
           <code class="calibre21">
            private
           </code>
           member functions and access
           <code class="calibre21">
            private
           </code>
           data members. Member functions in derived classes cannot access
           <code class="calibre21">
            private
           </code>
           members of a base class.
          </td>
          <td class="left1">
           Everything should be
           <code class="calibre21">
            private
           </code>
           by default, especially data members. You can provide
           <code class="calibre21">
            protected
           </code>
           getters and setters if you only want to allow derived classes to access them, and provide
           <code class="calibre21">
            public
           </code>
           getters and setters if you want clients to access them.
           <span aria-label="362" class="calibre20" epub:type="pagebreak" id="Page_362" role="doc-pagebreak">
           </span>
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-193">
        Preventing Inheritance
       </h4>
       <p class="calibre13">
        C++ allows you to mark a class as
        <code class="calibre21">
         final
        </code>
        , which means trying to inherit from it will result in a compilation error. A class can be marked as
        <code class="calibre21">
         final
        </code>
        with the
        <code class="calibre21">
         final
        </code>
        keyword right behind the name of the class. For example, if a class tries to inherit from the following
        <code class="calibre21">
         Foo
        </code>
        class, the compiler will produce an error:
       </p>
       <pre class="calibre26" id="c10-code-0009"><code class="calibre21">class Foo <b class="calibre14">final</b> { };</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0012">
      </span>
      <h3 class="calibre27" id="head-3-207">
       Overriding Member Functions
      </h3>
      <p class="calibre13" id="c10-para-0039">
       The main reasons to inherit from a class are to add or replace functionality. The definition of
       <code class="calibre21">
        Derived
       </code>
       adds functionality to its parent class by providing an additional member function,
       <code class="calibre21">
        someOtherFunction()
       </code>
       . The other member function,
       <code class="calibre21">
        someFunction()
       </code>
       , is inherited from
       <code class="calibre21">
        Base
       </code>
       and behaves in the derived class exactly as it does in the base class. In many cases, you will want to modify the behavior of a class by replacing, or
       <i class="calibre18">
        overriding
       </i>
       , a member function.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0013">
       </span>
       <h4 class="calibre29" id="head-4-194">
        The virtual Keyword
       </h4>
       <p class="calibre13">
        Simply defining a member function from a base class in a derived class does not properly override that member function. To correctly override a member function, we need a new C++ keyword called
        <code class="calibre21">
         virtual
        </code>
        . Only member functions that are declared as
        <code class="calibre21">
         virtual
        </code>
        in the base class can be overridden properly by derived classes. The keyword goes at the beginning of a member function declaration as shown in the modified version of
        <code class="calibre21">
         Base
        </code>
        that follows:
       </p>
       <pre class="calibre26" id="c10-code-0010"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">virtual void someFunction();</b></code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        The same holds for the
        <code class="calibre21">
         Derived
        </code>
        class. Its member functions should also be marked
        <code class="calibre21">
         virtual
        </code>
        if you want to override them in further derived classes:
       </p>
       <pre class="calibre26" id="c10-code-0011"><code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">virtual void someOtherFunction();</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="363" class="calibre20" epub:type="pagebreak" id="Page_363" role="doc-pagebreak">
        </span>
        The
        <code class="calibre21">
         virtual
        </code>
        keyword is not repeated in front of the member function definition, e.g.:
       </p>
       <pre class="calibre26" id="c10-code-0012"><code class="calibre21">void Base::someFunction()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("This is Base's version of someFunction().");</code>
<code class="calibre21">}</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0044">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Attempting to override a non-
           </i>
           <code class="calibre21">
            virtual
           </code>
           <i class="calibre18">
            member function from a base class hides the base class definition, and it will be used only in the context of the derived class.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0015">
       </span>
       <h4 class="calibre29" id="head-4-195">
        Syntax for Overriding a Member Function
       </h4>
       <p class="calibre13">
        To override a member function, you redeclare it in the derived class definition exactly as it was declared in the base class, but you add the
        <code class="calibre21">
         override
        </code>
        keyword and remove the
        <code class="calibre21">
         virtual
        </code>
        keyword. For example, if you want to provide a new definition for
        <code class="calibre21">
         someFunction()
        </code>
        in the
        <code class="calibre21">
         Derived
        </code>
        class, you must first add it to the class definition for
        <code class="calibre21">
         Derived
        </code>
        , as follows:
       </p>
       <pre class="calibre26" id="c10-code-0013"><code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">void someFunction() override;</b> <span class="color">// Overrides Base's someFunction()</span></code>
<code class="calibre21">        virtual void someOtherFunction();</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        The new definition of
        <code class="calibre21">
         someFunction()
        </code>
        is specified along with the rest of
        <code class="calibre21">
         Derived
        </code>
        's member functions. Just as with the
        <code class="calibre21">
         virtual
        </code>
        keyword, you do not repeat the
        <code class="calibre21">
         override
        </code>
        keyword in the member function definition:
       </p>
       <pre class="calibre26" id="c10-code-0014"><code class="calibre21">void Derived::someFunction()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("This is Derived's version of someFunction().");</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        If you want, you are allowed to add the
        <code class="calibre21">
         virtual
        </code>
        keyword in front of overridden member functions, but it's redundant. Here's an example:
       </p>
       <pre class="calibre26" id="c10-code-0015"><code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">virtual void someFunction() override;</b>  <span class="color">// Overrides Base's someFunction()</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c10-para-0048">
        Once a member function or destructor is marked as
        <code class="calibre21">
         virtual
        </code>
        , it is
        <code class="calibre21">
         virtual
        </code>
        for all derived classes even if the
        <code class="calibre21">
         virtual
        </code>
        keyword is removed from derived classes.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-196">
        A Client's View of Overridden Member Functions
       </h4>
       <p class="calibre13" id="c10-para-0049">
        With the preceding changes, other code still calls
        <code class="calibre21">
         someFunction()
        </code>
        the same way it did before. Just as before, the member function could be called on an object of class
        <code class="calibre21">
         Base
        </code>
        or an object of class
        <code class="calibre21">
         Derived
        </code>
        . Now, however, the behavior of
        <code class="calibre21">
         someFunction()
        </code>
        varies based on the class of the object.
       </p>
       <p class="calibre13">
        <span aria-label="364" class="calibre20" epub:type="pagebreak" id="Page_364" role="doc-pagebreak">
        </span>
        For example, the following code works just as it did before, calling
        <code class="calibre21">
         Base
        </code>
        's version of
        <code class="calibre21">
         someFunction()
        </code>
        :
       </p>
       <pre class="calibre26" id="c10-code-0016"><code class="calibre21">Base myBase;</code>
<code class="calibre21">myBase.someFunction();  <span class="color">// Calls Base's version of someFunction().</span></code></pre>
       <p class="calibre13">
        The output of this code is as follows:
       </p>
       <pre class="calibre26" id="c10-code-0017"><code class="calibre21">This is Base's version of someFunction().</code></pre>
       <p class="calibre13">
        If the code declares an object of class
        <code class="calibre21">
         Derived
        </code>
        , the other version is automatically called:
       </p>
       <pre class="calibre26" id="c10-code-0018"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">myDerived.someFunction();   <span class="color">// Calls Derived's version of someFunction()</span></code></pre>
       <p class="calibre13">
        The output this time is as follows:
       </p>
       <pre class="calibre26" id="c10-code-0019"><code class="calibre21">This is Derived's version of someFunction().</code></pre>
       <p class="calibre13" id="c10-para-0054">
        Everything else about objects of class
        <code class="calibre21">
         Derived
        </code>
        remains the same. Other member functions that might have been inherited from
        <code class="calibre21">
         Base
        </code>
        still have the definition provided by
        <code class="calibre21">
         Base
        </code>
        unless they are explicitly overridden in
        <code class="calibre21">
         Derived
        </code>
        .
       </p>
       <p class="calibre13">
        As you learned earlier, a pointer or reference can refer to an object of a class or any of its derived classes. The object itself “knows” the class of which it is actually a member, so the appropriate member function is called as long as it was declared
        <code class="calibre21">
         virtual
        </code>
        . For example, if you have a
        <code class="calibre21">
         Base
        </code>
        reference that refers to an object that is really a
        <code class="calibre21">
         Derived
        </code>
        , calling
        <code class="calibre21">
         someFunction()
        </code>
        actually calls the derived class's version, as shown next. This aspect of overriding does
        <i class="calibre18">
         not
        </i>
        work properly if you omit the
        <code class="calibre21">
         virtual
        </code>
        keyword in the base class.
       </p>
       <pre class="calibre26" id="c10-code-0020"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">Base&amp; ref { myDerived };</code>
<code class="calibre21">ref.someFunction();   <span class="color">// Calls Derived's version of someFunction()</span></code></pre>
       <p class="calibre13">
        Remember that even though a
        <code class="calibre21">
         Base
        </code>
        reference or pointer knows that it is referring to a
        <code class="calibre21">
         Derived
        </code>
        instance, you cannot access
        <code class="calibre21">
         Derived
        </code>
        class members that are not defined in
        <code class="calibre21">
         Base
        </code>
        . The following code does not compile because a
        <code class="calibre21">
         Base
        </code>
        reference does not have a member function called
        <code class="calibre21">
         someOtherFunction()
        </code>
        :
       </p>
       <pre class="calibre26" id="c10-code-0021"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">Base&amp; ref { myDerived };</code>
<code class="calibre21">myDerived.someOtherFunction();  <span class="color">// This is fine.</span></code>
<code class="calibre21">ref.someOtherFunction();        <span class="color">// Error</span></code></pre>
       <p class="calibre13">
        This derived class knowledge characteristic is
        <i class="calibre18">
         not
        </i>
        true for nonpointer or nonreference objects. You can cast or assign a
        <code class="calibre21">
         Derived
        </code>
        to a
        <code class="calibre21">
         Base
        </code>
        because a
        <code class="calibre21">
         Derived
        </code>
        is a
        <code class="calibre21">
         Base
        </code>
        . However, the object loses any knowledge of the
        <code class="calibre21">
         Derived
        </code>
        class at that point.
       </p>
       <pre class="calibre26" id="c10-code-0022"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">Base assignedObject { myDerived };  <span class="color">// Assigns a Derived to a Base.</span></code>
<code class="calibre21">assignedObject.someFunction();      <span class="color">// Calls Base's version of someFunction()</span></code></pre>
       <p class="calibre13">
        One way to remember this seemingly strange behavior is to imagine what the objects look like in memory. Picture a
        <code class="calibre21">
         Base
        </code>
        object as a box taking up a certain amount of memory. A
        <code class="calibre21">
         Derived
        </code>
        object is a box that is slightly bigger because it has everything a
        <code class="calibre21">
         Base
        </code>
        has plus a bit more. Whether you have a
        <code class="calibre21">
         Derived
        </code>
        or
        <code class="calibre21">
         Base
        </code>
        reference or pointer to a
        <code class="calibre21">
         Derived
        </code>
        , the box doesn't change—you just have a new
        <span aria-label="365" class="calibre20" epub:type="pagebreak" id="Page_365" role="doc-pagebreak">
        </span>
        way of accessing it. However, when you cast a
        <code class="calibre21">
         Derived
        </code>
        into a
        <code class="calibre21">
         Base
        </code>
        , you are throwing out all the “uniqueness” of the
        <code class="calibre21">
         Derived
        </code>
        class to fit it into a smaller box.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0059">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Derived classes retain all their data members and member functions when referred to by base class pointers or references. They lose their uniqueness when cast to a base class object. The loss of the derived class's data members and member functions is called slicing
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0018">
       </span>
       <h4 class="calibre29" id="head-4-197">
        The override Keyword
       </h4>
       <p class="calibre13">
        The use of the
        <code class="calibre21">
         override
        </code>
        keyword is optional, but highly recommended. Without the keyword, it is possible to accidentally create a new (
        <code class="calibre21">
         virtual
        </code>
        ) member function in a derived class instead of overriding a member function from the base class, effectively hiding the member function from the base class. Take the following
        <code class="calibre21">
         Base
        </code>
        and
        <code class="calibre21">
         Derived
        </code>
        classes where
        <code class="calibre21">
         Derived
        </code>
        is properly overriding
        <code class="calibre21">
         someFunction()
        </code>
        , but is not using the
        <code class="calibre21">
         override
        </code>
        keyword:
       </p>
       <pre class="calibre26" id="c10-code-0023"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual void someFunction(double d);</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual void someFunction(double d);</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        You can call
        <code class="calibre21">
         someFunction()
        </code>
        through a reference as follows:
       </p>
       <pre class="calibre26" id="c10-code-0024"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">Base&amp; ref { myDerived };</code>
<code class="calibre21">ref.someFunction(1.1);  <span class="color">// Calls Derived's version of someFunction()</span></code></pre>
       <p class="calibre13">
        This correctly calls the overridden
        <code class="calibre21">
         someFunction()
        </code>
        from the
        <code class="calibre21">
         Derived
        </code>
        class. Now, suppose you accidentally use an integer parameter instead of a
        <code class="calibre21">
         double
        </code>
        while overriding
        <code class="calibre21">
         someFunction()
        </code>
        , as follows:
       </p>
       <pre class="calibre26" id="c10-code-0025"><code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">virtual void someFunction(int i);</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        This code does
        <i class="calibre18">
         not
        </i>
        override
        <code class="calibre21">
         someFunction()
        </code>
        from
        <code class="calibre21">
         Base
        </code>
        , but instead creates a new
        <code class="calibre21">
         virtual
        </code>
        member function. If you try to call
        <code class="calibre21">
         someFunction()
        </code>
        through a
        <code class="calibre21">
         Base
        </code>
        reference as in the following code,
        <code class="calibre21">
         someFunction()
        </code>
        of
        <code class="calibre21">
         Base
        </code>
        is called instead of the one from
        <code class="calibre21">
         Derived
        </code>
        !
       </p>
       <pre class="calibre26" id="c10-code-0026"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">Base&amp; ref { myDerived };</code>
<code class="calibre21">ref.someFunction(1.1);  <span class="color">// Calls Base's version of someFunction()</span></code></pre>
       <p class="calibre13" id="c10-para-0064">
        <span aria-label="366" class="calibre20" epub:type="pagebreak" id="Page_366" role="doc-pagebreak">
        </span>
        This type of problem can happen when you start to modify the
        <code class="calibre21">
         Base
        </code>
        class but forget to update all derived classes. For example, maybe your first version of the
        <code class="calibre21">
         Base
        </code>
        class has a member function called
        <code class="calibre21">
         someFunction()
        </code>
        accepting an integer. You then write the
        <code class="calibre21">
         Derived
        </code>
        class overriding this
        <code class="calibre21">
         someFunction()
        </code>
        accepting an integer. Later you decide that
        <code class="calibre21">
         someFunction()
        </code>
        in
        <code class="calibre21">
         Base
        </code>
        needs a
        <code class="calibre21">
         double
        </code>
        instead of an integer, so you update
        <code class="calibre21">
         someFunction()
        </code>
        in the
        <code class="calibre21">
         Base
        </code>
        class. It could happen that at that time, you forget to update overrides of
        <code class="calibre21">
         someFunction()
        </code>
        in derived classes to also accept a
        <code class="calibre21">
         double
        </code>
        instead of an integer. By forgetting this, you are now actually creating a new
        <code class="calibre21">
         virtual
        </code>
        member function instead of properly overriding the base member function.
       </p>
       <p class="calibre13">
        You can prevent this situation by using the
        <code class="calibre21">
         override
        </code>
        keyword as follows:
       </p>
       <pre class="calibre26" id="c10-code-0027"><code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">void someFunction(int i) override;</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c10-para-0066">
        This definition of
        <code class="calibre21">
         Derived
        </code>
        generates a compilation error, because with the
        <code class="calibre21">
         override
        </code>
        keyword you are saying that
        <code class="calibre21">
         someFunction()
        </code>
        is supposed to be overriding a member function from a base class, but the
        <code class="calibre21">
         Base
        </code>
        class has no
        <code class="calibre21">
         someFunction()
        </code>
        accepting an integer, only one accepting a
        <code class="calibre21">
         double
        </code>
        .
       </p>
       <p class="calibre13">
        The problem of accidentally creating a new member function instead of properly overriding one can also happen when you rename a member function in the base class and forget to rename the overriding member functions in derived classes.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0068">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Always use the
           </i>
           <code class="calibre21">
            override
           </code>
           <i class="calibre18">
            keyword on member functions that are meant to be overriding member functions from a base class.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0020">
       </span>
       <h4 class="calibre29" id="head-4-198">
        The Truth about virtual
       </h4>
       <p class="calibre13" id="c10-para-0069">
        By now you know that if a member function is not
        <code class="calibre21">
         virtual
        </code>
        , trying to override it in a derived class will hide the base class's version of that member function. This section explores how
        <code class="calibre21">
         virtual
        </code>
        member functions are implemented by the compiler and what their performance impact is, as well as discussing the importance of
        <code class="calibre21">
         virtual
        </code>
        destructors.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c10-sec-0021">
        </span>
        <h5 class="calibre35" id="head-5-74">
         How virtual Is Implemented
        </h5>
        <p class="calibre13" id="c10-para-0070">
         To understand how member function hiding is avoided, you need to know a bit more about what the
         <code class="calibre21">
          virtual
         </code>
         keyword actually does. When a class is compiled in C++, a binary object is created that contains all member functions for the class. In the non-
         <code class="calibre21">
          virtual
         </code>
         case, the code to transfer control to the appropriate member function is hard-coded directly where the member function is called based on the compile-time type. This is called
         <i class="calibre18">
          static binding
         </i>
         , also known as
         <i class="calibre18">
          early binding
         </i>
         .
        </p>
        <p class="calibre13" id="c10-para-0071">
         If the member function is declared
         <code class="calibre21">
          virtual
         </code>
         , the correct implementation is called through the use of a special area of memory called the
         <i class="calibre18">
          vtable
         </i>
         , or “
         <i class="calibre18">
          virtual table
         </i>
         .” Each class that has one or more virtual member functions has a vtable, and every object of such a class contains a pointer to said vtable. This vtable contains pointers to the implementations of the
         <code class="calibre21">
          virtual
         </code>
         member functions. In this way, when a member function is called on a pointer or reference to an object, its vtable pointer is followed, and
         <span aria-label="367" class="calibre20" epub:type="pagebreak" id="Page_367" role="doc-pagebreak">
         </span>
         the appropriate version of the member function is executed based on the actual type of the object at run time. This is called
         <i class="calibre18">
          dynamic binding
         </i>
         , also known as
         <i class="calibre18">
          late binding
         </i>
         . It's important to remember that this dynamic binding works only when using pointers or references to objects. If you call a
         <code class="calibre21">
          virtual
         </code>
         member function directly on an object, then that call will use static binding resolved at compile time.
        </p>
        <p class="calibre13">
         To better understand how vtables make overriding of member functions possible, take the following
         <code class="calibre21">
          Base
         </code>
         and
         <code class="calibre21">
          Derived
         </code>
         classes as an example:
        </p>
        <pre class="calibre26" id="c10-code-0028"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual void func1();</code>
<code class="calibre21">        virtual void func2();</code>
<code class="calibre21">        void nonVirtualFunc();</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void func2() override;</code>
<code class="calibre21">        void nonVirtualFunc();</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         For this example, assume that you have the following two instances:
        </p>
        <pre class="calibre26" id="c10-code-0029"><code class="calibre21">Base myBase;</code>
<code class="calibre21">Derived myDerived;</code></pre>
        <p class="calibre13" id="c10-para-0074">
         <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0005" id="R_c10-fig-0005">
          Figure 10.5
         </a>
         shows a high-level view of the vtables of both instances. The
         <code class="calibre21">
          myBase
         </code>
         object contains a pointer to its vtable. This vtable has two entries, one for
         <code class="calibre21">
          func1()
         </code>
         and one for
         <code class="calibre21">
          func2()
         </code>
         . Those entries point to the implementations of
         <code class="calibre21">
          Base::func1()
         </code>
         and
         <code class="calibre21">
          Base::func2()
         </code>
         .
        </p>
        <figure class="calibre36">
         <img alt="A set of two variables. 1. myBase. It has two base functions. 2. myDerived. It has two derived functions." class="center" src="images/c10f005.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0005" id="c10-fig-0005" role="doc-backlink">
             <b class="calibre14">
              FIGURE 10.5
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <p class="calibre13" id="c10-para-0075">
         <code class="calibre21">
          myDerived
         </code>
         also contains a pointer to its vtable, which also has two entries, one for
         <code class="calibre21">
          func1()
         </code>
         and one for
         <code class="calibre21">
          func2()
         </code>
         . Its
         <code class="calibre21">
          func1()
         </code>
         entry points to
         <code class="calibre21">
          Base::func1()
         </code>
         because
         <code class="calibre21">
          Derived
         </code>
         does not override
         <code class="calibre21">
          func1()
         </code>
         . On the other hand, its
         <code class="calibre21">
          func2()
         </code>
         entry points to
         <code class="calibre21">
          Derived::func2()
         </code>
         .
        </p>
        <p class="calibre13" id="c10-para-0076">
         Note that both vtables do not contain any entry for the
         <code class="calibre21">
          nonVirtualFunc()
         </code>
         member function because that member function is not
         <code class="calibre21">
          virtual
         </code>
         .
        </p>
       </section>
       <span aria-label="368" class="calibre20" epub:type="pagebreak" id="Page_368" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c10-sec-0022">
        </span>
        <h5 class="calibre35" id="head-5-75">
         The Justification for virtual
        </h5>
        <p class="calibre13" id="c10-para-0077">
         In some languages, such as Java, all member functions are automatically
         <code class="calibre21">
          virtual
         </code>
         so they can be overridden properly. In C++ that's not the case. The argument against making everything
         <code class="calibre21">
          virtual
         </code>
         in C++, and the reason that the keyword was created in the first place, has to do with the overhead of the vtable. To call a
         <code class="calibre21">
          virtual
         </code>
         member function, the program needs to perform an extra operation by dereferencing the pointer to the appropriate code to execute. This is a miniscule performance hit in most cases, but the designers of C++ thought that it was better, at least at the time, to let the programmer decide if the performance hit was necessary. If the member function was never going to be overridden, there was no need to make it
         <code class="calibre21">
          virtual
         </code>
         and take the performance hit. However, with today's CPUs, the performance hit is measured in fractions of a nanosecond, and this will keep getting smaller with future CPUs. In most applications, you will not have a measurable performance difference between using
         <code class="calibre21">
          virtual
         </code>
         member functions and avoiding them.
        </p>
        <p class="calibre13" id="c10-para-0078">
         Still, in certain specific use cases, the performance overhead might be too costly, and you may need to have an option to avoid the hit. For example, suppose you have a
         <code class="calibre21">
          Point
         </code>
         class that has a
         <code class="calibre21">
          virtual
         </code>
         member function. If you have another data structure that stores millions or even billions of
         <code class="calibre21">
          Point
         </code>
         s, calling a virtual member function on each point creates significant overhead. In that case, it's probably wise to avoid any
         <code class="calibre21">
          virtual
         </code>
         member functions in your
         <code class="calibre21">
          Point
         </code>
         class.
        </p>
        <p class="calibre13" id="c10-para-0079">
         There is also a tiny hit to memory usage for each object. In addition to the implementation of the member function, each object also needs a pointer for its vtable, which takes up a tiny amount of space. This is not an issue in the majority of cases. However, sometimes it does matter. Take again the
         <code class="calibre21">
          Point
         </code>
         class and the container storing billions of
         <code class="calibre21">
          Point
         </code>
         s. In that case, the additional required memory becomes significant.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c10-sec-0023">
        </span>
        <h5 class="calibre35" id="head-5-76">
         The Need for virtual Destructors
        </h5>
        <p class="calibre13" id="c10-para-0080">
         Destructors should almost always be
         <code class="calibre21">
          virtual
         </code>
         . Making your destructors non-
         <code class="calibre21">
          virtual
         </code>
         can easily result in situations in which memory is not freed by object destruction. Only for a class that is marked as
         <code class="calibre21">
          final
         </code>
         could you make its destructor non-
         <code class="calibre21">
          virtual
         </code>
         .
        </p>
        <p class="calibre13" id="c10-para-0081">
         For example, if a derived class uses memory that is dynamically allocated in the constructor and deleted in the destructor, it will never be freed if the destructor is never called. Similarly, if your derived class has members that are automatically deleted when an instance of the class is destroyed, such as
         <code class="calibre21">
          std::unique_ptr
         </code>
         s, then those members will not get deleted either if the destructor is never called.
        </p>
        <p class="calibre13">
         As the following code shows, it is easy to “trick” the compiler into skipping the call to the destructor if it is non-
         <code class="calibre21">
          virtual
         </code>
         :
        </p>
        <pre class="calibre26" id="c10-code-0030"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Base() = default;</code>
<code class="calibre21">        ˜Base() {}</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Derived()</code>
<code class="calibre21">        {</code>
<span aria-label="369" class="calibre20" epub:type="pagebreak" id="Page_369" role="doc-pagebreak"></span><code class="calibre21">            m_string = new char[30];</code>
<code class="calibre21">            println("m_string allocated");</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        ˜Derived()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            delete[] m_string;</code>
<code class="calibre21">            println("m_string deallocated");</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        char* m_string;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Base* ptr { new Derived {} };   <span class="color">// m_string is allocated here.</span></code>
<code class="calibre21">    delete ptr; <span class="color">// ˜Base is called, but not ˜Derived because the destructor</span></code>
<code class="calibre21">                <span class="color">// is not virtual!</span></code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         As you can see from the following output, the destructor of the
         <code class="calibre21">
          Derived
         </code>
         object is never called, that is, the “m_string deallocated” message is never displayed:
        </p>
        <pre class="calibre26" id="c10-code-0031"><code class="calibre21">m_string allocated</code></pre>
        <p class="calibre13" id="c10-para-0084">
         Technically, the behavior of the
         <code class="calibre21">
          delete
         </code>
         call in the preceding code is undefined by the standard. A C++ compiler could do whatever it wants in such undefined situations. However, most compilers simply call the destructor of the base class, and not the destructor of the derived class.
        </p>
        <p class="calibre13">
         The fix is to mark the destructor in the base class as
         <code class="calibre21">
          virtual
         </code>
         . If you don't need to do any extra work in that destructor but want to make it
         <code class="calibre21">
          virtual
         </code>
         , you can explicitly default it. Here's an example:
        </p>
        <pre class="calibre26" id="c10-code-0032"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Base() = default;</code>
<code class="calibre21">        <b class="calibre14">virtual ˜Base() = default;</b></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         With this change, the output is as expected:
        </p>
        <pre class="calibre26" id="c10-code-0033"><code class="calibre21">m_string allocated</code>
<code class="calibre21">m_string deallocated</code></pre>
        <p class="calibre13">
         Note that since C++11, the generation of a copy constructor and copy assignment operator is deprecated if the class has a user-declared destructor. Basically, once you have a user-declared destructor, the rule of five kicks in. This means you need to declare a copy constructor, copy assignment operator, move constructor, and move assignment operator, possibly by explicitly defaulting them. This is not done in the examples in this chapter in the interest of keeping them concise and to the point.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c10-para-0088">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Unless you have a specific reason not to, or the class is marked as
            </i>
            <code class="calibre21">
             final
            </code>
            <i class="calibre18">
             , destructors should be marked as
            </i>
            <code class="calibre21">
             virtual
            </code>
            <i class="calibre18">
             . Constructors cannot and need not be
            </i>
            <code class="calibre21">
             virtual
            </code>
            <i class="calibre18">
             because you always specify the exact class being constructed when creating an object.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         <span aria-label="370" class="calibre20" epub:type="pagebreak" id="Page_370" role="doc-pagebreak">
         </span>
         Earlier in this chapter it was advised to use the
         <code class="calibre21">
          override
         </code>
         keyword on member functions that are meant to override base class member functions. It's also possible to use the
         <code class="calibre21">
          override
         </code>
         keyword on a destructor. This makes sure that the compiler will trigger an error if the destructor in the base class is not
         <code class="calibre21">
          virtual
         </code>
         . You can combine
         <code class="calibre21">
          virtual
         </code>
         ,
         <code class="calibre21">
          override
         </code>
         , and
         <code class="calibre21">
          default
         </code>
         . Here's an example:
        </p>
        <pre class="calibre26" id="c10-code-0034"><code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜Derived() override = default;</code>
<code class="calibre21">};</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0025">
       </span>
       <h4 class="calibre29" id="head-4-199">
        Preventing Overriding
       </h4>
       <p class="calibre13">
        Besides marking an entire class as
        <code class="calibre21">
         final
        </code>
        , C++ also allows you to mark individual member functions as
        <code class="calibre21">
         final
        </code>
        . Such member functions cannot be overridden in a further derived class. For example, overriding
        <code class="calibre21">
         someFunction()
        </code>
        from the following
        <code class="calibre21">
         Derived
        </code>
        class in
        <code class="calibre21">
         DerivedDerived
        </code>
        results in a compilation error:
       </p>
       <pre class="calibre26" id="c10-code-0035"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜Base() = default;</code>
<code class="calibre21">        virtual void someFunction();</code>
<code class="calibre21">};</code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">void someFunction() override final;</b></code>
<code class="calibre21">};</code>
<code class="calibre21">class DerivedDerived : public Derived</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">void someFunction() override;</b>  <span class="color">// Compilation error.</span></code>
<code class="calibre21">};</code></pre>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-123" class="calibre2">
     <span class="calibre" id="c10-sec-0026">
     </span>
     <h2 class="calibre6" id="head-2-123">
      INHERITANCE FOR REUSE
     </h2>
     <p class="calibre13" id="c10-para-0091">
      Now that you are familiar with the basic syntax for inheritance, it's time to explore one of the main reasons that inheritance is an important feature of the C++ language. Inheritance is a vehicle that allows you to leverage existing code. This section presents an example of inheritance for the purpose of code reuse.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0027">
      </span>
      <h3 class="calibre27" id="head-3-208">
       The WeatherPrediction Class
      </h3>
      <p class="calibre13">
       Imagine that you are given the task of writing a program to issue simple weather predictions, working with both Fahrenheit and Celsius. Weather predictions may be a little bit out of your area of expertise as a programmer, so you obtain a third-party class library that was written to make weather predictions based on the current temperature and the current distance between Jupiter and Mars (hey, it's plausible). This third-party package is distributed as a compiled library to protect the intellectual
       <span aria-label="371" class="calibre20" epub:type="pagebreak" id="Page_371" role="doc-pagebreak">
       </span>
       property of the prediction algorithms, but you do get to see the class definition. The
       <code class="calibre21">
        weather_prediction
       </code>
       module interface file looks as follows:
      </p>
      <pre class="calibre26" id="c10-code-0036"><code class="calibre21">export module weather_prediction;</code>
<code class="calibre21">import std;</code>
<code class="calibre21"><span class="color">// Predicts the weather using proven new-age techniques given the current</span></code>
<code class="calibre21"><span class="color">// temperature and the distance from Jupiter to Mars. If these values are</span></code>
<code class="calibre21"><span class="color">// not provided, a guess is still given but it's only 99% accurate.</span></code>
<code class="calibre21">export class WeatherPrediction</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Virtual destructor</span></code>
<code class="calibre21">        virtual ˜WeatherPrediction();</code>
<code class="calibre21">        <span class="color">// Sets the current temperature in Fahrenheit</span></code>
<code class="calibre21">        virtual void setCurrentTempFahrenheit(int temp);</code>
<code class="calibre21">        <span class="color">// Sets the current distance between Jupiter and Mars</span></code>
<code class="calibre21">        virtual void setPositionOfJupiter(int distanceFromMars);</code>
<code class="calibre21">        <span class="color">// Gets the prediction for tomorrow's temperature</span></code>
<code class="calibre21">        virtual int getTomorrowTempFahrenheit() const;</code>
<code class="calibre21">        <span class="color">// Gets the probability of rain tomorrow. 1 means</span></code>
<code class="calibre21">        <span class="color">// definite rain. 0 means no chance of rain.</span></code>
<code class="calibre21">        virtual double getChanceOfRain() const;</code>
<code class="calibre21">        <span class="color">// Displays the result to the user in this format:</span></code>
<code class="calibre21">        <span class="color">// Result: x.xx chance. Temp. xx</span></code>
<code class="calibre21">        virtual void showResult() const;</code>
<code class="calibre21">        <span class="color">// Returns a string representation of the temperature</span></code>
<code class="calibre21">        virtual std::string getTemperature() const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_currentTempFahrenheit { 0 };</code>
<code class="calibre21">        int m_distanceFromMars { 0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c10-para-0093">
       Note that this class marks all member functions as
       <code class="calibre21">
        virtual
       </code>
       , because the class presumes that they might get overridden in derived classes.
      </p>
      <p class="calibre13" id="c10-para-0094">
       This class solves most of the problems for your program. However, as is usually the case, it's not
       <i class="calibre18">
        exactly
       </i>
       right for your needs. First, all the temperatures are given in Fahrenheit. Your program needs to operate in Celsius as well. Also, the
       <code class="calibre21">
        showResult()
       </code>
       member function might not display the result in a way you require.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0028">
      </span>
      <h3 class="calibre27" id="head-3-209">
       Adding Functionality in a Derived Class
      </h3>
      <p class="calibre13">
       When you learned about inheritance in
       <a class="calibre5" href="c05.xhtml">
        Chapter 5
       </a>
       , adding functionality was the first technique described. Fundamentally, your program needs something just like the
       <code class="calibre21">
        WeatherPrediction
       </code>
       class but with a few extra bells and whistles. Sounds like a good case for inheritance to reuse code. To begin, define a new class,
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       , that inherits from
       <code class="calibre21">
        WeatherPrediction
       </code>
       :
      </p>
      <pre class="calibre26" id="c10-code-0037"><code class="calibre21">import weather_prediction;</code>
<code class="calibre21"> </code>
<code class="calibre21">export class MyWeatherPrediction : public WeatherPrediction</code>
<code class="calibre21">{</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c10-para-0096">
       <span aria-label="372" class="calibre20" epub:type="pagebreak" id="Page_372" role="doc-pagebreak">
       </span>
       The preceding class definition compiles just fine. The
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       class can already be used in place of
       <code class="calibre21">
        WeatherPrediction
       </code>
       . It provides the same functionality, but nothing new yet. For the first modification, you might want to add knowledge of the Celsius scale to the class. There is a bit of a quandary here because you don't know what the class is doing internally. If all of the internal calculations are made using Fahrenheit, how do you add support for Celsius? One way is to use the derived class to act as a go-between, interfacing between the user, who can use either scale, and the base class, which only understands Fahrenheit.
      </p>
      <p class="calibre13">
       The first step in supporting Celsius is to add new member functions that allow clients to set the current temperature in Celsius instead of Fahrenheit and to get tomorrow's prediction in Celsius instead of Fahrenheit. You also need private helper functions that convert between Celsius and Fahrenheit in both directions. These functions can be
       <code class="calibre21">
        static
       </code>
       because they are the same for all instances of the class.
      </p>
      <pre class="calibre26" id="c10-code-0038"><code class="calibre21">export class MyWeatherPrediction : public WeatherPrediction</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">public:</b></code>
<code class="calibre21">        <b class="calibre14">virtual void setCurrentTempCelsius(int temp);</b></code>
<code class="calibre21">        <b class="calibre14">virtual int getTomorrowTempCelsius() const;</b></code>
<code class="calibre21">    <b class="calibre14">private:</b></code>
<code class="calibre21">        <b class="calibre14">static int convertCelsiusToFahrenheit(int celsius);</b></code>
<code class="calibre21">        <b class="calibre14">static int convertFahrenheitToCelsius(int fahrenheit);</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c10-para-0098">
       The new member functions follow the same naming convention as the parent class. Remember that from the point of view of other code, a
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       object has all of the functionality defined in both
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       and
       <code class="calibre21">
        WeatherPrediction
       </code>
       . Adopting the parent class's naming convention presents a consistent interface.
      </p>
      <p class="calibre13">
       The implementation of the Celsius/Fahrenheit conversion functions is left as an exercise for the reader—and a fun one at that! The other two member functions are more interesting. To set the current temperature in Celsius, you need to convert the temperature first and then present it to the parent class in units that it understands:
      </p>
      <pre class="calibre26" id="c10-code-0039"><code class="calibre21">void MyWeatherPrediction::setCurrentTempCelsius(int temp)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int fahrenheitTemp { convertCelsiusToFahrenheit(temp) };</code>
<code class="calibre21">    setCurrentTempFahrenheit(fahrenheitTemp);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       As you can see, once the temperature is converted, the member function calls the existing functionality from the base class. Similarly, the implementation of
       <code class="calibre21">
        getTomorrowTempCelsius()
       </code>
       uses the parent's existing functionality to get the temperature in Fahrenheit, but converts the result before returning it:
      </p>
      <pre class="calibre26" id="c10-code-0040"><code class="calibre21">int MyWeatherPrediction::getTomorrowTempCelsius() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    int fahrenheitTemp { getTomorrowTempFahrenheit() };</code>
<code class="calibre21">    return convertFahrenheitToCelsius(fahrenheitTemp);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c10-para-0101">
       The two new member functions effectively reuse the parent class because they “wrap” the existing functionality in a way that provides a new interface for using it.
      </p>
      <p class="calibre13" id="c10-para-0102">
       <span aria-label="373" class="calibre20" epub:type="pagebreak" id="Page_373" role="doc-pagebreak">
       </span>
       You can also add new functionality completely unrelated to existing functionality of the parent class. For example, you could add a member function that retrieves alternative forecasts from the Internet or a member function that suggests an activity based on the predicted weather.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0029">
      </span>
      <h3 class="calibre27" id="head-3-210">
       Replacing Functionality in a Derived Class
      </h3>
      <p class="calibre13" id="c10-para-0103">
       The other major technique for inheritance is replacing existing functionality. The
       <code class="calibre21">
        showResult()
       </code>
       member function in the
       <code class="calibre21">
        WeatherPrediction
       </code>
       class is in dire need of a facelift.
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       can override this member function to replace the behavior with its own implementation.
      </p>
      <p class="calibre13">
       The new class definition for
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       is as follows:
      </p>
      <pre class="calibre26" id="c10-code-0041"><code class="calibre21">export class MyWeatherPrediction : public WeatherPrediction</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual void setCurrentTempCelsius(int temp);</code>
<code class="calibre21">        virtual int getTomorrowTempCelsius() const;</code>
<code class="calibre21">        <b class="calibre14">void showResult() const override;</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        static int convertCelsiusToFahrenheit(int celsius);</code>
<code class="calibre21">        static int convertFahrenheitToCelsius(int fahrenheit);</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Here is a new, user-friendlier implementation of the overridden
       <code class="calibre21">
        showResult()
       </code>
       member function:
      </p>
      <pre class="calibre26" id="c10-code-0042"><code class="calibre21">void MyWeatherPrediction::showResult() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("Tomorrow will be {} degrees Celsius ({} degrees Fahrenheit)",</code>
<code class="calibre21">        getTomorrowTempCelsius(), getTomorrowTempFahrenheit());</code>
<code class="calibre21">    println("Chance of rain is {}%", getChanceOfRain() * 100);</code>
<code class="calibre21">    if (getChanceOfRain()&gt; 0.5) { println("Bring an umbrella!"); }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c10-para-0106">
       To clients using this class, it's as if the old version of
       <code class="calibre21">
        showResult()
       </code>
       never existed. As long as the object is a
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       object, the new version is called. As a result of these changes,
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       has emerged as a new class with new functionality tailored to a more specific purpose. Yet, it did not require much code because it leveraged its base class's existing functionality.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-124" class="calibre2">
     <span class="calibre" id="c10-sec-0030">
     </span>
     <h2 class="calibre6" id="head-2-124">
      RESPECT YOUR PARENTS
     </h2>
     <p class="calibre13" id="c10-para-0107">
      When you write a derived class, you need to be aware of the interaction between parent classes and child classes. Issues such as order of creation, constructor chaining, and casting are all potential sources of bugs.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0031">
      </span>
      <h3 class="calibre27" id="head-3-211">
       Parent Constructors
      </h3>
      <p class="calibre13">
       Objects don't spring to life all at once; they must be constructed along with their parents and any objects that are contained within them. C++ defines the creation order as follows:
      </p>
      <ol class="calibre7" id="c10-list-0003">
       <li class="calibre9" id="c10-li-0012">
        If the class has a base class, the default constructor of the base class is executed, unless there is a call to a base class constructor in the ctor-initializer, in which case that constructor is called instead of the default constructor.
       </li>
       <li class="calibre9" id="c10-li-0013">
        <span aria-label="374" class="calibre20" epub:type="pagebreak" id="Page_374" role="doc-pagebreak">
        </span>
        Non-
        <code class="calibre21">
         static
        </code>
        data members of the class are constructed in the order in which they are declared.
       </li>
       <li class="calibre9" id="c10-li-0014">
        The body of the class's constructor is executed.
       </li>
      </ol>
      <p class="calibre13">
       These rules can apply recursively. If the class has a grandparent, the grandparent is initialized before the parent, and so on. The following code shows this creation order. The proper execution of this code outputs
       <code class="calibre21">
        123
       </code>
       .
      </p>
      <pre class="calibre26" id="c10-code-0043"><code class="calibre21">class Something</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Something() { print("2"); }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Base() { print("1"); }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Derived() { print("3"); }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        Something m_dataMember;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Derived myDerived;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c10-para-0110">
       When the
       <code class="calibre21">
        myDerived
       </code>
       object is created, the constructor for
       <code class="calibre21">
        Base
       </code>
       is called first, outputting the string
       <code class="calibre21">
        "1"
       </code>
       . Next,
       <code class="calibre21">
        m_dataMember
       </code>
       is initialized, calling the
       <code class="calibre21">
        Something
       </code>
       constructor, which outputs the string
       <code class="calibre21">
        "2"
       </code>
       . Finally, the
       <code class="calibre21">
        Derived
       </code>
       constructor is called, which outputs
       <code class="calibre21">
        "3"
       </code>
       .
      </p>
      <p class="calibre13">
       Note that the
       <code class="calibre21">
        Base
       </code>
       constructor is called automatically. C++ automatically calls the default constructor for the parent class if one exists. If no default constructor exists in the parent class or if one does exist but you want to use an alternate parent constructor, you can
       <i class="calibre18">
        chain
       </i>
       the constructor just as when initializing data members in the ctor-initializer. For example, the following code shows a version of
       <code class="calibre21">
        Base
       </code>
       that lacks a default constructor. The associated version of
       <code class="calibre21">
        Derived
       </code>
       must explicitly tell the compiler how to call the
       <code class="calibre21">
        Base
       </code>
       constructor or the code will not compile.
      </p>
      <pre class="calibre26" id="c10-code-0044"><code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Base(int i) {}</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<span aria-label="375" class="calibre20" epub:type="pagebreak" id="Page_375" role="doc-pagebreak"></span><code class="calibre21">    public:</code>
<code class="calibre21">        Derived() : Base { 7 } { <span class="color">/* Other Derived's initialization … */</span> }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        Derived
       </code>
       constructor passes a fixed value (7) to the
       <code class="calibre21">
        Base
       </code>
       constructor. Of course,
       <code class="calibre21">
        Derived
       </code>
       could also pass a variable:
      </p>
      <pre class="calibre26" id="c10-code-0045"><code class="calibre21">Derived::Derived(int i) : Base { i } { <span class="color">/* Other Derived's initialization … */</span> }</code></pre>
      <p class="calibre13" id="c10-para-0113">
       Passing constructor arguments from the derived class to the base class is perfectly fine and quite normal. Passing data members, however, will not work. The code will compile, but remember that data members are not initialized until
       <i class="calibre18">
        after
       </i>
       the base class is constructed. If you pass a data member as an argument to the parent constructor, it will be uninitialized.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0032">
      </span>
      <h3 class="calibre27" id="head-3-212">
       Parent Destructors
      </h3>
      <p class="calibre13">
       Because destructors cannot take arguments, the language can always automatically call the destructor for parent classes. The order of destruction is conveniently the reverse of the order of construction:
      </p>
      <ol class="calibre7" id="c10-list-0004">
       <li class="calibre9" id="c10-li-0015">
        The body of the class's destructor is called.
       </li>
       <li class="calibre9" id="c10-li-0016">
        Any data members of the class are destroyed in the reverse order of their construction.
       </li>
       <li class="calibre9" id="c10-li-0017">
        The parent class, if any, is destructed.
       </li>
      </ol>
      <p class="calibre13">
       Again, these rules apply recursively. The lowest member of the chain is always destructed first. The following code adds destructors to the earlier example. The destructors are all declared
       <code class="calibre21">
        virtual
       </code>
       ! If executed, this code outputs
       <code class="calibre21">
        "123321"
       </code>
       .
      </p>
      <pre class="calibre26" id="c10-code-0046"><code class="calibre21">class Something</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Something() { print("2"); }</code>
<code class="calibre21">        <b class="calibre14">virtual ˜Something() { print("2"); }</b></code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Base() { print("1"); }</code>
<code class="calibre21">        <b class="calibre14">virtual ˜Base() { print("1"); }</b></code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Derived : public Base</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Derived() { print("3"); }</code>
<code class="calibre21">        <b class="calibre14">virtual ˜Derived() override { print("3"); }</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        Something m_dataMember;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="376" class="calibre20" epub:type="pagebreak" id="Page_376" role="doc-pagebreak">
       </span>
       If the preceding destructors were not declared
       <code class="calibre21">
        virtual
       </code>
       , the code would seem to work fine. However, if code ever called
       <code class="calibre21">
        delete
       </code>
       on a
       <code class="calibre21">
        Base
       </code>
       pointer that was really pointing to a
       <code class="calibre21">
        Derived
       </code>
       instance, the destruction chain would begin in the wrong place. For example, if you remove the
       <code class="calibre21">
        virtual
       </code>
       and
       <code class="calibre21">
        override
       </code>
       keywords from all destructors in the previous code, then a problem arises when a
       <code class="calibre21">
        Derived
       </code>
       object is accessed as a pointer to a
       <code class="calibre21">
        Base
       </code>
       and deleted, as shown here:
      </p>
      <pre class="calibre26" id="c10-code-0047"><code class="calibre21">Base* ptr { new Derived{} };</code>
<code class="calibre21">delete ptr;</code></pre>
      <p class="calibre13" id="c10-para-0117">
       The output of this code is a shockingly terse
       <code class="calibre21">
        "1231"
       </code>
       . When the
       <code class="calibre21">
        ptr
       </code>
       variable is deleted, only the
       <code class="calibre21">
        Base
       </code>
       destructor is called because the destructor was not declared
       <code class="calibre21">
        virtual
       </code>
       . As a result, the
       <code class="calibre21">
        Derived
       </code>
       destructor is not called, and the destructors for its data members are not called!
      </p>
      <p class="calibre13">
       Technically, you could fix the preceding problem by marking only the
       <code class="calibre21">
        Base
       </code>
       destructor
       <code class="calibre21">
        virtual
       </code>
       . The “virtualness” automatically applies to any derived classes. However, I advocate explicitly making all destructors
       <code class="calibre21">
        virtual
       </code>
       so that you never have to worry about it.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c10-para-0119">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Always make your destructors
          </i>
          <code class="calibre21">
           virtual
          </code>
          <i class="calibre18">
           ! The compiler-generated default destructor is not
          </i>
          <code class="calibre21">
           virtual
          </code>
          <i class="calibre18">
           , so you should define (or explicitly default) a
          </i>
          <code class="calibre21">
           virtual
          </code>
          <i class="calibre18">
           destructor, at least for your non-
          </i>
          <code class="calibre21">
           final
          </code>
          <i class="calibre18">
           base classes.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0034">
      </span>
      <h3 class="calibre27" id="head-3-213">
       virtual Member Function Calls within Constructors and Destructor
      </h3>
      <p class="calibre13" id="c10-para-0120">
       <code class="calibre21">
        virtual
       </code>
       member functions behave differently in constructors and destructors. If your derived class has overridden a
       <code class="calibre21">
        virtual
       </code>
       member function from a base class, calling that member function from a base class constructor or destructor calls the base class implementation of that
       <code class="calibre21">
        virtual
       </code>
       member function and not your overridden version in the derived class! In other words, calls to
       <code class="calibre21">
        virtual
       </code>
       member functions from within a constructor or destructor are resolved statically at compile time.
      </p>
      <p class="calibre13" id="c10-para-0121">
       The reason for this behavior of constructors has to do with the order of initialization when constructing an instance of a derived class. When creating such an instance, the constructor of any base class is called first, before the derived class instance is fully initialized. Hence, it would be dangerous to already call overridden
       <code class="calibre21">
        virtual
       </code>
       member functions from the not-yet-fully initialized derived class. A similar reasoning holds for destructors due to the order of destruction when destroying an object.
      </p>
      <p class="calibre13" id="c10-para-0122">
       If you really need polymorphic behavior in your constructors, although this is not recommended, you can define an
       <code class="calibre21">
        initialize() virtual
       </code>
       member function in your base class, which derived classes can override. Clients creating an instance of your class will have to call this
       <code class="calibre21">
        initialize()
       </code>
       member function after construction has finished.
      </p>
      <p class="calibre13" id="c10-para-0123">
       Similarly, if you need polymorphic behavior in your destructor, again, not recommended, you can define a
       <code class="calibre21">
        shutdown() virtual
       </code>
       member function that clients then need to call before the object is destroyed.
      </p>
     </section>
     <span aria-label="377" class="calibre20" epub:type="pagebreak" id="Page_377" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0035">
      </span>
      <h3 class="calibre27" id="head-3-214">
       Referring to Parent Names
      </h3>
      <p class="calibre13">
       When you override a member function in a derived class, you are effectively replacing the original as far as other code is concerned. However, that parent version of the member function still exists, and you may want to make use of it. For example, an overridden member function would like to keep doing what the base class implementation does, plus something else. Take a look at the
       <code class="calibre21">
        getTemperature()
       </code>
       member function in the
       <code class="calibre21">
        WeatherPrediction
       </code>
       class that returns a
       <code class="calibre21">
        string
       </code>
       representation of the current temperature:
      </p>
      <pre class="calibre26" id="c10-code-0048"><code class="calibre21">export class WeatherPrediction</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual std::string getTemperature() const;</code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       You can override this member function in the
       <code class="calibre21">
        MyWeatherPrediction
       </code>
       class as follows:
      </p>
      <pre class="calibre26" id="c10-code-0049"><code class="calibre21">export class MyWeatherPrediction : public WeatherPrediction</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">std::string getTemperature() const override;</b></code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Suppose the derived class wants to add °F to the string by first calling the base class's
       <code class="calibre21">
        getTemperature()
       </code>
       member function and then adding °F to it. You might write this as follows:
      </p>
      <pre class="calibre26" id="c10-code-0050"><code class="calibre21">string MyWeatherPrediction::getTemperature() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Note: \u00B0 is the ISO/IEC 10646 representation of the degree symbol.</span></code>
<code class="calibre21">    return getTemperature() + "\u00B0F";  <span class="color">// BUG</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c10-para-0127">
       However, this does not work because, under the rules of name resolution for C++, it first resolves against the local scope, then resolves against the class scope, and as a result ends up calling
       <code class="calibre21">
        MyWeatherPrediction::getTemperature()
       </code>
       . This causes an infinite recursion until you run out of stack space (some compilers detect this error and report it at compile time).
      </p>
      <p class="calibre13">
       To make this work, you need to use the scope resolution operator as follows:
      </p>
      <pre class="calibre26" id="c10-code-0051"><code class="calibre21">string MyWeatherPrediction::getTemperature() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Note: \u00B0 is the ISO/IEC 10646 representation of the degree symbol.</span></code>
<code class="calibre21">    <b class="calibre14">return WeatherPrediction::getTemperature() + "\u00B0F";</b></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c10-para-0130">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Microsoft Visual C++ supports the non-standard
          </i>
          <code class="calibre21">
           <i class="calibre18">
            __
           </i>
           super
          </code>
          <i class="calibre18">
           keyword (with two underscores). This allows you to write the following:
          </i>
         </p>
         <pre class="calibre26" id="c10-code-0052"><code class="calibre21">    return __super::getTemperature() + "\u00B0F";</code></pre>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c10-para-0132">
       <span aria-label="378" class="calibre20" epub:type="pagebreak" id="Page_378" role="doc-pagebreak">
       </span>
       Calling the parent version of the current member function is a commonly used pattern in C++. If you have a chain of derived classes, each might want to perform the operation already defined by the base class but add their own additional functionality as well.
      </p>
      <p class="calibre13" id="c10-para-0133">
       Let's look at another example. Imagine a class hierarchy of book types, as shown in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0006" id="R_c10-fig-0006">
        Figure 10.6
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A flowchart represents a class hierarchy of book types. It includes the following. 1. Romance. 2. Paperback. 3. Technical. 4. Book." class="center" src="images/c10f006.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0006" id="c10-fig-0006" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.6
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13">
       Because each lower class in the hierarchy further specifies the type of book, a member function that gets the description of a book really needs to take all levels of the hierarchy into consideration. This can be accomplished by chaining to the parent member function. The following code illustrates this pattern:
      </p>
      <pre class="calibre26" id="c10-code-0053"><code class="calibre21">class Book</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜Book() = default;</code>
<code class="calibre21">        virtual string getDescription() const { return "Book"; }</code>
<code class="calibre21">        virtual int getHeight() const { return 120; }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Paperback : public Book</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        string getDescription() const override {</code>
<code class="calibre21">            return "Paperback " + Book::getDescription();</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Romance : public Paperback</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        string getDescription() const override {</code>
<code class="calibre21">            return "Romance " + Paperback::getDescription();</code>
<code class="calibre21">        }</code>
<code class="calibre21">        int getHeight() const override { return Paperback::getHeight() / 2; }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class Technical : public Book</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        string getDescription() const override {</code>
<code class="calibre21">            return "Technical " + Book::getDescription();</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Romance novel;</code>
<code class="calibre21">    Book book;</code>
<code class="calibre21">    println("{}", novel.getDescription()); <span class="color">// Outputs "Romance Paperback Book"</span></code>
<code class="calibre21">    println("{}", book.getDescription());  <span class="color">// Outputs "Book"</span></code>
<code class="calibre21">    println("{}", novel.getHeight());      <span class="color">// Outputs "60"</span></code>
<code class="calibre21">    println("{}", book.getHeight());       <span class="color">// Outputs "120"</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c10-para-0135">
       <span aria-label="379" class="calibre20" epub:type="pagebreak" id="Page_379" role="doc-pagebreak">
       </span>
       The
       <code class="calibre21">
        Book
       </code>
       base class has two
       <code class="calibre21">
        virtual
       </code>
       member functions:
       <code class="calibre21">
        getDescription()
       </code>
       and
       <code class="calibre21">
        getHeight()
       </code>
       . All derived classes override
       <code class="calibre21">
        getDescription()
       </code>
       , but only the
       <code class="calibre21">
        Romance
       </code>
       class overrides
       <code class="calibre21">
        getHeight()
       </code>
       by calling
       <code class="calibre21">
        getHeight()
       </code>
       on its parent class (
       <code class="calibre21">
        Paperback
       </code>
       ) and dividing the result by two.
       <code class="calibre21">
        Paperback
       </code>
       does not override
       <code class="calibre21">
        getHeight()
       </code>
       , but C++ walks up the class hierarchy to find a class that implements
       <code class="calibre21">
        getHeight()
       </code>
       . In this example,
       <code class="calibre21">
        Paperback::getHeight()
       </code>
       resolves to
       <code class="calibre21">
        Book::getHeight()
       </code>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0037">
      </span>
      <h3 class="calibre27" id="head-3-215">
       Casting Up and Down
      </h3>
      <p class="calibre13">
       As you have already seen, an object can be cast or assigned to its parent class. Here's an example:
      </p>
      <pre class="calibre26" id="c10-code-0054"><code class="calibre21">Derived myDerived;</code>
<code class="calibre21">Base myBase { myDerived };  <span class="color">// Slicing!</span></code></pre>
      <p class="calibre13">
       Slicing occurs in situations like this because the end result is a
       <code class="calibre21">
        Base
       </code>
       object, and
       <code class="calibre21">
        Base
       </code>
       objects lack the additional functionality defined in the
       <code class="calibre21">
        Derived
       </code>
       class. However, slicing does
       <i class="calibre18">
        not
       </i>
       occur if a derived class is assigned to a pointer or reference to its base class:
      </p>
      <pre class="calibre26" id="c10-code-0055"><code class="calibre21">Base&amp; myBase { myDerived }; <span class="color">// No slicing!</span></code></pre>
      <p class="calibre13">
       This is generally the correct way to refer to a derived class in terms of its base class, also called
       <i class="calibre18">
        upcasting
       </i>
       . This is why it's always a good idea for functions to take references to classes instead of directly using objects of those classes. By using references, derived classes can be passed in without slicing.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c10-para-0139">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           When upcasting, use a pointer or reference to the base class to avoid slicing
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Casting from a base class to one of its derived classes, also called
       <i class="calibre18">
        downcasting
       </i>
       , is often frowned upon by professional C++ programmers because there is no guarantee that the object really belongs to that derived class and because downcasting is a sign of bad design. For example, consider the following code:
      </p>
      <pre class="calibre26" id="c10-code-0056"><code class="calibre21">void presumptuous(Base* base)</code>
<code class="calibre21">{</code>
<code class="calibre21">    Derived* myDerived { static_cast&lt;Derived*&gt;(base) };</code>
<code class="calibre21">    <span class="color">// Proceed to access Derived member functions on myDerived.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c10-para-0141">
       If the author of
       <code class="calibre21">
        presumptuous()
       </code>
       also writes the code that calls
       <code class="calibre21">
        presumptuous()
       </code>
       , everything will probably be OK, albeit still ugly, because the author knows that the function expects the argument to be of type
       <code class="calibre21">
        Derived*
       </code>
       . However, if other programmers call
       <code class="calibre21">
        presumptuous()
       </code>
       , they might pass in a
       <code class="calibre21">
        Base*
       </code>
       . There are no compile-time checks that can be done to enforce the type of the argument, and the function blindly assumes that
       <code class="calibre21">
        base
       </code>
       is actually a pointer to a
       <code class="calibre21">
        Derived
       </code>
       object.
      </p>
      <p class="calibre13" id="c10-para-0142">
       Downcasting is sometimes necessary, and you can use it effectively in controlled circumstances. However, if you are going to downcast, you should use a
       <code class="calibre21">
        dynamic_cast()
       </code>
       , which uses the object's built-in knowledge of its type to refuse a cast that doesn't make sense. This built-in knowledge typically resides in the vtable, which means that
       <code class="calibre21">
        dynamic_cast()
       </code>
       works only for objects with a vtable, that is,
       <span aria-label="380" class="calibre20" epub:type="pagebreak" id="Page_380" role="doc-pagebreak">
       </span>
       objects with at least one
       <code class="calibre21">
        virtual
       </code>
       member. If a
       <code class="calibre21">
        dynamic_cast()
       </code>
       fails on a pointer, the result will be
       <code class="calibre21">
        nullptr
       </code>
       instead of pointing to nonsensical data. If a
       <code class="calibre21">
        dynamic_cast()
       </code>
       fails on an object reference, an
       <code class="calibre21">
        std::bad_cast
       </code>
       exception will be thrown. The last section of this chapter discusses the different options for casting in more detail.
      </p>
      <p class="calibre13">
       The previous example could have been written as follows:
      </p>
      <pre class="calibre26" id="c10-code-0057"><code class="calibre21">void lessPresumptuous(Base* base)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">Derived* myDerived { dynamic_cast&lt;Derived*&gt;(base) };</b></code>
<code class="calibre21">    <b class="calibre14">if (myDerived != nullptr) {</b></code>
<code class="calibre21">        <span class="color">// Proceed to access Derived member functions on myDerived.</span></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       However, keep in mind that the use of downcasting is often a sign of a bad design. You should rethink and modify your design so that downcasting can be avoided. For example, the
       <code class="calibre21">
        lessPresumptuous()
       </code>
       function only really works with
       <code class="calibre21">
        Derived
       </code>
       objects, so instead of accepting a
       <code class="calibre21">
        Base
       </code>
       pointer, it should simply accept a
       <code class="calibre21">
        Derived
       </code>
       pointer. This eliminates the need for any downcasting. If the function should work with different derived classes, all inheriting from
       <code class="calibre21">
        Base
       </code>
       , then look for a solution that uses polymorphism, which is discussed next.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c10-para-0145">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Use downcasting only when really necessary, and be sure to use
          </i>
          <code class="calibre21">
           dynamic_cast()
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-125" class="calibre2">
     <span class="calibre" id="c10-sec-0040">
     </span>
     <h2 class="calibre6" id="head-2-125">
      INHERITANCE FOR POLYMORPHISM
     </h2>
     <p class="calibre13" id="c10-para-0146">
      Now that you understand the relationship between a derived class and its parent, you can use inheritance in its most powerful scenario—polymorphism.
      <a class="calibre5" href="c05.xhtml">
       Chapter 5
      </a>
      discusses how polymorphism allows you to use objects with a common parent class interchangeably and to use objects in place of their parents.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-216">
       Return of the Spreadsheet
      </h3>
      <p class="calibre13">
       <a class="calibre5" href="c08.xhtml">
        Chapters 8
       </a>
       and
       <a class="calibre5" href="c09.xhtml">
        9
       </a>
       use a spreadsheet program as an example of an application that lends itself to an object-oriented design. A
       <code class="calibre21">
        SpreadsheetCell
       </code>
       represents a single element of data. Up to now, that element always stored a single
       <code class="calibre21">
        double
       </code>
       value. A simplified class definition for
       <code class="calibre21">
        SpreadsheetCell
       </code>
       follows. Note that a cell can be set either as a
       <code class="calibre21">
        double
       </code>
       or as a
       <code class="calibre21">
        string_view
       </code>
       , but it is always stored as a
       <code class="calibre21">
        double
       </code>
       . The current value of the cell, however, is always returned as a
       <code class="calibre21">
        string
       </code>
       for this example.
      </p>
      <pre class="calibre26" id="c10-code-0058"><code class="calibre21">class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual void set(double value);</code>
<code class="calibre21">        virtual void set(std::string_view value);</code>
<code class="calibre21">        virtual std::string getString() const;</code>
<code class="calibre21">     private:</code>
<code class="calibre21">        static std::string doubleToString(double value);</code>
<span aria-label="381" class="calibre20" epub:type="pagebreak" id="Page_381" role="doc-pagebreak"></span><code class="calibre21">        static double stringToDouble(std::string_view value);</code>
<code class="calibre21">        double m_value;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c10-para-0148">
       In a real spreadsheet application, cells can store different things. A cell could store a
       <code class="calibre21">
        double
       </code>
       , but it might just as well store a piece of text. There could also be a need for additional types of cells, such as a formula cell or a date cell. How can you support this?
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0042">
      </span>
      <h3 class="calibre27" id="head-3-217">
       Designing the Polymorphic Spreadsheet Cell
      </h3>
      <p class="calibre13" id="c10-para-0149">
       The
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class is screaming out for a hierarchical makeover. A reasonable approach would be to narrow the scope of the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       to cover only
       <code class="calibre21">
        string
       </code>
       s, perhaps renaming it to
       <code class="calibre21">
        StringSpreadsheetCell
       </code>
       in the process. To handle
       <code class="calibre21">
        double
       </code>
       s, a second class,
       <code class="calibre21">
        DoubleSpreadsheetCell
       </code>
       , would inherit from the
       <code class="calibre21">
        StringSpreadsheetCell
       </code>
       and provide functionality specific to its own format.
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0007" id="R_c10-fig-0007">
        Figure 10.7
       </a>
       illustrates such a design. This approach models inheritance for reuse because the
       <code class="calibre21">
        DoubleSpreadsheetCell
       </code>
       would be deriving from
       <code class="calibre21">
        StringSpreadsheetCell
       </code>
       only to make use of some of its built-in functionality.
      </p>
      <figure class="calibre36">
       <img alt="A set of two boards. It includes the following. A. StringSpreadSheetCell. B. DoubleSpreadSheetCell." class="center" src="images/c10f007.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0007" id="c10-fig-0007" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.7
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c10-para-0150">
       If you were to implement the design shown in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0007">
        Figure 10.7
       </a>
       , you might discover that the derived class would override most, if not all, of the functionality of the base class. Because
       <code class="calibre21">
        double
       </code>
       s are treated differently from
       <code class="calibre21">
        string
       </code>
       s in almost all cases, the relationship may not be quite as it was originally understood. Yet, there clearly is a relationship between a cell containing
       <code class="calibre21">
        string
       </code>
       s and a cell containing
       <code class="calibre21">
        double
       </code>
       s. Rather than using the model in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0007">
        Figure 10.7
       </a>
       , which implies that somehow a
       <code class="calibre21">
        DoubleSpreadsheetCell
       </code>
       “is-a”
       <code class="calibre21">
        StringSpreadsheetCell
       </code>
       , a better design would make these classes peers with a common parent,
       <code class="calibre21">
        SpreadsheetCell
       </code>
       .
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0008" id="R_c10-fig-0008">
        Figure 10.8
       </a>
       shows such a design.
      </p>
      <figure class="calibre36">
       <img alt="A set of three boards. It includes the following. A. SpreadSheetCell. B. DoubleSpreadSheetCell. C. StringSpreadSheetCell." class="center" src="images/c10f008.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c10_split_000.xhtml#R_c10-fig-0008" id="c10-fig-0008" role="doc-backlink">
           <b class="calibre14">
            FIGURE 10.8
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13">
       The design in
       <a class="calibre5" href="c10_split_000.xhtml#c10-fig-0008">
        Figure 10.8
       </a>
       shows a polymorphic approach to the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       hierarchy. Because
       <code class="calibre21">
        DoubleSpreadsheetCell
       </code>
       and
       <code class="calibre21">
        StringSpreadsheetCell
       </code>
       both inherit from a common parent,
       <code class="calibre21">
        SpreadsheetCell
       </code>
       , they are interchangeable in the view of other code. In practical terms, that means the following:
      </p>
      <ul class="check" id="c10-list-0005">
       <li class="calibre9" id="c10-li-0018">
        Both derived classes support the same interface (set of member functions) defined by the base class.
       </li>
       <li class="calibre9" id="c10-li-0019">
        Code that makes use of
        <code class="calibre21">
         SpreadsheetCell
        </code>
        objects can call any member function in the interface without even knowing whether the cell is a
        <code class="calibre21">
         DoubleSpreadsheetCell
        </code>
        or a
        <code class="calibre21">
         StringSpreadsheetCell
        </code>
        .
       </li>
       <li class="calibre9" id="c10-li-0020">
        Through the magic of
        <code class="calibre21">
         virtual
        </code>
        member functions, the appropriate instance of every member function in the interface is called depending on the class of the object.
       </li>
       <li class="calibre9" id="c10-li-0021">
        Other data structures, such as the
        <code class="calibre21">
         Spreadsheet
        </code>
        class described in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        , can contain a collection of multityped cells by referring to the base type.
       </li>
      </ul>
      <span aria-label="382" class="calibre20" epub:type="pagebreak" id="Page_382" role="doc-pagebreak">
      </span>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-218">
       The SpreadsheetCell Base Class
      </h3>
      <p class="calibre13" id="c10-para-0152">
       Because all spreadsheet cells are deriving from the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       base class, it is probably a good idea to write that class first. When designing a base class, you need to consider how the derived classes relate to each other. From this information, you can derive the commonality that will go inside the parent class. For example,
       <code class="calibre21">
        string
       </code>
       cells and
       <code class="calibre21">
        double
       </code>
       cells are similar in that they both contain a single piece of data. Because the data is coming from the user and will be displayed back to the user, the value is set as a
       <code class="calibre21">
        string
       </code>
       and retrieved as a
       <code class="calibre21">
        string
       </code>
       . These behaviors are the shared functionality that will make up the base class.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0044">
       </span>
       <h4 class="calibre29" id="head-4-200">
        A First Attempt
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         SpreadsheetCell
        </code>
        base class is responsible for defining the behaviors that all
        <code class="calibre21">
         SpreadsheetCell
        </code>
        -derived classes will support. In this example, all cells need to be able to set their value as a string. All cells also need to be able to return their current value as a string. The base class definition declares these member functions, as well as an explicitly defaulted
        <code class="calibre21">
         virtual
        </code>
        destructor, but note that it has no data members. The definition is in a
        <code class="calibre21">
         spreadsheet_cell
        </code>
        module.
       </p>
       <pre class="calibre26" id="c10-code-0059"><code class="calibre21">export module spreadsheet_cell;</code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜SpreadsheetCell() = default;</code>
<code class="calibre21">        virtual void set(std::string_view value);</code>
<code class="calibre21">        virtual std::string getString() const;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c10-para-0154">
        When you start writing the
        <code class="calibre21">
         .cpp
        </code>
        file for this class, you quickly run into a problem. Considering that the base class of the spreadsheet cell contains neither a
        <code class="calibre21">
         double
        </code>
        nor a
        <code class="calibre21">
         string
        </code>
        data member, how can you implement it? More generally, how do you write a base class that declares the behaviors that are supported by derived classes without actually defining the implementation of those behaviors?
       </p>
       <p class="calibre13" id="c10-para-0155">
        One possible approach is to implement “do nothing” functionality for those behaviors. For example, calling the
        <code class="calibre21">
         set()
        </code>
        member function on the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        base class will have no effect because the base class has nothing to set. This approach still doesn't feel right, however. Ideally, there should never be an object that is an instance of the base class. Calling
        <code class="calibre21">
         set()
        </code>
        should always have an effect because it should always be called on either a
        <code class="calibre21">
         DoubleSpreadsheetCell
        </code>
        or a
        <code class="calibre21">
         StringSpreadsheetCell
        </code>
        . A good solution enforces this constraint.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0045">
       </span>
       <h4 class="calibre29" id="head-4-201">
        Pure virtual Member Functions and Abstract Base Classes
       </h4>
       <p class="calibre13" id="c10-para-0156">
        <i class="calibre18">
         Pure virtual member functions
        </i>
        are member functions that are explicitly undefined in the class definition. By making a member function pure virtual, you are telling the compiler that no definition for the member function exists in the current class. A class with at least one pure virtual member function is said to be an
        <i class="calibre18">
         abstract class
        </i>
        because no other code will be able to instantiate it. The compiler enforces the fact that if a class contains one or more pure virtual member functions, it can never be used to construct an object of that type.
       </p>
       <p class="calibre13">
        <span aria-label="383" class="calibre20" epub:type="pagebreak" id="Page_383" role="doc-pagebreak">
        </span>
        There is a special syntax for designating a pure virtual member function. The member function declaration is followed by
        <code class="calibre21">
         =0
        </code>
        . No implementation needs to be written.
       </p>
       <pre class="calibre26" id="c10-code-0060"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜SpreadsheetCell() = default;</code>
<code class="calibre21">        <b class="calibre14">virtual void set(std::string_view value) = 0;</b></code>
<code class="calibre21">        <b class="calibre14">virtual std::string getString() const = 0;</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Now that the base class is an abstract class, it is impossible to create a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object. The following code does not compile and returns an error such as “‘SpreadsheetCell': cannot instantiate abstract class”:
       </p>
       <pre class="calibre26" id="c10-code-0061"><code class="calibre21">SpreadsheetCell cell; <span class="color">// Error! Attempts creating abstract class instance.</span></code></pre>
       <p class="calibre13">
        However, once the
        <code class="calibre21">
         StringSpreadsheetCell
        </code>
        class has been implemented, the following code will compile fine because it instantiates a derived class of the abstract base class:
       </p>
       <pre class="calibre26" id="c10-code-0062"><code class="calibre21">unique_ptr&lt;SpreadsheetCell&gt; cell { new StringSpreadsheetCell {} };</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c10-para-0161">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            An abstract class provides a way to prevent other code from instantiating an object directly, as opposed to one of its derived classes
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c10-para-0162">
        Note that there is nothing to implement for the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class. All member functions are pure virtual, and the destructor is explicitly defaulted.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c10-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-219">
       The Individual Derived Classes
      </h3>
      <p class="calibre13" id="c10-para-0163">
       Writing the
       <code class="calibre21">
        StringSpreadsheetCell
       </code>
       and
       <code class="calibre21">
        DoubleSpreadsheetCell
       </code>
       classes is just a matter of implementing the functionality that is
       <i class="calibre18">
        defined
       </i>
       in the parent. Because you want clients to be able to instantiate and work with
       <code class="calibre21">
        string
       </code>
       cells and
       <code class="calibre21">
        double
       </code>
       cells, the cells can't be abstract—they
       <i class="calibre18">
        must
       </i>
       implement all of the pure virtual member functions inherited from their parent. If a derived class does not implement all pure virtual member functions from the base class, then the derived class is abstract as well, and clients will not be able to instantiate objects of the derived class.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0048">
       </span>
       <h4 class="calibre29" id="head-4-202">
        StringSpreadsheetCell Class Definition
       </h4>
       <p class="calibre13" id="c10-para-0164">
        The
        <code class="calibre21">
         StringSpreadsheetCell
        </code>
        class is defined in its own module called
        <code class="calibre21">
         string_spreadsheet_cell
        </code>
        . The first step in writing the class definition of
        <code class="calibre21">
         StringSpreadsheetCell
        </code>
        is to inherit from
        <code class="calibre21">
         SpreadsheetCell
        </code>
        . For this, the
        <code class="calibre21">
         spreadsheet_cell
        </code>
        module needs to be imported.
       </p>
       <p class="calibre13" id="c10-para-0165">
        Next, the inherited pure virtual member functions are overridden, this time without being set to zero.
       </p>
       <p class="calibre13">
        Finally, the string cell adds a private data member,
        <code class="calibre21">
         m_value
        </code>
        , which stores the actual cell data. This data member is an
        <code class="calibre21">
         std::optional
        </code>
        , introduced in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        , “A Crash Course in C++ and the Standard Library.” By using an
        <code class="calibre21">
         optional
        </code>
        , it is possible to distinguish whether a value for a cell has never been set or whether it was set to the empty string.
       </p>
       <pre class="calibre26" id="c10-code-0063"><span aria-label="384" class="calibre20" epub:type="pagebreak" id="Page_384" role="doc-pagebreak"></span><code class="calibre21">export module string_spreadsheet_cell;</code>
<code class="calibre21">export import spreadsheet_cell;</code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">export class StringSpreadsheetCell : public SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void set(std::string_view value) override;</code>
<code class="calibre21">        std::string getString() const override;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::optional&lt;std::string&gt; m_value;</code>
<code class="calibre21">};</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c10-sec-0049">
       </span>
      </section>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
