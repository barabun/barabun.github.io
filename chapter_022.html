<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   14
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_021.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_023.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div class="calibre2" id="_idContainer256">
    <h1 class="chapter-number" id="_idParaDest-284">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor284">
     </a>
     14
    </h1>
    <h1 class="calibre5" id="_idParaDest-285">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor285">
     </a>
     Performance Optimization
    </h1>
    <p class="calibre3">
     Qt 6 is known for its optimized performance. However, performance issues may still occur if your code is poorly written. There are many ways we can identify these issues and fix them before releasing the software to
     <span>
      our users.
     </span>
    </p>
    <p class="calibre3">
     In this chapter, we will cover the
     <span>
      following recipes:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Optimizing forms
      <span>
       and C++
      </span>
     </li>
     <li class="calibre14">
      Profiling and
      <span>
       optimizing QML
      </span>
     </li>
     <li class="calibre14">
      Rendering
      <span>
       and animation
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-286">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor286">
     </a>
     Technical requirements
    </h1>
    <p class="calibre3">
     The technical requirements for this chapter include Qt 6.6.1 MinGW 64 bit, Qt Creator 12.0.2, and Windows 11. All the code used in this chapter can be downloaded from the following GitHub repository
     <span>
      at
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14">
      <span>
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-287">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor287">
     </a>
     Optimizing forms and C++
    </h1>
    <p class="calibre3">
     It’s
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker931">
     </a>
     very important to learn how to optimize your form-based Qt 6 applications that are built with C++. The best way to do that is to learn how to measure and compare the different methods that are used and decide which one works the best
     <span>
      for you.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-288">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor288">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker932">
      </a>
      create a
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      . After that, add the following headers to the top of the
      <span>
       source code:
      </span>
      <pre class="source-code">
#include &lt;QPushButton&gt;
#include &lt;QGridLayout&gt;
#include &lt;QMessageBox&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li class="calibre14">
      Create a
      <strong class="source-inline1">
       QGridLayout
      </strong>
      object and set its parent
      <span>
       to
      </span>
      <span>
       <strong class="source-inline1">
        centralWidget
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    <strong class="bold1">QGridLayout *layout = new QGridLayout(ui-&gt;centralWidget);</strong></pre>
     </li>
     <li class="calibre14">
      Create a
      <strong class="source-inline1">
       QElapsedTimer
      </strong>
      object. We will be using this to measure the performance of our
      <span>
       next operation:
      </span>
      <pre class="source-code">
    QElapsedTimer* time = new QElapsedTimer;
    time-&gt;start();</pre>
     </li>
     <li class="calibre14">
      We will use two loops to add 600 push buttons to our grid layout and connect all of them to a lambda function when clicked. We will then measure the elapsed time and print out the result,
      <span>
       as follows:
      </span>
      <pre class="source-code">
    for (int i = 0; i &lt; 40; ++i) {
        for (int j = 0; j &lt; 15; ++j) {
            QPushButton* newWidget = new QPushButton();
            newWidget-&gt;setText("Button");
            layout-&gt;addWidget(newWidget, i, j);
            connect(newWidget, QPushButton::clicked, [this]() {
            QMessageBox::information(this, "Clicked", "Button has been clicked!");
            });
        }
    }
    qDebug() &lt;&lt; "Test GUI:" &lt;&lt; time-&gt;elapsed() &lt;&lt; "msec";</pre>
     </li>
     <li class="calibre14">
      If we
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker933">
      </a>
      build and run the project now, we will see a window filled with lots of buttons. When we click on one of them, a message box will pop up on the screen. It only took around nine milliseconds on my computer to create and lay out all of the 600 buttons on the main window. There is also no performance issue when we move the window around or resize it, which is quite impressive. It proves that Qt 6 can handle this pretty well. However, please be aware that your users might be using older machines, and you might want to be extra careful when designing your
      <span>
       user interface:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer241">
      <img alt="Figure 14.1 – Spawn 600 buttons on a Qt window" class="calibre4" src="image/B20976_14_001.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.1 – Spawn 600 buttons on a Qt window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="6">
      Let’s
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker934">
      </a>
      add a style sheet to each of the buttons,
      <span>
       like so:
      </span>
      <pre class="source-code">
QPushButton* newWidget = new QPushButton();
newWidget-&gt;setText("Button");
newWidget-&gt;setStyleSheet("background-color: blue; color: white;");
layout-&gt;addWidget(newWidget, i, j);</pre>
     </li>
     <li class="calibre14">
      Build and run the program again. This time, it took roughly 75 milliseconds to set up the GUI. This means that the style sheet does have some impact on the performance of
      <span>
       your program:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer242">
      <img alt="Figure 14.2 – Apply the style sheet to all 600 buttons" class="calibre4" src="image/B20976_14_002.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.2 – Apply the style sheet to all 600 buttons
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="8">
      Once you
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker935">
      </a>
      are done with that, let’s do some performance tests on different types of C++ containers. Open up
      <strong class="source-inline1">
       main.cpp
      </strong>
      and add the
      <span>
       following headers:
      </span>
      <pre class="source-code">
#include "mainwindow.h"
#include &lt;QApplication&gt;
#include &lt;QDebug&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;vector&gt;
#include &lt;QVector&gt;</pre>
     </li>
     <li class="calibre14">
      Create
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker936">
      </a>
      a
      <strong class="source-inline1">
       testArray()
      </strong>
      function before the
      <span>
       <strong class="source-inline1">
        main()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
int testArray(int count) {
    int sum = 0;
    int *myarray = new int[count];
    for (int i = 0; i &lt; count; ++i)
        myarray[i] = i;
    for (int j = 0; j &lt; count; ++j)
        sum += myarray[j];
    delete [] myarray;
    return sum;
}</pre>
     </li>
     <li class="calibre14">
      Create another function called
      <strong class="source-inline1">
       testVector()
      </strong>
      ,
      <span>
       as follows:
      </span>
      <pre class="source-code">
int testVector(int count) {
    int sum = 0;
    std::vector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</pre>
     </li>
     <li class="calibre14">
      Once you are done with that, proceed to create yet another function
      <span>
       called
      </span>
      <span>
       <strong class="source-inline1">
        testQtVector()
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
int testQtVector(int count) {
    int sum = 0;
    QVector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</pre>
     </li>
     <li class="calibre14">
      Inside
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker937">
      </a>
      the
      <strong class="source-inline1">
       main()
      </strong>
      function, define a
      <strong class="source-inline1">
       QElapsedTimer
      </strong>
      object and an integer variable
      <span>
       called
      </span>
      <span>
       <strong class="source-inline1">
        lastElapse
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    <strong class="bold1">QElapsedTimer* time = new QElapsedTimer;</strong>
    <strong class="bold1">time-&gt;start();</strong>
    <strong class="bold1">int lastElapse = 0;</strong></pre>
     </li>
     <li class="calibre14">
      We will call the three functions we created in the previous steps to test
      <span>
       their performance:
      </span>
      <pre class="source-code">
    int result = testArray(100000000);
    qDebug() &lt;&lt; "Array:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result2 = testVector(100000000);
    qDebug() &lt;&lt; "STL vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result3 = testQtVector(100000000);
    qDebug() &lt;&lt; "Qt vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();</pre>
     </li>
     <li class="calibre14">
      Build and run the program now; we will see the performance differences between these containers. On my computer, the array took 650 milliseconds to execute, while the STL vector took roughly 3,830 milliseconds, and the Qt vector took around 5,400 milliseconds
      <span>
       to execute.
      </span>
     </li>
    </ol>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     As a result, the array is still the container that yields the best performance, despite its lack of features compared to the other two. Surprisingly, Qt’s own vector class works slightly slower than the vector container provided by the C++
     <span>
      standard library.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-289">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor289">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     When
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker938">
     </a>
     creating a
     <strong class="bold">
      Qt Widgets Application
     </strong>
     project, try to do the following to
     <span>
      improve performance:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Avoid adding too many pages to a stacked widget and filling them with widgets, as Qt needs to find all of them recursively during the rendering process and event handling, which will highly impact the
      <span>
       program’s performance.
      </span>
     </li>
     <li class="calibre14">
      Do note that the
      <strong class="source-inline1">
       QWidget
      </strong>
      class uses the Raster Engine, a software renderer, to render the widgets instead of using the GPU. However, it is lightweight enough to keep the performance good most of the time. Alternatively, you could consider using QML for your program’s GUI instead, since it is fully
      <span>
       hardware accelerated.
      </span>
     </li>
     <li class="calibre14">
      Turn off
      <strong class="bold">
       mouseTracking
      </strong>
      ,
      <strong class="bold">
       tabletTracking
      </strong>
      , and other event catching for your widgets if they do not need it. This tracking and catchings adds to the CPU usage costs of
      <span>
       your program:
      </span>
     </li>
    </ul>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer243">
      <img alt="Figure 14.3 – Disable mouseTracking and tabletTracking for optimization" class="calibre4" src="image/B20976_14_003.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.3 – Disable mouseTracking and tabletTracking for optimization
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Keep
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker939">
      </a>
      your style sheets as simple as possible. A large style sheet needs a longer time for Qt to parse the information into the rendering system, which will also
      <span>
       impact performance.
      </span>
     </li>
     <li class="calibre14">
      Different C++ containers produce different speeds, as we showed in the preceding example. Surprisingly, Qt’s vector container is slightly slower than STL’s (the C++ standard library) vector container. Overall, the good old C++ array is still the fastest, but does not provide sorting functionality. Use what is best for
      <span>
       your requirements.
      </span>
     </li>
     <li class="calibre14">
      For large operations, use
      <em class="italic">
       asynchronous
      </em>
      methods whenever possible as it will not stall the main process and will keep your program
      <span>
       running smoothly.
      </span>
     </li>
     <li class="calibre14">
      <em class="italic">
       Multi-threading
      </em>
      is
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker940">
      </a>
      really good for running different operations in parallel event loops. However, it can also become quite ugly if not done right, for example, creating and destroying threads frequently, or with inter-thread communications that are not
      <span>
       planned well.
      </span>
     </li>
     <li class="calibre14">
      Try to avoid using the web engine unless absolutely necessary. This is because embedding a full web browser on your program is really heavy overkill, especially for a small application. You can consider using QML instead of making a hybrid application if you want to create user
      <span>
       interface-centric software.
      </span>
     </li>
     <li class="calibre14">
      By
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker941">
      </a>
      doing performance tests as we did in the preceding example project, you can easily determine which method is the best choice for your project and how to make your program
      <span>
       perform better.
      </span>
     </li>
    </ul>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     In Qt 5, we can use the
     <strong class="source-inline1">
      QTime
     </strong>
     class to do the test as seen in this section. However, functions such as
     <strong class="source-inline1">
      start()
     </strong>
     and
     <strong class="source-inline1">
      elapsed()
     </strong>
     have been deprecated from the
     <strong class="source-inline1">
      QTime
     </strong>
     class in Qt 6. Since Qt 6, the player must use
     <strong class="source-inline1">
      QElapsedTimer
     </strong>
     to
     <span>
      handle this.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-290">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor290">
     </a>
     Profiling and optimizing QML
    </h1>
    <p class="calibre3">
     The QML engine in Qt 6 took advantage of hardware acceleration to make its rendering capability and performance superior to the old widgets user interface. However, this does not mean that you do not need to worry about optimization, because small performance issues may snowball into bigger problems over time and cause damage to your
     <span>
      product’s reputation.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-291">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor291">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Follow these steps to start profiling
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker942">
     </a>
     and optimizing
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker943">
     </a>
     a
     <span>
      QML application:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s create a
      <strong class="bold">
       Qt Quick
      </strong>
      <span>
       <strong class="bold">
        Application
       </strong>
      </span>
      <span>
       project:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer244">
      <img alt="Figure 14.4 – Create a Qt Quick Application project" class="calibre4" src="image/B20976_14_004.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.4 – Create a Qt Quick Application project
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Then, go
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker944">
      </a>
      to
      <strong class="bold">
       Analyze | QML Profiler
      </strong>
      and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker945">
      </a>
      run the
      <strong class="bold">
       QML
      </strong>
      <span>
       <strong class="bold">
        Profiler
       </strong>
      </span>
      <span>
       tool:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer245">
      <img alt="Figure 14.5 – Run the QML Profiler to check the QML performance" class="calibre4" src="image/B20976_14_005.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.5 – Run the QML Profiler to check the QML performance
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Your Qt Quick project will then be run by the QML Profiler. The
      <strong class="bold">
       QML Profiler
      </strong>
      window will also appear under the code editor. Click the
      <strong class="bold">
       Stop
      </strong>
      button located at the top bar of the
      <strong class="bold">
       QML Profiler
      </strong>
      window after the program has passed the test point, which in this case meant successfully creating the
      <span>
       empty window:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer246">
      <img alt="Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon" class="calibre4" src="image/B20976_14_006.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="4">
      After you
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker946">
      </a>
      stop the profiler analysis, a timeline will be
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker947">
      </a>
      displayed in the
      <strong class="bold">
       Timeline
      </strong>
      tab under the
      <strong class="bold">
       QML Profiler
      </strong>
      window. There are four tabs that you can switch between, namely
      <strong class="bold">
       Timeline
      </strong>
      ,
      <strong class="bold">
       Flame Graph
      </strong>
      ,
      <strong class="bold">
       Quick3D Frame
      </strong>
      , and
      <strong class="bold">
       Statistics
      </strong>
      , at the bottom of the
      <strong class="bold">
       QML
      </strong>
      <span>
       <strong class="bold">
        Profiler
       </strong>
      </span>
      <span>
       window:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer247">
      <img alt="Figure 14.7 – You can look at different data on different tabs" class="calibre4" src="image/B20976_14_007.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.7 – You can look at different data on different tabs
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="5">
      Let’s check out the
      <strong class="bold">
       Timeline
      </strong>
      tab. We can see six different categories under the timeline display:
      <strong class="bold">
       Scene Graph
      </strong>
      ,
      <strong class="bold">
       Memory Usage
      </strong>
      ,
      <strong class="bold">
       Input Events
      </strong>
      ,
      <strong class="bold">
       Compiling
      </strong>
      ,
      <strong class="bold">
       Creating
      </strong>
      , and
      <strong class="bold">
       Binding
      </strong>
      . These categories give us an overview of the different stages and processes of our program throughout its execution. We can also see some colorful bars displayed on the timeline. Let’s click on one of the bars under the
      <strong class="bold">
       Creating
      </strong>
      category that says
      <strong class="bold">
       QtQuick/Window
      </strong>
      . Once clicked, we will see the total duration for this operation and the location of the code displayed in a rectangular window located at the top of the QML
      <span>
       Profiler window:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer248">
      <img alt="Figure 14.8 – The Timeline tab" class="calibre4" src="image/B20976_14_008.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.8 – The Timeline tab
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="6">
      Once you are
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker948">
      </a>
      done with that, let’s move on and open up
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker949">
      </a>
      the
      <strong class="bold">
       Flame Graph
      </strong>
      tab instead. Under the
      <strong class="bold">
       Flame Graph
      </strong>
      tab, you will see the visualization of the total time, memory, and allocation of your application in the form of percentages. You can switch between total time, memory, and allocation by clicking on the selection box that’s located at the top-right corner of the
      <strong class="bold">
       QML
      </strong>
      <span>
       <strong class="bold">
        Profiler
       </strong>
      </span>
      <span>
       window:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer249">
      <img alt="Figure 14.9 – The Flame Graph tab" class="calibre4" src="image/B20976_14_009.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.9 – The Flame Graph tab
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="7">
      Not only
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker950">
      </a>
      that, you will also see the percentage value
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker951">
      </a>
      displayed on your QML
      <span>
       code editor:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer250">
      <img alt="Figure 14.10 – Percentage values are shown on the right" class="calibre4" src="image/B20976_14_010.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.10 – Percentage values are shown on the right
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="8">
      Open up the
      <strong class="bold">
       Quick3D Frame
      </strong>
      category under the
      <strong class="bold">
       QML Profiler
      </strong>
      window. This tab is where you check the performance of 3D rendering. It is currently empty because we are not doing any
      <span>
       3D rendering.
      </span>
     </li>
     <li class="calibre14">
      Next, let’s open up the
      <strong class="bold">
       Statistics
      </strong>
      category. This tab basically shows us information about the processes in
      <span>
       table form:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer251">
      <img alt="Figure 14.11 – The Statistics tab" class="calibre4" src="image/B20976_14_011.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.11 – The Statistics tab
    </p>
    <h2 class="calibre7" id="_idParaDest-292">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor292">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     This is similar to what we did in the previous example project that used C++ and widgets except, this time, it is automatically analyzed by the
     <strong class="bold">
      QML Profiler
     </strong>
     tool that’s provided by
     <span>
      Qt 6.
     </span>
    </p>
    <p class="calibre3">
     The QML Profiler not only produces the total time used for running a specific process, but also displays the memory allocation, the execution timeline of your application, and other information that gives you insight into the performance of
     <span>
      your software.
     </span>
    </p>
    <p class="calibre3">
     By looking at the data that was analyzed by the QML Profiler, you will be able to find out which part of your code slows down the program, allowing you to fix any
     <span>
      problems quickly.
     </span>
    </p>
    <p class="calibre3">
     There are
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker952">
     </a>
     some rules that you need to be aware of when writing
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker953">
     </a>
     QML to avoid performance bottlenecks. For instance, type conversion can sometimes be expensive, especially between types that are not closely matched (string to number, for example). Small issues like this will likely snowball into bottlenecks as your project grows larger
     <span>
      over time.
     </span>
    </p>
    <p class="calibre3">
     Other than that, try not to use
     <strong class="source-inline">
      id
     </strong>
     for an item lookup multiple times in blocks of code that are run often, as in the
     <span>
      following example:
     </span>
    </p>
    <pre class="source-code">
Item {
    width: 400
    height: 400
    Rectangle {
    id: rect
    anchors.fill: parent
    color: "green"
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            console.log("red", rect.color.r);
            console.log("green", rect.color.g);
            console.log("blue", rect.color.b);
            console.log("alpha", rect.color.a);
        }
    }</pre>
    <p class="calibre3">
     Instead, we can use a variable to cache the data and avoid multiple look-ups on the same item over and
     <span>
      over again:
     </span>
    </p>
    <pre class="source-code">
Component.onCompleted: {
    var rectColor = rect.color;
    for (var i = 0; i &lt; 1000; ++i) {
        console.log("red", rectColor.r);
        console.log("green", rectColor.g);
        console.log("blue", rectColor.b);
        console.log("alpha", rectColor.a);
    }
}</pre>
    <p class="calibre3">
     Besides, if you
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker954">
     </a>
     change the property of a binding expression, especially
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker955">
     </a>
     in a loop, Qt will be forced to re-evaluate it repeatedly. This will cause some performance issues. Instead of doing this, the user should follow the next
     <span>
      code snippet:
     </span>
    </p>
    <pre class="source-code">
Item {
    id: myItem
    width: 400
    height: 400
    property int myValue: 0
    Text {
        anchors.fill: parent
        text: myItem.myValue.toString()
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            myValue += 1;
        }
    }
}</pre>
    <p class="calibre3">
     Instead, we can
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker956">
     </a>
     use a temporary variable for storing the data of
     <strong class="source-inline">
      myValue
     </strong>
     , then
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker957">
     </a>
     apply the final result back to
     <strong class="source-inline">
      myValue
     </strong>
     once the loop has
     <span>
      been completed:
     </span>
    </p>
    <pre class="source-code">
Component.onCompleted: {
    var temp = myValue;
    for (var i = 0; i &lt; 1000; ++i) {
        temp += 1;
    }
    myValue = temp;
}</pre>
    <p class="calibre3">
     Consider using an anchor to position your UI items instead of using bindings. Item positioning with bindings is really slow and inefficient, although it allows for
     <span>
      maximum flexibility.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-293">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor293">
     </a>
     Rendering and animation
    </h1>
    <p class="calibre3">
     When it
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker958">
     </a>
     comes to an application that renders graphics and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker959">
     </a>
     animation, good performance is critical. Users can easily notice performance issues when graphics are not animated smoothly on screen. In the following example, we will look at how we can further optimize a graphics-heavy Qt
     <span>
      Quick application.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-294">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor294">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     To
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker960">
     </a>
     learn how to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker961">
     </a>
     render animation in QML, follow
     <span>
      this example:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a
      <strong class="bold">
       Qt Quick Application
      </strong>
      project. Then, right-click on the
      <strong class="bold">
       Resources
      </strong>
      icon under our project panel and add
      <strong class="source-inline1">
       tux.png
      </strong>
      to our
      <span>
       project’s resources:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer252">
      <img alt="Figure 14.12 – Include main.qml and tux.png into your project resources" class="calibre4" src="image/B20976_14_012.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.12 – Include main.qml and tux.png into your project resources
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Open up
      <strong class="bold">
       main.qml
      </strong>
      and change the window size to
      <strong class="source-inline1">
       650
      </strong>
      x
      <strong class="source-inline1">
       650
      </strong>
      . We will also add
      <strong class="source-inline1">
       id
      </strong>
      to the
      <strong class="source-inline1">
       window
      </strong>
      item and name
      <span>
       it
      </span>
      <span>
       <strong class="source-inline1">
        window
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
Window {
    id: window
    visible: true
    width: 650
    height: 650</pre>
     </li>
     <li class="calibre14">
      Add the following code inside the
      <span>
       <strong class="source-inline1">
        window
       </strong>
      </span>
      <span>
       item:
      </span>
      <pre class="source-code">
    property int frame: 0;
    onAfterRendering: { frame++; }
    Timer {
    id: timer
    interval: 1000
    running: true
    repeat: true
    onTriggered: { frame = 0; }
}</pre>
     </li>
     <li class="calibre14">
      Right
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker962">
      </a>
      after
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker963">
      </a>
      that, add
      <strong class="source-inline1">
       Repeater
      </strong>
      and
      <strong class="source-inline1">
       Image
      </strong>
      <span>
       under it:
      </span>
      <pre class="source-code">
    Repeater {
        model: 10
        delegate:
        Image {
        id: tux
        source: "tux.png"
        sourceSize.width: 50
        sourceSize.height: 60
        width: 50
        height: 60
        smooth: false
        antialiasing: false
        asynchronous: true</pre>
     </li>
     <li class="calibre14">
      We will proceed and add the
      <span>
       following code:
      </span>
      <pre class="source-code">
        property double startX: Math.random() * 600;
        property double startY: Math.random() * 600;
        property double endX: Math.random() * 600;
        property double endY: Math.random() * 600;
        property double speed: Math.random() * 3000 + 1000;
        RotationAnimation on rotation{
        loops: Animation.Infinite
        from: 0
        to: 360
        duration: Math.random() * 3000 + 1000;
}</pre>
     </li>
     <li class="calibre14">
      Once
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker964">
      </a>
      you are
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker965">
      </a>
      done with that, add the following code below the
      <span>
       previous code:
      </span>
      <pre class="source-code">
    SequentialAnimation {
        running: true
        loops: Animation.Infinite
        ParallelAnimation {
        NumberAnimation {
        target: tux
        property: "x"
        from: startX
        to: endX
        duration: speed
        easing.type: Easing.InOutQuad
    }</pre>
     </li>
     <li class="calibre14">
      The preceding code animates the
      <strong class="source-inline1">
       x
      </strong>
      property of the image. We need another
      <strong class="source-inline1">
       NumberAnimation
      </strong>
      property to animate the
      <span>
       <strong class="source-inline1">
        y
       </strong>
      </span>
      <span>
       property:
      </span>
      <pre class="source-code">
    NumberAnimation {
        target: tux
        property: "y"
        from: startY
        to: endY
        duration: speed
        easing.type: Easing.InOutQuad
    }
}</pre>
     </li>
     <li class="calibre14">
      After that, we
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker966">
      </a>
      repeat the entire code of
      <strong class="source-inline1">
       ParallelAnimation
      </strong>
      , except this time, we
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker967">
      </a>
      swap the
      <strong class="source-inline1">
       from
      </strong>
      and
      <strong class="source-inline1">
       to
      </strong>
      values,
      <span>
       like so:
      </span>
      <pre class="source-code">
    ParallelAnimation {
        NumberAnimation {
            target: tux
            property: "x"
            from: endX
            to: startX
            duration: speed
            easing.type: Easing.InOutQuad
        }</pre>
     </li>
     <li class="calibre14">
      The same goes for
      <strong class="source-inline1">
       NumberAnimation
      </strong>
      for the
      <span>
       <strong class="source-inline1">
        y
       </strong>
      </span>
      <span>
       property:
      </span>
      <pre class="source-code">
        NumberAnimation {
            target: tux
            property: "y"
            from: endY
            to: startY
            duration: speed
            easing.type: Easing.InOutQuad
        }
    }</pre>
     </li>
     <li class="calibre14">
      Then, we
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker968">
      </a>
      add a
      <strong class="source-inline1">
       Text
      </strong>
      item for displaying the frame rate of
      <span>
       our
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker969">
       </a>
      </span>
      <span>
       application:
      </span>
      <pre class="source-code">
Text {
    property int frame: 0
    color: "red"
    text: "FPS: 0 fps"
    x: 20
    y: 20
    font.pointSize: 20</pre>
     </li>
     <li class="calibre14">
      Let’s add
      <strong class="source-inline1">
       Timer
      </strong>
      under
      <strong class="source-inline1">
       Text
      </strong>
      and update the frame rate to display
      <span>
       every second:
      </span>
      <pre class="source-code">
    Timer {
        id: fpsTimer
        repeat: true
        interval: 1000
        running: true
        onTriggered: {
        parent.text = "FPS: " + frame + " fps"
        }
    }
}</pre>
     </li>
     <li class="calibre14">
      If we build and run the program now, we will be able to see several penguins moving around the screen with a steady
      <span>
       60 fps:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer253">
      <img alt="Figure 14.13 – 10 penguins floating around the window" class="calibre4" src="image/B20976_14_013.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.13 – 10 penguins floating around the window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="13">
      Let’s go
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker970">
      </a>
      back to our code and change the
      <strong class="source-inline1">
       model
      </strong>
      property
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker971">
      </a>
      of the
      <strong class="source-inline1">
       Repeater
      </strong>
      item to
      <strong class="source-inline1">
       10000
      </strong>
      . Build and run the program again; you should see that your window is full of moving penguins and that the frame rate has significantly dropped to roughly 39 fps, which is not too bad, considering the amount of penguins
      <span>
       we have:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer254">
      <img alt="Figure 14.14 – 10,000 penguins floating around the window" class="calibre4" src="image/B20976_14_014.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.14 – 10,000 penguins floating around the window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="14">
      Next, let’s
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker972">
      </a>
      go back to our source code and comment out both
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker973">
      </a>
      of the
      <strong class="source-inline1">
       sourceSize
      </strong>
      properties. We also set the
      <strong class="source-inline1">
       smooth
      </strong>
      and
      <strong class="source-inline1">
       antialiasing
      </strong>
      properties to
      <strong class="source-inline1">
       false
      </strong>
      , while setting the
      <strong class="source-inline1">
       asynchronous
      </strong>
      property
      <span>
       to
      </span>
      <span>
       <strong class="source-inline1">
        false
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
Image {
    id: tux
    source: "tux.png"
    <strong class="bold1">//sourceSize.width: 50</strong>
    <strong class="bold1">//sourceSize.height: 60</strong>
    width: 50
    height: 60
    <strong class="bold1">smooth: true</strong>
    <strong class="bold1">antialiasing: false</strong>
    <strong class="bold1">asynchronous: false</strong></pre>
     </li>
     <li class="calibre14">
      Let’s build
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker974">
      </a>
      and run the program again. This time, the frame rate
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker975">
      </a>
      dropped slightly to 32 fps, but the penguins look smoother and are of better quality, even
      <span>
       when moving:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer255">
      <img alt="Figure 14.15 – Our penguins look much smoother now without slowing down too much" class="calibre4" src="image/B20976_14_015.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 14.15 – Our penguins look much smoother now without slowing down too much
    </p>
    <h2 class="calibre7" id="_idParaDest-295">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor295">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker976">
     </a>
     QML engine that powers Qt Quick applications is very optimized and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker977">
     </a>
     powerful when it comes to rendering animated graphics on screen. However, there are still some tips that we can follow to make it
     <span>
      even faster.
     </span>
    </p>
    <p class="calibre3">
     Try and make use of the built-in features provided by Qt 6 instead of implementing your own, such as
     <strong class="source-inline">
      Repeater
     </strong>
     ,
     <strong class="source-inline">
      NumberAnimation
     </strong>
     , and
     <strong class="source-inline">
      SequentialAnimation
     </strong>
     . This is because Qt 6 developers have put great effort into optimizing these features so that you don’t
     <span>
      have to.
     </span>
    </p>
    <p class="calibre3">
     The
     <strong class="source-inline">
      sourceSize
     </strong>
     properties tell Qt to resize the image before loading it into memory so that large images do not use more memory
     <span>
      than necessary.
     </span>
    </p>
    <p class="calibre3">
     The
     <strong class="source-inline">
      smooth
     </strong>
     property, when enabled, tells Qt to filter the image to make look it smoother when scaled or transformed from its natural size. It will not make any difference if the image is rendered at the same as its
     <strong class="source-inline">
      sourceSize
     </strong>
     value. This property will impact the performance of your application on some
     <span>
      older hardware.
     </span>
    </p>
    <p class="calibre3">
     The
     <strong class="source-inline">
      antialiasing
     </strong>
     property tells Qt to remove the aliasing artifacts around the edge of the image and make it look smoother. This property will also impact the performance of
     <span>
      your program.
     </span>
    </p>
    <p class="calibre3">
     The
     <strong class="source-inline">
      asynchronous
     </strong>
     property tells Qt to load the image under a low-priority thread, which means that your program will not stall when loading huge
     <span>
      image files.
     </span>
    </p>
    <p class="calibre3">
     We used the frame rate to indicate the performance of our program. Since
     <strong class="source-inline">
      onAfterRendering
     </strong>
     always gets called on every frame, we can then accumulate the frame variable on every render. Then, we used
     <strong class="source-inline">
      Timer
     </strong>
     to reset the frame value
     <span>
      every second.
     </span>
    </p>
    <p class="calibre3">
     Finally, we displayed the value on screen using a
     <span>
      <strong class="source-inline">
       Text
      </strong>
     </span>
     <span>
      item.
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
