<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   17Understanding Iterators and the Ranges Library
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_027.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_029.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c17_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c17_1">
      <span aria-label="653" epub:type="pagebreak" id="Page_653" role="doc-pagebreak">
      </span>
      <span id="c17">
      </span>
      <span class="chapterNumber">
       17
      </span>
      <br/>
      <span class="chapterTitle">
       Understanding Iterators and the Ranges Library
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c17-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c17-list-0001">
         <li id="c17-li-0001">
          Details on iterators
         </li>
         <li id="c17-li-0002">
          How to use stream iterators
         </li>
         <li id="c17-li-0003">
          What iterator adapters are, and how to use the standard iterator adapters
         </li>
         <li id="c17-li-0004">
          What the ranges library is, consisting of ranges, range-based and constrained algorithms, projections, views, and factories
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c17-fea-0001">
        </span>
        <h3 id="head-2-189">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c17-sec-0003">
        </span>
        <p id="c17-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <code>
           <a href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c17-para-0005">
      <a href="c16.xhtml">
       Chapter 16
      </a>
      , “Overview of the C++ Standard Library,” introduces the Standard Library, describes its basic philosophy, and provides an overview of the provided functionality. This chapter begins a more-in-depth tour of the Standard Library by covering the ideas behind iterators used throughout a big part of the library. It also discusses the available stream iterators and iterator adapters. The second part of the chapter discusses the ranges library, a powerful library that allows for more
      <i>
       functional-style programming
      </i>
      : you write code that specifies
      <i>
       what
      </i>
      you want to accomplish instead of
      <i>
       how
      </i>
      .
     </p>
    </section>
    <span aria-label="654" epub:type="pagebreak" id="Page_654" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-190">
     <span id="c17-sec-0004">
     </span>
     <h2 id="head-2-190">
      ITERATORS
     </h2>
     <p id="c17-para-0006">
      The Standard Library uses the iterator pattern to provide a generic abstraction for accessing the elements of a container. Each container provides a container-specific iterator, which is a glorified pointer that knows how to iterate over the elements of that specific container, i.e., an iterator supports traversing the elements of a container. The different iterators for the various containers adhere to standard interfaces defined by the C++ standard. Thus, even though the containers provide different functionality, the iterators present a common interface to code that wants to work with elements of the containers. This results in code that is easier to read and write, less error-prone (e.g., iterators are easier to use correctly compared to pointer arithmetic), more efficient (especially for containers that do not support random access, such as
      <code>
       std::list
      </code>
      and
      <code>
       forward_list
      </code>
      ; see
      <a href="c16.xhtml">
       Chapter 16
      </a>
      ), and easier to debug (e.g., iterators could perform bounds checking in debug builds of your code). Additionally, when using iterators to iterate over the contents of a container, the underlying implementation of the container could change completely without any impact on your iterator-based code.
     </p>
     <p id="c17-para-0007">
      You can think of an iterator as a pointer to a specific element of the container. Like pointers to elements in an array, iterators can move to the next element with
      <code>
       operator++
      </code>
      . Similarly, you can usually use
      <code>
       operator*
      </code>
      and
      <code>
       operator-&gt;
      </code>
      on the iterator to access the actual element or field of the element. Some iterators allow comparison with
      <code>
       operator==
      </code>
      and
      <code>
       operator!=
      </code>
      , and support
      <code>
       operator--
      </code>
      for moving to previous elements.
     </p>
     <p id="c17-para-0008">
      All iterators must be copy constructible, copy assignable, and destructible. Lvalues of iterators must be swappable. Different containers provide iterators with slightly different additional capabilities. The standard defines six categories of iterators, as summarized in the following table:
     </p>
     <table border="1">
      <thead>
       <tr>
        <th class="left bgcolor2" scope="col">
         ITERATOR CATEGORY
        </th>
        <th class="left bgcolor2" scope="col">
         OPERATIONS REQUIRED
        </th>
        <th class="left bgcolor2" scope="col">
         COMMENTS
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td class="left bor1 bgcolor3">
         Input (also known as Read)
        </td>
        <td class="left bor1 bgcolor3">
         <code>
          operator++
         </code>
         ,
         <code>
          *
         </code>
         ,
         <code>
          -&gt;
         </code>
         ,
         <code>
          =
         </code>
         ,
         <code>
          ==
         </code>
         ,
         <code>
          !=
         </code>
         <br/>
         copy constructor
        </td>
        <td class="left bor1 bgcolor3">
         Provides read-only access, forward only (no
         <code>
          operator--
         </code>
         to move backward).
         <br/>
         Iterators can be assigned, copied, and compared for equality.
        </td>
       </tr>
       <tr>
        <td class="left bor1 bgcolor3">
         Output (also known as Write)
        </td>
        <td class="left bor1 bgcolor3">
         <code>
          operator++
         </code>
         ,
         <code>
          *
         </code>
         ,
         <code>
          =
         </code>
         <br/>
         copy constructor
        </td>
        <td class="left bor1 bgcolor3">
         Provides write-only access, forward only.
         <br/>
         Iterators can be assigned, but cannot be compared for equality.
         <br/>
         Specific to output iterators is that you can do
         <code>
          *iter = value
         </code>
         .
         <br/>
         Note the absence of
         <code>
          operator-&gt;
         </code>
         .
         <br/>
         Provides both prefix and postfix
         <code>
          operator++
         </code>
         .
        </td>
       </tr>
       <tr>
        <td class="left bor1 bgcolor3">
         Forward
        </td>
        <td class="left bor1 bgcolor3">
         Capabilities of input iterators, plus default constructor
        </td>
        <td class="left bor1 bgcolor3">
         Provides read access, forward only.
         <br/>
         Iterators can be assigned, copied, and compared for equality.
        </td>
       </tr>
       <tr>
        <td class="left bor1 bgcolor3">
         Bidirectional
        </td>
        <td class="left bor1 bgcolor3">
         Capabilities of forward iterators, plus
         <br/>
         <code>
          operator--
         </code>
        </td>
        <td class="left bor1 bgcolor3">
         Provides everything a forward iterator provides.
         <br/>
         Iterators can also move backward to a previous element.
         <br/>
         Provides both prefix and postfix
         <code>
          operator--
         </code>
         .
        </td>
       </tr>
       <tr>
        <td class="left bor1 bgcolor3">
         Random access
        </td>
        <td class="left bor1 bgcolor3">
         Bidirectional capability, plus the following:
         <pre class="pre1" id="c17-code-0001"><code>operator+, -, +=, -=, &lt;,&gt;, &lt;=,&gt;=, []</code></pre>
        </td>
        <td class="left bor1 bgcolor3">
         Equivalent to raw pointers: support pointer arithmetic, array index syntax, and all forms of comparison.
        </td>
       </tr>
       <tr>
        <td class="left bor1 bgcolor3">
         Contiguous
        </td>
        <td class="left bor1 bgcolor3">
         Random-access capability and logically adjacent elements of the container must be physically adjacent in memory
        </td>
        <td class="left bor1 bgcolor3">
         Examples of this are iterators of
         <code>
          std::array, vector
         </code>
         (not
         <code>
          vector&lt;bool&gt;
         </code>
         ),
         <code>
          string
         </code>
         , and
         <code>
          string_view
         </code>
         .
         <span aria-label="655" epub:type="pagebreak" id="Page_655" role="doc-pagebreak">
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <p id="c17-para-0029">
      According to this table, there are six types of iterators: input, output, forward, bidirectional, random access, and contiguous. There is no formal class hierarchy of these iterators. However, one can deduce a hierarchy based on the functionality they are required to provide. Specifically, every contiguous iterator is also random access, every random-access iterator is also bidirectional, every bidirectional iterator is also forward, and every forward iterator is also input. Iterators that additionally satisfy the requirements for output iterators are called
      <i>
       mutable iterators
      </i>
      ; otherwise, they are called
      <i>
       constant iterators
      </i>
      .
      <a href="#c17-fig-0001" id="R_c17-fig-0001">
       Figure 17.1
      </a>
      shows such hierarchy. Dotted lines are used because the figure is not a real class hierarchy.
     </p>
     <figure>
      <img alt="A diagram with five boxes arranged vertically. Each box has a term related to data or information processing. From top to bottom, the boxes include input, forward, bidirectional, random access, and contiguous." class="center" src="../images\images/c17f001.png"/>
      <figcaption>
       <p>
        <span class="figureLabel">
         <a href="#R_c17-fig-0001" id="c17-fig-0001" role="doc-backlink">
          <b>
           FIGURE 17.1
          </b>
         </a>
        </span>
       </p>
      </figcaption>
     </figure>
     <p>
      The standard technique for an algorithm to specify what kind of iterators it requires is to use names similar to the following for its iterator template type parameters:
      <code>
       InputIterator
      </code>
      ,
      <code>
       OutputIterator
      </code>
      ,
      <code>
       ForwardIterator
      </code>
      ,
      <code>
       BidirectionalIterator
      </code>
      ,
      <code>
       RandomAccessIterator
      </code>
      , and
      <code>
       ContiguousIterator
      </code>
      . These names are just names: they don't provide binding type checking. Therefore, you could, for example, try to call an algorithm expecting a
      <code>
       RandomAccessIterator
      </code>
      by passing a bidirectional iterator. The template cannot do type checking, so it would allow this instantiation. However, the code in the function that uses the random-access iterator capabilities would fail to compile on the bidirectional iterator. Thus, the requirement is enforced, just not where you would expect. The error message can therefore be somewhat confusing. For example, attempting to use the generic
      <code>
       sort()
      </code>
      algorithm, which requires a random-access iterator, on a
      <code>
       list
      </code>
      , which provides only a bidirectional iterator, can result in a cryptic error. The following is the error generated by Visual C++ 2022:
     </p>
     <pre id="c17-code-0002"><code>…\MSVC\14.37.32705\include\algorithm(8061,45): error C2676: binary '-': 'const std::_List_unchecked_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;_Ty&gt;&gt;&gt;' does not define this operator or a conversion to a type acceptable to the predefined operator</code>
<code>        with</code>
<code>        [</code>
<code>            _Ty=int</code>
<code>        ]</code></pre>
     <p>
      <span aria-label="656" epub:type="pagebreak" id="Page_656" role="doc-pagebreak">
      </span>
      Later in this chapter, the ranges library is introduced, which comes with range-based and constrained versions of most Standard Library algorithms. These constrained algorithms have proper type constraints (see
      <a href="c12.xhtml">
       Chapter 12
      </a>
      , “Writing Generic Code with Templates”) for their template type parameters. Hence, the compiler can provide clearer error messages if you try to execute such an algorithm on a container that provides the wrong type of iterators.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c17-para-0032">
         <b>
          NOTE
         </b>
         <i>
          Iterators mediate between algorithms and containers. They provide a standard interface to traverse the elements of a container in sequence so that any algorithm can work on any container as long as the container provides the algorithm's required iterator category
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c17-para-0033">
      Iterators are implemented similarly to smart pointer classes in that they overload the specific desired operators. Consult
      <a href="c15.xhtml">
       Chapter 15
      </a>
      , “Overloading C++ Operators,” for details on operator overloading.
     </p>
     <p>
      The basic iterator operations are similar to those supported by raw pointers, so a raw pointer can be a legitimate iterator for certain containers. In fact, the
      <code>
       vector
      </code>
      iterator could technically be implemented as a simple raw pointer. However, as a client of the containers, you need not worry about the implementation details; you can simply use the iterator abstraction.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c17-para-0035">
         <b>
          NOTE
         </b>
         <i>
          Iterators might, or might not, be implemented internally as pointers, so this text uses the term
         </i>
         <b>
          <i>
           refers to
          </i>
         </b>
         <i>
          instead of
         </i>
         <b>
          <i>
           points to
          </i>
         </b>
         <i>
          when discussing the elements accessible via an iterator.
         </i>
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <span id="c17-sec-0007">
      </span>
      <h3 id="head-3-384">
       Getting Iterators for Containers
      </h3>
      <p>
       Every data structure of the Standard Library that supports iterators provides public type aliases for its iterator types, called
       <code>
        iterator
       </code>
       and
       <code>
        const_iterator
       </code>
       . For example, a
       <code>
        const
       </code>
       iterator for a
       <code>
        vector
       </code>
       of
       <code>
        int
       </code>
       s has as type
       <code>
        std::vector&lt;int&gt;::const_iterator
       </code>
       . Containers that allow you to iterate over their elements in reverse order also provide public type aliases called
       <code>
        reverse_iterator
       </code>
       and
       <code>
        const_reverse_iterator
       </code>
       . This way, clients can use the container iterators without worrying about the actual types.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0037">
          <b>
           NOTE
          </b>
          <code>
           const_iterator
          </code>
          <i>
           s and
          </i>
          <code>
           const_reverse_iterator
          </code>
          <i>
           s provide read-only access to elements of a container
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c17-para-0038">
       The containers also provide a member function
       <code>
        begin()
       </code>
       that returns an iterator referring to the first element in the container. The
       <code>
        end()
       </code>
       member function returns an iterator to the “past-the-end” value
       <span aria-label="657" epub:type="pagebreak" id="Page_657" role="doc-pagebreak">
       </span>
       of the sequence of elements. That is,
       <code>
        end()
       </code>
       returns an iterator that is equal to the result of applying
       <code>
        operator++
       </code>
       to an iterator referring to the last element in the sequence. Together,
       <code>
        begin()
       </code>
       and
       <code>
        end()
       </code>
       provide a
       <i>
        half-open range
       </i>
       that includes the first element but not the last. The reason for this apparent complication is to support empty ranges (containers without any elements), in which case
       <code>
        begin()
       </code>
       is equal to
       <code>
        end()
       </code>
       . The half-open range bounded by iterators
       <code>
        begin()
       </code>
       and
       <code>
        end()
       </code>
       is often written mathematically like this: [begin, end).
      </p>
      <p>
       Additionally, the following member functions are available:
      </p>
      <ul class="check1" id="c17-list-0002">
       <li id="c17-li-0005">
        <code>
         cbegin()
        </code>
        and
        <code>
         cend()
        </code>
        returning
        <code>
         const
        </code>
        iterators
       </li>
       <li id="c17-li-0006">
        <code>
         rbegin()
        </code>
        and
        <code>
         rend()
        </code>
        returning reverse iterators
       </li>
       <li id="c17-li-0007">
        <code>
         crbegin()
        </code>
        and
        <code>
         crend()
        </code>
        returning
        <code>
         const
        </code>
        reverse iterators
       </li>
      </ul>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0040">
          <b>
           NOTE
          </b>
          <i>
           A sequence specified by two iterators is called a
          </i>
          <b>
           <i>
            common range
           </i>
          </b>
          <i>
           to disambiguate it from ranges defined by the ranges library, discussed later in this chapter.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c17-para-0041">
       <code>
        &lt;iterator&gt;
       </code>
       also provides the following global nonmember functions to retrieve specific iterators for a container:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          FUNCTION NAME
         </th>
         <th class="left bgcolor2" scope="col">
          FUNCTION SYNOPSIS
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           begin()
          </code>
          <br/>
          <code>
           end()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns a non-
          <code>
           const
          </code>
          iterator to the first, and one past the last, element in a sequence
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           cbegin()
          </code>
          <br/>
          <code>
           cend()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns a
          <code>
           const
          </code>
          iterator to the first, and one past the last, element in a sequence
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           rbegin()
          </code>
          <br/>
          <code>
           rend()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns a non-
          <code>
           const
          </code>
          reverse iterator to the last, and one before the first, element in a sequence
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           crbegin()
          </code>
          <br/>
          <code>
           crend()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns a
          <code>
           const
          </code>
          reverse iterator to the last, and one before the first, element in a sequence
         </td>
        </tr>
       </tbody>
      </table>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0052">
          <b>
           NOTE
          </b>
          <i>
           It's recommended to use these nonmember functions instead of the member versions
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       These nonmember functions are defined in the
       <code>
        std
       </code>
       namespace; however, especially when writing generic code for class and function templates, it is recommended to use these non-member functions as follows:
      </p>
      <pre id="c17-code-0003"><code>using std::begin;</code>
<code>begin(…);</code></pre>
      <p>
       <span aria-label="658" epub:type="pagebreak" id="Page_658" role="doc-pagebreak">
       </span>
       Note that
       <code>
        begin()
       </code>
       is called without any namespace qualification, as this enables
       <i>
        argument-dependent lookups
       </i>
       (ADL).
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0055">
          <b>
           NOTE
          </b>
          <i>
           ADL allows you to call unqualified functions. The compiler tries to find those functions first in the namespace of the arguments passed to them. If not found there, the usual name lookup rules apply
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c17-para-0056">
       When you specialize one of these nonmember functions for your own types, you can either put those specializations in the
       <code>
        std
       </code>
       namespace or put them in the same namespace as the type for which you are specializing them. The latter is recommended as this enables ADL. Thanks to ADL, you can then call your specialization without having to qualify it with any namespace, because the compiler is able to find the correct specialization in your namespace based on the types of arguments passed to the specialized function template.
      </p>
      <p id="c17-para-0057">
       By combining ADL (calling
       <code>
        begin(…
       </code>
       ) without any namespace qualification) with the
       <code>
        using std::begin
       </code>
       declaration, the compiler first looks up the right overload in the namespace of the type of its argument using ADL. If the compiler cannot find an overload using ADL, it tries to find an appropriate overload in the
       <code>
        std
       </code>
       namespace due to the
       <code>
        using
       </code>
       declaration. Just calling
       <code>
        begin()
       </code>
       without the
       <code>
        using
       </code>
       declaration would only call user-defined overloads through ADL, and just calling
       <code>
        std::begin()
       </code>
       would only look in the
       <code>
        std
       </code>
       namespace.
      </p>
      <p>
       Of course, ADL is not limited to the functions discussed in this section but can be used with any function.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0059">
          <b>
           NOTE
          </b>
          <i>
           Normally it is not allowed to add anything to the
          </i>
          <code>
           std
          </code>
          <i>
           namespace; however, it is legal to put specializations of Standard Library templates in the
          </i>
          <code>
           std
          </code>
          <i>
           namespace.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c17-sec-0013">
      </span>
      <h3 id="head-3-385">
       Iterator Traits
      </h3>
      <p id="c17-para-0060">
       Some algorithm implementations need additional information about their iterators. For example, they might need to know the type of the elements referred to by the iterator to store temporary values, or perhaps they want to know whether the iterator is bidirectional or random access.
      </p>
      <p>
       C++ provides a class template called
       <code>
        iterator_traits
       </code>
       , defined in
       <code>
        &lt;iterator&gt;
       </code>
       , that allows you to retrieve this information. You instantiate the
       <code>
        iterator_traits
       </code>
       class template with the iterator type of interest, and access one of five type aliases:
      </p>
      <ul class="check1" id="c17-list-0003">
       <li id="c17-li-0008">
        value_type: The type of elements referred to
       </li>
       <li id="c17-li-0009">
        difference:type: A type capable of representing the distance, i.e., number of elements, between two iterators
       </li>
       <li id="c17-li-0010">
        iterator_category: The type of iterator:
        <code>
         input_iterator_tag
        </code>
        ,
        <code>
         output_iterator_tag
        </code>
        ,
        <code>
         forward_iterator_tag
        </code>
        ,
        <code>
         bidirectional_iterator_tag
        </code>
        ,
        <code>
         random_access_iterator_tag
        </code>
        , or
        <code>
         contiguous_iterator_tag
        </code>
       </li>
       <li id="c17-li-0011">
        <span aria-label="659" epub:type="pagebreak" id="Page_659" role="doc-pagebreak">
        </span>
        pointer: The type of a pointer to an element
       </li>
       <li id="c17-li-0012">
        reference: The type of a reference to an element
       </li>
      </ul>
      <p>
       For example, the following function template declares a temporary variable of the type that an iterator of type
       <code>
        IteratorType
       </code>
       refers to. Note the use of the
       <code>
        typename
       </code>
       keyword in front of
       <code>
        iterator_traits
       </code>
       . You must specify
       <code>
        typename
       </code>
       explicitly whenever you access a type based on one or more template type parameters. In this case, the template type parameter
       <code>
        IteratorType
       </code>
       is used to access the
       <code>
        value_type
       </code>
       type of
       <code>
        iterator_traits
       </code>
       .
      </p>
      <pre id="c17-code-0004"><code>template &lt;typename IteratorType&gt;</code>
<code>void iteratorTraitsTest(IteratorType it)</code>
<code>{</code>
<code>   typename iterator_traits&lt;IteratorType&gt;::value_type temp;</code>
<code>   temp = *it;</code>
<code>   println("{}", temp);</code>
<code>}</code></pre>
      <p>
       This function can be tested with the following code:
      </p>
      <pre id="c17-code-0005"><code>vector v { 5 };</code>
<code>iteratorTraitsTest(cbegin(v));</code></pre>
      <p id="c17-para-0064">
       With this code, the variable
       <code>
        temp
       </code>
       in
       <code>
        iteratorTraitsTest()
       </code>
       is of type
       <code>
        int
       </code>
       . The output is
       <code>
        5
       </code>
       .
      </p>
      <p id="c17-para-0065">
       Of course, the
       <code>
        auto
       </code>
       keyword could be used in this example to simplify the code, but that wouldn't show you how to use
       <code>
        iterator_traits
       </code>
       .
      </p>
     </section>
     <section>
      <span id="c17-sec-0014">
      </span>
      <h3 id="head-3-386">
       Examples
      </h3>
      <p>
       The following example simply uses a
       <code>
        for
       </code>
       loop and iterators to iterate over every element in a
       <code>
        vector
       </code>
       and prints them to standard output:
      </p>
      <pre id="c17-code-0006"><code>vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code>for (auto iter { cbegin(values) }; iter != cend(values); ++iter) {</code>
<code>    print("{} ", *iter);</code>
<code>}</code></pre>
      <p id="c17-para-0067">
       You might be tempted to test for the end of a common range using
       <code>
        operator&lt;
       </code>
       , as in
       <code>
        iter&lt;cend(values)
       </code>
       . That is not recommended, however. The canonical way to test for the end of a range is to use
       <code>
        !=
       </code>
       , as in
       <code>
        iter!=cend(values)
       </code>
       . The reason is that the
       <code>
        !=
       </code>
       operator works on all types of iterators, while the
       <code>
        &lt;
       </code>
       operator is not supported by bidirectional and forward iterators.
      </p>
      <p>
       A helper function can be implemented that accepts a common range of elements given as a begin and end iterator and prints all elements in that range to standard output. The
       <code>
        input_iterator
       </code>
       concept is used to constrain the template type parameter to input iterators.
      </p>
      <pre id="c17-code-0007"><code>template &lt;input_iterator Iter&gt;</code>
<code>void myPrint(Iter begin, Iter end)</code>
<code>{</code>
<code>    for (auto iter { begin }; iter != end; ++iter) { print("{} ", *iter); }</code>
<code>}</code></pre>
      <p>
       This helper function can be used as follows:
      </p>
      <pre id="c17-code-0008"><code>myPrint(cbegin(values), cend(values));</code></pre>
      <p>
       <span aria-label="660" epub:type="pagebreak" id="Page_660" role="doc-pagebreak">
       </span>
       A second example is a
       <code>
        myFind()
       </code>
       function template that finds a given value in a given common range. If the value is not found, the end iterator of the range is returned. Note the special type of the
       <code>
        value
       </code>
       parameter. It uses
       <code>
        iterator_traits
       </code>
       to get the type of the values to which the given iterators point to.
      </p>
      <pre id="c17-code-0009"><code>template &lt;input_iterator Iter&gt;</code>
<code>auto myFind(Iter begin, Iter end,</code>
<code>    const typename iterator_traits&lt;Iter&gt;::value_type&amp; value)</code>
<code>{</code>
<code>    for (auto iter { begin }; iter != end; ++iter) {</code>
<code>        if (*iter == value) { return iter; }</code>
<code>    }</code>
<code>    return end;</code>
<code>}</code></pre>
      <p>
       This function template can be used as follows. The
       <code>
        std::distance()
       </code>
       function is used to compute the distance between two iterators of a container.
      </p>
      <pre id="c17-code-0010"><code>vector values { 11, 22, 33, 44 };</code>
<code>auto result { myFind(cbegin(values), cend(values), 22) };</code>
<code>if (result != cend(values)) {</code>
<code>    println("Found value at position {}", distance(cbegin(values), result));</code>
<code>}</code></pre>
      <p id="c17-para-0072">
       More examples of using iterators are given throughout this and subsequent chapters.
      </p>
     </section>
     <section>
      <span id="c17-sec-0015">
      </span>
      <h3 id="head-3-387">
       Function Dispatching Using Iterator Traits
      </h3>
      <p>
       The Standard Library provides the
       <code>
        std::advance(iter, n)
       </code>
       function to advance a given iterator,
       <code>
        iter
       </code>
       , by
       <code>
        n
       </code>
       positions. This function works on all types of iterators. For random-access iterators, it simply does
       <code>
        iter += n
       </code>
       . For other iterators, it does
       <code>
        ++iter
       </code>
       or
       <code>
        --iter
       </code>
       in a loop
       <code>
        n
       </code>
       times, depending on whether
       <code>
        n
       </code>
       is positive or negative. You might wonder how such behavior is implemented. It can be implemented using
       <i>
        function dispatching
       </i>
       . Based on the iterator category, the request is dispatched to a specific helper function. Here's a simplified implementation of our own
       <code>
        myAdvance(iter, n)
       </code>
       function demonstrating such function dispatching:
      </p>
      <pre id="c17-code-0011"><code>template &lt;typename Iter, typename Distance&gt;</code>
<code>void advanceHelper(Iter&amp; iter, Distance n, <b>input_iterator_tag</b>)</code>
<code>{</code>
<code>    while (n &gt; 0) { ++iter; --n; }</code>
<code>}</code>
<code> </code>
<code>template &lt;typename Iter, typename Distance&gt;</code>
<code>void advanceHelper(Iter&amp; iter, Distance n, <b>bidirectional_iterator_tag</b>)</code>
<code>{</code>
<code>    while (n &gt; 0) { ++iter; --n; }</code>
<code>    while (n &lt; 0) { --iter; ++n; }</code>
<code>}</code>
<code> </code>
<code>template &lt;typename Iter, typename Distance&gt;</code>
<code>void advanceHelper(Iter&amp; iter, Distance n, <b>random_access_iterator_tag</b>)</code>
<code>{</code>
<code>    iter += n;</code>
<code>}</code>
<code> </code>
<span aria-label="661" epub:type="pagebreak" id="Page_661" role="doc-pagebreak"></span><code>template &lt;typename Iter, typename Distance&gt;</code>
<code>void myAdvance(Iter&amp; iter, Distance n)</code>
<code>{</code>
<code>    <b>using category = typename iterator_traits&lt;Iter&gt;::iterator_category;</b></code>
<code>    advanceHelper(iter, n, <b>category {}</b>);</code>
<code>}</code></pre>
      <p>
       This implementation of
       <code>
        myAdvance()
       </code>
       can be used on random-access iterators from
       <code>
        vector
       </code>
       s, on bidirectional iterators from
       <code>
        list
       </code>
       s, and so on:
      </p>
      <pre id="c17-code-0012"><code>template &lt;typename Iter&gt;</code>
<code>void testAdvance(Iter iter)</code>
<code>{</code>
<code>    print("*iter = {} | ", *iter);</code>
<code>    myAdvance(iter, 3); print("3 ahead = {} | ", *iter);</code>
<code>    myAdvance(iter, -2); println("2 back = {}", *iter);</code>
<code>}</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    vector vec { 1, 2, 3, 4, 5, 6 };  testAdvance(begin(vec));</code>
<code>    list lst { 1, 2, 3, 4, 5, 6 };    testAdvance(begin(lst));</code>
<code>}</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c17-code-0013"><code>*iter = 1 | 3 ahead = 4 | 2 back = 2</code>
<code>*iter = 1 | 3 ahead = 4 | 2 back = 2</code></pre>
      <p>
       With concepts (see
       <a href="c12.xhtml">
        Chapter 12
       </a>
       ), the
       <code>
        myAdvance()
       </code>
       implementation can be simplified. Instead of using helper functions, you can just provide
       <code>
        myAdvance()
       </code>
       overloads with appropriate constraints:
      </p>
      <pre id="c17-code-0014"><code>template &lt;<b>input_iterator</b> Iter, typename Distance&gt;</code>
<code>void <b>myAdvance</b>(Iter&amp; iter, Distance n)</code>
<code>{</code>
<code>    while (n &gt; 0) { ++iter; --n; }</code>
<code>}</code>
<code> </code>
<code>template &lt;<b>bidirectional_iterator</b> Iter, typename Distance&gt;</code>
<code>void <b>myAdvance</b>(Iter&amp; iter, Distance n)</code>
<code>{</code>
<code>    while (n &gt; 0) { ++iter; --n; }</code>
<code>    while (n &lt; 0) { --iter; ++n; }</code>
<code>}</code>
<code> </code>
<code>template &lt;<b>random_access_iterator</b> Iter, typename Distance&gt;</code>
<code>void <b>myAdvance</b>(Iter&amp; iter, Distance n)</code>
<code>{</code>
<code>    iter += n;</code>
<code>}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-191">
     <span id="c17-sec-0016">
     </span>
     <h2 id="head-2-191">
      STREAM ITERATORS
     </h2>
     <p>
      The Standard Library provides four
      <i>
       stream iterators
      </i>
      . These are iterator-like class templates that allow you to treat input and output streams as input and output iterators. Using these stream iterators, you
      <span aria-label="662" epub:type="pagebreak" id="Page_662" role="doc-pagebreak">
      </span>
      can adapt input and output streams so that they can serve as sources and destinations, respectively, for various Standard Library algorithms. The following stream iterators are available:
     </p>
     <ul class="check1" id="c17-list-0004">
      <li id="c17-li-0013">
       <code>
        ostream_iterator
       </code>
       : Output iterator writing to a
       <code>
        basic_ostream
       </code>
      </li>
      <li id="c17-li-0014">
       <code>
        istream_iterator
       </code>
       : Input iterator reading from a
       <code>
        basic_istream
       </code>
      </li>
      <li id="c17-li-0015">
       <code>
        ostreambuf_iterator
       </code>
       : Output iterator writing to a
       <code>
        basic_streambuf
       </code>
      </li>
      <li id="c17-li-0016">
       <code>
        istreambuf_iterator
       </code>
       : Input iterator reading from a
       <code>
        basic_streambuf
       </code>
      </li>
     </ul>
     <section>
      <span id="c17-sec-0017">
      </span>
      <h3 id="head-3-388">
       Output Stream Iterator: ostream_iterator
      </h3>
      <p id="c17-para-0078">
       <code>
        ostream_iterator
       </code>
       is an
       <i>
        output stream iterator
       </i>
       . It is a class template that takes the element type as a template type parameter. The constructor takes an output stream and a delimiter string to write to the stream following each element. The
       <code>
        ostream_iterator
       </code>
       class writes elements using
       <code>
        operator&lt;&lt;
       </code>
       .
      </p>
      <p>
       Let's look at an example. Suppose you have the following
       <code>
        myCopy()
       </code>
       function template that copies a common range given as a begin and end iterator to a target range given as a begin iterator. The second template type parameter is constrained to be an output iterator that accepts values of type
       <code>
        std::iter_reference:t&lt;InputIter&gt;
       </code>
       which is the type of the values referred to by the given
       <code>
        InputIter
       </code>
       .
      </p>
      <pre id="c17-code-0015"><code>template &lt;input_iterator InputIter,</code>
<code>    output_iterator&lt;iter_reference:t&lt;InputIter&gt;&gt; OutputIter&gt;</code>
<code>void myCopy(InputIter begin, InputIter end, OutputIter target)</code>
<code>{</code>
<code>    for (auto iter { begin }; iter != end; ++iter, ++target) { *target = *iter; }</code>
<code>}</code></pre>
      <p>
       The first two parameters of
       <code>
        myCopy()
       </code>
       are the begin and end iterator of the range to copy, and the third parameter is an iterator to the destination range. You have to make sure the destination range is big enough to hold all the elements from the source range. Using the
       <code>
        myCopy()
       </code>
       function template to copy the elements of one
       <code>
        vector
       </code>
       to another one is straightforward.
      </p>
      <pre id="c17-code-0016"><code>vector myVector { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code><span class="color3">// Use myCopy() to copy myVector to vectorCopy.</span></code>
<code>vector&lt;int&gt; vectorCopy(myVector.size());</code>
<code><b>myCopy(cbegin(myVector), cend(myVector), begin(vectorCopy));</b></code></pre>
      <p>
       Now, by using an
       <code>
        ostream_iterator
       </code>
       , the
       <code>
        myCopy()
       </code>
       function template can also be used to print elements of a container with just a single line of code. The following code snippet prints the contents of
       <code>
        myVector
       </code>
       and
       <code>
        vectorCopy
       </code>
       :
      </p>
      <pre id="c17-code-0017"><code><span class="color3">// Use the same myCopy() to print the contents of both vectors.</span></code>
<code>myCopy(cbegin(myVector), cend(myVector), <b>ostream_iterator&lt;int&gt; { cout, " " }</b>);</code>
<code>println("");</code>
<code>myCopy(cbegin(vectorCopy), cend(vectorCopy), <b>ostream_iterator&lt;int&gt; { cout, " " }</b>);</code>
<code>println("");</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c17-code-0018"><code>1 2 3 4 5 6 7 8 9 10</code>
<code>1 2 3 4 5 6 7 8 9 10</code></pre>
     </section>
     <span aria-label="663" epub:type="pagebreak" id="Page_663" role="doc-pagebreak">
     </span>
     <section>
      <span id="c17-sec-0018">
      </span>
      <h3 id="head-3-389">
       Input Stream Iterator: istream_iterator
      </h3>
      <p id="c17-para-0083">
       You can use the
       <i>
        input stream iterator
       </i>
       ,
       <code>
        istream_iterator
       </code>
       , to read values from an input stream using the iterator abstraction. It is a class template that takes the element type as a template type parameter. Its constructor takes an input stream as a parameter. Elements are read using
       <code>
        operator&gt;&gt;
       </code>
       . You can use an
       <code>
        istream_iterator
       </code>
       as a source for algorithms and container member functions.
      </p>
      <p>
       Suppose you have the following
       <code>
        sum()
       </code>
       function template that calculates the sum of all the elements in a given common range:
      </p>
      <pre id="c17-code-0019"><code>template &lt;input_iterator InputIter&gt;</code>
<code>auto sum(InputIter begin, InputIter end)</code>
<code>{</code>
<code>    auto sum { *begin };</code>
<code>    for (auto iter { ++begin }; iter != end; ++iter) { sum += *iter; }</code>
<code>    return sum;</code>
<code>}</code></pre>
      <p>
       Now, an
       <code>
        istream_iterator
       </code>
       can be used to read integers from the console until the end of the stream is reached. On Windows, this happens when you press Ctrl+Z followed by Enter, while on Linux you press Enter followed by Ctrl+D. The
       <code>
        sum()
       </code>
       function is used to calculate the sum of all the integers. A default constructed
       <code>
        istream_iterator
       </code>
       represents the end iterator.
      </p>
      <pre id="c17-code-0020"><code>println("Enter numbers separated by whitespace.");</code>
<code>println("Press Ctrl+Z followed by Enter to stop.");</code>
<code><b>istream_iterator&lt;int&gt; numbersIter { cin };</b></code>
<code><b>istream_iterator&lt;int&gt; endIter;</b></code>
<code><b>int result { sum(numbersIter, endIter) };</b></code>
<code>println("Sum: {}", result);</code></pre>
     </section>
     <section>
      <span id="c17-sec-0019">
      </span>
      <h3 id="head-3-390">
       Input Stream Iterator: istreambuf_iterator
      </h3>
      <p>
       One use case of the
       <code>
        istreambuf_iterator
       </code>
       input stream iterator is to easily read the contents of an entire file with a single statement. A default constructed
       <code>
        istreambuf_iterator
       </code>
       represents the end iterator. Here is an example:
      </p>
      <pre id="c17-code-0021"><code>ifstream inputFile { "some_data.txt" };</code>
<code>if (inputFile.fail()) {</code>
<code>    println(cerr, "Unable to open file for reading.");</code>
<code>    return 1;</code>
<code>}</code>
<code>string fileContents {</code>
<code>    <b>istreambuf_iterator&lt;char&gt; { inputFile },</b></code>
<code>    <b>istreambuf_iterator&lt;char&gt; { }</b></code>
<code>};</code>
<code>println("{}", fileContents);</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-192">
     <span id="c17-sec-0020">
     </span>
     <h2 id="head-2-192">
      ITERATOR ADAPTERS
     </h2>
     <p>
      The Standard Library provides a number of
      <i>
       iterator adapters
      </i>
      , which are special iterators, all defined in
      <code>
       &lt;iterator&gt;
      </code>
      . They are split into two groups. The first group of adapters are created from a container and are usually used as output iterators:
      <span aria-label="664" epub:type="pagebreak" id="Page_664" role="doc-pagebreak">
      </span>
     </p>
     <ul class="check1" id="c17-list-0005">
      <li id="c17-li-0017">
       back_insert_iterator: Uses
       <code>
        push_back()
       </code>
       to insert elements into a container
      </li>
      <li id="c17-li-0018">
       front_insert_iterator: Uses
       <code>
        push_front()
       </code>
       to insert elements into a container
      </li>
      <li id="c17-li-0019">
       insert_iterator: Uses
       <code>
        insert()
       </code>
       to insert elements into a container
      </li>
     </ul>
     <p>
      Other adapters are created from another iterator, not a container, and are usually used as input iterators. Two common adapters are:
     </p>
     <ul class="check1" id="c17-list-0006">
      <li id="c17-li-0020">
       reverse_iterator: Reverse the iteration order of another iterator.
      </li>
      <li id="c17-li-0021">
       move_iterator: The dereferencing operator for a
       <code>
        move_iterator
       </code>
       automatically converts the value to an rvalue reference, so it can be moved to a new destination.
      </li>
     </ul>
     <p id="c17-para-0089">
      It's also possible to write your own iterator adapters, but this is not covered in this book. Consult one of the Standard Library references listed in
      <a href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography,” for details.
     </p>
     <section>
      <span id="c17-sec-0021">
      </span>
      <h3 id="head-3-391">
       Insert Iterators
      </h3>
      <p id="c17-para-0090">
       The
       <code>
        myCopy()
       </code>
       function template as implemented earlier in this chapter does not insert elements into a container; it simply replaces old elements in a range with new ones. To make such algorithms more useful, the Standard Library provides three
       <i>
        insert iterator adapters
       </i>
       that really insert elements into a container:
       <code>
        insert_iterator
       </code>
       ,
       <code>
        back_insert_iterator
       </code>
       , and
       <code>
        front_insert_iterator
       </code>
       . They are all parametrized on a container type and take an actual container reference in their constructor. Because they supply the necessary iterator interfaces, these adapters can be used as the destination iterators for algorithms like
       <code>
        myCopy()
       </code>
       . However, instead of replacing elements in the container, they make calls on their container to actually insert new elements.
      </p>
      <p id="c17-para-0091">
       The basic
       <code>
        insert_iterator
       </code>
       calls
       <code>
        insert(position,element)
       </code>
       on the container,
       <code>
        back_insert_iterator
       </code>
       calls
       <code>
        push_back(element)
       </code>
       , and
       <code>
        front_insert_iterator
       </code>
       calls
       <code>
        push_front(element)
       </code>
       .
      </p>
      <p>
       The following example uses a
       <code>
        back_insert_iterator
       </code>
       with
       <code>
        myCopy()
       </code>
       to populate
       <code>
        vectorTwo
       </code>
       with copies of all elements from
       <code>
        vectorOne
       </code>
       . Note that
       <code>
        vectorTwo
       </code>
       is not first resized to have enough elements, the insert iterator takes care of properly inserting new elements.
      </p>
      <pre id="c17-code-0022"><code>vector vectorOne { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code>vector&lt;int&gt; vectorTwo;</code>
<code> </code>
<code>back_insert_iterator&lt;vector&lt;int&gt;&gt; inserter { vectorTwo };</code>
<code>myCopy(cbegin(vectorOne), cend(vectorOne), inserter);</code>
<code> </code>
<code>println("{:n}", vectorTwo);</code></pre>
      <p id="c17-para-0093">
       As you can see, when you use insert iterators, you don't need to size the destination containers ahead of time.
      </p>
      <p>
       You can also use the
       <code>
        std::back_inserter()
       </code>
       utility function to create a
       <code>
        back_insert_iterator
       </code>
       . In the previous example, you can remove the line that defines the
       <code>
        inserter
       </code>
       variable and rewrite the
       <code>
        myCopy()
       </code>
       call as follows. The result remains the same.
      </p>
      <pre id="c17-code-0023"><code>myCopy(cbegin(vectorOne), cend(vectorOne), back_inserter(vectorTwo));</code></pre>
      <p>
       <span aria-label="665" epub:type="pagebreak" id="Page_665" role="doc-pagebreak">
       </span>
       With class template argument deduction (CTAD), this can also be written as follows:
      </p>
      <pre id="c17-code-0024"><code>myCopy(cbegin(vectorOne), cend(vectorOne), back_insert_iterator { vectorTwo });</code></pre>
      <p id="c17-para-0096">
       The
       <code>
        front_insert_iterator
       </code>
       and
       <code>
        insert_iterator
       </code>
       work similarly, except that the
       <code>
        insert_iterator
       </code>
       also takes an initial iterator position in its constructor, which it passes to the first call to
       <code>
        insert(position,element)
       </code>
       . Subsequent iterator position hints are generated based on the return value from each
       <code>
        insert()
       </code>
       call.
      </p>
      <p id="c17-para-0097">
       One benefit of using an
       <code>
        insert_iterator
       </code>
       is that it allows you to use associative containers as destinations of modifying algorithms.
       <a href="c20.xhtml">
        Chapter 20
       </a>
       , “Mastering Standard Library Algorithms,” explains that the problem with associative containers is that you are not allowed to modify the keys over which you iterate. By using an
       <code>
        insert_iterator
       </code>
       , you insert elements instead of modifying existing ones. Associative containers have an
       <code>
        insert()
       </code>
       member function that takes an iterator position and can use the position as a “hint,” which they can ignore. When you use an
       <code>
        insert_iterator
       </code>
       on an associative container, you can pass the
       <code>
        begin()
       </code>
       or
       <code>
        end()
       </code>
       iterator of the container as the hint. The
       <code>
        insert_iterator
       </code>
       modifies the iterator hint that it passes to
       <code>
        insert()
       </code>
       after each call to
       <code>
        insert()
       </code>
       , such that the position is one past the just-inserted element.
      </p>
      <p>
       Here is the previous example modified so that the destination container is a
       <code>
        set
       </code>
       instead of a
       <code>
        vector
       </code>
       :
      </p>
      <pre id="c17-code-0025"><code>vector vectorOne { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code><b>set&lt;int&gt; setOne;</b></code>
<code> </code>
<code><b>insert_iterator&lt;set&lt;int&gt;&gt; inserter { setOne, begin(setOne) };</b></code>
<code>myCopy(cbegin(vectorOne), cend(vectorOne), inserter);</code>
<code> </code>
<code><b>println("{:n}", setOne);</b></code></pre>
      <p>
       Similar to the
       <code>
        back_insert_iterator
       </code>
       example, you can use the
       <code>
        std::inserter()
       </code>
       utility function to create an
       <code>
        insert_iterator
       </code>
       :
      </p>
      <pre id="c17-code-0026"><code>myCopy(cbegin(vectorOne), cend(vectorOne), inserter(setOne, begin(setOne)));</code></pre>
      <p>
       Or, use class template argument deduction:
      </p>
      <pre id="c17-code-0027"><code>myCopy(cbegin(vectorOne), cend(vectorOne),</code>
<code>    insert_iterator { setOne, begin(setOne) });</code></pre>
     </section>
     <section>
      <span id="c17-sec-0022">
      </span>
      <h3 id="head-3-392">
       Reverse Iterators
      </h3>
      <p>
       The Standard Library provides an
       <code>
        std::reverse_iterator
       </code>
       class template that iterates through a bidirectional or random-access iterator in a reverse direction. Every reversible container in the Standard Library, which happens to be every container that's part of the standard except
       <code>
        forward_list
       </code>
       and the unordered associative containers, supplies a
       <code>
        reverse_iterator
       </code>
       type alias and member functions called
       <code>
        rbegin()
       </code>
       and
       <code>
        rend()
       </code>
       . These
       <code>
        reverse_iterator
       </code>
       type aliases are of type
       <code>
        std::reverse_iterator&lt;T&gt;
       </code>
       with
       <code>
        T
       </code>
       equal to the
       <code>
        iterator
       </code>
       type alias of the container. The member function
       <code>
        rbegin()
       </code>
       returns a
       <code>
        reverse_iterator
       </code>
       pointing to the last element of the container, and
       <code>
        rend()
       </code>
       returns a
       <code>
        reverse_iterator
       </code>
       pointing to the element before the first element of
       <span aria-label="666" epub:type="pagebreak" id="Page_666" role="doc-pagebreak">
       </span>
       the container. Applying
       <code>
        operator++
       </code>
       to a
       <code>
        reverse_iterator
       </code>
       calls
       <code>
        operator--
       </code>
       on the underlying container iterator, and vice versa. For example, iterating over a collection from the beginning to the end can be done as follows:
      </p>
      <pre id="c17-code-0028"><code>for (auto iter { begin(collection) }; iter != end(collection); ++iter) {}</code></pre>
      <p>
       Iterating over the elements in the collection from the end to the beginning can be done using a
       <code>
        reverse_iterator
       </code>
       by calling
       <code>
        rbegin()
       </code>
       and
       <code>
        rend()
       </code>
       . Note that you still call
       <code>
        ++iter
       </code>
       .
      </p>
      <pre id="c17-code-0029"><code>for (auto iter { rbegin(collection) }; iter != rend(collection); ++iter) {}</code></pre>
      <p id="c17-para-0103">
       An
       <code>
        std::reverse_iterator
       </code>
       is useful mostly with algorithms in the Standard Library or your own functions that have no equivalents that work in reverse order. The
       <code>
        myFind()
       </code>
       function introduced earlier in this chapter searches for the first element in a sequence. If you want to find the last element in the sequence, you can use a
       <code>
        reverse_iterator
       </code>
       . Note that when you call an algorithm such as
       <code>
        myFind()
       </code>
       with a
       <code>
        reverse_iterator
       </code>
       , it returns a
       <code>
        reverse_iterator
       </code>
       as well. You can always obtain the underlying
       <code>
        iterator
       </code>
       from a
       <code>
        reverse_iterator
       </code>
       by calling its
       <code>
        base()
       </code>
       member function. However, because of how
       <code>
        reverse_iterator
       </code>
       is implemented, the
       <code>
        iterator
       </code>
       returned from
       <code>
        base()
       </code>
       always refers to one element past the element referred to by the
       <code>
        reverse_iterator
       </code>
       on which it's called. To get to the same element, you must subtract one.
      </p>
      <p>
       Here is an example of
       <code>
        myFind()
       </code>
       with a
       <code>
        reverse_iterator
       </code>
       :
      </p>
      <pre id="c17-code-0030"><code>vector myVector { 11, 22, 33, 22, 11 };</code>
<code><b>auto it1 { myFind(begin(myVector), end(myVector), 22) };</b></code>
<code><b>auto it2 { myFind(rbegin(myVector), rend(myVector), 22) };</b></code>
<code>if (it1 != end(myVector) &amp;&amp; it2 != rend(myVector)) {</code>
<code>    println("Found at position {} going forward.",</code>
<code>             distance(begin(myVector), it1));</code>
<code>    println("Found at position {} going backward.",</code>
<code>             distance(begin(myVector), --it2.base()));</code>
<code>} else {</code>
<code>    println("Failed to find.");</code>
<code>}</code></pre>
      <p>
       The output of this program is as follows:
      </p>
      <pre id="c17-code-0031"><code>Found at position 1 going forward.</code>
<code>Found at position 3 going backward.</code></pre>
     </section>
     <section>
      <span id="c17-sec-0023">
      </span>
      <h3 id="head-3-393">
       Move Iterators
      </h3>
      <p>
       <a href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” discusses
       <i>
        move semantics
       </i>
       , which can be used to prevent unnecessary copying in cases where you know that the source object will be destroyed after an assignment operation or copy construction, or explicitly when using
       <code>
        std::move()
       </code>
       . The Standard Library provides an iterator adapter called
       <code>
        std::move_iterator
       </code>
       . The dereferencing operator of a
       <code>
        move_iterator
       </code>
       automatically converts the value to an
       <i>
        rvalue reference
       </i>
       , which means that the value can be moved to a new destination without the overhead of copying. Before you can use move semantics, you need to make sure your objects are supporting it. The following
       <code>
        MoveableClass
       </code>
       supports move semantics. For more details, see
       <a href="c09.xhtml">
        Chapter 9
       </a>
       .
      </p>
      <pre id="c17-code-0032"><code>class MoveableClass</code>
<code>{</code>
<code>    public:</code>
<span aria-label="667" epub:type="pagebreak" id="Page_667" role="doc-pagebreak"></span><code>        MoveableClass() {</code>
<code>            println("Default constructor");</code>
<code>        }</code>
<code>        MoveableClass(const MoveableClass&amp; src) {</code>
<code>            println("Copy constructor");</code>
<code>        }</code>
<code>        MoveableClass(MoveableClass&amp;&amp; src) noexcept {</code>
<code>            println("Move constructor");</code>
<code>        }</code>
<code>        MoveableClass&amp; operator=(const MoveableClass&amp; rhs) {</code>
<code>            println("Copy assignment operator");</code>
<code>            return *this;</code>
<code>        }</code>
<code>        MoveableClass&amp; operator=(MoveableClass&amp;&amp; rhs) noexcept {</code>
<code>            println("Move assignment operator");</code>
<code>            return *this;</code>
<code>        }</code>
<code>};</code></pre>
      <p>
       The constructors and assignment operators are not doing anything useful here, except printing a message to make it easy to see which one is being called. Now that you have this class, you can define a
       <code>
        vector
       </code>
       and store a few
       <code>
        MoveableClass
       </code>
       instances in it as follows:
      </p>
      <pre id="c17-code-0033"><code>vector&lt;MoveableClass&gt; vecSource;</code>
<code>MoveableClass mc;</code>
<code>vecSource.push_back(mc);</code>
<code>vecSource.push_back(mc);</code></pre>
      <p>
       The output could be as follows. The numbers behind each line are not part of the output but are added to make it easier for the upcoming discussion to refer to specific lines.
      </p>
      <pre id="c17-code-0034"><code>Default constructor  <span class="color3">// [1]</span></code>
<code>Copy constructor     <span class="color3">// [2]</span></code>
<code>Copy constructor     <span class="color3">// [3]</span></code>
<code>Move constructor     <span class="color3">// [4]</span></code></pre>
      <p id="c17-para-0109">
       The second line of the code creates a
       <code>
        MoveableClass
       </code>
       instance by using the default constructor, [1]. The first
       <code>
        push_back()
       </code>
       call triggers the copy constructor to copy
       <code>
        mc
       </code>
       into the
       <code>
        vector
       </code>
       , [2]. After this operation, the vector has space for one element, the first copy of
       <code>
        mc
       </code>
       . Note that this discussion is based on the growth strategy and the initial size of a
       <code>
        vector
       </code>
       as implemented by Microsoft Visual C++ 2022. The C++ standard does not specify the initial capacity of a
       <code>
        vector
       </code>
       or its growth strategy, so the output can be different with different compilers.
      </p>
      <p id="c17-para-0110">
       The second
       <code>
        push_back()
       </code>
       call triggers the
       <code>
        vector
       </code>
       to resize itself, to allocate space for the second element. This resizing causes the move constructor to be called to move every element from the old
       <code>
        vector
       </code>
       to the new resized
       <code>
        vector
       </code>
       , [4]. The copy constructor is triggered to copy
       <code>
        mc
       </code>
       a second time into the
       <code>
        vector
       </code>
       , [3]. The order of moving and copying is undefined, so [3] and [4] could be reversed.
      </p>
      <p>
       You can create a new
       <code>
        vector
       </code>
       called
       <code>
        vecOne
       </code>
       that contains a copy of the elements from
       <code>
        vecSource
       </code>
       as follows:
      </p>
      <pre id="c17-code-0035"><code>vector&lt;MoveableClass&gt; vecOne { cbegin(vecSource), cend(vecSource) };</code></pre>
      <p>
       <span aria-label="668" epub:type="pagebreak" id="Page_668" role="doc-pagebreak">
       </span>
       Without using
       <code>
        move_iterator
       </code>
       s, this code triggers the copy constructor two times, once for every element in
       <code>
        vecSource
       </code>
       :
      </p>
      <pre id="c17-code-0036"><code>Copy constructor</code>
<code>Copy constructor</code></pre>
      <p>
       By using
       <code>
        std::make_move_iterator()
       </code>
       to create
       <code>
        move_iterator
       </code>
       s, the move constructor of
       <code>
        MoveableClass
       </code>
       is called instead of the copy constructor:
      </p>
      <pre id="c17-code-0037"><code>vector&lt;MoveableClass&gt; vecTwo { make_move_iterator(begin(vecSource)),</code>
<code>                               make_move_iterator(end(vecSource)) };</code></pre>
      <p>
       This generates the following output:
      </p>
      <pre id="c17-code-0038"><code>Move constructor</code>
<code>Move constructor</code></pre>
      <p>
       You can also use class template argument deduction (CTAD) with
       <code>
        move_iterator
       </code>
       :
      </p>
      <pre id="c17-code-0039"><code>vector&lt;MoveableClass&gt; vecTwo { move_iterator { begin(vecSource) },</code>
<code>                               move_iterator { end(vecSource) } };</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0117">
          <b>
           WARNING
          </b>
          <i>
           Remember that you should no longer use an object once it has been moved to another object
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-193">
     <span id="c17-sec-0025">
     </span>
     <h2 id="head-2-193">
      RANGES
     </h2>
     <p>
      The iterator support of the C++ Standard Library allows algorithms to work independently of the actual containers, as they abstract away the mechanism to navigate through the elements of a container. As you've seen in all iterator examples up to now, most algorithms need an iterator pair consisting of a begin iterator that refers to the first element in the sequence, and an end iterator referring to one past the last element in the sequence. This makes it possible for algorithms to work on all kinds of containers, but it's a bit cumbersome to always have to provide two iterators to specify a sequence of elements and to make sure you don't provide mismatching iterators.
      <i>
       Ranges
      </i>
      provided by the
      <i>
       ranges library
      </i>
      are an abstraction layer on top of iterators, eliminating mismatching iterator errors, and adding extra functionality such as allowing range adapters to lazily filter and transform underlying sequences of elements. The ranges library, defined in
      <code>
       &lt;ranges&gt;
      </code>
      , consists of the following major components:
     </p>
     <ul class="check1" id="c17-list-0007">
      <li id="c17-li-0022">
       <b>
        Ranges:
       </b>
       A range is a concept (see
       <a href="c12.xhtml">
        Chapter 12
       </a>
       ) defining the requirements for a type that allows iteration over its elements. Any data structure that supports
       <code>
        begin()
       </code>
       and
       <code>
        end()
       </code>
       is a valid range. For example,
       <code>
        std::array
       </code>
       ,
       <code>
        vector
       </code>
       ,
       <code>
        string_view
       </code>
       ,
       <code>
        span
       </code>
       , fixed-size C-style arrays, and so on, are all valid ranges.
      </li>
      <li id="c17-li-0023">
       <b>
        Constrained algorithms:
       </b>
       <a href="c16.xhtml">
        Chapters 16
       </a>
       and
       <a href="c20.xhtml">
        20
       </a>
       discuss the available Standard Library algorithms accepting iterator pairs to perform their work. For most of these algorithms there are equivalent range-based and constrained variants that accept iterator pairs or ranges.
      </li>
      <li id="c17-li-0024">
       <span aria-label="669" epub:type="pagebreak" id="Page_669" role="doc-pagebreak">
       </span>
       <b>
        Projection:
       </b>
       A lot of the constrained algorithms accept a projection callback. This callback is called for each element in the range and can transform an element to some other value before it is passed to the algorithm.
      </li>
      <li id="c17-li-0025">
       <b>
        Views:
       </b>
       A view can be used to transform or filter the elements of an underlying range. Views can be composed together to form pipelines of operations to be applied to a range.
      </li>
      <li id="c17-li-0026">
       <b>
        Factories:
       </b>
       A range factory is used to construct a view that produces values on demand.
      </li>
     </ul>
     <p id="c17-para-0119">
      Iteration over the elements in a range can be done with iterators that can be retrieved with accessors such as
      <code>
       ranges::begin()
      </code>
      ,
      <code>
       end()
      </code>
      ,
      <code>
       rbegin()
      </code>
      , and so on. Ranges also support
      <code>
       ranges::empty()
      </code>
      ,
      <code>
       data()
      </code>
      ,
      <code>
       cdata()
      </code>
      , and
      <code>
       size()
      </code>
      . The latter returns the number of elements in a range but works only if the size can be retrieved in constant time. Otherwise, use
      <code>
       std::distance()
      </code>
      to calculate the number of elements between a begin and end iterator of a range. All these accessors are not member functions but stand-alone free functions, all requiring a range as argument.
     </p>
     <p id="c17-para-0120">
      Additionally,
      <code>
       std::format()
      </code>
      ,
      <code>
       print()
      </code>
      , and
      <code>
       println()
      </code>
      have full support for formatting and printing ranges, as is demonstrated by numerous examples throughout this section.
     </p>
     <section>
      <span id="c17-sec-0026">
      </span>
      <h3 id="head-3-394">
       Constrained Algorithms
      </h3>
      <p>
       The
       <code>
        std::sort()
       </code>
       algorithm is an example of an algorithm that requires a sequence of elements specified as a begin and end iterator. Algorithms are introduced in
       <a href="c16.xhtml">
        Chapter 16
       </a>
       and discussed in detail in
       <a href="c20.xhtml">
        Chapter 20
       </a>
       . The
       <code>
        sort()
       </code>
       algorithm is straightforward to use. For example, the following code sorts all the elements of a
       <code>
        vector
       </code>
       :
      </p>
      <pre id="c17-code-0040"><code>vector data { 33, 11, 22 };</code>
<code>sort(begin(data), end(data));</code></pre>
      <p>
       This code sorts all the elements in the
       <code>
        data
       </code>
       container, but you have to specify the sequence as a begin/end iterator pair. Wouldn't it be nicer to more accurately describe in your code what you really want to do? That's where the
       <i>
        range-based and constrained algorithms
       </i>
       , simply called
       <i>
        constrained algorithms
       </i>
       in this book, come in. These algorithms live in the
       <code>
        std::ranges
       </code>
       namespace and are defined in the same header file as the corresponding unconstrained variants. With those, you can simply write the following:
      </p>
      <pre id="c17-code-0041"><code>ranges::sort(data);</code></pre>
      <p>
       This code clearly describes your intent, that is, sorting all elements of the
       <code>
        data
       </code>
       container. Since you are not specifying iterators anymore, these constrained algorithms eliminate the possibility of accidentally supplying mismatching begin and end iterators. The constrained algorithms have proper type constraints (see
       <a href="c12.xhtml">
        Chapter 12
       </a>
       ) for their template type parameters. This allows compilers to provide clearer error messages in case you supply a container to a constrained algorithm that does not provide the type of iterator the algorithm requires. For example, calling the
       <code>
        ranges::sort()
       </code>
       algorithm on an
       <code>
        std::list
       </code>
       will result in a compiler error stating more clearly that
       <code>
        sort()
       </code>
       requires a random-access range, which
       <code>
        list
       </code>
       isn't. Similar to iterators, you have input-, output-, forward-, bidirectional-, random-access-, and contiguous ranges, with corresponding concepts such as
       <code>
        ranges::contiguous_range
       </code>
       ,
       <code>
        ranges::random_access_range
       </code>
       , and so on.
       <span aria-label="670" epub:type="pagebreak" id="Page_670" role="doc-pagebreak">
       </span>
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c17-para-0124">
          <b>
           NOTE
          </b>
          <i>
           Most Standard Library algorithms, introduced in
          </i>
          <a href="c16.xhtml">
           <i>
            Chapter
           </i>
           16
          </a>
          <i>
           and discussed in detail in
          </i>
          <a href="c20.xhtml">
           <i>
            Chapter
           </i>
           20
          </a>
          <i>
           , have constrained equivalents in the
          </i>
          <code>
           std::ranges
          </code>
          <i>
           namespace. It's recommended to always use these constrained algorithms, if possible, as the compiler can provide better error messages when such algorithms are used with the wrong types, thanks to their type constraints.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <section>
       <span id="c17-sec-0028">
       </span>
       <h4 id="head-4-275">
        Projection
       </h4>
       <p>
        A lot of the constrained algorithms have a
        <i>
         projection
        </i>
        parameter, a callback used to transform each element before it is handed over to the algorithm. Let's look at an example. Suppose you have a simple class representing a person:
       </p>
       <pre id="c17-code-0042"><code>class Person</code>
<code>{</code>
<code>    public:</code>
<code>        explicit Person(string first, string last)</code>
<code>            : m_firstName { move(first) }, m_lastName { move(last) } { }</code>
<code>        const string&amp; getFirstName() const { return m_firstName; }</code>
<code>        const string&amp; getLastName() const { return m_lastName; }</code>
<code>    private:</code>
<code>        string m_firstName;</code>
<code>        string m_lastName;</code>
<code>};</code></pre>
       <p>
        The following code stores a couple of
        <code>
         Person
        </code>
        objects in a
        <code>
         vector
        </code>
        :
       </p>
       <pre id="c17-code-0043"><code>vector persons { Person {"John", "White"}, Person {"Chris", "Blue"} };</code></pre>
       <p>
        Since the
        <code>
         Person
        </code>
        class does not implement
        <code>
         operator&lt;
        </code>
        , you cannot sort this
        <code>
         vector
        </code>
        using the normal
        <code>
         std::sort()
        </code>
        algorithm, as it compares elements using
        <code>
         operator&lt;
        </code>
        . So, the following does not compile:
       </p>
       <pre id="c17-code-0044"><code>sort(begin(persons), end(persons)); <span class="color3">// Error: does not compile.</span></code></pre>
       <p>
        Switching to the constrained
        <code>
         ranges::sort()
        </code>
        algorithm doesn't help much at first sight. The following still doesn't compile as the algorithm still doesn't know how to compare elements in the range:
       </p>
       <pre id="c17-code-0045"><code>ranges::sort(persons); <span class="color3">// Error: does not compile.</span></code></pre>
       <p>
        However, you can sort
        <code>
         persons
        </code>
        based on their first name, by specifying a projection function for the sort algorithm to project each person to their first name. The projection parameter is the third one, so we have to specify the second parameter as well, which is the comparator to use, by default
        <code>
         std::ranges::less
        </code>
        . In the following call, the
        <code>
         {}
        </code>
        specifies to use the default comparator, and the projection function is specified as a
        <i>
         lambda expression
        </i>
        , see upcoming note.
       </p>
       <pre id="c17-code-0046"><code>ranges::sort(persons, {},</code>
<code>    [](const Person&amp; person) { return person.getFirstName(); });</code></pre>
       <p>
        Or even shorter:
       </p>
       <pre id="c17-code-0047"><code>ranges::sort(persons, {}, &amp;Person::getFirstName);</code></pre>
       <p>
        <span aria-label="671" epub:type="pagebreak" id="Page_671" role="doc-pagebreak">
        </span>
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p>
           <b>
            NOTE
           </b>
           <i>
            The discussion on ranges in this chapter uses a few basic lambda expressions. Lambda expressions are discussed in detail in
           </i>
           <a href="c19.xhtml">
            <i>
             Chapter
            </i>
            19
           </a>
           <i>
            , “Function Pointers, Function Objects, and Lambda Expressions,” but all those details are not important for the current discussion. For now, it's enough to know only basic use. A lambda expression, as used in this chapter, has the following syntax:
           </i>
          </p>
          <pre id="c17-code-0048"><code>[](const Person&amp; person) { return person.getFirstName(); }</code></pre>
          <p id="c17-para-0134">
           <i>
            The
            <code>
             []
            </code>
            denotes the start of a lambda expression. Next is a comma-separated list of parameters, just as for functions. Finally, the body of the lambda expression is between a set of curly brackets
           </i>
           .
          </p>
          <p>
           <i>
            Basically, lambda expressions allow you to write small, unnamed inline functions at the place where you need them. The previous lambda expression could be replaced with the following standalone function:
           </i>
          </p>
          <pre id="c17-code-0049"><code>auto getFirstName(const Person&amp; person) {</code>
<code>     return person.getFirstName(); }</code></pre>
          <p>
           <i>
            The type of lambda expression parameters can also be
            <code>
             auto
            </code>
            . Here is an example:
           </i>
          </p>
          <pre id="c17-code-0050"><code>[](const auto&amp; person) { return person.getFirstName(); }</code></pre>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section>
      <span id="c17-sec-0032">
      </span>
      <h3 id="head-3-395">
       Views
      </h3>
      <p id="c17-para-0139">
       A
       <i>
        view
       </i>
       allows you to perform operations on an underlying range's elements, such as filtering and transforming. Views can be chained/composed together to form a
       <i>
        pipeline
       </i>
       performing multiple operations on the elements of a range. Composing views is easy, you just combine different operations using the bitwise OR operator,
       <code>
        operator|
       </code>
       . For example, you can easily filter the elements of a range first and then transform the remaining elements. In contrast, if you want to do something similar, filtering followed by transforming, using the unconstrained algorithms, your code will be much less readable and possibly less performant, as you'll have to create temporary containers to store intermediate results.
      </p>
      <p>
       A view has the following important properties:
      </p>
      <ul class="check1" id="c17-list-0008">
       <li id="c17-li-0027">
        <b>
         Lazily evaluated:
        </b>
        Just constructing a view doesn't perform any operations yet. The operations of a view are applied only at the moment you iterate over the elements of the view and dereference such an iterator.
       </li>
       <li id="c17-li-0028">
        <b>
         Nonowning
        </b>
        <a aria-describedby="c17-note-0001" epub:type="noteref" href="#c17-note-0001" id="R_c17-note-0001" role="doc-noteref">
         <sup>
          1
         </sup>
        </a>
        <b>
         :
        </b>
        A view doesn't own any elements. As the name suggests, it's a view over a range's elements that could be stored in some container, and it's that container that's the owner of the data. A view just allows you to view that data in different ways. As such, the number of elements in a view does not influence the cost of copying, moving, or destroying a view. This is similar to
        <code>
         std::string_view
        </code>
        discussed in
        <a href="c02.xhtml">
         Chapter 2
        </a>
        , “Working with Strings and String Views,” and
        <code>
         std::span
        </code>
        discussed in
        <a href="c18.xhtml">
         Chapter 18
        </a>
        , “Standard Library Containers.”
       </li>
       <li id="c17-li-0029">
        <b>
         Nonmutating:
        </b>
        A view never modifies the data in the underlying range.
       </li>
      </ul>
      <p id="c17-para-0141">
       <span aria-label="672" epub:type="pagebreak" id="Page_672" role="doc-pagebreak">
       </span>
       A view itself is also a range, but not every range is a view. A container is a range but not a view, as it owns its elements.
      </p>
      <p id="c17-para-0142">
       Views can be created using
       <i>
        range adapters
       </i>
       . A range adapter accepts an underlying sequence of elements, and optionally some arguments, and creates a new view. The following table lists the range adapters provided by the Standard Library. If none of the Standard Library adapters suits your needs, it's possible to write your own range adapters that properly interoperate with existing adapters. However, writing a full-fledged production-quality range adapter is not trivial and would take us a bit too far for the scope of this book. See your favorite Standard Library reference for more details.
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          RANGE ADAPTER
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           views::all
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view that includes all elements of a range.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           filter_view
          </code>
          <br/>
          <code>
           views::filter
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Filters the elements of an underlying sequence based on a given predicate. If the predicate returns
          <code>
           true
          </code>
          , the element is kept, otherwise it is skipped.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           transform_view
          </code>
          <br/>
          <code>
           views::transform
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Applies a callback to each element of an underlying sequence to transform the element to some other value, possibly of a different type.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           take_view
          </code>
          <br/>
          <code>
           views::take
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view of the first
          <i>
           n
          </i>
          elements of another view.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           take_while_view
          </code>
          <br/>
          <code>
           views::take_while
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view of the initial elements of an underlying sequence until an element is reached for which a given predicate returns
          <code>
           false
          </code>
          .
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           drop_view
          </code>
          <br/>
          <code>
           views::drop
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view by dropping the first
          <i>
           n
          </i>
          elements of another view.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           drop_while_view
          </code>
          <br/>
          <code>
           views::drop_while
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view by dropping all initial elements of an underlying sequence until an element is reached for which a given predicate returns
          <code>
           false
          </code>
          .
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           join_view
          </code>
          <br/>
          <code>
           views::join
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Flattens a view of ranges into a view. For example, flatten a
          <code>
           vector&lt;vector&lt;int&gt;&gt;
          </code>
          into a
          <code>
           vector&lt;int&gt;
          </code>
          .
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           lazy_split_view
          </code>
          <br/>
          <code>
           views::lazy_split
          </code>
          <br/>
          <code>
           split_view
          </code>
          <br/>
          <code>
           views::split
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Given a delimiter, splits a given view into subranges on the delimiter. The delimiter can be a single element or a view of elements.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           reverse_view
          </code>
          <br/>
          <code>
           views::reverse
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view that iterates over the elements of another view in reverse order. The view must be a bidirectional view.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           elements_view
          </code>
          <br/>
          <code>
           views::elements
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Requires a view of tuple-like elements, creates a view of the
          <i>
           n
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          elements of the tuple-like elements.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           keys_view
          </code>
          <br/>
          <code>
           views::keys
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Requires a view of pair-like elements, creates a view of the first element of each pair.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           values_view
          </code>
          <br/>
          <code>
           views::values
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Requires a view of pair-like elements, creates a view of the second element of each pair.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           common_view
          </code>
          <br/>
          <code>
           views::common
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Depending on the type of range,
          <code>
           begin()
          </code>
          and
          <code>
           end()
          </code>
          might return different types, such as a begin iterator and an end
          <i>
           sentinel
          </i>
          . This means that you cannot, for example, pass such an iterator pair to functions that expect them to be of the same type.
          <code>
           common_view
          </code>
          can be used to convert such a range to a
          <i>
           common range
          </i>
          which is a range for which
          <code>
           begin()
          </code>
          and
          <code>
           end()
          </code>
          return the same type. You will use this range adapter in one of the exercises.
          <span aria-label="673" epub:type="pagebreak" id="Page_673" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p id="c17-para-0176">
       <img alt="C++23" src="../images\images/icon1.png"/>
       C++23 adds the following range adapters:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          RANGE ADAPTER
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           as_const_view
          </code>
          <br/>
          <code>
           views::as_const
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view through which the elements of an underlying sequence cannot be modified.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           as_rvalue_view
          </code>
          <br/>
          <code>
           views::as_rvalue
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view of rvalues of all elements of an underlying sequence.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           enumerate_view
          </code>
          <br/>
          <code>
           views::enumerate
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view where each element represents the position and value of all elements of an underlying sequence.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           zip_view
          </code>
          <br/>
          <code>
           views::zip
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view consisting of tuples of reference to corresponding elements of all given views.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           zip_transform_view
          </code>
          <br/>
          <code>
           views::zip_transform
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view whose
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          element is the result of applying a given callable to the
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          elements of all given views.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           adjacent_view
          </code>
          <br/>
          <code>
           views::adjacent
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          For a given
          <i>
           n
          </i>
          , creates a view whose
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          element is a tuple of references to the
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          through (
          <i>
           i
          </i>
          +
          <i>
           n
          </i>
          − 1)
          <sup>
           th
          </sup>
          elements of a given view.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           adjacent_transform_view
          </code>
          <br/>
          <code>
           views::adjacent_transform
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          For a given
          <i>
           n
          </i>
          , creates a view whose
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          element is the result of applying a given callable to the
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          through (
          <i>
           i
          </i>
          +
          <i>
           n
          </i>
          − 1)
          <sup>
           th
          </sup>
          elements of a given view.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           views::pairwise
          </code>
          <br/>
          <code>
           views::pairwise_transform
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Helper types representing
          <code>
           views::adjacent&lt;2&gt;
          </code>
          and
          <code>
           views::adjacent_transform&lt;2&gt;
          </code>
          respectively.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           join_with_view
          </code>
          <br/>
          <code>
           views::join_with
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Given a delimiter, flattens the elements of a given view, inserting every element of the delimiter in between elements of the view. The delimiter can be a single element or a view of elements.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           stride_view
          </code>
          <br/>
          <code>
           views::stride
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          For a given
          <i>
           n
          </i>
          , creates a view of an underlying sequence, advancing over
          <i>
           n
          </i>
          elements at a time, instead of one by one.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           slide_view
          </code>
          <br/>
          <code>
           views::slide
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          For a given
          <i>
           n
          </i>
          , creates a view whose
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          element is a view over the
          <i>
           i
          </i>
          <sup>
           <i>
            th
           </i>
          </sup>
          through (
          <i>
           i
          </i>
          +
          <i>
           n
          </i>
          − 1)
          <sup>
           th
          </sup>
          elements of the original view. Similar to
          <code>
           views::adjacent
          </code>
          , but the window size,
          <i>
           n
          </i>
          , is a runtime parameter for
          <code>
           slide
          </code>
          , while it's a template argument for
          <code>
           adjacent
          </code>
          .
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           chunk_view
          </code>
          <br/>
          <code>
           views::chunk
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          For a given
          <i>
           n
          </i>
          , creates a range of views that are
          <i>
           n
          </i>
          -sized non-overlapping successive chunks of the elements of the original view, in order.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           chunk_by_view
          </code>
          <br/>
          <code>
           views::chunk_by
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Splits a given view into subranges between each pair of adjacent elements for which a given predicate returns
          <code>
           false
          </code>
          .
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           cartesian_product_view
          </code>
          <br/>
          <code>
           views::cartesian_product
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Given a number of ranges,
          <i>
           n
          </i>
          , creates a view of tuples calculated by the
          <i>
           n
          </i>
          -ary cartesian product of the provided ranges.
          <span aria-label="674" epub:type="pagebreak" id="Page_674" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p id="c17-para-0207">
       The range adapters in the first column of both tables show both the class name in the
       <code>
        std::ranges
       </code>
       namespace and a corresponding
       <i>
        range adapter object
       </i>
       from the
       <code>
        std::ranges::views
       </code>
       namespace. The Standard Library provides a namespace alias called
       <code>
        std::views
       </code>
       equal to
       <code>
        std::ranges::views
       </code>
       .
      </p>
      <p>
       Each range adapter can be constructed by calling its constructor and passing any required arguments. The first argument is always the range on which to operate, followed by zero or more additional arguments, as follows:
      </p>
      <pre id="c17-code-0051"><code>std::ranges::<i>operation</i>_view { range, arguments… }</code></pre>
      <p>
       Usually, you will not create these range adapters using their constructors, but instead use the range adapter objects from the
       <code>
        std::ranges::views
       </code>
       namespace in combination with the bitwise OR operator,
       <code>
        |
       </code>
       , as follows:
      </p>
      <pre id="c17-code-0052"><code>range | std::ranges::views::<i>operation</i>(arguments…)</code></pre>
      <p>
       Let's see some of these range adapters in action. The following example first defines an abbreviated function template called
       <code>
        printRange()
       </code>
       to print a message followed by all the elements in a given range. Next, the
       <code>
        main()
       </code>
       function starts by creating a
       <code>
        vector
       </code>
       of integers, 1…10, and subsequently applies several range adapters on it, each time calling
       <code>
        printRange()
       </code>
       on the result so you can follow
       <span aria-label="675" epub:type="pagebreak" id="Page_675" role="doc-pagebreak">
       </span>
       what's happening. Afterward, it demonstrates several of the new C++23 range adapters. The example uses the
       <code>
        myCopy()
       </code>
       function introduced earlier in this chapter.
      </p>
      <pre id="c17-code-0053"><code>void printRange(string_view msg, auto&amp;&amp; range) { println("{}{:n}", msg, range); }</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code>    printRange("Original sequence: ", values);</code>
<code> </code>
<code>    <span class="color3">// Filter out all odd values, leaving only the even values.</span></code>
<code>    auto result1 { values</code>
<code>        | views::<b>filter</b>([](const auto&amp; value) { return value % 2 == 0; }) };</code>
<code>    printRange("Only even values: ", result1);</code>
<code> </code>
<code>    <span class="color3">// Transform all values to their double value.</span></code>
<code>    auto result2 { result1</code>
<code>        | views::<b>transform</b>([](const auto&amp; value) { return value * 2.0; }) };</code>
<code>    printRange("Values doubled: ", result2);</code>
<code> </code>
<code>    <span class="color3">// Drop the first 2 elements.</span></code>
<code>    auto result3 { result2 | views::<b>drop</b>(2) };</code>
<code>    printRange("First two dropped: ", result3);</code>
<code> </code>
<code>    <span class="color3">// Reverse the view.</span></code>
<code>    auto result4 { result3 | views::<b>reverse</b> };</code>
<code>    printRange("Sequence reversed: ", result4);</code>
<code> </code>
<code>    <span class="color3">// C++23: views::zip</span></code>
<code>    vector v1 { 1, 2 };</code>
<code>    vector v2 { 'a', 'b', 'c' };</code>
<code>    auto result5 { views::<b>zip</b>(v1, v2) };</code>
<code>    printRange("views::zip: ", result5);</code>
<code> </code>
<code>    <span class="color3">// C++23: views::adjacent</span></code>
<code>    vector v3 { 1, 2, 3, 4, 5 };</code>
<code>    auto result6 { v3 | views::<b>adjacent</b>&lt;2&gt; };</code>
<code>    printRange("views::adjacent: ", result6);</code>
<code> </code>
<code>    <span class="color3">// C++23: views::chunk</span></code>
<code>    auto result7 { v3 | views::<b>chunk</b>(2) };</code>
<code>    printRange("views::chunk: ", result7);</code>
<code> </code>
<code>    <span class="color3">// C++23: views::stride</span></code>
<code>    auto result8 { v3 | views::<b>stride</b>(2) };</code>
<code>    printRange("views::stride: ", result8);</code>
<code> </code>
<code>    <span class="color3">// C++23: views::enumerate + views::split</span></code>
<code>    string lorem { "Lorem ipsum dolor sit amet" };</code>
<code>    for (auto [index, word] : lorem | views::<b>split</b>(' ') | views::<b>enumerate</b>) {</code>
<code>        print("{}:'{}' ", index, string_view { word });</code>
<code>    }</code>
<code>    println("");</code>
<code> </code>
<span aria-label="676" epub:type="pagebreak" id="Page_676" role="doc-pagebreak"></span><code>    <span class="color3">// C++23: views::as_rvalue</span></code>
<code>    vector&lt;string&gt; words { "Lorem", "ipsum", "dolor", "sit", "amet" };</code>
<code>    vector&lt;string&gt; movedWords;</code>
<code>    auto rvalueView { words | views::<b>as_rvalue</b> };</code>
<code>    myCopy(begin(rvalueView), end(rvalueView), back_inserter(movedWords));</code>
<code>    printRange("movedWords: ", movedWords);</code>
<code> </code>
<code>    <span class="color3">// C++23: Cartesian product of vector v with itself.</span></code>
<code>    vector v { 0, 1, 2 };</code>
<code>    for (auto&amp;&amp;[a, b] : views::<b>cartesian_product</b>(v, v)) {print("({},{}) ", a, b);}</code>
<code>}</code></pre>
      <p>
       The output of this program is as follows:
      </p>
      <pre id="c17-code-0054"><code>Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code>Only even values: 2, 4, 6, 8, 10</code>
<code>Values doubled: 4, 8, 12, 16, 20</code>
<code>First two dropped: 12, 16, 20</code>
<code>Sequence reversed: 20, 16, 12</code>
<code>views::zip: (1, 'a'), (2, 'b')</code>
<code>views::adjacent: (1, 2), (2, 3), (3, 4), (4, 5)</code>
<code>views::chunk: (1, 2), (3, 4), (5)</code>
<code>views::stride: 1, 3, 5</code>
<code>0:'Lorem' 1:'ipsum' 2:'dolor' 3:'sit' 4:'amet'</code>
<code>movedWords: Lorem, ipsum, dolor, sit, amet</code>
<code>(0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1) (2,2)</code></pre>
      <p id="c17-para-0212">
       It's worth repeating that views are lazily evaluated. In this example, the construction of the
       <code>
        result1
       </code>
       view does not do any actual filtering yet. The filtering happens at the time when the
       <code>
        printRange()
       </code>
       function iterates over the elements of
       <code>
        result1
       </code>
       .
      </p>
      <p>
       The code snippet uses the range adapter objects from
       <code>
        std::ranges::views
       </code>
       . You can also construct range adapters using their constructors. For example, the
       <code>
        result1
       </code>
       view can be constructed as follows:
      </p>
      <pre id="c17-code-0055"><code>auto result1 { ranges::filter_view { values,</code>
<code>    [](const auto&amp; value) { return value % 2 == 0; } } };</code></pre>
      <p>
       This example is creating several intermediate views,
       <code>
        result1
       </code>
       ,
       <code>
        result2
       </code>
       ,
       <code>
        result3
       </code>
       , and
       <code>
        result4
       </code>
       , to be able to output their elements to make it easier to follow what's happening in each step. If you don't need these intermediate views, you can chain them all together in a single pipeline as follows:
      </p>
      <pre id="c17-code-0056"><code>vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code>printRange("Original sequence: ", values);</code>
<code> </code>
<code>auto result { values</code>
<code>    | views::filter([](const auto&amp; value) { return value % 2 == 0; })</code>
<code>    | views::transform([](const auto&amp; value) { return value * 2.0; })</code>
<code>    | views::drop(2)</code>
<code>    | views::reverse };</code>
<code>printRange("Final sequence: ", result);</code></pre>
      <p>
       The output is as follows. The last line shows that the final sequence is the same as the earlier
       <code>
        result4
       </code>
       view.
      </p>
      <pre id="c17-code-0057"><code>Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code>Final sequence: 20, 16, 12</code></pre>
      <span aria-label="677" epub:type="pagebreak" id="Page_677" role="doc-pagebreak">
      </span>
      <section>
       <span id="c17-sec-0033">
       </span>
       <h4 id="head-4-276">
        Modifying Elements Through a View
       </h4>
       <p id="c17-para-0216">
        Some ranges are read-only. For example, the result of
        <code>
         views::transform
        </code>
        is a read-only view, because it creates a view with transformed elements but without transforming the actual values in the underlying range. If a range is not read-only, then you can modify the elements of that range through a view. Let's look an example.
       </p>
       <p>
        The following example constructs a
        <code>
         vector
        </code>
        of ten elements. It then creates a view over the even values, drops the first two even values, and finally reverses the elements. The range-based
        <code>
         for
        </code>
        loop then multiplies the elements in the resulting view with 10. The last line outputs the elements in the original
        <code>
         values vector
        </code>
        to confirm that some elements have been changed through the view.
       </p>
       <pre id="c17-code-0058"><code>vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code>printRange("Original sequence: ", values);</code>
<code> </code>
<code><span class="color3">// Filter out all odd values, leaving only the even values.</span></code>
<code>auto result1 { values</code>
<code>    | views::filter([](const auto&amp; value) { return value % 2 == 0; }) };</code>
<code>printRange("Only even values: ", result1);</code>
<code> </code>
<code><span class="color3">// Drop the first 2 elements.</span></code>
<code>auto result2 { result1 | views::drop(2) };</code>
<code>printRange("First two dropped: ", result2);</code>
<code> </code>
<code><span class="color3">// Reverse the view.</span></code>
<code>auto result3 { result2 | views::reverse };</code>
<code>printRange("Sequence reversed: ", result3);</code>
<code> </code>
<code><span class="color3">// Modify the elements using a range-based for loop.</span></code>
<code>for (auto&amp; value : result3) { value *= 10; }</code>
<code>printRange("After modifying elements through a view, vector contains:\n", values);</code></pre>
       <p>
        The output of this program is as follows:
       </p>
       <pre id="c17-code-0059"><code>Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code>Only even values: 2, 4, 6, 8, 10</code>
<code>First two dropped: 6, 8, 10</code>
<code>Sequence reversed: 10, 8, 6</code>
<code>After modifying elements through a view, vector contains: 1, 2, 3, 4, 5, 60, 7, 80, 9, 100</code></pre>
      </section>
      <section>
       <span id="c17-sec-0034">
       </span>
       <h4 id="head-4-277">
        Mapping Elements
       </h4>
       <p>
        Transforming elements of a range doesn't need to result in a range with elements of the same type. Instead, you can
        <i>
         map
        </i>
        elements to another type. The following example starts with a range of integers, filters out all odd elements, keeps only the first three even values, and transforms those to strings using
        <code>
         std::format()
        </code>
        :
       </p>
       <pre id="c17-code-0060"><code>vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code>printRange("Original sequence: ", values);</code>
<code> </code>
<code>auto result { values</code>
<code>    | views::filter([](const auto&amp; value) { return value % 2 == 0; })</code>
<code>    | views::take(3)</code>
<code>    | views::transform([](const auto&amp; v) { return format("{}", v); }) };</code>
<code>printRange("Result: ", result);</code></pre>
       <p>
        <span aria-label="678" epub:type="pagebreak" id="Page_678" role="doc-pagebreak">
        </span>
        The output is as follows:
       </p>
       <pre id="c17-code-0061"><code>Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code>Result: "2", "4", "6"</code></pre>
      </section>
     </section>
     <section>
      <span id="c17-sec-0035">
      </span>
      <h3 id="head-3-396">
       Range Factories
      </h3>
      <p id="c17-para-0221">
       The ranges library provides the following
       <i>
        range factories
       </i>
       to construct views that produce elements lazily on demand:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          RANGE FACTORY
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           empty_view
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates an empty view.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           single_view
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view with a single given element.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           iota_view
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates an infinite or a bounded view containing elements starting with an initial value, and where each subsequent element has a value equal to the value of the previous element incremented by one.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <img alt="C++23" src="../images\images/icon1.png"/>
          <code>
           repeat_view
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view that repeats a given value. The resulting view can be unbounded (infinite) or bounded by a given number of values.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           basic_istream_view
          </code>
          <br/>
          <code>
           istream_view
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Creates a view containing elements retrieved by calling the extraction operator,
          <code>
           operator&gt;&gt;
          </code>
          , on an underlying input stream.
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       Just as with the range adapters from the previous section, the names in the range factories table are class names living in the
       <code>
        std::ranges
       </code>
       namespace, which you can directly create using their constructor. Alternatively, you can use the factory functions available in the
       <code>
        std::ranges:views
       </code>
       namespace. For example, the following two statements are equivalent and create an infinite view with elements 10, 11, 12, …:
      </p>
      <pre id="c17-code-0062"><code>std::ranges::iota_view { 10 }</code>
<code>std::ranges::views::iota(10)</code></pre>
      <p>
       Let's look at a range factory in practice. The following example is loosely based on an earlier example, but instead of constructing a
       <code>
        vector
       </code>
       with 10 elements in it, this code uses the
       <code>
        iota
       </code>
       range factory to create a lazy infinite sequence of numbers starting at 10. It then removes all odd values, doubles the remaining elements, and finally only keeps the first ten elements that are subsequently output to the console using
       <code>
        printRange()
       </code>
       .
      </p>
      <pre id="c17-code-0063"><code><span class="color3">// Create an infinite sequence of the numbers 10, 11, 12, …</span></code>
<code>auto values { views::iota(10) };</code>
<code><span class="color3">// Filter out all odd values, leaving only the even values.</span></code>
<code>auto result1 { values</code>
<code>    | views::filter([](const auto&amp; value) { return value % 2 == 0; }) };</code>
<code><span class="color3">// Transform all values to their double value.</span></code>
<code>auto result2 { result1</code>
<code>    | views::transform([](const auto&amp; value) { return value * 2.0; }) };</code>
<code><span class="color3">// Take only the first ten elements.</span></code>
<code>auto result3 { result2 | views::take(10) };</code>
<code>printRange("Result: ", result3);</code></pre>
      <p>
       <span aria-label="679" epub:type="pagebreak" id="Page_679" role="doc-pagebreak">
       </span>
       The output is as follows:
      </p>
      <pre id="c17-code-0064"><code>Result: 20, 24, 28, 32, 36, 40, 44, 48, 52, 56</code></pre>
      <p id="c17-para-0231">
       The
       <code>
        values
       </code>
       range represents an infinite range, which is subsequently filtered and transformed. Working with infinite ranges is possible because all these operations are lazily evaluated only at the time when
       <code>
        printRange()
       </code>
       iterates over the elements of the view. This also means that in this example you cannot call
       <code>
        printRange()
       </code>
       to output the contents of
       <code>
        values
       </code>
       ,
       <code>
        result1
       </code>
       , or
       <code>
        result2
       </code>
       because that would trigger an infinite loop in
       <code>
        printRange()
       </code>
       as those are infinite ranges.
      </p>
      <p>
       Of course, you can get rid of those intermediate views and simply construct one big pipeline. The following produces the same output as before:
      </p>
      <pre id="c17-code-0065"><code>auto result { views::iota(10)</code>
<code>    | views::filter([](const auto&amp; value) { return value % 2 == 0; })</code>
<code>    | views::transform([](const auto&amp; value) { return value * 2.0; })</code>
<code>    | views::take(10) };</code>
<code>printRange("Result: ", result);</code></pre>
      <p>
       Another range factory example demonstrates how to use a
       <code>
        repeat_view
       </code>
       :
      </p>
      <pre id="c17-code-0066"><code>printRange("Repeating view: ", views::repeat(42, 5));</code></pre>
      <p>
       This outputs the following:
      </p>
      <pre id="c17-code-0067"><code>Repeating view: 42, 42, 42, 42, 42</code></pre>
      <section>
       <span id="c17-sec-0036">
       </span>
       <h4 id="head-4-278">
        Input Streams as Views
       </h4>
       <p id="c17-para-0235">
        The
        <code>
         basic_istream_view
        </code>
        /
        <code>
         istream_view
        </code>
        range factory can be used to construct a view over the elements read from an input stream, such as the standard input. Elements are read using
        <code>
         operator&gt;&gt;
        </code>
        .
       </p>
       <p>
        For example, the following code snippet keeps reading integers from standard input. For each read number that is less than 5, the number is doubled and printed on standard output. Once you enter a number 5 or higher, the loop stops.
       </p>
       <pre id="c17-code-0068"><code>println("Type integers, an integer&gt;= 5 stops the program.");</code>
<code>for (auto value : ranges::istream_view&lt;int&gt; { cin }</code>
<code>    | views::take_while([](const auto&amp; v) { return v &lt; 5; })</code>
<code>    | views::transform([](const auto&amp; v) { return v * 2; })) {</code>
<code>    println("&gt; {}", value);</code>
<code>}</code>
<code>println("Terminating…");</code></pre>
       <p>
        The following is a possible output sequence:
       </p>
       <pre id="c17-code-0069"><code>Type integers, an integer&gt;= 5 stops the program.</code>
<code>1 2</code>
<code>&gt; 2</code>
<code>&gt; 4</code>
<code>3</code>
<code>&gt; 6</code>
<code>4</code>
<code>&gt; 8</code>
<code>5</code>
<code>Terminating…</code></pre>
       <span aria-label="680" epub:type="pagebreak" id="Page_680" role="doc-pagebreak">
       </span>
      </section>
     </section>
     <section>
      <span id="c17-sec-0037">
      </span>
      <h3 id="head-3-397">
       <img alt="C++23" src="../images\images/icon1.png"/>
       Converting a Range into a Container
      </h3>
      <p id="c17-para-0239">
       Before C++23, it was not easy to convert a range into a container. C++23 introduces
       <code>
        std::ranges::to()
       </code>
       to make such conversions straightforward. This can also be used to convert the elements of a view into a container, as a view is a range. Even more, since a container is a range as well, you can use
       <code>
        ranges::to()
       </code>
       to convert one container into a different container, even with different element types.
      </p>
      <p>
       The following code snippet demonstrates several uses of
       <code>
        ranges::to()
       </code>
       . The example also demonstrates special constructors for
       <code>
        set
       </code>
       and
       <code>
        string
       </code>
       , which accept the
       <code>
        std::from_range
       </code>
       tag as the first parameter and convert a given range into a
       <code>
        set
       </code>
       or
       <code>
        string
       </code>
       . All Standard Library containers now include such constructors.
      </p>
      <pre id="c17-code-0070"><code><span class="color3">// Convert a vector to a set with the same element type.</span></code>
<code>vector vec { 33, 11, 22 };</code>
<code>auto s1 { ranges::to&lt;set&gt;(vec) };</code>
<code>println("{:n}", s1);</code>
<code> </code>
<code><span class="color3">// Convert a vector of integers to a set of doubles, using the pipe operator.</span></code>
<code>auto s2 { vec | ranges::to&lt;set&lt;double&gt;&gt;() };</code>
<code>println("{:n}", s2);</code>
<code> </code>
<code><span class="color3">// Convert a vector of integers to a set of doubles, using from_range constructor.</span></code>
<code>set&lt;double&gt; s3 { from_range, vec };</code>
<code>println("{:n}", s3);</code>
<code> </code>
<code><span class="color3">// Lazily generate the integers from 10 to 14, divide these by 2,</span></code>
<code><span class="color3">// and store the result in a vector of doubles.</span></code>
<code>auto vec2 { views::iota(10, 15)</code>
<code>    | views::transform([](const auto&amp; v) { return v / 2.0; })</code>
<code>    | ranges::to&lt;vector&lt;double&gt;&gt;() };</code>
<code>println("{:n}", vec2);</code>
<code> </code>
<code><span class="color3">// Use views::split() and views::transform() to create a view</span></code>
<code><span class="color3">// containing individual words of a string, and then convert</span></code>
<code><span class="color3">// the resulting view to a vector of strings containing all the words.</span></code>
<code>string lorem { "Lorem ipsum dolor sit amet" };</code>
<code>auto words { lorem | views::split(' ')</code>
<code>    | views::transform([](const auto&amp; v) { return string { from_range, v }; })</code>
<code>    | ranges::to&lt;vector&gt;() };</code>
<code>println("{:n:?}", words);</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c17-code-0071"><code>11, 22, 33</code>
<code>11, 22, 33</code>
<code>11, 22, 33</code>
<code>5, 5.5, 6, 6.5, 7</code>
<code>"Lorem", "ipsum", "dolor", "sit", "amet"</code></pre>
      <p>
       C++23 also introduces a number of new member functions for Standard Library containers, providing for interoperability between containers and ranges. These member functions are of the form
       <code>
        <i>
         xyz
        </i>
        _range(…)
       </code>
       , where
       <i>
        <code>
         xyz
        </code>
       </i>
       can be
       <code>
        insert
       </code>
       ,
       <code>
        append
       </code>
       ,
       <code>
        prepend
       </code>
       ,
       <code>
        assign
       </code>
       ,
       <code>
        replace
       </code>
       ,
       <code>
        push
       </code>
       ,
       <code>
        push_front
       </code>
       ,
       <span aria-label="681" epub:type="pagebreak" id="Page_681" role="doc-pagebreak">
       </span>
       or
       <code>
        push_back
       </code>
       .
       <a href="c18.xhtml">
        Chapter 18
       </a>
       discusses all Standard Library containers in detail, but consult a Standard Library reference to learn exactly which member functions are supported by which container. Here is an example demonstrating the
       <code>
        append_range()
       </code>
       and
       <code>
        insert_range()
       </code>
       member functions of
       <code>
        vector
       </code>
       :
      </p>
      <pre id="c17-code-0072"><code>vector&lt;int&gt; vec3;</code>
<code>vec3.append_range(views::iota(10, 15));</code>
<code>println("{:n}", vec3);</code>
<code>vec3.insert_range(begin(vec3), views::iota(10, 15) | views::reverse);</code>
<code>println("{:n}", vec3);</code></pre>
      <p>
       The output is:
      </p>
      <pre id="c17-code-0073"><code>10, 11, 12, 13, 14</code>
<code>14, 13, 12, 11, 10, 10, 11, 12, 13, 14</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-194">
     <span id="c17-sec-0038">
     </span>
     <h2 id="head-2-194">
      SUMMARY
     </h2>
     <p id="c17-para-0244">
      This chapter explained the ideas behind iterators, which are an abstraction that allows you to navigate the elements of a container without the need to know the structure of the container. You have seen that output stream iterators can use standard output as a destination for iterator-based algorithms, and similarly that input stream iterators can use standard input as the source of data for algorithms. The chapter also discussed the insert-, reverse-, and move iterator adapters that can be used to adapt other iterators.
     </p>
     <p id="c17-para-0245">
      The last part of this chapter discussed the ranges library, part of the C++ Standard Library. It allows you to write more functional-style code, by specifying
      <i>
       what
      </i>
      you want to accomplish instead of
      <i>
       how
      </i>
      . You can construct pipelines consisting of a combination of operations applied to the elements of a range. Such pipelines are executed lazily; that is, they don't do anything until you iterate over the resulting view.
     </p>
    </section>
    <section aria-labelledby="head-2-195">
     <span id="c17-sec-0039">
     </span>
     <h2 id="head-2-195">
      EXERCISES
     </h2>
     <p id="c17-para-0246">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <code>
        <a href="http://www.wiley.com/go/proc++6e">
         www.wiley.com/go/proc++6e
        </a>
       </code>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c17-exsec-0001">
      </span>
      <ol class="none">
       <li id="c17-ex-0001">
        <b>
         Exercise 17-1:
        </b>
        Write a program that lazily constructs the sequence of elements 10-100, squares each number, removes all numbers dividable by five, and transforms the remaining values to strings using
        <code>
         std::to_string()
        </code>
        .
       </li>
       <li id="c17-ex-0002">
        <b>
         Exercise 17-2:
        </b>
        Write a program that creates a
        <code>
         vector
        </code>
        of
        <code>
         pair
        </code>
        s, where each
        <code>
         pair
        </code>
        contains an instance of the
        <code>
         Person
        </code>
        class introduced earlier in this chapter, and their age. Next, use the ranges library to construct a single pipeline that extracts all ages from all persons from the
        <code>
         vector
        </code>
        , and removes all ages below 12 and above 65. Finally, calculate the average of the remaining ages using the
        <code>
         sum()
        </code>
        algorithm from earlier in this chapter. As you'll pass a range to the
        <code>
         sum()
        </code>
        algorithm, you'll have to work with a common range.
       </li>
       <li id="c17-ex-0003">
        <span aria-label="682" epub:type="pagebreak" id="Page_682" role="doc-pagebreak">
        </span>
        <b>
         Exercise 17-3:
        </b>
        Building further on the solution for Exercise 17-2, add an implementation for
        <code>
         operator&lt;&lt;
        </code>
        for the
        <code>
         Person
        </code>
        class.
        <p class="listPara1" id="c17-para-0250">
         Next, create a pipeline to extract the
         <code>
          Person
         </code>
         of each
         <code>
          pair
         </code>
         from the
         <code>
          vector
         </code>
         of
         <code>
          pair
         </code>
         s, and only keep the first four
         <code>
          Person
         </code>
         s. Use the
         <code>
          myCopy()
         </code>
         algorithm introduced earlier in this chapter to print the names of those four persons to the standard output; one name per line.
        </p>
        <p class="listPara1" id="c17-para-0251">
         Finally, create a similar pipeline but one that additionally projects all filtered
         <code>
          Person
         </code>
         s to their last name. This time, use a single
         <code>
          println()
         </code>
         statement to print the last names to the standard output.
        </p>
       </li>
       <li id="c17-ex-0004">
        <b>
         Exercise 17-4:
        </b>
        Write a program that uses a range-based
        <code>
         for
        </code>
        loop and
        <code>
         ranges::istream_view()
        </code>
        to read integers from the standard input until a -1 is entered. Store the read integers in a
        <code>
         vector
        </code>
        , and afterward, print the content of the
        <code>
         vector
        </code>
        to the console to verify it contains the correct values.
       </li>
       <li id="c17-ex-0005">
        <b>
         Bonus exercise:
        </b>
        Can you find a couple of ways to change the solution for Exercise 17-4 to not use any explicit loops? Hint: one option could be to use the
        <code>
         std::ranges::copy()
        </code>
        algorithm to copy a range from a source to a target. It can be called with a range as first argument and an output iterator as the second argument.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c17_2" class="notesSet" role="doc-endnotes">
    <h2 id="c17_2">
     NOTE
    </h2>
    <ol class="notesList">
     <li class="noteEntry">
      <a href="#R_c17-note-0001" id="c17-note-0001" role="doc-backlink">
       1
      </a>
      C++23 slightly modifies the definition of a view. It allows for a view to own its elements, but only if it guarantees that it's either non-copyable, or copyable in constant time, O(1). Most views will be nonowning, so owning views are not further discussed in this text.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
