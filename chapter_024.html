<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   13Demystifying C++ I/O
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_023.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_025.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c13_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c13_1">
      <span aria-label="501" epub:type="pagebreak" id="Page_501" role="doc-pagebreak">
      </span>
      <span id="c13">
      </span>
      <span class="chapterNumber">
       13
      </span>
      <br/>
      <span class="chapterTitle">
       Demystifying C++ I/O
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c13-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c13-list-0001">
         <li id="c13-li-0001">
          The concept of streams
         </li>
         <li id="c13-li-0002">
          How to use streams for input and output of data
         </li>
         <li id="c13-li-0003">
          The available standard streams provided by the Standard Library
         </li>
         <li id="c13-li-0004">
          How to use the filesystem support library
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c13-fea-0001">
        </span>
        <h3 id="head-2-149">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c13-sec-0003">
        </span>
        <p id="c13-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <a href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c13-para-0004">
      A program's fundamental job is to accept input and produce output. A program that produces no output of any sort would not be very useful. All languages provide some mechanism for I/O, either as a built-in part of the language or through an OS-specific API. A good I/O system is both flexible and easy to use. Flexible I/O systems support input and output through a variety of devices, such as files and the user console. Files could be standard files but could also be data coming from a variety of sources such as Internet of Things (IoT) devices, web services, and more. It could be weather data from a weather device or stock values from a stockbroker web service. Flexible I/O systems also support reading and writing of different types of data. I/O is error-prone because data coming from a user can be incorrect or the underlying filesystem or other data source can be inaccessible. Thus, a good I/O system is also capable of handling error conditions.
     </p>
     <p id="c13-para-0005">
      If you are familiar with the C language, you have undoubtedly used
      <code>
       printf
      </code>
      (
      <code>
       )
      </code>
      and
      <code>
       scanf()
      </code>
      . As I/O mechanisms,
      <code>
       printf()
      </code>
      and
      <code>
       scanf()
      </code>
      are certainly flexible. Through escape codes and variable placeholders (similar to format specifiers and replacement fields for
      <code>
       std::format()
      </code>
      ,
      <span aria-label="502" epub:type="pagebreak" id="Page_502" role="doc-pagebreak">
      </span>
      <code>
       print()
      </code>
      , and
      <code>
       println()
      </code>
      as discussed in
      <a href="c02.xhtml">
       Chapter 2
      </a>
      , “Working with Strings and String Views”), they can be customized to read in specially formatted data or output any value that the formatting codes permit. Supported types are limited to integer/character values, floating-point values, and strings. However,
      <code>
       printf()
      </code>
      and
      <code>
       scanf()
      </code>
      falter on other measures of good I/O systems. They do not handle errors particularly well. For example, if you tell them to interpret a floating-point number as an integer, they will happily do so. Additionally, they are not flexible enough to handle custom data types, they are not type safe, and in an object-oriented language like C++, they are not at all object oriented.
     </p>
     <p id="c13-para-0006">
      C++ provides a more refined, more flexible, and object-oriented approach to I/O.
      <i>
       Streams
      </i>
      are encapsulated in classes that result in a user-friendly and safe solution. In this chapter, you will first learn what streams are and then learn how to use streams for data output and input. You will also learn how to use the stream mechanism to read from various sources and write to various destinations, such as the user console, files, and even strings. This chapter covers the most commonly used I/O features.
     </p>
     <p id="c13-para-0007">
      Almost all examples in this book use
      <code>
       print()
      </code>
      and
      <code>
       println()
      </code>
      to print text to the user console. An alternative is to use the I/O streaming functionality discussed in this chapter. I recommend using
      <code>
       print()
      </code>
      and
      <code>
       println()
      </code>
      instead of streaming to standard output, as the former is easier to read, more compact, and more performant. However, this chapter discusses I/O streaming in detail, as it's still important to know how it works in C++ because you'll undoubtedly have to work with code that uses I/O streaming.
     </p>
     <p id="c13-para-0008">
      The last part of this chapter discusses the filesystem support library provided by the C++ Standard Library. This library allows you to work with paths, directories, and files, and it nicely complements the mechanisms provided for I/O by the streams.
     </p>
    </section>
    <section aria-labelledby="head-2-150">
     <span id="c13-sec-0004">
     </span>
     <h2 id="head-2-150">
      USING STREAMS
     </h2>
     <p id="c13-para-0009">
      The stream metaphor takes a bit of getting used to. At first, streams may seem more complex than traditional C-style I/O, such as
      <code>
       printf()
      </code>
      . In reality, they seem complicated initially only because there is a deeper metaphor behind streams than there is behind
      <code>
       printf()
      </code>
      . Don't worry, though: after a few examples, everything will be clear.
     </p>
     <section>
      <span id="c13-sec-0005">
      </span>
      <h3 id="head-3-287">
       What Is a Stream, Anyway?
      </h3>
      <p id="c13-para-0010">
       <a href="c01.xhtml">
        Chapter 1
       </a>
       , “A Crash Course in C++ and the Standard Library,” compares the
       <code>
        cout
       </code>
       stream to a laundry chute for data. You throw some variables down the stream, and they are written to the user's screen, or
       <i>
        console
       </i>
       . More generally, all streams can be viewed as data chutes. Streams vary in their direction and their associated source or destination. For example, the
       <code>
        cout
       </code>
       stream that you are already familiar with is an output stream, so its direction is “out.” It writes data to the console, so its associated destination is “console.” The
       <code>
        c
       </code>
       in
       <code>
        cout
       </code>
       does not stand for “console” as you might expect but stands for “character” as it's a character-based stream. There is another standard stream called
       <code>
        cin
       </code>
       that accepts input from the user. Its direction is “in,” and its associated source is “console.” As with
       <code>
        cout
       </code>
       , the
       <code>
        c
       </code>
       in
       <code>
        cin
       </code>
       stands for “character.” Both
       <code>
        cout
       </code>
       and
       <code>
        cin
       </code>
       are predefined instances of streams available in the
       <code>
        std
       </code>
       namespace. The following table gives a brief description of all predefined streams defined in
       <code>
        &lt;iostream&gt;
       </code>
       .
      </p>
      <p id="c13-para-0011">
       <span aria-label="503" epub:type="pagebreak" id="Page_503" role="doc-pagebreak">
       </span>
       Streams can be
       <i>
        buffered
       </i>
       or
       <i>
        unbuffered
       </i>
       . The difference between them is that a buffered stream does not immediately send the data to the destination. Instead, it buffers, that is collects, incoming data and then sends it in blocks. An unbuffered stream, on the other hand, immediately sends the data to the destination. Buffering is usually done to improve performance, as certain destinations, such as files, perform better when writing bigger blocks at once. Note that you can always force a buffered stream to send all its currently buffered data to the destination by
       <i>
        flushing
       </i>
       its buffer using the
       <code>
        flush()
       </code>
       member function. Buffering and flushing is discussed in a bit more detail later in this chapter.
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          STREAM
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           cin
          </span>
         </td>
         <td class="left bgcolor3">
          An input stream, reads data from the “input console”
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           cout
          </span>
         </td>
         <td class="left bgcolor3">
          A buffered output stream, writes data to the “output console”
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           cerr
          </span>
         </td>
         <td class="left bgcolor3">
          An unbuffered output stream, writes data to the “error console,” which is often the same as the “output console”
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           clog
          </span>
         </td>
         <td class="left bgcolor3">
          A buffered version of
          <span class="forecolor1">
           cerr
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       Remember from
       <a href="c01.xhtml">
        Chapter 1
       </a>
       that
       <code>
        std::print()
       </code>
       and
       <code>
        println()
       </code>
       by default print to
       <code>
        cout
       </code>
       but that you can pass a stream as first argument to these functions if you want to print to a different stream, for example:
      </p>
      <pre id="c13-code-0001"><code>println(<b>cerr,</b> "This is an error printed to cerr.");</code></pre>
      <p>
       There are also wide-character,
       <code>
        wchar_t
       </code>
       versions available of these streams that have names starting with
       <code>
        w
       </code>
       :
       <code>
        wcin
       </code>
       ,
       <code>
        wcout
       </code>
       ,
       <code>
        wcerr
       </code>
       , and
       <code>
        wclog
       </code>
       . Wide characters can be used to work with languages that have more characters than, for example, English, such as Chinese. Wide characters are discussed in
       <a href="c21.xhtml">
        Chapter 21
       </a>
       , “String Localization and Regular Expressions.”
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c13-para-0015">
          <b>
           NOTE
          </b>
          <i>
           Every input stream has an associated source. Every output stream has an associated destination
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       Another important aspect of streams is that they include data but also have a
       <i>
        current position
       </i>
       . The current position is the position in the stream where the next read or write operation will take place.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c13-para-0017">
          <b>
           NOTE
          </b>
          <i>
           Graphical user interface applications normally do not have a console; that is, if you write something to
          </i>
          <code>
           cout
          </code>
          <i>
           , the user will not see it. If you are writing a library, you should never assume the existence of
          </i>
          <code>
           cout
          </code>
          <i>
           ,
          </i>
          <code>
           cin
          </code>
          <i>
           ,
          </i>
          <code>
           cerr
          </code>
          <i>
           , or
          </i>
          <code>
           clog
          </code>
          <i>
           because you never know whether your library will be used in a console or a GUI application.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <span aria-label="504" epub:type="pagebreak" id="Page_504" role="doc-pagebreak">
     </span>
     <section>
      <span id="c13-sec-0008">
      </span>
      <h3 id="head-3-288">
       Stream Sources and Destinations
      </h3>
      <p id="c13-para-0018">
       Streams as a concept can be applied to any object that accepts data or emits data. You could write a stream-based network class or stream-based access to a Musical Instrument Digital Interface (MIDI) instrument. In C++, there are four common sources and destinations for streams: consoles, files, strings, and fixed buffer arrays. Fixed buffer array support is introduced with C++23.
      </p>
      <p id="c13-para-0019">
       You have already seen many examples of user, or console, streams. Console input streams make programs interactive by allowing input from the user at run time. Console output streams provide feedback to the user and output results.
      </p>
      <p id="c13-para-0020">
       File streams, as the name implies, read data from and write data to a filesystem. File input streams are useful for reading configuration data and saved files or for batch processing file-based data. File output streams are useful for saving state and providing output. If you are familiar with C-style input and output, then file streams subsume the functionality of the C functions
       <code>
        fprintf()
       </code>
       ,
       <code>
        fwrite()
       </code>
       , and
       <code>
        fputs()
       </code>
       for output, and
       <code>
        fscanf()
       </code>
       ,
       <code>
        fread()
       </code>
       , and
       <code>
        fgets()
       </code>
       for input. As these C-style functions are not recommended in C++, they are not further discussed.
      </p>
      <p id="c13-para-0021">
       String streams are an application of the stream metaphor to the string type. With a string stream, you can treat character data just as you would treat any other stream. For the most part, this is merely a handy syntax for functionality that could be handled through member functions on the
       <code>
        string
       </code>
       class. However, using stream syntax provides opportunities for optimization and can be far more convenient and more efficient than direct use of the
       <code>
        string
       </code>
       class. String streams subsume the functionality of
       <code>
        sprintf()
       </code>
       ,
       <code>
        sprintf_s()
       </code>
       ,
       <code>
        sscanf()
       </code>
       , and other forms of C-style string-formatting functions, not further discussed in this C++ book.
      </p>
      <p id="c13-para-0022">
       The streams working with fixed buffer arrays allow you to use the stream metaphor on any block of memory, independently of how memory for that buffer was allocated.
      </p>
      <p id="c13-para-0023">
       The rest of this section deals with console streams (
       <code>
        cin
       </code>
       and
       <code>
        cout
       </code>
       ). Examples of file, string, and fixed buffer array streams are provided later in this chapter. Other types of streams, such as printer output or network I/O, are often platform dependent, so they are not covered in this book.
      </p>
     </section>
     <section>
      <span id="c13-sec-0009">
      </span>
      <h3 id="head-3-289">
       Output with Streams
      </h3>
      <p id="c13-para-0024">
       Output using streams is introduced in
       <a href="c01.xhtml">
        Chapter 1
       </a>
       . This section briefly revisits some of the basics and introduces material that is more advanced.
      </p>
      <section>
       <span id="c13-sec-0010">
       </span>
       <h4 id="head-4-233">
        Output Basics
       </h4>
       <p id="c13-para-0025">
        Output streams are defined in &lt;
        <code>
         ostream
        </code>
        &gt;. There is also &lt;
        <code>
         iostream
        </code>
        &gt;, which in turn includes the functionality for both input streams and output streams. &lt;
        <code>
         iostream
        </code>
        &gt; also declares all predefined stream instances:
        <code>
         cout
        </code>
        ,
        <code>
         cin
        </code>
        ,
        <code>
         cerr
        </code>
        ,
        <code>
         clog
        </code>
        , and the wide versions.
       </p>
       <p>
        The
        <code>
         &lt;&lt;
        </code>
        operator is the simplest way to use output streams. C++ basic types, such as
        <code>
         int
        </code>
        s, pointers,
        <code>
         double
        </code>
        s, and characters, can be output using
        <code>
         &lt;&lt;
        </code>
        . In addition, the C++
        <code>
         string
        </code>
        class is compatible with
        <code>
         &lt;&lt;
        </code>
        , and C-style strings are properly output as well. The following are some examples of using
        <code>
         &lt;&lt;
        </code>
        :
       </p>
       <pre id="c13-code-0002"><code>int i { 7 };</code>
<code>cout &lt;&lt; i &lt;&lt; endl;</code>
<code> </code>
<span aria-label="505" epub:type="pagebreak" id="Page_505" role="doc-pagebreak"></span><code>char ch { 'a' };</code>
<code>cout &lt;&lt; ch &lt;&lt; endl;</code>
<code> </code>
<code>string myString { "Hello World." };</code>
<code>cout &lt;&lt; myString &lt;&lt; endl;</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c13-code-0003"><code>7</code>
<code>a</code>
<code>Hello World.</code></pre>
       <p>
        The
        <code>
         cout
        </code>
        stream is the built-in stream for writing to the console, or
        <i>
         standard output
        </i>
        . You can “chain” uses of
        <code>
         &lt;&lt;
        </code>
        together to output multiple pieces of data. This is because
        <code>
         operator&lt;&lt;
        </code>
        returns a reference to the stream as its result, so you can immediately use
        <code>
         &lt;&lt;
        </code>
        again on the same stream. Here is an example:
       </p>
       <pre id="c13-code-0004"><code>int j { 11 };</code>
<code>cout &lt;&lt; "The value of j is " &lt;&lt; j &lt;&lt; "!" &lt;&lt; endl;</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c13-code-0005"><code>The value of j is 11!</code></pre>
       <p>
        C++ streams correctly parse C-style escape sequences, such as strings that contain
        <code>
         \n
        </code>
        . You can also use
        <code>
         std::endl
        </code>
        to start a new line. The difference between using
        <code>
         \n
        </code>
        and
        <code>
         endl
        </code>
        is that
        <code>
         \n
        </code>
        just starts a new line while
        <code>
         endl
        </code>
        also flushes the buffer. Watch out with
        <code>
         endl
        </code>
        because too many flushes might hurt performance. The following example uses
        <code>
         endl
        </code>
        to output and flush several lines of text with just one line of code:
       </p>
       <pre id="c13-code-0006"><code>cout &lt;&lt; "Line 1" &lt;&lt; endl &lt;&lt; "Line 2" &lt;&lt; endl &lt;&lt; "Line 3" &lt;&lt; endl;</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c13-code-0007"><code>Line 1</code>
<code>Line 2</code>
<code>Line 3</code></pre>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c13-para-0033">
           <b>
            WARNING
           </b>
           <code>
            endl
           </code>
           <i>
            flushes the destination buffer, so use it judiciously in performance critical code, such as tight loops.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c13-sec-0012">
       </span>
       <h4 id="head-4-234">
        Member Functions of Output Streams
       </h4>
       <p id="c13-para-0034">
        The
        <code>
         &lt;&lt;
        </code>
        operator is, without a doubt, the most useful part of output streams. However, there is additional functionality to be explored. If you look through the contents of
        <code>
         &lt;ostream&gt;
        </code>
        , you'll see many lines of overloaded definitions of the
        <code>
         &lt;&lt;
        </code>
        operator to support outputting all kinds of different data types. You'll also find some useful public member functions.
       </p>
       <section>
        <span id="c13-sec-0013">
        </span>
        <h5 id="head-5-84">
         put() and write()
        </h5>
        <p>
         <code>
          put()
         </code>
         and
         <code>
          write()
         </code>
         are
         <i>
          raw output member functions
         </i>
         . Instead of taking an object or variable that has some defined behavior for output,
         <code>
          put()
         </code>
         accepts a single character, while
         <code>
          write()
         </code>
         accepts a character array. The data passed to these member functions is output as is, without any special formatting
         <span aria-label="506" epub:type="pagebreak" id="Page_506" role="doc-pagebreak">
         </span>
         or processing. For example, the following code snippet shows how to output a C-style string to the console without using the
         <code>
          &lt;&lt;
         </code>
         operator:
        </p>
        <pre id="c13-code-0008"><code>const char* test { "hello there" };</code>
<code>cout.write(test, strlen(test));</code></pre>
        <p>
         The next snippet shows how to write a single character to the console by using the
         <code>
          put()
         </code>
         member function:
        </p>
        <pre id="c13-code-0009"><code>cout.put('a');</code></pre>
       </section>
       <section>
        <span id="c13-sec-0014">
        </span>
        <h5 id="head-5-85">
         flush()
        </h5>
        <p>
         When you write to an output stream, the stream does not necessarily write the data to its destination right away. Most output streams
         <i>
          buffer
         </i>
         , or accumulate, data instead of writing it out as soon as it comes in. This is usually done to improve performance. Certain stream destinations, such as files, are much more performant if data is written in larger blocks, instead of, for example, character by character. The stream
         <i>
          flushes
         </i>
         , or writes out, the accumulated data, when one of the following conditions occurs:
        </p>
        <ul class="check1" id="c13-list-0002">
         <li id="c13-li-0005">
          An
          <code>
           endl
          </code>
          manipulator is encountered.
         </li>
         <li id="c13-li-0006">
          The stream goes out of scope and is destructed.
         </li>
         <li id="c13-li-0007">
          The stream buffer is full.
         </li>
         <li id="c13-li-0008">
          You explicitly tell the stream to flush its buffer.
         </li>
         <li id="c13-li-0009">
          Input is requested from a corresponding input stream (that is, when you make use of
          <code>
           cin
          </code>
          for input,
          <code>
           cout
          </code>
          will flush). In the section “
          <a href="#c13-sec-0036">
           File Streams
          </a>
          ,” you will learn how to establish this type of link.
         </li>
        </ul>
        <p>
         One way to explicitly tell a stream to flush is to call its
         <code>
          flush()
         </code>
         member function, as in the following code:
        </p>
        <pre id="c13-code-0010"><code>cout &lt;&lt; "abc";</code>
<code>cout.flush();    <span class="color3">// abc is written to the console.</span></code>
<code>cout &lt;&lt; "def";</code>
<code>cout &lt;&lt; endl;    <span class="color3">// def is written to the console.</span></code></pre>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c13-para-0040">
            <b>
             NOTE
            </b>
            <i>
             Not all output streams are buffered. The
            </i>
            <code>
             cerr
            </code>
            <i>
             stream, for example, does not buffer its output.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section>
       <span id="c13-sec-0016">
       </span>
       <h4 id="head-4-235">
        Handling Output Errors
       </h4>
       <p id="c13-para-0041">
        Output errors can arise in a variety of situations. Perhaps you are trying to open a non-existing file. Maybe a disk error has prevented a write operation from succeeding, for example, because the disk is full. None of the streams' code you have seen up until this point has considered these possibilities, mainly for brevity. However, it is vital that you address any error conditions that occur.
       </p>
       <p>
        <span aria-label="507" epub:type="pagebreak" id="Page_507" role="doc-pagebreak">
        </span>
        When a stream is in its normal usable state, it is said to be “good.” The
        <code>
         good()
        </code>
        member function can be called directly on a stream to determine whether the stream is currently good:
       </p>
       <pre id="c13-code-0011"><code>if (cout.good()) {</code>
<code>    cout &lt;&lt; "All good" &lt;&lt; endl;</code>
<code>}</code></pre>
       <p>
        <code>
         good()
        </code>
        provides an easy way to obtain basic information about the validity of the stream, but it does not tell you why the stream is unusable. There is a member function called
        <code>
         bad()
        </code>
        that provides a bit more information. If
        <code>
         bad()
        </code>
        returns
        <code>
         true
        </code>
        , it means that a fatal error has occurred (as opposed to any nonfatal condition like end-of-file,
        <code>
         eof()
        </code>
        ). Another member function,
        <code>
         fail()
        </code>
        , returns
        <code>
         true
        </code>
        if the most recent operation has failed; however, it doesn't say anything about the next operation, which can either succeed or fail as well. For example, after calling
        <code>
         flush()
        </code>
        on an output stream, you could call
        <code>
         fail()
        </code>
        to make sure the flush was successful:
       </p>
       <pre id="c13-code-0012"><code>cout.flush();</code>
<code>if (cout.fail()) {</code>
<code>    cerr &lt;&lt; "Unable to flush to standard out" &lt;&lt; endl;</code>
<code>}</code></pre>
       <p>
        Streams have a conversion operator to convert to type
        <code>
         bool
        </code>
        . This conversion operator returns the same as calling
        <code>
         !fail()
        </code>
        . So, the previous code snippet can be rewritten as follows:
       </p>
       <pre id="c13-code-0013"><code>cout.flush();</code>
<code><b>if (!cout) {</b></code>
<code>    cerr &lt;&lt; "Unable to flush to standard out" &lt;&lt; endl;</code>
<code>}</code></pre>
       <p id="c13-para-0045">
        Important to know is that both
        <code>
         good()
        </code>
        and
        <code>
         fail()
        </code>
        return
        <code>
         false
        </code>
        if the end-of-file is reached. The relation is as follows:
        <code>
         good() == (!fail() &amp;&amp; !eof())
        </code>
        .
       </p>
       <p>
        You can also tell the streams to throw exceptions when a failure occurs. You then write a
        <code>
         catch
        </code>
        handler to catch
        <code>
         ios_base::failure
        </code>
        exceptions, on which you can use the
        <code>
         what()
        </code>
        member function to get a description of the error, and the
        <code>
         code()
        </code>
        member function to get the error code. However, whether or not you get useful information depends on the Standard Library implementation that you use.
       </p>
       <pre id="c13-code-0014"><code>cout.exceptions(ios::failbit | ios::badbit | ios::eofbit);</code>
<code>try {</code>
<code>    cout &lt;&lt; "Hello World." &lt;&lt; endl;</code>
<code>} catch (const ios_base::failure&amp; ex) {</code>
<code>    cerr &lt;&lt; "Caught exception: " &lt;&lt; ex.what()</code>
<code>         &lt;&lt; ", error code = " &lt;&lt; ex.code() &lt;&lt; endl;</code>
<code>}</code></pre>
       <p>
        To reset the error state of a stream, use
        <code>
         clear()
        </code>
        :
       </p>
       <pre id="c13-code-0015"><code>cout.clear();</code></pre>
       <p id="c13-para-0048">
        Error checking is performed less frequently for console output streams than for file output or input streams. The member functions discussed here apply for other types of streams as well and are revisited later as each type is discussed.
       </p>
      </section>
      <span aria-label="508" epub:type="pagebreak" id="Page_508" role="doc-pagebreak">
      </span>
      <section>
       <span id="c13-sec-0017">
       </span>
       <h4 id="head-4-236">
        Output Manipulators
       </h4>
       <p id="c13-para-0049">
        One of the unusual features of streams is that you can throw more than just data down the chute. C++ streams also recognize
        <i>
         manipulators
        </i>
        , objects that make a change to the behavior of the stream instead of, or in addition to, providing data for the stream to work with.
       </p>
       <p>
        You have already seen one manipulator:
        <code>
         endl
        </code>
        . The
        <code>
         endl
        </code>
        manipulator encapsulates data and behavior. It tells the stream to output an end-of-line sequence and to flush its buffer. The following is a non-exhaustive list of some other useful manipulators, many of which are defined in
        <code>
         &lt;ios&gt;
        </code>
        and
        <code>
         &lt;iomanip&gt;
        </code>
        . An example after this list shows how to use them:
       </p>
       <ul class="check1" id="c13-list-0003">
        <li id="c13-li-0010">
         <code>
          boolalpha
         </code>
         and
         <code>
          noboolalpha
         </code>
         : Tells the stream to output
         <code>
          bool
         </code>
         values as
         <i>
          true
         </i>
         and
         <i>
          false
         </i>
         (
         <code>
          boolalpha
         </code>
         ) or
         <i>
          1
         </i>
         and
         <i>
          0
         </i>
         (
         <code>
          noboolalpha
         </code>
         ). The default is
         <code>
          noboolalpha
         </code>
         .
        </li>
        <li id="c13-li-0011">
         <code>
          hex
         </code>
         ,
         <code>
          oct
         </code>
         , and
         <code>
          dec
         </code>
         : Outputs numbers in hexadecimal, octal, and base 10, respectively.
        </li>
        <li id="c13-li-0012">
         <code>
          fixed
         </code>
         ,
         <code>
          scientific
         </code>
         , and
         <code>
          defaultfloat
         </code>
         : Outputs fractional numbers using fixed, scientific, or default formatting, respectively.
        </li>
        <li id="c13-li-0013">
         <code>
          setprecision
         </code>
         : Sets the number of decimal places that are output for fractional numbers using fixed or scientific formatting, or else the total number of digits to output. This is a parameterized manipulator (meaning that it takes an argument).
        </li>
        <li id="c13-li-0014">
         <code>
          setw
         </code>
         : Sets the field width for outputting data. This is a parameterized manipulator.
        </li>
        <li id="c13-li-0015">
         <code>
          setfill
         </code>
         : Sets a character as the new fill character for the stream. The fill character pads output according to the width set by
         <code>
          setw
         </code>
         . This is a parameterized manipulator.
        </li>
        <li id="c13-li-0016">
         <code>
          showpoint
         </code>
         and
         <code>
          noshowpoint
         </code>
         : Forces the stream to always or never show the decimal point for floating-point numbers with no fractional part.
        </li>
        <li id="c13-li-0017">
         <code>
          put_money
         </code>
         : A parameterized manipulator that writes a formatted monetary value to a stream.
        </li>
        <li id="c13-li-0018">
         <code>
          put_time
         </code>
         : A parameterized manipulator that writes a formatted time to a stream.
        </li>
        <li id="c13-li-0019">
         <code>
          quoted
         </code>
         : A parameterized manipulator that encloses a given string with quotes and escapes embedded quotes.
        </li>
       </ul>
       <p>
        All of these manipulators stay in effect for subsequent output to the stream until they are reset, except
        <code>
         setw
        </code>
        , which is active for only the next single output. The following example uses several of these manipulators to customize its output:
       </p>
       <pre id="c13-code-0016"><code><span class="color3">// Boolean values</span></code>
<code>bool myBool { true };</code>
<code>cout &lt;&lt; "This is the default: " &lt;&lt; myBool &lt;&lt; endl;</code>
<code>cout &lt;&lt; "This should be true: " &lt;&lt; boolalpha &lt;&lt; myBool &lt;&lt; endl;</code>
<code>cout &lt;&lt; "This should be 1: " &lt;&lt; noboolalpha &lt;&lt; myBool &lt;&lt; endl;</code>
<code> </code>
<code><span class="color3">// Simulate println-style "{:6}" with streams</span></code>
<code>int i { 123 };</code>
<code>println("This should be '   123': {:6}", i);</code>
<code>cout &lt;&lt; "This should be '   123': " &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; endl;</code>
<code> </code>
<span aria-label="509" epub:type="pagebreak" id="Page_509" role="doc-pagebreak"></span><code><span class="color3">// Simulate println-style "{:0&gt;6}" with streams</span></code>
<code>println("This should be '000123': {:0&gt;6}", i);</code>
<code>cout &lt;&lt; "This should be '000123': " &lt;&lt; setfill('0') &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; endl;</code>
<code> </code>
<code><span class="color3">// Fill with *</span></code>
<code>cout &lt;&lt; "This should be '***123': " &lt;&lt; setfill('*') &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; endl;</code>
<code><span class="color3">// Reset fill character</span></code>
<code>cout &lt;&lt; setfill(' ');</code>
<code> </code>
<code><span class="color3">// Floating-point values</span></code>
<code>double dbl { 1.452 };</code>
<code>double dbl2 { 5 };</code>
<code>cout &lt;&lt; "This should be ' 5': " &lt;&lt; setw(2) &lt;&lt; noshowpoint &lt;&lt; dbl2 &lt;&lt; endl;</code>
<code>cout &lt;&lt; "This should be @@1.452: " &lt;&lt; setw(7) &lt;&lt; setfill('@') &lt;&lt; dbl &lt;&lt; endl;</code>
<code><span class="color3">// Reset fill character</span></code>
<code>cout &lt;&lt; setfill(' ');</code>
<code> </code>
<code><span class="color3">// Instructs cout to start formatting numbers according to your location.</span></code>
<code><span class="color3">// <a href="c21.xhtml">Chapter 21</a> explains the details of the imbue() call and the locale object.</span></code>
<code>cout.imbue(locale { "" });</code>
<code> </code>
<code><span class="color3">// Format numbers according to your location</span></code>
<code>cout &lt;&lt; "This is 1234567 formatted according to your location: " &lt;&lt; 1234567</code>
<code>     &lt;&lt; endl;</code>
<code> </code>
<code><span class="color3">// Monetary value. What exactly a monetary value means depends on your</span></code>
<code><span class="color3">// location. For example, in the USA, a monetary value of 120000 means 120000</span></code>
<code><span class="color3">// dollar cents, which is 1200.00 dollars.</span></code>
<code>cout &lt;&lt; "This should be a monetary value of 120000, "</code>
<code>     &lt;&lt; "formatted according to your location: "</code>
<code>     &lt;&lt; put_money("120000") &lt;&lt; endl;</code>
<code> </code>
<code><span class="color3">// Date and time</span></code>
<code>time_t t_t { time(nullptr) };     <span class="color3">// Get current system time.</span></code>
<code>tm t { *localtime(&amp;t_t) };        <span class="color3">// Convert to local time.</span></code>
<code>cout &lt;&lt; "This should be the current date and time "</code>
<code>     &lt;&lt; "formatted according to your location: "</code>
<code>     &lt;&lt; put_time(&amp;t, "%c") &lt;&lt; endl;</code>
<code> </code>
<code><span class="color3">// Quoted string</span></code>
<code>cout &lt;&lt; "This should be: \"Quoted string with \\\"embedded quotes\\\".\": "</code>
<code>     &lt;&lt; quoted("Quoted string with \"embedded quotes\".") &lt;&lt; endl;</code></pre>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c13-para-0053">
           <b>
            NOTE
           </b>
           <i>
            With Microsoft Visual C++, this example might give you a security-related error or warning on the call to
           </i>
           <code>
            localtime()
           </code>
           <i>
            . You can either switch to using
           </i>
           <code>
            localtime_s()
           </code>
           <i>
            or temporarily disable this warning using a
           </i>
           <code>
            #pragma
           </code>
           <i>
            . See the downloadable source code archive
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p>
        If you don't care for the concept of manipulators, you can usually get by without them. Streams provide much of the same functionality through equivalent member functions like
        <code>
         precision()
        </code>
        . For example, take the following line:
       </p>
       <pre id="c13-code-0017"><code>cout &lt;&lt; "This should be '1.2346': " &lt;&lt; setprecision(5) &lt;&lt; 1.23456789 &lt;&lt; endl;</code></pre>
       <p>
        <span aria-label="510" epub:type="pagebreak" id="Page_510" role="doc-pagebreak">
        </span>
        This can be converted to use a member function call as follows. The advantage of the member function calls is that they return the previous value, allowing you to restore it, if needed.
       </p>
       <pre id="c13-code-0018"><code>cout.precision(5);</code>
<code>cout &lt;&lt; "This should be '1.2346': " &lt;&lt; 1.23456789 &lt;&lt; endl;</code></pre>
       <p id="c13-para-0056">
        For a detailed description of all stream member functions and manipulators, consult your favorite Standard Library Reference.
       </p>
      </section>
     </section>
     <section>
      <span id="c13-sec-0019">
      </span>
      <h3 id="head-3-290">
       Input with Streams
      </h3>
      <p id="c13-para-0057">
       Input streams provide a simple way to read in structured or unstructured data. In this section, the techniques for input are discussed within the context of
       <code>
        cin
       </code>
       , the console input stream.
      </p>
      <section>
       <span id="c13-sec-0020">
       </span>
       <h4 id="head-4-237">
        Input Basics
       </h4>
       <p>
        There are two easy ways to read data by using an input stream. The first is an analog of the
        <code>
         &lt;&lt;
        </code>
        operator that outputs data to an output stream. The corresponding operator for reading data is
        <code>
         &gt;&gt;
        </code>
        . When you use
        <code>
         &gt;&gt;
        </code>
        to read data from an input stream, the variable you provide is the storage for the received value. For example, the following program reads one word from the user and puts it into a string. Then the string is output back to the console:
       </p>
       <pre id="c13-code-0019"><code>string userInput;</code>
<code>cin &gt;&gt; userInput;</code>
<code>println("User input was {}.", userInput);</code></pre>
       <p>
        By default, the
        <code>
         &gt;&gt;
        </code>
        operator tokenizes values according to whitespace. For example, if a user runs the previous program and enters
        <code>
         hello there
        </code>
        as input, only the characters up to the first whitespace character (the space character in this instance) are captured into the
        <code>
         userInput
        </code>
        variable. The output would be as follows:
       </p>
       <pre id="c13-code-0020"><code>User input was hello.</code></pre>
       <p>
        One solution to include whitespace in the input is to use
        <code>
         get()
        </code>
        , which is discussed later in this chapter.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c13-para-0061">
           <b>
            NOTE
           </b>
           <i>
            Whitespace characters in C++ are space (
            <code>
             <i>
              '
             </i>
             '
            </code>
            ), form feed
           </i>
           (
           <code>
            '\f'
           </code>
           <i>
            ), line feed (
           </i>
           <code>
            '\n'
           </code>
           <i>
            ), carriage return (
           </i>
           <code>
            '\r'
           </code>
           <i>
            ), horizontal tab (
           </i>
           <code>
            '\t'
           </code>
           <i>
            ), and vertical tab (
           </i>
           <code>
            '\v'
           </code>
           <i>
            ).
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p>
        The
        <code>
         &gt;&gt;
        </code>
        operator works with different variable types, just like the
        <code>
         &lt;&lt;
        </code>
        operator. For example, to read an integer, the code differs only in the type of the variable:
       </p>
       <pre id="c13-code-0021"><code><b>int userInput;</b></code>
<code>cin &gt;&gt; userInput;</code>
<code>println("User input was {}.", userInput);</code></pre>
       <p>
        You can use input streams to read in multiple values, mixing and matching types as necessary. For example, the following function, an excerpt from a restaurant reservation system, asks the user for a last name and the number of people in their party:
       </p>
       <pre id="c13-code-0022"><code>void getReservationData()</code>
<code>{</code>
<span aria-label="511" epub:type="pagebreak" id="Page_511" role="doc-pagebreak"></span><code>    string guestName;</code>
<code>    int partySize;</code>
<code>    print("Name and number of guests: ");</code>
<code>    cin &gt;&gt; guestName &gt;&gt; partySize;</code>
<code>    println("Thank you, {}.", guestName);</code>
<code>    if (partySize &gt; 10) {</code>
<code>        println("An extra gratuity will apply.");</code>
<code>    }</code>
<code>}</code></pre>
       <p>
        Remember that the
        <code>
         &gt;&gt;
        </code>
        operator tokenizes values according to whitespace, so
        <code>
         getReservationData()
        </code>
        does not allow you to enter a name with whitespace. A solution using
        <code>
         unget()
        </code>
        is discussed later in this chapter. Note also that the first use of
        <code>
         cout
        </code>
        does not explicitly flush the buffer using
        <code>
         endl
        </code>
        or
        <code>
         flush()
        </code>
        , but still, the text will be written to the console because the use of
        <code>
         cin
        </code>
        immediately flushes the
        <code>
         cout
        </code>
        buffer; they are linked together in this way.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c13-para-0065">
           <b>
            NOTE
           </b>
           <i>
            If you get confused between
            <code>
             &lt;&lt;
            </code>
            and
            <code>
             &gt;&gt;
            </code>
            , just think of the angles as pointing toward their destination. In an output stream,
            <code>
             &lt;&lt;
            </code>
            points toward the stream itself because data is being sent to the stream. In an input stream,
            <code>
             &gt;&gt;
            </code>
            points toward the variables because data is being stored
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c13-sec-0023">
       </span>
       <h4 id="head-4-238">
        Handling Input Errors
       </h4>
       <p>
        Input streams have a number of member functions to detect unusual circumstances. Most of the error conditions related to input streams occur when there is no data available to read. For example, the end of the stream (referred to as
        <i>
         end-of-file
        </i>
        , even for non–file streams) may have been reached. The most common way of querying the state of an input stream is to access it within a conditional statement. For example, the following loop keeps looping as long as
        <code>
         cin
        </code>
        remains in a good state. This pattern takes advantage of the fact that evaluating an input stream within a conditional context results in
        <code>
         true
        </code>
        only if the stream is not in any error state. Encountering an error causes the stream to evaluate to
        <code>
         false
        </code>
        . The underlying details of the conversion operations required to implement such behavior are explained in
        <a href="c15.xhtml">
         Chapter 15
        </a>
        , “Overloading C++ Operators.”
       </p>
       <pre id="c13-code-0023"><code>while (cin) { … }</code></pre>
       <p>
        You can input data at the same time:
       </p>
       <pre id="c13-code-0024"><code>while (cin &gt;&gt; ch) { … }</code></pre>
       <p id="c13-para-0068">
        The
        <code>
         good()
        </code>
        ,
        <code>
         bad()
        </code>
        , and
        <code>
         fail()
        </code>
        member functions can be called on input streams, just as on output streams. There is also an
        <code>
         eof()
        </code>
        member function that returns
        <code>
         true
        </code>
        if the stream has reached its end. Similar as for output streams, both
        <code>
         good()
        </code>
        and
        <code>
         fail()
        </code>
        return
        <code>
         false
        </code>
        if the end-of-file is reached. The relation is again as follows:
        <code>
         good() == (!fail() &amp;&amp; !eof())
        </code>
        .
       </p>
       <p id="c13-para-0069">
        You should get into the habit of checking the stream state after reading data so that you can recover from bad input.
       </p>
       <p>
        The following program shows a common pattern for reading data from a stream and handling errors. The program reads numbers from standard input and displays their sum once end-of-file is reached. Note that in command-line environments, the end-of-file is indicated by the user typing a
        <span aria-label="512" epub:type="pagebreak" id="Page_512" role="doc-pagebreak">
        </span>
        particular character. In Unix and Linux, it is
        <code>
         Control+D
        </code>
        ; in Windows it is
        <code>
         Control+Z
        </code>
        , both followed by
        <code>
         Enter
        </code>
        . The exact character is operating-system dependent, so you will need to know what your operating system requires.
       </p>
       <pre id="c13-code-0025"><code>println("Enter numbers on separate lines to add.");</code>
<code>println("Use Control+D followed by Enter to finish (Control+Z in Windows).");</code>
<code>int sum { 0 };</code>
<code> </code>
<code>if (!cin.good()) {</code>
<code>    println(cerr, "Standard input is in a bad state!");</code>
<code>    return 1;</code>
<code>}</code>
<code> </code>
<code>while (!cin.bad()) {</code>
<code>    int number;</code>
<code>    cin &gt;&gt; number;</code>
<code>    if (cin.good()) {</code>
<code>        sum += number;</code>
<code>    } else if (cin.eof()) {</code>
<code>        break; <span class="color3">// Reached end-of-file.</span></code>
<code>    } else if (cin.fail()) {</code>
<code>        <span class="color3">// Failure!</span></code>
<code>        cin.clear(); <span class="color3">// Clear the failure state.</span></code>
<code>        string badToken;</code>
<code>        cin &gt;&gt; badToken; <span class="color3">// Consume the bad input.</span></code>
<code>        println(cerr, "WARNING: Bad input encountered: {}", badToken);</code>
<code>    }</code>
<code>}</code>
<code>println("The sum is {}.", sum);</code></pre>
       <p>
        Here is some example output of this program. The
        <code>
         ^Z
        </code>
        characters in the output appear when
        <code>
         Control+Z
        </code>
        is pressed.
       </p>
       <pre id="c13-code-0026"><code>Enter numbers on separate lines to add.</code>
<code>Use Control+D followed by Enter to finish (Control+Z in Windows).</code>
<code>1</code>
<code>2</code>
<code>test</code>
<code>WARNING: Bad input encountered: test</code>
<code>3</code>
<code>^Z</code>
<code>The sum is 6.</code></pre>
      </section>
      <section>
       <span id="c13-sec-0024">
       </span>
       <h4 id="head-4-239">
        Input Member Functions
       </h4>
       <p id="c13-para-0072">
        Just like output streams, input streams have several member functions that allow a lower level of access than the functionality provided by the more common
        <code>
         &gt;&gt;
        </code>
        operator.
       </p>
       <section>
        <span id="c13-sec-0025">
        </span>
        <h5 id="head-5-86">
         get()
        </h5>
        <p>
         The
         <code>
          get()
         </code>
         member function allows raw input of data from a stream. The simplest version of
         <code>
          get()
         </code>
         returns the next character in the stream, though other versions exist that read multiple characters at once.
         <code>
          get()
         </code>
         is most commonly used to avoid the automatic tokenization that occurs with
         <span aria-label="513" epub:type="pagebreak" id="Page_513" role="doc-pagebreak">
         </span>
         the
         <code>
          &gt;&gt;
         </code>
         operator. For example, the following function reads a name, which can be made up of several words, from an input stream until the end of the stream is reached:
        </p>
        <pre id="c13-code-0027"><code>string readName(istream&amp; stream)</code>
<code>{</code>
<code>    string name;</code>
<code>    while (stream) { <span class="color3">// Or: while (!stream.fail()) {</span></code>
<code>        int next { stream.get() };</code>
<code>        if (!stream || next == std::char_traits&lt;char&gt;::eof())</code>
<code>            break;</code>
<code>        name += static_cast&lt;char&gt;(next);<span class="color3">// Append character.</span></code>
<code>    }</code>
<code>    return name;</code>
<code>}</code></pre>
        <p>
         There are several interesting observations to make about this
         <code>
          readName()
         </code>
         function:
        </p>
        <ul class="check1" id="c13-list-0004">
         <li id="c13-li-0020">
          Its parameter is a reference-to-non-
          <code>
           const
          </code>
          to an
          <code>
           istream
          </code>
          , not a reference-to-
          <code>
           const
          </code>
          . The member functions that read in data from a stream will change the actual stream (most notably, its position), so they are not
          <code>
           const
          </code>
          member functions. Thus, you cannot call them on a reference-to-
          <code>
           const
          </code>
          .
         </li>
         <li id="c13-li-0021">
          The return value of
          <code>
           get()
          </code>
          is stored in an
          <code>
           int
          </code>
          , not in a
          <code>
           char
          </code>
          , because
          <code>
           get()
          </code>
          can return special non-character values such as
          <code>
           std::char_traits&lt;char&gt;::eof()
          </code>
          (end-of-file).
         </li>
         <li id="c13-li-0022">
          Newline and other escape characters that are read by
          <code>
           get()
          </code>
          will appear in the
          <code>
           string
          </code>
          returned by
          <code>
           readName()
          </code>
          . If the
          <code>
           Ctrl+D
          </code>
          or
          <code>
           Ctrl+Z
          </code>
          isn't done at the beginning of a line, they too will appear in the returned
          <code>
           string
          </code>
          .
         </li>
        </ul>
        <p>
         <code>
          readName()
         </code>
         is a bit strange because there are two ways to get out of the loop: either the stream can get into a failed state or the end of the stream is reached. A more common pattern for reading from a stream uses a different version of
         <code>
          get()
         </code>
         that takes a reference to a character and returns a reference to the stream. Evaluating an input stream within a conditional context results in
         <code>
          true
         </code>
         only if the stream is not in any error state. The following version of the same function is a bit more concise:
        </p>
        <pre id="c13-code-0028"><code>string readName(istream&amp; stream)</code>
<code>{</code>
<code>    string name;</code>
<code>    char next;</code>
<code>    while (stream.get(next)) {</code>
<code>        name += next;</code>
<code>    }</code>
<code>    return name;</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c13-sec-0026">
        </span>
        <h5 id="head-5-87">
         unget()
        </h5>
        <p id="c13-para-0076">
         For most purposes, the correct way to think of an input stream is as a one-way chute. Data falls down the chute and into variables. The
         <code>
          unget()
         </code>
         member function breaks this model in a way by allowing you to push data back up the chute.
        </p>
        <p id="c13-para-0077">
         A call to
         <code>
          unget()
         </code>
         causes the stream to back up by one position, essentially putting the previous character read back on the stream. You can use the
         <code>
          fail()
         </code>
         member function to see whether
         <code>
          unget()
         </code>
         <span aria-label="514" epub:type="pagebreak" id="Page_514" role="doc-pagebreak">
         </span>
         was successful or not. For example,
         <code>
          unget()
         </code>
         can fail if the current position is at the beginning of the stream.
        </p>
        <p>
         The
         <code>
          getReservationData()
         </code>
         function shown earlier in this chapter did not allow you to enter a name with whitespace. The following code uses
         <code>
          unget()
         </code>
         to allow whitespace in the name. The code reads character by character and checks whether the character is a digit or not. If the character is not a digit, it is added to
         <code>
          guestName
         </code>
         . If it is a digit, the character is put back into the stream using
         <code>
          unget()
         </code>
         , the loop is stopped, and the
         <code>
          &gt;&gt;
         </code>
         operator is used to input an integer,
         <code>
          partySize
         </code>
         . The
         <code>
          noskipws
         </code>
         input manipulator tells the stream not to skip whitespace; that is, whitespace is read like any other characters.
        </p>
        <pre id="c13-code-0029"><code>void getReservationData()</code>
<code>{</code>
<code>    print("Name and number of guests: ");</code>
<code>    string guestName;</code>
<code>    int partySize { 0 };</code>
<code>    <span class="color3">// Read characters until we find a digit</span></code>
<code>    char ch;</code>
<code>    cin &gt;&gt; noskipws;</code>
<code>    while (cin &gt;&gt; ch) {</code>
<code>        if (isdigit(ch)) {</code>
<code>            cin.unget();</code>
<code>            if (cin.fail()) { println(cerr, "unget() failed."); }</code>
<code>            break;</code>
<code>        }</code>
<code>        guestName += ch;</code>
<code>    }</code>
<code>    <span class="color3">// Read partySize, if the stream is not in error state</span></code>
<code>    if (cin) { cin &gt;&gt; partySize; }</code>
<code>    if (!cin) {</code>
<code>        println(cerr, "Error getting party size.");</code>
<code>        return;</code>
<code>    }</code>
<code> </code>
<code>    println("Thank you '{}', party of {}.", guestName, partySize);</code>
<code>    if (partySize &gt; 10) {</code>
<code>        println("An extra gratuity will apply.");</code>
<code>    }</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c13-sec-0027">
        </span>
        <h5 id="head-5-88">
         putback()
        </h5>
        <p>
         The
         <code>
          putback()
         </code>
         member function, like
         <code>
          unget()
         </code>
         , lets you move backward by one character in an input stream. The difference is that
         <code>
          putback()
         </code>
         takes the character being placed back on the stream as a parameter. Here is an example:
        </p>
        <pre id="c13-code-0030"><code>char c;</code>
<code>cin &gt;&gt; c;</code>
<code>println("Retrieved {}.", c);</code>
<code> </code>
<code>cin.putback('e');  <span class="color3">// 'e' will be the next character read off the stream.</span></code>
<code>println("Called putback('e').");</code>
<code> </code>
<code>while (cin &gt;&gt; c) { println("Retrieved {}.", c); }</code></pre>
        <p>
         <span aria-label="515" epub:type="pagebreak" id="Page_515" role="doc-pagebreak">
         </span>
         The output can be as follows:
        </p>
        <pre id="c13-code-0031"><code>wow</code>
<code>Retrieved w.</code>
<code>Called putback('e').</code>
<code>Retrieved e.</code>
<code>Retrieved o.</code>
<code>Retrieved w.</code></pre>
       </section>
       <section>
        <span id="c13-sec-0028">
        </span>
        <h5 id="head-5-89">
         peek ()
        </h5>
        <p id="c13-para-0081">
         The
         <code>
          peek()
         </code>
         member function allows you to preview the next value that
         <i>
          would
         </i>
         be returned if you were to call
         <code>
          get()
         </code>
         . To take the chute metaphor perhaps a bit too far, you could think of it as looking up the chute without a value actually falling down it.
        </p>
        <p>
         <code>
          peek()
         </code>
         is ideal for any situation where you need to look ahead before reading a value. For example, the following code implements
         <code>
          getReservationData()
         </code>
         that allows whitespace in the name, but uses
         <code>
          peek()
         </code>
         instead of
         <code>
          unget()
         </code>
         :
        </p>
        <pre id="c13-code-0032"><code>void getReservationData()</code>
<code>{</code>
<code>    print("Name and number of guests: ");</code>
<code>    string guestName;</code>
<code>    int partySize { 0 };</code>
<code>    <span class="color3">// Read characters until we find a digit.</span></code>
<code>    cin &gt;&gt; noskipws;</code>
<code>    while (true) {</code>
<code>        <span class="color3">// 'peek' at next character.</span></code>
<code>        char ch { static_cast&lt;char&gt;(cin.peek()) };</code>
<code>        if (!cin) { break; }</code>
<code>        if (isdigit(ch)) {</code>
<code>            <span class="color3">// Next character will be a digit, so stop the loop.</span></code>
<code>            break;</code>
<code>        }</code>
<code>        <span class="color3">// Next character will be a non-digit, so read it.</span></code>
<code>        cin &gt;&gt; ch;</code>
<code>        if (!cin) { break; }</code>
<code>        guestName += ch;</code>
<code>    }</code>
<code>    <span class="color3">// Read partySize, if the stream is not in error state.</span></code>
<code>    if (cin) { cin &gt;&gt; partySize; }</code>
<code>    if (!cin) {</code>
<code>        println(cerr, "Error getting party size.");</code>
<code>        return;</code>
<code>    }</code>
<code> </code>
<code>    println("Thank you '{}', party of {}.", guestName, partySize);</code>
<code>    if (partySize &gt; 10) {</code>
<code>        println("An extra gratuity will apply.");</code>
<code>    }</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c13-sec-0029">
        </span>
        <h5 id="head-5-90">
         getline()
        </h5>
        <p>
         Obtaining a single line of data from an input stream is so common that a member function exists to do it for you. The
         <code>
          getline()
         </code>
         member function fills a character buffer with a line of data up to the
         <span aria-label="516" epub:type="pagebreak" id="Page_516" role="doc-pagebreak">
         </span>
         specified size. This specified size includes the
         <code>
          \0
         </code>
         character. Thus, the following code reads a maximum of
         <code>
          BufferSize-1
         </code>
         characters from
         <code>
          cin
         </code>
         or until an end-of-line sequence is read:
        </p>
        <pre id="c13-code-0033"><code>char buffer[BufferSize] { 0 };</code>
<code>cin.getline(buffer, BufferSize);</code></pre>
        <p id="c13-para-0084">
         When
         <code>
          getline()
         </code>
         is called, it reads a line from the input stream, up to and including the end-of-line sequence. However, the end-of-line character or characters do not appear in the string. Note that the end-of-line sequence is platform dependent. For example, it can be
         <code>
          \r\n
         </code>
         ,
         <code>
          \n
         </code>
         , or
         <code>
          \n\r
         </code>
         .
        </p>
        <p id="c13-para-0085">
         There is a form of
         <code>
          get()
         </code>
         that performs the same operation as
         <code>
          getline()
         </code>
         , except that it leaves the newline sequence in the input stream.
        </p>
        <p>
         There is also a non-member function called
         <code>
          std::getline()
         </code>
         that can be used with C++
         <code>
          string
         </code>
         s. It is defined in
         <code>
          &lt;string&gt;
         </code>
         and is in the
         <code>
          std
         </code>
         namespace. It takes a stream and a
         <code>
          string
         </code>
         reference. The advantage of using this version of
         <code>
          getline()
         </code>
         is that it doesn't require you to specify the size of any buffer.
        </p>
        <pre id="c13-code-0034"><code>string myString;</code>
<code>getline(cin, myString);</code></pre>
        <p>
         Both the
         <code>
          getline()
         </code>
         member function and the
         <code>
          std::getline()
         </code>
         function accept an optional delimiter as last parameter. The default delimiter is
         <code>
          \n
         </code>
         . By changing this delimiter, these functions can be used to read in multiple lines of text until a given delimiter is reached. For example, the following code reads in multiple lines of text until it reads an
         <code>
          @
         </code>
         character:
        </p>
        <pre id="c13-code-0035"><code>print("Enter multiple lines of text. "</code>
<code>      "Use an @ character to signal the end of the text.\n&gt; ");</code>
<code>string myString;</code>
<code><b>getline(cin, myString, '@');</b></code>
<code>println("Read text: \"{}\"", myString);</code></pre>
        <p>
         Here is a possible output:
        </p>
        <pre id="c13-code-0036"><code>Enter multiple lines of text. Use an @ character to signal the end of the text.</code>
<code>&gt; This is some</code>
<code>text on multiple</code>
<code>lines.@</code>
<code>Read text: "This is some</code>
<code>text on multiple</code>
<code>lines."</code></pre>
       </section>
      </section>
      <section>
       <span id="c13-sec-0030">
       </span>
       <h4 id="head-4-240">
        Input Manipulators
       </h4>
       <p>
        Just as for output streams, input streams support a number of input manipulators. You've already seen one,
        <code>
         noskipws
        </code>
        , which tells an input stream not to skip any whitespace characters. The following list shows other built-in input manipulators available to you that allow you to customize the way data is read:
       </p>
       <ul class="check1" id="c13-list-0005">
        <li id="c13-li-0023">
         <code>
          boolalpha
         </code>
         and
         <code>
          noboolalpha
         </code>
         : If
         <code>
          boolalpha
         </code>
         is used, the string
         <i>
          false
         </i>
         will be interpreted as the Boolean value
         <code>
          false
         </code>
         ; anything else will be treated as the Boolean value
         <code>
          true
         </code>
         . If
         <code>
          noboolalpha
         </code>
         is set, zero will be interpreted as
         <code>
          false
         </code>
         , anything else as
         <code>
          true
         </code>
         . The default is
         <code>
          noboolalpha
         </code>
         .
        </li>
        <li id="c13-li-0024">
         <span aria-label="517" epub:type="pagebreak" id="Page_517" role="doc-pagebreak">
         </span>
         <code>
          dec
         </code>
         ,
         <code>
          hex
         </code>
         , and
         <code>
          oct
         </code>
         : Reads numbers in decimal base 10, hexadecimal, or octal notation, respectively. For example, the decimal base 10 number
         <code>
          207
         </code>
         is
         <code>
          cf
         </code>
         in hexadecimal, and
         <code>
          317
         </code>
         in octal notation.
        </li>
        <li id="c13-li-0025">
         <code>
          skipws
         </code>
         and
         <code>
          noskipws
         </code>
         : Tells the stream to either skip whitespace when tokenizing or to read in whitespace as its own token. The default is
         <code>
          skipws
         </code>
         .
        </li>
        <li id="c13-li-0026">
         <code>
          ws
         </code>
         : A handy manipulator that simply skips over the current series of whitespace at the current position in the stream.
        </li>
        <li id="c13-li-0027">
         <code>
          get_money
         </code>
         : A parameterized manipulator that reads a monetary value from a stream.
        </li>
        <li id="c13-li-0028">
         <code>
          get_time
         </code>
         : A parameterized manipulator that reads a formatted time from a stream.
        </li>
        <li id="c13-li-0029">
         <code>
          quoted
         </code>
         : A parameterized manipulator that reads a string enclosed with quotes and in which embedded quotes are escaped. An example of this manipulator is shown later in this chapter.
        </li>
       </ul>
       <p>
        Input is locale aware. For example, the following code enables your system locale for
        <code>
         cin
        </code>
        . Locales are discussed in
        <a href="c21.xhtml">
         Chapter 21
        </a>
        :
       </p>
       <pre id="c13-code-0037"><code>cin.imbue(locale { "" });</code>
<code>int i;</code>
<code>cin &gt;&gt; i;</code></pre>
       <p id="c13-para-0091">
        If your system locale is U.S. English, you can enter
        <code>
         1,000
        </code>
        and it will be parsed as 1000. If you enter
        <code>
         1.000
        </code>
        , it will be parsed as 1. On the other hand, if your system locale is Dutch Belgium, you can enter
        <code>
         1.000
        </code>
        to get the value of 1000, but entering
        <code>
         1,000
        </code>
        will result in 1. In both cases, you can also just enter
        <code>
         1000
        </code>
        without any digit separators to get the value 1000.
       </p>
      </section>
     </section>
     <section>
      <span id="c13-sec-0031">
      </span>
      <h3 id="head-3-291">
       Input and Output with Objects
      </h3>
      <p>
       If you are familiar with the old-school
       <code>
        printf()
       </code>
       function from C for output, you know that it is not flexible and does not support custom types.
       <code>
        printf()
       </code>
       knows about several types of data, but there really isn't a way to give it additional knowledge. For example, consider the following simple class:
      </p>
      <pre id="c13-code-0038"><code>class Muffin final</code>
<code>{</code>
<code>    public:</code>
<code>        const string&amp; getDescription() const { return m_description; }</code>
<code>        void setDescription(string description)</code>
<code>        {</code>
<code>            m_description = std::move(description);</code>
<code>        }</code>
<code> </code>
<code>        int getSize() const { return m_size; }</code>
<code>        void setSize(int size) { m_size = size; }</code>
<code> </code>
<code>        bool hasChocolateChips() const { return m_hasChocolateChips; }</code>
<code>        void setHasChocolateChips(bool hasChips)</code>
<code>        {</code>
<code>            m_hasChocolateChips = hasChips;</code>
<code>        }</code>
<code>    private:</code>
<code>        string m_description;</code>
<span aria-label="518" epub:type="pagebreak" id="Page_518" role="doc-pagebreak"></span><code>        int m_size { 0 };</code>
<code>        bool m_hasChocolateChips { false };</code>
<code>};</code></pre>
      <p>
       To output an object of class
       <code>
        Muffin
       </code>
       by using
       <code>
        printf()
       </code>
       , it would be nice if you could specify it as an argument, perhaps using
       <code>
        %m
       </code>
       as a placeholder:
      </p>
      <pre id="c13-code-0039"><code>printf("Muffin: %m\n", myMuffin); <span class="color3">// BUG! printf doesn't understand Muffin.</span></code></pre>
      <p id="c13-para-0094">
       Unfortunately, the
       <code>
        printf()
       </code>
       function knows nothing about the
       <code>
        Muffin
       </code>
       type and is unable to output an object of type
       <code>
        Muffin
       </code>
       . Worse still, because of the way the
       <code>
        printf()
       </code>
       function is declared, this will result in a run-time error, not a compile-time error (though a good compiler will give you a warning).
      </p>
      <p>
       The best you can do with
       <code>
        printf()
       </code>
       is to add a new
       <code>
        output()
       </code>
       member function to the
       <code>
        Muffin
       </code>
       class:
      </p>
      <pre id="c13-code-0040"><code>class Muffin final</code>
<code>{</code>
<code>    public:</code>
<code>        void output() const</code>
<code>        {</code>
<code>            printf("%s, size is %d, %s", getDescription().c_str(), getSize(),</code>
<code>                (hasChocolateChips() ? "has chips" : "no chips"));</code>
<code>        }</code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>};</code></pre>
      <p>
       Using such a mechanism is cumbersome, however. To output a
       <code>
        Muffin
       </code>
       in the middle of another line of text, you'd need to split the line into two calls with a call to
       <code>
        Muffin::output()
       </code>
       in between, as shown here:
      </p>
      <pre id="c13-code-0041"><code>printf("The muffin is a ");</code>
<code>myMuffin.output();</code>
<code>printf(" -- yummy!\n");</code></pre>
      <p>
       A much better and modern option is to write a custom
       <code>
        std::formatter
       </code>
       specialization for
       <code>
        Muffin
       </code>
       objects as explained in
       <a href="c02.xhtml">
        Chapter 2
       </a>
       . The following is a simple custom
       <code>
        formatter
       </code>
       for
       <code>
        Muffin
       </code>
       s. To keep the example concise, this formatter does not support any format specifiers. Thus, the
       <code>
        parse()
       </code>
       abbreviated member function template does not need to parse anything and can just return
       <code>
        begin(context)
       </code>
       .
      </p>
      <pre id="c13-code-0042"><code>template &lt;&gt;</code>
<code>class std::formatter&lt;Muffin&gt;</code>
<code>{</code>
<code>    public:</code>
<code>        constexpr auto parse(auto&amp; context) { return begin(context); }</code>
<code> </code>
<code>        auto format(const Muffin&amp; muffin, auto&amp; ctx) const</code>
<code>        {</code>
<code>            ctx.advance:to(format_to(ctx.out(), "{}, size is {}, {}",</code>
<code>                muffin.getDescription(), muffin.getSize(),</code>
<code>                (muffin.hasChocolateChips() ? "has chips" : "no chips")));</code>
<code>            return ctx.out();</code>
<code>        }</code>
<code>};</code></pre>
      <p>
       <span aria-label="519" epub:type="pagebreak" id="Page_519" role="doc-pagebreak">
       </span>
       With this custom formatter, you can use the modern
       <code>
        std::print()
       </code>
       and
       <code>
        println()
       </code>
       functions to print a muffin. Here is an example:
      </p>
      <pre id="c13-code-0043"><code>println("The muffin is a {} -- yummy!", myMuffin);</code></pre>
      <p id="c13-para-0099">
       Yet another option to print
       <code>
        Muffin
       </code>
       s is to overload the
       <code>
        &lt;&lt;
       </code>
       operator after which you output a
       <code>
        Muffin
       </code>
       just like you output a
       <code>
        string
       </code>
       —by providing it as an argument to
       <code>
        operator&lt;&lt;
       </code>
       . Additionally, you can overload the
       <code>
        &gt;&gt;
       </code>
       operator so that you can input
       <code>
        Muffin
       </code>
       s from an input stream.
       <a href="c15.xhtml">
        Chapter 15
       </a>
       covers the details of overloading the
       <code>
        &lt;&lt;
       </code>
       and
       <code>
        &gt;&gt;
       </code>
       operators.
      </p>
     </section>
     <section>
      <span id="c13-sec-0032">
      </span>
      <h3 id="head-3-292">
       Custom Manipulators
      </h3>
      <p id="c13-para-0100">
       The Standard Library comes with a number of built-in stream manipulators, but, if need be, custom manipulators can be written.
      </p>
      <p>
       Writing your own non-parameterized manipulator is easy. Here's a simple example defining a
       <code>
        tab
       </code>
       output manipulator which outputs the tab character to a given stream:
      </p>
      <pre id="c13-code-0044"><code>ostream&amp; tab(ostream&amp; stream) { return stream &lt;&lt; '\t'; }</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    cout &lt;&lt; "Test" &lt;&lt; tab &lt;&lt; "!" &lt;&lt; endl;</code>
<code>}</code></pre>
      <p id="c13-para-0102">
       Writing custom parameterized manipulators is more complicated. It involves using functionality exposed by
       <code>
        ios_base
       </code>
       , such as
       <code>
        xalloc()
       </code>
       ,
       <code>
        iword()
       </code>
       ,
       <code>
        pword()
       </code>
       , and
       <code>
        register_callback()
       </code>
       . Since such manipulators are rarely needed, this text does not further discuss this topic. Consult your favorite Standard Library reference in case you are interested.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-151">
     <span id="c13-sec-0033">
     </span>
     <h2 id="head-2-151">
      STRING STREAMS
     </h2>
     <p id="c13-para-0103">
      String streams provide a way to use stream semantics with
      <code>
       string
      </code>
      s. In this way, you can have an
      <i>
       in-memory stream
      </i>
      that represents textual data. For example, in a GUI application you might want to use streams to build up textual data, but instead of outputting the text to the console or a file, you might want to display the result in a GUI element like a message box or an edit control. Another example could be that you want to pass a string stream around to different functions, while retaining the current read position, so that each function can process the next part of the stream. String streams are also useful for parsing text, because streams have built-in tokenizing functionality.
     </p>
     <p id="c13-para-0104">
      The
      <code>
       std::ostringstream
      </code>
      class is used to write data to a
      <code>
       string
      </code>
      , while
      <code>
       std::istringstream
      </code>
      is used to read data from a
      <code>
       string
      </code>
      . The
      <code>
       o
      </code>
      in
      <code>
       ostringstream
      </code>
      stands for output, while the
      <code>
       i
      </code>
      in
      <code>
       istringstream
      </code>
      stands for input. They are both defined in
      <code>
       &lt;sstream&gt;
      </code>
      . Because
      <code>
       ostringstream
      </code>
      and
      <code>
       istringstream
      </code>
      inherit the same behavior as
      <code>
       ostream
      </code>
      and
      <code>
       istream
      </code>
      , working with them is pleasantly similar.
     </p>
     <p>
      The following program requests words from the user and outputs them to a single
      <code>
       ostringstream
      </code>
      , separated by commas and surrounded by double quotes. At the end of the program, the whole stream is turned into a
      <code>
       string
      </code>
      object using the
      <code>
       str()
      </code>
      member function and is written to the console.
      <span aria-label="520" epub:type="pagebreak" id="Page_520" role="doc-pagebreak">
      </span>
      Input of tokens can be stopped by entering the token “done” or by closing the input stream with
      <code>
       Control+D
      </code>
      (Unix) or
      <code>
       Control+Z
      </code>
      (Windows).
     </p>
     <pre id="c13-code-0045"><code>println("Enter tokens. "</code>
<code>      "Control+D (Unix) or Control+Z (Windows) followed by Enter to end.");</code>
<code>ostringstream outStream;</code>
<code>bool firstLoop { true };</code>
<code>while (cin) {</code>
<code>    string nextToken;</code>
<code>    print("Next token: ");</code>
<code>    cin &gt;&gt; nextToken;</code>
<code> </code>
<code>    if (!cin || nextToken == "done") { break; }</code>
<code> </code>
<code>    if (!firstLoop) { outStream &lt;&lt; ", "; }</code>
<code>    outStream &lt;&lt; '"' &lt;&lt; nextToken &lt;&lt; '"';</code>
<code>    firstLoop = false;</code>
<code>}</code>
<code>println("The end result is: {}", outStream.str());</code></pre>
     <p>
      Reading data from a string stream is similarly familiar. The following function creates and populates a
      <code>
       Muffin
      </code>
      object (see the earlier example) from a string input stream. The stream data is in a fixed format so that the function can easily turn its values into calls to
      <code>
       Muffin
      </code>
      's setters. This fixed format is the description of the muffin between double quotes, followed by the size, followed by true or false depending on whether the muffin has chocolate chips. For example, the following string is a valid muffin:
     </p>
     <pre id="c13-code-0046"><code>"Raspberry Muffin" 12 true</code></pre>
     <p>
      Here is the implementation. Note the use of the
      <code>
       quoted
      </code>
      manipulator to read a quoted string from the input stream.
     </p>
     <pre id="c13-code-0047"><code>Muffin createMuffin(istringstream&amp; stream)</code>
<code>{</code>
<code>    Muffin muffin;</code>
<code>    <span class="color3">// Assume data is properly formatted:</span></code>
<code>    <span class="color3">// "Description" size chips</span></code>
<code> </code>
<code>    string description;</code>
<code>    int size;</code>
<code>    bool hasChips;</code>
<code> </code>
<code>    <span class="color3">// Read all three values. Note that chips is represented</span></code>
<code>    <span class="color3">// by the strings "true" and "false".</span></code>
<code>    <b>stream &gt;&gt; quoted(description) &gt;&gt; size &gt;&gt; boolalpha &gt;&gt; hasChips;</b></code>
<code>    if (stream) { <span class="color3">// Reading was successful.</span></code>
<code>        muffin.setSize(size);</code>
<code>        muffin.setDescription(description);</code>
<code>        muffin.setHasChocolateChips(hasChips);</code>
<code>    }</code>
<code>    return muffin;</code>
<code>}</code></pre>
     <p>
      <span aria-label="521" epub:type="pagebreak" id="Page_521" role="doc-pagebreak">
      </span>
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c13-para-0109">
         <b>
          NOTE
         </b>
         <i>
          Turning an object into a “flattened” type, like a string, is often called marshaling. Marshaling is useful for saving objects to disk or sending them across a network
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c13-para-0110">
      An advantage of string streams over standard C++
      <code>
       string
      </code>
      s is that, in addition to data, they know where the next read or write operation will take place, also called the
      <i>
       current position
      </i>
      .
     </p>
     <p id="c13-para-0111">
      Another advantage is that string streams support manipulators and locales to enable more powerful formatting compared to
      <code>
       string
      </code>
      s.
     </p>
     <p id="c13-para-0112">
      Finally, if you need to build up a string by concatenating several smaller strings, using a string stream will be more performant compared to concatenating
      <code>
       string
      </code>
      objects directly.
     </p>
    </section>
    <section aria-labelledby="head-2-152">
     <span id="c13-sec-0035">
     </span>
     <h2 id="head-2-152">
      <img alt="C++23" src="../images\images/icon1.png"/>
      SPAN-BASED STREAMS
     </h2>
     <p id="c13-para-0114">
      C++23 introduces
      <i>
       span-based streams
      </i>
      , defined in
      <code>
       &lt;spanstream&gt;
      </code>
      , which allow you to use the stream metaphor on any fixed memory buffer you have available. How memory was allocated for that buffer is not important. The most important classes in this context that you'll use are
      <code>
       ispanstream
      </code>
      for input,
      <code>
       ospanstream
      </code>
      for output, and
      <code>
       spanstream
      </code>
      for input and output. Technically, these are
      <code>
       char
      </code>
      instantiations for the class templates
      <code>
       basic_ispanstream
      </code>
      ,
      <code>
       basic_ospanstream
      </code>
      , and
      <code>
       basic_spanstream
      </code>
      . There are also wide-character,
      <code>
       wchar_t
      </code>
      instantiations available called
      <code>
       wispanstream
      </code>
      ,
      <code>
       wospanstream
      </code>
      , and
      <code>
       wspanstream
      </code>
      . Wide characters are mentioned earlier in this chapter and covered in more detail in
      <a href="c21.xhtml">
       Chapter 21
      </a>
      . This section gives examples of the non-wide-character classes, as the others work very similarly.
     </p>
     <p id="c13-para-0115">
      The constructors of the span-based stream classes require an
      <code>
       std::span
      </code>
      .
      <a href="c18.xhtml">
       Chapter 18
      </a>
      , “Standard Library Containers,” discusses
      <code>
       span
      </code>
      in detail and explains why and when you want to use it, but those details are not important for this section. The use of
      <code>
       span
      </code>
      in the context of span-based streams is straightforward, as you'll see. In a nutshell, a
      <code>
       span
      </code>
      allows you to make a view over a contiguous block of memory. It's a bit similar to how
      <code>
       std::string_view
      </code>
      allows you to create a read-only view over any kind of string, as discussed in
      <a href="c02.xhtml">
       Chapter 2
      </a>
      . The difference is that a
      <code>
       span
      </code>
      can be a read-only view, but it can also be a writable view allowing modifications to the underlying buffer.
     </p>
     <p>
      Here is an example of using an
      <code>
       ispanstream
      </code>
      to parse data stored in a fixed memory buffer called
      <code>
       fixedBuffer
      </code>
      . To construct a
      <code>
       span
      </code>
      over that buffer, you simply use the
      <code>
       span
      </code>
      constructor and pass it the location of the buffer.
     </p>
     <pre id="c13-code-0048"><code>char fixedBuffer[] { "11 2.222 Hello" };</code>
<code><b>ispanstream stream { span { fixedBuffer } };</b></code>
<code>int i;   double d;   string str;</code>
<code>stream &gt;&gt; i &gt;&gt; d &gt;&gt; str;</code>
<code>println("Parsed data: int: {}, double: {}, string: {}", i, d, str);</code></pre>
     <p>
      The output is as follows:
     </p>
     <pre id="c13-code-0049"><code>Parsed data: int: 11, double: 2.222, string: Hello</code></pre>
     <p>
      <span aria-label="522" epub:type="pagebreak" id="Page_522" role="doc-pagebreak">
      </span>
      Using an
      <code>
       ospanstream
      </code>
      is similarly straightforward. The following code creates a fixed buffer of 32
      <code>
       char
      </code>
      s, constructs a writable
      <code>
       ospanstream
      </code>
      view over that buffer, uses standard stream insertion operations to output some data to the buffer, and finally prints out the result:
     </p>
     <pre id="c13-code-0050"><code>char fixedBuffer[32] {};</code>
<code><b>ospanstream stream { span { fixedBuffer } };</b></code>
<code>stream &lt;&lt; "Hello " &lt;&lt; 2.222 &lt;&lt; ' ' &lt;&lt; 11;</code>
<code>println("Buffer contents: \"{}\"", fixedBuffer);</code></pre>
     <p>
      The output is:
     </p>
     <pre id="c13-code-0051"><code>Buffer contents: "Hello 2.222 11"</code></pre>
    </section>
    <section aria-labelledby="head-2-153">
     <span id="c13-sec-0036">
     </span>
     <h2 id="head-2-153">
      FILE STREAMS
     </h2>
     <p id="c13-para-0120">
      Files lend themselves well to the stream abstraction because reading and writing files always involves a position in addition to the data. In C++, the
      <code>
       std::ofstream
      </code>
      and
      <code>
       ifstream
      </code>
      classes provide output and input functionality for files. They are defined in
      <code>
       &lt;fstream&gt;
      </code>
      .
     </p>
     <p id="c13-para-0121">
      When dealing with the filesystem, it is especially important to detect and handle error cases. The file you are working with could be on a network file store that just went offline, or you may be trying to write to a file that is located on a disk that is full. Maybe you are trying to open a file for which the current user does not have permissions. Error conditions can be detected by using the standard error handling mechanisms described earlier.
     </p>
     <p id="c13-para-0122">
      The only major difference between output file streams and other output streams is that the file stream constructor can take the name of the file and the mode in which you would like to open it. The default mode is write,
      <code>
       ios_base::out
      </code>
      , which starts writing to a file at the beginning, overwriting any existing data. You can also open an output file stream in append mode by specifying the constant
      <code>
       ios_base::app
      </code>
      as the second argument to the file stream constructor. The following table lists the different constants that are available:
     </p>
     <table border="1">
      <thead>
       <tr>
        <th class="left bgcolor2" scope="col">
         CONSTANT
        </th>
        <th class="left bgcolor2" scope="col">
         DESCRIPTION
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ios_base::app
         </span>
        </td>
        <td class="left bgcolor3">
         Open, and go to the end before each write operation.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ios_base::ate
         </span>
        </td>
        <td class="left bgcolor3">
         Open, and go to the end once immediately after opening.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ios_base::binary
         </span>
        </td>
        <td class="left bgcolor3">
         Perform input and output in binary mode as opposed to text mode. See the next section.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ios_base::in
         </span>
        </td>
        <td class="left bgcolor3">
         Open for input, start reading at the beginning.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ios_base::out
         </span>
        </td>
        <td class="left bgcolor3">
         Open for output, start writing at the beginning, overwriting existing data.
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <span class="forecolor1">
          ios_base::trunc
         </span>
        </td>
        <td class="left bgcolor3">
         Option for
         <span class="forecolor1">
          out
         </span>
         . Delete all existing data (truncate).
        </td>
       </tr>
       <tr>
        <td class="left bgcolor3">
         <img alt="C++23" src="../images\images/icon1.png"/>
         <span class="forecolor1">
          ios_base::noreplace
         </span>
        </td>
        <td class="left bgcolor3">
         Option for
         <code>
          out
         </code>
         . Open in exclusive mode. Open will fail if the file already exists.
        </td>
       </tr>
      </tbody>
     </table>
     <p>
      <span aria-label="523" epub:type="pagebreak" id="Page_523" role="doc-pagebreak">
      </span>
      Note that modes can be combined. For example, if you want to open a file for output in binary mode, while truncating existing data, you would specify the open mode as follows:
     </p>
     <pre id="c13-code-0052"><code>ios_base::out | ios_base::binary  | ios_base::trunc</code></pre>
     <p id="c13-para-0128">
      An
      <code>
       ifstream
      </code>
      automatically includes the
      <code>
       ios_base::in
      </code>
      mode, while an
      <code>
       ofstream
      </code>
      automatically includes the
      <code>
       ios_base::out
      </code>
      mode, even if you don't explicitly specify
      <code>
       in
      </code>
      or
      <code>
       out
      </code>
      as the mode.
     </p>
     <p>
      The following program opens the
      <code>
       test.txt
      </code>
      file and writes the program's arguments to it. The
      <code>
       ifstream
      </code>
      and
      <code>
       ofstream
      </code>
      destructors automatically close the underlying file, so there is no need to explicitly call
      <code>
       close()
      </code>
      .
     </p>
     <pre id="c13-code-0053"><code>int main(int argc, char* argv[])</code>
<code>{</code>
<code>    ofstream outFile { "test.txt", ios_base::trunc };</code>
<code>    if (!outFile.good()) {</code>
<code>        println(cerr, "Error while opening output file!");</code>
<code>        return -1;</code>
<code>    }</code>
<code>    outFile &lt;&lt; "There were " &lt;&lt; argc &lt;&lt; " arguments to this program." &lt;&lt; endl;</code>
<code>    outFile &lt;&lt; "They are: " &lt;&lt; endl;</code>
<code>    for (int i { 0 }; i &lt; argc; i++) {</code>
<code>        outFile &lt;&lt; argv[i] &lt;&lt; endl;</code>
<code>    }</code>
<code>}</code></pre>
     <section>
      <span id="c13-sec-0037">
      </span>
      <h3 id="head-3-293">
       Text Mode vs. Binary Mode
      </h3>
      <p id="c13-para-0130">
       By default, a file stream is opened in
       <i>
        text mode
       </i>
       . If you specify the
       <code>
        ios_base::binary
       </code>
       flag, then the file is opened in
       <i>
        binary mode
       </i>
       .
      </p>
      <p id="c13-para-0131">
       In binary mode, the exact bytes you ask the stream to write are written to the file. When reading, the bytes are returned to you exactly as they are in the file.
      </p>
      <p id="c13-para-0132">
       In text mode, there is some hidden conversion happening: each line you write to, or read from, a file ends with
       <code>
        \n
       </code>
       . However, how the end of a line is encoded in a file depends on the operating system. For example, on Windows, a line ends with
       <code>
        \r\n
       </code>
       instead of with a single
       <code>
        \n
       </code>
       character. Therefore, when a file is opened in text mode and you write a line ending with
       <code>
        \n
       </code>
       to it, the underlying implementation automatically converts the
       <code>
        \n
       </code>
       to
       <code>
        \r\n
       </code>
       before writing it to the file. Similarly, when reading a line from the file, the
       <code>
        \r\n
       </code>
       that is read from the file is automatically converted back to
       <code>
        \n
       </code>
       before being returned to you.
      </p>
     </section>
     <section>
      <span id="c13-sec-0038">
      </span>
      <h3 id="head-3-294">
       Jumping Around with seek() and tell()
      </h3>
      <p id="c13-para-0133">
       The
       <code>
        seek
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       and
       <code>
        tell
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       member functions are present on all input and output streams. The
       <code>
        seek
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       member functions let you move to an arbitrary position within an input or output stream. There are several forms of
       <code>
        seek
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       . For an input stream, the member function is called
       <code>
        seekg()
       </code>
       (the
       <i>
        g
       </i>
       is for
       <i>
        get
       </i>
       ), and for an output stream, it is called
       <code>
        seekp()
       </code>
       (the
       <i>
        p
       </i>
       is for
       <i>
        put
       </i>
       ). You might wonder why there is both a
       <code>
        seekg()
       </code>
       and a
       <code>
        seekp()
       </code>
       member function, instead of one
       <code>
        seek()
       </code>
       member function. The reason is that you can have streams that are both input and output, for example, file streams.
       <span aria-label="524" epub:type="pagebreak" id="Page_524" role="doc-pagebreak">
       </span>
       In that case, the stream needs to remember both a read position and a separate write position. This is also called
       <i>
        bidirectional I/O
       </i>
       and is covered later in this chapter.
      </p>
      <p id="c13-para-0134">
       There are two overloads of
       <code>
        seekg()
       </code>
       and two of
       <code>
        seekp()
       </code>
       . One overload accepts a single argument, an absolute position, and seeks to this absolute position. The second overload accepts an offset and a position and seeks an offset relative to the given position. Positions are of type
       <code>
        std::streampos
       </code>
       , while offsets are of type
       <code>
        std::streamoff
       </code>
       ; both are measured in bytes. There are three predefined positions available, as shown in the following table:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          POSITION
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           ios_base::beg
          </span>
         </td>
         <td class="left bgcolor3">
          The beginning of the stream
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           ios_base::end
          </span>
         </td>
         <td class="left bgcolor3">
          The end of the stream
         </td>
        </tr>
        <tr>
         <td class="left bgcolor3">
          <span class="forecolor1">
           ios_base::cur
          </span>
         </td>
         <td class="left bgcolor3">
          The current position in the stream
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       For example, to seek to an absolute position in an output stream, you can use the one-parameter overload of
       <code>
        seekp()
       </code>
       , as in the following case, which uses the constant
       <code>
        ios_base::beg
       </code>
       to move to the beginning of the stream:
      </p>
      <pre id="c13-code-0054"><code>outStream.seekp(ios_base::beg);</code></pre>
      <p>
       Seeking within an input stream is the same, except that the
       <code>
        seekg()
       </code>
       member function is used:
      </p>
      <pre id="c13-code-0055"><code>inStream.seekg(ios_base::beg);</code></pre>
      <p>
       The two-argument overloads move to a relative position in the stream. The first argument prescribes how many positions to move, and the second argument provides the starting point. To move relative to the beginning of the file, the constant
       <code>
        ios_base::beg
       </code>
       is used. To move relative to the end of the file,
       <code>
        ios_base::end
       </code>
       is used. To move relative to the current position,
       <code>
        ios_base::cur
       </code>
       is used. For example, the following line moves to the second byte from the beginning of the output stream. Note that integers are implicitly converted to type
       <code>
        streampos
       </code>
       and
       <code>
        streamoff
       </code>
       .
      </p>
      <pre id="c13-code-0056"><code>outStream.seekp(2, ios_base::beg);</code></pre>
      <p>
       The next example moves to the third-to-last byte of an input stream:
      </p>
      <pre id="c13-code-0057"><code>inStream.seekg(-3, ios_base::end);</code></pre>
      <p id="c13-para-0140">
       You can also query a stream's current location using the
       <code>
        tell
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       member function, which returns a
       <code>
        streampos
       </code>
       that indicates the current position. You can use this result to remember the current marker position before doing a
       <code>
        seek
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       or to query whether you are in a particular location. There are again separate versions of
       <code>
        tell
       </code>
       <i>
        x
       </i>
       <code>
        ()
       </code>
       for input streams and output streams. Input streams use
       <code>
        tellg()
       </code>
       , and output streams use
       <code>
        tellp()
       </code>
       .
      </p>
      <p>
       The following code checks the position of an input stream to determine whether it is at the beginning:
      </p>
      <pre id="c13-code-0058"><code>streampos curPos { inStream.tellg() };</code>
<code>if (ios_base::beg == curPos) {</code>
<code>    println("We're at the beginning.");</code>
<code>}</code></pre>
      <p>
       <span aria-label="525" epub:type="pagebreak" id="Page_525" role="doc-pagebreak">
       </span>
       The following is a sample program that brings it all together. This program writes into a file called
       <code>
        test.out
       </code>
       and performs the following tests:
      </p>
      <ol class="decimal" id="c13-list-0006">
       <li id="c13-li-0030">
        Outputs the string
        <code>
         54321
        </code>
        to the file
       </li>
       <li id="c13-li-0031">
        Verifies that the marker is at position 5 in the stream
       </li>
       <li id="c13-li-0032">
        Moves to position 2 in the output stream
       </li>
       <li id="c13-li-0033">
        Outputs a
        <code>
         0
        </code>
        in position 2 and closes the output stream
       </li>
       <li id="c13-li-0034">
        Opens an input stream on the
        <code>
         test.out
        </code>
        file
       </li>
       <li id="c13-li-0035">
        Reads the first token as an integer
       </li>
       <li id="c13-li-0036">
        Confirms that the value is
        <code>
         54021
        </code>
       </li>
      </ol>
      <pre id="c13-code-0059"><code>ofstream fout { "test.out" };</code>
<code>if (!fout) {</code>
<code>    println(cerr, "Error opening test.out for writing.");</code>
<code>    return 1;</code>
<code>}</code>
<code> </code>
<code><span class="color3">// 1. Output the string "54321".</span></code>
<code>fout &lt;&lt; "54321";</code>
<code> </code>
<code><span class="color3">// 2. Verify that the marker is at position 5.</span></code>
<code>streampos curPos { fout.tellp() };</code>
<code>if (curPos == 5) {</code>
<code>    println("Test passed: Currently at position 5.");</code>
<code>} else {</code>
<code>    println("Test failed: Not at position 5!");</code>
<code>}</code>
<code> </code>
<code><span class="color3">// 3. Move to position 2 in the output stream.</span></code>
<code>fout.seekp(2, ios_base::beg);</code>
<code> </code>
<code><span class="color3">// 4. Output a 0 in position 2 and close the output stream.</span></code>
<code>fout &lt;&lt; 0;</code>
<code>fout.close();</code>
<code> </code>
<code><span class="color3">// 5. Open an input stream on test.out.</span></code>
<code>ifstream fin { "test.out" };</code>
<code>if (!fin) {</code>
<code>    println(cerr, "Error opening test.out for reading.");</code>
<code>    return 1;</code>
<code>}</code>
<code> </code>
<code><span class="color3">// 6. Read the first token as an integer.</span></code>
<code>int testVal;</code>
<code>fin &gt;&gt; testVal;</code>
<code>if (!fin) {</code>
<code>    println(cerr,  "Error reading from file.");</code>
<code>    return 1;</code>
<code>}</code>
<code> </code>
<span aria-label="526" epub:type="pagebreak" id="Page_526" role="doc-pagebreak"></span><code><span class="color3">// 7. Confirm that the value is 54021.</span></code>
<code>const int expected { 54021 };</code>
<code>if (testVal == expected) {</code>
<code>    println("Test passed: Value is {}.", expected);</code>
<code>} else {</code>
<code>    println("Test failed: Value is not {} (it was {}).", expected, testVal);</code>
<code>}</code></pre>
     </section>
     <section>
      <span id="c13-sec-0039">
      </span>
      <h3 id="head-3-295">
       Linking Streams Together
      </h3>
      <p id="c13-para-0143">
       A link can be established between any input and output streams to give them
       <i>
        flush-on-access
       </i>
       behavior. In other words, when data is requested from an input stream, its linked output stream is automatically flushed. This behavior is available to all streams but is particularly useful for file streams that may be dependent upon each other.
      </p>
      <p id="c13-para-0144">
       Stream linking is accomplished with the
       <code>
        tie()
       </code>
       member function. To tie an output stream to an input stream, call
       <code>
        tie()
       </code>
       on the input stream, and pass the address of the output stream. To break the link, pass
       <code>
        nullptr
       </code>
       .
      </p>
      <p>
       The following program ties the input stream of one file to the output stream of an entirely different file. You could also tie it to an output stream on the same file, but bidirectional I/O (covered in the next section) is perhaps a more elegant way to read and write the same file simultaneously.
      </p>
      <pre id="c13-code-0060"><code>ifstream inFile { "input.txt" };  <span class="color3">// Note: input.txt must exist.</span></code>
<code>ofstream outFile { "output.txt" };</code>
<code><span class="color3">// Set up a link between inFile and outFile.</span></code>
<code>inFile.tie(&amp;outFile);</code>
<code><span class="color3">// Output some text to outFile. Normally, this would</span></code>
<code><span class="color3">// not flush because std::endl is not send.</span></code>
<code>outFile &lt;&lt; "Hello there!";</code>
<code><span class="color3">// outFile has NOT been flushed.</span></code>
<code><span class="color3">// Read some text from inFile. This will trigger flush() on outFile.</span></code>
<code>string nextToken;</code>
<code>inFile &gt;&gt; nextToken;</code>
<code><span class="color3">// outFile HAS been flushed.</span></code></pre>
      <p>
       The
       <code>
        flush()
       </code>
       member function is defined on the
       <code>
        ostream
       </code>
       base class, so you can also link an output stream to another output stream. Here's an example:
      </p>
      <pre id="c13-code-0061"><code>outFile.tie(&amp;anotherOutputFile);</code></pre>
      <p id="c13-para-0147">
       Such a relationship means that every time you write to one file, the buffered data that has been sent to the other file is flushed. You can use this mechanism to keep two related files synchronized.
      </p>
      <p id="c13-para-0148">
       One example of this stream linking is the link between
       <code>
        cout
       </code>
       and
       <code>
        cin
       </code>
       . Whenever you try to input data from
       <code>
        cin
       </code>
       ,
       <code>
        cout
       </code>
       is automatically flushed. There is also a link between
       <code>
        cerr
       </code>
       and
       <code>
        cout
       </code>
       , meaning that any output to
       <code>
        cerr
       </code>
       causes
       <code>
        cout
       </code>
       to flush. The
       <code>
        clog
       </code>
       stream, on the other hand, is not linked to
       <code>
        cout
       </code>
       . The wide versions of these streams have similar links.
      </p>
     </section>
     <section>
      <span id="c13-sec-0040">
      </span>
      <h3 id="head-3-296">
       Read an Entire File
      </h3>
      <p>
       You can use
       <code>
        getline()
       </code>
       to read the entire contents of a file by specifying
       <code>
        \0
       </code>
       as the delimiter. This works only as long as the file doesn't contain any
       <code>
        \0
       </code>
       characters in its contents. For example:
      </p>
      <pre id="c13-code-0062"><code>ifstream inputFile { "some_data.txt" };</code>
<span aria-label="527" epub:type="pagebreak" id="Page_527" role="doc-pagebreak"></span><code>if (inputFile.fail()) {</code>
<code>    println(cerr, "Unable to open file for reading.");</code>
<code>    return 1;</code>
<code>}</code>
<code>string fileContents;</code>
<code><b>getline(inputFile, fileContents, '\0');</b></code>
<code>println("\"{}\"", fileContents);</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-154">
     <span id="c13-sec-0041">
     </span>
     <h2 id="head-2-154">
      BIDIRECTIONAL I/O
     </h2>
     <p id="c13-para-0150">
      So far, this chapter has discussed input and output streams as two separate but related classes. However, there is such a thing as a stream that performs both input and output: a
      <i>
       bidirectional stream
      </i>
      .
     </p>
     <p id="c13-para-0151">
      Bidirectional streams derive from
      <code>
       iostream
      </code>
      , which in turn derives from both
      <code>
       istream
      </code>
      and
      <code>
       ostream
      </code>
      , thus serving as an example of useful multiple inheritance. As you would expect, bidirectional streams support both the
      <code>
       &gt;&gt;
      </code>
      operator and the
      <code>
       &lt;&lt;
      </code>
      operator, as well as the member functions of both input streams and output streams.
     </p>
     <p>
      The
      <code>
       fstream
      </code>
      class provides a bidirectional file stream.
      <code>
       fstream
      </code>
      is ideal for applications that need to replace data within a file, because you can read until you find the correct position and then immediately switch to writing. For example, imagine a program that stores a list of mappings between ID numbers and phone numbers. It might use a data file with the following format:
     </p>
     <pre id="c13-code-0063"><code>123 408-555-0394</code>
<code>124 415-555-3422</code>
<code>263 585-555-3490</code>
<code>100 650-555-3434</code></pre>
     <p>
      A reasonable approach to such a program would be to read in the entire data file when the program opens and rewrite the file, with any modifications, when the program closes. If the data set is huge, however, you might not be able to keep everything in memory. With
      <code>
       iostream
      </code>
      s, you don't have to. You can easily scan through the file to find a record, and you can add new records by opening the file for output in append mode. To modify an existing record, you could use a bidirectional stream, as in the following function that changes the phone number for a given ID:
     </p>
     <pre id="c13-code-0064"><code>bool changeNumberForID(const string&amp; filename, int id, string_view newNumber)</code>
<code>{</code>
<code>    fstream ioData { filename };</code>
<code>    if (!ioData) {</code>
<code>        println(cerr, "Error while opening file {}.", filename);</code>
<code>        return false;</code>
<code>    }</code>
<code> </code>
<code>    <span class="color3">// Loop until the end of file.</span></code>
<code>    while (ioData) {</code>
<code>        <span class="color3">// Read the next ID.</span></code>
<code>        int idRead;</code>
<code>        ioData &gt;&gt; idRead;</code>
<code>        if (!ioData) { break; }</code>
<code> </code>
<code>        <span class="color3">// Check to see if the current record is the one being changed.</span></code>
<code>        if (idRead == id) {</code>
<code>            <span class="color3">// Seek the write position to the current read position.</span></code>
<span aria-label="528" epub:type="pagebreak" id="Page_528" role="doc-pagebreak"></span><code>            ioData.seekp(ioData.tellg());</code>
<code>            <span class="color3">// Output a space, then the new number.</span></code>
<code>            ioData &lt;&lt; " " &lt;&lt; newNumber;</code>
<code>            break;</code>
<code>        }</code>
<code> </code>
<code>        <span class="color3">// Read the current number to advance the stream.</span></code>
<code>        string number;</code>
<code>        ioData &gt;&gt; number;</code>
<code>    }</code>
<code>    return true;</code>
<code>}</code></pre>
     <p id="c13-para-0154">
      Of course, an approach like this only works properly if the data is of a fixed size. When the preceding program switched from reading to writing, the output data overwrote other data in the file. To preserve the format of the file and to avoid writing over the next record, the data had to be the exact same size.
     </p>
     <p>
      String streams can also be accessed in a bidirectional manner through the
      <code>
       stringstream
      </code>
      class.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c13-para-0156">
         <b>
          NOTE
         </b>
         <i>
          Bidirectional streams have separate pointers for the read position and the write position. When switching between reading and writing, you need to seek the appropriate position
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-155">
     <span id="c13-sec-0043">
     </span>
     <h2 id="head-2-155">
      FILESYSTEM SUPPORT LIBRARY
     </h2>
     <p id="c13-para-0157">
      The C++ Standard Library includes a filesystem support library, defined in
      <code>
       &lt;filesystem&gt;
      </code>
      and living in the
      <code>
       std::filesystem
      </code>
      namespace. It allows you to write portable code to work with the filesystem. You can use it for querying whether something is a directory or a file, iterating over the contents of a directory, manipulating paths, and retrieving information about files such as their size, extension, creation time, and so on. The two most important parts of the library—paths and directory entries—are introduced in the next sections.
     </p>
     <section>
      <span id="c13-sec-0044">
      </span>
      <h3 id="head-3-297">
       Path
      </h3>
      <p>
       The basic component of the library is a
       <code>
        path
       </code>
       . A
       <code>
        path
       </code>
       can be absolute or relative and can optionally include a filename. For example, the following code defines a couple of
       <code>
        path
       </code>
       s. Note the use of raw string literals, introduced in
       <a href="c02.xhtml">
        Chapter 2
       </a>
       , to avoid having to escape backslashes:
      </p>
      <pre id="c13-code-0065"><code>path p1 { R"(D:\Foo\Bar)" };</code>
<code>path p2 { "D:/Foo/Bar" };</code>
<code>path p3 { "D:/Foo/Bar/MyFile.txt" };</code>
<code>path p4 { R"(..\SomeFolder)" };</code>
<code>path p5 { "/usr/lib/X11" };</code></pre>
      <p>
       A
       <code>
        path
       </code>
       can be converted to the native format of the system on which the code is running by calling
       <code>
        string()
       </code>
       . Here's an example:
      </p>
      <pre id="c13-code-0066"><code>println("{}", p1.string());</code>
<code>println("{}", p2.string());</code></pre>
      <p>
       <span aria-label="529" epub:type="pagebreak" id="Page_529" role="doc-pagebreak">
       </span>
       The output on Windows, which supports both forward and backward slashes, is as follows:
      </p>
      <pre id="c13-code-0067"><code>D:\Foo\Bar</code>
<code>D:/Foo/Bar</code></pre>
      <p>
       You can append a component to a
       <code>
        path
       </code>
       with the
       <code>
        append()
       </code>
       member function or with
       <code>
        operator/=
       </code>
       . A platform-dependent path separator is automatically inserted. Here's an example:
      </p>
      <pre id="c13-code-0068"><code>path p { "D:\\Foo" };</code>
<code><b>p.append("Bar");</b></code>
<code><b>p /= "Bar";</b></code>
<code>println("{}", p.string());</code></pre>
      <p id="c13-para-0162">
       The output on Windows is
       <code>
        D:\Foo\Bar\Bar
       </code>
       .
      </p>
      <p>
       You can use
       <code>
        concat()
       </code>
       or
       <code>
        operator+=
       </code>
       to concatenate a string to an existing
       <code>
        path
       </code>
       . This does not insert any path separator! Here's an example:
      </p>
      <pre id="c13-code-0069"><code>path p { "D:\\Foo" };</code>
<code><b>p.concat("Bar");</b></code>
<code><b>p += "Bar";</b></code>
<code>println("{}", p.string());</code></pre>
      <p>
       The output on Windows now is
       <code>
        D:\FooBarBar
       </code>
       .
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c13-para-0165">
          <b>
           WARNING
          </b>
          <code>
           append()
          </code>
          <i>
           and
          </i>
          <code>
           operator/=
          </code>
          <i>
           automatically insert a platform-dependent path separator, while
          </i>
          <code>
           concat()
          </code>
          <i>
           and
          </i>
          <code>
           operator+=
          </code>
          <i>
           do not.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       A range-based
       <code>
        for
       </code>
       loop can be used to iterate over the different components of a
       <code>
        path
       </code>
       . Here is an example:
      </p>
      <pre id="c13-code-0070"><code>path p { R"(C:\Foo\Bar)" };</code>
<code>for (const auto&amp; component : p) {</code>
<code>    println("{}", component.string());</code>
<code>}</code></pre>
      <p>
       The output on Windows is as follows:
      </p>
      <pre id="c13-code-0071"><code>C:</code>
<code>\</code>
<code>Foo</code>
<code>Bar</code></pre>
      <p>
       The
       <code>
        path
       </code>
       interface supports operations such as
       <code>
        remove_filename()
       </code>
       ,
       <code>
        replace:filename()
       </code>
       ,
       <code>
        replace:extension()
       </code>
       ,
       <code>
        root_name()
       </code>
       ,
       <code>
        parent_path()
       </code>
       ,
       <code>
        extension()
       </code>
       ,
       <code>
        stem()
       </code>
       ,
       <code>
        filename()
       </code>
       ,
       <code>
        has_extension()
       </code>
       ,
       <code>
        is_absolute()
       </code>
       ,
       <code>
        is_relative()
       </code>
       , and more. A few of these are demonstrated in the following code snippet:
      </p>
      <pre id="c13-code-0072"><code>path p { R"(C:\Foo\Bar\file.txt)" };</code>
<code>println("{}", p.root_name().string());</code>
<code>println("{}", p.filename().string());</code>
<code>println("{}", p.stem().string());</code>
<code>println("{}", p.extension().string());</code></pre>
      <p>
       <span aria-label="530" epub:type="pagebreak" id="Page_530" role="doc-pagebreak">
       </span>
       This code produces the following result on Windows:
      </p>
      <pre id="c13-code-0073"><code>C:</code>
<code>file.txt</code>
<code>file</code>
<code>.txt</code></pre>
      <p id="c13-para-0170">
       Consult your favorite Standard Library reference for a full list of all available functionality.
      </p>
     </section>
     <section>
      <span id="c13-sec-0046">
      </span>
      <h3 id="head-3-298">
       Directory Entry
      </h3>
      <p id="c13-para-0171">
       A
       <code>
        path
       </code>
       just represents a directory or a file on a filesystem. A
       <code>
        path
       </code>
       may refer to a non-existing directory or file. If you want to query an actual directory or file on the filesystem, you need to construct a
       <code>
        directory_entry
       </code>
       from a
       <code>
        path
       </code>
       . The
       <code>
        directory_entry
       </code>
       interface supports operations such as
       <code>
        exists()
       </code>
       ,
       <code>
        is_directory()
       </code>
       ,
       <code>
        is_regular_file()
       </code>
       ,
       <code>
        file_size()
       </code>
       ,
       <code>
        last_write_time()
       </code>
       , and others.
      </p>
      <p>
       The following example constructs a
       <code>
        directory_entry
       </code>
       from a
       <code>
        path
       </code>
       to query the size of a file:
      </p>
      <pre id="c13-code-0074"><code>path myPath { "c:/windows/win.ini" };</code>
<code>directory_entry dirEntry { myPath };</code>
<code>if (dirEntry.exists() &amp;&amp; dirEntry.is_regular_file()) {</code>
<code>    println("File size: {}", dirEntry.file_size());</code>
<code>}</code></pre>
     </section>
     <section>
      <span id="c13-sec-0047">
      </span>
      <h3 id="head-3-299">
       Helper Functions
      </h3>
      <p id="c13-para-0173">
       An entire collection of helper functions is available as well. For example, you can use
       <code>
        copy()
       </code>
       to copy files or directories,
       <code>
        create_directory()
       </code>
       to create a new directory on the filesystem,
       <code>
        exists()
       </code>
       to query whether a given directory or file exists,
       <code>
        file_size()
       </code>
       to get the size of a file,
       <code>
        last_write_time()
       </code>
       to get the time the file was last modified,
       <code>
        remove()
       </code>
       to delete a file,
       <code>
        temp_directory_path()
       </code>
       to get a directory suitable for storing temporary files,
       <code>
        space()
       </code>
       to query the available space on a filesystem, and more. Consult a Standard Library reference (see
       <a href="b02.xhtml">
        Appendix B
       </a>
       , “Annotated Bibliography”) for a full list.
      </p>
      <p>
       The following example prints out the capacity of a filesystem and how much space is still free:
      </p>
      <pre id="c13-code-0075"><code>space:info s { space("c:\\") };</code>
<code>println("Capacity: {}", s.capacity);</code>
<code>println("Free: {}", s.free);</code></pre>
      <p id="c13-para-0175">
       You can find more examples of these helper functions in the following section on directory iteration.
      </p>
     </section>
     <section>
      <span id="c13-sec-0048">
      </span>
      <h3 id="head-3-300">
       Directory Iteration
      </h3>
      <p>
       If you want to recursively iterate over all files and subdirectories in a given directory, you can use a
       <code>
        recursive_directory_iterator
       </code>
       . To start the iteration process, you need an iterator to the first
       <code>
        directory_entry
       </code>
       . To know when to stop the iteration, you need an end iterator. To create the start iterator, construct a
       <code>
        recursive_directory_iterator
       </code>
       and pass as argument a
       <code>
        path
       </code>
       of the directory over which you want to iterate. To construct the end iterator, default construct a
       <code>
        recursive_directory_iterator
       </code>
       . To get access to the
       <code>
        directory_entry
       </code>
       that an iterator refers to, use the dereferencing operator,
       <code>
        *
       </code>
       . Traversing all elements in the collection is accomplished by simply incrementing the iterator using the ++ operator until it reaches the end iterator. Note that the end
       <span aria-label="531" epub:type="pagebreak" id="Page_531" role="doc-pagebreak">
       </span>
       iterator is not part of the collection anymore and hence does not refer to a valid
       <code>
        directory_entry
       </code>
       and must not be dereferenced.
      </p>
      <pre id="c13-code-0076"><code>void printDirectoryStructure(const path&amp; p)</code>
<code>{</code>
<code>    if (!exists(p)) { return; }</code>
<code> </code>
<code>    recursive_directory_iterator begin { p };</code>
<code>    recursive_directory_iterator end { };</code>
<code>    for (auto iter { begin }; iter != end; ++iter) {</code>
<code>        const string spacer(iter.depth() * 2, ' ');</code>
<code> </code>
<code>        auto&amp; entry { *iter }; <span class="color3">// Dereference iter to access directory_entry.</span></code>
<code> </code>
<code>        if (is_regular_file(entry)) {</code>
<code>            println("{}File: {} ({} bytes)",</code>
<code>                spacer, entry.path().string(), file_size(entry));</code>
<code>        } else if (is_directory(entry)) {</code>
<code>            println("{}Dir: {}", spacer, entry.path().string());</code>
<code>        }</code>
<code>    }</code>
<code>}</code></pre>
      <p>
       This function can be called as follows:
      </p>
      <pre id="c13-code-0077"><code>path p { R"(D:\Foo\Bar)" };</code>
<code>printDirectoryStructure(p);</code></pre>
      <p>
       You can also use a
       <code>
        directory_iterator
       </code>
       to iterate over the contents of a directory and implement the recursion yourself. Here is an example that does the same thing as the previous example but using a
       <code>
        directory_iterator
       </code>
       instead of a
       <code>
        recursive_directory_iterator
       </code>
       :
      </p>
      <pre id="c13-code-0078"><code>void printDirectoryStructure(const path&amp; p, unsigned level = 0)</code>
<code>{</code>
<code>    if (!exists(p)) { return; }</code>
<code> </code>
<code>    const string spacer(level * 2, ' ');</code>
<code> </code>
<code>    if (is_regular_file(p)) {</code>
<code>        println("{}File: {} ({} bytes)", spacer, p.string(), file_size(p));</code>
<code>    } else if (is_directory(p)) {</code>
<code>        println("{}Dir: {}", spacer, p.string());</code>
<code>        for (auto&amp; entry : directory_iterator { p }) {</code>
<code>            printDirectoryStructure(entry, level + 1);</code>
<code>        }</code>
<code>    }</code>
<code>}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-156">
     <span id="c13-sec-0049">
     </span>
     <h2 id="head-2-156">
      SUMMARY
     </h2>
     <p id="c13-para-0179">
      Streams provide a flexible and object-oriented way to perform input and output. The most important message in this chapter, even more important than the use of streams, is the concept of a stream. Some operating systems may have their own file access and I/O facilities, but knowledge of how streams and stream-like libraries work is essential to working with any type of modern I/O system.
     </p>
     <p id="c13-para-0180">
      <span aria-label="532" epub:type="pagebreak" id="Page_532" role="doc-pagebreak">
      </span>
      The chapter finished with an introduction to the filesystem support library, which you can use to work with files and directories in a platform-independent manner.
     </p>
    </section>
    <section aria-labelledby="head-2-157">
     <span id="c13-sec-0050">
     </span>
     <h2 id="head-2-157">
      EXERCISES
     </h2>
     <p id="c13-para-0181">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c13-exsec-0001">
      </span>
      <ol class="none">
       <li id="c13-ex-0001">
        <b>
         Exercise 13-1:
        </b>
        Let's revisit the
        <code>
         Person
        </code>
        class you developed during exercises in previous chapters. Take your implementation from Exercise 9-2 and add an
        <code>
         output()
        </code>
        member function that writes the details of a person to the standard output console.
       </li>
       <li id="c13-ex-0002">
        <b>
         Exercise 13-2:
        </b>
        The
        <code>
         output()
        </code>
        member function from the previous exercise always writes the details of a person to the standard output console. Change the
        <code>
         output()
        </code>
        member function to have an output stream as parameter and write the details of a person to that stream. Test your new implementation in
        <code>
         main()
        </code>
        by writing a person to the standard output console, a string stream, and a file. Notice how it's possible to output a person to all kinds of different targets (output console, string streams, files, and so on) with a single member function using streams.
       </li>
       <li id="c13-ex-0003">
        <b>
         Exercise 13-3:
        </b>
        Develop a class called
        <code>
         Database
        </code>
        that stores
        <code>
         Person
        </code>
        s (from Exercise 13-2) in an
        <code>
         std::vector
        </code>
        . Provide an
        <code>
         add()
        </code>
        member function to add a person to the database. Also provide a
        <code>
         save()
        </code>
        member function, accepting the name of a file to which it saves all persons in the database. Any existing contents in the file is removed. Add a
        <code>
         load()
        </code>
        member function, accepting the name of a file from which the database loads all persons. Provide a
        <code>
         clear()
        </code>
        member function to remove all persons from the database. Finally, add a member function
        <code>
         outputAll()
        </code>
        that calls
        <code>
         output()
        </code>
        on all persons in the database. Make sure your implementation works, even if there are spaces in a person's first or last name.
       </li>
       <li id="c13-ex-0004">
        <b>
         Exercise 13-4:
        </b>
        The
        <code>
         Database
        </code>
        from Exercise 13-3 stores all persons in a single file. To practice the filesystem support library, let's change that to store each person in its own file. Modify the
        <code>
         save()
        </code>
        and
        <code>
         load()
        </code>
        member functions to accept a directory as argument where files should be stored to or loaded from. The
        <code>
         save()
        </code>
        member function saves every person in the database to its own file. The name of each file is the first name of the person followed by an underscore followed by the last name of the person. The extension of the files should be
        <code>
         .person
        </code>
        . If a file already exists, overwrite it. The
        <code>
         load()
        </code>
        member function iterates over all
        <code>
         .person
        </code>
        files in a given directory and loads all of them.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
