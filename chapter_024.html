<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   15: Extensibility
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_023.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_025.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="533" epub:type="pagebreak" id="pagebreak_533" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0015" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000040">
      15: Extensibility
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         Extensibility is an important aspect of application programming interface (API) design because it lets users expand the base functionality without requiring you to support their needs explicitly. Most of this chapter deals with how to create a Plugin API. It is a way for users to extend the functionality of your API in defined ways by creating dynamic libraries that are discovered and loaded at run time. The chapter deals with how to create stable C++ interfaces and cover the entire architecture, including the Plugin API itself, the Plugin Manager, and example plugins. The chapter also covers other ways to extend an API, such as through inheritance, with a specific example of the Visitor design pattern. Extensibility via templates is also covered, including policy-based templates and the curiously recurring template pattern.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Enums; Inheritance; Plugin; Subclassing; Templates; Versioning; Visitor pattern
      </div>
     </section>
     <section>
      <p class="textfl" id="p0010">
       In this final chapter, I'll discuss the topic of application programming interface (API) extensibility. By this, I mean the ability for your clients to modify the behavior of your interface without requiring you to evolve the API for their specific needs. This can be a critical factor in your ability to maintain a clean and focused interface while delivering a flexible system that lets your users solve problems that you never anticipated. This concept is expressed by the open/closed principle, which we discussed in
       <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
        Chapter 4
       </a>
       on Design: that an API should be open for extension but closed for modification (
       <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib66" id="bib_66">
        Meyer, 1997
       </a>
       ).
      </p>
      <p class="text" id="p0015">
       To offer a real-world example, the Marionette animation system at Pixar supported key-frame animation with a range of possible interpolation schemes between animation keys, such as Bézier, Catmull-Rom, linear, and step interpolation. However, during the development of
       <i>
        The Incredibles and Cars
       </i>
       , it became necessary to allow our production users to devise and iterate on more sophisticated interpolation routines. Rather than continually update the core animation system every time our users needed to change their custom interpolation algorithm, we devised a plugin system that allowed production users to create dynamic libraries that could be discovered at run time and would then be added to the set of built-in interpolation routines. This proved an effective way to resolve the production-specific needs while maintaining a general-purpose filmmaking system.
      </p>
      <p class="text" id="p0020">
       This chapter is dedicated to various techniques that allow you to achieve the same level of flexibility in your own APIs. I will spend most of the chapter detailing how to create industrial-strength cross-platform plugin architectures for your C and C++ APIs, but I will also cover other extensibility techniques using inheritance and templates.
      </p>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        Extending via plugins
       </h2>
       <p class="textfl" id="p0025">
        In the most common scenario, a plugin is a dynamic library that's discovered and loaded at run time, as opposed to a dynamic library against which an application is linked at build time. Plugins can therefore be written by your users, using a well-defined Plugin API that you provide. This allows them to extend the functionality of your API in designated ways.
        <a href="#f0010" id="Bf0010">
         Fig. 15.1
        </a>
        illustrates this concept, in which the white boxes represent artifacts that your users produce.
       </p>
       <p class="text" id="p0030">
        However, static library plugins are also possible, such as for embedded systems in which all plugins are statically linked into the application at compile time. This is useful to ensure that a plugin can be found at run time and that it’s been built under the same environment as the main executable. However, I'll focus on the dynamic library model in this chapter, because this poses the most design challenges and gives users the ability to add new plugins to the system at run time.
        <a id="p534">
        </a>
       </p>
       <div>
        <span aria-label="534" epub:type="pagebreak" id="pagebreak_534" role="doc-pagebreak">
        </span>
       </div>
       <section>
        <a id="sf0010">
        </a>
        <div class="pageavoid">
         <figure class="fig" id="f0010">
          <img alt="image" height="850" src="../../IMAGES/B9780443222191000040/main.assets/f15-01-9780443222191.jpg" width="2418"/>
          <figcaption class="figleg">
           <a id="cap0010">
           </a>
           <a id="fspara0010">
           </a>
           <span class="fignum">
            <a href="#Bf0010">
             Figure 15.1
            </a>
           </span>
           A plugin library is a dynamic library that can be compiled separately from a Core application programming interface (API) and explicitly loaded by the API on demand.
          </figcaption>
         </figure>
        </div>
       </section>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         Plugin model overview
        </h3>
        <p class="textfl" id="p0035">
         There are many examples of commercial software packages that allow their core functionality to be extended by C/C++ plugins. For example, the Apache Web server supports C-based “modules,” Adobe Photoshop supports a range of plugin types to manipulate images, and Web browsers such as Firefox, Chrome, and Opera support the Netscape Plugin API (NPAPI) for the creation of browser plugins such as the PDF Reader plugin. The Qt toolkit can also be extended via the
         <span class="inlinecode">
          QPluginLoader
         </span>
         class. (A server-based Plugin API such as Apache's module interface is sometimes referred to as a Server API.)
        </p>
        <p class="text" id="p0040">
         Some of the benefits of adopting a plugin model in your API are:
        </p>
        <div>
         <ol id="ulist0010">
          <li class="bulllist" id="p0045">
           <a id="u0010">
           </a>
           ▪
           <b>
            Greater versatility
           </b>
           . Your API can be used to solve a greater range of problems without requiring you to implement solutions for all of them.
          </li>
          <li class="bulllist" id="p0050">
           <a id="u0015">
           </a>
           ▪
           <b>
            Community catalyst
           </b>
           . By giving your users the ability to solve their own problems within the framework of your API, you can spark a community of user-contributed additions to your base design.
          </li>
          <li class="bulllist" id="p0055">
           <a id="u0020">
           </a>
           ▪
           <b>
            Smaller updates
           </b>
           . Functionality that exists as a plugin can be easily updated independently of the application simply by dropping in a new version of the plugin. This can often be a much smaller update than distributing a new version of the entire application.
          </li>
          <li class="bulllist" id="p0060">
           <a id="u0025">
           </a>
           ▪
           <b>
            Future proofing
           </b>
           . Your API may reach a level stability where you feel that no more updates are necessary. However, further evolution of the functionality of your API can continue through the development of plugins, allowing the API to maintain its
           <a id="p535">
           </a>
           <span aria-label="535" epub:type="pagebreak" id="pagebreak_535" role="doc-pagebreak">
           </span>
           usefulness and relevance for a greater period. For example, the NPAPI has changed little in recent years, but it remains a popular method to write plugins for many Web browsers.
          </li>
          <li class="bulllist" id="p0065">
           <a id="u0030">
           </a>
           ▪
           <b>
            Isolating risk
           </b>
           . Plugins can be beneficial for in-house development, too, by letting engineers change functionality without destabilizing the core of your system. This is, of course, because by their nature, plugins are loosely coupled from the core system.
          </li>
         </ol>
        </div>
        <p class="text" id="p0070">
         As I hinted earlier, a plugin system doesn't have to be used only by your clients. You can develop parts of your Core API implementation as plugins, too. In fact, this is a good practice because it ensures that you fully exercise your plugin architecture and that you live in the same world as your users (“eat your own dog food”). For example, the GNU Image Manipulation Program (GIMP) ships many of its built-in image processing functions as plugins using its GIMP Plugin API.
        </p>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0015">
            <i>
             SIDEBAR: Netscape Plugins
            </i>
           </div>
           <div class="b1textfl" id="bpar0010">
            <i>
             The Netscape Plugin API provides a cross-platform Plugin API to embed custom functionality inside various Web browsers. The interface grew out of work from Adobe Systems to integrate a PDF viewer into early versions of the Netscape browser. This plain C Plugin API is still used today to embed native code extensions inside Web browsers such as Mozilla Firefox, Apple Safari, and Google Chrome. For example, Shockwave Flash, Apple QuickTime, and Microsoft Silverlight are implemented as browser plugins (try typing “about:plugins” into Firefox to see a list of installed plugins).
            </i>
           </div>
           <div class="b1text" id="bpar0015">
            <i>
             The NPAPI gives native code
            </i>
            <i>
             these capabilities inside a Web browser:
            </i>
           </div>
           <div>
            <ol id="ulist0015">
             <li class="b1bulllist" id="bpar0020">
              <a id="u0035">
              </a>
              •
              <i>
               Register new MIME types.
              </i>
             </li>
             <li class="b1bulllist" id="bpar0025">
              <a id="u0040">
              </a>
              •
              <i>
               Draw into a region of the browser window.
              </i>
             </li>
             <li class="b1bulllist" id="bpar0030">
              <a id="u0045">
              </a>
              •
              <i>
               Receive mouse and keyboard events.
              </i>
             </li>
             <li class="b1bulllist" id="bpar0035">
              <a id="u0050">
              </a>
              •
              <i>
               Send and receive data over HTTP.
              </i>
             </li>
             <li class="b1bulllist" id="bpar0040">
              <a id="u0055">
              </a>
              •
              <i>
               Add hyperlinks or hotspots that link to new URLs.
              </i>
             </li>
             <li class="b1bulllist" id="bpar0045">
              <a id="u0060">
              </a>
              •
              <i>
               Communicate with the Document Object Model.
              </i>
             </li>
            </ol>
           </div>
           <div class="b1text" id="bpar0050">
            <i>
             While I was at SRI International in the 1990s, we developed a Web-based 3D terrain visualization system called TerraVision (
            </i>
            <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib53" id="bib_53">
             <i>
              Leclerc and Lau, 1994
             </i>
            </a>
            <i>
             ). This started life as a desktop application that required a 4-processor SGI Onyx RealityEngine
            </i>
            <i>
             <sup>
              2
             </sup>
            </i>
            <i>
             . However, as commodity graphics hardware advanced, we were eventually able to make it run as a plugin inside Netscape Navigator and Microsoft Explorer on a standard PC.
            </i>
           </div>
           <div>
            <div class="pageavoid">
             <figure class="fig" id="f0035">
              <img alt="image" class="box_img" height="1965" src="../../IMAGES/B9780443222191000040/main.assets/u15-01-9780443222191.jpg" width="2030"/>
              <figcaption class="figleg">
              </figcaption>
             </figure>
            </div>
           </div>
           <div class="b1textfl">
            <i>
             TerraVision was a complex multithreaded application, so to make this work in a non–thread-safe browser environment we had to run it in a separate process. Our Netscape plugin would create a new process for TerraVision to run in and pass it a window handle to draw into. All communication between the plugin and the TerraVision processes happened via pipe I/O.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p536">
         </a>
        </p>
        <div>
         <span aria-label="536" epub:type="pagebreak" id="pagebreak_536" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0015">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="1096" src="../../IMAGES/B9780443222191000040/main.assets/f15-02-9780443222191.jpg" width="2014"/>
           <figcaption class="figleg">
            <a id="cap0015">
            </a>
            <a id="fspara0015">
            </a>
            <span class="fignum">
             <a href="#Bf0015">
              Figure 15.2
             </a>
            </span>
            The Plugin manager lives in the core application programming interface (API). It discovers and loads plugins that have been built against the Plugin API.
           </figcaption>
          </figure>
         </div>
        </section>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Plugin system design issues
        </h3>
        <p class="textfl" id="p0080">
         There are many ways to design a plugin system. The best solution for your current project may not be the best choice for your next project. I will therefore start by trying to tease out some of the high-level issues that you should be aware of when devising a plugin system.
        </p>
        <p class="text" id="p0085">
         At the same time, a few general concepts are applicable to all plugin systems. For example, when supporting dynamic library plugins, you'll always need a mechanism to load a dynamic library and access symbols in that file. Also, when creating any plugin system, there are two major features that you must design (
         <a href="#f0015" id="Bf0015">
          Fig. 15.2
         </a>
         ):
        </p>
        <div>
         <ul class="ce_list" id="olist0010">
          <li class="numlist" id="p0090">
           <a id="o0010">
           </a>
           1.
           <b>
            The Plugin API
           </b>
           : This is the API that your users must compile and link against to create a plugin. I differentiate this from your Core API, which is the larger code base into which you are adding the plugin system.
          </li>
          <li class="numlist" id="p0095">
           <a id="o0015">
           </a>
           2.
           <b>
            The Plugin Manager
           </b>
           : This is an object (often a singleton) in the Core API code that manages the life cycle of all plugins, such as loading, registration, and unloading. This object can also be called the Plugin registry.
          </li>
         </ul>
        </div>
        <p class="text" id="p0100">
         With these general concepts in hand, let's look at some of the design decisions that will affect the precise plugin architecture that you should build for your API:
        </p>
        <div>
         <ol id="ulist0020">
          <li class="bulllist" id="p0105">
           <a id="u0065">
           </a>
           ▪
           <b>
            C versus C++
           </b>
           . As I discussed earlier in the Versioning chapter, the C++ specification does not define a specific application binary interface (ABI). Therefore, different compilers, and even different versions of the same compiler, can produce code that is binary incompatible. The implication for a plugin system is that plugins developed by clients using a compiler with a different ABI may not be
           <a id="p538">
           </a>
           <span aria-label="538" epub:type="pagebreak" id="pagebreak_538" role="doc-pagebreak">
           </span>
           loadable. In contrast, the ABI for plain C code is well-defined and will work across platforms and compilers.
          </li>
          <li class="bulllist" id="p0110">
           <a id="u0070">
           </a>
           ▪
           <b>
            Versioning
           </b>
           . You will want some way to know whether a plugin was built with an incompatible version of your API. Determining what constitutes an incompatible API can be difficult to surmise automatically, so it's often left to the plugin writer to specify. For example, Firefox's extensions API lets you specify a minimum and maximum version range with which the extension is known to work (with a system to update an extension's max version easily for occasions when an incompatible API is released). It's also useful to know which version of the API a plugin was compiled against. This could be embedded in the plugin automatically or again, it could be left to the plugin writer to specify. For example, Google's Android API lets you specify an
           <span class="inlinecode">
            android:targetSdkVersion
           </span>
           in addition to
           <span class="inlinecode">
            android:minSdkVersion
           </span>
           and
           <span class="inlinecode">
            android:maxSdkVersion
           </span>
           .
          </li>
          <li class="bulllist" id="p0115">
           <a id="u0075">
           </a>
           ▪
           <b>
            Internal versus external metadata
           </b>
           . Metadata, such as a human-readable name and version information, can either be defined within the plugin code itself or specified in a simple external file format. The benefit of using an external metadata file is that you don't have to load all plugins to know the set of all available objects. For example, you may want to present a list of all plugins to the user and then load only the plugins they chose to use. The downside, however, is that you can't simply drop a new plugin into a directory and have it be loaded automatically. You must also include a per-plugin metadata file, or update a global metadata file for all plugins, depending upon the approach you adopt.
          </li>
          <li class="bulllist" id="p0120">
           <a id="u0080">
           </a>
           ▪
           <b>
            Generic versus specialized Plugin Manager
           </b>
           : One approach to implementing the Plugin Manager is to make it low-level and generic (i.e., it simply loads plugins and accesses symbols in those plugins). However, doing so can mean that the Plugin Manager does not know about the existence of concrete types in your API. As a result, it will probably have to return objects as
           <span class="inlinecode">
            void∗
           </span>
           pointers and you must cast those to concrete types before using them. Alternatively, a Plugin Manager that can, at a minimum, forward declare the types for any objects in a plugin can produce a more type-safe solution, although as a result it can't be implemented independently of your API. A middle ground is to introduce a dynamic run time typing system into your API, in which the Plugin Manager can return references in terms of a generic type that can be registered later by your API.
          </li>
          <li class="bulllist" id="p0125">
           <a id="u0085">
           </a>
           ▪
           <b>
            Security
           </b>
           : You must decide how much you'll trust user plugins. Plugins are arbitrary compiled code that you allow to run in your process. A plugin could therefore potentially do anything, from accessing data that it shouldn't, to deleting files on the end user's hard drive, and to crashing the entire application. If you need to protect against such malicious plugins, then you may consider creating a socket-based solution, in which plugins run in a separate process and communicate with the Core API through an IPC channel. Alternatively, you could implement bindings for a language that supports sandboxing of user scripts, such as JavaScript or TypeScript, and require all plugins to be written in that scripting language.
           <a id="p539">
           </a>
          </li>
          <li>
           <span aria-label="539" epub:type="pagebreak" id="pagebreak_539" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p0130">
           <a id="u0090">
           </a>
           ▪
           <b>
            Static versus dynamic libraries
           </b>
           : As I've mentioned, it's possible to define plugins as static libraries, meaning that they must be compiled into the application program. The more common solution for consumer applications is to use dynamic libraries, so that users can write their own plugins and extend the application at run time. A constraint for writing static plugins is that you must ensure that no two plugins define the same symbols: that is, the initialization function for each plugin must be named uniquely, such as
           <span class="inlinecode">
            &lt;PluginName&gt;_PluginInit()
           </span>
           , whereas in the case of dynamic library plugins you can use the same initialization function name for every plugin, such as
           <span class="inlinecode">
            PluginInit()
           </span>
           .
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Implementing plugins in C++
        </h3>
        <p class="textfl" id="p0135">
         I've identified that supporting C++ plugins can be difficult because of cross-platform and cross-compiler ABI problems. However, this is a book about C++ API design, so let's take a few more moments to present some solutions that let you use C++ plugins more robustly.
        </p>
        <p class="text" id="p0140">
         First off, if you're happy requiring that plugin developers use the identical version of the same compiler that you use for building your API, then you should have nothing to worry about. If that's not the case, one solution is to use a binding technology for your plugins: for example, an IPC solution such as COM, XPC, or gRPC, or creating script bindings for your API and letting users write extensions with a cross-platform scripting language such as Python or Ruby (as I covered in the previous chapter).
        </p>
        <p class="text" id="p0145">
         If you absolutely need to use C++ plugins for maximum performance or feel that creating a COM or script binding is too heavyweight for your needs, there are still ways that you can use C++ more safely in plugins. This list offers several best practices, many of which are implemented by the open source DynObj library available on
         <a href="http://www.codeproject.com/">
          http://www.codeproject.com/
         </a>
         :
        </p>
        <div>
         <ol id="ulist0025">
          <li class="bulllist" id="p0150">
           <a id="u0095">
           </a>
           ▪
           <b>
            Use abstract base classes
           </b>
           : Implementing virtual methods of an abstract base class can insulate a plugin from ABI problems because a virtual method call is usually represented as an index into a class's vtable. Theoretically, the vtable format can differ between compilers, but in practice this tends not to happen. (However, different compilers may order overloaded virtual methods differently, so it's best to avoid these.) All of the methods in the interface need to be pure virtual, although inlined methods can be used safely, too, because the code will get embedded directly into the plugin.
          </li>
          <li class="bulllist" id="p0155">
           <a id="u0100">
           </a>
           ▪
           <b>
            Use C linkage for free functions
           </b>
           : All global functions in your Plugin API should use C linkage to avoid C++ ABI issues (i.e., they should be declared with
           <span class="inlinecode">
            extern "C")
           </span>
           . Similarly, function callbacks that a plugin passes to the Core API should also use C linkage for maximum portability.
          </li>
          <li class="bulllist" id="p0160">
           <a id="u0105">
           </a>
           ▪
           <b>
            Avoid the C++ Standard Library and exceptions
           </b>
           : Different implementations of Standard Library classes such as
           <span class="inlinecode">
            std::string
           </span>
           and
           <span class="inlinecode">
            std::vector
           </span>
           may not be ABI compatible. It's therefore best to avoid these containers in any function calls
           <a id="p540">
           </a>
           <span aria-label="540" epub:type="pagebreak" id="pagebreak_540" role="doc-pagebreak">
           </span>
           between the Core API and Plugin API. Similarly, the ABI for exceptions tends to be unstable across compilers, and so these should also be avoided in your Plugin API.
          </li>
          <li class="bulllist" id="p0165">
           <a id="u0110">
           </a>
           ▪
           <b>
            Don't mix allocators
           </b>
           : It's possible for plugins to be linked against a memory allocator different from your API. For example, on Windows it's common for debug builds to use a different allocator from release builds. The implication for the design of our plugin system is that either the plugin must allocate and free all of its objects or the plugin should pass control to the Core API to create and destroy all objects. However, your Core API should never free objects that were allocated by a plugin, and vice versa.
          </li>
         </ol>
        </div>
        <p class="text" id="p0170">
         Putting all of this information together, I'll now develop a flexible and robust cross-platform C++ plugin system. The plugin system will allow new C++ classes to be registered with the Core API by providing one or more factory methods. I'll continue our extensible factory example from
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         (Patterns) and augment it to allow new
         <span class="inlinecode">
          IRenderer
         </span>
         classes to be registered from plugins, in which these plugins are dynamically loaded at run time rather than being compiled into the Core API. Furthermore, the plugin architecture will support different approaches to storing plugin metadata, either within an accompanying external file or within the plugins themselves.
        </p>
       </section>
       <section>
        <a id="s0030">
        </a>
        <h3 class="h2hd" id="cesectitle0040">
         The plugin API
        </h3>
        <p class="textfl" id="p0175">
         The Plugin API is the interface that you provide to your users to create plugins. I'll call it
         <span class="inlinecode">
          pluginapi.h
         </span>
         in our example here. This header file will contain functionality that allows plugins to communicate with the Core API.
        </p>
        <p class="text" id="p0180">
         When the Core API loads a plugin, it needs to know which functions to call or which symbols to access to let the plugin do its work. This means that you should define specifically named entry points in the plugin that your users must provide. There are several ways in which you can do this. For example, when writing a GIMP plugin, you must define a variable called
         <span class="inlinecode">
          PLUG_IN_INFO
         </span>
         that lists the various callbacks defined in the plugin:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="486" src="../../IMAGES/B9780443222191000040/main.assets/u15-02-9780443222191.jpg" width="2256"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0185">
         Netscape Plugins use a similar, although slightly more flexible technique. In this case, plugin writers define an
         <span class="inlinecode">
          NP_GetEntryPoints()
         </span>
         function and fill in the appropriate fields of the
         <span class="inlinecode">
          NPPluginFuncs
         </span>
         structure that the browser passes in during plugin
         <a id="p541">
         </a>
         <span aria-label="541" epub:type="pagebreak" id="pagebreak_541" role="doc-pagebreak">
         </span>
         registration. The
         <span class="inlinecode">
          NPPluginFuncs
         </span>
         structure includes size and version fields to handle future expansion.
        </p>
        <p class="text" id="p0190">
         Another solution is to have specifically named functions that the Core API can call if they are exported by the plugin. I'll adopt this approach for our example because it's simple and scalable (e.g., it doesn't rely on a fixed size array or structure).
        </p>
        <p class="text" id="p0195">
         The two most basic callbacks that a plugin should provide are an initialization function and a cleanup function. As I noted earlier, these functions should be declared with C linkage to avoid name mangling differences between compilers. If you want to develop a cross-platform plugin system, you'll also have to deal with correctly using
         <span class="inlinecode">
          __declspec(dllexport)
         </span>
         and
         <span class="inlinecode">
          __declspec(dllimport)
         </span>
         decorators on Windows. Rather than require our plugin developers to know all of these details, I'll provide some macros to simplify everything. (I stated earlier that you should avoid preprocessor macros for declaring things such as API constants, but they are perfectly valid to affect compile-time configurations such as this.)
        </p>
        <p class="text" id="p0200">
         Also, I've decided that our plugin should be allowed to register new
         <span class="inlinecode">
          IRenderer
         </span>
         derived classes, so I'll provide a Plugin API call to let plugins do just that. Here's a first draft of our Plugin API:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="1007" src="../../IMAGES/B9780443222191000040/main.assets/u15-03-9780443222191.jpg" width="2011"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0205">
         This header provides macros to define the initialization and cleanup functions for a plugin:
         <span class="inlinecode">
          PLUGIN_INIT()
         </span>
         and
         <span class="inlinecode">
          PLUGIN_FREE()
         </span>
         , respectively. I also provide the
         <span class="inlinecode">
          PLUGIN_FUNC()
         </span>
         macro to let plugins export functions for the Core API to call, as well as the
         <span class="inlinecode">
          CORE_FUNC()
         </span>
         macro that exports Core API functions for plugins to call. Finally I provide a function,
         <span class="inlinecode">
          RegisterRenderer()
         </span>
         , which allows plugins to register new
         <span class="inlinecode">
          IRenderer
         </span>
         classes with the Core API. A plugin must provide both an init function and a free function for their new
         <span class="inlinecode">
          IRenderer
         </span>
         classes to ensure that allocations and frees happen within the plugin (to address the point that you should not mix memory allocators).
        </p>
        <p class="text" id="p0210">
         You may also note our use of the
         <span class="inlinecode">
          CORE_API
         </span>
         and
         <span class="inlinecode">
          PLUGIN_API
         </span>
         defines. These let us specify the correct DLL export/import decorators under Windows.
         <span class="inlinecode">
          CORE_API
         </span>
         is used to decorate
         <a id="p542">
         </a>
         <span aria-label="542" epub:type="pagebreak" id="pagebreak_542" role="doc-pagebreak">
         </span>
         functions that are part of the Core API, and
         <span class="inlinecode">
          PLUGIN_API
         </span>
         is used for functions that will be defined in plugins. The definition of these macros is contained in the
         <span class="inlinecode">
          defines.h
         </span>
         header and looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000040/main.assets/u15-04-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0215">
         You must build your Core API with the
         <span class="inlinecode">
          BUILDING_CORE
         </span>
         define set for these macros to work correctly (e.g., add
         <span class="inlinecode">
          /DBUILDING_CORE
         </span>
         to the compile line on Windows). This define is not needed when compiling plugins.
        </p>
        <p class="text" id="p0220">
         Finally, for completeness, here are the contents of the
         <span class="inlinecode">
          renderer.h
         </span>
         file, which is included by
         <span class="inlinecode">
          pluginapi.h
         </span>
         :
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000040/main.assets/u15-05-9780443222191.jpg" width="2218"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0225">
         This is essentially the same definition that I presented in the Patterns chapter, except that I have changed the
         <span class="inlinecode">
          LoadScene()
         </span>
         method to accept a
         <span class="inlinecode">
          const char ∗
         </span>
         parameter instead of an
         <span class="inlinecode">
          std::string
         </span>
         (to address our concerns about binary compatibility of C++ Standard Library classes between compilers).
        </p>
       </section>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         An example plugin
        </h3>
        <p class="textfl" id="p0230">
         Now that I've developed a rudimentary Plugin API, let's examine what a plugin built against this API might look like. The basic parts that you need to include are:
        </p>
        <div>
         <ul class="ce_list" id="olist0015">
          <li class="numlist" id="p0235">
           <a id="o0020">
           </a>
           1. The new
           <span class="inlinecode">
            IRenderer
           </span>
           class.
           <a id="p543">
           </a>
          </li>
          <li>
           <span aria-label="543" epub:type="pagebreak" id="pagebreak_543" role="doc-pagebreak">
           </span>
          </li>
          <li class="numlist" id="p0240">
           <a id="o0025">
           </a>
           2. Callbacks to create and destroy this class.
          </li>
          <li class="numlist" id="p0245">
           <a id="o0030">
           </a>
           3. A plugin initialization routine that registers the create/destroy callbacks with the Core API.
          </li>
         </ul>
        </div>
        <p class="text" id="p0250">
         Here's the code for such a plugin. This plugin defines and registers a new renderer called “opengl.” This is defined in a new
         <span class="inlinecode">
          OpenGLRenderer
         </span>
         class that derives from our
         <span class="inlinecode">
          IRenderer
         </span>
         abstract base class:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0060">
           <img alt="image" height="1974" src="../../IMAGES/B9780443222191000040/main.assets/u15-06-9780443222191.jpg" width="2022"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div id="p0255">
         In this example, I've defined a
         <span class="inlinecode">
          PLUGIN_INIT()
         </span>
         function, which will be run whenever the plugin is loaded. This registers our
         <span class="inlinecode">
          OpenGLRenderer
         </span>
         factory function,
         <span class="inlinecode">
          CreateRenderer()
         </span>
         , and the associated destruction function,
         <span class="inlinecode">
          DestroyRenderer()
         </span>
         . These are both defined using
         <a id="p544">
         </a>
         <span aria-label="544" epub:type="pagebreak" id="pagebreak_544" role="doc-pagebreak">
         </span>
         <span class="inlinecode">
          PLUGIN_FUNC
         </span>
         to ensure that they're correctly exported with C linkage. The
         <span class="inlinecode">
          PLUGIN_FREE()
         </span>
         function will then unregister the renderer when the plugin is unloaded.
        </div>
        <p class="text" id="p0260">
         The
         <span class="inlinecode">
          RegisterRenderer()
         </span>
         function essentially just calls the
         <span class="inlinecode">
          RendererFactory::RegisterRenderer()
         </span>
         method that I presented in the Patterns chapter (with the addition of being able to pass a destruction callback as well as the
         <span class="inlinecode">
          CreateCallback
         </span>
         ). There are a couple of reasons why I added an explicit registration function to the Plugin API rather than letting plugins register themselves directly with the
         <span class="inlinecode">
          RendererFactory
         </span>
         . One reason is simply to give us a layer of abstraction so that you could change
         <span class="inlinecode">
          RendererFactory
         </span>
         in the future without breaking existing plugins. Another reason is to avoid plugins calling methods that use C++ Standard Library strings:
         <span class="inlinecode">
          RegisterRenderer
         </span>
         uses a
         <span class="inlinecode">
          const char ∗
         </span>
         to specify the renderer name.
        </p>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         The Plugin manager
        </h3>
        <p class="textfl" id="p0265">
         Now that you have a Plugin API and you can build plugins against this API, you need to be able to load and register those plugins into the Core API. This is the role of the Plugin Manager. Specifically, the Plugin Manager needs to handle these tasks:
        </p>
        <div>
         <ol id="ulist0030">
          <li class="bulllist" id="p0270">
           <a id="u0115">
           </a>
           ▪ Load metadata for all plugins. These metadata can be either stored in a separate file (such as an XML or JSON file) or embedded within the plugins themselves. In the latter case, the Plugin Manager will need to load all available plugins to collate the metadata for all plugins. These metadata let you present users with a list of available plugins among which they may choose.
          </li>
          <li class="bulllist" id="p0275">
           <a id="u0120">
           </a>
           ▪ Load a dynamic library into memory, provide access to the symbols in that library, and unload the library if necessary. This involves using
           <span class="inlinecode">
            dlopen()
           </span>
           ,
           <span class="inlinecode">
            dlclose()
           </span>
           , and
           <span class="inlinecode">
            dlsym()
           </span>
           on UNIX platforms (including macOS) and
           <span class="inlinecode">
            LoadLibrary()
           </span>
           ,
           <span class="inlinecode">
            FreeLibrary()
           </span>
           , and
           <span class="inlinecode">
            GetProcAddress()
           </span>
           on Windows. I provide details about these calls in Appendix A (Libraries).
          </li>
          <li class="bulllist" id="p0280">
           <a id="u0125">
           </a>
           ▪ Call the plugin's initialization routine when the plugin is loaded and call the cleanup routine when the plugin is unloaded. These are the functions that are defined by
           <span class="inlinecode">
            PLUGIN_INIT()
           </span>
           and
           <span class="inlinecode">
            PLUGIN_FREE()
           </span>
           within the plugin.
          </li>
         </ol>
        </div>
        <p class="text" id="p0285">
         The Plugin Manager provides a single point of access to all plugins in the system; as such it's often implemented as a singleton. In terms of design, the Plugin Manager can be thought of as a collection of plugin instances, in which each plugin instance represents a single plugin and offers functionality to load and unload that plugin. Here's an example implementation for a Plugin Manager:
         <a id="p545">
         </a>
         <span aria-label="545" epub:type="pagebreak" id="pagebreak_545" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0065">
           <img alt="image" height="2283" src="../../IMAGES/B9780443222191000040/main.assets/u15-07-9780443222191.jpg" width="1747"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0290">
         This design decouples the ability to access the metadata for all plugins from the need to load those plugins. That is, if metadata such as the plugin's display name are stored in an external file, you can call
         <span class="inlinecode">
          PluginManager::GetAllPlugins()
         </span>
         without loading the actual plugins. On the other hand, if the metadata are stored in the plugins, then
         <span class="inlinecode">
          GetAllPlugins()
         </span>
         can simply call
         <span class="inlinecode">
          LoadAll()
         </span>
         first. The following example presents a sample external metadata file based upon an XML syntax:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0070">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000040/main.assets/u15-08-9780443222191.jpg" width="1318"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p546">
         </a>
        </p>
        <div>
         <span aria-label="546" epub:type="pagebreak" id="pagebreak_546" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0070">
         </a>
        </section>
        <p class="text" id="p0295">
         Irrespective of the approach to store plugin metadata within an external file or embedded within each plugin, this code outputs the display name for all available plugins:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0075">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000040/main.assets/u15-09-9780443222191.jpg" width="2254"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0300">
         A related issue is that of plugin discovery. The previous API doesn't restrict the ability for the implementation of
         <span class="inlinecode">
          PluginManager::Load()
         </span>
         to search multiple directories to discover all plugins. The name passed to this
         <span class="inlinecode">
          Load()
         </span>
         method can be a base plugin name without any path or file extension, such as “glplugin.” The
         <span class="inlinecode">
          Load()
         </span>
         method can then search various directories and look for files with extensions that may be platform specific, such as
         <span class="inlinecode">
          libglplugin.dylib
         </span>
         on macOS or
         <span class="inlinecode">
          glplugin.dll
         </span>
         on Windows. Of course, you can always introduce your own plugin filename extension. For example, Adobe Illustrator uses the
         <span class="inlinecode">
          .aip
         </span>
         extension for its plugins, and Microsoft Excel uses the
         <span class="inlinecode">
          .xll
         </span>
         extension.
        </p>
        <p class="text" id="p0305">
         The following Core API initialization code registers a single built-in renderer and then loads all plugins, allowing additional renderers to be added to the system at run time:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0080">
           <img alt="image" height="1066" src="../../IMAGES/B9780443222191000040/main.assets/u15-10-9780443222191.jpg" width="2218"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p547">
         </a>
        </p>
        <div>
         <span aria-label="547" epub:type="pagebreak" id="pagebreak_547" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         Plugin versioning
        </h3>
        <p class="textfl" id="p0310">
         As a final note, I will expand on the topic of plugin versioning. As with API versioning, you'll want to make sure that the release of your first plugin system includes a versioning system. You could either coopt the version number of your Core API or you could introduce a specific Plugin API version number. I suggest the latter, because the Plugin API is a separate interface from the Core API and the two may change at different rates. For example, Google's Android API uses the notion of API Level (
         <a href="#t0010" id="Bt0010">
          Table 15.1
         </a>
         ). This is a single integer that increases monotonically with each new version of the Android API.
        </p>
        <p class="text" id="p0315">
         One of the most important pieces of information you'll want to access is the Plugin API version against which a given plugin was built. This can let you determine whether a plugin is incompatible with the current release and therefore shouldn't be registered, such as if the plugin was built with a later version of the API or an incompatible older API. Given the importance of this information, it's advisable to embed this information automatically in every plugin. This ensures that the correct version is always compiled
         <a id="p548">
         </a>
         <span aria-label="548" epub:type="pagebreak" id="pagebreak_548" role="doc-pagebreak">
         </span>
         into the plugin every time it’s successfully rebuilt. With the Plugin API I've proposed, you could include this information in the
         <span class="inlinecode">
          PLUGIN_INIT()
         </span>
         macro, because users must call this for the plugin to do anything. For example:
        </p>
        <div class="pageavoid">
         <p class="tnum">
          <a href="#Bt0010">
           Table 15.1
          </a>
         </p>
         <table class="tbody" id="t0010">
          <caption class="ttitle">
           <a id="tspara0010">
           </a>
           The Android application programming interface (API) Level for each version of the Android platform.
          </caption>
          <thead>
           <tr>
            <th class="tcolhd1" scope="col">
             Platform version
            </th>
            <th class="tcolhd1" scope="col">
             API Level
            </th>
           </tr>
          </thead>
          <tbody>
           <tr>
            <th class="tb" scope="row">
             Android 2.1
            </th>
            <td class="tb_calign">
             7
            </td>
           </tr>
           <tr>
            <th class="tb" scope="row">
             Android 2.0.1
            </th>
            <td class="tb_calign">
             6
            </td>
           </tr>
           <tr>
            <th class="tb" scope="row">
             Android 2.0
            </th>
            <td class="tb_calign">
             5
            </td>
           </tr>
           <tr>
            <th class="tb" scope="row">
             Android 1.6
            </th>
            <td class="tb_calign">
             4
            </td>
           </tr>
           <tr>
            <th class="tb" scope="row">
             Android 1.5
            </th>
            <td class="tb_calign">
             3
            </td>
           </tr>
           <tr>
            <th class="tb" scope="row">
             Android 1.1
            </th>
            <td class="tb_calign">
             2
            </td>
           </tr>
           <tr>
            <th class="tb" scope="row">
             Android 1.0
            </th>
            <td class="tb_calign">
             1
            </td>
           </tr>
          </tbody>
         </table>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000040/main.assets/u15-11-9780443222191.jpg" width="1770"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0320">
         In addition, users can optionally specify a minimum and maximum version of the API with which the plugin will work. The minimum version number will be more commonly specified. For example, if the plugin uses a new feature that was added to the API in a specific release, that release should be specified as the minimum version. Specifying a maximum version number is useful only after a new version of the API has been released and the plugin writer finds that it breaks the plugin. Normally, the maximum version will be unset, because plugin writers should assume that future API releases will be backward compatible.
        </p>
        <p class="text" id="p0325">
         This min/max version number could be specified in an external metadata format, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000040/main.assets/u15-12-9780443222191.jpg" width="1318"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0330">
         Alternatively, you can extend the Plugin API with additional calls to let plugins specify this information in code:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000040/main.assets/u15-13-9780443222191.jpg" width="1560"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p549">
         </a>
        </p>
        <div>
         <span aria-label="549" epub:type="pagebreak" id="pagebreak_549" role="doc-pagebreak">
         </span>
        </div>
       </section>
      </section>
      <section>
       <a id="s0050">
       </a>
       <h2 class="h1hd" id="cesectitle0060">
        Extending via inheritance
       </h2>
       <p class="textfl" id="p0335">
        The focus of this chapter thus far has been supporting API extensibility at run time via plugins. However, there are other ways in which your clients can extend the functionality of your API for their own purposes. The primary object-oriented mechanism for extending a class is inheritance. This can be used to let your users define new classes that build upon and modify the functionality of existing classes in your API.
       </p>
       <section>
        <a id="s0055">
        </a>
        <h3 class="h2hd" id="cesectitle0065">
         Adding functionality
        </h3>
        <p class="textfl" id="p0340">
         Jonathan Wood has a video on Microsoft's Visual C++ Developer Center in which he demonstrates extending MFC's
         <span class="inlinecode">
          CString
         </span>
         class via inheritance to create a
         <span class="inlinecode">
          CPathString
         </span>
         class that adds some path manipulation functions to the basic string class. The resulting class looks something like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000040/main.assets/u15-14-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0345">
         This is a simple example of extending an existing class in which only new methods are added to the base class.
        </p>
        <p class="text" id="p0350">
         An important point to reiterate is that this can be done safely only if the class was designed to be inherited from. The primary indicator for this is whether the class has a virtual destructor. In that example, MFC's
         <span class="inlinecode">
          CString
         </span>
         class does not have a virtual destructor. This means that there are cases when the destructor for
         <span class="inlinecode">
          CPathString
         </span>
         will not be called, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000040/main.assets/u15-15-9780443222191.jpg" width="1074"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0355">
         In this case, this is not an issue because all of the new
         <span class="inlinecode">
          CPathString
         </span>
         methods are stateless; that is, they do not allocate any memory that must be freed by the
         <span class="inlinecode">
          CPathString
         </span>
         destructor. However, this does highlight the issue that if you expect your users to inherit from any of your classes, you should declare the destructor for those classes to be virtual.
         <a id="p550">
         </a>
         <span aria-label="550" epub:type="pagebreak" id="pagebreak_550" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b00100" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b00100">
           <div class="b1textfl" id="bpar00100">
            <i>
             TIP: Declaring a virtual destructor for a class is a signal to your users that you have designed it to be inherited from.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0060">
        </a>
        <h3 class="h2hd" id="cesectitle0070">
         Modifying functionality
        </h3>
        <p class="textfl" id="p0365">
         In addition to adding new member functions to a class, we know that C++ allows you to define functions in a derived class that override existing functions in a base class if they've been marked as virtual in the base class. This can provide even more avenues for your users to customize the behavior of a class if you give them the hooks to do so.
        </p>
        <p class="text" id="p0370">
         For example, all UI widgets in the Qt library provide these virtual methods:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000040/main.assets/u15-16-9780443222191.jpg" width="1316"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0375">
         This allows users of the Qt library to create derived classes of these widgets and change their appearance. To illustrate this, the following class inherits from the standard Qt button widget and overrides the
         <span class="inlinecode">
          sizeHint()
         </span>
         method to specify the preferred size of the button. The result of this can be seen in
         <a href="#f0020" id="Bf0020">
          Fig. 15.3
         </a>
         :
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000040/main.assets/u15-17-9780443222191.jpg" width="1421"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0380">
         This code works because
         <span class="inlinecode">
          sizeHint()
         </span>
         is a known method of every widget and is called by the layout classes to determine the widget's preferred size. That is, the creators of the
         <a id="p551">
         </a>
         <span aria-label="551" epub:type="pagebreak" id="pagebreak_551" role="doc-pagebreak">
         </span>
         Qt library explicitly designed this point of customization into the tool kit and allowed users to modify it in their own derived classes by deliberately declaring the method to be virtual.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0020">
          <img alt="image" height="739" src="../../IMAGES/B9780443222191000040/main.assets/f15-03-9780443222191.jpg" width="1667"/>
          <figcaption class="figleg">
           <a id="cap0020">
           </a>
           <a id="fspara0020">
           </a>
           <span class="fignum">
            <a href="#Bf0020">
             Figure 15.3
            </a>
           </span>
           A standard Qt
           <span class="inlinecode">
            QPushButton
           </span>
           widget (
           <i>
            left
           </i>
           ), and a derived class of
           <span class="inlinecode">
            QPushButton
           </span>
           that overrides the
           <span class="inlinecode">
            sizeHint()
           </span>
           virtual method (
           <i>
            right
           </i>
           ).
          </figcaption>
         </figure>
        </div>
        <p class="text" id="p0385">
         Simply changing the size of the widget by calling the
         <span class="inlinecode">
          resize()
         </span>
         method in the
         <span class="inlinecode">
          MySquareButton
         </span>
         constructor is not the same thing. The effect of this would be to set the size of the button forcibly. However, the point of
         <span class="inlinecode">
          sizeHint()
         </span>
         is to provide an indication of the preferred size to the UI layout engine (i.e., to other classes in the API), so that it can override this size when necessary to satisfy other widget size constraints.
        </p>
        <p class="text" id="p0390">
         This could be implemented without a virtual
         <span class="inlinecode">
          sizeHint()
         </span>
         method. For example, nonvirtual
         <span class="inlinecode">
          setSizeHint()
         </span>
         and
         <span class="inlinecode">
          getSizeHint()
         </span>
         methods could be added to the widget base class. However, this would require the base class to store the hint information as a data member in the object and hence increase the size of every object that inherits from it. In contrast, the use of the
         <span class="inlinecode">
          sizeHint()
         </span>
         virtual method supports the ability for a class to simply calculate the preferred size on each invocation without the need to store the size within the object instance.
        </p>
        <p class="text" id="p0395">
         In the chapter on Performance, I cautioned you to add virtual methods to a class only when you need them. That advice is still valid. In the previous example, the designers of the Qt API added these virtual methods to their API carefully and consciously, to produce a flexible way for their users to extend the base functionality of their classes.
        </p>
       </section>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         Inheritance and the standard library
        </h3>
        <p class="textfl" id="p0400">
         Programmers who are new to C++ and the C++ Standard Library often try to subclass containers, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000040/main.assets/u15-18-9780443222191.jpg" width="1212"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0405">
         However, as I've noted, you should only attempt to derive from a class that defines a virtual destructor. The Standard Library container classes don't provide virtual destructors, and in fact they have no virtual methods for you to override at all. This is a clear indication that these classes were not meant to be inherited from. Attempting to do so could introduce subtle and difficult-to-debug resource leaks into your code and your clients' code. The general rule is therefore that you should never inherit from C++ Standard Library container classes.
         <a id="p552">
         </a>
        </p>
        <div>
         <span aria-label="552" epub:type="pagebreak" id="pagebreak_552" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0410">
         As an alternative, you could use composition to add functionality to a Standard. Library container in a safe manner. That is, use an
         <span class="inlinecode">
          std::string
         </span>
         as a private member and provide accessor methods that thinly wrap the underlying
         <span class="inlinecode">
          std::string
         </span>
         methods. Then you can add your own methods to this class. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0125">
           <img alt="image" height="1066" src="../../IMAGES/B9780443222191000040/main.assets/u15-19-9780443222191.jpg" width="1698"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0415">
         However, the Standard Library does provide a few classes that were designed for inheritance. One of the most obvious of these is
         <span class="inlinecode">
          std::exception
         </span>
         . This is the base class for all Standard Library exceptions, including:
         <span class="inlinecode">
          bad_alloc
         </span>
         ,
         <span class="inlinecode">
          bad_cast
         </span>
         ,
         <span class="inlinecode">
          bad_exception
         </span>
         ,
         <span class="inlinecode">
          bad_typeid
         </span>
         ,
         <span class="inlinecode">
          lock_error
         </span>
         ,
         <span class="inlinecode">
          logic_error
         </span>
         , and
         <span class="inlinecode">
          runtime_error
         </span>
         . You can define your own exceptions that derive from
         <span class="inlinecode">
          std::exception
         </span>
         simply:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0130">
           <img alt="image" height="486" src="../../IMAGES/B9780443222191000040/main.assets/u15-20-9780443222191.jpg" width="1664"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0420">
         Another part of the Standard Library that supports extension through inheritance is the iostream library. This is actually a powerful, well-designed, and extensible API that provides various stream abstractions. A stream can be thought of simply as a sequence of bytes waiting to be processed, such as the standard
         <span class="inlinecode">
          cin
         </span>
         input stream and
         <span class="inlinecode">
          cout
         </span>
         output stream. You can write custom stream classes by deriving from a particular stream class or from the
         <span class="inlinecode">
          streambuf
         </span>
         base class. For example, you could create custom stream classes to send and receive HTTP data to/from a Web server.
         <a id="p553">
         </a>
        </p>
        <div>
         <span aria-label="553" epub:type="pagebreak" id="pagebreak_553" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0425">
         There is also the Boost Iostreams library, which makes it easier to work with Standard Library streams and stream buffers, and provides a framework for defining filters on streams and buffers. The library comes with a collection of handy filters including regular expression filtering and data compression schemes such as zlib, gzip, and bzip2.
        </p>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         Inheritance and enums
        </h3>
        <p class="textfl" id="p0430">
         There are times when your users may want to extend an enum that you define in one of your base classes, such as to add further enumerators for new features that they have added in their derived classes. This can be done easily in C++:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0135">
           <img alt="image" height="1181" src="../../IMAGES/B9780443222191000040/main.assets/u15-21-9780443222191.jpg" width="1005"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0435">
         Here is an example that demonstrates the use of this extended enum:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0140">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000040/main.assets/u15-22-9780443222191.jpg" width="2116"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p554">
         </a>
        </p>
        <div>
         <span aria-label="554" epub:type="pagebreak" id="pagebreak_554" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0440">
         The important part that makes this work robustly is that the
         <span class="inlinecode">
          Base
         </span>
         class defined
         <span class="inlinecode">
          SHAPE_END
         </span>
         , so that the
         <span class="inlinecode">
          Derived
         </span>
         class could add new values after the last value defined by
         <span class="inlinecode">
          Base::SHAPE
         </span>
         . Therefore this is a good practice for you to adopt when defining enums in classes that you expect to be subclassed by your clients. Without this, your clients could pick an arbitrarily large integer to start numbering their enumerators (e.g.,
         <span class="inlinecode">
          OVAL=100)
         </span>
         , although this is a less elegant solution.
        </p>
        <div>
         <aside aria-labelledby="b00105" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b00105">
           <div class="b1textfl" id="bpar00105">
            <i>
             TIP: For enums in a base class, add an enumerator for the last value in the enum, such as &lt;enum-name&gt;_END.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0450">
         You can also do this with C++11's
         <span class="inlinecode">
          enum class
         </span>
         , although an
         <span class="inlinecode">
          enum class
         </span>
         is not implicitly convertible to its underlying type, so you would have to add an explicit cast, such as
         <span class="inlinecode">
          OVAL = static_cast&lt;int&gt;(Base::SHAPE::SHAPE_END) + 1
         </span>
         .
        </p>
       </section>
       <section>
        <a id="s0075">
        </a>
        <h3 class="h2hd" id="cesectitle0085">
         The Visitor pattern
        </h3>
        <p class="textfl" id="p0455">
         We presented various generic design patterns back in
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         (Patterns). However, we deferred discussion of the Visitor design pattern until now because it’s specifically targeted at API extensibility. The core goal of the Visitor pattern is to allow clients to traverse all objects in a data structure and perform a given operation on each of those objects. This pattern is essentially a way to simulate adding new virtual methods to an existing class. It therefore provides a useful pattern for your clients to extend the functionality of your API. For example, a Visitor pattern could be used to let clients provide a set of methods that operate on every node in a scene graph hierarchy or to traverse the derivation tree of a programming language parser and output a human-readable form of the program.
        </p>
        <p class="text" id="p0460">
         Let's develop a Visitor example to illustrate how this pattern works. I'll use the example of a scene graph hierarchy that describes a 3D scene, such as that used by Open Inventor, OpenSceneGraph, or the Virtual Reality Modeling Language. To keep the example simple, our scene graph will contain only three different node types:
         <span class="inlinecode">
          Shape
         </span>
         ,
         <span class="inlinecode">
          Transform
         </span>
         , and
         <span class="inlinecode">
          Light
         </span>
         .
         <a href="#f0025" id="Bf0025">
          Fig. 15.4
         </a>
         shows an example hierarchy using these node types.
         <a id="p555">
         </a>
        </p>
        <div>
         <span aria-label="555" epub:type="pagebreak" id="pagebreak_555" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0025">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0025">
           <img alt="image" height="1712" src="../../IMAGES/B9780443222191000040/main.assets/f15-04-9780443222191.jpg" width="2219"/>
           <figcaption class="figleg">
            <a id="cap0025">
            </a>
            <a id="fspara0025">
            </a>
            <span class="fignum">
             <a href="#Bf0025">
              Figure 15.4
             </a>
            </span>
            Example scene graph hierarchy showing nodes of different types.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0465">
         I'll begin by defining our abstract Visitor interface. Clients can create concrete subclasses of this interface to add custom operations to the scene graph. It essentially declares a
         <span class="inlinecode">
          Visit()
         </span>
         method for each node type in the scene graph:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0145">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000040/main.assets/u15-23-9780443222191.jpg" width="1664"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p556">
         </a>
        </p>
        <div>
         <span aria-label="556" epub:type="pagebreak" id="pagebreak_556" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0470">
         Now let's look at our scene graph API. This provides the declarations for each of our node types, as well as a skeleton
         <span class="inlinecode">
          SceneGraph
         </span>
         class. Each node type derives from a base node type, called
         <span class="inlinecode">
          BaseNode
         </span>
         :
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0150">
           <img alt="image" height="2667" src="../../IMAGES/B9780443222191000040/main.assets/u15-24-9780443222191.jpg" width="1497"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p557">
         </a>
        </p>
        <div>
         <span aria-label="557" epub:type="pagebreak" id="pagebreak_557" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0030">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="1374" src="../../IMAGES/B9780443222191000040/main.assets/f15-05-9780443222191.jpg" width="2487"/>
           <figcaption class="figleg">
            <a id="cap0030">
            </a>
            <a id="fspara0030">
            </a>
            <span class="fignum">
             <a href="#Bf0030">
              Figure 15.5
             </a>
            </span>
            UML diagram of the visitor design pattern.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0475">
         Each node type declares an
         <span class="inlinecode">
          Accept()
         </span>
         method, taking a Visitor object as its parameter. This method is used to call the appropriate
         <span class="inlinecode">
          Visit()
         </span>
         method in the Visitor class. This can be thought of as a way to have a single virtual method in each node that can then call any user-supplied virtual method.
         <a href="#f0030" id="Bf0030">
          Fig. 15.5
         </a>
         portrays a unified modeling language (UML) diagram that shows this Visitor pattern:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0155">
           <img alt="image" height="891" src="../../IMAGES/B9780443222191000040/main.assets/u15-25-9780443222191.jpg" width="1698"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0480">
         Building upon this infrastructure, the
         <span class="inlinecode">
          SceneGraph::Traverse()
         </span>
         method can be implemented by navigating the scene graph hierarchy and then calling the
         <span class="inlinecode">
          Accept()
         </span>
         method for every node in the graph. Your clients can then define custom Visitor classes to perform arbitrary operations on the scene graph. This is done without exposing details about how the scene graph is implemented. For example, the next code demonstrates
         <a id="p558">
         </a>
         <span aria-label="558" epub:type="pagebreak" id="pagebreak_558" role="doc-pagebreak">
         </span>
         how a client could write a Visitor to count the number of each node type in the scene graph and sum the polygon count for all shape nodes in the scene graph:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0160">
           <img alt="image" height="2069" src="../../IMAGES/B9780443222191000040/main.assets/u15-26-9780443222191.jpg" width="1928"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0485">
         This example demonstrates many of the benefits of the Visitor pattern. The most relevant benefit to the topic of extensibility is that clients can effectively plug in their own methods into your class hierarchy. Other benefits include the colocation of all code that performs a single coherent operation. For example, all of the code that implements the node counting functionality in that example is contained with the single
         <span class="inlinecode">
          MyVisitor
         </span>
         class rather than being distributed across all individual node classes. A further benefit is that the state required to count the various nodes and the number of polygons (
         <span class="inlinecode">
          mNumShapes
         </span>
         ,
         <span class="inlinecode">
          mNumPolygons
         </span>
         ,
         <span class="inlinecode">
          mNumTransforms
         </span>
         , and
         <span class="inlinecode">
          mNumLights
         </span>
         ) is isolated in the
         <span class="inlinecode">
          MyVisitor
         </span>
         <a id="p559">
         </a>
         <span aria-label="559" epub:type="pagebreak" id="pagebreak_559" role="doc-pagebreak">
         </span>
         class rather than being stored directly in the
         <span class="inlinecode">
          SceneGraph
         </span>
         object, and hence increasing the size of it.
        </p>
        <p class="text" id="p0490">
         However, there are some significant downsides to the Visitor pattern, too. The flexibility of being able to add new methods to a related set of classes comes at the cost of making it more difficult to add new related classes. In
         <span class="inlinecode">
          visitor.h
         </span>
         , the visitor interface must know about every class that can be visited (i.e., all of our node types). Therefore, adding a new node type to our scene graph will require the Visitor interface also to be updated. As a result, the Visitor pattern is most appropriately used in cases where the class hierarchy is stable (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib3" id="bib_3">
          Alexandrescu, 2001
         </a>
         ).
        </p>
        <p class="text" id="p0495">
         To address this problem, let's consider adding a new node type, called
         <span class="inlinecode">
          CameraNode
         </span>
         , to our scene graph. The naive way to do this would be to add another
         <span class="inlinecode">
          Visit()
         </span>
         pure virtual method to the
         <span class="inlinecode">
          INodeVisitor
         </span>
         interface that accepts a
         <span class="inlinecode">
          CameraNode
         </span>
         reference. However, we know that adding a pure virtual method to an interface is a bad thing to do in terms of API backward compatibility, because it will break all existing client code. Instead, there are a couple of alternative ways to solve this problem:
        </p>
        <div>
         <ul class="ce_list" id="olist0020">
          <li class="numlist" id="p0500">
           <a id="o0035">
           </a>
           1. Thinking ahead, you could release the first version of
           <span class="inlinecode">
            INodeVisitor
           </span>
           with a
           <span class="inlinecode">
            Visit()
           </span>
           pure virtual method for
           <span class="inlinecode">
            BaseNode
           </span>
           . This will effectively become a catch-all method that will be called if a node type is encountered for which there is not an explicit
           <span class="inlinecode">
            Visit()
           </span>
           method. The inelegant consequence of this is that users must use a sequence of
           <span class="inlinecode">
            dynamic_cast
           </span>
           calls inside this catch-all method to work out which node type has been passed in. Adopting this solution would change the visitor interface as follows:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0165">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000040/main.assets/u15-27-9780443222191.jpg" width="1978"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0025">
          <li class="numlist" id="p0505">
           <a id="o0040">
           </a>
           2. A better solution is to add a new
           <span class="inlinecode">
            Visit()
           </span>
           virtual method for the new node type, instead of a pure virtual method. That is, you provide an empty implementation for the new method so that existing code will continue to compile, while allowing
           <a id="p560">
           </a>
           <span aria-label="560" epub:type="pagebreak" id="pagebreak_560" role="doc-pagebreak">
           </span>
           users to implement a type-safe
           <span class="inlinecode">
            Visit()
           </span>
           method for the new node type where appropriate. This would change the
           <span class="inlinecode">
            INodeVisitor
           </span>
           interface thus:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0170">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000040/main.assets/u15-28-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
      </section>
      <section>
       <a id="s0080">
       </a>
       <h2 class="h1hd" id="cesectitle0090">
        Extending via templates
       </h2>
       <p class="textfl" id="p0510">
        C++ is often referred to as a multiparadigm language because it supports different styles of programming, such as procedural, object-oriented, and generic programming. Inheritance is the primary way to extend classes using object-oriented concepts. However, when programming with templates, the default way to extend an interface is to specialize a template with concrete types.
       </p>
       <p class="text" id="p0515">
        For example, the C++ Standard Library provides various container classes, such as
        <span class="inlinecode">
         std::vector
        </span>
        and
        <span class="inlinecode">
         std::set
        </span>
        . You can use these container classes to create data structures that contain arbitrary data types, such as
        <span class="inlinecode">
         std::vector&lt;MyCustomClass ∗&gt;
        </span>
        , which the creators of the Standard Library had no way of knowing about when they designed the library.
       </p>
       <p class="text" id="p0520">
        Similarly, the Standard Library provides the ability to create reference-counted pointers that can hold any pointer type, without having to resort to using
        <span class="inlinecode">
         void ∗
        </span>
        . This provides a powerful and generic facility that can be customized by clients to create type-safe shared pointers to any object, such as
        <span class="inlinecode">
         std::shared_ptr&lt;MyCustomClass&gt;
        </span>
        .
       </p>
       <p class="text" id="p0525">
        Templates therefore offer an excellent way for you to write extensible code that can be applied to many different types, including types that your clients define in their own code. In the next couple of sections, I will present the concept of policy-based templates to help you maximize the flexibility of your class templates. I will also investigate a curiously common template pattern that provides static polymorphism as an alternative to the dynamic polymorphism of object-oriented programming.
       </p>
       <section>
        <a id="s0085">
        </a>
        <h3 class="h2hd" id="cesectitle0095">
         Policy-based templates
        </h3>
        <p class="textfl" id="p0530">
         Andrei Alexandrescu popularized the use of policy-based templates in his book
         <i>
          Modern C++ Design
         </i>
         in 2001. The term refers to the approach of building complex behaviors out
         <a id="p561">
         </a>
         <span aria-label="561" epub:type="pagebreak" id="pagebreak_561" role="doc-pagebreak">
         </span>
         of smaller classes, called policy classes, each of which define the interface for a single aspect of the overall component. This concept is implemented using class templates that accept several template parameters (often template template parameters), instantiated with classes that conform to the interface for each policy. By plugging in different policy classes, you can produce an exponentially large number of concrete classes.
        </p>
        <p class="text" id="p0535">
         For example, Alexandrescu presents this design for a smart pointer class template that accepts several policy classes to customize its behavior (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib3">
          Alexandrescu, 2001
         </a>
         ):
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0175">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000040/main.assets/u15-29-9780443222191.jpg" width="2082"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0540">
         The type that
         <span class="inlinecode">
          SmartPtr
         </span>
         points toward is represented by the template parameter
         <span class="inlinecode">
          T
         </span>
         . The remaining parameters specify various policies, or behaviors, for the smart pointer. These can be instantiated with classes that conform to a defined interface for each parameter and provide alternative implementations for the smart pointer. Here's an overview of each parameter's purpose:
        </p>
        <div>
         <ol id="ulist0035">
          <li class="bulllist" id="p0545">
           <a id="u0130">
           </a>
           •
           <b>
            OwnershipPolicy
           </b>
           : Specifies the ownership model for the smart pointer. Predefined policy classes include
           <span class="inlinecode">
            RefCounted
           </span>
           ,
           <span class="inlinecode">
            DeepCopy
           </span>
           , and
           <span class="inlinecode">
            NoCopy
           </span>
           .
          </li>
          <li class="bulllist" id="p0550">
           <a id="u0135">
           </a>
           •
           <b>
            ConversionPolicy
           </b>
           : Determines whether implicit conversion to the type of the object being pointed to is allowed. The two available classes are
           <span class="inlinecode">
            AllowConversion
           </span>
           and
           <span class="inlinecode">
            DisallowConversion
           </span>
           .
          </li>
          <li class="bulllist" id="p0555">
           <a id="u0140">
           </a>
           •
           <b>
            CheckingPolicy
           </b>
           : Specifies the error checking strategy. The predefined policy classes for this parameter include
           <span class="inlinecode">
            AssertCheck
           </span>
           ,
           <span class="inlinecode">
            RejectNull
           </span>
           , and
           <span class="inlinecode">
            NoCheck
           </span>
           .
          </li>
          <li class="bulllist" id="p0560">
           <a id="u0145">
           </a>
           •
           <b>
            StoragePolicy
           </b>
           : Defines how the object being pointed to is stored and accessed, including
           <span class="inlinecode">
            DefaultSPStorage
           </span>
           ,
           <span class="inlinecode">
            ArrayStorage
           </span>
           , and
           <span class="inlinecode">
            HeapStorage
           </span>
           .
          </li>
         </ol>
        </div>
        <p class="text" id="p0565">
         Policy-based design recognizes that there is a multiplicity of solutions for every problem in computer science. The use of these generic components means that clients can choose among literally thousands of solutions simply by supplying different combinations of policy classes at compile time.
        </p>
        <p class="text" id="p0570">
         The first step in creating your own policy-based templates is to decompose a class into orthogonal parts. Anything that can be done in multiple ways is a candidate for factoring out as a policy. Policies that depend upon each other are also candidates for further decomposition or redesign. There is, of course, nothing new here. The essence of good software engineering is being able to recognize the more general and flexible abstraction for a particular problem.
         <a id="p562">
         </a>
        </p>
        <div>
         <span aria-label="562" epub:type="pagebreak" id="pagebreak_562" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0575">
         Taken to the extreme, a host class (as policy-based templates are often called) becomes a shell that simply assembles a collection of policies to produce aggregate behavior. However, Alexandrescu states that you should try to keep the number of policy classes small for any given host class, because it becomes awkward to work with more than four to six template parameters. This correlates well with the cognitive limit of our working memory, which is believed to be 7
         <span title='hsp="0.25"'>
         </span>
         ±
         <span title='hsp="0.25"'>
         </span>
         2 (Miller, 1956).
        </p>
        <p class="text" id="p0580">
         It is also useful to provide typedefs for specific combinations of policy classes that you use for a given task. For example, if your API passes around smart pointers that uses nondefault policies, it would be tedious to have to specify all of those parameters all of the time, and changing those policies in the future would require your clients to update all of their code accordingly. Instead, you can introduce a typedef for the specific pointer type, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0180">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000040/main.assets/u15-30-9780443222191.jpg" width="1874"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0090">
        </a>
        <h3 class="h2hd" id="cesectitle0100">
         The curiously recurring template pattern
        </h3>
        <p class="textfl" id="p0585">
         In this final section on extensibility via templates, I will present an interesting C++ idiom that was first observed by James Coplien in early template code (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib22" id="bib_22">
          Coplien, 1995
         </a>
         ) and which may prove useful in your own API designs. The Curiously Recurring Template Pattern (CRTP) involves a template class that inherits from a base class using itself as a template parameter. Said differently (perhaps to make that last sentence clearer), it's when a base class is templated on the type of its derived class. This provides the fascinating quality that the base class can access the namespace of its derived class. The general form of this pattern is:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0185">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000040/main.assets/u15-31-9780443222191.jpg" width="1283"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0590">
         The CRTP is essentially just a way to provide compile-time polymorphism. That is, it allows you to inherit an interface from a base class, but to avoid the overhead of virtual method calls at run time. In this way, it can be thought of as a “mixin” class (i.e., an interface class with implemented methods).
        </p>
        <p class="text" id="p0595">
         As a practical example of this pattern, the CRTP can be used to track statistics for each specialization of a template. For example, you can use it track a count of all existing objects of a given type, or the total amount of memory occupied by all existing objects of a given type. I will demonstrate the latter.
         <a id="p563">
         </a>
        </p>
        <div>
         <span aria-label="563" epub:type="pagebreak" id="pagebreak_563" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0600">
         This class provides the base class declaration for our memory tracker interface:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0190">
           <img alt="image" height="1123" src="../../IMAGES/B9780443222191000040/main.assets/u15-32-9780443222191.jpg" width="2080"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0605">
         For completeness, I also provide the associated definitions for this base class:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0195">
           <img alt="image" height="1849" src="../../IMAGES/B9780443222191000040/main.assets/u15-33-9780443222191.jpg" width="2159"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p564">
         </a>
        </p>
        <div>
         <span aria-label="564" epub:type="pagebreak" id="pagebreak_564" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0610">
         The clever part is the line directly after comment marked [∗]. Here, the base class is accessing details of the derived class, in this case the size of the derived class. However, in a different example, it could just as easily call a method in the derived class.
        </p>
        <p class="text" id="p0615">
         Now you can derive from this
         <span class="inlinecode">
          MemoryTracker
         </span>
         class, using the CRTP, to keep track of all memory currently consumed by a certain class. This can even be used to track memory use of individual template specializations, as the next example shows. All of these derived classes will essentially inherit the
         <span class="inlinecode">
          BytesUsed()
         </span>
         method from our previous base class, but significantly, the method will be bound at compile time, not run time:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0200">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000040/main.assets/u15-34-9780443222191.jpg" width="1873"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0620">
         This code will print out the values 8, 4, and 12, assuming a 32-bit system in which
         <span class="inlinecode">
          sizeof(MyClass1)
         </span>
         ==
         <span class="inlinecode">
          sizeof(MyClass2)
         </span>
         == 4 bytes. That is, there are two instances of
         <span class="inlinecode">
          MyClass1&lt;char&gt;
         </span>
         (8 bytes), one instance of
         <span class="inlinecode">
          MyClass1&lt;wchar_t&gt;
         </span>
         (4 bytes), and three instances of
         <span class="inlinecode">
          MyClass2
         </span>
         (12 bytes).
        </p>
       </section>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
