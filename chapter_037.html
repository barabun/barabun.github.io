<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   25Customizing and Extending the Standard Library
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_036.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_038.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c25_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c25_1">
      <span aria-label="909" epub:type="pagebreak" id="Page_909" role="doc-pagebreak">
      </span>
      <span id="c25">
      </span>
      <span class="chapterNumber">
       25
      </span>
      <br/>
      <span class="chapterTitle">
       Customizing and Extending the Standard Library
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c25-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c25-list-0001">
         <li id="c25-li-0001">
          What allocators are
         </li>
         <li id="c25-li-0002">
          How to write Standard Library–compliant custom algorithms, containers, and iterators
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c25-fea-0001">
        </span>
        <h3 id="head-2-252">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c25-sec-0003">
        </span>
        <p id="c25-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <a href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p>
      <a href="c16.xhtml">
       Chapters 16
      </a>
      , “Overview of the C++ Standard Library,”
      <a href="c18.xhtml">
       18
      </a>
      , “Standard Library Containers,” and
      <a href="c20.xhtml">
       20
      </a>
      , “Mastering Standard Library Algorithms,” show that the Standard Library contains a powerful general-purpose collection of containers and algorithms. The information covered so far should be sufficient for most applications. However, those chapters show only the functionality of the library that is available out of the box. The Standard Library can be customized and extended however you like. For example, you can write your own Standard Library–compliant containers, algorithms, and iterators, compatible with existing Standard Library functionality. You can even specify your own memory allocation schemes for containers to use. This chapter provides a taste of these advanced features, primarily through the development of a
      <code>
       find_all
      </code>
      (
      <code>
       )
      </code>
      algorithm and a
      <code>
       directed_graph
      </code>
      container.
      <span aria-label="910" epub:type="pagebreak" id="Page_910" role="doc-pagebreak">
      </span>
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c25-para-0005">
         <b>
          NOTE
         </b>
         <i>
          Customizing and extending the Standard Library is rarely necessary. If you're happy with the existing Standard Library containers and algorithms, you can skip this chapter. However, if you really want to understand the Standard Library, not just use it, give this chapter a chance. You should be comfortable with the operator-overloading material from
          <a href="c15.xhtml">
           Chapter 15
          </a>
          , “Overloading C++ Operators,” and because this chapter uses templates extensively, you should also be comfortable with the template material from
          <a href="c12.xhtml">
           Chapter 12
          </a>
          , “Writing Generic Code with Templates,” before continuing
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-253">
     <span id="c25-sec-0005">
     </span>
     <h2 id="head-2-253">
      ALLOCATORS
     </h2>
     <p>
      Every Standard Library container takes an
      <code>
       Allocator
      </code>
      type as a template type parameter, for which the default usually suffices. For example, the
      <code>
       vector
      </code>
      template definition looks like this:
     </p>
     <pre id="c25-code-0001"><code>template &lt;class T, <b>class Allocator = allocator&lt;T&gt;&gt;</b> class vector;</code></pre>
     <p id="c25-para-0007">
      The container constructors then allow you to pass in an object of type
      <code>
       Allocator
      </code>
      . This permits you to customize the way the containers allocate memory. Every memory allocation performed by a container is made with a call to the
      <code>
       allocate
      </code>
      (
      <code>
       )
      </code>
      member function of the
      <code>
       Allocator
      </code>
      object. Conversely, every deallocation is performed with a call to the
      <code>
       deallocate()
      </code>
      member function of the
      <code>
       Allocator
      </code>
      object. When a Standard Library container takes an
      <code>
       Allocator
      </code>
      parameter, that parameter always defaults to
      <code>
       std::allocator&lt;T&gt;
      </code>
      if not provided. The
      <code>
       allocate()
      </code>
      and
      <code>
       deallocate()
      </code>
      member functions of
      <code>
       std::allocator&lt;T&gt;
      </code>
      are simple wrappers around
      <code>
       new
      </code>
      and
      <code>
       delete
      </code>
      .
     </p>
     <p>
      Keep in mind that
      <code>
       allocate()
      </code>
      simply allocates a big-enough block of uninitialized memory and does not call any object constructor. Similarly,
      <code>
       deallocate()
      </code>
      simply frees the memory block and does not call any destructor. Once a memory block has been allocated, a placement
      <code>
       new
      </code>
      operator (see
      <a href="c15.xhtml">
       Chapter 15
      </a>
      ) can be used to construct an object in place. The following code snippet shows a contrived example.
      <a href="c29.xhtml">
       Chapter 29
      </a>
      , “Writing Efficient C++,” shows a more realistic use of an allocator for the implementation of an object pool.
     </p>
     <pre id="c25-code-0002"><code>class MyClass {};</code>
<code>int main()</code>
<code>{</code>
<code>    <span class="color3">// Create an allocator to use.</span></code>
<code>    std::allocator&lt;MyClass&gt; alloc;</code>
<code>    <span class="color3">// Allocate an uninitialized memory block for 1 instance of MyClass.</span></code>
<code>    auto* memory { alloc.allocate(1) };</code>
<code>    <span class="color3">// Use placement new operator to construct a MyClass in place.</span></code>
<code>    ::new (memory) MyClass{};</code>
<code>    <span class="color3">// Destroy MyClass instance.</span></code>
<code>    std::destroy_at(memory);</code>
<code>    <span class="color3">// Deallocate memory block.</span></code>
<code>    alloc.deallocate(memory, 1);</code>
<code>    memory = nullptr;</code></pre>
     <pre id="c25-code-0003"><code>}</code></pre>
     <p id="c25-para-0009">
      <span aria-label="911" epub:type="pagebreak" id="Page_911" role="doc-pagebreak">
      </span>
      If you want containers in your program to use a custom memory allocation and deallocation scheme, you can write your own
      <code>
       Allocator
      </code>
      class. There are several reasons for using custom allocators. For example, if the underlying allocator has unacceptable performance, there are alternatives. When OS-specific capabilities, such as shared memory segments, must be allocated, using custom allocators allows the use of Standard Library containers in those shared memory segments. The use of custom allocators is complex, and there are many potential problems if you are not careful, so this should not be approached lightly.
     </p>
     <p id="c25-para-0010">
      Any class that provides
      <code>
       allocate()
      </code>
      ,
      <code>
       deallocate()
      </code>
      , and several other required member functions and type aliases can be used in place of the default
      <code>
       allocator
      </code>
      class.
     </p>
     <p id="c25-para-0011">
      Additionally, the Standard Library has the concept of
      <i>
       polymorphic memory allocators
      </i>
      . Basically, the problem with the allocator for a container being specified as a template type parameter is that two containers that are similar but have different allocator types are completely different types. For example,
      <code>
       vector&lt;int, A1&gt;
      </code>
      and
      <code>
       vector&lt;int, A2&gt;
      </code>
      are different and so cannot, e.g., be assigned to one another.
     </p>
     <p id="c25-para-0012">
      The polymorphic memory allocators, defined in
      <code>
       &lt;memory_resource&gt;
      </code>
      in the
      <code>
       std::pmr
      </code>
      namespace, help to solve this problem. The class
      <code>
       std::pmr::polymorphic_allocator
      </code>
      is a proper
      <code>
       Allocator
      </code>
      class because it satisfies all the allocator requirements, such as having
      <code>
       allocate()
      </code>
      and
      <code>
       deallocate()
      </code>
      member functions. The allocation behavior of a
      <code>
       polymorphic_allocator
      </code>
      depends on the
      <code>
       memory_resource
      </code>
      it's given during construction, and not on any template type parameters. As such, different
      <code>
       polymorphic_allocator
      </code>
      s can behave in completely different ways when allocating and deallocating memory, even though they all have the same type, that is,
      <code>
       polymorphic_allocator
      </code>
      . The standard provides some built-in memory resources that you can use to initialize a polymorphic memory allocator:
      <code>
       synchronized_pool_resource
      </code>
      ,
      <code>
       unsynchronized_pool_resource
      </code>
      , and
      <code>
       monotonic_buffer_resource
      </code>
      . The Standard Library also provides template type aliases such as
      <code>
       std::pmr::vector&lt;T&gt;
      </code>
      for
      <code>
       std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;
      </code>
      . An
      <code>
       std::pmr::vector&lt;T&gt;
      </code>
      is still a different type from
      <code>
       std::vector&lt;T&gt;
      </code>
      and cannot be assigned from
      <code>
       std::vector&lt;T&gt;
      </code>
      . But an
      <code>
       std::pmr::vector&lt;T&gt;
      </code>
      affiliated with one memory resource is the same type as, and can be assigned from, a second
      <code>
       std::pmr::vector&lt;T&gt;
      </code>
      object affiliated with a different memory resource.
     </p>
     <p id="c25-para-0013">
      However, in my experience, both custom allocators and polymorphic memory allocators are rather advanced and rarely used features in day-to-day coding. I've never used them myself, so a detailed discussion falls outside the scope of this book. For more information, consult one of the books listed in
      <a href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography,” that specifically covers the C++ Standard Library.
     </p>
    </section>
    <section aria-labelledby="head-2-254">
     <span id="c25-sec-0006">
     </span>
     <h2 id="head-2-254">
      EXTENDING THE STANDARD LIBRARY
     </h2>
     <p>
      The Standard Library includes many useful containers, algorithms, and iterators that you can use in your applications. It is impossible, however, for any library to include all possible utilities that all potential clients might need. Thus, the best libraries are extensible: they allow clients to adapt and add to the basic capabilities to obtain exactly the functionality they require. The Standard Library is inherently extensible because of its fundamental structure of separating data from the algorithms
      <span aria-label="912" epub:type="pagebreak" id="Page_912" role="doc-pagebreak">
      </span>
      that operate on them. You can write your own containers that can work with the Standard Library algorithms by providing iterators that conform to the Standard Library guidelines. Similarly, you can write your own algorithms that work with iterators from the standard containers. Keep in mind, though, that you are not allowed to put your own containers and algorithms in the
      <code>
       std
      </code>
      namespace.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c25-para-0015">
         <b>
          NOTE
         </b>
         <i>
          This book usually uses the convention to name functions and member functions without any underscores and where each word of the name is capitalized, except for the first word, for example:
         </i>
         <code>
          getIndex()
         </code>
         <i>
          . However, this chapter talks about extending the Standard Library, hence it uses the naming conventions used by the Standard Library. This means function and member function names are all lowercase with underscores separating the words, for example
         </i>
         <code>
          get_index()
         </code>
         <i>
          . Class names are also using the Standard Library naming conventions.
         </i>
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <span id="c25-sec-0008">
      </span>
      <h3 id="head-3-476">
       Why Extend the Standard Library?
      </h3>
      <p id="c25-para-0016">
       If you sit down to write an algorithm or container in C++, you can either make it adhere to the Standard Library conventions or not. For simple containers and algorithms, it might not be worth the extra effort to follow the Standard Library requirements. However, for substantial code that you plan to reuse, the effort pays off. First, the code will be easier for other C++ programmers to understand, because you follow well-established interface guidelines. Second, you will be able to use your container or algorithm with the other parts of the Standard Library (algorithms or containers) without needing to provide special hacks or adapters. Finally, it will force you to employ the necessary rigor required to develop solid code.
      </p>
     </section>
     <section>
      <span id="c25-sec-0009">
      </span>
      <h3 id="head-3-477">
       Writing a Standard Library Algorithm
      </h3>
      <p id="c25-para-0017">
       <a href="c16.xhtml">
        Chapters 16
       </a>
       and
       <a href="c20.xhtml">
        20
       </a>
       describe a useful set of algorithms that is part of the Standard Library, but you will inevitably encounter situations in your programs for which you need new algorithms. When that happens, it is usually not difficult to write your own algorithm that works with Standard Library iterators just like the standard algorithms.
      </p>
      <section>
       <span id="c25-sec-0010">
       </span>
       <h4 id="head-4-362">
        find_all
       </h4>
       <p id="c25-para-0018">
        Suppose you want to find all elements, including their position, matching a predicate in a given range. The
        <code>
         find()
        </code>
        and
        <code>
         find_if()
        </code>
        algorithms are the most likely candidates, but each returns an iterator referring to only one element. You can use
        <code>
         copy_if()
        </code>
        to find all elements matching a given predicate, but it fills the output with copies of the found elements, so you lose their position. If you want to avoid copies, you can use
        <code>
         copy_if()
        </code>
        with a
        <code>
         back_insert_iterator
        </code>
        (see
        <a href="c17.xhtml">
         Chapter 17
        </a>
        , “Understanding Iterators and the Ranges Library”) into a
        <code>
         vector&lt;reference:wrapper&lt;T&gt;&gt;
        </code>
        , but this does not give you the position of the found elements either. In fact, there is no standard algorithm to get iterators to all the elements matching a predicate. However, you can write your own version of this functionality called
        <code>
         find_all()
        </code>
        .
       </p>
       <p id="c25-para-0019">
        <span aria-label="913" epub:type="pagebreak" id="Page_913" role="doc-pagebreak">
        </span>
        In this first section, we'll look at an implementation of
        <code>
         find_all()
        </code>
        following the model of legacy unconstrained algorithms. Once that implementation is working, we'll see how it can be extended and adapted to follow the model of modern constrained algorithms by adding support for projections and more.
       </p>
       <p>
        The first task is to define the function prototype. You can follow the model established by
        <code>
         copy_if()
        </code>
        , that is, a function template with three template type parameters: the input iterator type, the output iterator type, and the predicate type. The parameters of the function are start and end iterators of the input sequence, a start iterator of the output sequence, and a predicate object. As with
        <code>
         copy_if()
        </code>
        , the algorithm returns an iterator into the output sequence that is one-past-the-last element stored in the output sequence. Of course, in modern C++ code, it's recommended to add proper constraints to template type parameters, so let's follow that advice. Here is the prototype:
       </p>
       <pre id="c25-code-0004"><code>template &lt;forward_iterator ForwardIterator,</code>
<code>          output_iterator&lt;ForwardIterator&gt; OutputIterator,</code>
<code>          indirect_unary_predicate&lt;ForwardIterator&gt; Predicate&gt;</code>
<code>OutputIterator find_all(ForwardIterator first, ForwardIterator last,</code>
<code>                        OutputIterator dest, Predicate pred);</code></pre>
       <p id="c25-para-0021">
        The
        <code>
         forward_iterator
        </code>
        concept specifies that an iterator must be dereferenceable and incrementable, among others. The
        <code>
         output_iterator&lt;ForwardIterator&gt;
        </code>
        concept requires that an iterator is an output iterator that accepts values of type
        <code>
         ForwardIterator
        </code>
        . The
        <code>
         indirect_unary_predicate
        </code>
        concept is a predefined set of requirements that algorithms can use to specify the requirements for unary predicate arguments. It's “indirect” because the requirements are applied to the type that its template type parameter,
        <code>
         ForwardIterator
        </code>
        in this case, refers to, and not to
        <code>
         ForwardIterator
        </code>
        itself.
       </p>
       <p id="c25-para-0022">
        Another design choice would be to omit the output iterator and return an iterator into the input sequence that iterates over all the matching elements in the input sequence. This would require you to write your own iterator class, which is discussed later in this chapter.
       </p>
       <p>
        The next task is to write the implementation. The
        <code>
         find_all()
        </code>
        algorithm iterates over all elements in the input sequence, uses
        <code>
         invoke()
        </code>
        to call the predicate on each element, and stores iterators of matching elements in the output sequence. Here is the implementation:
       </p>
       <pre id="c25-code-0005"><code>template &lt;forward_iterator ForwardIterator,</code>
<code>          output_iterator&lt;ForwardIterator&gt; OutputIterator,</code>
<code>          indirect_unary_predicate&lt;ForwardIterator&gt; Predicate&gt;</code>
<code>OutputIterator find_all(ForwardIterator first, ForwardIterator last,</code>
<code>                        OutputIterator dest, Predicate pred) </code>
<code>{</code>
<code>    while (first != last) {</code>
<code>        if (invoke(pred, *first)) { </code>
<code>            *dest = first;</code>
<code>            ++dest;</code>
<code>        }</code>
<code>        ++first;</code>
<code>    }</code>
<code>    return dest;</code>
<code>}</code></pre>
       <p>
        Similar to
        <code>
         copy_if()
        </code>
        , the algorithm only overwrites existing elements in the output sequence, so make sure the output sequence is large enough to hold the result, or use an iterator adapter such as
        <span aria-label="914" epub:type="pagebreak" id="Page_914" role="doc-pagebreak">
        </span>
        <code>
         back_insert_iterator
        </code>
        , as demonstrated in the following code. After finding all matching elements, the code counts the number of elements found, which is the number of iterators in
        <code>
         matches
        </code>
        . Then, it iterates through the result, printing each element.
       </p>
       <pre id="c25-code-0006"><code>vector&lt;int&gt; vec { 5, 4, 5, 4, 10, 6, 5, 8, 10 }; </code>
<code>vector&lt;vector&lt;int&gt;::iterator&gt; matches;</code>
<code> </code>
<code>find_all(begin(vec), end(vec), back_inserter(matches),</code>
<code>    [](int i){ return i == 10; });</code>
<code> </code>
<code>println("Found {} matching elements: ", matches.size());</code>
<code>for (const auto&amp; it : matches) {</code>
<code>    println("{} at position {}", *it, distance(begin(vec), it));</code>
<code>}</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c25-code-0007"><code>Found 2 matching elements:</code>
<code>10 at position 4</code>
<code>10 at position 8</code></pre>
      </section>
      <section>
       <span id="c25-sec-0011">
       </span>
       <h4 id="head-4-363">
        Modernized find_all
       </h4>
       <p>
        As
        <a href="c17.xhtml">
         Chapter 17
        </a>
        explains, most constrained algorithms accept a projection parameter. The
        <code>
         find_all()
        </code>
        algorithm can be modernized to support such a projection parameter. Additionally, constrained algorithms usually don't have a begin and end iterator of the same type. Instead, the begin iterator is as usual, but the end marker can be of a different type and is then called a
        <i>
         sentinel
        </i>
        . Here is the updated algorithm:
       </p>
       <pre id="c25-code-0008"><code>template &lt;forward_iterator ForwardIterator,</code>
<code>    sentinel_for&lt;ForwardIterator&gt; Sentinel,</code>
<code>    output_iterator&lt;ForwardIterator&gt; OutputIterator,</code>
<code>    typename Projection = std::identity,</code>
<code>    indirect_unary_predicate&lt;projected&lt;ForwardIterator, Projection&gt;&gt; Predicate&gt;</code>
<code>OutputIterator find_all(ForwardIterator first, Sentinel last,</code>
<code>                        OutputIterator dest, Predicate pred, Projection proj = {})</code>
<code>{</code>
<code>    while (first != last) {</code>
<code>        if (invoke(pred, invoke(proj, *first))) {</code>
<code>            *dest = first;</code>
<code>            ++dest;</code>
<code>        }</code>
<code>        ++first;</code>
<code>    }</code>
<code>    return dest;</code>
<code>}</code></pre>
       <p id="c25-para-0027">
        The
        <code>
         sentinel_for
        </code>
        constraint ensures that the expression
        <code>
         first != last
        </code>
        is valid. The
        <code>
         Projection
        </code>
        template type parameter is new and has a default value, the
        <code>
         identity
        </code>
        operation. The template type argument for
        <code>
         indirect_unary_predicate
        </code>
        changed slightly to
        <code>
         projected&lt;ForwardIterator,Projection&gt;
        </code>
        , which represents the type of applying the
        <code>
         Projection
        </code>
        function to a dereferenced
        <code>
         ForwardIterator
        </code>
        .
       </p>
       <p>
        <span aria-label="915" epub:type="pagebreak" id="Page_915" role="doc-pagebreak">
        </span>
        The modernized
        <code>
         find_all()
        </code>
        can be tested as follows:
       </p>
       <pre id="c25-code-0009"><code>find_all(begin(vec), end(vec), back_inserter(matches),</code>
<code>    [](int i) { return i == 10; },</code>
<code>    [](int i) { return i * 2; });</code></pre>
       <p>
        This invocation of
        <code>
         find_all()
        </code>
        is similar to the one from the previous section, except that it now includes a projection. For each element, the algorithm first transforms it using this projection function, and then passes it to the given predicate. In this case, each element is first doubled, and then checked whether the transformed element is equal to 10. Thus, the output now is as follows. Compare this with the output from the previous section.
       </p>
       <pre id="c25-code-0010"><code>Found 3 matching elements:</code>
<code>5 at position 0</code>
<code>5 at position 2</code>
<code>5 at position 6</code></pre>
      </section>
     </section>
     <section>
      <span id="c25-sec-0012">
      </span>
      <h3 id="head-3-478">
       Writing a Standard Library Container
      </h3>
      <p id="c25-para-0030">
       The C++ Standard Library contains a list of requirements that any container must fulfill to qualify as a Standard Library container. Additionally, if you want your container to be sequential (like a
       <code>
        vector
       </code>
       ), ordered associative (like a
       <code>
        map
       </code>
       ), or unordered associative (like an
       <code>
        unordered_map
       </code>
       ), it must conform to supplementary requirements.
      </p>
      <p id="c25-para-0031">
       My suggestion when writing a custom container is to write the basic container first, following the general Standard Library rules such as making it a class template, but without worrying too much yet about the specific details of Standard Library conformity. After developing the basic implementation, add iterator support so that it can work with the Standard Library framework. Next, add member functions and type aliases to fulfill all basic container requirements, and finally, fulfill any additional container requirements. This chapter takes that approach to develop a
       <i>
        directed graph
       </i>
       data structure, also called a
       <i>
        digraph
       </i>
       .
      </p>
      <section>
       <span id="c25-sec-0013">
       </span>
       <h4 id="head-4-364">
        A Basic Directed Graph
       </h4>
       <p id="c25-para-0032">
        Certain C++ Standard Library containers might possibly use a graph in their implementation, but the standard does not make any graph-like data structures available to the user. So, implementing your own graph sounds like a perfect example of writing your own Standard Library–compliant container.
       </p>
       <p id="c25-para-0033">
        Before starting with writing any code, let's first take a look at what kind of data structure a directed graph is and how to represent its data in memory.
        <a href="#c25-fig-0001" id="R_c25-fig-0001">
         Figure 25.1
        </a>
        shows a visual representation of a directed graph example. Basically, a directed graph consists of a set of
        <i>
         nodes
        </i>
        , also called
        <i>
         vertices
        </i>
        , which are connected by
        <i>
         edges
        </i>
        . Additionally, every edge has a direction, indicated by the arrows, which is why it's called a
        <i>
         directed
        </i>
        graph.
       </p>
       <span aria-label="916" epub:type="pagebreak" id="Page_916" role="doc-pagebreak">
       </span>
       <figure>
        <img alt="A diagram illustrates circles, each has a number, connected by arrows. There are eight circles numbered 1 to 7, 11 and 12. Circle 1 is central and has arrows pointing towards circles numbered 6, 3, and 7." class="center" src="../images\images/c25f001.png"/>
        <figcaption>
         <p>
          <span class="figureLabel">
           <a href="#R_c25-fig-0001" id="c25-fig-0001" role="doc-backlink">
            <b>
             FIGURE 25.1
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p id="c25-para-0034">
        There are multiple ways to store such a data structure in memory, such as edge lists, adjacency matrices, and adjacency lists. This implementation uses
        <i>
         adjacency lists
        </i>
        . Nodes are stored in a
        <code>
         vector
        </code>
        with each node having an adjacency list listing its neighboring nodes. Let's look at an example. Suppose you have the directed graph from
        <a href="#c25-fig-0002" id="R_c25-fig-0002">
         Figure 25.2
        </a>
        .
       </p>
       <figure>
        <img alt="A diagram illustrates a simple directed graph comprising three nodes. A, B, and C. There is an arrow from node A to node B, another arrow from node B to node C, and a final arrow from node A to node C." class="center" src="../images\images/c25f002.png"/>
        <figcaption>
         <p>
          <span class="figureLabel">
           <a href="#R_c25-fig-0002" id="c25-fig-0002" role="doc-backlink">
            <b>
             FIGURE 25.2
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p id="c25-para-0035">
        Representing this graph with adjacency lists results in the following data structure:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NODE
          </th>
          <th class="left bgcolor2" scope="col">
           ADJACENCY LIST
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bgcolor3">
           A
          </td>
          <td class="left bgcolor3">
           B, C
          </td>
         </tr>
         <tr>
          <td class="left bgcolor3">
           B
          </td>
          <td class="left bgcolor3">
           C
          </td>
         </tr>
         <tr>
          <td class="left bgcolor3">
           C
          </td>
          <td class="left bgcolor3">
          </td>
         </tr>
        </tbody>
       </table>
       <p id="c25-para-0037">
        This can be stored as a
        <code>
         vector
        </code>
        where each element in the
        <code>
         vector
        </code>
        represents one row of the table; that is, each
        <code>
         vector
        </code>
        element represents a single node and its corresponding adjacency list. Let's start with a basic implementation without worrying too much about Standard Library compliance. This first section implements a simple, but fully functional,
        <code>
         directed_graph&lt;T&gt;
        </code>
        where
        <code>
         T
        </code>
        is the type of value to be stored in a single node. All values stored in a
        <code>
         directed_graph
        </code>
        must be unique. This might not be the best or most performant implementation of a directed graph, but that's not the point of this chapter. The point is to walk through the process of making a data structure following the Standard Library philosophy.
       </p>
       <section>
        <span id="c25-sec-0014">
        </span>
        <h5 id="head-5-138">
         The graph_node Class Template
        </h5>
        <p>
         The
         <code>
          directed_graph
         </code>
         implementation uses the concept of nodes, so the first piece of code to implement is a data structure representing a single node of a graph. A node has a value and a list of adjacent nodes, stored as a
         <code>
          set
         </code>
         of indices to those adjacent nodes. Using a
         <code>
          set
         </code>
         makes sure that no duplicate adjacent indices are stored in the list. The class has a constructor to construct a new
         <code>
          graph_node
         </code>
         for a given value and has a
         <code>
          value()
         </code>
         member function to retrieve the value of the node. Only a
         <code>
          const
         </code>
         overload of
         <code>
          value()
         </code>
         is provided, as values should never change. The definition is in a
         <code>
          directed_graph:node
         </code>
         partition file called
         <code>
          graph_node.cppm
         </code>
         , inside a namespace called
         <code>
          details
         </code>
         , and is not exported from the module, as users of
         <code>
          directed_graph
         </code>
         s should not directly use
         <code>
          graph_node
         </code>
         s themselves. Here is the interface of
         <code>
          graph_node
         </code>
         . Note the use of the
         <code>
          [[nodiscard]]
         </code>
         attribute, introduced in
         <a href="c01.xhtml">
          Chapter 1
         </a>
         , “A Crash Course in C++ and the Standard Library”:
        </p>
        <pre id="c25-code-0011"><code>export module directed_graph:node;</code>
<code>…</code>
<code>namespace details</code>
<code>{</code>
<code>    template &lt;typename T&gt;</code>
<code>    class graph_node</code>
<code>    {</code>
<code>        public:</code>
<code>            <span class="color3">// Constructs a graph_node for the given value.</span></code>
<code>            explicit graph_node(directed_graph&lt;T&gt;* graph, T t)</code>
<code>                : m_graph { graph }, m_data(std::move(t)) { }</code>
<code> </code>
<span aria-label="917" epub:type="pagebreak" id="Page_917" role="doc-pagebreak"></span><code>            <span class="color3">// Returns a reference to the stored value.</span></code>
<code>            [[nodiscard]] const T&amp; value() const noexcept { return m_data; }</code>
<code> </code>
<code>            <span class="color3">// Type alias for the container type used to store the adjacency list.</span></code>
<code>            using adjacency_list_type = std::set&lt;std::size_t&gt;;</code>
<code> </code>
<code>            <span class="color3">// Returns a reference to the adjacency list.</span></code>
<code>            [[nodiscard]] auto&amp; get_adjacent_nodes_indices() {</code>
<code>                return m_adjacentNodeIndices; }</code>
<code>            [[nodiscard]] const auto&amp; get_adjacent_nodes_indices() const {</code>
<code>                return m_adjacentNodeIndices; }</code>
<code>        private:</code>
<code>            <span class="color3">// A pointer to the graph this node is in.</span></code>
<code>            directed_graph&lt;T&gt;* m_graph;</code>
<code> </code>
<code>            T m_data;</code>
<code>            adjacency_list_type m_adjacentNodeIndices;</code>
<code>    };</code>
<code>}</code></pre>
        <p id="c25-para-0039">
         In this definition, no constraints are placed on the template type parameter
         <code>
          T
         </code>
         . The reason is that, just as
         <code>
          vector
         </code>
         , the element requirements depend on what operations are actually performed on the container.
        </p>
        <p id="c25-para-0040">
         The initialization of
         <code>
          m_data
         </code>
         in the constructor initializer uses
         <code>
          m_data
          <b>
           (
          </b>
          std::move(t)
          <b>
           )
          </b>
         </code>
         . Using the uniform initialization syntax,
         <code>
          m_data
          <b>
           {
          </b>
          std::move(t)
          <b>
           }
          </b>
         </code>
         , might not compile because
         <code>
          T
         </code>
         is a user-defined type.
        </p>
        <p id="c25-para-0041">
         Now that we have our
         <code>
          graph_node
         </code>
         implementation, let's look at the
         <code>
          directed_graph
         </code>
         class itself.
        </p>
       </section>
       <section>
        <span id="c25-sec-0015">
        </span>
        <h5 id="head-5-139">
         The directed_graph Interface
        </h5>
        <p>
         A
         <code>
          directed_graph
         </code>
         supports three basic operations: insertion, deletion, and lookup; additionally, it is swappable. It is defined in a
         <code>
          directed_graph
         </code>
         module. Here is the
         <code>
          public
         </code>
         portion of the
         <code>
          directed_graph
         </code>
         class template:
        </p>
        <pre id="c25-code-0012"><code>export module directed_graph;</code>
<code>…</code>
<code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// For insert to be successful, the value shall not be in the graph yet.</span></code>
<code>        <span class="color3">// Returns true if a new node with given value has been added to</span></code>
<code>        <span class="color3">// the graph, and false if there was already a node with the given value.</span></code>
<code>        bool insert(T node_value);</code>
<code> </code>
<code>        <span class="color3">// Returns true if the given node value was erased, false otherwise.</span></code>
<code>        bool erase(const T&amp; node_value);</code>
<code> </code>
<code>        <span class="color3">// Returns true if the edge was successfully created, false otherwise.</span></code>
<code>        bool insert_edge(const T&amp; from_node_value, const T&amp; to_node_value);</code>
<code> </code>
<code>        <span class="color3">// Returns true if the given edge was erased, false otherwise.</span></code>
<code>        bool erase_edge(const T&amp; from_node_value, const T&amp; to_node_value);</code>
<code> </code>
<span aria-label="918" epub:type="pagebreak" id="Page_918" role="doc-pagebreak"></span><code>        <span class="color3">// Removes all nodes from the graph.</span></code>
<code>        void clear() noexcept;</code>
<code> </code>
<code>        <span class="color3">// Returns a reference to the value in the node with given index</span></code>
<code>        <span class="color3">// without bounds checking.</span></code>
<code>        const T&amp; operator[](std::size_t index) const;</code>
<code> </code>
<code>        <span class="color3">// Two directed graphs are equal if their sets of nodes are equal (where</span></code>
<code>        <span class="color3">// nodes with the same T value are considered equal) and the same number</span></code>
<code>        <span class="color3">// of edges between each corresponding pair of nodes.</span></code>
<code>        <span class="color3">// The order in which the nodes and edges have been added does not</span></code>
<code>        <span class="color3">// affect equality.</span></code>
<code>        bool operator==(const directed_graph&amp; rhs) const;</code>
<code> </code>
<code>        <span class="color3">// Swaps all nodes between this graph and the given graph.</span></code>
<code>        void swap(directed_graph&amp; other_graph) noexcept;</code>
<code> </code>
<code>        <span class="color3">// Returns the number of nodes in the graph.</span></code>
<code>        [[nodiscard]] std::size_t size() const noexcept;</code>
<code> </code>
<code>        <span class="color3">// Returns a set with the values of the adjacent nodes of a given node.</span></code>
<code>        <span class="color3">// If the given node does not exist, an empty set is returned.</span></code>
<code>        [[nodiscard]] std::set&lt;T&gt; get_adjacent_nodes_values(</code>
<code>            const T&amp; node_value) const;</code>
<code>    private:</code>
<code>        <span class="color3">// Implementation details not shown yet.</span></code>
<code>};</code></pre>
        <p id="c25-para-0043">
         The element type is a template type parameter, similar to the Standard Library
         <code>
          vector
         </code>
         container's. This interface looks straightforward. Note that this interface does not define any user-defined copy and move constructors, copy and move assignment operators, or destructor; i.e., the class follows the Rule of Zero as discussed in
         <a href="c09.xhtml">
          Chapter 9
         </a>
         , “Mastering Classes and Objects.”
        </p>
        <p id="c25-para-0044">
         Let's now look at concrete implementations of the
         <code>
          public
         </code>
         member functions.
        </p>
       </section>
       <section>
        <span id="c25-sec-0016">
        </span>
        <h5 id="head-5-140">
         The Implementation
        </h5>
        <p>
         After you finalize the
         <code>
          directed_graph
         </code>
         interface, you need to choose the implementation model. As discussed earlier, this implementation stores a directed graph as a list of nodes where each node contains its value and its set of adjacent node indices. Since the adjacent node lists contain indices to other nodes, nodes should be accessible based on their indices. Thus, a
         <code>
          vector
         </code>
         is the most appropriate container for storing the nodes. Each node is represented as a
         <code>
          graph_node
         </code>
         instance. Thus, the final structure is a
         <code>
          vector
         </code>
         of
         <code>
          graph_node
         </code>
         s. Here are the first
         <code>
          private
         </code>
         members of the
         <code>
          directed_graph
         </code>
         class:
        </p>
        <pre id="c25-code-0013"><code>private:</code>
<code>    using node_container_type = std::vector&lt;details::graph_node&lt;T&gt;&gt;;</code>
<code>    node_container_type m_nodes;</code></pre>
       </section>
       <section>
        <span id="c25-sec-0017">
        </span>
        <h5 id="head-5-141">
         Searching Nodes
        </h5>
        <p>
         Insert and delete operations on a graph require code to find an element with a given node value. Thus, it is helpful to have a
         <code>
          private
         </code>
         helper member function that performs this task. Both a
         <code>
          const
         </code>
         and a non-
         <code>
          const
         </code>
         overload are provided:
        </p>
        <pre id="c25-code-0014"><span aria-label="919" epub:type="pagebreak" id="Page_919" role="doc-pagebreak"></span><code><span class="color3">// Helper member function to return an iterator to the given node, or the</span></code>
<code><span class="color3">// end iterator if the given node is not in the graph.</span></code>
<code>typename node_container_type::iterator find_node(const T&amp; node_value);</code>
<code>typename node_container_type::const_iterator find_node(const T&amp; node_value) const;</code></pre>
        <p>
         The implementation of the non-
         <code>
          const
         </code>
         overload of
         <code>
          find_node()
         </code>
         is as follows. The
         <code>
          const
         </code>
         overload has the same implementation.
        </p>
        <pre id="c25-code-0015"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::node_container_type::iterator</code>
<code>    directed_graph&lt;T&gt;::find_node(const T&amp; node_value)</code>
<code>{</code>
<code>    return std::find_if(std::begin(m_nodes), std::end(m_nodes),</code>
<code>        [&amp;](const auto&amp; node) { return node.value() == node_value; });</code>
<code>}</code></pre>
        <p id="c25-para-0048">
         The body of the member function is not too complicated. It uses the
         <code>
          find_if()
         </code>
         algorithm from the Standard Library, discussed in
         <a href="c20.xhtml">
          Chapter 20
         </a>
         , to search all the nodes in the graph for a node with a value equal to the
         <code>
          node_value
         </code>
         parameter. If such a node is found in the graph, an iterator to that node is returned; otherwise, an end iterator is returned.
        </p>
        <p id="c25-para-0049">
         The syntax in the function header of this member function is somewhat confusing, particularly the use of the
         <code>
          typename
         </code>
         keyword. You must use the
         <code>
          typename
         </code>
         keyword whenever you are using a type that is dependent on a template parameter. Specifically, the type
         <code>
          node_container_type::iterator
         </code>
         , which is
         <code>
          vector&lt;details::graph_node&lt;T&gt;&gt;::iterator
         </code>
         , is dependent on the
         <code>
          T
         </code>
         template type parameter.
        </p>
       </section>
       <section>
        <span id="c25-sec-0018">
        </span>
        <h5 id="head-5-142">
         Inserting Nodes
        </h5>
        <p>
         <code>
          insert()
         </code>
         must first check whether a node with a given value already exists in the graph. If it doesn't exist yet, a new node can be created for the given value. The
         <code>
          public
         </code>
         interface provides an
         <code>
          insert()
         </code>
         member function accepting a
         <code>
          T
         </code>
         by value. This is optimal in this case and follows the recommendation explained in the section “
         <a href="c09.xhtml#c09-sec-0033">
          Optimal Way to Pass Arguments to Functions
         </a>
         ” in
         <a href="c09.xhtml">
          Chapter 9
         </a>
         . The call to
         <code>
          emplace:back()
         </code>
         constructs a new
         <code>
          graph_node
         </code>
         by passing a pointer to the
         <code>
          directed_graph
         </code>
         and the node's value to the
         <code>
          graph_node
         </code>
         constructor:
        </p>
        <pre id="c25-code-0016"><code>template &lt;typename T&gt;</code>
<code>bool directed_graph&lt;T&gt;::insert(T node_value)</code>
<code>{</code>
<code>    auto iter { find_node(node_value) };</code>
<code>    if (iter != std::end(m_nodes)) {</code>
<code>        <span class="color3">// Value is already in the graph, return false.</span></code>
<code>        return false;</code>
<code>    }</code>
<code>    m_nodes.emplace:back(this, std::move(node_value));</code>
<code>    <span class="color3">// Value successfully added to the graph, return true.</span></code>
<code>    return true;</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0019">
        </span>
        <h5 id="head-5-143">
         Inserting Edges
        </h5>
        <p>
         Once nodes have been added to the graph, edges between those nodes can be constructed to build up a directed graph. For this, an
         <code>
          insert_edge()
         </code>
         member function is provided that requires two
         <span aria-label="920" epub:type="pagebreak" id="Page_920" role="doc-pagebreak">
         </span>
         parameters: the value of the node from which the edge should start, and the value of the node to which the edge should point. The first thing the member function does is to search the graph for the from and to nodes. If either one of them is not found in the graph,
         <code>
          false
         </code>
         is returned. If both are found, then the code calculates the index of the node containing
         <code>
          to_node_value
         </code>
         by calling
         <code>
          get_index_of_node()
         </code>
         , a
         <code>
          private
         </code>
         helper function, and finally adds this index to the adjacency list of the node containing
         <code>
          from_node_value
         </code>
         . The
         <code>
          insert_edge()
         </code>
         member function returns
         <code>
          true
         </code>
         if and only if the graph changed as a result of the call. Remember from
         <a href="c18.xhtml">
          Chapter 18
         </a>
         that
         <code>
          insert()
         </code>
         on a
         <code>
          set
         </code>
         returns a
         <code>
          pair&lt;iterator,bool&gt;
         </code>
         , where the Boolean represents whether the insert was successful, which is why
         <code>
          .second
         </code>
         is used on the result of
         <code>
          insert()
         </code>
         in the
         <code>
          return
         </code>
         statement.
        </p>
        <pre id="c25-code-0017"><code>template &lt;typename T&gt;</code>
<code>bool directed_graph&lt;T&gt;::insert_edge(const T&amp; from_node_value,</code>
<code>    const T&amp; to_node_value)</code>
<code>{</code>
<code>    const auto from { find_node(from_node_value) };</code>
<code>    const auto to { find_node(to_node_value) };</code>
<code>    if (from == std::end(m_nodes) || to == std::end(m_nodes)) {</code>
<code>        return false;</code>
<code>    }</code>
<code>    const std::size_t to_index { get_index_of_node(to) };</code>
<code>    return from-&gt;get_adjacent_nodes_indices().insert(to_index).second;</code>
<code>}</code></pre>
        <p>
         The
         <code>
          get_index_of_node()
         </code>
         helper member function is implemented as follows:
        </p>
        <pre id="c25-code-0018"><code>template &lt;typename T&gt;</code>
<code>std::size_t directed_graph&lt;T&gt;::get_index_of_node(</code>
<code>    typename node_container_type::const_iterator node) const noexcept</code>
<code>{</code>
<code>    return node - std::cbegin(m_nodes);</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0020">
        </span>
        <h5 id="head-5-144">
         Deleting Nodes
        </h5>
        <p>
         <code>
          erase()
         </code>
         follows the same pattern as
         <code>
          insert()
         </code>
         : it first attempts to find the given node by calling
         <code>
          find_node()
         </code>
         . If the node exists, it erases it from the graph. Otherwise, it does nothing. Removing an existing node from the graph is a two-step procedure:
        </p>
        <ol class="decimal" id="c25-list-0002">
         <li id="c25-li-0003">
          Remove the index of the to-be-deleted node from all adjacency lists of all other nodes.
         </li>
         <li id="c25-li-0004">
          Remove the actual node from the list of nodes.
         </li>
        </ol>
        <p>
         For the first step, a helper member function
         <code>
          remove_node_index()
         </code>
         is added to
         <code>
          graph_node,
         </code>
         which removes a given node index from the adjacency list of a node and updates the remaining indices to account for the shift in indices. The implementation follows. One tricky part is that the adjacency list is a
         <code>
          set
         </code>
         , and a
         <code>
          set
         </code>
         does not allow modifications to its values. Instead, the second step in the implementation converts the
         <code>
          set
         </code>
         into a
         <code>
          vector
         </code>
         , uses the
         <code>
          for_each()
         </code>
         algorithm to update all indices that require updating, and finally clears the
         <code>
          set
         </code>
         and inserts the updated indices. Again, this might not be the most performant implementation, but, as mentioned earlier, that's not the point of this discussion.
        </p>
        <pre id="c25-code-0019"><code>template &lt;typename T&gt;</code>
<code>void graph_node&lt;T&gt;::remove_node_index(std::size_t node_index)</code>
<code>{</code>
<span aria-label="921" epub:type="pagebreak" id="Page_921" role="doc-pagebreak"></span><code>    <span class="color3">// First, remove references to the to-be-deleted node.</span></code>
<code>    m_adjacentNodeIndices.erase(node_index);</code>
<code> </code>
<code>    <span class="color3">// Second, modify all adjacency indices to account for the removal of a node.</span></code>
<code>    <span class="color3">// std::set doesn't let us modify its elements in place,</span></code>
<code>    <span class="color3">// so we rebuild the set from scratch.</span></code>
<code>    std::vector&lt;std::size_t&gt; indices(std::begin(m_adjacentNodeIndices),</code>
<code>        std::end(m_adjacentNodeIndices));</code>
<code>    std::for_each(std::begin(indices), std::end(indices),</code>
<code>        [node_index](std::size_t&amp; index) {</code>
<code>            if (index &gt; node_index) { --index; }</code>
<code>        });</code>
<code>    m_adjacentNodeIndices.clear();</code>
<code>    m_adjacentNodeIndices.insert(std::begin(indices), std::end(indices));</code>
<code>}</code></pre>
        <p>
         Next, a
         <code>
          remove_all_links_to()
         </code>
         helper member function is added to
         <code>
          directed_graph
         </code>
         . This member function updates remaining adjacent node indices in all nodes to account for the removal of a node from the graph. First, it calculates
         <code>
          node_index
         </code>
         , the index of the given node in the
         <code>
          vector
         </code>
         of nodes. Then, it iterates over all nodes and removes
         <code>
          node_index
         </code>
         from the adjacency list of each node.
        </p>
        <pre id="c25-code-0020"><code>template &lt;typename T&gt;</code>
<code>void directed_graph&lt;T&gt;::remove_all_links_to(</code>
<code>    typename node_container_type::const_iterator node_iter)</code>
<code>{</code>
<code>    const std::size_t node_index { get_index_of_node(node_iter) };</code>
<code>    for (auto&amp;&amp; node : m_nodes) { node.remove_node_index(node_index); }</code>
<code>}</code></pre>
        <p>
         With this helper member function, the implementation of the actual
         <code>
          erase()
         </code>
         member function becomes easy:
        </p>
        <pre id="c25-code-0021"><code>template &lt;typename T&gt;</code>
<code>bool directed_graph&lt;T&gt;::erase(const T&amp; node_value)</code>
<code>{</code>
<code>    auto iter { find_node(node_value) };</code>
<code>    if (iter == std::end(m_nodes)) {</code>
<code> return false;</code>
<code> }</code>
<code>    remove_all_links_to(iter);</code>
<code>    m_nodes.erase(iter);</code>
<code>    return true;</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0021">
        </span>
        <h5 id="head-5-145">
         Deleting Edges
        </h5>
        <p>
         The procedure to remove edges is quite similar to adding them. If either the from or to node is not found, nothing is done; otherwise, the index of the node with value
         <code>
          to_node_value
         </code>
         is removed from the adjacency list of the node with value
         <code>
          from_node_value
         </code>
         :
        </p>
        <pre id="c25-code-0022"><code>template &lt;typename T&gt;</code>
<code>bool directed_graph&lt;T&gt;::erase_edge(const T&amp; from_node_value,</code>
<code>    const T&amp; to_node_value)</code>
<code>{</code>
<code>    const auto from { find_node(from_node_value) };</code>
<span aria-label="922" epub:type="pagebreak" id="Page_922" role="doc-pagebreak"></span><code>    const auto to { find_node(to_node_value) };</code>
<code>    if (from == std::end(m_nodes) || to == std::end(m_nodes)) {</code>
<code>        return false; // nothing to erase</code>
<code>    }</code>
<code>    const std::size_t to_index { get_index_of_node(to) };</code>
<code>    from-&gt;get_adjacent_nodes_indices().erase(to_index);</code>
<code>    return true;</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0022">
        </span>
        <h5 id="head-5-146">
         Removing All Elements
        </h5>
        <p>
         <code>
          clear()
         </code>
         simply clears the entire graph:
        </p>
        <pre id="c25-code-0023"><code>template &lt;typename T&gt;</code>
<code>void directed_graph&lt;T&gt;::clear() noexcept</code>
<code>{</code>
<code>    m_nodes.clear();</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0023">
        </span>
        <h5 id="head-5-147">
         Swapping Graphs
        </h5>
        <p>
         Since
         <code>
          directed_graph
         </code>
         has only one data member, a
         <code>
          vector
         </code>
         container, swapping two
         <code>
          directed_graph
         </code>
         s just means swapping their single data member:
        </p>
        <pre id="c25-code-0024"><code>template &lt;typename T&gt;</code>
<code>void directed_graph&lt;T&gt;::swap(directed_graph&amp; other_graph) noexcept</code>
<code>{</code>
<code>    m_nodes.swap(other_graph.m_nodes);</code>
<code>}</code></pre>
        <p>
         The following stand-alone exported
         <code>
          swap()
         </code>
         function is also provided, which simply forwards to the
         <code>
          public swap()
         </code>
         member function:
        </p>
        <pre id="c25-code-0025"><code>export template &lt;typename T&gt;</code>
<code>void swap(directed_graph&lt;T&gt;&amp; first, directed_graph&lt;T&gt;&amp; second) noexcept</code>
<code>{</code>
<code>    first.swap(second);</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0024">
        </span>
        <h5 id="head-5-148">
         Accessing Nodes
        </h5>
        <p>
         The
         <code>
          public
         </code>
         interface of
         <code>
          directed_graph
         </code>
         supports accessing nodes based on their index with
         <code>
          operator[]
         </code>
         . Its implementation is straightforward. Just as with
         <code>
          vector
         </code>
         , the operator does not perform any bounds checking on the requested index:
        </p>
        <pre id="c25-code-0026"><code>template &lt;typename T&gt;</code>
<code>const T&amp; directed_graph&lt;T&gt;::operator[](std::size_t index) const</code>
<code>{</code>
<code>    return m_nodes[index].value();</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0025">
        </span>
        <h5 id="head-5-149">
         Comparing Graphs
        </h5>
        <p id="c25-para-0062">
         Two
         <code>
          directed_graph
         </code>
         s are equal if and only if they contain the same set of nodes and the same set of edges between all the nodes. A slight complication arises from the fact that the two
         <code>
          directed_graph
         </code>
         s
         <span aria-label="923" epub:type="pagebreak" id="Page_923" role="doc-pagebreak">
         </span>
         could have been created by adding nodes to them in different order; as such, the implementation cannot just compare the
         <code>
          m_nodes
         </code>
         data member but instead needs to do a bit more work.
        </p>
        <p>
         The code first checks the size of both
         <code>
          directed_graph
         </code>
         s. If the size is different, both graphs cannot be the same. If they have the same size, the code iterates over all the nodes of one of the graphs. For each node, it tries to find the same node in the other graph. If it doesn't find such a node, the graphs are not equal. If it does find such a node, the adjacent node indices are converted to adjacent node values using a
         <code>
          get_adjacent_nodes_values()
         </code>
         helper member function, and those values are then compared for equality.
        </p>
        <pre id="c25-code-0027"><code>template &lt;typename T&gt;</code>
<code>bool directed_graph&lt;T&gt;::operator==(const directed_graph&amp; rhs) const</code>
<code>{</code>
<code>    if (m_nodes.size() != rhs.m_nodes.size()) { return false; }</code>
<code> </code>
<code>    for (auto&amp;&amp; node : m_nodes) {</code>
<code>        const auto rhsNodeIter {   rhs.find_node(node.value()) };</code>
<code>        if (rhsNodeIter == std::end(rhs.m_nodes)) { return false; }</code>
<code> </code>
<code>        const auto adjacent_values_lhs { get_adjacent_nodes_values(</code>
<code>            node.get_adjacent_nodes_indices()) };</code>
<code>        const auto adjacent_values_rhs { rhs.get_adjacent_nodes_values(</code>
<code>            rhsNodeIter-&gt;get_adjacent_nodes_indices()) };</code>
<code>        if (adjacent_values_lhs != adjacent_values_rhs) { return false; }</code>
<code>    }</code>
<code>    return true;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>std::set&lt;T&gt; directed_graph&lt;T&gt;::get_adjacent_nodes_values(</code>
<code>    const typename details::graph_node&lt;T&gt;::adjacency_list_type&amp; indices) const</code>
<code>{</code>
<code>    std::set&lt;T&gt; values;</code>
<code>    for (auto&amp;&amp; index : indices) { values.insert(m_nodes[index].value()); }</code>
<code>    return values;</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0026">
        </span>
        <h5 id="head-5-150">
         Getting Adjacent Nodes
        </h5>
        <p>
         The
         <code>
          public
         </code>
         interface provides a
         <code>
          get_adjacent_nodes_values()
         </code>
         member function accepting a
         <code>
          node_value
         </code>
         of type reference-to-
         <code>
          const T
         </code>
         as parameter. It returns a
         <code>
          set
         </code>
         containing the values of the nodes adjacent to the given node. If the given node does not exist, an empty
         <code>
          set
         </code>
         is returned. The implementation uses the
         <code>
          get_adjacent_nodes_values()
         </code>
         overload accepting a list of indices as implemented in the previous section:
        </p>
        <pre id="c25-code-0028"><code>template &lt;typename T&gt;</code>
<code>std::set&lt;T&gt; directed_graph&lt;T&gt;::get_adjacent_nodes_values(const T&amp; node_value) const</code>
<code>{</code>
<code>    auto iter { find_node(node_value) };</code>
<code>    if (iter == std::end(m_nodes)) { return {}; }</code>
<code>    return get_adjacent_nodes_values(iter-&gt;get_adjacent_nodes_indices());</code>
<code>}</code></pre>
       </section>
       <span aria-label="924" epub:type="pagebreak" id="Page_924" role="doc-pagebreak">
       </span>
       <section>
        <span id="c25-sec-0027">
        </span>
        <h5 id="head-5-151">
         Querying the Graph Size
        </h5>
        <p>
         Finally, the
         <code>
          size()
         </code>
         member function returns the number of nodes in the graph:
        </p>
        <pre id="c25-code-0029"><code>template &lt;typename T&gt;</code>
<code>std::size_t directed_graph&lt;T&gt;::size() const noexcept</code>
<code>{</code>
<code>    return m_nodes.size();</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0028">
        </span>
        <h5 id="head-5-152">
         Printing Graphs
        </h5>
        <p>
         Graphs can be printed in a standard format called
         <i>
          DOT
         </i>
         , a
         <i>
          graph description language
         </i>
         . There are tools available that understand DOT-formatted graphs and that can convert them into graphical representations. To make it easier to test the
         <code>
          directed_graph
         </code>
         code, the following
         <code>
          to_dot()
         </code>
         conversion function can be used. An example of its use is given in the next section.
        </p>
        <pre id="c25-code-0030"><code><span class="color3">// Returns a given graph in DOT format.</span></code>
<code>export template &lt;typename T&gt;</code>
<code>std::string to_dot(const directed_graph&lt;T&gt;&amp; graph, std::string_view graph_name)</code>
<code>{</code>
<code>    std::ostringstream output;</code>
<code>    std::println(output, "digraph {} {{", graph_name);</code>
<code>    for (std::size_t index { 0 }; index &lt; graph.size(); ++index) {</code>
<code>        const auto&amp; node_value { graph[index] };</code>
<code>        const auto adjacent_values { graph.get_adjacent_nodes_values(node_value) };</code>
<code>        if (adjacent_values.empty()) {</code>
<code>            std::println(output, "{}", node_value);</code>
<code>        } else {</code>
<code>            for (auto&amp;&amp; neighbor : adjacent_values) {</code>
<code>                std::println(output, "{} -&gt; {}", node_value, neighbor);</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>    std::println(output, "}}");</code>
<code>    return std::move(output).str();</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0029">
        </span>
        <h5 id="head-5-153">
         Using the Basic Directed Graph
        </h5>
        <p>
         We have now completed the full implementation of a basic directed graph class. It's high time to give this class a test drive. Here is a small program demonstrating the basic
         <code>
          directed_graph
         </code>
         class template:
        </p>
        <pre id="c25-code-0031"><code>directed_graph&lt;int&gt; graph;</code>
<code><span class="color3">// Insert some nodes and edges.</span></code>
<code>graph.insert(11);</code>
<code>graph.insert(22);</code>
<code>graph.insert(33);</code>
<code>graph.insert(44);</code>
<code>graph.insert(55);</code>
<code>graph.insert_edge(11, 33);</code>
<code>graph.insert_edge(22, 33);</code>
<code>graph.insert_edge(22, 44);</code>
<code>graph.insert_edge(22, 55);</code>
<span aria-label="925" epub:type="pagebreak" id="Page_925" role="doc-pagebreak"></span><code>graph.insert_edge(33, 44);</code>
<code>graph.insert_edge(44, 55);</code>
<code>println("{}", to_dot(graph, "Graph1"));</code>
<code> </code>
<code><span class="color3">// Remove an edge and a node.</span></code>
<code>graph.erase_edge(22, 44);</code>
<code>graph.erase(44);</code>
<code>println("{}", to_dot(graph, "Graph1"));</code>
<code> </code>
<code><span class="color3">// Print the size of the graph.</span></code>
<code>println("Size: {}", graph.size());</code></pre>
        <p>
         The output is as follows:
        </p>
        <pre id="c25-code-0032"><code>digraph Graph1 {</code>
<code>11 -&gt; 33</code>
<code>22 -&gt; 33</code>
<code>22 -&gt; 44</code>
<code>22 -&gt; 55</code>
<code>33 -&gt; 44</code>
<code>44 -&gt; 55</code>
<code>55</code>
<code>}</code>
<code>digraph Graph1 {</code>
<code>11 -&gt; 33</code>
<code>22 -&gt; 33</code>
<code>22 -&gt; 55</code>
<code>33</code>
<code>55</code>
<code>}</code>
<code>Size: 4</code></pre>
       </section>
      </section>
      <section>
       <span id="c25-sec-0030">
       </span>
       <h4 id="head-4-365">
        Making directed_graph a Standard Library Container
       </h4>
       <p id="c25-para-0069">
        The basic
        <code>
         directed_graph
        </code>
        implemented in the previous sections follows the spirit, but not the letter, of the Standard Library. For most purposes, the preceding implementation is good enough. However, if you want to use the Standard Library algorithms on your
        <code>
         directed_graph
        </code>
        , you must do a bit more work. The C++ standard specifies member functions and type aliases that a class template must provide to qualify as a Standard Library container.
       </p>
       <section>
        <span id="c25-sec-0031">
        </span>
        <h5 id="head-5-154">
         Required Type Aliases
        </h5>
        <p id="c25-para-0070">
         The C++ standard requires that every Standard Library container provide the following
         <code>
          public
         </code>
         type aliases:
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            TYPE NAME
           </th>
           <th class="left bgcolor2" scope="col">
            DESCRIPTION
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             value_type
            </span>
           </td>
           <td class="left bgcolor3">
            The element type stored in the container
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             reference
            </span>
           </td>
           <td class="left bgcolor3">
            A reference to the element type stored in the container
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             const_reference
            </span>
           </td>
           <td class="left bgcolor3">
            A reference-to-
            <span class="forecolor1">
             const
            </span>
            to the element type stored in the container
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             iterator
            </span>
           </td>
           <td class="left bgcolor3">
            The type for iterating over elements of the container
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             const_iterator
            </span>
           </td>
           <td class="left bgcolor3">
            A version of
            <span class="forecolor1">
             iterator
            </span>
            for iterating over
            <code>
             const
            </code>
            elements of the container
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             size_type
            </span>
           </td>
           <td class="left bgcolor3">
            A type that can represent the number of elements in the container; this is usually just
            <span class="forecolor1">
             size_t
            </span>
            (from
            <code>
             &lt;cstddef&gt;
            </code>
            )
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             difference:type
            </span>
           </td>
           <td class="left bgcolor3">
            A type that can represent the difference of two
            <span class="forecolor1">
             iterator
            </span>
            s for the container; this is usually just
            <code>
             ptrdiff_t
            </code>
            (from
            <code>
             &lt;cstddef&gt;
            </code>
            )
            <span aria-label="926" epub:type="pagebreak" id="Page_926" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
        <p>
         Here are the definitions for the
         <code>
          directed_graph
         </code>
         class template of all these type aliases except
         <code>
          iterator
         </code>
         and
         <code>
          const_iterator
         </code>
         . Writing iterators is covered in detail later in this chapter.
        </p>
        <pre id="c25-code-0033"><code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    public:</code>
<code>        <b>using value_type = T;</b></code>
<code>        <b>using reference = value_type&amp;;</b></code>
<code>        <b>using const_reference = const value_type&amp;;</b></code>
<code>        <b>using size_type = std::size_t;</b></code>
<code>        <b>using difference:type = std::ptrdiff_t;</b></code>
<code>        <span class="color3">// Remainder of class definition omitted for brevity.</span></code>
<code>};</code></pre>
        <p>
         With these type aliases, some member functions can be slightly modified. For example, here is the earlier definition for
         <code>
          operator[]
         </code>
         :
        </p>
        <pre id="c25-code-0034"><code>const T&amp; operator[](std::size_t index) const;</code></pre>
        <p>
         With the new type aliases, this can be written as follows:
        </p>
        <pre id="c25-code-0035"><code>const_reference operator[](size_type index) const;</code></pre>
       </section>
       <section>
        <span id="c25-sec-0032">
        </span>
        <h5 id="head-5-155">
         Required Member Functions
        </h5>
        <p id="c25-para-0076">
         In addition to the obligatory type aliases, every container must provide the following member functions:
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            MEMBER FUNCTION
           </th>
           <th class="left bgcolor2" scope="col">
            DESCRIPTION
           </th>
           <th class="left bgcolor2" scope="col">
            WORST-CASE COMPLEXITY
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bgcolor3">
            Default constructor
           </td>
           <td class="left bgcolor3">
            Constructs an empty container
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            Copy constructor
           </td>
           <td class="left bgcolor3">
            Performs a deep copy of the container
           </td>
           <td class="left bgcolor3">
            Linear
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            Move constructor
           </td>
           <td class="left bgcolor3">
            Performs a move constructing operation
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            Copy assignment operator
           </td>
           <td class="left bgcolor3">
            Performs a deep copy of the container
           </td>
           <td class="left bgcolor3">
            Linear
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            Move assignment operator
           </td>
           <td class="left bgcolor3">
            Performs a move assignment operation
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            Destructor
           </td>
           <td class="left bgcolor3">
            Destroys any elements left in the container and frees their heap-allocated memory, if any
           </td>
           <td class="left bgcolor3">
            Linear
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0036"><code>iterator begin();</code>
<code>const_iterator</code>
<code> begin() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Returns an iterator or
            <span class="forecolor1">
             const
            </span>
            iterator referring to the first element in the container
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0037"><code>iterator end();</code>
<code>const_iterator</code>
<code> end() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Returns an iterator or
            <span class="forecolor1">
             const
            </span>
            iterator referring to one-past-the-last element in the container
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0038"><code>const_iterator</code>
<code> cbegin() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Same as
            <span class="forecolor1">
             begin() const
            </span>
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0039"><code>const_iterator</code>
<code> cend() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Same as
            <span class="forecolor1">
             end() const
            </span>
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0040"><code>operator==</code></pre>
           </td>
           <td class="left bgcolor3">
            Comparison operator that compares two containers
           </td>
           <td class="left bgcolor3">
            Linear
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0041"><code>void swap(Container&amp;)</code>
<code> noexcept;</code></pre>
           </td>
           <td class="left bgcolor3">
            Swaps the contents of the container passed to the member function with the object on which the member function is called
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0042"><code>size_type size() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Returns the number of elements in the container
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0043"><code>size_type max_size() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Returns the maximum number of elements the container can hold
           </td>
           <td class="left bgcolor3">
            Constant
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <pre class="pre1" id="c25-code-0044"><code>bool empty() const;</code></pre>
           </td>
           <td class="left bgcolor3">
            Returns whether the container has any elements
           </td>
           <td class="left bgcolor3">
            Constant
            <span aria-label="927" epub:type="pagebreak" id="Page_927" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
        <p id="c25-para-0088">
         As discussed earlier, the
         <code>
          directed_graph
         </code>
         implementation follows the rule of zero (see
         <a href="c09.xhtml">
          Chapter 9
         </a>
         ); that is, it does not need an explicit copy/move constructor, copy/move assignment operator, or destructor.
        </p>
        <p>
         The following code snippet shows the declarations of the
         <code>
          size()
         </code>
         ,
         <code>
          max_size()
         </code>
         , and
         <code>
          empty()
         </code>
         member functions. The iterator-related member functions,
         <code>
          begin()
         </code>
         ,
         <code>
          end()
         </code>
         ,
         <code>
          cbegin()
         </code>
         , and
         <code>
          cend()
         </code>
         , are covered in the next section on writing iterators.
        </p>
        <pre id="c25-code-0045"><code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    public:</code>
<code>        <b>[[nodiscard]] size_type size() const noexcept;</b></code>
<code>        <b>[[nodiscard]] size_type max_size() const noexcept;</b></code>
<code>        <b>[[nodiscard]] bool empty() const noexcept;</b></code>
<code>        <span class="color3">// Other member functions omitted for brevity.</span></code>
<code>};</code></pre>
        <p>
         <span aria-label="928" epub:type="pagebreak" id="Page_928" role="doc-pagebreak">
         </span>
         The implementations of these three member functions are easy because they can simply forward to the similarly named member functions of the
         <code>
          m_nodes
         </code>
         container. Note that
         <code>
          size_type
         </code>
         is one of the type aliases defined in the class template. Because it is a member of the class template, such a return type in the implementation must be fully qualified with
         <code>
          typename directed_graph&lt;T&gt;
         </code>
         .
        </p>
        <pre id="c25-code-0046"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::size_type directed_graph&lt;T&gt;::size() const noexcept</code>
<code>{</code>
<code>    return m_nodes.size();</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::size_type directed_graph&lt;T&gt;::max_size() const noexcept</code>
<code>{</code>
<code>    return m_nodes.max_size();</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>bool directed_graph&lt;T&gt;::empty() const noexcept</code>
<code>{</code>
<code>    return m_nodes.empty();</code>
<code>}</code></pre>
        <p>
         The current implementation of
         <code>
          directed_graph
         </code>
         has
         <code>
          operator[]
         </code>
         to get access to a node based on its index. This operator, just as with
         <code>
          operator[]
         </code>
         for
         <code>
          vector
         </code>
         , does not perform any bounds checking. Passing an out-of-bounds index could make your application crash. As for
         <code>
          vector
         </code>
         ,
         <code>
          directed_graph
         </code>
         can be augmented with an
         <code>
          at()
         </code>
         member function that does bounds checking and that throws an
         <code>
          std::out_of_range
         </code>
         exception if the passed index is out of bounds. Here is the definition:
        </p>
        <pre id="c25-code-0047"><code>const_reference at(size_type index) const;</code></pre>
        <p>
         The implementation just forwards to the
         <code>
          m_nodes vector
         </code>
         :
        </p>
        <pre id="c25-code-0048"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_reference</code>
<code>    directed_graph&lt;T&gt;::at(size_type index) const</code>
<code>{</code>
<code>    return m_nodes.at(index).value();</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0033">
        </span>
        <h5 id="head-5-156">
         Writing an Iterator
        </h5>
        <p id="c25-para-0093">
         The most important container requirement is iterator support. To work with the generic algorithms, every container must provide an iterator type for accessing the elements in the container. Your iterator should generally provide overloaded
         <code>
          operator++
         </code>
         ,
         <code>
          *
         </code>
         ,
         <code>
          -&gt;
         </code>
         , and
         <code>
          ==
         </code>
         , plus some other operations depending on its specific behavior. As long as your iterator provides the basic iteration operations, everything should be fine.
        </p>
        <p id="c25-para-0094">
         The first decision to make about your iterator is what kind it will be: forward, bidirectional, random access, or contiguous. Bidirectional iterator support seems like a good choice for a
         <code>
          directed_graph
         </code>
         iterator. That means you must additionally provide
         <code>
          operator--
         </code>
         . Another option would be to implement random-access iterators for
         <code>
          directed_graph
         </code>
         , which involves adding the operators
         <code>
          +
         </code>
         ,
         <code>
          -
         </code>
         ,
         <code>
          +=
         </code>
         ,
         <code>
          -=
         </code>
         ,
         <code>
          &lt;
         </code>
         ,
         <code>
          &gt;
         </code>
         ,
         <code>
          &lt;=
         </code>
         ,
         <code>
          &gt;=
         </code>
         , and
         <code>
          []
         </code>
         . This could be a good exercise to practice writing iterators. Consult
         <a href="c17.xhtml">
          Chapter 17
         </a>
         for more details on the requirements for random-access iterators.
        </p>
        <p id="c25-para-0095">
         <span aria-label="929" epub:type="pagebreak" id="Page_929" role="doc-pagebreak">
         </span>
         The second decision is how to order the elements of your container. The
         <code>
          directed_graph
         </code>
         is unsorted, so iterating in a sorted order would not be efficient. The important thing about a Standard Library-compliant container is that iterating over its elements from
         <code>
          begin()
         </code>
         to
         <code>
          end()
         </code>
         will hit every element once; just because it is
         <b>
          <i>
           a
          </i>
         </b>
         sequence, doesn't mean that it is a
         <b>
          <i>
           specific
          </i>
         </b>
         sequence. Thus, the
         <code>
          directed_graph
         </code>
         iterator can just step through the nodes in the order in which they were added to the graph. This is the same as how iteration for
         <code>
          std::unordered_set
         </code>
         works.
        </p>
        <p id="c25-para-0096">
         The third decision is how to represent your iterator internally. The representation is usually quite dependent on the internal implementation of the container. The first purpose of an iterator is to refer to a single element in the container. In the case of a
         <code>
          directed_graph
         </code>
         , all nodes are stored in the
         <code>
          m_nodes
         </code>
         vector, so perhaps a
         <code>
          directed_graph
         </code>
         iterator can be a wrapper around a
         <code>
          vector
         </code>
         iterator referring to the element in question.
        </p>
        <p id="c25-para-0097">
         Once you've chosen your implementation, you must decide on a consistent representation for the end iterator. Recall that the end iterator should really be the “past-the-end” marker: the iterator that's reached by applying
         <code>
          ++
         </code>
         to an iterator referring to the final element in the container. A
         <code>
          directed_graph
         </code>
         iterator can use as its end iterator the end iterator of the
         <code>
          m_nodes vector
         </code>
         .
        </p>
        <p id="c25-para-0098">
         Finally, a container needs to provide both
         <code>
          iterator
         </code>
         and
         <code>
          const_iterator
         </code>
         type aliases. This implementation defines both these type aliases in terms of a
         <code>
          const_directed_graph_iterator_impl
         </code>
         class template. The reason is that values cannot be changed once in the graph. This follows the same principle as
         <code>
          std::set
         </code>
         .
        </p>
        <p id="c25-para-0099">
         If you do need separate
         <code>
          iterator
         </code>
         and
         <code>
          const_iterator
         </code>
         types for your own data structure, keep in mind that an
         <code>
          iterator
         </code>
         must be convertible to a
         <code>
          const_iterator
         </code>
         .
        </p>
       </section>
       <section>
        <span id="c25-sec-0034">
        </span>
        <h5 id="head-5-157">
         The const_directed_graph_iterator_impl Class Template
        </h5>
        <p id="c25-para-0100">
         Given the decisions made in the previous section, it's time to define the
         <code>
          const_directed_graph_iterator_impl
         </code>
         class template. The first thing to note is that each
         <code>
          const_directed_graph_iterator_impl
         </code>
         object is an iterator for a specific instantiation of
         <code>
          directed_graph
         </code>
         . To provide this one-to-one mapping, the
         <code>
          const_directed_graph_iterator_impl
         </code>
         must also be a class template with the directed graph type as a template type parameter called
         <code>
          DirectedGraph
         </code>
         .
        </p>
        <p>
         The main question is how to conform to the bidirectional iterator requirements. Recall that anything that behaves like an iterator is an iterator. Your iterator is not required to derive from another class to qualify as a bidirectional iterator. However, if you want your iterator to be usable by the generic algorithms, you must specify its traits.
         <a href="c17.xhtml">
          Chapter 17
         </a>
         explains that
         <code>
          iterator_traits
         </code>
         is a class template that defines, for each iterator type, five type aliases:
         <code>
          value_type
         </code>
         ,
         <code>
          difference:type
         </code>
         ,
         <code>
          iterator_category
         </code>
         ,
         <code>
          pointer
         </code>
         , and
         <code>
          reference
         </code>
         . The default implementation of the
         <code>
          iterator_traits
         </code>
         class template just grabs the five type aliases out of the iterator itself. Thus, you can simply define those type aliases directly for your iterator. The
         <code>
          const_directed_graph_iterator_impl
         </code>
         is a bidirectional iterator, so you specify
         <code>
          bidirectional_iterator_tag
         </code>
         as the iterator category. Other legal iterator categories are
         <code>
          input_iterator_tag
         </code>
         ,
         <code>
          output_iterator_tag
         </code>
         ,
         <code>
          forward_iterator_tag
         </code>
         ,
         <code>
          random_access_iterator_tag
         </code>
         , and
         <code>
          contiguous_iterator_tag
         </code>
         . A contiguous iterator is a random-access iterator for which adjacent elements are also adjacent in memory. For the
         <code>
          const_directed_graph_iterator_impl
         </code>
         , the element type (
         <code>
          value_type
         </code>
         ) is
         <code>
          typename DirectedGraph::value_type
         </code>
         .
         <span aria-label="930" epub:type="pagebreak" id="Page_930" role="doc-pagebreak">
         </span>
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c25-para-0102">
            <b>
             NOTE
            </b>
            <i>
             In the past, it was recommended to derive custom iterators from the
            </i>
            <code>
             std::iterator
            </code>
            <i>
             class template, defined in
            </i>
            <code>
             &lt;iterator&gt;
            </code>
            <i>
             . This class template has been deprecated and should not be used anymore.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         Here is the
         <code>
          const_directed_graph_iterator_impl
         </code>
         class template definition:
        </p>
        <pre id="c25-code-0049"><code>template &lt;typename DirectedGraph&gt;</code>
<code>class const_directed_graph_iterator_impl</code>
<code>{</code>
<code>    public:</code>
<code>        using value_type = typename DirectedGraph::value_type;</code>
<code>        using difference:type = std::ptrdiff_t;</code>
<code>        using iterator_category = std::bidirectional_iterator_tag;</code>
<code>        using pointer = const value_type*;</code>
<code>        using reference = const value_type&amp;;</code>
<code>        using node_container_iterator =</code>
<code>            typename DirectedGraph::node_container_type::const_iterator;</code>
<code> </code>
<code>        <span class="color3">// Bidirectional iterators must supply a default constructor.</span></code>
<code>        const_directed_graph_iterator_impl() = default;</code>
<code> </code>
<code>        explicit const_directed_graph_iterator_impl(node_container_iterator it);</code>
<code> </code>
<code>        reference operator*() const;</code>
<code> </code>
<code>        <span class="color3">// Return type must be something to which -&gt; can be applied.</span></code>
<code>        <span class="color3">// So, return a pointer.</span></code>
<code>        pointer operator-&gt;() const;</code>
<code> </code>
<code>        const_directed_graph_iterator_impl&amp; operator++();</code>
<code>        const_directed_graph_iterator_impl operator++(int);</code>
<code> </code>
<code>        const_directed_graph_iterator_impl&amp; operator--();</code>
<code>        const_directed_graph_iterator_impl operator--(int);</code>
<code> </code>
<code>        <span class="color3">// Defaulted operator==.</span></code>
<code>        bool operator==(const const_directed_graph_iterator_impl&amp;) const = default;</code>
<code> </code>
<code>    private:</code>
<code>        friend class directed_graph&lt;value_type&gt;;</code>
<code> </code>
<code>        node_container_iterator m_nodeIterator;</code>
<code>};</code></pre>
        <p id="c25-para-0104">
         Consult
         <a href="c15.xhtml">
          Chapter 15
         </a>
         for details on operator overloading if the definitions and implementations (shown in the next section) of the overloaded operators confuse you. The
         <code>
          const_directed_graph_iterator_impl
         </code>
         implementation does not need copy/move constructors and copy/move assignment operators, as the default behavior is what we want. The class also does not need an explicit destructor, as there's nothing to clean up. Hence, this class also follows the rule of zero.
        </p>
       </section>
       <span aria-label="931" epub:type="pagebreak" id="Page_931" role="doc-pagebreak">
       </span>
       <section>
        <span id="c25-sec-0036">
        </span>
        <h5 id="head-5-158">
         The const_directed_graph_iterator_impl Member Function Implementations
        </h5>
        <p>
         The
         <code>
          const_directed_graph_iterator_impl
         </code>
         constructor initializes the data member:
        </p>
        <pre id="c25-code-0050"><code>template &lt;typename DirectedGraph&gt;</code>
<code>const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::</code>
<code>    const_directed_graph_iterator_impl(node_container_iterator it)</code>
<code>        : m_nodeIterator { it } { }</code></pre>
        <p id="c25-para-0106">
         The default constructor is defaulted so that clients can declare
         <code>
          const_directed_graph_iterator_impl
         </code>
         variables without initializing them. An iterator constructed with the default constructor does not need to refer to any value, and attempting any operations on it is allowed to have undefined results.
        </p>
        <p>
         The implementations of the dereferencing operators are concise but can look tricky.
         <a href="c15.xhtml">
          Chapter 15
         </a>
         explains that
         <code>
          operator*
         </code>
         and
         <code>
          -&gt;
         </code>
         are asymmetric:
        </p>
        <ul class="check1" id="c25-list-0003">
         <li id="c25-li-0005">
          <code>
           operator*
          </code>
          returns a reference to the actual underlying value, which in this case is the element to which the iterator refers.
         </li>
         <li id="c25-li-0006">
          <code>
           operator-&gt;
          </code>
          must return something to which the arrow operator can be applied again, and thus returns a pointer to the element. The compiler then applies
          <code>
           -&gt;
          </code>
          to the pointer, which results in accessing a field or member function of the element.
         </li>
        </ul>
        <pre id="c25-code-0051"><code><span class="color3">// Return a reference to the actual element.</span></code>
<code>template &lt;typename DirectedGraph&gt;</code>
<code>typename const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::reference</code>
<code>    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator*() const</code>
<code>{</code>
<code>    return m_nodeIterator-&gt;value();</code>
<code>}</code>
<code> </code>
<code><span class="color3">// Return a pointer to the actual element, so the compiler can</span></code>
<code><span class="color3">// apply -&gt; to it to access the actual desired field.</span></code>
<code>template &lt;typename DirectedGraph&gt;</code>
<code>typename const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::pointer</code>
<code>    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator-&gt;() const</code>
<code>{</code>
<code>    return &amp;m_nodeIterator-&gt;value();</code>
<code>}</code></pre>
        <p>
         The increment operators are implemented as follows. The decrement operators are not shown as they are implemented analogously.
        </p>
        <pre id="c25-code-0052"><code>template &lt;typename DirectedGraph&gt;</code>
<code>const_directed_graph_iterator_impl&lt;DirectedGraph&gt;&amp;</code>
<code>    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator++()</code>
<code>{</code>
<code>    ++m_nodeIterator;</code>
<code>    return *this;</code>
<code>}</code>
<code> </code>
<span aria-label="932" epub:type="pagebreak" id="Page_932" role="doc-pagebreak"></span><code>template &lt;typename DirectedGraph&gt;</code>
<code>const_directed_graph_iterator_impl&lt;DirectedGraph&gt;</code>
<code>    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator++(int)</code>
<code>{</code>
<code>    auto oldIt { *this };</code>
<code>    ++*this;</code>
<code>    return oldIt;</code>
<code>}</code></pre>
        <p id="c25-para-0109">
         Iterators are not required to be any safer than raw pointers, so error-checking for things like incrementing an iterator already at the end is not required.
        </p>
        <p>
         The
         <code>
          node_container_iterator
         </code>
         type alias of
         <code>
          const_directed_graph_iterator_impl
         </code>
         uses the private
         <code>
          node_container_type
         </code>
         type alias of
         <code>
          directed_graph
         </code>
         . Thus, the
         <code>
          directed_graph
         </code>
         class template must declare
         <code>
          const_directed_graph_iterator_impl
         </code>
         to be a
         <code>
          friend
         </code>
         :
        </p>
        <pre id="c25-code-0053"><code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    <span class="color3">// Other member functions omitted for brevity.</span></code>
<code>    private:</code>
<code>        <b>friend class const_directed_graph_iterator_impl&lt;directed_graph&gt;;</b></code>
<code>};</code></pre>
       </section>
       <section>
        <span id="c25-sec-0037">
        </span>
        <h5 id="head-5-159">
         Iterator Type Aliases and Access Member Functions
        </h5>
        <p>
         The final piece involved in providing iterator support for
         <code>
          directed_graph
         </code>
         is to supply the necessary type aliases in the
         <code>
          directed_graph
         </code>
         class template, and to write the
         <code>
          begin()
         </code>
         ,
         <code>
          end()
         </code>
         ,
         <code>
          cbegin()
         </code>
         , and
         <code>
          cend()
         </code>
         member functions. The type aliases and member function prototypes look like this:
        </p>
        <pre id="c25-code-0054"><code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Other type aliases omitted for brevity.</span></code>
<code>        <b>using iterator = const_directed_graph_iterator_impl&lt;directed_graph&gt;;</b></code>
<code>        <b>using const_iterator = const_directed_graph_iterator_impl&lt;directed_graph&gt;;</b></code>
<code> </code>
<code>        <span class="color3">// Iterator member functions.</span></code>
<code>        <b>iterator begin() noexcept;</b></code>
<code>        <b>iterator end() noexcept;</b></code>
<code>        <b>const_iterator begin() const noexcept;</b></code>
<code>        <b>const_iterator end() const noexcept;</b></code>
<code>        <b>const_iterator cbegin() const noexcept;</b></code>
<code>        <b>const_iterator cend() const noexcept;</b></code>
<code>        <span class="color3">// Remainder of class definition omitted for brevity.</span></code>
<code>};</code></pre>
        <p id="c25-para-0112">
         Both
         <code>
          iterator
         </code>
         and
         <code>
          const_iterator
         </code>
         are type aliases for
         <code>
          const_directed_graph_iterator_impl
         </code>
         , which means users cannot modify the values to which
         <code>
          directed_graph
         </code>
         iterators refer. Node values in a
         <code>
          directed_graph
         </code>
         must be unique. Allowing the user to modify the value of a node through an iterator would allow the possibility of introducing duplicate values. This follows the same principle as
         <code>
          std::set
         </code>
         , in which you also cannot modify elements.
        </p>
        <p id="c25-para-0113">
         As
         <code>
          iterator
         </code>
         and
         <code>
          const_iterator
         </code>
         are both type aliases for
         <code>
          const_directed_graph_iterator_impl
         </code>
         , the non-
         <code>
          const begin()
         </code>
         and
         <code>
          end()
         </code>
         member functions returning
         <code>
          iterator
         </code>
         are not strictly
         <span aria-label="933" epub:type="pagebreak" id="Page_933" role="doc-pagebreak">
         </span>
         necessary; the
         <code>
          const
         </code>
         overloads are enough. However, the Standard Library requirements state that a container must supply non-
         <code>
          const begin()
         </code>
         and
         <code>
          end()
         </code>
         overloads.
        </p>
        <p>
         The
         <code>
          directed_graph
         </code>
         class template stores all its nodes in a simple
         <code>
          vector
         </code>
         . As such,
         <code>
          begin()
         </code>
         and
         <code>
          end()
         </code>
         can simply forward their work to the identically named member functions on
         <code>
          vector
         </code>
         and wrap those results in a
         <code>
          const_directed_graph_iterator_impl
         </code>
         :
        </p>
        <pre id="c25-code-0055"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::iterator</code>
<code>    directed_graph&lt;T&gt;::begin() noexcept { return iterator{ std::begin(m_nodes) }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::iterator</code>
<code>    directed_graph&lt;T&gt;::end() noexcept { return iterator { std::end(m_nodes) }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_iterator</code>
<code>    directed_graph&lt;T&gt;::begin() const noexcept</code>
<code>{ return const_iterator { std::begin(m_nodes) }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_iterator</code>
<code>    directed_graph&lt;T&gt;::end() const noexcept</code>
<code>{ return const_iterator { std::end(m_nodes) }; }</code></pre>
        <p>
         The
         <code>
          cbegin()
         </code>
         and
         <code>
          cend()
         </code>
         member functions forward the request to the
         <code>
          const
         </code>
         overloads of
         <code>
          begin()
         </code>
         and
         <code>
          end()
         </code>
         :
        </p>
        <pre id="c25-code-0056"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_iterator</code>
<code>    directed_graph&lt;T&gt;::cbegin() const noexcept { return begin(); }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_iterator</code>
<code>    directed_graph&lt;T&gt;::cend() const noexcept { return end(); }</code></pre>
       </section>
       <section>
        <span id="c25-sec-0038">
        </span>
        <h5 id="head-5-160">
         Modifying Other Member Functions to Use Iterators
        </h5>
        <p>
         Now that
         <code>
          directed_graph
         </code>
         supports iterators, other member functions can be slightly modified to work with iterators so that they follow the Standard Library guidelines. Let's look at the
         <code>
          insert()
         </code>
         member function first. In the earlier basic implementation, it is defined as follows:
        </p>
        <pre id="c25-code-0057"><code><span class="color3">// For an insert to be successful, the value shall not be in the graph yet.</span></code>
<code><span class="color3">// Returns true if a new node with given value has been added to</span></code>
<code><span class="color3">// the graph, and false if there was already a node with the given value.</span></code>
<code>bool insert(T node_value);</code></pre>
        <p>
         To follow more closely the spirit of the Standard Library, this can be modified to return an
         <code>
          std::pair&lt;iterator, bool&gt;
         </code>
         where the Boolean is
         <code>
          true
         </code>
         if the element was added to the graph, and
         <code>
          false
         </code>
         if the element was already in the graph. The iterator of the
         <code>
          pair
         </code>
         refers to the newly added element or the element that was already in the graph.
        </p>
        <pre id="c25-code-0058"><code>std::pair&lt;iterator, bool&gt; insert(T node_value);</code></pre>
        <p>
         The implementation is as follows. The changes compared to the version returning a simple
         <code>
          bool
         </code>
         are highlighted.
        </p>
        <pre id="c25-code-0059"><span aria-label="934" epub:type="pagebreak" id="Page_934" role="doc-pagebreak"></span><code>template &lt;typename T&gt;</code>
<code><b>std::pair&lt;typename directed_graph&lt;T&gt;::iterator, bool&gt;</b></code>
<code>    directed_graph&lt;T&gt;::insert(T node_value)</code>
<code>{</code>
<code>    auto iter { find_node(node_value) };</code>
<code>    if (iter != std::end(m_nodes)) {</code>
<code>        <span class="color3">// Value is already in the graph.</span></code>
<code>        <b>return { iterator { iter }, false };</b></code>
<code>    }</code>
<code>    m_nodes.emplace:back(this, std::move(node_value));</code>
<code>    <span class="color3">// Value successfully added to the graph.</span></code>
<code>    <b>return { iterator { std::prev(std::end(m_nodes)) }, true };</b></code>
<code>}</code></pre>
        <p>
         Additionally, an overload of
         <code>
          insert()
         </code>
         is provided that accepts an iterator hint. This hint is useless for a
         <code>
          directed_graph
         </code>
         , but it is provided for symmetry with other Standard Library containers, such as
         <code>
          std::vector
         </code>
         . The hint is ignored, and it merely calls the overload of
         <code>
          insert()
         </code>
         without the hint.
        </p>
        <pre id="c25-code-0060"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::iterator</code>
<code>    directed_graph&lt;T&gt;::insert(const_iterator hint, T node_value)</code>
<code>{</code>
<code>    <span class="color3">// Ignore the hint, just forward to another insert().</span></code>
<code>    return insert(std::move(node_value)).first;</code>
<code>}</code></pre>
        <p>
         A last overload of
         <code>
          insert()
         </code>
         accepts an iterator range. This overload is a member function template so that it can take an iterator range from any container, not just other
         <code>
          directed_graph
         </code>
         s. The actual implementation uses an
         <code>
          insert_iterator
         </code>
         , described
         <a href="c17.xhtml">
          Chapter 17
         </a>
         .
        </p>
        <pre id="c25-code-0061"><code>template &lt;typename T&gt;</code>
<code>template &lt;std::input_iterator Iter&gt;</code>
<code>void directed_graph&lt;T&gt;::insert(Iter first, Iter last)</code>
<code>{</code>
<code>    <span class="color3">// Copy each element in the range by using an insert_iterator adapter.</span></code>
<code>    <span class="color3">// Give end() as a dummy position -- insert ignores it anyway.</span></code>
<code>    std::copy(first, last, std::insert_iterator { *this, end() });</code>
<code>}</code></pre>
        <p>
         The
         <code>
          erase()
         </code>
         member functions should be modified to work with iterators. The earlier definition has a node value as parameter and returns a
         <code>
          bool
         </code>
         :
        </p>
        <pre id="c25-code-0062"><code><span class="color3">// Returns true if the given node value was erased, false otherwise.</span></code>
<code>bool erase(const T&amp; node_value);</code></pre>
        <p>
         To follow Standard Library principles,
         <code>
          directed_graph
         </code>
         is modified to provide two
         <code>
          erase()
         </code>
         member functions: one erasing a node to which an iterator refers and another one erasing a range of nodes given as an iterator range. Both return an iterator to the node after the last deleted node:
        </p>
        <pre id="c25-code-0063"><code><span class="color3">// Returns an iterator to the element after the last deleted element.</span></code>
<code>iterator erase(const_iterator pos);</code>
<code>iterator erase(const_iterator first, const_iterator last);</code></pre>
        <p>
         Here are the implementations:
        </p>
        <pre id="c25-code-0064"><span aria-label="935" epub:type="pagebreak" id="Page_935" role="doc-pagebreak"></span><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::iterator</code>
<code>    directed_graph&lt;T&gt;::erase(const_iterator pos)</code>
<code>{</code>
<code>    if (pos.m_nodeIterator == std::end(m_nodes)) {</code>
<code>        return end();</code>
<code>    }</code>
<code>    remove_all_links_to(pos.m_nodeIterator);</code>
<code>    return iterator { m_nodes.erase(pos.m_nodeIterator) };</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::iterator</code>
<code>    directed_graph&lt;T&gt;::erase(const_iterator first, const_iterator last)</code>
<code>{</code>
<code>    for (auto iter { first }; iter != last; ++iter) {</code>
<code>        remove_all_links_to(iter.m_nodeIterator);</code>
<code>    }</code>
<code>    return iterator { m_nodes.erase(first.m_nodeIterator, last.m_nodeIterator) };</code>
<code>}</code></pre>
        <p>
         Finally, the following public
         <code>
          find()
         </code>
         member function can be implemented returning an iterator. The implementation is left as an exercise at the end of this chapter.
        </p>
        <pre id="c25-code-0065"><code>const_iterator find(const T&amp; node_value) const;</code></pre>
       </section>
       <section>
        <span id="c25-sec-0039">
        </span>
        <h5 id="head-5-161">
         Using the directed_graph Iterators
        </h5>
        <p>
         Now that
         <code>
          directed_graph
         </code>
         supports iterators, you can iterate over its elements just as you would with any other Standard Library container, and you can pass the iterators to member functions and functions. Here are some examples:
        </p>
        <pre id="c25-code-0066"><code>directed_graph&lt;int&gt; graph;</code>
<code><span class="color3">// Populate the graph, omitted (see downloadable source code archive) …</span></code>
<code> </code>
<code><span class="color3">// Try to insert a duplicate, and use structured bindings for the result.</span></code>
<code>auto [iter22, inserted] { graph.insert(22) };</code>
<code>if (!inserted) { println("Duplicate element."); }</code>
<code> </code>
<code><span class="color3">// Print nodes using a for loop and iterators.</span></code>
<code>for (auto iter { graph.cbegin() }; iter != graph.cend(); ++iter) {</code>
<code>    print("{} ", *iter);</code>
<code>}</code>
<code>println("");</code>
<code> </code>
<code><span class="color3">// Print nodes using a for loop and iterators retrieved with the non-member</span></code>
<code><span class="color3">// functions cbegin() and cend().</span></code>
<code>for (auto iter { cbegin(graph) }; iter != cend(graph); ++iter) {</code>
<code>    print("{} ", *iter);</code>
<code>}</code>
<code>println("");</code>
<code> </code>
<code><span class="color3">// Print nodes using a range-based for loop.</span></code>
<code>for (auto&amp; node : graph) { print("{} ", node); }</code>
<code>println("");</code>
<code> </code>
<span aria-label="936" epub:type="pagebreak" id="Page_936" role="doc-pagebreak"></span><code><span class="color3">// Search a node using the find() Standard Library algorithm.</span></code>
<code>auto result { find(begin(graph), end(graph), 22) };</code>
<code>if (result != end(graph)) {</code>
<code> println("Node 22 found.");</code>
<code>} else {</code>
<code> println("Node 22 NOT found.");</code>
<code>}</code>
<code> </code>
<code><span class="color3">// Count all nodes with values &gt; 22.</span></code>
<code>auto count { count_if(begin(graph), end(graph),</code>
<code>    [](const auto&amp; node) { return node &gt; 22; }) };</code>
<code>println("{} nodes &gt; 22", count);</code>
<code> </code>
<code><span class="color3">// Use the iterator-based erase() member function in combination with find().</span></code>
<code>graph.erase(find(begin(graph), end(graph), 44));</code></pre>
        <p>
         This code snippet also shows that, thanks to the support for iterators, Standard Library algorithms can be used with a
         <code>
          directed_graph
         </code>
         . However, since
         <code>
          directed_graph
         </code>
         supports only
         <code>
          const
         </code>
         iterators, only non-modifying Standard Library algorithms are supported, just as with
         <code>
          std::set
         </code>
         . For example, the following code snippet using the remove-erase idiom does not compile:
        </p>
        <pre id="c25-code-0067"><code>graph.erase(remove_if(begin(graph), end(graph),</code>
<code>    [](const auto&amp; node) { return node &gt; 22; }), end(graph));</code></pre>
       </section>
       <section>
        <span id="c25-sec-0040">
        </span>
        <h5 id="head-5-162">
         Adding Support for Reverse Iterators
        </h5>
        <p id="c25-para-0127">
         If your container supplies bidirectional iterators, it is considered
         <i>
          reversible
         </i>
         . Reversible containers should have two additional type aliases:
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            TYPE NAME
           </th>
           <th class="left bgcolor2" scope="col">
            DESCRIPTION
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             reverse_iterator
            </span>
           </td>
           <td class="left bgcolor3">
            The type for iterating over elements of the container in reverse order
           </td>
          </tr>
          <tr>
           <td class="left bgcolor3">
            <span class="forecolor1">
             const_reverse_iterator
            </span>
           </td>
           <td class="left bgcolor3">
            A version of
            <span class="forecolor1">
             reverse_iterator
            </span>
            for iterating over
            <code>
             const
            </code>
            elements of the container in reverse order
           </td>
          </tr>
         </tbody>
        </table>
        <p id="c25-para-0129">
         Additionally, the container should provide
         <code>
          rbegin()
         </code>
         and
         <code>
          rend()
         </code>
         , which are symmetric with
         <code>
          begin()
         </code>
         and
         <code>
          end()
         </code>
         ; and it should provide
         <code>
          crbegin()
         </code>
         and
         <code>
          crend()
         </code>
         , which are symmetric with
         <code>
          cbegin()
         </code>
         and
         <code>
          cend()
         </code>
         .
        </p>
        <p>
         The
         <code>
          directed_graph
         </code>
         iterators are bidirectional, which means they should support reverse iteration. The following code snippet highlights the necessary changes. The two new type aliases use the
         <code>
          std::reverse_iterator
         </code>
         adapter provided by the Standard Library and described in
         <a href="c17.xhtml">
          Chapter 17
         </a>
         to convert the
         <code>
          directed_graph
         </code>
         iterators to behave as reverse iterators.
        </p>
        <pre id="c25-code-0068"><code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Other type aliases omitted for brevity.</span></code>
<code>        <b>using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;</b></code>
<code>        <b>using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;</b></code>
<code> </code>
<code>        <span class="color3">// Reverse iterator member functions.</span></code>
<code>        <b>reverse_iterator rbegin() noexcept;</b></code>
<code>        <b>reverse_iterator rend() noexcept;</b></code>
<span aria-label="937" epub:type="pagebreak" id="Page_937" role="doc-pagebreak"></span><code>        <b>const_reverse_iterator rbegin() const noexcept;</b></code>
<code>        <b>const_reverse_iterator rend() const noexcept;</b></code>
<code>        <b>const_reverse_iterator crbegin() const noexcept;</b></code>
<code>        <b>const_reverse_iterator crend() const noexcept;</b></code>
<code>        <span class="color3">// Remainder of class definition omitted for brevity.</span></code>
<code>};</code></pre>
        <p>
         The implementations of the reverse iterator member functions are as follows.
        </p>
        <pre id="c25-code-0069"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::reverse_iterator</code>
<code>    directed_graph&lt;T&gt;::rbegin() noexcept { return reverse_iterator { end() }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::reverse_iterator</code>
<code>    directed_graph&lt;T&gt;::rend() noexcept { return reverse_iterator { begin() }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code>    directed_graph&lt;T&gt;::rbegin() const noexcept</code>
<code>{ return const_reverse_iterator { end() }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code>    directed_graph&lt;T&gt;::rend() const noexcept</code>
<code>{ return const_reverse_iterator { begin() }; }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code>    directed_graph&lt;T&gt;::crbegin() const noexcept { return rbegin(); }</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code>    directed_graph&lt;T&gt;::crend() const noexcept { return rend(); }</code></pre>
        <p>
         The following code snippet shows how to print all the nodes of a graph in reverse order:
        </p>
        <pre id="c25-code-0070"><code>for (auto iter { graph.rbegin() }; iter != graph.rend(); ++iter) {</code>
<code>    print("{} ", *iter);</code>
<code>}</code></pre>
       </section>
       <section>
        <span id="c25-sec-0041">
        </span>
        <h5 id="head-5-163">
         Iterating over Adjacent Nodes
        </h5>
        <p id="c25-para-0133">
         A
         <code>
          directed_graph
         </code>
         keeps a
         <code>
          vector
         </code>
         of nodes, where each node contains the node's value and a list of adjacent nodes. Let's improve the
         <code>
          directed_graph
         </code>
         interface to support iteration over the adjacent nodes of a given node without copying those nodes into another container as it is done in the earlier implementation of
         <code>
          get_adjacent_nodes_values()
         </code>
         . The first thing to add is a
         <code>
          const_adjacent_nodes_iterator_impl
         </code>
         class template following the same principles as
         <code>
          const_directed_graph_iterator_impl
         </code>
         so the code is not shown. Consult the downloadable source code archive to see the full code.
        </p>
        <p>
         The next step is to augment the
         <code>
          directed_graph
         </code>
         interface with a new type alias, a helper structure to represent adjacent nodes as a range, and a member function to get access to the adjacent nodes of a
         <span aria-label="938" epub:type="pagebreak" id="Page_938" role="doc-pagebreak">
         </span>
         given node value. The
         <code>
          nodes_adjacent_to()
         </code>
         member function returns an empty
         <code>
          optional
         </code>
         when the given node value cannot be found.
        </p>
        <pre id="c25-code-0071"><code>export template &lt;typename T&gt;</code>
<code>class directed_graph</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Other type aliases omitted for brevity.</span></code>
<code>        <b>using const_adjacent_nodes_iterator =</b></code>
<code>            <b>const_adjacent_nodes_iterator_impl&lt;directed_graph&gt;;</b></code>
<code> </code>
<code>        <span class="color3">// Helper structure to represent a range of adjacent nodes.</span></code>
<code>        <b>struct nodes_adjacent_to_result</b></code>
<code>        <b>{</b></code>
<code>            <b>const_adjacent_nodes_iterator m_begin;</b></code>
<code>            <b>const_adjacent_nodes_iterator m_end;</b></code>
<code>            <b>const_adjacent_nodes_iterator begin() const noexcept{ return m_begin; }</b></code>
<code>            <b>const_adjacent_nodes_iterator end() const noexcept { return m_end; }</b></code>
<code>        <b>};</b></code>
<code> </code>
<code>        <span class="color3">// Returns a range with the adjacent nodes for the given node value.</span></code>
<code>        <b>std::optional&lt;nodes_adjacent_to_result&gt; nodes_adjacent_to(</b></code>
<code>            <b>const T&amp; node_value) const noexcept;</b></code>
<code>        <span class="color3">// Remainder of class definition omitted for brevity.</span></code>
<code>};</code></pre>
        <p>
         Here is the implementation of the
         <code>
          nodes_adjacent_to()
         </code>
         member function:
        </p>
        <pre id="c25-code-0072"><code>template &lt;typename T&gt;</code>
<code>std::optional&lt;typename directed_graph&lt;T&gt;::nodes_adjacent_to_result&gt;</code>
<code>    directed_graph&lt;T&gt;::nodes_adjacent_to(const T&amp; node_value) const noexcept</code>
<code>{</code>
<code>    auto iter { find_node(node_value) };</code>
<code>    if (iter == std::end(m_nodes)) { return {}; }</code>
<code>    return nodes_adjacent_to_result {</code>
<code>        const_adjacent_nodes_iterator {</code>
<code>            std::cbegin(iter-&gt;get_adjacent_nodes_indices()), this },</code>
<code>        const_adjacent_nodes_iterator {</code>
<code>            std::cend(iter-&gt;get_adjacent_nodes_indices()), this }</code>
<code>    };</code>
<code>}</code></pre>
        <p>
         With
         <code>
          nodes_adjacent_to()
         </code>
         , accessing all adjacent nodes of a given node becomes trivial. Here is an example to print all adjacent nodes of the node with value 22.
        </p>
        <pre id="c25-code-0073"><code>print("Adjacency list for node 22: ");</code>
<code>auto nodesAdjacentTo22 { graph.nodes_adjacent_to(22) };</code>
<code>if (!nodesAdjacentTo22.has_value()) {</code>
<code>    println("Value 22 not found.");</code>
<code>} else {</code>
<code>    for (const auto&amp; node : *nodesAdjacentTo22) { print("{} ", node); }</code>
<code>}</code></pre>
       </section>
       <span aria-label="939" epub:type="pagebreak" id="Page_939" role="doc-pagebreak">
       </span>
       <section>
        <span id="c25-sec-0042">
        </span>
        <h5 id="head-5-164">
         Printing Graphs
        </h5>
        <p>
         Now that
         <code>
          directed_graph
         </code>
         supports
         <code>
          nodes_adjacent_to()
         </code>
         , the
         <code>
          to_dot()
         </code>
         helper function template to print a graph can be simplified:
        </p>
        <pre id="c25-code-0074"><code>export template &lt;typename T&gt;</code>
<code>std::string to_dot(const directed_graph&lt;T&gt;&amp; graph, std::string_view graph_name)</code>
<code>{</code>
<code>    std::ostringstream output;</code>
<code>    std::println(output, "digraph {} {{", graph_name);</code>
<code>    for (auto&amp;&amp; node : graph) {</code>
<code>        auto adjacent_nodes { graph.nodes_adjacent_to(node) };</code>
<code>        if (adjacent_nodes-&gt;begin() == adjacent_nodes-&gt;end()) {</code>
<code>            std::println(output, "{}", node);</code>
<code>        } else {</code>
<code>            for (const auto&amp; adjacent_node : *adjacent_nodes) {</code>
<code>                std::println(output, "{} -&gt; {}", node, adjacent_node);</code>
<code>            }</code>
<code>        }</code>
<code>    }</code>
<code>    std::println(output, "}}");</code>
<code>    return std::move(output).str();</code>
<code>}</code></pre>
       </section>
      </section>
      <section>
       <span id="c25-sec-0043">
       </span>
       <h4 id="head-4-366">
        Additional Standard Library–Like Functionality
       </h4>
       <p>
        A few more Standard Library–like features can be added to the
        <code>
         directed_graph
        </code>
        class template. First, let's add
        <code>
         assign()
        </code>
        member functions like
        <code>
         vector
        </code>
        has. The
        <code>
         assign()
        </code>
        member function accepting an iterator range is again a member function template, just like the iterator-based
        <code>
         insert()
        </code>
        discussed earlier in this chapter:
       </p>
       <pre id="c25-code-0075"><code>template &lt;std::input_iterator Iter&gt;</code>
<code>void assign(Iter first, Iter last);</code>
<code> </code>
<code>void assign(std::initializer_list&lt;T&gt; il);</code></pre>
       <p>
        These allow you to assign all elements of a given iterator range or an
        <code>
         initializer_list
        </code>
        , discussed in
        <a href="c01.xhtml">
         Chapter 1
        </a>
        , to a directed graph. Assignment means that the current graph is cleared, and new nodes are inserted. Despite the syntax, the implementations are easy:
       </p>
       <pre id="c25-code-0076"><code>template &lt;typename T&gt;</code>
<code>template &lt;std::input_iterator Iter&gt;</code>
<code>void directed_graph&lt;T&gt;::assign(Iter first, Iter last)</code>
<code>{</code>
<code>    clear();</code>
<code>    for (auto iter { first }; iter != last; ++iter) { insert(*iter); }</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>void directed_graph&lt;T&gt;::assign(std::initializer_list&lt;T&gt; il)</code>
<code>{</code>
<code>    assign(std::begin(il), std::end(il));</code>
<code>}</code></pre>
       <p>
        <span aria-label="940" epub:type="pagebreak" id="Page_940" role="doc-pagebreak">
        </span>
        An
        <code>
         initializer_list
        </code>
        overload of
        <code>
         insert()
        </code>
        is provided as well:
       </p>
       <pre id="c25-code-0077"><code>template &lt;typename T&gt;</code>
<code>void directed_graph&lt;T&gt;::insert(std::initializer_list&lt;T&gt; il)</code>
<code>{</code>
<code>    insert(std::begin(il), std::end(il));</code>
<code>}</code></pre>
       <p>
        With this overload of
        <code>
         insert()
        </code>
        , nodes can be added as follows:
       </p>
       <pre id="c25-code-0078"><code>graph.insert({ 66, 77, 88 });</code></pre>
       <p>
        Next, an
        <code>
         initializer_list
        </code>
        constructor and assignment operator can be added. As this is the first explicit
        <code>
         directed_graph
        </code>
        constructor and assignment operator, the default, copy, and move constructors, and the copy and move assignment operators need to be explicitly defaulted as well.
       </p>
       <pre id="c25-code-0079"><code><span class="color3">// Default, copy, and move constructors.</span></code>
<code>directed_graph() = default;</code>
<code>directed_graph(const directed_graph&amp;) = default;</code>
<code>directed_graph(directed_graph&amp;&amp;) noexcept = default;</code>
<code> </code>
<code><span class="color3">// initializer_list constructor.</span></code>
<code>directed_graph(std::initializer_list&lt;T&gt; il);</code>
<code> </code>
<code><span class="color3">// Copy and move assignment operators.</span></code>
<code>directed_graph&amp; operator=(const directed_graph&amp;) = default;</code>
<code>directed_graph&amp; operator=(directed_graph&amp;&amp;) noexcept = default;</code>
<code> </code>
<code><span class="color3">// initializer_list assignment operator.</span></code>
<code>directed_graph&amp; operator=(std::initializer_list&lt;T&gt; il);</code></pre>
       <p>
        Here are the implementations of the
        <code>
         initializer_list
        </code>
        constructor and assignment operator:
       </p>
       <pre id="c25-code-0080"><code>template &lt;typename T&gt;</code>
<code>directed_graph&lt;T&gt;::directed_graph(std::initializer_list&lt;T&gt; il)</code>
<code>{</code>
<code>    assign(std::begin(il), std::end(il));</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt;</code>
<code>directed_graph&lt;T&gt;&amp; directed_graph&lt;T&gt;::operator=(</code>
<code>    std::initializer_list&lt;T&gt; il)</code>
<code>{</code>
<code>    <span class="color3">// Use a copy-and-swap-like algorithm to guarantee strong exception safety.</span></code>
<code>    <span class="color3">// Do all the work in a temporary instance.</span></code>
<code>    directed_graph new_graph { il };</code>
<code>    <span class="color3">swap(new_graph); // Commit the work with only non-throwing operations.</span></code>
<code>    return *this;</code>
<code>}</code></pre>
       <p>
        With these in place, a
        <code>
         directed_graph
        </code>
        can be constructed using uniform initialization, as follows:
       </p>
       <pre id="c25-code-0081"><code>directed_graph&lt;int&gt; graph { 11, 22, 33 };</code></pre>
       <p>
        <span aria-label="941" epub:type="pagebreak" id="Page_941" role="doc-pagebreak">
        </span>
        instead of the following:
       </p>
       <pre id="c25-code-0082"><code>directed_graph&lt;int&gt; graph;</code>
<code>graph.insert(11);</code>
<code>graph.insert(22);</code>
<code>graph.insert(33);</code></pre>
       <p>
        And you can assign to a graph as follows:
       </p>
       <pre id="c25-code-0083"><code>graph = { 66, 77, 88 };</code></pre>
       <p>
        Thanks to the
        <code>
         initializer_list
        </code>
        constructor and class template argument deduction (CTAD), you can even drop the element type when constructing a
        <code>
         directed_graph
        </code>
        , just as with
        <code>
         vector
        </code>
        :
       </p>
       <pre id="c25-code-0084"><code>directed_graph graph { 11, 22, 33 };</code></pre>
       <p>
        A constructor accepting an iterator range of elements can be added as well. This is again a member function template, similar to
        <code>
         assign()
        </code>
        accepting an iterator range. The implementation simply forwards the work to
        <code>
         assign()
        </code>
        :
       </p>
       <pre id="c25-code-0085"><code>template &lt;typename T&gt;</code>
<code>template &lt;std::input_iterator Iter&gt;</code>
<code>directed_graph&lt;T&gt;::directed_graph(Iter first, Iter last)</code>
<code>{</code>
<code>    assign(first, last);</code>
<code>}</code></pre>
       <p>
        C++23 adds an
        <code>
         insert_range()
        </code>
        member function to most Standard Library containers, which can be added to
        <code>
         directed_graph
        </code>
        as well. This implementation uses the
        <code>
         std::ranges::input_range
        </code>
        concept to constrain the
        <code>
         Range
        </code>
        template type parameter.
       </p>
       <pre id="c25-code-0086"><code>template &lt;typename T&gt;</code>
<code>template &lt;std::ranges::input_range Range&gt;</code>
<code>void directed_graph&lt;T&gt;::insert_range(Range&amp;&amp; range)</code>
<code>{</code>
<code>    insert(std::ranges::begin(range), std::ranges::end(range));</code>
<code>}</code></pre>
       <p>
        With
        <code>
         insert_range()
        </code>
        you can easily insert elements from any range, for example, from a
        <code>
         vector
        </code>
        :
       </p>
       <pre id="c25-code-0087"><code>vector moreNodes { 66, 77 };</code>
<code>graph.insert_range(moreNodes);</code></pre>
       <p>
        Finally, an extra overload of
        <code>
         erase()
        </code>
        accepting a node value can be added. Similar to
        <code>
         std::set
        </code>
        , it returns the number of nodes erased, which is always 0 or 1 for
        <code>
         directed_graph
        </code>
        .
       </p>
       <pre id="c25-code-0088"><code>template &lt;typename T&gt;</code>
<code>typename directed_graph&lt;T&gt;::size_type directed_graph&lt;T&gt;::erase(</code>
<code>    const T&amp; node_value)</code>
<code>{</code>
<code>    const auto iter { find_node(node_value) };</code>
<code>    if (iter != std::end(m_nodes)) {</code>
<code>        remove_all_links_to(iter);</code>
<code>        m_nodes.erase(iter);</code>
<code>        return 1;</code>
<code>    }</code>
<code>    return 0;</code>
<code>}</code></pre>
      </section>
      <span aria-label="942" epub:type="pagebreak" id="Page_942" role="doc-pagebreak">
      </span>
      <section>
       <span id="c25-sec-0044">
       </span>
       <h4 id="head-4-367">
        Further Improvements
       </h4>
       <p>
        There are several improvements that can be made to the
        <code>
         directed_graph
        </code>
        class template. Here are a few:
       </p>
       <ul class="check1" id="c25-list-0004">
        <li id="c25-li-0007">
         The current implementation does not check for cycles in the graph. Such a check could be added to make the graph a
         <i>
          directed acyclic graph
         </i>
         .
        </li>
        <li id="c25-li-0008">
         Instead of supporting bidirectional iterators, support for random-access iterators could be implemented.
        </li>
        <li id="c25-li-0009">
         The Standard Library associative containers support node-related functionality, see
         <a href="c18.xhtml">
          Chapter 18
         </a>
         . The
         <code>
          directed_graph
         </code>
         class template could be improved to include a
         <code>
          node_type
         </code>
         type alias and member functions such as
         <code>
          extract()
         </code>
         .
        </li>
        <li id="c25-li-0010">
         A more complicated improvement might be to add support for custom allocators, just as all Standard Library containers have. This would require using Standard Library functionality from
         <code>
          std::allocator_traits&lt;A&gt;
         </code>
         , such as
         <code>
          construct()
         </code>
         ,
         <code>
          destroy()
         </code>
         ,
         <code>
          propagate_on_container_move_assignment
         </code>
         ,
         <code>
          propagate_on_container_copy_assignment
         </code>
         ,
         <code>
          propagate_on_container_swap
         </code>
         , and more.
        </li>
       </ul>
      </section>
      <section>
       <span id="c25-sec-0045">
       </span>
       <h4 id="head-4-368">
        Other Container Types
       </h4>
       <p id="c25-para-0153">
        The
        <code>
         directed_graph
        </code>
        class template is basically a sequential container, but due to the nature of graphs, it does implement certain functionality from associative containers, such as the return types of the
        <code>
         insert()
        </code>
        member functions.
       </p>
       <p id="c25-para-0154">
        You could also write a pure sequential container, unordered associative container, or ordered associative container. In that case, you would need to follow a specific set of requirements mandated by the Standard Library. Instead of listing them here, it's easier to point out that the
        <code>
         deque
        </code>
        container follows the prescribed sequential container requirements almost exactly. The only difference is that it provides an extra
        <code>
         resize()
        </code>
        member function (not required by the standard). An example of an ordered associative container is
        <code>
         map
        </code>
        , on which you can model your own ordered associative containers. And
        <code>
         unordered_map
        </code>
        is an example of an unordered associative container.
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-255">
     <span id="c25-sec-0046">
     </span>
     <h2 id="head-2-255">
      SUMMARY
     </h2>
     <p id="c25-para-0155">
      This chapter introduced you to the concept of allocators that allow you to customize how memory is allocated and deallocated for containers. It also showed you how to write your own algorithms that can work with data from Standard Library containers. Finally, the major part of this chapter showed almost the complete development of a Standard Library–compliant
      <code>
       directed_graph
      </code>
      container. Thanks to its iterator support,
      <code>
       directed_graph
      </code>
      is compatible with Standard Library algorithms.
     </p>
     <p id="c25-para-0156">
      In the process of reading this chapter, you ideally gained an appreciation for the steps involved in developing algorithms and containers. Even if you never write another Standard Library algorithm or container, you understand better the Standard Library's mentality and capabilities, and you can put it to better use.
     </p>
     <p id="c25-para-0157">
      <span aria-label="943" epub:type="pagebreak" id="Page_943" role="doc-pagebreak">
      </span>
      This chapter concludes the tour of the C++ Standard Library. Even with all the details given in this book, some features are still omitted. If this material excited you, and you would like more information, consult some of the resources in
      <a href="b02.xhtml">
       Appendix B
      </a>
      . Don't feel compelled to use all the features discussed in these chapters. Forcing them into your programs without a true need will just complicate your code. However, I encourage you to consider incorporating aspects of the Standard Library into your programs where they make sense. Start with the containers, maybe throw in an algorithm or two, and before you know it, you'll be a convert!
     </p>
    </section>
    <section aria-labelledby="head-2-256">
     <span id="c25-sec-0047">
     </span>
     <h2 id="head-2-256">
      EXERCISES
     </h2>
     <p id="c25-para-0158">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c25-exsec-0001">
      </span>
      <ol class="none">
       <li id="c25-ex-0001">
        <b>
         Exercise 25-1:
        </b>
        Write an algorithm called
        <code>
         transform_if()
        </code>
        , similar to the Standard Library's
        <code>
         transform()
        </code>
        , discussed in
        <a href="c20.xhtml">
         Chapter 20
        </a>
        . The difference is that
        <code>
         transform_if()
        </code>
        should accept an extra predicate and that it only transforms elements for which the predicate returns
        <code>
         true
        </code>
        . Other elements are left untouched. To test your algorithm, create an
        <code>
         array
        </code>
        of integers, and then use
        <code>
         transform_if()
        </code>
        to copy the integers into a
        <code>
         vector
        </code>
        while multiplying all odd values by 2.
       </li>
       <li id="c25-ex-0002">
        <b>
         Exercise 25-2:
        </b>
        Write an algorithm called
        <code>
         generate_fibonacci()
        </code>
        , which fills a given range with a Fibonacci series of numbers.
        <a aria-describedby="c25-note-0001" epub:type="noteref" href="#c25-note-0001" id="R_c25-note-0001" role="doc-noteref">
         <sup>
          1
         </sup>
        </a>
        The Fibonacci series starts with 0 and 1, and any subsequent value is the sum of the two previous values, so: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, and so on. Your implementation is not allowed to contain any manually written loops or be implemented using a recursive algorithm. Instead, you should use the Standard Library's
        <code>
         generate()
        </code>
        algorithm to do most of the work.
       </li>
       <li id="c25-ex-0003">
        <b>
         Exercise 25-3:
        </b>
        Implement a
        <code>
         find(const T&amp;)
        </code>
        member function for the
        <code>
         directed_graph
        </code>
        class template.
       </li>
       <li id="c25-ex-0004">
        <b>
         Exercise 25-4:
        </b>
        All associative containers have a
        <code>
         contains()
        </code>
        member function that returns
        <code>
         true
        </code>
        if a given element is in the container and
        <code>
         false
        </code>
        otherwise. As this could be useful for a
        <code>
         directed_graph
        </code>
        as well, add an implementation of
        <code>
         contains()
        </code>
        to
        <code>
         directed_graph
        </code>
        .
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c25_2" class="notesSet" role="doc-endnotes">
    <h2 id="c25_2">
     NOTE
    </h2>
    <ol class="notesList">
     <li class="noteEntry">
      <a href="#R_c25-note-0001" id="c25-note-0001" role="doc-backlink">
       1
      </a>
      The ratio of two successive Fibonacci numbers converges to the golden ratio, 1.618034 … The Fibonacci numbers and the golden ratio often occur in nature, such as branching in trees, flowering of artichokes, flower petals, shells, and many more. The golden ratio is artistically attractive for humans, and hence is often used by architects to design rooms, for the arrangements of plants in gardens, and more.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
