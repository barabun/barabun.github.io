<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   29Writing Efficient C++
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_043.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_045.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c29_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c29_1">
      <span aria-label="1065" class="calibre17" epub:type="pagebreak" id="Page_1065" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c29">
      </span>
      <span class="calibre">
       29
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Writing Efficient C++
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c29-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c29-list-0001">
         <li class="calibre9" id="c29-li-0001">
          What
          <i class="calibre18">
           efficiency
          </i>
          and
          <i class="calibre18">
           performance
          </i>
          mean
         </li>
         <li class="calibre9" id="c29-li-0002">
          What kind of language-level optimizations you can use
         </li>
         <li class="calibre9" id="c29-li-0003">
          Which design-level guidelines you can follow to design efficient programs
         </li>
         <li class="calibre9" id="c29-li-0004">
          What profiling tools are
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c29-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-292">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c29-sec-0003">
        </span>
        <p class="calibre25" id="c29-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c29-para-0005">
      The efficiency of your programs is important regardless of your application domain. If your product competes with others in the marketplace, speed can be a major differentiator: given the choice between a slower and a faster program, which one would you choose? No one would buy an operating system that takes two weeks to boot up. Even if you don't intend to sell your products, they will have users. Those users will not be happy with you if they end up wasting time waiting for your programs to complete tasks.
     </p>
     <p class="calibre13" id="c29-para-0006">
      Now that you understand the concepts of professional C++ design and coding and have tackled some of the more complex facilities that the language provides, you are ready to incorporate performance into your programs. Writing efficient programs involves thought at the design level, as well as details at the implementation level. Although this chapter falls late in this book, remember to consider performance from the beginning of your projects.
     </p>
    </section>
    <span aria-label="1066" class="calibre20" epub:type="pagebreak" id="Page_1066" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-293" class="calibre2">
     <span class="calibre" id="c29-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-293">
      OVERVIEW OF PERFORMANCE AND EFFICIENCY
     </h2>
     <p class="calibre13">
      Before delving further into the details, it's helpful to define the terms
      <i class="calibre18">
       performance
      </i>
      and
      <i class="calibre18">
       efficiency
      </i>
      , as used in this book. The
      <i class="calibre18">
       performance
      </i>
      of a program can refer to several areas, such as speed, memory usage, disk access, and network use. This chapter focuses on speed performance. The term
      <i class="calibre18">
       efficiency
      </i>
      , when applied to programs, means running without wasted effort. An efficient program completes its tasks as quickly as possible within the given circumstances. A program can be efficient without being fast, if the application domain is inherently prohibitive to quick execution.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c29-para-0008">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          An efficient, or high-performance, program runs as fast as possible for its particular task
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c29-para-0009">
      Note that the title of this chapter, “Writing Efficient C++,” means writing programs that run efficiently, not efficiently writing programs. That is, the time you learn to save by reading this chapter will be your users', not your own!
     </p>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-534">
       Two Approaches to Efficiency
      </h3>
      <p class="calibre13" id="c29-para-0010">
       <i class="calibre18">
        Language-level efficiency
       </i>
       involves using the language as efficiently as possible; for example, passing objects by reference instead of by value. However, this will only get you so far. Much more important is
       <i class="calibre18">
        design-level efficiency
       </i>
       , which includes choosing efficient algorithms, avoiding unnecessary steps and computations, and selecting appropriate design optimizations. More often than not, optimizing existing code involves replacing a bad algorithm or data structure with a better, more efficient one.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0007">
      </span>
      <h3 class="calibre27" id="head-3-535">
       Two Kinds of Programs
      </h3>
      <p class="calibre13" id="c29-para-0011">
       As I've noted, efficiency is important for all application domains. Additionally, there is a small subset of programs, such as system-level software, embedded systems, intensive computational applications, and real-time games, that require extremely high levels of efficiency. Most programs don't. Unless you write those types of high-performance applications, you probably don't need to worry about squeezing every ounce of speed out of your C++ code. Think of it as the difference between building normal family cars and building race cars. Every car must be reasonably efficient, but sports cars require extremely high performance. You wouldn't want to waste your time optimizing family cars for speed when they'll never go faster than 70 miles per hour.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-536">
       Is C++ an Inefficient Language?
      </h3>
      <p class="calibre13" id="c29-para-0012">
       C programmers often resist using C++ for high-performance applications. They claim that the language is inherently less efficient than C or a similar procedural language because C++ includes high-level concepts, such as exceptions and virtual member functions. However, there are problems with this argument.
      </p>
      <p class="calibre13" id="c29-para-0013">
       When discussing the efficiency of a language, you cannot ignore the effect of compilers. Recall that the C or C++ code you write is not the code that the computer executes. A compiler first translates
       <span aria-label="1067" class="calibre20" epub:type="pagebreak" id="Page_1067" role="doc-pagebreak">
       </span>
       that code into machine language, applying optimizations in the process. This means that you can't simply run benchmarks of C and C++ programs and compare the results. You're really comparing the compiler optimizations of the languages, not the languages themselves. C++ compilers can optimize away many of the high-level constructs in the language to generate machine code similar to, or even better than, the machine code generated from a comparable C program. These days, much more research and development is poured into C++ compilers than into C compilers, so C++ code might actually get better optimized and might run faster than C code.
      </p>
      <p class="calibre13" id="c29-para-0014">
       Critics, however, still maintain that some features of C++ cannot be optimized away. For example, as
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       , “Discovering Inheritance Techniques,” explains, virtual member functions require the existence of a vtable, also known as virtual table, and an additional level of indirection at run time, possibly making them slower than regular nonvirtual function calls. However, when you really think about it, this argument is unconvincing. Virtual member function calls provide more than just a function call: they also give you a run-time choice of which function to call. A comparable non-virtual function call would need a conditional statement to decide which function to call. If you don't need those extra semantics, you can use a non-virtual function. A general design rule in the C++ language is that “if you don't use a feature, you don't need to pay for it.” If you don't use virtual member functions, you pay no performance penalty for the fact that you
       <i class="calibre18">
        could
       </i>
       use them. Thus, non-virtual function calls in C++ are identical to function calls in C in terms of performance.
      </p>
      <p class="calibre13" id="c29-para-0015">
       Far more important, the high-level constructs of C++ enable you to write cleaner programs that are more efficient at the design level, are more readable, are more easily maintained, and avoid accumulating unnecessary and dead code.
      </p>
      <p class="calibre13" id="c29-para-0016">
       I believe that you will be better served in your development, performance, and code maintenance by choosing C++ instead of a procedural language such as C.
      </p>
      <p class="calibre13" id="c29-para-0017">
       There are also other higher-level object-oriented languages such as C# and Java, both of which run on top of a virtual machine. C++ code is executed directly by a CPU; there is no such thing as a virtual machine to run your code. C++ is closer to the hardware, which means that in most cases it runs faster than languages such as C# and Java.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-294" class="calibre2">
     <span class="calibre" id="c29-sec-0009">
     </span>
     <h2 class="calibre6" id="head-2-294">
      LANGUAGE-LEVEL EFFICIENCY
     </h2>
     <p class="calibre13" id="c29-para-0018">
      Many books, articles, and programmers spend a lot of time trying to convince you to apply language-level optimizations to your code. These tips and tricks are important and can speed up your programs in some cases. However, they are far less important than the overall design and algorithm choices in your program. You can pass-by-reference all you want, but it won't make your program fast if you perform twice as many disk writes as you need to. It's easy to get bogged down in references and pointers and forget about the big picture.
     </p>
     <p class="calibre13" id="c29-para-0019">
      Furthermore, some of these language-level tricks can be performed automatically by good optimizing compilers. A rule of thumb is that you should never spend time optimizing a particular area, unless a profiler, discussed later in this chapter, tells you that that particular area is a bottleneck.
     </p>
     <p class="calibre13" id="c29-para-0020">
      That being said, using certain language-level optimizations, such as pass-by-reference, is just considered good coding style.
     </p>
     <p class="calibre13">
      <span aria-label="1068" class="calibre20" epub:type="pagebreak" id="Page_1068" role="doc-pagebreak">
      </span>
      In this book, I've tried to present a balance of strategies. So, I've included here what I feel are the most useful language-level optimizations. This list is not comprehensive but is a good start to write optimized code. However, make sure to read, and practice, the design-level efficiency advice that I offer later in this chapter as well.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c29-para-0022">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          Apply language-level optimizations thoughtfully. I recommend making a clean, well-structured design and implementation first. Then use a profiler, and only invest time optimizing those parts that are flagged by a profiler as being a performance bottleneck
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0011">
      </span>
      <h3 class="calibre27" id="head-3-537">
       Handle Objects Efficiently
      </h3>
      <p class="calibre13" id="c29-para-0023">
       C++ does a lot of work for you behind the scenes, particularly with regard to objects. You should always be aware of the performance impact of the code you write. If you follow a few simple guidelines, your code will become more efficient. Note that these guidelines are only relevant for objects, and not for primitive types such as
       <code class="calibre21">
        bool
       </code>
       ,
       <code class="calibre21">
        int
       </code>
       ,
       <code class="calibre21">
        float
       </code>
       , and so on.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0012">
       </span>
       <h4 class="calibre29" id="head-4-404">
        Pass-by-Value or Pass-by-Reference
       </h4>
       <p class="calibre13">
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapters 1
        </a>
        , “A Crash Course in C++ and the Standard Library,” and
        <a class="calibre5" href="c09.xhtml">
         9
        </a>
        , “Mastering Classes and Objects,” present a rule to decide between pass-by-value and pass-by-reference. The rule is worth repeating here.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c29-para-0025">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Prefer pass-by-value parameters for parameters that a function inherently would copy, but only if the parameter is of a type that supports move semantics. Otherwise, use reference-to-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            parameters.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c29-para-0026">
        With pass-by-value parameters, you have to keep a few things in mind. When you pass an object of a derived class by value as an argument for a function parameter that has one of the base classes as its type, then the derived object is “sliced” to fit into the base class type. This causes information to be lost; see
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        for details. Pass-by-value could also incur copying costs that are avoided with pass-by-reference.
       </p>
       <p class="calibre13">
        However, in certain cases, pass-by-value is actually the optimal way to pass an argument to a function. Consider a class to represent a person that looks as follows:
       </p>
       <pre class="calibre26" id="c29-code-0001"><code class="calibre21">class Person</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Person() = default;</code>
<code class="calibre21">        explicit Person(string firstName, string lastName, int age)</code>
<code class="calibre21">            : m_firstName { move(firstName) }, m_lastName { move(lastName) }</code>
<code class="calibre21">            , m_age { age } { }</code>
<code class="calibre21">        virtual ~Person() = default;</code>
<code class="calibre21"> </code>
<span aria-label="1069" class="calibre20" epub:type="pagebreak" id="Page_1069" role="doc-pagebreak"></span><code class="calibre21">        const string&amp; getFirstName() const { return m_firstName; }</code>
<code class="calibre21">        const string&amp; getLastName() const { return m_lastName; }</code>
<code class="calibre21">        int getAge() const { return m_age; }</code>
<code class="calibre21"> </code>
<code class="calibre21">     private:</code>
<code class="calibre21">        string m_firstName, m_lastName;</code>
<code class="calibre21">        int m_age { 0 };</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c29-para-0028">
        As the rule recommends, the
        <code class="calibre21">
         Person
        </code>
        constructor accepts
        <code class="calibre21">
         firstName
        </code>
        and
        <code class="calibre21">
         lastName
        </code>
        by value and then moves them to
        <code class="calibre21">
         m_firstName
        </code>
        and
        <code class="calibre21">
         m_lastName
        </code>
        , respectively, because it would make a copy of those anyway. See
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        for an explanation of this idiom.
       </p>
       <p class="calibre13">
        Now, take a look at the following function accepting a
        <code class="calibre21">
         Person
        </code>
        object by value:
       </p>
       <pre class="calibre26" id="c29-code-0002"><code class="calibre21">void processPerson(Person p) { <span class="color">/* Process the person. */</span> }</code></pre>
       <p class="calibre13">
        You can call this function like this:
       </p>
       <pre class="calibre26" id="c29-code-0003"><code class="calibre21">Person me { "Marc", "Gregoire", 42 };</code>
<code class="calibre21">processPerson(me);</code></pre>
       <p class="calibre13">
        This doesn't look like there's more code than if you write the function like this instead:
       </p>
       <pre class="calibre26" id="c29-code-0004"><code class="calibre21"><b class="calibre14">void processPerson(const Person&amp; p)</b> { <span class="color">/* Process the person. */</span> }</code></pre>
       <p class="calibre13" id="c29-para-0032">
        The call to the function remains the same. However, consider what happens when you pass-by-value in the first version of the function. To initialize the
        <code class="calibre21">
         p
        </code>
        parameter of
        <code class="calibre21">
         processPerson()
        </code>
        ,
        <code class="calibre21">
         me
        </code>
        must be copied with a call to its copy constructor. Even though you didn't write a copy constructor for the
        <code class="calibre21">
         Person
        </code>
        class, the compiler generates one that copies each of the data members. That still doesn't look so bad: there are only three data members. However, two of them are
        <code class="calibre21">
         string
        </code>
        s, which are themselves objects with copy constructors. So, each of their copy constructors will be called as well. The version of
        <code class="calibre21">
         processPerson()
        </code>
        that takes
        <code class="calibre21">
         p
        </code>
        by reference incurs no such copying costs. Thus, pass-by-reference in this example avoids a lot of overhead when the code enters the function.
       </p>
       <p class="calibre13">
        And you're still not done. Remember that
        <code class="calibre21">
         p
        </code>
        in the first version of
        <code class="calibre21">
         processPerson()
        </code>
        is a local variable to the
        <code class="calibre21">
         processPerson()
        </code>
        function, and so must be destroyed when the function exits. This destruction requires a call to the
        <code class="calibre21">
         Person
        </code>
        destructor, which will call the destructor of all the data members.
        <code class="calibre21">
         string
        </code>
        s have destructors, so exiting this function (if you passed by value) incurs calls to three destructors. None of those calls are needed if the
        <code class="calibre21">
         Person
        </code>
        object is passed by reference.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c29-para-0034">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            If a function must modify an object, pass the object by reference-to-non-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            . If the function should not modify the object, pass it by value or by reference-to-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            , as in the preceding example
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c29-para-0035">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Avoid using pass-by-pointer, which is a relatively obsolete technique for pass-by-reference. It is a throwback to the C language and thus rarely suitable in C++ (unless passing
           </i>
           <code class="calibre21">
            nullptr
           </code>
           <i class="calibre18">
            has meaning in your design).
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <span aria-label="1070" class="calibre20" epub:type="pagebreak" id="Page_1070" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-405">
        Return-by-Value or Return-by-Reference
       </h4>
       <p class="calibre13" id="c29-para-0036">
        You could return objects by reference from functions to avoid copying the objects unnecessarily. Unfortunately, it is sometimes impossible to return objects by reference, such as when you write overloaded
        <code class="calibre21">
         operator+
        </code>
        and other similar operators. And, you should never return a reference or a pointer to a local object that will be destroyed when the function exits!
       </p>
       <p class="calibre13" id="c29-para-0037">
        However, returning objects by value from functions is usually fine. This is due to mandatory and non-mandatory elision of copy/move operations and move semantics, both of which optimize returning objects by value, and both are discussed
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0017">
       </span>
       <h4 class="calibre29" id="head-4-406">
        Catch Exceptions by Reference
       </h4>
       <p class="calibre13" id="c29-para-0038">
        As noted in
        <a class="calibre5" href="c14.xhtml">
         Chapter 14
        </a>
        , “Handling Errors,” you should catch exceptions by reference to avoid slicing and unnecessary copying. Throwing exceptions is heavy in terms of performance, so any little thing you can do to improve their efficiency will help.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0018">
       </span>
       <h4 class="calibre29" id="head-4-407">
        Use Move Semantics
       </h4>
       <p class="calibre13" id="c29-para-0039">
        You should make sure your classes support move semantics (see
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        ), either through the compiler-generated move constructor and move assignment operator or by implementing them yourself. According to the rule of zero (see
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        ), you should try to design your classes such that the compiler-generated copy and move constructors and copy and move assignment operators are sufficient. If the compiler cannot implicitly define these for a class, try to explicitly default them if that works for your class. If that is also not an option, you should implement them yourself. With move semantics for your objects, lots of operations will be more efficient, especially in combination with Standard Library containers and algorithms.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0019">
       </span>
       <h4 class="calibre29" id="head-4-408">
        Avoid Creating Temporary Objects
       </h4>
       <p class="calibre13">
        The compiler creates temporary, unnamed objects in several circumstances.
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        explains that after writing a global
        <code class="calibre21">
         operator+
        </code>
        for a class, you can add objects of that class to other types, as long as those types can be converted to objects of that class. For example, the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class definition from
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        , which includes support for the arithmetic operators, looks in part like this:
       </p>
       <pre class="calibre26" id="c29-code-0005"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Other constructors omitted for brevity.</span></code>
<code class="calibre21">        SpreadsheetCell(double initialValue);</code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">export SpreadsheetCell operator+(const SpreadsheetCell&amp; lhs,</code>
<code class="calibre21">    const SpreadsheetCell&amp; rhs);</code></pre>
       <p class="calibre13">
        The non-
        <code class="calibre21">
         explicit
        </code>
        constructor that takes a
        <code class="calibre21">
         double
        </code>
        allows you to write code like this:
       </p>
       <pre class="calibre26" id="c29-code-0006"><code class="calibre21">SpreadsheetCell myCell { 4 }, aThirdCell;</code>
<code class="calibre21">aThirdCell = myCell + 5.6;</code>
<code class="calibre21">aThirdCell = myCell + 4;</code></pre>
       <p class="calibre13" id="c29-para-0042">
        <span aria-label="1071" class="calibre20" epub:type="pagebreak" id="Page_1071" role="doc-pagebreak">
        </span>
        The second statement constructs a temporary
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object from the
        <code class="calibre21">
         5.6
        </code>
        argument; it then calls the
        <code class="calibre21">
         operator+
        </code>
        with
        <code class="calibre21">
         myCell
        </code>
        and this temporary object as arguments. The result is stored in
        <code class="calibre21">
         aThirdCell
        </code>
        . The third statement does the same thing, except that
        <code class="calibre21">
         4
        </code>
        must be coerced to a
        <code class="calibre21">
         double
        </code>
        to call the
        <code class="calibre21">
         double
        </code>
        constructor of the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        .
       </p>
       <p class="calibre13" id="c29-para-0043">
        The important point in this example is that the compiler generates code to create an extra, unnamed
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object for both addition operations in this example. That object must be constructed and destructed with calls to its constructor and destructor. If you're still skeptical, try inserting
        <code class="calibre21">
         print()
        </code>
        statements in your constructor and destructor, and watch the printout.
       </p>
       <p class="calibre13">
        In general, the compiler constructs a temporary object whenever your code converts a variable of one type to another type for use in a larger expression. This rule applies mostly to function calls. For example, suppose that you write a function with the following prototype:
       </p>
       <pre class="calibre26" id="c29-code-0007"><code class="calibre21">void doSomething(const SpreadsheetCell&amp; s);</code></pre>
       <p class="calibre13">
        You can call this function like this:
       </p>
       <pre class="calibre26" id="c29-code-0008"><code class="calibre21">doSomething(5.56);</code></pre>
       <p class="calibre13" id="c29-para-0046">
        The compiler constructs a temporary
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object from
        <code class="calibre21">
         5.56
        </code>
        using the
        <code class="calibre21">
         double
        </code>
        constructor. This temporary object is then passed to
        <code class="calibre21">
         doSomething()
        </code>
        . Note that if you remove the
        <code class="calibre21">
         const
        </code>
        from the
        <code class="calibre21">
         s
        </code>
        parameter, you can no longer call
        <code class="calibre21">
         doSomething()
        </code>
        with a constant; you must pass an lvalue.
       </p>
       <p class="calibre13" id="c29-para-0047">
        You should generally attempt to avoid cases in which the compiler is forced to construct temporary objects. Although it is impossible to avoid in some situations, you should at least be aware of the existence of this “feature” so you aren't surprised by performance and profiling results.
       </p>
       <p class="calibre13" id="c29-para-0048">
        Move semantics is used by the compiler to make working with temporary objects more efficient. That's another reason to make sure your classes support move semantics. See
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        for details.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0020">
      </span>
      <h3 class="calibre27" id="head-3-538">
       Pre-allocate Memory
      </h3>
      <p class="calibre13" id="c29-para-0049">
       One of the main advantages of using containers such as those from the C++ Standard Library discussed in
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       , “Standard Library Containers,” is that they handle all memory management for you. The containers grow automatically when you add more elements to them. However, sometimes this causes a performance penalty. For example, an
       <code class="calibre21">
        std::vector
       </code>
       container stores its elements contiguously in memory. If it needs to grow in size, it needs to allocate a new block of memory and then move (or copy) all elements to this new memory. This has serious performance implications, for example, if you use
       <code class="calibre21">
        push_back()
       </code>
       in a loop to add millions of elements to a
       <code class="calibre21">
        vector
       </code>
       .
      </p>
      <p class="calibre13" id="c29-para-0050">
       If you know in advance how many elements you are going to add to a
       <code class="calibre21">
        vector
       </code>
       or if you have a rough estimate, you should pre-allocate enough memory before starting to add your elements. A
       <code class="calibre21">
        vector
       </code>
       has a capacity, that is, the number of elements that can be added without reallocation, and a size, that is, the actual number of elements in the container. You can pre-allocate memory by changing the capacity using the
       <code class="calibre21">
        reserve()
       </code>
       member function or by resizing the
       <code class="calibre21">
        vector
       </code>
       using
       <code class="calibre21">
        resize()
       </code>
       . See
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       for details.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0021">
      </span>
      <h3 class="calibre27" id="head-3-539">
       Use Inline Functions
      </h3>
      <p class="calibre13" id="c29-para-0051">
       Some compilers use the
       <code class="calibre21">
        inline
       </code>
       keyword as a hint to the optimizer to more aggressively optimize a marked function (especially at low optimization levels). If you notice that a particular small function
       <span aria-label="1072" class="calibre20" epub:type="pagebreak" id="Page_1072" role="doc-pagebreak">
       </span>
       is a performance bottleneck, try marking it
       <code class="calibre21">
        inline
       </code>
       . Do not overuse this feature, because it throws away a fundamental design principle stating that the interface and the implementation should be separated such that the implementation can evolve without changes to the interface.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0022">
      </span>
      <h3 class="calibre27" id="head-3-540">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Mark Unreachable Code
      </h3>
      <p class="calibre13">
       The C++ Standard Library includes
       <code class="calibre21">
        std::unreachable
       </code>
       , defined in
       <code class="calibre21">
        &lt;utility&gt;
       </code>
       , to mark source code locations as being
       <i class="calibre18">
        unreachable
       </i>
       . Doing so helps the compiler to better optimize the final executable code. For example,
       <a aria-describedby="c29-note-0001" class="calibre5" epub:type="noteref" href="#c29-note-0001" id="R_c29-note-0001" role="doc-noteref">
        <sup class="calibre22">
         1
        </sup>
       </a>
       the following function accepts an integer parameter, and the programmer of this function knows for a fact that this parameter can only ever have the values 0, 1, 2, or 3, nothing else.
      </p>
      <pre class="calibre26" id="c29-code-0009"><code class="calibre21">void doSomething(int number_that_is_only_0_1_2_or_3)</code>
<code class="calibre21">{</code>
<code class="calibre21">    switch (number_that_is_only_0_1_2_or_3) {</code>
<code class="calibre21">        case 0:</code>
<code class="calibre21">        case 2:</code>
<code class="calibre21">            handle0Or2(); break;</code>
<code class="calibre21">        case 1:</code>
<code class="calibre21">            handle1();    break;</code>
<code class="calibre21">        case 3:</code>
<code class="calibre21">            handle3();    break;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c29-para-0054">
       However, all the compiler sees is an
       <code class="calibre21">
        int
       </code>
       parameter, so it doesn't know that the value can be only 0, 1, 2, or 3. The
       <code class="calibre21">
        switch
       </code>
       statement in the function handles all possible values of the parameter. However, the compiler does not know this and thus must generate executable code to check that the value is 0, 1, 2, or 3, before it executes the jump to the correct
       <code class="calibre21">
        case
       </code>
       block; for any other value, it has to jump to the first statement after the
       <code class="calibre21">
        switch
       </code>
       statement.
      </p>
      <p class="calibre13">
       By adding a
       <code class="calibre21">
        default
       </code>
       case to the
       <code class="calibre21">
        switch
       </code>
       statement and specifying to the compiler that this
       <code class="calibre21">
        default
       </code>
       case will never be reached, the compiler can omit the executable code to check that the parameter value is 0, 1, 2, or 3, and just immediately jump to the correct
       <code class="calibre21">
        case
       </code>
       block. In certain cases, for example in tight loops, this can improve the performance of the final executable code.
      </p>
      <pre class="calibre26" id="c29-code-0010"><code class="calibre21">void doSomething(int number_that_is_only_0_1_2_or_3)</code>
<code class="calibre21">{</code>
<code class="calibre21">    switch (number_that_is_only_0_1_2_or_3) {</code>
<code class="calibre21">        <span class="color">// Same cases for 0, 1, 2, and 3 as before, omitted for brevity…</span></code>
<code class="calibre21">        <b class="calibre14">default:</b></code>
<code class="calibre21">            <b class="calibre14">unreachable();</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c29-para-0056">
       If a call to
       <code class="calibre21">
        unreachable()
       </code>
       is ever reached at run time, the result is undefined behavior. For example, calling
       <code class="calibre21">
        doSomething()
       </code>
       with argument 8 triggers undefined behavior, and a compiler is free to choose what to do in such a case.
      </p>
     </section>
    </section>
    <span aria-label="1073" class="calibre20" epub:type="pagebreak" id="Page_1073" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-295" class="calibre2">
     <span class="calibre" id="c29-sec-0023">
     </span>
     <h2 class="calibre6" id="head-2-295">
      DESIGN-LEVEL EFFICIENCY
     </h2>
     <p class="calibre13" id="c29-para-0057">
      The design choices in your program affect its performance far more than do language details such as pass-by-reference. For example, if you choose an algorithm for a fundamental task in your application that runs in
      <i class="calibre18">
       O
      </i>
      (
      <i class="calibre18">
       n
      </i>
      <sup class="calibre22">
       2
      </sup>
      ) time instead of a simpler one that runs in
      <i class="calibre18">
       O
      </i>
      (
      <i class="calibre18">
       n
      </i>
      ) time, you could potentially perform the square of the number of operations that you really need. To put numbers on that, a task that uses an
      <i class="calibre18">
       O
      </i>
      (
      <i class="calibre18">
       n
      </i>
      <sup class="calibre22">
       2
      </sup>
      ) algorithm and performs 1 million operations would perform only 1,000 with an
      <i class="calibre18">
       O
      </i>
      (
      <i class="calibre18">
       n
      </i>
      ) algorithm. Even if that operation is optimized beyond recognition at the language level, the simple fact that you perform 1 million operations when a better algorithm would use only 1,000 will make your program very inefficient. Always choose your algorithms carefully. Refer to
      <a class="calibre5" href="p02.xhtml">
       Part II
      </a>
      , specifically
      <a class="calibre5" href="c04.xhtml">
       Chapter 4
      </a>
      , “Designing Professional C++ Programs,” of this book for a detailed discussion of algorithm design choices and big-O notation.
     </p>
     <p class="calibre13" id="c29-para-0058">
      In addition to your choice of algorithms, design-level efficiency includes specific tips and tricks. Instead of writing your own data structures and algorithms, you should use existing ones, such as those from the C++ Standard Library, the Boost libraries (
      <code class="calibre21">
       <a class="calibre5" href="http://boost.org">
        boost.org
       </a>
      </code>
      ), or other libraries, as much as possible because they are written by experts. These libraries have been, and are being, used a lot, so you can expect most bugs to have been discovered and fixed. You should also think about incorporating multithreading in your design to take full advantage of all the processing power available on a machine. See
      <a class="calibre5" href="c27.xhtml">
       Chapter 27
      </a>
      , “Multithreaded Programming with C++,” for more details. The remainder of this section presents two more design techniques for optimizing your program: caching and using object pools.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0024">
      </span>
      <h3 class="calibre27" id="head-3-541">
       Cache Where Necessary
      </h3>
      <p class="calibre13" id="c29-para-0059">
       <i class="calibre18">
        Caching
       </i>
       means storing items for future use to avoid retrieving or recalculating them. You might be familiar with the principle from its use in computer hardware. Modern computer processors are built with memory caches that store recently and frequently accessed memory values in a location that is quicker to access than main memory. Most memory locations that are accessed at all are accessed more than once in a short time period, so caching at the hardware level can significantly speed up computations.
      </p>
      <p class="calibre13">
       Caching in software follows the same approach. If a task or computation is particularly slow, you should make sure that you are not performing it more than necessary. Store the results in memory the first time you perform the task so that they are available for future needs. Here is a list of tasks that are usually slow:
      </p>
      <ul class="check" id="c29-list-0002">
       <li class="calibre9" id="c29-li-0005">
        <b class="calibre14">
         Disk access:
        </b>
        You should avoid opening and reading the same file more than once in your program. If memory is available, save the file contents in RAM if you need to access it frequently.
       </li>
       <li class="calibre9" id="c29-li-0006">
        <b class="calibre14">
         Network communication:
        </b>
        Whenever you need to communicate over a network, your program is subject to the vagaries of the network. Treat network accesses like file accesses, and cache as much static information as possible.
       </li>
       <li class="calibre9" id="c29-li-0007">
        <b class="calibre14">
         Mathematical computations:
        </b>
        If you need the result of a complex computation in more than one place, perform the calculation once and share the result. However, if it's not very complex, then it's probably faster to just calculate it instead of retrieving it from a cache. Use a profiler to be sure.
       </li>
       <li class="calibre9" id="c29-li-0008">
        <span aria-label="1074" class="calibre20" epub:type="pagebreak" id="Page_1074" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Object allocation:
        </b>
        If you need to create and use a large number of short-lived objects in your program, consider using an object pool, described later in this chapter.
       </li>
       <li class="calibre9" id="c29-li-0009">
        <b class="calibre14">
         Thread creation:
        </b>
        Creating threads is slow. You can “cache” threads in a thread pool, similar to caching objects in an object pool.
       </li>
      </ul>
      <p class="calibre13" id="c29-para-0061">
       One common problem with caching is that the data you store often comprises only copies of the underlying information. The original data might change during the lifetime of the cache. For example, you might want to cache the values in a configuration file so that you don't need to read it repeatedly. However, the user might be allowed to change the configuration file while your program is running, which would make your cached version of the information obsolete. In cases like this, you need a mechanism for
       <i class="calibre18">
        cache invalidation
       </i>
       : when the underlying data changes, you must either stop using your cached information or repopulate your cache.
      </p>
      <p class="calibre13" id="c29-para-0062">
       One technique for cache invalidation is to request that the entity managing the underlying data notifies your program of every change. It could do this through a
       <i class="calibre18">
        callback
       </i>
       that your program registers with the manager. Alternatively, your program could poll for certain events that would trigger it to repopulate the cache automatically. Regardless of your specific cache invalidation technique, make sure that you think about these issues before relying on a cache in your program.
      </p>
      <p class="calibre13">
       When adding caching to a data structure, make sure your design hides any details of this caching from the
       <code class="calibre21">
        public
       </code>
       interface. Client code should not be aware that the underlying implementation uses any kind of caching. This also allows you to change the caching mechanism without affecting the
       <code class="calibre21">
        public
       </code>
       interface.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c29-para-0064">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Always keep in mind that maintaining caches takes code, memory, and processing time. On top of that, caches can be a source of subtle bugs. You should only add caching to a particular area when a profiler clearly shows that that area is a performance bottleneck. First write clean and correct code, then profile it, and only then optimize parts of it
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0026">
      </span>
      <h3 class="calibre27" id="head-3-542">
       Use Object Pools
      </h3>
      <p class="calibre13" id="c29-para-0065">
       There are different kinds of object pools. This section discusses one kind of object pool where it allocates a large chunk of memory at once, in which the pool creates smaller objects in-place. These objects can be handed out to clients and reused when clients are done with them, without incurring any additional calls to the memory manager to allocate or deallocate memory for individual objects.
      </p>
      <p class="calibre13" id="c29-para-0066">
       Where the following object pool implementation shines, as will be demonstrated with benchmarks, is for objects with big data members. Whether or not an object pool is the right solution for a specific use case can only be decided by profiling your code.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0027">
       </span>
       <h4 class="calibre29" id="head-4-409">
        An Object Pool Implementation
       </h4>
       <p class="calibre13" id="c29-para-0067">
        This section provides an implementation of an object pool class template that you can use in your programs. The implementation keeps a
        <code class="calibre21">
         vector
        </code>
        of chunks of objects of type
        <code class="calibre21">
         T
        </code>
        . Additionally, it also
        <span aria-label="1075" class="calibre20" epub:type="pagebreak" id="Page_1075" role="doc-pagebreak">
        </span>
        keeps track of free objects in a
        <code class="calibre21">
         vector
        </code>
        that contains pointers to all free objects. The pool hands out objects via the
        <code class="calibre21">
         acquireObject()
        </code>
        member function. If
        <code class="calibre21">
         acquireObject()
        </code>
        is called but there are no free objects anymore, then the pool allocates another chunk of objects.
        <code class="calibre21">
         acquireObject()
        </code>
        returns a
        <code class="calibre21">
         shared_ptr
        </code>
        .
       </p>
       <p class="calibre13" id="c29-para-0068">
        This implementation is using the
        <code class="calibre21">
         vector
        </code>
        Standard Library container without any synchronization. As such, this version is not thread-safe. See
        <a class="calibre5" href="c27.xhtml">
         Chapter 27
        </a>
        for a discussion on how you can make the implementation thread-safe.
       </p>
       <p class="calibre13">
        Here is the class definition with comments explaining the details. The class template is parameterized on the type that is to be stored in the pool and on the type of allocator to use for allocating and deallocating chunks of memory.
       </p>
       <pre class="calibre26" id="c29-code-0011"><code class="calibre21"><span class="color">// Provides an object pool that can be used with any class.</span></code>
<code class="calibre21"><span class="color">//</span></code>
<code class="calibre21"><span class="color">// acquireObject() returns an object from the list of free objects. If</span></code>
<code class="calibre21"><span class="color">// there are no more free objects, acquireObject() creates a new chunk</span></code>
<code class="calibre21"><span class="color">// of objects.</span></code>
<code class="calibre21"><span class="color">// The pool only grows: objects are never removed from the pool, until</span></code>
<code class="calibre21"><span class="color">// the pool is destroyed.</span></code>
<code class="calibre21"><span class="color">// acquireObject() returns an std::shared_ptr with a custom deleter that</span></code>
<code class="calibre21"><span class="color">// automatically puts the object back into the object pool when the</span></code>
<code class="calibre21"><span class="color">// shared_ptr is destroyed and its reference count reaches 0.</span></code>
<code class="calibre21">export</code>
<code class="calibre21">template &lt;typename T, typename Allocator = std::allocator&lt;T&gt;&gt;</code>
<code class="calibre21">class ObjectPool final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        ObjectPool() = default;</code>
<code class="calibre21">        explicit ObjectPool(const Allocator&amp; allocator);</code>
<code class="calibre21">        ~ObjectPool();</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Prevent move construction and move assignment.</span></code>
<code class="calibre21">        ObjectPool(ObjectPool&amp;&amp;) = delete;</code>
<code class="calibre21">        ObjectPool&amp; operator=(ObjectPool&amp;&amp;) = delete;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Prevent copy construction and copy assignment.</span></code>
<code class="calibre21">        ObjectPool(const ObjectPool&amp;) = delete;</code>
<code class="calibre21">        ObjectPool&amp; operator=(const ObjectPool&amp;) = delete;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Reserves and returns an object from the pool. Arguments can be</span></code>
<code class="calibre21">        <span class="color">// provided which are perfectly forwarded to a constructor of T.</span></code>
<code class="calibre21">        template &lt;typename… Args&gt;</code>
<code class="calibre21">        std::shared_ptr&lt;T&gt; acquireObject(Args&amp;&amp;… args);</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Creates a new block of uninitialized memory, big enough to hold</span></code>
<code class="calibre21">        <span class="color">// m_newChunkSize instances of T.</span></code>
<code class="calibre21">        void addChunk();</code>
<code class="calibre21">        <span class="color">// Contains chunks of memory in which instances of T will be created.</span></code>
<code class="calibre21">        <span class="color">// For each chunk, the pointer to its first object is stored.</span></code>
<code class="calibre21">        std::vector&lt;T*&gt; m_pool;</code>
<code class="calibre21">        <span class="color">// Contains pointers to all free instances of T that</span></code>
<code class="calibre21">        <span class="color">// are available in the pool.</span></code>
<code class="calibre21">        std::vector&lt;T*&gt; m_freeObjects;</code>
<span aria-label="1076" class="calibre20" epub:type="pagebreak" id="Page_1076" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// The number of T instances that should fit in the first allocated chunk.</span></code>
<code class="calibre21">        static constexpr std::size_t ms_initialChunkSize { 5 };</code>
<code class="calibre21">        <span class="color">// The number of T instances that should fit in a newly allocated chunk.</span></code>
<code class="calibre21">        <span class="color">// This value is doubled after each newly created chunk.</span></code>
<code class="calibre21">        std::size_t m_newChunkSize { ms_initialChunkSize };</code>
<code class="calibre21">        <span class="color">// The allocator to use for allocating and deallocating chunks.</span></code>
<code class="calibre21">        Allocator m_allocator;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c29-para-0070">
        When using this object pool, you have to make sure that the object pool itself outlives all the objects handed out by the pool.
       </p>
       <p class="calibre13">
        The constructor is trivial and just stores the given allocator in a data member:
       </p>
       <pre class="calibre26" id="c29-code-0012"><code class="calibre21">template &lt;typename T, typename Allocator&gt;</code>
<code class="calibre21">ObjectPool&lt;T, Allocator&gt;::ObjectPool(const Allocator&amp; allocator)</code>
<code class="calibre21">    : m_allocator { allocator }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         addChunk()
        </code>
        member function to allocate a new chunk is implemented as follows. The first part of
        <code class="calibre21">
         addChunk()
        </code>
        does the actual allocation of a new chunk. A “chunk” is just a block of
        <i class="calibre18">
         uninitialized
        </i>
        memory, allocated using an allocator and big enough to hold
        <code class="calibre21">
         m_newChunkSize
        </code>
        instances of
        <code class="calibre21">
         T
        </code>
        . By adding a chunk of objects, no objects are actually constructed yet; i.e., no object constructors are called. That is done later in
        <code class="calibre21">
         acquireObject()
        </code>
        when instances are handed out. The second part of
        <code class="calibre21">
         addChunk()
        </code>
        creates pointers to the new instances of
        <code class="calibre21">
         T
        </code>
        . It uses the
        <code class="calibre21">
         iota()
        </code>
        algorithm, defined in
        <code class="calibre21">
         &lt;numeric&gt;
        </code>
        . To refresh your memory,
        <code class="calibre21">
         iota()
        </code>
        fills a range given by its first two arguments with values. The values start with the value of the third argument and are incremented by one for each subsequent value. Since we are working with
        <code class="calibre21">
         T*
        </code>
        pointers, incrementing a
        <code class="calibre21">
         T*
        </code>
        pointer by one jumps ahead to the next
        <code class="calibre21">
         T
        </code>
        in the memory block. Finally, the
        <code class="calibre21">
         m_newChunkSize
        </code>
        value is doubled so that the next block that will be added is double the size of the currently added block. This is done for performance reasons and follows the principle of
        <code class="calibre21">
         std::vector
        </code>
        . Here is the implementation:
       </p>
       <pre class="calibre26" id="c29-code-0013"><code class="calibre21">template &lt;typename T, typename Allocator&gt;</code>
<code class="calibre21">void ObjectPool&lt;T, Allocator&gt;::addChunk()</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::println("Allocating new chunk…");</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Allocate a new chunk of uninitialized memory big enough to hold</span></code>
<code class="calibre21">    <span class="color">// m_newChunkSize instances of T, and add the chunk to the pool.</span></code>
<code class="calibre21">    <span class="color">// Care is taken that everything is cleaned up in the event of an exception.</span></code>
<code class="calibre21">    m_pool.push_back(nullptr);</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        m_pool.back() = m_allocator.allocate(m_newChunkSize);</code>
<code class="calibre21">    } catch (…) {</code>
<code class="calibre21">        m_pool.pop_back();</code>
<code class="calibre21">        throw;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Create pointers to each individual object in the new chunk</span></code>
<code class="calibre21">    <span class="color">// and store them in the list of free objects.</span></code>
<code class="calibre21">    auto oldFreeObjectsSize { m_freeObjects.size() };</code>
<code class="calibre21">    m_freeObjects.resize(oldFreeObjectsSize + m_newChunkSize);</code>
<code class="calibre21">    std::iota(begin(m_freeObjects) + oldFreeObjectsSize, end(m_freeObjects),</code>
<code class="calibre21">        m_pool.back());</code>
<code class="calibre21"><span aria-label="1077" class="calibre20" epub:type="pagebreak" id="Page_1077" role="doc-pagebreak"></span> </code>
<code class="calibre21">    <span class="color">// Double the chunk size for next time.</span></code>
<code class="calibre21">    m_newChunkSize *= 2;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c29-para-0073">
        <code class="calibre21">
         acquireObject()
        </code>
        , a variadic member function template, returns a free object from the pool, allocating a new chunk if there are no more free objects available. As explained earlier, adding a new chunk just allocates a block of uninitialized memory. It is the responsibility of
        <code class="calibre21">
         acquireObject()
        </code>
        to properly construct a new instance of
        <code class="calibre21">
         T
        </code>
        at the right place in memory. This is done using a placement
        <code class="calibre21">
         new
        </code>
        operator. Any arguments passed to
        <code class="calibre21">
         acquireObject()
        </code>
        are perfectly forwarded to a constructor of type
        <code class="calibre21">
         T
        </code>
        .
       </p>
       <p class="calibre13" id="c29-para-0074">
        <code class="calibre21">
         acquireObject()
        </code>
        uses a placement
        <code class="calibre21">
         new
        </code>
        operator to construct a new instance of an object of type
        <code class="calibre21">
         T
        </code>
        at an explicitly specified memory location. If type
        <code class="calibre21">
         T
        </code>
        contains any
        <code class="calibre21">
         const
        </code>
        or reference members, accessing the newly constructed object through the original pointer triggers undefined behavior. To turn this into defined behavior, you need to launder the memory using
        <code class="calibre21">
         std::launder()
        </code>
        , defined in
        <code class="calibre21">
         &lt;new&gt;
        </code>
        .
        <a aria-describedby="c29-note-0002" class="calibre5" epub:type="noteref" href="#c29-note-0002" id="R_c29-note-0002" role="doc-noteref">
         <sup class="calibre22">
          2
         </sup>
        </a>
       </p>
       <p class="calibre13">
        Finally, the laundered
        <code class="calibre21">
         T*
        </code>
        pointer is wrapped in a
        <code class="calibre21">
         shared_ptr
        </code>
        with a custom deleter. This deleter does not deallocate any memory; instead, it manually calls the destructor by using
        <code class="calibre21">
         std::destroy_at()
        </code>
        and then puts the pointer back on the list of available objects.
       </p>
       <pre class="calibre26" id="c29-code-0014"><code class="calibre21">template &lt;typename T, typename Allocator&gt;</code>
<code class="calibre21">template &lt;typename… Args&gt;</code>
<code class="calibre21">std::shared_ptr&lt;T&gt; ObjectPool&lt;T, Allocator&gt;::acquireObject(Args&amp;&amp;… args)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// If there are no free objects, allocate a new chunk.</span></code>
<code class="calibre21">    if (m_freeObjects.empty()) { addChunk(); }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Get a free object.</span></code>
<code class="calibre21">    T* object { m_freeObjects.back() };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Initialize, i.e. construct, an instance of T in an</span></code>
<code class="calibre21">    <span class="color">// uninitialized block of memory using placement new, and</span></code>
<code class="calibre21">    <span class="color">// perfectly forward any provided arguments to the constructor.</span></code>
<code class="calibre21">    ::new(object) T { std::forward&lt;Args&gt;(args)… };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Launder the object pointer.</span></code>
<code class="calibre21">    T* constructedObject { std::launder(object) };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Remove the object from the list of free objects.</span></code>
<code class="calibre21">    m_freeObjects.pop_back();</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Wrap the constructed object and return it.</span></code>
<code class="calibre21">    return std::shared_ptr&lt;T&gt; { constructedObject, [this](T* object) {</code>
<code class="calibre21">        <span class="color">// Destroy object.</span></code>
<code class="calibre21">        std::destroy_at(object);</code>
<code class="calibre21">        <span class="color">// Put the object back in the list of free objects.</span> </code>
<code class="calibre21">        m_freeObjects.push_back(object);</code>
<code class="calibre21">    } };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="1078" class="calibre20" epub:type="pagebreak" id="Page_1078" role="doc-pagebreak">
        </span>
        Finally, the destructor of the pool must deallocate any allocated memory using the given allocator:
       </p>
       <pre class="calibre26" id="c29-code-0015"><code class="calibre21">template &lt;typename T, typename Allocator&gt;</code>
<code class="calibre21">ObjectPool&lt;T, Allocator&gt;::~ObjectPool()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Note: this implementation assumes that all objects handed out by this</span></code>
<code class="calibre21">    <span class="color">//       pool have been returned to the pool before the pool is destroyed.</span></code>
<code class="calibre21">    <span class="color">//       The following statement asserts if that is not the case.</span></code>
<code class="calibre21">    assert(m_freeObjects.size() ==</code>
<code class="calibre21">        ms_initialChunkSize * (std::pow(2, m_pool.size()) - 1));</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Deallocate all allocated memory.</span></code>
<code class="calibre21">    std::size_t chunkSize { ms_initialChunkSize };</code>
<code class="calibre21">    for (auto* chunk : m_pool) {</code>
<code class="calibre21">        m_allocator.deallocate(chunk, chunkSize);</code>
<code class="calibre21">        chunkSize *= 2;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    m_pool.clear();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c29-para-0077">
        <code class="calibre21">
         assert()
        </code>
        is a macro defined in
        <code class="calibre21">
         &lt;cassert&gt;
        </code>
        . It takes a Boolean expression and, if the expression evaluates to
        <code class="calibre21">
         false
        </code>
        , prints an error message and terminates the program.
        <a class="calibre5" href="c31.xhtml">
         Chapter 31
        </a>
        , “Conquering Debugging,” gives more details. The formula used in the
        <code class="calibre21">
         assert()
        </code>
        statement is based on the fact that each allocated chunk is double in size compared to the previous chunk.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0028">
       </span>
       <h4 class="calibre29" id="head-4-410">
        Using the Object Pool
       </h4>
       <p class="calibre13">
        Consider an application that uses a lot of short-lived objects with big data members and hence are expensive to allocate. Let's assume we have an
        <code class="calibre21">
         ExpensiveObject
        </code>
        class definition that looks as follows:
       </p>
       <pre class="calibre26" id="c29-code-0016"><code class="calibre21">class ExpensiveObject</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        ExpensiveObject() { <span class="color">/* … */</span> }</code>
<code class="calibre21">        virtual ~ExpensiveObject() = default;</code>
<code class="calibre21">        <span class="color">// Member functions to populate the object with specific information.</span></code>
<code class="calibre21">        <span class="color">// Member functions to retrieve the object data.</span></code>
<code class="calibre21">        <span class="color">// (not shown)</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// An expensive data member.</span></code>
<code class="calibre21">        array&lt;double, 4 * 1024 * 1024&gt; m_data;</code>
<code class="calibre21">        <span class="color">// Other data members (not shown)</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Instead of allocating and deallocating large numbers of such objects throughout the lifetime of your program, you can use the object pool developed in the previous section. We can benchmark the pool using the chrono library (see
        <a class="calibre5" href="c22.xhtml">
         Chapter 22
        </a>
        , “Date and Time Utilities”) as follows:
       </p>
       <pre class="calibre26" id="c29-code-0017"><code class="calibre21">using MyPool = ObjectPool&lt;ExpensiveObject&gt;;</code>
<code class="calibre21"> </code>
<code class="calibre21">shared_ptr&lt;ExpensiveObject&gt; getExpensiveObject(MyPool&amp; pool)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Obtain an ExpensiveObject object from the pool.</span></code>
<code class="calibre21">    auto object { pool.acquireObject() };</code>
<span aria-label="1079" class="calibre20" epub:type="pagebreak" id="Page_1079" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// Populate the object. (not shown)</span></code>
<code class="calibre21">    return object;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void processExpensiveObject(ExpensiveObject&amp; object) { <span class="color">/* … */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    const size_t NumberOfIterations { 500'000 };</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("Starting loop using pool…");</code>
<code class="calibre21">    MyPool requestPool;</code>
<code class="calibre21">    auto start1 { chrono::steady_clock::now() };</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; NumberOfIterations; ++i) {</code>
<code class="calibre21">        auto object { getExpensiveObject(requestPool) };</code>
<code class="calibre21">        processExpensiveObject(*object.get());</code>
<code class="calibre21">    }</code>
<code class="calibre21">    auto end1 { chrono::steady_clock::now() };</code>
<code class="calibre21">    auto diff1 { end1 - start1 };</code>
<code class="calibre21">    println("{}", chrono::duration&lt;double, milli&gt;(diff1));</code>
<code class="calibre21"> </code>
<code class="calibre21"> </code>
<code class="calibre21">    println("Starting loop using new/delete…");</code>
<code class="calibre21">    auto start2 { chrono::steady_clock::now() };</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; NumberOfIterations; ++i) {</code>
<code class="calibre21">        auto object { std::make_unique&lt;ExpensiveObject&gt;() };</code>
<code class="calibre21">        processExpensiveObject(*object);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    auto end2 { chrono::steady_clock::now() };</code>
<code class="calibre21">    auto diff2 { end2 - start2 };</code>
<code class="calibre21">    println("{}", chrono::duration&lt;double, milli&gt;(diff2));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         main()
        </code>
        function contains a small benchmark of the pool's performance. It asks for 500,000 objects in a loop and times how long it takes. The loop is done twice, once using our pool and once using the standard
        <code class="calibre21">
         new
        </code>
        /
        <code class="calibre21">
         delete
        </code>
        operators. The results on a test machine with a release build of the code are as follows:
       </p>
       <pre class="calibre26" id="c29-code-0018"><code class="calibre21">Starting loop using pool…</code>
<code class="calibre21">Allocating new chunk…</code>
<code class="calibre21">54.526ms</code>
<code class="calibre21">Starting loop using new/delete…</code>
<code class="calibre21">9463.2393ms</code></pre>
       <p class="calibre13" id="c29-para-0081">
        In this example, using the object pool is around 170 times faster. Keep in mind, though, that this object pool is tailored to work with objects with big data members. This is the case for the
        <code class="calibre21">
         ExpensiveObject
        </code>
        class used in the example, which contains a 32MB
        <code class="calibre21">
         array
        </code>
        as one of its data members.
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-296" class="calibre2">
     <span class="calibre" id="c29-sec-0029">
     </span>
     <h2 class="calibre6" id="head-2-296">
      PROFILING
     </h2>
     <p class="calibre13" id="c29-para-0082">
      It is good to think about efficiency as you design and code. There is no point in writing obviously inefficient programs if this can be avoided with some common sense or experience-based intuition.
      <span aria-label="1080" class="calibre20" epub:type="pagebreak" id="Page_1080" role="doc-pagebreak">
      </span>
      However, I urge you not to get too obsessed with performance during the design and coding phases. It's best to first make a clean, well-structured design and implementation, then use a profiler, and only optimize parts that are flagged by the profiler as being performance bottlenecks. Remember the “90/10” rule, introduced in
      <a class="calibre5" href="c04.xhtml">
       Chapter 4
      </a>
      , which states that 90 percent of the running time of most programs is spent in only 10 percent of the code (Hennessy and Patterson,
      <i class="calibre18">
       Computer Architecture, A Quantitative Approach, Fourth Edition
      </i>
      , [Morgan Kaufmann, 2006]). This means you could optimize 90 percent of your code, but still only improve the running time of the program by 10 percent. Obviously, you want to optimize the parts of the code that are exercised the most for the specific workload that you expect the program to run.
     </p>
     <p class="calibre13" id="c29-para-0083">
      Consequently, it is often helpful to
      <i class="calibre18">
       profile
      </i>
      your program to determine which parts of the code require optimization. There are many
      <i class="calibre18">
       profiling tools
      </i>
      available that analyze programs as they run to generate data about their performance. Most profiling tools provide analysis at the function level by specifying the amount of time (or percent of total execution time) spent in each function in the program. After running a profiler on your program, you can usually tell immediately which parts of the program need optimization. Profiling before and after optimizing is essential to prove that your optimizations had an effect.
     </p>
     <p class="calibre13" id="c29-para-0084">
      If you are using Microsoft Visual C++, you already have a great built-in profiler, which is discussed later in this chapter. If you are not yet using Visual C++, Microsoft has a community edition available (
      <code class="calibre21">
       <a class="calibre5" href="http://visualstudio.microsoft.com">
        visualstudio.microsoft.com
       </a>
      </code>
      ) that is free of charge for students, open-source developers, and individual developers to create both free and paid applications. It's also free of charge for up to five users in small organizations. Another great profiling tool is Rational PurifyPlus from IBM (
      <code class="calibre21">
       <a class="calibre5" href="http://www.almtoolbox.com/purify.php">
        www.almtoolbox.com/purify.php
       </a>
      </code>
      ). There are also a number of smaller free profiling tools available: Very Sleepy (
      <code class="calibre21">
       <a class="calibre5" href="http://www.codersnotes.com/sleepy">
        www.codersnotes.com/sleepy
       </a>
      </code>
      ) and Luke Stackwalker (
      <code class="calibre21">
       <a class="calibre5" href="http://lukestackwalker.sourceforge.net">
        lukestackwalker.sourceforge.net
       </a>
      </code>
      ) are popular profilers for Windows, Valgrind (
      <code class="calibre21">
       <a class="calibre5" href="http://valgrind.org">
        valgrind.org
       </a>
      </code>
      ) and gprof (GNU profiler,
      <code class="calibre21">
       <a class="calibre5" href="http://sourceware.org/binutils/docs/gprof">
        sourceware.org/binutils/docs/gprof
       </a>
      </code>
      ) are well-known profilers for Unix/Linux systems, and there are plenty of other choices. This section demonstrates two profilers: gprof for Linux, and the profiler that comes with Visual C++ 2022.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0030">
      </span>
      <h3 class="calibre27" id="head-3-543">
       Profiling Example with gprof
      </h3>
      <p class="calibre13" id="c29-para-0085">
       The power of profiling can best be seen with a real coding example. As a disclaimer, the performance bugs in the first implementation shown are not subtle! Real efficiency issues would probably be more complex, but a program long enough to demonstrate them would be too lengthy for this book.
      </p>
      <p class="calibre13" id="c29-para-0086">
       Suppose that you work for the US Social Security Administration. Every year the administration puts up a website that allows users to look up the popularity of new baby names from the previous year. Your job is to write the backend program that looks up names for users. Your input is a file containing the name of every new baby. This file will obviously contain duplicate names. For example, in the file for boys for 2003, the name Jacob was the most popular, showing up 29,195 times. Your program must read the file to construct an in-memory database. A user may then request the absolute number of babies with a given name or the rank of that name among all the babies.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0031">
       </span>
       <h4 class="calibre29" id="head-4-411">
        First Design Attempt
       </h4>
       <p class="calibre13">
        A logical design for this program consists of a
        <code class="calibre21">
         NameDB
        </code>
        class with the following public member functions:
       </p>
       <pre class="calibre26" id="c29-code-0019"><code class="calibre21">export class NameDB</code>
<code class="calibre21">{</code>
<span aria-label="1081" class="calibre20" epub:type="pagebreak" id="Page_1081" role="doc-pagebreak"></span><code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Reads list of baby names in nameFile to populate the database.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if nameFile cannot be opened or read.</span></code>
<code class="calibre21">        explicit NameDB(const std::string&amp; nameFile);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns the rank of the name (1st, 2nd, etc).</span></code>
<code class="calibre21">        <span class="color">// Returns –1 if the name is not found.</span></code>
<code class="calibre21">        int getNameRank(const std::string&amp; name) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns the number of babies with a given name.</span></code>
<code class="calibre21">        <span class="color">// Returns –1 if the name is not found.</span></code>
<code class="calibre21">        int getAbsoluteNumber(const std::string&amp; name) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Private members not shown yet …</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        The hard part is choosing a good data structure for the in-memory database. A first attempt is a
        <code class="calibre21">
         vector
        </code>
        of name/count
        <code class="calibre21">
         pair
        </code>
        s. Remember,
        <code class="calibre21">
         pair
        </code>
        is a utility class that combines two values of possibly different types. Each entry in the
        <code class="calibre21">
         vector
        </code>
        stores one of the names, along with a count of the number of times that name shows up in the raw data file. Here is the complete class definition with this design:
       </p>
       <pre class="calibre26" id="c29-code-0020"><code class="calibre21">export class NameDB</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit NameDB(const std::string&amp; nameFile);</code>
<code class="calibre21">        int getNameRank(const std::string&amp; name) const;</code>
<code class="calibre21">        int getAbsoluteNumber(const std::string&amp; name) const;</code>
<code class="calibre21">    <b class="calibre14">private:</b></code>
<code class="calibre21">        <b class="calibre14">std::vector&lt;std::pair&lt;std::string, int&gt;&gt; m_names;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Helper member functions</span></code>
<code class="calibre21">        <b class="calibre14">bool nameExists(const std::string&amp; name) const;</b></code>
<code class="calibre21">        <b class="calibre14">void incrementNameCount(const std::string&amp; name);</b></code>
<code class="calibre21">        <b class="calibre14">void addNewName(const std::string&amp; name);</b></code>
<code class="calibre21"><b class="calibre14">};</b></code></pre>
       <p class="calibre13">
        Here are the implementations of the constructor and the helper member functions
        <code class="calibre21">
         nameExists()
        </code>
        ,
        <code class="calibre21">
         incrementNameCount()
        </code>
        , and
        <code class="calibre21">
         addNewName()
        </code>
        . The loops in
        <code class="calibre21">
         nameExists()
        </code>
        and
        <code class="calibre21">
         incrementNameCount()
        </code>
        iterate over all the elements of the
        <code class="calibre21">
         vector
        </code>
        .
       </p>
       <pre class="calibre26" id="c29-code-0021"><code class="calibre21"><span class="color">// Reads the names from the file and populates the database.</span></code>
<code class="calibre21"><span class="color">// The database is a vector of name/count pairs, storing the</span></code>
<code class="calibre21"><span class="color">// number of times each name shows up in the raw data.</span></code>
<code class="calibre21">NameDB::NameDB(const string&amp; nameFile)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Open the file and check for errors.</span></code>
<code class="calibre21">    ifstream inputFile { nameFile };</code>
<code class="calibre21">    if (!inputFile) {</code>
<code class="calibre21">        throw invalid_argument { "Unable to open file" };</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the names one at a time.</span></code>
<code class="calibre21">    string name;</code>
<code class="calibre21">    while (inputFile &gt;&gt; name) {</code>
<code class="calibre21">        <span class="color">// Look up the name in the database so far.</span></code>
<code class="calibre21">        if (nameExists(name)) {</code>
<span aria-label="1082" class="calibre20" epub:type="pagebreak" id="Page_1082" role="doc-pagebreak"></span><code class="calibre21">            <span class="color">// If the name exists in the database, just increment the count.</span></code>
<code class="calibre21">            incrementNameCount(name);</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            <span class="color">// If the name doesn't yet exist, add it with a count of 1.</span></code>
<code class="calibre21">            addNewName(name);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Returns true if the name exists in the database, false otherwise.</span></code>
<code class="calibre21">bool NameDB::nameExists(const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Iterate through the vector of names looking for the name.</span></code>
<code class="calibre21">    for (auto&amp; entry : m_names) {</code>
<code class="calibre21">        if (entry.first == name) {</code>
<code class="calibre21">            return true;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return false;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Precondition: name exists in the vector of names.</span></code>
<code class="calibre21"><span class="color">// Postcondition: the count associated with name is incremented.</span></code>
<code class="calibre21">void NameDB::incrementNameCount(const string&amp; name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto&amp; entry : m_names) {</code>
<code class="calibre21">        if (entry.first == name) {</code>
<code class="calibre21">            entry.second += 1;</code>
<code class="calibre21">            return;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Adds a new name to the database.</span></code>
<code class="calibre21">void NameDB::addNewName(const string&amp; name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_names.emplace:back(name, 1);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c29-para-0090">
        Note that you could use an algorithm like
        <code class="calibre21">
         std::find_if()
        </code>
        , discussed in
        <a class="calibre5" href="c20.xhtml">
         Chapter 20
        </a>
        , “Mastering Standard Library Algorithms,” to accomplish the same thing as the loops in
        <code class="calibre21">
         nameExists()
        </code>
        and
        <code class="calibre21">
         incrementNameCount()
        </code>
        . The loops are shown explicitly to emphasize the performance problems.
       </p>
       <p class="calibre13" id="c29-para-0091">
        You might have noticed some performance problems already. What if there are hundreds of thousands of names? The many linear searches involved in populating the database will become slow.
       </p>
       <p class="calibre13">
        To complete the example, here are the implementations of the two public member functions:
       </p>
       <pre class="calibre26" id="c29-code-0022"><code class="calibre21"><span class="color">// Returns the rank of the name.</span></code>
<code class="calibre21"><span class="color">// First looks up the name to obtain the number of babies with that name.</span></code>
<code class="calibre21"><span class="color">// Then iterates through all the names, counting all the names with a higher</span></code>
<code class="calibre21"><span class="color">// count than the specified name. Returns that count as the rank.</span></code>
<code class="calibre21">int NameDB::getNameRank(const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Make use of the getAbsoluteNumber() member function.</span></code>
<code class="calibre21">    int num { getAbsoluteNumber(name) };</code>
<code class="calibre21"><span aria-label="1083" class="calibre20" epub:type="pagebreak" id="Page_1083" role="doc-pagebreak"></span> </code>
<code class="calibre21">    <span class="color">// Check if we found the name.</span></code>
<code class="calibre21">    if (num == -1) {</code>
<code class="calibre21">        return -1;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Now count all the names in the vector that have a</span></code>
<code class="calibre21">    <span class="color">// count higher than this one. If no name has a higher count,</span></code>
<code class="calibre21">    <span class="color">// this name is rank number 1. Every name with a higher count</span></code>
<code class="calibre21">    <span class="color">// decreases the rank of this name by 1.</span></code>
<code class="calibre21">    int rank { 1 };</code>
<code class="calibre21">    for (auto&amp; entry : m_names) {</code>
<code class="calibre21">        if (entry.second &gt; num) {</code>
<code class="calibre21">            ++rank;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return rank;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Returns the count associated with the given name.</span></code>
<code class="calibre21">int NameDB::getAbsoluteNumber(const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto&amp; entry : m_names) {</code>
<code class="calibre21">        if (entry.first == name) {</code>
<code class="calibre21">            return entry.second;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return -1;</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0032">
       </span>
       <h4 class="calibre29" id="head-4-412">
        Profiling the First Design Attempt
       </h4>
       <p class="calibre13">
        To test the program, you need a
        <code class="calibre21">
         main()
        </code>
        function:
       </p>
       <pre class="calibre26" id="c29-code-0023"><code class="calibre21">import name_db;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    NameDB boys { "boys_long.txt" };</code>
<code class="calibre21">    println("{}", boys.getNameRank("Daniel"));</code>
<code class="calibre21">    println("{}", boys.getNameRank("Jacob"));</code>
<code class="calibre21">    println("{}", boys.getNameRank("William"));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c29-para-0094">
        This
        <code class="calibre21">
         main()
        </code>
        function creates one
        <code class="calibre21">
         NameDB
        </code>
        database called
        <code class="calibre21">
         boys
        </code>
        , telling it to populate itself with the file
        <code class="calibre21">
         boys_long.txt
        </code>
        , which contains 500,500 names.
       </p>
       <p class="calibre13">
        There are three steps to using gprof:
       </p>
       <ol class="calibre7" id="c29-list-0003">
        <li class="calibre9" id="c29-li-0010">
         After having compiled the
         <code class="calibre21">
          name_db
         </code>
         module, you should compile the main program with a special flag that causes it to log raw execution information when it is run. When using GCC as your compiler, the flag is
         <code class="calibre21">
          -pg
         </code>
         , as in this example:
         <pre class="calibre26" id="c29-code-0024"><code class="calibre21">&gt; gcc -lstdc++ -std=c++2b <b class="calibre14">-pg</b> -fmodules-ts -o namedb NameDB.cpp NameDBTest.cpp</code></pre>
         <p class="listpara">
          <span aria-label="1084" class="calibre20" epub:type="pagebreak" id="Page_1084" role="doc-pagebreak">
          </span>
         </p>
         <section class="calibre2">
          <aside class="calibre23">
           <div class="top">
            <hr class="calibre24"/>
           </div>
           <section class="feature">
            <p class="calibre25" id="c29-para-0096">
             <b class="calibre14">
              NOTE
             </b>
             <i class="calibre18">
              At the time of this writing, GCC does not yet have full support for C++ modules
             </i>
             .
             <i class="calibre18">
              Once GCC fully supports modules, check its documentation to learn how to compile and work with modules
             </i>
             .
            </p>
            <p class="calibre25" id="c29-para-0097">
             <i class="calibre18">
              Additionally, at this moment, you have to specify
             </i>
             <code class="calibre21">
              -std=c++2b
             </code>
             <i class="calibre18">
              to enable C++23 features. This will change in the future to
             </i>
             <code class="calibre21">
              -std=c++23
             </code>
             <i class="calibre18">
              . Check the documentation.
             </i>
            </p>
            <div class="top">
             <hr class="calibre24"/>
            </div>
           </section>
          </aside>
         </section>
        </li>
        <li class="calibre9" id="c29-li-0011">
         Run your program. This should generate a file called
         <code class="calibre21">
          gmon.out
         </code>
         in the working directory. Be patient when you run the program because this first version is slow.
        </li>
        <li class="calibre9" id="c29-li-0012">
         Run the
         <code class="calibre21">
          gprof
         </code>
         command. This final step enables you to analyze the
         <code class="calibre21">
          gmon.out
         </code>
         profiling information and produce a (somewhat) readable report. gprof outputs to standard out, so you should redirect the output to a file:
         <pre class="calibre26" id="c29-code-0025"><code class="calibre21">&gt; gprof namedb gmon.out&gt; gprof_analysis.out</code></pre>
        </li>
       </ol>
       <p class="calibre13">
        Now you can analyze the data. Unfortunately, the output file is somewhat cryptic and intimidating, so it takes a little while to learn how to interpret it. gprof provides two separate sets of information. The first set summarizes the amount of time spent executing each function in the program. The second and more useful set summarizes the amount of time spent executing each function
        <i class="calibre18">
         and its descendants
        </i>
        ; this set is also called a
        <i class="calibre18">
         call graph
        </i>
        . Here is some of the output from the
        <code class="calibre21">
         gprof_analysis.out
        </code>
        file, edited to make it more readable. Note that the numbers will be different on your machine.
       </p>
       <pre class="calibre26" id="c29-code-0026"><code class="calibre21">index  %time    self  children    called     name</code>
<code class="calibre21">[1]    100.0    0.00   14.06                 main [1]</code>
<code class="calibre21">                0.00   14.00       1/1           NameDB::NameDB [2]</code>
<code class="calibre21">                0.00    0.04       3/3           NameDB::getNameRank [25]</code>
<code class="calibre21">                0.00    0.01       1/1           NameDB::~NameDB [28]</code></pre>
       <p class="calibre13">
        The following list explains the different columns:
       </p>
       <ul class="check" id="c29-list-0005">
        <li class="calibre9" id="c29-li-0013">
         <b class="calibre14">
          <code class="calibre21">
           index
          </code>
          :
         </b>
         An index to be able to refer to this entry in the call graph.
        </li>
        <li class="calibre9" id="c29-li-0014">
         <b class="calibre14">
          <code class="calibre21">
           %time
          </code>
          :
         </b>
         The percentage of the total execution time of the program required by this function and its descendants.
        </li>
        <li class="calibre9" id="c29-li-0015">
         <b class="calibre14">
          <code class="calibre21">
           self
          </code>
          :
         </b>
         How many seconds the function itself was executing.
        </li>
        <li class="calibre9" id="c29-li-0016">
         <b class="calibre14">
          <code class="calibre21">
           children
          </code>
          :
         </b>
         How many seconds the descendants of this function were executing.
        </li>
        <li class="calibre9" id="c29-li-0017">
         <b class="calibre14">
          <code class="calibre21">
           called
          </code>
          :
         </b>
         How often this function was called.
        </li>
        <li class="calibre9" id="c29-li-0018">
         <b class="calibre14">
          <code class="calibre21">
           name
          </code>
          :
         </b>
         The name of the function. If the name of the function is followed by a number between square brackets, that number refers to another index in the call graph.
        </li>
       </ul>
       <p class="calibre13">
        The preceding extract tells you that
        <code class="calibre21">
         main()
        </code>
        and its descendants took 100 percent of the total execution time of the program, for a total of 14.06 seconds. The second line shows that the
        <code class="calibre21">
         NameDB
        </code>
        constructor took 14.00 seconds of the total 14.06 seconds. So, it's immediately clear where the performance issue is situated. To track down which part of the constructor is taking that long, you need
        <span aria-label="1085" class="calibre20" epub:type="pagebreak" id="Page_1085" role="doc-pagebreak">
        </span>
        to jump to the call graph entry with index 2, because that's the index in square brackets behind the name in the last column. The call graph entry with index 2 is as follows on my test system:
       </p>
       <pre class="calibre26" id="c29-code-0027"><code class="calibre21">[2] 99.6    0.00   14.00       1         NameDB::NameDB [2]</code>
<code class="calibre21">            1.20    6.14  500500/500500      NameDB::nameExists [3]</code>
<code class="calibre21">            1.24    5.24  499500/499500      NameDB::incrementNameCount [4]</code>
<code class="calibre21">            0.00    0.18    1000/1000        NameDB::addNewName [19]</code>
<code class="calibre21">            0.00    0.00       1/1           vector::vector [69]</code></pre>
       <p class="calibre13" id="c29-para-0102">
        The nested entries below
        <code class="calibre21">
         NameDB::NameDB
        </code>
        show which of its descendants took the most time. Here you can see that
        <code class="calibre21">
         nameExists()
        </code>
        took 6.14 seconds, and
        <code class="calibre21">
         incrementNameCount()
        </code>
        took 5.24 seconds. These times are the sums of all the calls to the functions. The fourth column in those lines shows the number of calls to the function (500,500 to
        <code class="calibre21">
         nameExists()
        </code>
        and 499,500 to
        <code class="calibre21">
         incrementNameCount()
        </code>
        ). No other function took a significant amount of time.
       </p>
       <p class="calibre13">
        Without going any further in this analysis, two things should jump out at you:
       </p>
       <ul class="check" id="c29-list-0006">
        <li class="calibre9" id="c29-li-0019">
         Taking 14 seconds to populate the database of approximately 500,000 names is slow. Perhaps you need a better data structure.
        </li>
        <li class="calibre9" id="c29-li-0020">
         <code class="calibre21">
          nameExists()
         </code>
         and
         <code class="calibre21">
          incrementNameCount()
         </code>
         take an almost identical amount of time and are called almost the same number of times. If you think about the application domain, that makes sense: most names in the input text file are duplicates, so the vast majority of the calls to
         <code class="calibre21">
          nameExists()
         </code>
         are followed by a call to
         <code class="calibre21">
          incrementNameCount()
         </code>
         . If you look back at the code, you can see that these functions are almost identical; they could probably be combined. In addition, most of what they are doing is searching the
         <code class="calibre21">
          vector
         </code>
         . It would probably be better to use a sorted data structure to reduce the searching time.
        </li>
       </ul>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0034">
       </span>
       <h4 class="calibre29" id="head-4-413">
        Second Design Attempt
       </h4>
       <p class="calibre13" id="c29-para-0104">
        With these two observations from the gprof output, it's time to redesign the program. The new design uses a
        <code class="calibre21">
         map
        </code>
        instead of a
        <code class="calibre21">
         vector
        </code>
        .
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        explains that the Standard Library
        <code class="calibre21">
         map
        </code>
        keeps the entries sorted and provides
        <i class="calibre18">
         O
        </i>
        (log
        <i class="calibre18">
         n
        </i>
        ) lookup instead of the
        <i class="calibre18">
         O
        </i>
        (
        <i class="calibre18">
         n
        </i>
        ) searches in a
        <code class="calibre21">
         vector
        </code>
        . A good exercise for you to try would be to use an
        <code class="calibre21">
         std::unordered_map
        </code>
        , which has an expected
        <i class="calibre18">
         O
        </i>
        (1) for lookups, and to use a profiler to see if that is faster than
        <code class="calibre21">
         std::map
        </code>
        for this application.
       </p>
       <p class="calibre13" id="c29-para-0105">
        The new version of the program also combines
        <code class="calibre21">
         nameExists()
        </code>
        and i
        <code class="calibre21">
         ncrementNameCount()
        </code>
        into one
        <code class="calibre21">
         incrementIfExists()
        </code>
        .
       </p>
       <p class="calibre13">
        Here is the new class definition:
       </p>
       <pre class="calibre26" id="c29-code-0028"><code class="calibre21">export class NameDB</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit NameDB(const std::string&amp; nameFile);</code>
<code class="calibre21">        int getNameRank(const std::string&amp; name) const;</code>
<code class="calibre21">        int getAbsoluteNumber(const std::string&amp; name) const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">std::map&lt;std::string, int&gt; m_names;</b></code>
<code class="calibre21">        <b class="calibre14">bool incrementIfExists(const std::string&amp; name);</b></code>
<code class="calibre21">        void addNewName(const std::string&amp; name);</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="1086" class="calibre20" epub:type="pagebreak" id="Page_1086" role="doc-pagebreak">
        </span>
        Here are the new member function implementations:
       </p>
       <pre class="calibre26" id="c29-code-0029"><code class="calibre21"><span class="color">// Reads the names from the file and populates the database.</span></code>
<code class="calibre21"><span class="color">// The database is a map associating names with their frequency.</span></code>
<code class="calibre21">NameDB::NameDB(const string&amp; nameFile)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Open the file and check for errors.</span></code>
<code class="calibre21">    ifstream inputFile { nameFile };</code>
<code class="calibre21">    if (!inputFile) {</code>
<code class="calibre21">        throw invalid_argument { "Unable to open file" };</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the names one at a time.</span></code>
<code class="calibre21">    string name;</code>
<code class="calibre21">    while (inputFile &gt;&gt; name) {</code>
<code class="calibre21">        <span class="color">// Look up the name in the database so far.</span></code>
<code class="calibre21">        <b class="calibre14">if (!incrementIfExists(name)) {</b></code>
<code class="calibre21">            <span class="color">// If the name exists in the database, the</span></code>
<code class="calibre21">            <span class="color">// member function incremented it, so we just continue.</span></code>
<code class="calibre21">            <span class="color">// We get here if it didn't exist, in which case</span></code>
<code class="calibre21">            <span class="color">// we add it with a count of 1.</span></code>
<code class="calibre21">            <b class="calibre14">addNewName(name);</b></code>
<code class="calibre21">        <b class="calibre14">}</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Returns true if the name exists in the database, false</span></code>
<code class="calibre21"><span class="color">// otherwise. If it finds it, it increments it.</span></code>
<code class="calibre21"><b class="calibre14">bool NameDB::incrementIfExists(const string&amp; name)</b></code>
<code class="calibre21"><b class="calibre14">{</b></code>
<code class="calibre21">    <span class="color">// Find the name in the map.</span></code>
<code class="calibre21">    <b class="calibre14">auto res { m_names.find(name) };</b></code>
<code class="calibre21">    <b class="calibre14">if (res != end(m_names)) {</b></code>
<code class="calibre21">        <b class="calibre14">res-&gt;second += 1;</b></code>
<code class="calibre21">        <b class="calibre14">return true;</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">    <b class="calibre14">return false;</b></code>
<code class="calibre21"><b class="calibre14">}</b></code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Adds a new name to the database.</span></code>
<code class="calibre21">void NameDB::addNewName(const string&amp; name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">m_names[name] = 1;</b></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int NameDB::getNameRank(const string&amp; name) const { <span class="color">/* Omitted, same as before */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Returns the count associated with the given name.</span></code>
<code class="calibre21">int NameDB::getAbsoluteNumber(const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">auto res { m_names.find(name) };</b></code>
<code class="calibre21">    <b class="calibre14">if (res != end(m_names)) {</b></code>
<code class="calibre21">        <b class="calibre14">return res-&gt;second;</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">    return -1;</code>
<code class="calibre21">}</code></pre>
      </section>
      <span aria-label="1087" class="calibre20" epub:type="pagebreak" id="Page_1087" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c29-sec-0035">
       </span>
       <h4 class="calibre29" id="head-4-414">
        Profiling the Second Design Attempt
       </h4>
       <p class="calibre13">
        By following the same steps shown earlier, you can obtain the gprof performance data on the new version of the program. The data is quite encouraging:
       </p>
       <pre class="calibre26" id="c29-code-0030"><code class="calibre21">index %time  self  children    called        name</code>
<code class="calibre21">[1]   100.0  0.00    0.21                    main [1]</code>
<code class="calibre21">             0.02    0.18      1/1           NameDB::NameDB [2]</code>
<code class="calibre21">             0.00    0.01      1/1           NameDB::~NameDB [13]</code>
<code class="calibre21">             0.00    0.00      3/3           NameDB::getNameRank [28]</code>
<code class="calibre21">[2]    95.2  0.02    0.18      1             NameDB::NameDB [2]</code>
<code class="calibre21">             0.02    0.16 500500/500500      NameDB::incrementIfExists</code>
<code class="calibre21">[3]          0.00    0.00   1000/1000        NameDB::addNewName [24]</code>
<code class="calibre21">             0.00    0.00      1/1           map::map [87]</code></pre>
       <p class="calibre13" id="c29-para-0109">
        If you run this on your machine, the output will be different. It's even possible that you will not see any data for
        <code class="calibre21">
         NameDB
        </code>
        member functions in your output. Because of the efficiency of this second attempt, the timings are getting so small that you might see more
        <code class="calibre21">
         map
        </code>
        member functions in the output than
        <code class="calibre21">
         NameDB
        </code>
        member functions.
       </p>
       <p class="calibre13">
        On my test system,
        <code class="calibre21">
         main()
        </code>
        now takes only 0.21 seconds—a 67-fold improvement! There are certainly further improvements that you could make to this program. For example, the current constructor performs a lookup to see if the name is already in the
        <code class="calibre21">
         map
        </code>
        , and if not, adds it to the
        <code class="calibre21">
         map
        </code>
        . You could combine these two operations simply with the following single line:
       </p>
       <pre class="calibre26" id="c29-code-0031"><code class="calibre21">m_names[name] += 1;</code></pre>
       <p class="calibre13" id="c29-para-0111">
        If the name is already in the
        <code class="calibre21">
         map
        </code>
        , this statement just increments its counter. If the name is not yet in the
        <code class="calibre21">
         map
        </code>
        , this statement first adds an entry to the
        <code class="calibre21">
         map
        </code>
        with the given name as key and a zero-initialized value, and then increments the value, resulting in a counter of 1.
       </p>
       <p class="calibre13">
        With this improvement, you can remove the
        <code class="calibre21">
         incrementIfExists()
        </code>
        and
        <code class="calibre21">
         addNewName()
        </code>
        member functions and change the constructor as follows:
       </p>
       <pre class="calibre26" id="c29-code-0032"><code class="calibre21">NameDB::NameDB(const string&amp; nameFile)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Open the file and check for errors.</span></code>
<code class="calibre21">    ifstream inputFile { nameFile };</code>
<code class="calibre21">    if (!inputFile) {</code>
<code class="calibre21">        throw invalid_argument { "Unable to open file" };</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the names one at a time.</span></code>
<code class="calibre21">    string name;</code>
<code class="calibre21">    while (inputFile &gt;&gt; name) {</code>
<code class="calibre21">        <b class="calibre14">m_names[name] += 1;</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c29-para-0113">
        <code class="calibre21">
         getNameRank()
        </code>
        still uses a loop that iterates over all elements in the
        <code class="calibre21">
         map
        </code>
        . A good exercise for you to try is to come up with another data structure so that the linear iteration in
        <code class="calibre21">
         getNameRank()
        </code>
        can be avoided.
       </p>
      </section>
     </section>
     <span aria-label="1088" class="calibre20" epub:type="pagebreak" id="Page_1088" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c29-sec-0036">
      </span>
      <h3 class="calibre27" id="head-3-544">
       Profiling Example with Visual C++ 2022
      </h3>
      <p class="calibre13" id="c29-para-0114">
       Most editions of Microsoft Visual C++ 2022 come with a great built-in profiler, which is briefly discussed in this section. The VC++ profiler has a complete graphical user interface. This book does not recommend one profiler over another, but it is always good to have an idea of what a command line–based profiler like gprof can provide in comparison with a GUI-based profiler like the one included with VC++.
      </p>
      <p class="calibre13" id="c29-para-0115">
       To start profiling an application in Visual C++ 2022, you first need to open the project in Visual Studio. This example uses the same
       <code class="calibre21">
        NameDB
       </code>
       code as in the first inefficient design attempt from the previous sections. That code is not repeated here. Once your project is opened in Visual Studio, make sure the configuration is set to Release instead of Debug, then click the Debug menu, and choose Performance Profiler. A new window appears, similar to the one shown in
       <a class="calibre5" href="#c29-fig-0001" id="R_c29-fig-0001">
        Figure 29.1
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A snapshot illustrates the user interface of a software analysis tool. At the top, the analysis target section with a startup project named Name D B. Available tools include C P U usage, G P U Usage, instrumentation, and memory usage." class="center" src="images/c29f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c29-fig-0001" id="c29-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 29.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13">
       Depending on your version of VC++, there will be a number of different analysis tools available from this window. The following non-exhaustive list explains two of them:
      </p>
      <ul class="check" id="c29-list-0007">
       <li class="calibre9" id="c29-li-0021">
        <b class="calibre14">
         CPU Usage:
        </b>
        Used to monitor applications with low overhead. This means that the act of profiling the application will not have a big performance impact on the target application.
       </li>
       <li class="calibre9" id="c29-li-0022">
        <b class="calibre14">
         Instrumentation:
        </b>
        Adds extra code to the application to be able to accurately count the number of function calls and to time individual function calls. However, this tool has a much bigger performance impact on the application. It is recommended to use the CPU Usage tool first to get an idea about the bottlenecks in your application. If that tool does not give you enough information, you can try the Instrumentation tool.
       </li>
      </ul>
      <p class="calibre13" id="c29-para-0117">
       <span aria-label="1089" class="calibre20" epub:type="pagebreak" id="Page_1089" role="doc-pagebreak">
       </span>
       For this profiling example, enable only the CPU Usage tool and click the Start button. This executes your program and analyzes its CPU usage. When the program execution is finished, Visual Studio automatically opens the profiling report.
       <a class="calibre5" href="#c29-fig-0002" id="R_c29-fig-0002">
        Figure 29.2
       </a>
       shows how this report might look like when profiling the first attempt of the
       <code class="calibre21">
        NameDB
       </code>
       application.
      </p>
      <p class="calibre13" id="c29-para-0118">
       From this report, you can immediately see the hot path. Just like with gprof, it shows that the
       <code class="calibre21">
        NameDB
       </code>
       constructor takes up most of the running time of the program. The Visual Studio profiling report is interactive. For example, you can drill down the
       <code class="calibre21">
        NameDB::NameDB
       </code>
       constructor by clicking on it in the hot path tree in
       <a class="calibre5" href="#c29-fig-0002">
        Figure 29.2
       </a>
       . This results in a drill-down report for that function, as show in
       <a class="calibre5" href="#c29-fig-0003" id="R_c29-fig-0003">
        Figure 29.3
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A snapshot illustrates a software diagnostic tool with tabs like Report 202308 digression, Name D B dot cpp, Name D B Test dot cpp. A graph has C P U percent of all processors over time." class="center" src="images/c29f002.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c29-fig-0002" id="c29-fig-0002" role="doc-backlink">
           <b class="calibre14">
            FIGURE 29.2
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c29-para-0119">
       This drill-down view shows the hot path at the top and the actual code of the member function at the bottom. The code view shows the percentage of the running time that a line of code needed. The lines using up most of the time are shown in shades of red. This view instantly makes it clear that
       <code class="calibre21">
        incrementNameCount()
       </code>
       and
       <code class="calibre21">
        nameExists()
       </code>
       both roughly take the same time.
      </p>
      <p class="calibre13" id="c29-para-0120">
       At the top of this report, there is a drop-down called Current View, which you can use to get different views of the profiling data.
      </p>
      <figure class="calibre36">
       <img alt="A snapshot illustrates a C P U usage report and a section of C++ code. The report has C P U usage, R 8 diagsession, shows various function names along with total C P U unit, self C P U unit, module, and category." class="center" src="images/c29f003.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c29-fig-0003" id="c29-fig-0003" role="doc-backlink">
           <b class="calibre14">
            FIGURE 29.3
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
     </section>
    </section>
    <span aria-label="1090" class="calibre20" epub:type="pagebreak" id="Page_1090" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-297" class="calibre2">
     <span class="calibre" id="c29-sec-0037">
     </span>
     <h2 class="calibre6" id="head-2-297">
      SUMMARY
     </h2>
     <p class="calibre13" id="c29-para-0121">
      This chapter discussed the key aspects of efficiency and performance in C++ programs and provided several specific tips and techniques for designing and writing more efficient applications. Ideally, you gained an appreciation for the importance of performance and for the power of profiling tools.
     </p>
     <p class="calibre13" id="c29-para-0122">
      There are two important things to remember from this chapter. The first thing is that you should not get too obsessed with performance while designing and coding. It's recommended to first make a correct, well-structured design and implementation, then use a profiler, and only optimize those parts that are flagged by a profiler as being a performance bottleneck.
     </p>
     <p class="calibre13" id="c29-para-0123">
      The second and most important thing to remember from this chapter is that design-level efficiency is far more important than language-level efficiency. For example, you shouldn't use algorithms or data structures with bad complexity if there are better ones available.
     </p>
    </section>
    <section aria-labelledby="head-2-298" class="calibre2">
     <span class="calibre" id="c29-sec-0038">
     </span>
     <h2 class="calibre6" id="head-2-298">
      EXERCISES
     </h2>
     <p class="calibre13" id="c29-para-0124">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <span aria-label="1091" class="calibre20" epub:type="pagebreak" id="Page_1091" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c29-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c29-ex-0001">
        <b class="calibre14">
         Exercise 29-1:
        </b>
        What are the two most important things to remember from this chapter?
       </li>
       <li class="calibre9" id="c29-ex-0002">
        <b class="calibre14">
         Exercise 29-2:
        </b>
        Modify the final
        <code class="calibre21">
         NameDB
        </code>
        solution from the “Profiling” section to use an
        <code class="calibre21">
         std::unordered_map
        </code>
        instead of a
        <code class="calibre21">
         map
        </code>
        . Profile your code before and after your changes and compare the results.
       </li>
       <li class="calibre9" id="c29-ex-0003">
        <b class="calibre14">
         Exercise 29-3:
        </b>
        From the profiling results of Exercise 29-2, it now looks like
        <code class="calibre21">
         operator&gt;&gt;
        </code>
        in the
        <code class="calibre21">
         NameDB
        </code>
        constructor is the bottleneck. Can you change the implementation to avoid using
        <code class="calibre21">
         operator&gt;&gt;
        </code>
        ? Since each line in the input file contains one name, maybe it's faster to simply use
        <code class="calibre21">
         std::getline()
        </code>
        ? Try to modify your implementation as such and compare the profiling results before and after your changes.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c29_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c29_2">
     NOTES
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c29-note-0001" id="c29-note-0001" role="doc-backlink">
       1
      </a>
      This example comes from the official proposal paper of
      <code class="calibre21">
       std::unreachable()
      </code>
      , P0627R6.
     </li>
     <li class="noteentry">
      <a class="calibre5" href="#R_c29-note-0002" id="c29-note-0002" role="doc-backlink">
       2
      </a>
      C++23 introduces a slightly related function called
      <code class="calibre21">
       std::start_lifetime_as()
      </code>
      . The difference with
      <code class="calibre21">
       launder()
      </code>
      is that
      <code class="calibre21">
       launder()
      </code>
      doesn't create a new object, it just launders a pointer to an already constructed object. On the other hand,
      <code class="calibre21">
       start_lifetime_as()
      </code>
      actually creates a new object but without running any constructor code. This can be useful if you have a block of memory that you know represents an object, maybe received over the network, and that you want to turn into an object, e.g.,
      <code class="calibre21">
       start_lifetime_as&lt;MyObjectType&gt;(networkBuffer)
      </code>
      .
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
