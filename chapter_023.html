<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   11Modules, Header Files, and Miscellaneous Topics
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_022.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_024.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c11_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c11_1">
      <span aria-label="421" class="calibre17" epub:type="pagebreak" id="Page_421" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c11">
      </span>
      <span class="calibre">
       11
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Modules, Header Files, and Miscellaneous Topics
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c11-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c11-list-0001">
         <li class="calibre9" id="c11-li-0001">
          What modules are and how to author and consume them
         </li>
         <li class="calibre9" id="c11-li-0002">
          Details of preprocessor directives
         </li>
         <li class="calibre9" id="c11-li-0003">
          What preprocessor macros are and why they are dangerous
         </li>
         <li class="calibre9" id="c11-li-0004">
          What linkage is and how it affects accessibility of named entities
         </li>
         <li class="calibre9" id="c11-li-0005">
          The meaning of the one definition rule, ODR
         </li>
         <li class="calibre9" id="c11-li-0006">
          Details of header files
         </li>
         <li class="calibre9" id="c11-li-0007">
          What feature-test macros for core language features are
         </li>
         <li class="calibre9" id="c11-li-0008">
          The different uses of the
          <code class="calibre21">
           static
          </code>
          keyword
         </li>
         <li class="calibre9" id="c11-li-0009">
          C-style variable-length argument lists
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c11-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-131">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p class="calibre25" id="c11-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c11-para-0005">
      This chapter starts with a detailed discussion on how modules allow you to write reusable components and contrasts this against old-style header files. It also explains what preprocessor directives are and gives some examples of why C-style preprocessor macros are dangerous. The chapter then explains the concept of linkage, which specifies where named entities can be accessed from, and explains the one definition rule. The final part of the chapter discusses the different uses of the
      <code class="calibre21">
       static
      </code>
      and
      <code class="calibre21">
       extern
      </code>
      keywords, as well as C-style variable-length argument lists.
     </p>
    </section>
    <span aria-label="422" class="calibre20" epub:type="pagebreak" id="Page_422" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-132" class="calibre2">
     <span class="calibre" id="c11-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-132">
      MODULES
     </h2>
     <p class="calibre13" id="c11-para-0006">
      <i class="calibre18">
       Modules
      </i>
      are introduced in
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library,” and you have already authored and consumed your own simple modules in previous chapters. However, there are quite a few more things to say about modules. Before the introduction of modules in C++20, header files, discussed later in this chapter, were used to provide the interface to a reusable piece of code. Header files do have a number of problems, though, such as avoiding multiple includes of the same header file and making sure header files are included in the correct order. Additionally, simply
      <code class="calibre21">
       #include
      </code>
      'ing, for example,
      <code class="calibre21">
       &lt;iostream&gt;
      </code>
      adds tens of thousands of lines of code that the compiler has to crunch through. If several source files
      <code class="calibre21">
       #include &lt;iostream&gt;
      </code>
      , all of those translation units grow much bigger. And that is with an include of just a single header file. Imagine if you need
      <code class="calibre21">
       &lt;iostream&gt;
      </code>
      ,
      <code class="calibre21">
       &lt;vector&gt;
      </code>
      ,
      <code class="calibre21">
       &lt;format&gt;
      </code>
      , and more.
     </p>
     <p class="calibre13">
      Modules solve all these issues, and more. The order in which modules are imported is not important. Modules are compiled once to a binary format, which the compiler can then use whenever a module is imported in another source file. This is in stark contrast with header files, which the compiler has to compile over and over again, every time it encounters an
      <code class="calibre21">
       #include
      </code>
      of that header file. Hence, modules can drastically improve compilation times. Incremental compilation times also improve, as certain modifications in modules, for example, modifying an exported function's implementation in a module interface file, do not trigger recompilation of users of that module (discussed in more details later in this chapter). Modules are not influenced by any externally defined macros, and any macros defined inside a module are never visible to any code outside the module, that is, modules are self-isolating. Hence, the following recommendation:
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c11-para-0008">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          With all the discussed benefits, if your compiler supports modules, newly written code should use modules to structure code into building blocks that are logically separated
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13">
      If possible, legacy code can slowly be transitioned to modules as well. However, there is a lot of legacy code in the world, and a lot of third-party libraries don't embrace modules yet, as not all compilers fully support modules at the time of this writing. For these reasons it is still important to know how legacy header files work. That's why this chapter still includes discussions on header files.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c11-para-0010">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          How to compile modules is compiler dependent. Consult your compiler's documentation to learn how to work with modules with your specific compiler
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c11-para-0011">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          As mentioned, at the time of this writing, not all compilers fully support modules yet, though all major compilers do, at least partially. This book uses modules everywhere. If your compiler does not yet fully support modules, you can convert the modularized code to non-modularized code, as explained next
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <span aria-label="423" class="calibre20" epub:type="pagebreak" id="Page_423" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-238">
       Unmodularizing Code
      </h3>
      <p class="calibre13">
       If you want to compile code samples from this book with a compiler that does not yet fully support modules, you can unmodularize the code as follows:
      </p>
      <ul class="calibre38" id="c11-list-0002">
       <li class="calibre9" id="c11-li-0010">
        Rename
        <code class="calibre21">
         .cppm
        </code>
        module interface files to
        <code class="calibre21">
         .h
        </code>
        header files.
       </li>
       <li class="calibre9" id="c11-li-0011">
        Add a
        <code class="calibre21">
         #pragma once
        </code>
        at the top of each
        <code class="calibre21">
         .h
        </code>
        header file.
       </li>
       <li class="calibre9" id="c11-li-0012">
        Remove
        <code class="calibre21">
         export module
         <i class="calibre18">
          xyz
         </i>
        </code>
        declarations.
       </li>
       <li class="calibre9" id="c11-li-0013">
        Replace
        <code class="calibre21">
         module
         <i class="calibre18">
          xyz
         </i>
        </code>
        declarations with an
        <code class="calibre21">
         #include
        </code>
        to include the corresponding header file.
       </li>
       <li class="calibre9" id="c11-li-0014">
        Replace
        <code class="calibre21">
         import
        </code>
        and
        <code class="calibre21">
         export import
        </code>
        declarations with proper
        <code class="calibre21">
         #include
        </code>
        directives. If the code is using
        <code class="calibre21">
         import std;
        </code>
        , then those need to be replaced with
        <code class="calibre21">
         #include
        </code>
        directives to include all necessary individual header files. See
        <a class="calibre5" href="b03.xhtml">
         Appendix C
        </a>
        , “Standard Library Header Files,” for a list of all Standard Library headers and a brief description of their contents.
       </li>
       <li class="calibre9" id="c11-li-0015">
        Remove any
        <code class="calibre21">
         export
        </code>
        keywords.
       </li>
       <li class="calibre9" id="c11-li-0016">
        Remove all occurrences of
        <code class="calibre21">
         module;
        </code>
        , which denotes the start of a global module fragment.
       </li>
       <li class="calibre9" id="c11-li-0017">
        If a function definition or variable definition appears in a
        <code class="calibre21">
         .h
        </code>
        header file, add the
        <code class="calibre21">
         inline
        </code>
        keyword in front of it.
       </li>
      </ul>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-239">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Standard Named Modules
      </h3>
      <p class="calibre13" id="c11-para-0014">
       As
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       explains, you get access to everything from the C++ Standard Library by importing the
       <i class="calibre18">
        standard named module
       </i>
       <code class="calibre21">
        std
       </code>
       . This named module makes the entire Standard Library available to you, including all C functionality, defined in such headers as
       <code class="calibre21">
        &lt;cstddef&gt;
       </code>
       . However, all C functionality is made available only through the
       <code class="calibre21">
        std
       </code>
       namespace. For legacy code, you can consider importing the
       <code class="calibre21">
        std.compat
       </code>
       named module instead, which imports everything
       <code class="calibre21">
        std
       </code>
       imports but makes all C functionality available both in the
       <code class="calibre21">
        std
       </code>
       namespace and the global namespace. The use of
       <code class="calibre21">
        std.compat
       </code>
       is not recommended in new code.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0010">
      </span>
      <h3 class="calibre27" id="head-3-240">
       Module Interface Files
      </h3>
      <p class="calibre13">
       A
       <i class="calibre18">
        module interface file
       </i>
       defines the interface for the functionality provided by a module and usually has
       <code class="calibre21">
        .cppm
       </code>
       as a file extension. A module interface file starts with a declaration stating that the file is defining a module with a certain name. This is called the
       <i class="calibre18">
        module declaration
       </i>
       . A module's name can be any valid C++ identifier. The name can include dots but cannot start or end with a dot and cannot contain multiple dots in a row. Examples of valid names are
       <code class="calibre21">
        datamodel
       </code>
       ,
       <code class="calibre21">
        mycompany.datamodel
       </code>
       ,
       <code class="calibre21">
        mycompany.datamodel.core
       </code>
       ,
       <code class="calibre21">
        datamodel_core
       </code>
       , and so on.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0016">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Currently, there is no standardized extension for module interface files. However, most compilers support the
           <code class="calibre21">
            .cppm
           </code>
           (C++ module) extension, so that's what this book uses. Check the documentation of your compiler to learn which extension to use
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c11-para-0017">
       <span aria-label="424" class="calibre20" epub:type="pagebreak" id="Page_424" role="doc-pagebreak">
       </span>
       A module needs to explicitly state what to export, i.e., what should be visible when client code imports the module. A module can export any declaration, such as variable declarations, function declarations, type declarations,
       <code class="calibre21">
        using
       </code>
       directives, and
       <code class="calibre21">
        using
       </code>
       declarations. Additionally,
       <code class="calibre21">
        import
       </code>
       declarations can be exported as well. Exporting entities from a module is done with the
       <code class="calibre21">
        export
       </code>
       keyword. Anything that is not exported from a module is visible only from within the module itself. The collection of all exported entities is called the
       <i class="calibre18">
        module interface
       </i>
       .
      </p>
      <p class="calibre13">
       Here is an example of a module interface file called
       <code class="calibre21">
        Person.cppm
       </code>
       , defining a
       <code class="calibre21">
        person
       </code>
       module and exporting a
       <code class="calibre21">
        Person
       </code>
       class. Note that it imports the functionality provided by
       <code class="calibre21">
        std
       </code>
       .
      </p>
      <pre class="calibre26" id="c11-code-0001"><code class="calibre21">export module person;  <span class="color">// Named module declaration</span></code>
<code class="calibre21"> </code>
<code class="calibre21">import std;            <span class="color">// Import declaration</span></code>
<code class="calibre21"> </code>
<code class="calibre21">export class Person    <span class="color">// Export declaration</span></code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Person(std::string firstName, std::string lastName)</code>
<code class="calibre21">            : m_firstName { std::move(firstName) }</code>
<code class="calibre21">            , m_lastName { std::move(lastName) } { }</code>
<code class="calibre21">        const std::string&amp; getFirstName() const { return m_firstName; }</code>
<code class="calibre21">        const std::string&amp; getLastName() const { return m_lastName; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_firstName;</code>
<code class="calibre21">        std::string m_lastName;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c11-para-0019">
       In standardese terms, everything starting from a named module declaration (the first line in the previous code snippet) until the end of the file is called the
       <i class="calibre18">
        module purview
       </i>
       .
      </p>
      <p class="calibre13">
       This
       <code class="calibre21">
        Person
       </code>
       class can be made available for use by importing the
       <code class="calibre21">
        person
       </code>
       module as follows (
       <code class="calibre21">
        test.cpp
       </code>
       ):
      </p>
      <pre class="calibre26" id="c11-code-0002"><code class="calibre21">import person;     <span class="color">// Import declaration for person module</span></code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Person person { "Kole", "Webb" };</code>
<code class="calibre21">    println("{}, {}", person.getLastName(), person.getFirstName());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Pretty much anything can be exported from a module, as long as it has a name. Examples are class definitions, function prototypes, class enumeration types,
       <code class="calibre21">
        using
       </code>
       declarations and directives, namespaces, and so on. If a namespace is explicitly exported with the
       <code class="calibre21">
        export
       </code>
       keyword, everything inside that namespace is automatically exported as well. For example, the following code snippet exports the entire
       <code class="calibre21">
        DataModel
       </code>
       namespace; hence, there is no need to explicitly export the individual classes and type alias:
      </p>
      <pre class="calibre26" id="c11-code-0003"><code class="calibre21">export module datamodel;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">export namespace DataModel</code>
<code class="calibre21">{</code>
<span aria-label="425" class="calibre20" epub:type="pagebreak" id="Page_425" role="doc-pagebreak"></span><code class="calibre21">    class Person { <span class="color">/* … */</span> };</code>
<code class="calibre21">    class Address { <span class="color">/* … */</span> };</code>
<code class="calibre21">    using Persons = std::vector&lt;Person&gt;;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You can also export a whole block of declarations using an
       <i class="calibre18">
        export block
       </i>
       . Here's an example:
      </p>
      <pre class="calibre26" id="c11-code-0004"><code class="calibre21">export</code>
<code class="calibre21">{</code>
<code class="calibre21">    namespace DataModel</code>
<code class="calibre21">    {</code>
<code class="calibre21">        class Person { <span class="color">/* … */</span> };</code>
<code class="calibre21">        class Address { <span class="color">/* … */</span> };</code>
<code class="calibre21">        using Persons = std::vector&lt;Person&gt;;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0012">
      </span>
      <h3 class="calibre27" id="head-3-241">
       Module Implementation Files
      </h3>
      <p class="calibre13" id="c11-para-0023">
       A module can be split into a module interface file and one or more
       <i class="calibre18">
        module implementation files
       </i>
       . Module implementation files usually have
       <code class="calibre21">
        .cpp
       </code>
       as their extension. You are free to decide which implementations you move to module implementation files and which implementations you leave in the module interface file. One option is to move all function and member function implementations to a module implementation file and leave only the function prototypes, class definitions, and so on in the module interface file. Another option is to leave the implementation of small functions and member functions in the interface file, while moving the implementations of other functions and member functions to an implementation file. You have a lot of flexibility here.
      </p>
      <p class="calibre13">
       A module implementation file again contains a named module declaration to specify for which module the implementations are for, but without the
       <code class="calibre21">
        export
       </code>
       keyword. For example, the previous
       <code class="calibre21">
        person
       </code>
       module can be split into an interface and an implementation file as follows. Here is the module interface file:
      </p>
      <pre class="calibre26" id="c11-code-0005"><code class="calibre21">export module person;  <span class="color">// Module declaration</span></code>
<code class="calibre21"> </code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">export class Person</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Person(std::string firstName, std::string lastName);</code>
<code class="calibre21">        const std::string&amp; getFirstName() const;</code>
<code class="calibre21">        const std::string&amp; getLastName() const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_firstName;</code>
<code class="calibre21">        std::string m_lastName;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The implementations now go in a
       <code class="calibre21">
        Person.cpp
       </code>
       module implementation file:
      </p>
      <pre class="calibre26" id="c11-code-0006"><code class="calibre21">module person;  <span class="color">// Module declaration, but without the export keyword</span></code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<span aria-label="426" class="calibre20" epub:type="pagebreak" id="Page_426" role="doc-pagebreak"></span><code class="calibre21">Person::Person(string firstName, string lastName)</code>
<code class="calibre21">    : m_firstName { move(firstName) }, m_lastName { move(lastName) }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">const string&amp; Person::getFirstName() const { return m_firstName; }</code>
<code class="calibre21">const string&amp; Person::getLastName() const { return m_lastName; }</code></pre>
      <p class="calibre13">
       Note that the implementation file does not have an import declaration for the
       <code class="calibre21">
        person
       </code>
       module. The
       <code class="calibre21">
        module person
       </code>
       declaration implicitly includes an
       <code class="calibre21">
        import person
       </code>
       declaration. Also note that the implementation file does not have any import declaration for
       <code class="calibre21">
        std
       </code>
       , even though it's using
       <code class="calibre21">
        std::string
       </code>
       in the implementation of the member functions. Thanks to the implicit
       <code class="calibre21">
        import person
       </code>
       , and because this implementation file is part of the same
       <code class="calibre21">
        person
       </code>
       module, it implicitly inherits the
       <code class="calibre21">
        std
       </code>
       import declaration from the module interface file. In contrast, adding an
       <code class="calibre21">
        import person
       </code>
       declaration to the
       <code class="calibre21">
        test.cpp
       </code>
       file does not implicitly inherit the
       <code class="calibre21">
        std
       </code>
       import declaration because
       <code class="calibre21">
        test.cpp
       </code>
       is not part of the
       <code class="calibre21">
        person
       </code>
       module. There is more to be said about this, which is the topic of the “Visibility vs. Reachability” section later in this chapter.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0027">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           All
          </i>
          <code class="calibre21">
           import
          </code>
          <i class="calibre18">
           declarations in module interface and module implementation files must be at the top of the file, after the named module declaration, but before any other declarations.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0028">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Module implementation files cannot export anything; only module interface files can
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0015">
      </span>
      <h3 class="calibre27" id="head-3-242">
       Splitting Interface from Implementation
      </h3>
      <p class="calibre13" id="c11-para-0029">
       When using header files, discussed later in this chapter, instead of modules, it is strongly recommended to put only declarations in your header file (
       <code class="calibre21">
        .h
       </code>
       ) and move all implementations to a source file (
       <code class="calibre21">
        .cpp
       </code>
       ). One of the reasons is to improve compilation times. If you were to put your implementations in the header file, any change, even just changing a comment, would require you to recompile all other source files that include that header. For certain header files, this could ripple through the entire code base, causing a full recompile of the program. By putting your implementations in a source file instead, making changes to those implementations without touching the header file means that only that single source file needs to be recompiled.
      </p>
      <p class="calibre13">
       Modules work differently. A
       <i class="calibre18">
        module interface
       </i>
       consists only of class definitions, function prototypes, and so on, but does not include any function or member function implementations, even if those implementations are directly in the module interface file. This means that changing a function or member function implementation that is inside a module interface file does not require a recompilation of users of that module, as long as you do not touch the interface part, for example, the function header (= function name, parameter list, and return type). Two exceptions are functions marked with
       <span aria-label="427" class="calibre20" epub:type="pagebreak" id="Page_427" role="doc-pagebreak">
       </span>
       the
       <code class="calibre21">
        inline
       </code>
       keyword, and template definitions. For both of these, the compiler needs to know their complete implementations at the time client code using them is compiled. Hence, any change to inline functions or template definitions can trigger recompilation of client code.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0031">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           When class definitions in header files contain member function implementations, those member functions are implicitly inline, even without marking them with the
          </i>
          <code class="calibre21">
           inline
          </code>
          <i class="calibre18">
           keyword. This is not true for member function implementations in class definitions in module interface files. If these need to be inline, they need to be explicitly marked as such.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c11-para-0032">
       Even though technically, it is not required anymore to split the interface from the implementation, in some cases I still recommend doing so. The main goal should be to have clean and easy-to-read interfaces. Implementations of functions can stay in the interface, as long as they don't obscure the interface and make it harder for users to quickly grasp what the public interface provides. For example, if a module has a rather big public interface, it might be better not to obscure that interface with implementations, so the user can have a better overview of what's being offered. Still, small getter and setter functions can stay in the interface, as they don't really impact the readability of the interface.
      </p>
      <p class="calibre13">
       Separating the interface from the implementation can be done in several ways. One option is to split a module into interface and implementation files, as discussed in the previous section. Another option is to separate the interface and the implementations within a single module interface file. For example, here is the
       <code class="calibre21">
        Person
       </code>
       class defined in a single module interface file (
       <code class="calibre21">
        person.cppm
       </code>
       ), but with the implementations split from the interface:
      </p>
      <pre class="calibre26" id="c11-code-0007"><code class="calibre21">export module person;</code>
<code class="calibre21">import std;</code>
<code class="calibre21"><span class="color">// Class definition</span></code>
<code class="calibre21">export class Person</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Person(std::string firstName, std::string lastName);</code>
<code class="calibre21">        const std::string&amp; getFirstName() const;</code>
<code class="calibre21">        const std::string&amp; getLastName() const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_firstName;</code>
<code class="calibre21">        std::string m_lastName;</code>
<code class="calibre21">};</code>
<code class="calibre21"><span class="color">// Implementations</span></code>
<code class="calibre21">Person::Person(std::string firstName, std::string lastName)</code>
<code class="calibre21">    : m_firstName { std::move(firstName) }, m_lastName { std::move(lastName) } { }</code>
<code class="calibre21">const std::string&amp; Person::getFirstName() const { return m_firstName; }</code>
<code class="calibre21">const std::string&amp; Person::getLastName() const { return m_lastName; }</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-243">
       Visibility vs. Reachability
      </h3>
      <p class="calibre13">
       As mentioned earlier, when you import the
       <code class="calibre21">
        person
       </code>
       module in another source file that is not part of the
       <code class="calibre21">
        person
       </code>
       module, for example in a
       <code class="calibre21">
        test.cpp
       </code>
       file, then you are not implicitly inheriting the
       <code class="calibre21">
        std
       </code>
       <span aria-label="428" class="calibre20" epub:type="pagebreak" id="Page_428" role="doc-pagebreak">
       </span>
       import declaration from the
       <code class="calibre21">
        person
       </code>
       module interface file. Without an explicit import for
       <code class="calibre21">
        std
       </code>
       in
       <code class="calibre21">
        test.cpp
       </code>
       , the
       <code class="calibre21">
        std::string
       </code>
       name, for example, is not
       <i class="calibre18">
        visible
       </i>
       , meaning the following highlighted line of code does not compile:
      </p>
      <pre class="calibre26" id="c11-code-0008"><code class="calibre21">import person;</code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">std::string str;</b></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Still, even without adding an explicit import for
       <code class="calibre21">
        std
       </code>
       to
       <code class="calibre21">
        test.cpp
       </code>
       , the following lines of code work just fine:
      </p>
      <pre class="calibre26" id="c11-code-0009"><code class="calibre21">Person person { "Kole", "Webb" };</code>
<code class="calibre21">const auto&amp; lastName { person.getLastName() };</code>
<code class="calibre21">auto length { lastName.length() };</code></pre>
      <p class="calibre13" id="c11-para-0036">
       Why is this working? There is a difference between
       <i class="calibre18">
        visibility
       </i>
       and
       <i class="calibre18">
        reachability
       </i>
       of entities in C++. By importing the
       <code class="calibre21">
        person
       </code>
       module, the functionality from
       <code class="calibre21">
        std
       </code>
       becomes
       <i class="calibre18">
        reachable
       </i>
       but not
       <i class="calibre18">
        visible
       </i>
       . Member functions of reachable classes automatically become visible. All this means that you can use certain functionality from
       <code class="calibre21">
        std
       </code>
       , such as storing the result of
       <code class="calibre21">
        getLastName()
       </code>
       in a variable by using
       <code class="calibre21">
        auto
       </code>
       type deduction and calling member functions on it such as
       <code class="calibre21">
        length()
       </code>
       .
      </p>
      <p class="calibre13" id="c11-para-0037">
       To make the
       <code class="calibre21">
        std::string
       </code>
       name properly visible in
       <code class="calibre21">
        test.cpp
       </code>
       , an explicit import of
       <code class="calibre21">
        std
       </code>
       or
       <code class="calibre21">
        &lt;string&gt;
       </code>
       is required.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0018">
      </span>
      <h3 class="calibre27" id="head-3-244">
       Submodules
      </h3>
      <p class="calibre13">
       The C++ standard does not speak about
       <i class="calibre18">
        submodules
       </i>
       as such; however, it is allowed to use dots in a module's name, and that makes it possible to structure your modules in any hierarchy you want. For example, earlier, the following example of a
       <code class="calibre21">
        DataModel
       </code>
       namespace was given:
      </p>
      <pre class="calibre26" id="c11-code-0010"><code class="calibre21">export module datamodel;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">export namespace DataModel</code>
<code class="calibre21">{</code>
<code class="calibre21">    class Person { <span class="color">/* … */</span> };</code>
<code class="calibre21">    class Address { <span class="color">/* … */</span> };</code>
<code class="calibre21">    using Persons = std::vector&lt;Person&gt;;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Both the
       <code class="calibre21">
        Person
       </code>
       and
       <code class="calibre21">
        Address
       </code>
       classes are inside the
       <code class="calibre21">
        DataModel
       </code>
       namespace and in the
       <code class="calibre21">
        datamodel
       </code>
       module. This can be restructured by defining two submodules:
       <code class="calibre21">
        datamodel.person
       </code>
       and
       <code class="calibre21">
        datamodel.address
       </code>
       . The module interface file for the
       <code class="calibre21">
        datamodel.person
       </code>
       submodule is as follows:
      </p>
      <pre class="calibre26" id="c11-code-0011"><code class="calibre21"><b class="calibre14">export module datamodel.person;</b>  <span class="color">// datamodel.person submodule</span></code>
<code class="calibre21">export namespace DataModel { class Person { <span class="color">/* … */</span> }; }</code></pre>
      <p class="calibre13">
       Here is the module interface file for
       <code class="calibre21">
        datamodel.address
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0012"><code class="calibre21"><b class="calibre14">export module datamodel.address;</b>  <span class="color">// datamodel.address submodule</span></code>
<code class="calibre21">export namespace DataModel { class Address { <span class="color">/* … */</span> }; }</code></pre>
      <p class="calibre13">
       <span aria-label="429" class="calibre20" epub:type="pagebreak" id="Page_429" role="doc-pagebreak">
       </span>
       Finally, a
       <code class="calibre21">
        datamodel
       </code>
       module is defined as follows. It imports and immediately exports both submodules.
      </p>
      <pre class="calibre26" id="c11-code-0013"><code class="calibre21"><b class="calibre14">export module datamodel;</b>          <span class="color">// datamodel module</span></code>
<code class="calibre21"><b class="calibre14">export import datamodel.person;</b>   <span class="color">// Import and export person submodule</span></code>
<code class="calibre21"><b class="calibre14">export import datamodel.address;</b>  <span class="color">// Import and export address submodule</span></code>
<code class="calibre21">import std;</code>
<code class="calibre21">export namespace DataModel { using Persons = std::vector&lt;Person&gt;; }</code></pre>
      <p class="calibre13">
       Of course, the member function implementations of classes in submodules can also go into module implementation files. For example, suppose the
       <code class="calibre21">
        Address
       </code>
       class has a default constructor that just prints a statement to standard output. That implementation could be in a file called
       <code class="calibre21">
        datamodel.address.cpp
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0014"><code class="calibre21">module datamodel.address;  <span class="color">// datamodel.address submodule</span></code>
<code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">DataModel::Address::Address() { println("Address::Address()"); }</code></pre>
      <p class="calibre13">
       A benefit of structuring your code with submodules is that clients can import either everything at once or only specific parts they want to use. For example, if client code needs access to everything in the
       <code class="calibre21">
        datamodel
       </code>
       module, then the following import declaration is the easiest:
      </p>
      <pre class="calibre26" id="c11-code-0015"><code class="calibre21">import datamodel;</code></pre>
      <p class="calibre13">
       On the other hand, if client code is only interested in using the
       <code class="calibre21">
        Address
       </code>
       class, then the following import declaration suffices:
      </p>
      <pre class="calibre26" id="c11-code-0016"><code class="calibre21">import datamodel.address;</code></pre>
      <p class="calibre13" id="c11-para-0045">
       Importing everything at once is more convenient than selectively importing what you need, especially for stable modules that rarely change. However, by using selective imports for less stable modules, it might be possible to improve build times if changes are made to the module. For example, if a change is made to the interface of the
       <code class="calibre21">
        datamodel.address
       </code>
       submodule, then only those files that import that submodule need to be recompiled.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0019">
      </span>
      <h3 class="calibre27" id="head-3-245">
       Module Partitions
      </h3>
      <p class="calibre13" id="c11-para-0046">
       Another option to structure modules is to split them into separate
       <i class="calibre18">
        partitions
       </i>
       . The difference between submodules and partitions is that the submodule structuring is visible to users of the module, allowing users to selectively import only those submodules they want to use. Partitions, on the other hand, are used to structure a module internally. Partitions are not exposed to users of the module. All partitions declared in
       <i class="calibre18">
        module interface partition files
       </i>
       must ultimately be exported by the
       <i class="calibre18">
        primary module interface file
       </i>
       , either directly or indirectly. A module always has only one such primary module interface file, and that's the interface file containing the
       <code class="calibre21">
        export module
        <i class="calibre18">
         name
        </i>
       </code>
       declaration.
      </p>
      <p class="calibre13">
       A module partition is created by separating the name of the module and the name of the partition with a colon. The name of a partition can be any legal identifier. For example, the
       <code class="calibre21">
        DataModel
       </code>
       module from the previous section can be restructured using partitions instead of submodules. Here is the
       <code class="calibre21">
        person
       </code>
       partition in a
       <code class="calibre21">
        datamodel.person.cppm
       </code>
       module interface partition file:
      </p>
      <pre class="calibre26" id="c11-code-0017"><code class="calibre21"><b class="calibre14">export module datamodel:person;</b>  <span class="color">// datamodel:person partition</span></code>
<code class="calibre21">export namespace DataModel { class Person { <span class="color">/* … */</span> }; }</code></pre>
      <p class="calibre13">
       <span aria-label="430" class="calibre20" epub:type="pagebreak" id="Page_430" role="doc-pagebreak">
       </span>
       Here is the
       <code class="calibre21">
        address
       </code>
       partition, including a default constructor:
      </p>
      <pre class="calibre26" id="c11-code-0018"><code class="calibre21"><b class="calibre14">export module datamodel:address;</b> <span class="color">// datamodel:address partition</span></code>
<code class="calibre21">export namespace DataModel</code>
<code class="calibre21">{</code>
<code class="calibre21">    class Address</code>
<code class="calibre21">    {</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Address();</code>
<code class="calibre21">        <span class="color">/* … */</span></code>
<code class="calibre21">    };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Unfortunately, there is a caveat when using implementation files in combination with partitions: there can be only one file with a certain partition name. So, having an implementation file that starts with the following declaration is ill-formed:
      </p>
      <pre class="calibre26" id="c11-code-0019"><code class="calibre21">module datamodel:address;</code></pre>
      <p class="calibre13">
       Instead, you can just put the
       <code class="calibre21">
        address
       </code>
       partition implementations in an implementation file for the
       <code class="calibre21">
        datamodel
       </code>
       module as follows:
      </p>
      <pre class="calibre26" id="c11-code-0020"><code class="calibre21"><b class="calibre14">module datamodel;</b>  <span class="color">// Not datamodel:address!</span></code>
<code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">DataModel::Address::Address() { println("Address::Address()"); }</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0052">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Multiple files cannot have the same partition name. Having multiple module interface partition files with the same partition name is illegal, and implementations for declarations in a module interface partition file cannot go in an implementation file with the same partition name. Instead, just put those implementations in a module implementation file for the module instead
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       An important point to remember when authoring modules structured in partitions is that each module interface partition must ultimately be exported by the primary module interface file, either directly or indirectly. To import a partition, you just specify the name of the partition prefixed with a colon, for example
       <code class="calibre21">
        import :person
       </code>
       . It's illegal to say something like
       <code class="calibre21">
        import datamodel:person
       </code>
       . Remember, partitions are not exposed to users of a module; partitions only structure a module internally. Hence, users cannot import a specific partition; they must import the entire module. Partitions can be imported only within the module itself, so it's redundant (and illegal) to specify the name of the module before the colon. Here is the primary module interface file for the
       <code class="calibre21">
        datamodel
       </code>
       module:
      </p>
      <pre class="calibre26" id="c11-code-0021"><code class="calibre21"><b class="calibre14">export module datamodel;</b> <span class="color">// datamodel module (primary module interface file)</span></code>
<code class="calibre21"><b class="calibre14">export import :person;</b>   <span class="color">// Import and export person partition</span></code>
<code class="calibre21"><b class="calibre14">export import :address;</b>  <span class="color">// Import and export address partition</span></code>
<code class="calibre21">import std;</code>
<code class="calibre21">export namespace DataModel { using Persons = std::vector&lt;Person&gt;; }</code></pre>
      <p class="calibre13">
       This partition-structured
       <code class="calibre21">
        datamodel
       </code>
       module can be used as follows:
      </p>
      <pre class="calibre26" id="c11-code-0022"><code class="calibre21">import datamodel;</code>
<code class="calibre21">int main() { DataModel::Address a; }</code></pre>
      <p class="calibre13">
       <span aria-label="431" class="calibre20" epub:type="pagebreak" id="Page_431" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0056">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Partitions are used to structure modules internally and are not visible outside of a module. Thus, users of a module cannot import specific partitions; they must import the entire module. You can use submodules instead of partitions if you want to allow users to selectively import parts of a module
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c11-para-0057">
       Earlier it is explained that a
       <code class="calibre21">
        module name
       </code>
       declaration implicitly includes an
       <code class="calibre21">
        import name
       </code>
       declaration. This is not the case for partitions.
      </p>
      <p class="calibre13" id="c11-para-0058">
       For example, the
       <code class="calibre21">
        datamodel:person
       </code>
       partition does not have an implicit
       <code class="calibre21">
        import datamodel
       </code>
       declaration. In this example, it's even not allowed to add an explicit
       <code class="calibre21">
        import datamodel
       </code>
       to the
       <code class="calibre21">
        datamodel:person
       </code>
       interface partition file. Doing so would result in a circular dependency: the
       <code class="calibre21">
        datamodel
       </code>
       interface file contains an
       <code class="calibre21">
        import :person
       </code>
       declaration, while the
       <code class="calibre21">
        datamodel:person
       </code>
       interface partition file would contain an
       <code class="calibre21">
        import datamodel
       </code>
       declaration.
      </p>
      <p class="calibre13" id="c11-para-0059">
       To break such circular dependencies, you can move the functionality that the
       <code class="calibre21">
        datamodel:person
       </code>
       partition needs from the
       <code class="calibre21">
        datamodel
       </code>
       interface file to another partition, which subsequently can be imported by both the
       <code class="calibre21">
        datamodel:person
       </code>
       interface partition file and the
       <code class="calibre21">
        datamodel
       </code>
       interface file.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c11-sec-0022">
       </span>
       <h4 class="calibre29" id="head-4-216">
        Implementation Partitions
       </h4>
       <p class="calibre13" id="c11-para-0060">
        A partition does not need to be declared in a module interface partition file, it can also be declared in a
        <i class="calibre18">
         module implementation partition file
        </i>
        , a normal source code file with extension
        <code class="calibre21">
         .cpp
        </code>
        , in which case it's an
        <i class="calibre18">
         implementation partition
        </i>
        , sometimes called an
        <i class="calibre18">
         internal partition
        </i>
        . Such partitions cannot be exported, compared to module interface partitions, which must be exported by the primary module interface file.
       </p>
       <p class="calibre13">
        For example, suppose you have the following
        <code class="calibre21">
         math
        </code>
        primary module interface file (
        <code class="calibre21">
         math.cppm
        </code>
        ):
       </p>
       <pre class="calibre26" id="c11-code-0023"><code class="calibre21">export module math; <span class="color">// math module declaration</span></code>
<code class="calibre21">export namespace Math</code>
<code class="calibre21">{</code>
<code class="calibre21">    double superLog(double z, double b);</code>
<code class="calibre21">    double lerchZeta(double lambda, double alpha, double s);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Suppose further that the implementations of the math functions require some helper functions that must not be exported by the module. An implementation partition is the perfect place to put such helper functions. The following defines such an implementation partition in a file called
        <code class="calibre21">
         math_helpers.cpp
        </code>
        :
       </p>
       <pre class="calibre26" id="c11-code-0024"><code class="calibre21"><b class="calibre14">module math:details;</b>  <span class="color">// math:details implementation partition</span></code>
<code class="calibre21">double someHelperFunction(double a) { return <span class="color">/* … */</span> ; }</code></pre>
       <p class="calibre13">
        Other
        <code class="calibre21">
         math
        </code>
        module implementation files can get access to these helper functions by importing this implementation partition. For example, a
        <code class="calibre21">
         math
        </code>
        module implementation file (
        <code class="calibre21">
         math.cpp
        </code>
        ) could look like this:
       </p>
       <pre class="calibre26" id="c11-code-0025"><code class="calibre21">module math;</code>
<code class="calibre21"><b class="calibre14">import :details;</b></code>
<span aria-label="432" class="calibre20" epub:type="pagebreak" id="Page_432" role="doc-pagebreak"></span><code class="calibre21">double Math::superLog(double z, double b) { return <span class="color">/* … */</span>; }</code>
<code class="calibre21">double Math::lerchZeta(double lambda, double alpha, double s) { return <span class="color">/* … */</span>; }</code></pre>
       <p class="calibre13" id="c11-para-0064">
        With the
        <code class="calibre21">
         import :details;
        </code>
        declaration, the
        <code class="calibre21">
         superLog()
        </code>
        and
        <code class="calibre21">
         lerchZeta()
        </code>
        functions can call
        <code class="calibre21">
         someHelperFunction()
        </code>
        .
       </p>
       <p class="calibre13" id="c11-para-0065">
        Of course, using such implementation partitions with helper functions makes sense only if multiple other source files use those helper functions.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0023">
      </span>
      <h3 class="calibre27" id="head-3-246">
       Private Module Fragment
      </h3>
      <p class="calibre13">
       The primary module interface can include a
       <i class="calibre18">
        private module fragment
       </i>
       . This private module fragment starts with the following line:
      </p>
      <pre class="calibre26" id="c11-code-0026"><code class="calibre21">module :private;</code></pre>
      <p class="calibre13" id="c11-para-0067">
       Everything after this line is part of the private module fragment. Anything that is defined in this private module fragment is not exported and thus not visible to consumers of the module.
      </p>
      <p class="calibre13">
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” demonstrates the pimpl idiom, also known as the private implementation idiom. It hides all implementation details from consumers of a class. The solution in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       requires two files: a primary module interface file and a module implementation file. Using a private module fragment, you can achieve this separation using a single file. Here is a concise example:
      </p>
      <pre class="calibre26" id="c11-code-0027"><code class="calibre21">export module adder;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">export class Adder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Adder();</code>
<code class="calibre21">        virtual ˜Adder();</code>
<code class="calibre21">        int add(int a, int b) const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        class Impl;</code>
<code class="calibre21">        std::unique_ptr&lt;Impl&gt; m_impl;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">module :private;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">class Adder::Impl</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        ˜Impl() { std::println("Destructor of Adder::Impl"); }</code>
<code class="calibre21">        int add(int a, int b) const { return a + b;}</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">Adder::Adder() : m_impl { std::make_unique&lt;Impl&gt;() } { }</code>
<code class="calibre21">Adder::˜Adder() {}</code>
<code class="calibre21">int Adder::add(int a, int b) const { return m_impl-&gt;add(a, b); }</code></pre>
      <p class="calibre13">
       This class can be tested as follows:
      </p>
      <pre class="calibre26" id="c11-code-0028"><code class="calibre21">Adder adder;</code>
<code class="calibre21">println("Value: {}", adder.add(20, 22));</code></pre>
      <p class="calibre13">
       <span aria-label="433" class="calibre20" epub:type="pagebreak" id="Page_433" role="doc-pagebreak">
       </span>
       Now, to prove that everything in the private module fragment is truly hidden, let's add a
       <code class="calibre21">
        public
       </code>
       member function
       <code class="calibre21">
        getImplementation()
       </code>
       at the end of the
       <code class="calibre21">
        Adder
       </code>
       class:
      </p>
      <pre class="calibre26" id="c11-code-0029"><code class="calibre21">export class Adder</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">/* … as before, omitted for brevity … */</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        class Impl;</code>
<code class="calibre21">        std::unique_ptr&lt;Impl&gt; m_impl;</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Impl* getImplementation() { return m_impl.get(); }</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The following compiles and works fine:
      </p>
      <pre class="calibre26" id="c11-code-0030"><code class="calibre21">Adder adder;</code>
<code class="calibre21">auto impl { adder.getImplementation() };</code></pre>
      <p class="calibre13">
       From the point of view of consumers of the
       <code class="calibre21">
        Adder
       </code>
       module,
       <code class="calibre21">
        getImplementation()
       </code>
       returns a pointer to an incomplete type. The code snippet is storing that pointer in a variable called
       <code class="calibre21">
        impl
       </code>
       . Simply storing a pointer to an incomplete type is fine, as long as you use
       <code class="calibre21">
        auto
       </code>
       type deduction. However, you cannot do anything with that pointer. Calling
       <code class="calibre21">
        add()
       </code>
       on that incomplete pointer results in an error:
      </p>
      <pre class="calibre26" id="c11-code-0031"><code class="calibre21">auto result { impl-&gt;add(20, 22) };  <span class="color">// Error!</span></code></pre>
      <p class="calibre13" id="c11-para-0073">
       The error is something like: use of undefined type Adder::Impl. The reason is that the
       <code class="calibre21">
        Adder::Impl
       </code>
       class is part of the private module fragment and hence not accessible from consumers of the
       <code class="calibre21">
        Adder
       </code>
       module.
      </p>
      <p class="calibre13" id="c11-para-0074">
       If you remove the
       <code class="calibre21">
        module :private;
       </code>
       line from the module interface file, then the previous code snippet compiles and runs fine. You might be surprised at first sight by this; after all, the
       <code class="calibre21">
        Adder::Impl
       </code>
       class is not explicitly exported. That's correct—it's not explicitly exported, but it is implicitly exported because the
       <code class="calibre21">
        Adder
       </code>
       class is exported and the
       <code class="calibre21">
        Impl
       </code>
       class is declared within the
       <code class="calibre21">
        Adder
       </code>
       class.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0024">
      </span>
      <h3 class="calibre27" id="head-3-247">
       Header Units
      </h3>
      <p class="calibre13">
       When importing a module, you use an import declaration such as the following:
      </p>
      <pre class="calibre26" id="c11-code-0032"><code class="calibre21">import person;</code></pre>
      <p class="calibre13">
       If you have legacy code, such as a
       <code class="calibre21">
        person.h
       </code>
       header file defining a
       <code class="calibre21">
        Person
       </code>
       class, then you can modularize it by converting it to a proper module,
       <code class="calibre21">
        person.cppm
       </code>
       , and use import declarations to make it available to client code. However, sometimes you cannot modularize such headers. Maybe your
       <code class="calibre21">
        Person
       </code>
       class should remain usable by compilers that do not yet have support for modules. Or maybe the
       <code class="calibre21">
        person.h
       </code>
       header is part of a third-party library that you cannot modify. In such cases, you can import your header file directly, as follows:
      </p>
      <pre class="calibre26" id="c11-code-0033"><code class="calibre21">import "person.h";</code></pre>
      <p class="calibre13" id="c11-para-0077">
       With such a declaration, everything in the
       <code class="calibre21">
        person.h
       </code>
       header file becomes implicitly exported. Additionally, macros defined in the header become visible to client code, which is not the case for real modules, neither for your own modules nor for the named
       <code class="calibre21">
        std
       </code>
       and
       <code class="calibre21">
        std.compat
       </code>
       modules.
      </p>
      <p class="calibre13">
       <span aria-label="434" class="calibre20" epub:type="pagebreak" id="Page_434" role="doc-pagebreak">
       </span>
       Such an import declaration can include relative or absolute paths to header files, and you can use
       <code class="calibre21">
        &lt; &gt;
       </code>
       instead of
       <code class="calibre21">
        ""
       </code>
       to search in the system include directories:
      </p>
      <pre class="calibre26" id="c11-code-0034"><code class="calibre21">import "include/person.h"; <span class="color">// Can include a relative or absolute path.</span></code>
<code class="calibre21">import &lt;person.h&gt;;         <span class="color">// Search in system include directories.</span></code></pre>
      <p class="calibre13" id="c11-para-0079">
       Compared to using
       <code class="calibre21">
        #include
       </code>
       to add a header file, using
       <code class="calibre21">
        import
       </code>
       will improve build throughput, as the
       <code class="calibre21">
        person.h
       </code>
       header will implicitly be converted to a module and hence be compiled only once, instead of every time when the header is included in a source file. As such, it can be used as a standardized way to support
       <i class="calibre18">
        precompiled header files
       </i>
       , instead of using compiler-dependent precompiled header file support.
      </p>
      <p class="calibre13">
       For each import declaration naming a header file, the compiler creates a module with an exported interface similar to what the header file defines, i.e., it implicitly exports everything from the header file. This is called a
       <i class="calibre18">
        header unit
       </i>
       . The procedure for this is compiler dependent, so check the documentation of your compiler to learn how to work with header units.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0081">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           By importing a header unit, the preprocessor definitions from that header unit become available to you. However, if you
          </i>
          <code class="calibre21">
           export import
          </code>
          <i class="calibre18">
           a header unit, its preprocessor definitions are not exported further. Any code that needs access to those preprocessor definitions needs to explicitly
          </i>
          <code class="calibre21">
           import
          </code>
          <i class="calibre18">
           the header unit.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0026">
      </span>
      <h3 class="calibre27" id="head-3-248">
       Importable Standard Library Headers
      </h3>
      <p class="calibre13">
       All C++ headers, such as
       <code class="calibre21">
        &lt;iostream&gt;
       </code>
       ,
       <code class="calibre21">
        &lt;vector&gt;
       </code>
       ,
       <code class="calibre21">
        &lt;string&gt;
       </code>
       , and so on, are
       <i class="calibre18">
        importable headers
       </i>
       that can be imported with an import declaration. That means you can, for example, write the following:
      </p>
      <pre class="calibre26" id="c11-code-0035"><code class="calibre21">import &lt;vector&gt;;</code></pre>
      <p class="calibre13">
       Of course, starting with C++23, it's more convenient to simply import the named module called
       <code class="calibre21">
        std
       </code>
       , instead of manually importing those importable headers that you need. For example, the following makes everything in the Standard Library available for your use:
      </p>
      <pre class="calibre26" id="c11-code-0036"><code class="calibre21">import std;</code></pre>
      <p class="calibre13" id="c11-para-0084">
       As you know by now, importable C++ Standard Library headers don't have any
       <code class="calibre21">
        .h
       </code>
       extension, e.g.,
       <code class="calibre21">
        &lt;vector&gt;
       </code>
       , and they define everything in the
       <code class="calibre21">
        std
       </code>
       namespace or a subnamespace of
       <code class="calibre21">
        std
       </code>
       .
      </p>
      <p class="calibre13" id="c11-para-0085">
       In C, the names of Standard Library header files end with
       <code class="calibre21">
        .h
       </code>
       , such as
       <code class="calibre21">
        &lt;stdio.h&gt;
       </code>
       , and namespaces are not used.
      </p>
      <p class="calibre13">
       Most of the Standard Library functionality from C is available in C++ but is provided through two different headers:
      </p>
      <ul class="calibre38" id="c11-list-0003">
       <li class="calibre9" id="c11-li-0018">
        The recommended versions without the
        <code class="calibre21">
         .h
        </code>
        extension but with a
        <code class="calibre21">
         c
        </code>
        prefix, for example,
        <code class="calibre21">
         &lt;cstdio&gt;
        </code>
        . These put everything in the
        <code class="calibre21">
         std
        </code>
        namespace.
       </li>
       <li class="calibre9" id="c11-li-0019">
        The C-style versions with the
        <code class="calibre21">
         .h
        </code>
        extension, for example,
        <code class="calibre21">
         &lt;stdio.h&gt;
        </code>
        . These do not use namespaces. Their use is discouraged, except when you are writing code that needs to be
        <span aria-label="435" class="calibre20" epub:type="pagebreak" id="Page_435" role="doc-pagebreak">
        </span>
        both valid C++ and valid C at the same time. This use case is not further discussed in this C++ book.
       </li>
      </ul>
      <p class="calibre13">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0088">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Up until C++23, the use of
          </i>
          <code class="calibre21">
           &lt;name.h&gt;
          </code>
          <i class="calibre18">
           C Standard Library headers was deprecated. Starting with C++23, their use is no longer deprecated, but discouraged.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c11-para-0089">
       Technically, the old versions are allowed to put things in the
       <code class="calibre21">
        std
       </code>
       namespace as well, and the new versions are allowed to additionally put things in the global namespace. This behavior is not standardized, so you should not rely on it.
      </p>
      <p class="calibre13" id="c11-para-0090">
       As mentioned earlier, when using
       <code class="calibre21">
        import std;
       </code>
       you automatically get access to C-style functions, such as the mathematical functions defined in
       <code class="calibre21">
        &lt;cmath&gt;
       </code>
       . They will be in the
       <code class="calibre21">
        std
       </code>
       namespace, e.g.,
       <code class="calibre21">
        std::sqrt()
       </code>
       . If you
       <code class="calibre21">
        import std.compat;
       </code>
       these C-style functions will additionally be available in the global namespace, e.g.,
       <code class="calibre21">
        ::sqrt()
       </code>
       .
      </p>
      <p class="calibre13" id="c11-para-0091">
       However, if you cannot use the
       <code class="calibre21">
        std
       </code>
       or
       <code class="calibre21">
        std.compat
       </code>
       named modules, then keep in mind that the C Standard Library headers are not guaranteed to be importable with an
       <code class="calibre21">
        import
       </code>
       declaration. In that case, to be safe, use
       <code class="calibre21">
        #include &lt;c
        <i class="calibre18">
         xyz
        </i>
        &gt;
       </code>
       instead of
       <code class="calibre21">
        import &lt;c
        <i class="calibre18">
         xyz
        </i>
        &gt;;
       </code>
       .
      </p>
      <p class="calibre13">
       Additionally, as mentioned in the previous section, importing a proper module, e.g.,
       <code class="calibre21">
        std
       </code>
       or
       <code class="calibre21">
        std.compat
       </code>
       , won't make any C-style macros defined in the module available to the importing code. This is especially important to remember when you want to use C-style macros from the C Standard Library. Luckily, there aren't many! One of them is
       <code class="calibre21">
        &lt;cassert&gt;
       </code>
       , a C Standard Library header that defines the
       <code class="calibre21">
        assert()
       </code>
       macro, which is explained in more detail in
       <a class="calibre5" href="c31.xhtml">
        Chapter 31
       </a>
       , “Conquering Debugging.” Since the named
       <code class="calibre21">
        std
       </code>
       and
       <code class="calibre21">
        std.compat
       </code>
       modules won't make the
       <code class="calibre21">
        assert()
       </code>
       macro available to importing code, and since
       <code class="calibre21">
        &lt;cassert&gt;
       </code>
       is a C Standard Library header and thus not guaranteed to be importable, you must use
       <code class="calibre21">
        #include &lt;cassert&gt;
       </code>
       to get access to
       <code class="calibre21">
        assert()
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0093">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           If you can
          </i>
          <code class="calibre21">
           import
          </code>
          <i class="calibre18">
           a header file, it's recommended to do so. Only
          </i>
          <code class="calibre21">
           #include
          </code>
          <i class="calibre18">
           a header file if it's not importable, for instance, because the content of the header file is dependent on some preprocessor
          </i>
          <code class="calibre21">
           #define
          </code>
          <i class="calibre18">
           s (see the next section)
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       If you do need to
       <code class="calibre21">
        #include
       </code>
       a header in a module interface or module implementation file, the
       <code class="calibre21">
        #include
       </code>
       directives should be placed in the
       <i class="calibre18">
        global module fragment
       </i>
       , which must come before any named module declaration and starts with a nameless module declaration. A global module fragment can only contain preprocessing directives such as
       <code class="calibre21">
        #include
       </code>
       s,
       <code class="calibre21">
        #define
       </code>
       s, and so on. Such a global module fragment and comments are the only things that are allowed to appear before a named module declaration. For example, if you need to use functionality from the
       <code class="calibre21">
        &lt;cassert&gt;
       </code>
       C header file, you can make that available as follows:
      </p>
      <pre class="calibre26" id="c11-code-0037"><code class="calibre21"><b class="calibre14">module;</b>                <span class="color">// Start of the global module fragment</span></code>
<code class="calibre21"><b class="calibre14">#include &lt;cassert&gt;</b>     <span class="color">// Include legacy header files</span></code>
<code class="calibre21"> </code>
<code class="calibre21">export module person;  <span class="color">// Named module declaration</span></code>
<span aria-label="436" class="calibre20" epub:type="pagebreak" id="Page_436" role="doc-pagebreak"></span><code class="calibre21">import std;</code>
<code class="calibre21">export class Person { <span class="color">/* … */</span> };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0096">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Place all
          </i>
          <code class="calibre21">
           #include
          </code>
          <i class="calibre18">
           directives in a module interface or module implementation file in the global module fragment.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-133" class="calibre2">
     <span class="calibre" id="c11-sec-0030">
     </span>
     <h2 class="calibre6" id="head-2-133">
      PREPROCESSOR DIRECTIVES
     </h2>
     <p class="calibre13">
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      introduces the
      <code class="calibre21">
       #include
      </code>
      preprocessor directive to include the contents of a header file. There are a few more preprocessor directives available. The following table shows some of the most commonly used preprocessor directives:
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         PREPROCESSOR DIRECTIVE
        </th>
        <th class="left" scope="col">
         FUNCTIONALITY
        </th>
        <th class="left" scope="col">
         COMMON USES
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="left1">
         <code class="calibre21">
          #include [file]
         </code>
        </td>
        <td class="left1">
         The contents of the file with name
         <code class="calibre21">
          [file]
         </code>
         is inserted into the code at the location of the directive.
        </td>
        <td class="left1">
         Almost always used to include header files so that code can make use of functionality defined elsewhere.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <code class="calibre21">
          #define [id] [value]
         </code>
        </td>
        <td class="left1">
         Every occurrence of the identifier
         <code class="calibre21">
          [id]
         </code>
         is replaced with
         <code class="calibre21">
          [value]
         </code>
         .
        </td>
        <td class="left1">
         Often used in C to define a constant value or a macro. C++ provides better mechanisms for constants and most types of macros. Macros can be dangerous, so use them cautiously. See the next section for some examples.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <code class="calibre21">
          #undef [id]
         </code>
        </td>
        <td class="left1">
         Undefines the identifier
         <code class="calibre21">
          [id]
         </code>
         previously defined using
         <code class="calibre21">
          #define
         </code>
         .
        </td>
        <td class="left1">
         Used if a defined identifier is only required within a limited scope of the code.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <pre class="calibre26" id="c11-code-0038"><code class="calibre21">#if [expression]</code>
<code class="calibre21">#elif [expression]</code>
<code class="calibre21">#else</code>
<code class="calibre21">#endif</code></pre>
        </td>
        <td class="left1">
         Conditionally include a block of code based on the result of a given expression.
        </td>
        <td class="left1">
         Often used to provide specific code for specific platforms.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <pre class="calibre26" id="c11-code-0039"><code class="calibre21">#ifdef [id]</code>
<code class="calibre21">#endif</code>
<code class="calibre21"> </code>
<code class="calibre21">#ifndef [id]</code>
<code class="calibre21">#endif</code></pre>
        </td>
        <td class="left1">
         Conditionally include code based on whether the specified identifier has been defined with
         <code class="calibre21">
          #define
         </code>
         .
         <code class="calibre21">
          #ifdef [id]
         </code>
         is equivalent to
         <code class="calibre21">
          #if defined(id)
         </code>
         and
         <code class="calibre21">
          #ifndef [id]
         </code>
         is equivalent to
         <code class="calibre21">
          #if !defined(id)
         </code>
         .
        </td>
        <td class="left1">
         Used most frequently to protect against circular includes. Each header file starts with an
         <code class="calibre21">
          #ifndef
         </code>
         checking the absence of an identifier, followed by a
         <code class="calibre21">
          #define
         </code>
         directive to define that identifier. The header file ends with an
         <code class="calibre21">
          #endif
         </code>
         . This prevents the file from being included multiple times; see the Header Files section later in this chapter.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         <pre class="calibre26" id="c11-code-0040"><code class="calibre21">#elifdef [id]</code>
<code class="calibre21">#elifndef [id]</code></pre>
        </td>
        <td class="left1">
         <code class="calibre21">
          #elifdef [id]
         </code>
         is equivalent to
         <code class="calibre21">
          #elif defined(id)
         </code>
         and
         <code class="calibre21">
          #elifndef [id]
         </code>
         is equivalent to
         <br class="calibre12"/>
         <code class="calibre21">
          #elif !defined(id)
         </code>
         .
        </td>
        <td class="left1">
         Shorthand notations for other functionality.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <code class="calibre21">
          #pragma [xyz]
         </code>
        </td>
        <td class="left1">
         Controls compiler-specific behavior.
         <code class="calibre21">
          [xyz]
         </code>
         is compiler dependent. Most compilers support
         <code class="calibre21">
          once
         </code>
         to prevent a header file from being included multiple times.
        </td>
        <td class="left1">
         See the Header Files section later in this chapter for an example.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <code class="calibre21">
          #error [message]
         </code>
        </td>
        <td class="left1">
         Causes the compilation to stop with the given message.
        </td>
        <td class="left1">
         Can be used to stop the compilation if the user tries to compile code on an unsupported platform.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         <code class="calibre21">
          #warning [message]
         </code>
        </td>
        <td class="left1">
         Causes the compiler to emit the given message as a warning, but compilation continues.
        </td>
        <td class="left1">
         Used to display a warning to the user without affecting the compilation result.
         <span aria-label="437" class="calibre20" epub:type="pagebreak" id="Page_437" role="doc-pagebreak">
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0031">
      </span>
      <h3 class="calibre27" id="head-3-249">
       Preprocessor Macros
      </h3>
      <p class="calibre13">
       You can use the C++ preprocessor to write
       <i class="calibre18">
        macros
       </i>
       , which are like little functions. Here is an example:
      </p>
      <pre class="calibre26" id="c11-code-0041"><code class="calibre21">#define SQUARE(x) ((x) * (x)) <span class="color">// No semicolon after the macro definition!</span></code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("{}", SQUARE(5));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Macros are a remnant from C that are quite similar to
       <code class="calibre21">
        inline
       </code>
       functions, except that they are not type-checked, and the preprocessor dumbly replaces any calls to them with their expansions. The preprocessor does not apply true function-call semantics. This behavior can cause unexpected results. For example, consider what would happen if you called the
       <code class="calibre21">
        SQUARE
       </code>
       macro with
       <code class="calibre21">
        2+3
       </code>
       instead of
       <code class="calibre21">
        5
       </code>
       , like this:
      </p>
      <pre class="calibre26" id="c11-code-0042"><code class="calibre21">println("{}", SQUARE(2 + 3));</code></pre>
      <p class="calibre13">
       You expect
       <code class="calibre21">
        SQUARE
       </code>
       to calculate
       <code class="calibre21">
        25
       </code>
       , which it does. However, what if you left out some parentheses from the macro definition, so that it looks like this?
      </p>
      <pre class="calibre26" id="c11-code-0043"><code class="calibre21">#define SQUARE(x) (x * x)</code></pre>
      <p class="calibre13">
       <span aria-label="438" class="calibre20" epub:type="pagebreak" id="Page_438" role="doc-pagebreak">
       </span>
       Now the call to
       <code class="calibre21">
        SQUARE(2+3)
       </code>
       generates
       <code class="calibre21">
        11
       </code>
       , not
       <code class="calibre21">
        25
       </code>
       ! Remember that the macro is dumbly expanded without regard to function-call semantics. This means that any
       <code class="calibre21">
        x
       </code>
       in the macro body is replaced by
       <code class="calibre21">
        2 + 3
       </code>
       , leading to this expansion:
      </p>
      <pre class="calibre26" id="c11-code-0044"><code class="calibre21">println("{}", (2 + 3 * 2 + 3));</code></pre>
      <p class="calibre13" id="c11-para-0111">
       Following proper order of operations, this line performs the multiplication first, followed by the additions, generating
       <code class="calibre21">
        11
       </code>
       instead of
       <code class="calibre21">
        25
       </code>
       !
      </p>
      <p class="calibre13">
       Macros can also have a performance impact. Suppose you call the
       <code class="calibre21">
        SQUARE
       </code>
       macro as follows:
      </p>
      <pre class="calibre26" id="c11-code-0045"><code class="calibre21">println("{}", SQUARE(veryExpensiveFunctionCallToComputeNumber()));</code></pre>
      <p class="calibre13">
       The preprocessor replaces this with the following:
      </p>
      <pre class="calibre26" id="c11-code-0046"><code class="calibre21">println("{}", ((veryExpensiveFunctionCallToComputeNumber()) *</code>
<code class="calibre21">         (veryExpensiveFunctionCallToComputeNumber())));</code></pre>
      <p class="calibre13" id="c11-para-0114">
       Now you are calling the expensive function twice—another reason to avoid macros.
      </p>
      <p class="calibre13">
       Macros also cause problems for debugging because the code you write is not the code that the compiler sees or that shows up in your debugger (because of the search-and-replace behavior of the preprocessor). For these reasons, you should avoid macros entirely in favor of inline functions. The details are shown here only because quite a bit of C++ code out there still employs macros. You need to understand them to read and maintain such code.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0116">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Most compilers can output the preprocessed source to a file or to standard output. You can use that feature to see how the preprocessor is preprocessing your file. For example, with Microsoft Visual C++ you can use the
          </i>
          <code class="calibre21">
           <i class="calibre18">
            /
           </i>
           P
          </code>
          <i class="calibre18">
           switch. With GCC you can use the
          </i>
          <code class="calibre21">
           <i class="calibre18">
            -
           </i>
           E
          </code>
          <i class="calibre18">
           switch.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-134" class="calibre2">
     <span class="calibre" id="c11-sec-0033">
     </span>
     <h2 class="calibre6" id="head-2-134">
      LINKAGE
     </h2>
     <p class="calibre13" id="c11-para-0117">
      This section describes the concept of
      <i class="calibre18">
       linkage
      </i>
      in C++. As
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      explains, C++ source files are first processed by the preprocessor, which processes all preprocessor directives, resulting in
      <i class="calibre18">
       translation units
      </i>
      . All translation units are then compiled independently into
      <i class="calibre18">
       object files
      </i>
      , which contain the machine executable code but in which references to functions and so on are not yet defined. Resolving those references is done by the final phase, the
      <i class="calibre18">
       linker
      </i>
      , which links all object files together into the final
      <i class="calibre18">
       executable
      </i>
      . Technically, there are a few more phases in the compilation process, but for this discussion, this simplified view is sufficient.
     </p>
     <p class="calibre13">
      Each name in a C++ translation unit, including functions and global variables, either has linkage or has no linkage, and this specifies where that name can be defined and from where it can be accessed. There are four types of linkage:
     </p>
     <ul class="check" id="c11-list-0004">
      <li class="calibre9" id="c11-li-0020">
       <b class="calibre14">
        No linkage:
       </b>
       The name is accessible only from the scope in which it is defined.
      </li>
      <li class="calibre9" id="c11-li-0021">
       <b class="calibre14">
        External linkage:
       </b>
       The name is accessible from any translation unit.
      </li>
      <li class="calibre9" id="c11-li-0022">
       <span aria-label="439" class="calibre20" epub:type="pagebreak" id="Page_439" role="doc-pagebreak">
       </span>
       <b class="calibre14">
        Internal linkage (also called static linkage):
       </b>
       The name is accessible only from the current translation unit, but not from other translation units.
      </li>
      <li class="calibre9" id="c11-li-0023">
       <b class="calibre14">
        Module linkage:
       </b>
       The name is accessible from any translation unit from the same module.
      </li>
     </ul>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0034">
      </span>
      <h3 class="calibre27" id="head-3-250">
       Internal Linkage
      </h3>
      <p class="calibre13">
       By default, functions and global variables have external linkage. However, you can specify internal (or static) linkage by employing
       <i class="calibre18">
        anonymous namespaces
       </i>
       . For example, suppose you have two source files:
       <code class="calibre21">
        FirstFile.cpp
       </code>
       and
       <code class="calibre21">
        AnotherFile.cpp
       </code>
       . Here is
       <code class="calibre21">
        FirstFile.cpp
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0047"><code class="calibre21">void f();</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    f();</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Note that this file provides a prototype for
       <code class="calibre21">
        f()
       </code>
       but doesn't show the definition. Here is
       <code class="calibre21">
        AnotherFile.cpp
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0048"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">void f();</code>
<code class="calibre21"> </code>
<code class="calibre21">void f()</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::println("f");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c11-para-0121">
       This file provides both a prototype and a definition for
       <code class="calibre21">
        f()
       </code>
       . Note that it is legal to write prototypes for the same function in two different files. That's precisely what the preprocessor does for you if you put the prototypes in a header file that you
       <code class="calibre21">
        #include
       </code>
       in each of the source files. For this example, I don't use a header file. The reason to use header files used to be that it was easier to maintain (and keep synchronized) one copy of the prototype, but now that C++ has support for modules, using modules is recommended over using header files.
      </p>
      <p class="calibre13" id="c11-para-0122">
       Each of these source files compiles without error, and the program links fine: because
       <code class="calibre21">
        f()
       </code>
       has external linkage,
       <code class="calibre21">
        main()
       </code>
       can call it from a different file.
      </p>
      <p class="calibre13">
       However, suppose you wrap the
       <code class="calibre21">
        f()
       </code>
       function in
       <code class="calibre21">
        AnotherFile.cpp
       </code>
       in an anonymous namespace to give it internal linkage as follows:
      </p>
      <pre class="calibre26" id="c11-code-0049"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">namespace</b></code>
<code class="calibre21"><b class="calibre14">{</b></code>
<code class="calibre21">    <b class="calibre14">void f();</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    void f()</code>
<code class="calibre21">    {</code>
<code class="calibre21">        std::println("f");</code>
<code class="calibre21">    }</code>
<code class="calibre21"><b class="calibre14">}</b></code></pre>
      <p class="calibre13" id="c11-para-0124">
       <span aria-label="440" class="calibre20" epub:type="pagebreak" id="Page_440" role="doc-pagebreak">
       </span>
       Entities in an anonymous namespace have internal linkage and thus can be accessed anywhere following their declaration in the same translation unit, but cannot be accessed from other translation units. With this change, each of the source files still compiles without error, but the linker step fails because
       <code class="calibre21">
        f()
       </code>
       has internal linkage, making it unavailable from
       <code class="calibre21">
        FirstFile.cpp
       </code>
       .
      </p>
      <p class="calibre13">
       An alternative to using anonymous namespaces to give a name internal linkage is to prefix the declaration with the keyword
       <code class="calibre21">
        static
       </code>
       . The earlier anonymous namespace example can be written as follows. Note that you don't need to repeat the
       <code class="calibre21">
        static
       </code>
       keyword in front of the definition of
       <code class="calibre21">
        f()
       </code>
       . As long as it precedes the first instance of the function name, there is no need to repeat it.
      </p>
      <pre class="calibre26" id="c11-code-0050"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">static void f();</b></code>
<code class="calibre21"> </code>
<code class="calibre21">void f()</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::println("f");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The semantics of this version of the code are exactly the same as the one using an anonymous namespace.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0127">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           If a translation unit needs a helper entity that is only required within that translation unit, wrap it in an anonymous namespace to give it internal linkage. Using the
          </i>
          <code class="calibre21">
           static
          </code>
          <i class="calibre18">
           keyword for this is discouraged.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0036">
      </span>
      <h3 class="calibre27" id="head-3-251">
       The extern Keyword
      </h3>
      <p class="calibre13">
       A related keyword,
       <code class="calibre21">
        extern
       </code>
       , seems like it should be the opposite of
       <code class="calibre21">
        static
       </code>
       , specifying external linkage for the names it precedes, and it can be used that way in certain cases. For example,
       <code class="calibre21">
        const
       </code>
       s and
       <code class="calibre21">
        typedef
       </code>
       s have internal linkage by default. You can use
       <code class="calibre21">
        extern
       </code>
       to give them external linkage. However,
       <code class="calibre21">
        extern
       </code>
       has some complications. When you specify a name as
       <code class="calibre21">
        extern
       </code>
       , the compiler treats it as a declaration, not a definition. For variables, this means the compiler doesn't allocate space for the variable. You must provide a separate definition for the variable without the
       <code class="calibre21">
        extern
       </code>
       keyword. For example, here is the content of
       <code class="calibre21">
        AnotherFile.cpp
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0051"><code class="calibre21">extern int x;</code>
<code class="calibre21">int x { 3 };</code></pre>
      <p class="calibre13">
       Alternatively, you can initialize
       <code class="calibre21">
        x
       </code>
       in the
       <code class="calibre21">
        extern
       </code>
       statement, which then serves as the declaration and the definition:
      </p>
      <pre class="calibre26" id="c11-code-0052"><code class="calibre21">extern int x { 3 };</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        extern
       </code>
       in this case is not very useful, because
       <code class="calibre21">
        x
       </code>
       has external linkage by default anyway. The real use of
       <code class="calibre21">
        extern
       </code>
       is when you want to use
       <code class="calibre21">
        x
       </code>
       from another source file,
       <code class="calibre21">
        FirstFile.cpp
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0053"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">extern int x;</b></code>
<span aria-label="441" class="calibre20" epub:type="pagebreak" id="Page_441" role="doc-pagebreak"></span><code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::println("{}", x);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Here,
       <code class="calibre21">
        FirstFile.cpp
       </code>
       uses an
       <code class="calibre21">
        extern
       </code>
       declaration so that it can use
       <code class="calibre21">
        x
       </code>
       . The compiler needs a declaration of
       <code class="calibre21">
        x
       </code>
       to use it in
       <code class="calibre21">
        main()
       </code>
       . If you declared
       <code class="calibre21">
        x
       </code>
       without the
       <code class="calibre21">
        extern
       </code>
       keyword, the compiler would think it's a definition and would allocate space for
       <code class="calibre21">
        x
       </code>
       , causing the linkage step to fail (because there are then two
       <code class="calibre21">
        x
       </code>
       variables in the global scope). With
       <code class="calibre21">
        extern
       </code>
       , you can make variables globally accessible from multiple source files.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0132">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           It is not recommended to use global variables at all. They are confusing and error-prone, especially in large programs. Use them judiciously!
          </i>
         </p>
         <p class="calibre25" id="c11-para-0133">
          <i class="calibre18">
           The only exception are global constants. Don't define the same constants all over the place: define them once and use them from everywhere
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-135" class="calibre2">
     <span class="calibre" id="c11-sec-0038">
     </span>
     <h2 class="calibre6" id="head-2-135">
      HEADER FILES
     </h2>
     <p class="calibre13" id="c11-para-0134">
      Before the introduction of C++20's modules,
      <i class="calibre18">
       header files
      </i>
      , also called
      <i class="calibre18">
       headers
      </i>
      , were used as a mechanism for providing the interface to a subsystem or piece of code. The most common use of headers is to declare functions that will be defined elsewhere. A
      <i class="calibre18">
       declaration
      </i>
      tells the compiler that an entity (function, variable, etc.) with a certain name exists. For functions, a declaration specifies how a function is called, declaring the number and types of parameters and the function's return type. A
      <i class="calibre18">
       definition
      </i>
      also tells the compiler that an entity with a certain name exists, but also defines the entity itself. For functions, a definition contains the actual code for the function. All definitions are declarations, but not all declarations are definitions. Declarations, and thus also class definitions, which are declarations, see
      <a class="calibre5" href="c08.xhtml">
       Chapter 8
      </a>
      , “Gaining Proficiency with Classes and Objects,” usually go into header files, typically with extension
      <code class="calibre21">
       .h
      </code>
      . Definitions, including definitions of non-inline class members, usually go into source files, typically with extension
      <code class="calibre21">
       .cpp
      </code>
      . This book uses modules everywhere, but this section briefly discusses a few trickier aspects of using header files, such as avoiding duplicate definitions and circular dependencies, because you will encounter these in legacy code bases.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0039">
      </span>
      <h3 class="calibre27" id="head-3-252">
       One Definition Rule (ODR)
      </h3>
      <p class="calibre13" id="c11-para-0135">
       A single translation unit can have exactly one definition of a variable, function, class type, enumeration type, concept, or template. For some types, multiple declarations are allowed, but not multiple definitions. Furthermore, exactly one definition of non-inline functions and non-inline variables is allowed in the entire program.
      </p>
      <p class="calibre13" id="c11-para-0136">
       With header files, it's easy to violate the one definition rule, resulting in duplicate definitions. The next section discusses how such duplicate definitions through header files can be avoided.
      </p>
      <p class="calibre13" id="c11-para-0137">
       Between modules, it's harder to violate the one definition rule, as each module is much better isolated from other modules. A major reason for this is that an entity in a module that is not exported from
       <span aria-label="442" class="calibre20" epub:type="pagebreak" id="Page_442" role="doc-pagebreak">
       </span>
       that module has module linkage and thus is inaccessible from code in other modules. That is, multiple modules can define their own local non-exported entities with the same name without any problem. On the other hand, in non-modular source files, local entities have external linkage by default. Of course, within a module itself, you still need to make sure you don't violate the one definition rule.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0040">
      </span>
      <h3 class="calibre27" id="head-3-253">
       Duplicate Definitions
      </h3>
      <p class="calibre13" id="c11-para-0138">
       Suppose
       <code class="calibre21">
        A.h
       </code>
       includes
       <code class="calibre21">
        Logger.h
       </code>
       , defining a
       <code class="calibre21">
        Logger
       </code>
       class, and
       <code class="calibre21">
        B.h
       </code>
       also includes
       <code class="calibre21">
        Logger.h
       </code>
       . If you have a source file called
       <code class="calibre21">
        App.cpp
       </code>
       , which includes both
       <code class="calibre21">
        A.h
       </code>
       and
       <code class="calibre21">
        B.h
       </code>
       , you end up with
       <i class="calibre18">
        duplicate definitions
       </i>
       of the
       <code class="calibre21">
        Logger
       </code>
       class because the
       <code class="calibre21">
        Logger.h
       </code>
       header is included through
       <code class="calibre21">
        A.h
       </code>
       and
       <code class="calibre21">
        B.h
       </code>
       .
      </p>
      <p class="calibre13">
       This problem of duplicate definitions can be avoided with a mechanism known as
       <i class="calibre18">
        include guards
       </i>
       , also known as
       <i class="calibre18">
        header guards
       </i>
       . The following code snippet shows the
       <code class="calibre21">
        Logger.h
       </code>
       header with include guards. At the beginning of each header file, the
       <code class="calibre21">
        #ifndef
       </code>
       directive checks whether a certain key has
       <i class="calibre18">
        not
       </i>
       been defined. If the key has been defined, the compiler skips to the matching
       <code class="calibre21">
        #endif
       </code>
       , which is usually placed at the end of the file. If the key has
       <i class="calibre18">
        not
       </i>
       been defined, the file proceeds to define the key so that a subsequent include of the same file will be skipped.
      </p>
      <pre class="calibre26" id="c11-code-0054"><code class="calibre21"><b class="calibre14">#ifndef LOGGER_H</b></code>
<code class="calibre21"><b class="calibre14">#define LOGGER_H</b></code>
<code class="calibre21"> </code>
<code class="calibre21">class Logger { <span class="color">/* … */</span> };</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">#endif</b> <span class="color">// LOGGER_H</span></code></pre>
      <p class="calibre13">
       Alternatively, nearly all compilers these days support the
       <code class="calibre21">
        #pragma once
       </code>
       directive, which replaces include guards. Placing a
       <code class="calibre21">
        #pragma once
       </code>
       at the beginning of a header file makes sure it'll be included only once and hence avoids duplicate definitions resulting from including the header multiple times. Here's an example:
      </p>
      <pre class="calibre26" id="c11-code-0055"><code class="calibre21"><b class="calibre14">#pragma once</b></code>
<code class="calibre21"> </code>
<code class="calibre21">class Logger { <span class="color">/* … */</span> };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0142">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Include guards and
          </i>
          <code class="calibre21">
           #pragma once
          </code>
          <i class="calibre18">
           directives prevent only one definition rule violations when a header file is included multiple times within a single translation unit, not across multiple translation units.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0042">
      </span>
      <h3 class="calibre27" id="head-3-254">
       Circular Dependencies
      </h3>
      <p class="calibre13" id="c11-para-0143">
       Another tool for avoiding problems with header files is
       <i class="calibre18">
        forward declarations
       </i>
       . If you need to refer to a class but you cannot include its header file (for example, because it relies heavily on the class you are writing), you can tell the compiler that such a class exists without providing a formal definition through the
       <code class="calibre21">
        #include
       </code>
       mechanism. Of course, you cannot actually use the class in the code because the compiler knows nothing about it, except that the named class will exist after everything is linked together. However, you can still make use of pointers and references to forward-declared classes in your code. You can also declare functions that return such forward-declared classes by value or that
       <span aria-label="443" class="calibre20" epub:type="pagebreak" id="Page_443" role="doc-pagebreak">
       </span>
       have such forward-declared classes as pass-by-value function parameters. Of course, both the code defining the function and any code calling the function will need to include the right header files that properly define the forward-declared classes.
      </p>
      <p class="calibre13">
       For example, assume that the
       <code class="calibre21">
        Logger
       </code>
       class uses another class called
       <code class="calibre21">
        Preferences
       </code>
       that keeps track of user settings. The
       <code class="calibre21">
        Preferences
       </code>
       class may in turn use the
       <code class="calibre21">
        Logger
       </code>
       class, so you have a
       <i class="calibre18">
        circular dependency
       </i>
       that cannot be resolved with include guards. You need to make use of forward declarations in such cases. In the following code, the
       <code class="calibre21">
        Logger.h
       </code>
       header file uses a forward declaration for the
       <code class="calibre21">
        Preferences
       </code>
       class and subsequently refers to the
       <code class="calibre21">
        Preferences
       </code>
       class without including its header file:
      </p>
      <pre class="calibre26" id="c11-code-0056"><code class="calibre21">#pragma once</code>
<code class="calibre21"> </code>
<code class="calibre21">#include &lt;string_view&gt;</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">class Preferences;</b>  <span class="color">// forward declaration</span></code>
<code class="calibre21"> </code>
<code class="calibre21">class Logger</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setPreferences(const Preferences&amp; preferences);</code>
<code class="calibre21">        void logError(std::string_view error);</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c11-para-0145">
       It's recommended to use forward declarations as much as possible in your header files instead of including other headers. This can reduce your compilation and recompilation times, because it breaks dependencies of your header file on other headers. Of course, your implementation file needs to include the correct headers for types that you've forward-declared; otherwise, it won't compile.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-255">
       Querying Existence of Headers
      </h3>
      <p class="calibre13">
       To query whether a certain header file exists, use the
       <code class="calibre21">
        __has_include("filename")
       </code>
       or
       <code class="calibre21">
        __has_include(&lt;filename&gt;)
       </code>
       preprocessor constant expressions. These evaluate to 1 if the header file exists, 0 if it doesn't exist. For example, before the
       <code class="calibre21">
        &lt;optional&gt;
       </code>
       header file was fully approved for C++17, some compilers already had a preliminary version in
       <code class="calibre21">
        &lt;experimental/optional&gt;
       </code>
       . You could use
       <code class="calibre21">
        __has_include()
       </code>
       to check which of the two header files was available on your system:
      </p>
      <pre class="calibre26" id="c11-code-0057"><code class="calibre21">#if __has_include(&lt;optional&gt;)</code>
<code class="calibre21">    #include &lt;optional&gt;</code>
<code class="calibre21">#elif __has_include(&lt;experimental/optional&gt;)</code>
<code class="calibre21">    #include &lt;experimental/optional&gt;</code>
<code class="calibre21">#endif</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0044">
      </span>
      <h3 class="calibre27" id="head-3-256">
       Module Import Declarations
      </h3>
      <p class="calibre13" id="c11-para-0147">
       Header files should not contain any module
       <code class="calibre21">
        import
       </code>
       declarations. The standard mandates that module
       <code class="calibre21">
        import
       </code>
       declarations must be at the beginning of a file before any other declarations and must not be coming from header inclusions or preprocessor macro expansions. This makes it easier on build systems to discover module dependencies, which are then used to determine the order modules need to be built.
      </p>
     </section>
    </section>
    <span aria-label="444" class="calibre20" epub:type="pagebreak" id="Page_444" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-136" class="calibre2">
     <span class="calibre" id="c11-sec-0045">
     </span>
     <h2 class="calibre6" id="head-2-136">
      FEATURE-TEST MACROS FOR CORE LANGUAGE FEATURES
     </h2>
     <p class="calibre13">
      You can use
      <i class="calibre18">
       feature-test macros
      </i>
      to detect which core language features are supported by a compiler. All these macros start with either
      <code class="calibre21">
       __cpp_
      </code>
      or
      <code class="calibre21">
       __has_cpp_
      </code>
      . The following are some examples. Consult your favorite C++ reference for a complete list of all possible core language feature-test macros.
     </p>
     <ul class="check" id="c11-list-0005">
      <li class="calibre9" id="c11-li-0024">
       <code class="calibre21">
        __cpp_range_based_for
       </code>
      </li>
      <li class="calibre9" id="c11-li-0025">
       <code class="calibre21">
        __cpp_binary_literals
       </code>
      </li>
      <li class="calibre9" id="c11-li-0026">
       <code class="calibre21">
        __cpp_char8_t
       </code>
      </li>
      <li class="calibre9" id="c11-li-0027">
       <code class="calibre21">
        __cpp_generic_lambdas
       </code>
      </li>
      <li class="calibre9" id="c11-li-0028">
       <code class="calibre21">
        __cpp_consteval
       </code>
      </li>
      <li class="calibre9" id="c11-li-0029">
       <code class="calibre21">
        __cpp_coroutines
       </code>
      </li>
      <li class="calibre9" id="c11-li-0030">
       …
      </li>
      <li class="calibre9" id="c11-li-0031">
       <code class="calibre21">
        __has_cpp_attribute(
        <i class="calibre18">
         [attribute_name]
        </i>
        )
       </code>
      </li>
      <li class="calibre9" id="c11-li-0032">
       …
      </li>
     </ul>
     <p class="calibre13" id="c11-para-0149">
      The value of these macros is a number representing the month and year when a specific feature was added or updated. The date is formatted as
      <code class="calibre21">
       YYYYMM
      </code>
      . For example, the value of
      <code class="calibre21">
       __cpp_binary_literals
      </code>
      is 201304, i.e., April 2013, which is the date when binary literals were introduced. As another example, the value of
      <code class="calibre21">
       __has_cpp_attribute(nodiscard)
      </code>
      can be 201603, i.e., March 2016, which is the date when the
      <code class="calibre21">
       [[nodiscard]]
      </code>
      attribute was first introduced. Or it can be 201907, i.e., July 2019, which is the date when the attribute was updated to allow specifying a reason such as
      <code class="calibre21">
       [[nodiscard("Reason")]]
      </code>
      .
     </p>
     <p class="calibre13">
      All these core language feature-test macros are available without having to include any specific header. Here is an example use:
     </p>
     <pre class="calibre26" id="c11-code-0058"><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">#ifdef __cpp_range_based_for</code>
<code class="calibre21">    println("Range-based for loops are supported!");</code>
<code class="calibre21">#else</code>
<code class="calibre21">    println("Bummer! Range-based for loops are NOT supported!");</code>
<code class="calibre21">#endif</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      <a class="calibre5" href="c16.xhtml">
       Chapter 16
      </a>
      , “Overview of the C++ Standard Library,” explains that there are similar feature-test macros for Standard Library features.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c11-para-0152">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          You will rarely need these feature-test macros, unless you are writing cross-platform and cross-compiler code. In that case, you might want to know if certain functionality is supported by a given compiler so that you can provide fallback code in case a feature is missing
         </i>
         .
         <a class="calibre5" href="c34.xhtml">
          <i class="calibre18">
           Chapter 34
          </i>
         </a>
         <i class="calibre18">
          , “Developing Cross-Platform and Cross-Language Applications,” discusses cross-platform development
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <span aria-label="445" class="calibre20" epub:type="pagebreak" id="Page_445" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-137" class="calibre2">
     <span class="calibre" id="c11-sec-0047">
     </span>
     <h2 class="calibre6" id="head-2-137">
      THE STATIC KEYWORD
     </h2>
     <p class="calibre13" id="c11-para-0153">
      There are several uses of the keyword
      <code class="calibre21">
       static
      </code>
      in C++, all seemingly unrelated. Part of the motivation for “overloading” the keyword was attempting to avoid having to introduce new keywords into the language. One use of the keyword is discussed earlier in this chapter in the context of linkage. Other uses are discussed in this section.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0048">
      </span>
      <h3 class="calibre27" id="head-3-257">
       static Data Members and Member Functions
      </h3>
      <p class="calibre13" id="c11-para-0154">
       You can declare
       <code class="calibre21">
        static
       </code>
       data members and member functions of classes.
       <code class="calibre21">
        static
       </code>
       data members, unlike non-
       <code class="calibre21">
        static
       </code>
       data members, are not part of each object. Instead, there is only one copy of the data member, which exists outside any objects of that class.
      </p>
      <p class="calibre13" id="c11-para-0155">
       <code class="calibre21">
        static
       </code>
       member functions are similarly at the class level instead of the object level. A
       <code class="calibre21">
        static
       </code>
       member function does not execute in the context of a specific object; hence, it does not have an implicit
       <code class="calibre21">
        this
       </code>
       pointer. This also means that
       <code class="calibre21">
        static
       </code>
       member functions cannot be marked as
       <code class="calibre21">
        const
       </code>
       .
      </p>
      <p class="calibre13" id="c11-para-0156">
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       provides examples of both
       <code class="calibre21">
        static
       </code>
       data members and member functions.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0049">
      </span>
      <h3 class="calibre27" id="head-3-258">
       static Variables in Functions
      </h3>
      <p class="calibre13">
       Another use of the
       <code class="calibre21">
        static
       </code>
       keyword in C++ is to create variables that retain their values between exits and entrances to their scope. For example, a
       <code class="calibre21">
        static
       </code>
       local variable inside a function is like a global variable that is accessible only from within that function. One common use of
       <code class="calibre21">
        static
       </code>
       variables is to “remember” whether a particular initialization has been performed for a certain function. For example, code that employs this technique might look something like this:
      </p>
      <pre class="calibre26" id="c11-code-0059"><code class="calibre21">void performTask()</code>
<code class="calibre21">{</code>
<code class="calibre21">    static bool initialized { false };</code>
<code class="calibre21">    if (!initialized) {</code>
<code class="calibre21">        println("initializing");</code>
<code class="calibre21">        <span class="color">// Perform initialization.</span></code>
<code class="calibre21">        initialized = true;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Perform the desired task.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       However,
       <code class="calibre21">
        static
       </code>
       variables can be confusing, and there are usually better ways to structure your code so that you can avoid them. In this case, you might want to write a class in which the constructor performs the required initialization.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0160">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Avoid using stand-alone
          </i>
          <code class="calibre21">
           static
          </code>
          <i class="calibre18">
           variables. Maintain state within an object instead.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <span aria-label="446" class="calibre20" epub:type="pagebreak" id="Page_446" role="doc-pagebreak">
       </span>
       Sometimes, however, they can be useful. One example is for implementing the Meyers’ singleton design pattern, as explained in
       <a class="calibre5" href="c33.xhtml">
        Chapter 33
       </a>
       , “Applying Design Patterns.”
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0162">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The implementation of
          </i>
          <code class="calibre21">
           performTask()
          </code>
          <i class="calibre18">
           is not thread-safe; it contains a race condition. In a multithreaded environment, you need to use atomics or other mechanisms for synchronization of multiple threads. Multithreading is discussed in detail in
           <a class="calibre5" href="c27.xhtml">
            Chapter 27
           </a>
           , “Multithreaded Programming with C++.”
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0052">
      </span>
      <h3 class="calibre27" id="head-3-259">
       Order of Initialization of Nonlocal Variables
      </h3>
      <p class="calibre13">
       Before leaving the topic of
       <code class="calibre21">
        static
       </code>
       variables, consider the order of initialization of such variables. All global and
       <code class="calibre21">
        static
       </code>
       variables in a program are initialized before
       <code class="calibre21">
        main()
       </code>
       begins. The variables in a given source file are initialized in the order they appear in the source file. For example, in the following file,
       <code class="calibre21">
        Demo::x
       </code>
       is guaranteed to be initialized before
       <code class="calibre21">
        y
       </code>
       :
      </p>
      <pre class="calibre26" id="c11-code-0060"><code class="calibre21">class Demo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        static int x;</code>
<code class="calibre21">};</code>
<code class="calibre21">int Demo::x { 3 };</code>
<code class="calibre21">int y { 4 };</code></pre>
      <p class="calibre13">
       However, C++ provides no specifications or guarantees about the initialization ordering of nonlocal variables in different source files. If you have a global variable
       <code class="calibre21">
        x
       </code>
       in one source file and a global variable
       <code class="calibre21">
        y
       </code>
       in another, you have no way of knowing which will be initialized first. Normally, this lack of specification isn't cause for concern. However, it can be problematic if one global or
       <code class="calibre21">
        static
       </code>
       variable depends on another. Recall that initialization of objects implies running their constructors. The constructor of one global object might access another global object, assuming that it is already constructed. If these two global objects are declared in two different source files, you cannot count on one being constructed before the other, and you cannot control the order of initialization. This order might not be the same for different compilers or even different versions of the same compiler, and the order might even change when you simply add another file to your project.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0165">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Initialization order of nonlocal variables in different source files is undefined
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0054">
      </span>
      <h3 class="calibre27" id="head-3-260">
       Order of Destruction of Nonlocal Variables
      </h3>
      <p class="calibre13" id="c11-para-0166">
       Nonlocal variables are destroyed in the reverse order they were initialized. Nonlocal variables in different source files are initialized in an undefined order, which means that the order of destruction is also undefined.
      </p>
     </section>
    </section>
    <span aria-label="447" class="calibre20" epub:type="pagebreak" id="Page_447" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-138" class="calibre2">
     <span class="calibre" id="c11-sec-0055">
     </span>
     <h2 class="calibre6" id="head-2-138">
      C-STYLE VARIABLE-LENGTH ARGUMENT LISTS
     </h2>
     <p class="calibre13" id="c11-para-0167">
      In legacy code, you might come across the use of C-style variable-length argument lists. In new code, you should avoid using these and instead use variadic templates for type-safe variable-length argument lists, which are covered in
      <a class="calibre5" href="c26.xhtml">
       Chapter 26
      </a>
      , “Advanced Templates.”
     </p>
     <p class="calibre13">
      So that you are aware of C-style variable-length argument lists, consider the C function
      <code class="calibre21">
       printf()
      </code>
      from
      <code class="calibre21">
       &lt;cstdio&gt;
      </code>
      . You can call it with any number of arguments:
     </p>
     <pre class="calibre26" id="c11-code-0061"><code class="calibre21">printf("int %d\n", 5);</code>
<code class="calibre21">printf("String %s and int %d\n", "hello", 5);</code>
<code class="calibre21">printf("Many ints: %d, %d, %d, %d, %d\n", 1, 2, 3, 4, 5);</code></pre>
     <p class="calibre13">
      C/C++ provides the syntax and some utility macros for writing your own functions with a variable number of arguments. These functions usually look a lot like
      <code class="calibre21">
       printf()
      </code>
      . For example, suppose you want to write a quick-and-dirty debug function that prints strings to
      <code class="calibre21">
       stderr
      </code>
      if a debug flag is set but does nothing if the debug flag is not set. Just like
      <code class="calibre21">
       printf()
      </code>
      , this function should be able to print strings with an arbitrary number of arguments and arbitrary types of arguments. A simple implementation looks as follows:
     </p>
     <pre class="calibre26" id="c11-code-0062"><code class="calibre21">import std;</code>
<code class="calibre21">#include &lt;cstdarg&gt;</code>
<code class="calibre21">#include &lt;cstdio&gt;</code>
<code class="calibre21"> </code>
<code class="calibre21">bool debug { false };</code>
<code class="calibre21"> </code>
<code class="calibre21">void debugOut(const char* str, …)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (debug) {</code>
<code class="calibre21">        va_list ap;</code>
<code class="calibre21">        va_start(ap, str);</code>
<code class="calibre21">        vfprintf(stderr, str, ap);</code>
<code class="calibre21">        va_end(ap);</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13" id="c11-para-0170">
      The code uses
      <code class="calibre21">
       va_list()
      </code>
      ,
      <code class="calibre21">
       va_start()
      </code>
      , and
      <code class="calibre21">
       va_end()
      </code>
      , which are macros defined in
      <code class="calibre21">
       &lt;cstdarg&gt;
      </code>
      and thus require an explicit
      <code class="calibre21">
       #include &lt;cstdarg&gt;
      </code>
      , as
      <code class="calibre21">
       import std;
      </code>
      does not export any macros. Similarly,
      <code class="calibre21">
       stderr
      </code>
      is a macro defined in
      <code class="calibre21">
       &lt;cstdio&gt;
      </code>
      requiring an explicit
      <code class="calibre21">
       #include &lt;cstdio&gt;
      </code>
      .
     </p>
     <p class="calibre13" id="c11-para-0171">
      The prototype for
      <code class="calibre21">
       debugOut()
      </code>
      contains one typed and named parameter
      <code class="calibre21">
       str
      </code>
      , followed by
      <code class="calibre21">
       …
      </code>
      (ellipses). They stand for any number and type of arguments. To access these arguments, you must declare a variable of type
      <code class="calibre21">
       va_list
      </code>
      and initialize it with a call to
      <code class="calibre21">
       va_start
      </code>
      . The second parameter to
      <code class="calibre21">
       va_start()
      </code>
      must be the rightmost
      <i class="calibre18">
       named
      </i>
      variable in the parameter list. All functions with variable-length argument lists require at least one named parameter. The
      <code class="calibre21">
       debugOut()
      </code>
      function simply passes this list to
      <code class="calibre21">
       vfprintf()
      </code>
      (a standard function in
      <code class="calibre21">
       &lt;cstdio&gt;
      </code>
      ). After the call to
      <code class="calibre21">
       vfprintf()
      </code>
      returns,
      <code class="calibre21">
       debugOut()
      </code>
      calls
      <code class="calibre21">
       va_end()
      </code>
      to terminate the access of the variable argument list. You must always call
      <code class="calibre21">
       va_end()
      </code>
      after calling
      <code class="calibre21">
       va_start()
      </code>
      to ensure that the function ends with the stack in a consistent state.
     </p>
     <p class="calibre13">
      You can use the function in the following way:
     </p>
     <pre class="calibre26" id="c11-code-0063"><code class="calibre21">debug = true;</code>
<code class="calibre21">debugOut("int %d\n", 5);</code>
<span aria-label="448" class="calibre20" epub:type="pagebreak" id="Page_448" role="doc-pagebreak"></span><code class="calibre21">debugOut("String %s and int %d\n", "hello", 5);</code>
<code class="calibre21">debugOut("Many ints: %d, %d, %d, %d, %d\n", 1, 2, 3, 4, 5);</code></pre>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0056">
      </span>
      <h3 class="calibre27" id="head-3-261">
       Accessing the Arguments
      </h3>
      <p class="calibre13" id="c11-para-0173">
       If you want to access the actual arguments yourself, you can use
       <code class="calibre21">
        va_arg()
       </code>
       to do so. It accepts a
       <code class="calibre21">
        va_list
       </code>
       as first argument, and the type of the argument to interpret. Unfortunately, there is no way to know what the end of the argument list is unless you provide an explicit way of doing so. For example, you can make the first parameter a count of the number of parameters. Or, in the case where you have a set of pointers, you may require the last pointer to be
       <code class="calibre21">
        nullptr
       </code>
       . There are many ways, but they are all burdensome to the programmer.
      </p>
      <p class="calibre13">
       The following example demonstrates the technique where the caller specifies in the first named parameter how many arguments are provided. The function accepts any number of
       <code class="calibre21">
        int
       </code>
       s and prints them out.
      </p>
      <pre class="calibre26" id="c11-code-0064"><code class="calibre21">void printInts(unsigned num, …)</code>
<code class="calibre21">{</code>
<code class="calibre21">    va_list ap;</code>
<code class="calibre21">    va_start(ap, num);</code>
<code class="calibre21">    for (unsigned i { 0 }; i &lt; num; ++i) {</code>
<code class="calibre21">        int temp { va_arg(ap, int) };</code>
<code class="calibre21">        print("{} ", temp);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    va_end(ap);</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You can call
       <code class="calibre21">
        printInts()
       </code>
       as follows. Note that the first parameter specifies how many integers will follow.
      </p>
      <pre class="calibre26" id="c11-code-0065"><code class="calibre21">printInts(5, 5, 4, 3, 2, 1);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c11-sec-0057">
      </span>
      <h3 class="calibre27" id="head-3-262">
       Why You Shouldn't Use C-Style Variable-Length Argument Lists
      </h3>
      <p class="calibre13">
       Accessing C-style variable-length argument lists is not very safe. There are several risks, as you can see from the
       <code class="calibre21">
        printInts()
       </code>
       function.
      </p>
      <ul class="check" id="c11-list-0006">
       <li class="calibre9" id="c11-li-0033">
        You don't know the number of parameters. In the case of
        <code class="calibre21">
         printInts()
        </code>
        , you must trust the caller to pass the right number of arguments as the first argument. In the case of
        <code class="calibre21">
         debugOut()
        </code>
        , you must trust the caller to pass the same number of arguments after the
        <code class="calibre21">
         str
        </code>
        string as there are replacement fields in the string.
       </li>
       <li class="calibre9" id="c11-li-0034">
        You don't know the types of the arguments.
        <code class="calibre21">
         va_arg()
        </code>
        takes a type, which it uses to interpret the value in its current spot. However, you can tell
        <code class="calibre21">
         va_arg()
        </code>
        to interpret the value as any type. There is no way for it to verify the correct type.
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c11-para-0177">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Avoid using C-style variable-length argument lists. It is preferable to pass in an
          </i>
          <code class="calibre21">
           std::array
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           vector
          </code>
          <i class="calibre18">
           of values, to use initializer lists described in
           <a class="calibre5" href="c01_split_000.xhtml">
            Chapter 1
           </a>
           , or to use variadic templates for type-safe variable-length argument lists, as described in
           <a class="calibre5" href="c26.xhtml">
            Chapter 26
           </a>
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <span aria-label="449" class="calibre20" epub:type="pagebreak" id="Page_449" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-139" class="calibre2">
     <span class="calibre" id="c11-sec-0059">
     </span>
     <h2 class="calibre6" id="head-2-139">
      SUMMARY
     </h2>
     <p class="calibre13" id="c11-para-0178">
      This chapter started with details on authoring and consuming modules and discussed a few trickier aspects of using old-style header files. You also learned about preprocessor directives, preprocessor macros, details of linkage, the one definition rule, and the different uses of the
      <code class="calibre21">
       static
      </code>
      and
      <code class="calibre21">
       extern
      </code>
      keywords. The chapter finished with a discussion on how to write C-style variable-length argument lists.
     </p>
     <p class="calibre13" id="c11-para-0179">
      Preprocessor directives and C-style variable-length argument lists are important to understand, because you might encounter them in legacy code bases. However, they should be avoided in any newly written code.
     </p>
     <p class="calibre13" id="c11-para-0180">
      The next chapter starts a discussion on templates allowing you to write generic code.
     </p>
    </section>
    <section aria-labelledby="head-2-140" class="calibre2">
     <span class="calibre" id="c11-sec-0060">
     </span>
     <h2 class="calibre6" id="head-2-140">
      EXERCISES
     </h2>
     <p class="calibre13" id="c11-para-0181">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c11-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c11-ex-0001">
        <b class="calibre14">
         Exercise 11-1:
        </b>
        Write a single-file module called
        <code class="calibre21">
         simulator
        </code>
        containing two classes,
        <code class="calibre21">
         CarSimulator
        </code>
        and
        <code class="calibre21">
         BikeSimulator
        </code>
        , in a
        <code class="calibre21">
         Simulator
        </code>
        namespace. The content of the classes is not important for these exercises. Just provide a default constructor that prints a message to the standard output. Test your code in a
        <code class="calibre21">
         main()
        </code>
        function.
       </li>
       <li class="calibre9" id="c11-ex-0002">
        <b class="calibre14">
         Exercise 11-2:
        </b>
        Take your solution from Exercise 11-1 and split the module into several files: a primary module interface file without any implementations and two module implementation files, one for the
        <code class="calibre21">
         CarSimulator
        </code>
        and one for the
        <code class="calibre21">
         BikeSimulator
        </code>
        class.
       </li>
       <li class="calibre9" id="c11-ex-0003">
        <b class="calibre14">
         Exercise 11-3:
        </b>
        Take your solution from Exercise 11-2 and convert it to use one primary module interface file and two module interface partition files, one for the
        <code class="calibre21">
         simulator:car
        </code>
        partition containing the
        <code class="calibre21">
         CarSimulator
        </code>
        class, and one for the
        <code class="calibre21">
         simulator:bike
        </code>
        partition containing the
        <code class="calibre21">
         BikeSimulator
        </code>
        class.
       </li>
       <li class="calibre9" id="c11-ex-0004">
        <b class="calibre14">
         Exercise 11-4:
        </b>
        Take your solution from Exercise 11-3 and add an implementation partition called
        <code class="calibre21">
         internals
        </code>
        , containing a helper function called
        <code class="calibre21">
         convertMilesToKm(double miles)
        </code>
        in the
        <code class="calibre21">
         Simulator
        </code>
        namespace. One mile is 1.6 kilometers. Add a member function to both the
        <code class="calibre21">
         CarSimulator
        </code>
        and
        <code class="calibre21">
         BikeSimulator
        </code>
        classes called
        <code class="calibre21">
         setOdometer(double miles)
        </code>
        , which uses the helper function to convert the given miles to kilometers and then prints it out to the standard output. Confirm in your
        <code class="calibre21">
         main()
        </code>
        function that the
        <code class="calibre21">
         setOdometer()
        </code>
        works on both classes. Also confirm that
        <code class="calibre21">
         main()
        </code>
        cannot call
        <code class="calibre21">
         convertMilesToKm()
        </code>
        .
       </li>
       <li class="calibre9" id="c11-ex-0005">
        <b class="calibre14">
         Exercise 11-5:
        </b>
        Write a source file containing a preprocessor identifier with the value 0 or 1. Use preprocessor directives to check the value of this identifier. If the value is 1, make the compiler output a warning. If it's 0, ignore it. If it's any other value, make the compiler generate an error.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
