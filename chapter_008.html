<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   4
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_007.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_009.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="_idContainer079">
    <h1 class="chapter-number" id="_idParaDest-89">
     <a id="_idTextAnchor089">
     </a>
     4
    </h1>
    <h1 id="_idParaDest-90">
     <a id="_idTextAnchor090">
     </a>
     QPainter and 2D Graphics
    </h1>
    <p>
     In this chapter, we will learn how to render 2D graphics on screen with Qt. Internally, Qt uses a low-level class called
     <strong class="source-inline">
      QPainter
     </strong>
     to render its widgets on the main window. Qt allows us to access and use the
     <strong class="source-inline">
      QPainter
     </strong>
     class for drawing vector graphics, text, 2D images, and even
     <span class="No-Break">
      3D graphics.
     </span>
    </p>
    <p>
     You can make use of the
     <strong class="source-inline">
      QPainter
     </strong>
     class to create your own custom widgets or to create programs that rely heavily on rendering computer graphics such as video games, photo editors, and 3D
     <span class="No-Break">
      modeling tools.
     </span>
    </p>
    <p>
     In this chapter, we’re going to cover the following
     <span class="No-Break">
      main topics:
     </span>
    </p>
    <ul>
     <li>
      Drawing basic shapes on
      <span class="No-Break">
       the screen
      </span>
     </li>
     <li>
      Exporting shapes to
      <strong class="bold">
       Scalable Vector Graphics
      </strong>
      (
      <span class="No-Break">
       <strong class="bold">
        SVG
       </strong>
      </span>
      <span class="No-Break">
       ) files
      </span>
     </li>
     <li>
      <span class="No-Break">
       <strong class="bold">
        Coordinate transformation
       </strong>
      </span>
     </li>
     <li>
      Displaying images
      <span class="No-Break">
       on screen
      </span>
     </li>
     <li>
      Applying image effects
      <span class="No-Break">
       to graphics
      </span>
     </li>
     <li>
      Creating a basic
      <span class="No-Break">
       paint program
      </span>
     </li>
     <li>
      Rendering a 2D canvas
      <span class="No-Break">
       in QML
      </span>
     </li>
    </ul>
    <h1 id="_idParaDest-91">
     <a id="_idTextAnchor091">
     </a>
     Technical requirements
    </h1>
    <p>
     The technical requirements for this chapter include
     <strong class="bold">
      Qt 6.6.1 MinGW 64-bit
     </strong>
     and
     <strong class="bold">
      Qt Creator 12.0.2
     </strong>
     . All the code used in this chapter can be downloaded from the following GitHub
     <span class="No-Break">
      repository:
     </span>
     <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04">
      <span class="No-Break">
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <h1 id="_idParaDest-92">
     <a id="_idTextAnchor092">
     </a>
     Drawing basic shapes on the screen
    </h1>
    <p>
     In this section, we will learn how to draw
     <a id="_idIndexMarker275">
     </a>
     simple vector shapes (a line, a rectangle, a circle, and so on) and display text on the main window using the
     <strong class="source-inline">
      QPainter
     </strong>
     class. We will also learn how to change the drawing style of these vector shapes using the
     <span class="No-Break">
      <strong class="source-inline">
       QPen
      </strong>
     </span>
     <span class="No-Break">
      class.
     </span>
    </p>
    <h2 id="_idParaDest-93">
     <a id="_idTextAnchor093">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s follow the steps listed here to display basic shapes in our
     <span class="No-Break">
      Qt window:
     </span>
    </p>
    <ol>
     <li>
      First, let’s create a new
      <strong class="bold">
       Qt Widgets
      </strong>
      <span class="No-Break">
       <strong class="bold">
        Application
       </strong>
      </span>
      <span class="No-Break">
       project.
      </span>
     </li>
     <li>
      Open up
      <strong class="source-inline">
       mainwindow.ui
      </strong>
      and remove the
      <strong class="source-inline">
       menuBar
      </strong>
      ,
      <strong class="source-inline">
       mainToolBar
      </strong>
      , and
      <strong class="source-inline">
       statusBar
      </strong>
      objects so that we get a clean, empty main window. Right-click on the bar widgets and select
      <strong class="bold">
       Remove Menu Bar
      </strong>
      from the
      <span class="No-Break">
       pop-up menu:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer058">
      <img alt="Figure 4.1 – Removing the menu bar from the main window" src="../images\image/B20976_04_001.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.1 – Removing the menu bar from the main window
    </p>
    <ol>
     <li value="3">
      Then, open up the
      <strong class="source-inline">
       mainwindow.h
      </strong>
      file and add the following code to include the
      <strong class="source-inline">
       QPainter
      </strong>
      <span class="No-Break">
       header file:
      </span>
      <pre class="source-code">
#include &lt;QMainWindow&gt;
#include &lt;QPainter&gt;</pre>
     </li>
     <li>
      Then, declare the
      <strong class="source-inline">
       paintEvent()
      </strong>
      event handler below the
      <span class="No-Break">
       class destructor:
      </span>
      <pre class="source-code">
public:
explicit MainWindow(QWidget *parent = 0);
~MainWindow();
<strong class="bold">virtual void paintEvent(QPaintEvent *event);</strong></pre>
     </li>
     <li>
      Next, open up the
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      file and define the
      <strong class="source-inline">
       paintEvent()
      </strong>
      <span class="No-Break">
       event handler:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {}</pre>
     </li>
     <li>
      After that, we will add
      <a id="_idIndexMarker276">
      </a>
      text to the screen using the
      <strong class="source-inline">
       QPainter
      </strong>
      class inside the
      <strong class="source-inline">
       paintEvent()
      </strong>
      event handler. We set the text font settings before drawing it on the screen at the position of
      <strong class="source-inline">
       (
      </strong>
      <span class="No-Break">
       <strong class="source-inline">
        20, 30)
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
QPainter textPainter;
textPainter.begin(this);
<strong class="bold">textPainter.setFont(QFont("Times", 14, QFont::Bold));</strong>
<strong class="bold">textPainter.drawText(QPoint(20, 30), "Testing");</strong>
textPainter.end();</pre>
     </li>
     <li>
      Then, we will draw a straight line that starts from
      <strong class="source-inline">
       (50, 60)
      </strong>
      and ends at
      <strong class="source-inline">
       (
      </strong>
      <span class="No-Break">
       <strong class="source-inline">
        100, 100)
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
QPainter linePainter;
linePainter.begin(this);
<strong class="bold">linePainter.drawLine(QPoint(50, 60), QPoint(100, 100));</strong>
linePainter.end();</pre>
     </li>
     <li>
      We can also easily draw a rectangle by calling the
      <strong class="source-inline">
       drawRect()
      </strong>
      function using a
      <strong class="source-inline">
       QPainter
      </strong>
      class. This time, however, we also apply a background pattern to the shape before
      <span class="No-Break">
       drawing it:
      </span>
      <pre class="source-code">
QPainter rectPainter;
rectPainter.begin(this);
<strong class="bold">rectPainter.setBrush(Qt::BDiagPattern);</strong>
<strong class="bold">rectPainter.drawRect(QRect(40, 120, 80, 30));</strong>
rectPainter.end();</pre>
     </li>
     <li>
      Next, declare a
      <strong class="source-inline">
       QPen
      </strong>
      class, set its color to
      <strong class="source-inline">
       red
      </strong>
      , and set its drawing style to
      <strong class="source-inline">
       Qt::DashDotLine
      </strong>
      . Then, apply
      <a id="_idIndexMarker277">
      </a>
      the
      <strong class="source-inline">
       QPen
      </strong>
      class to
      <strong class="source-inline">
       QPainter
      </strong>
      and draw an ellipse shape at
      <strong class="source-inline">
       (80, 200)
      </strong>
      with a horizontal radius of
      <strong class="source-inline">
       50
      </strong>
      and a vertical radius
      <span class="No-Break">
       of
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        20
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
QPen ellipsePen;
ellipsePen.setColor(Qt::red);
ellipsePen.setStyle(Qt::DashDotLine);
QPainter ellipsePainter;
ellipsePainter.begin(this);
ellipsePainter.setPen(ellipsePen);
ellipsePainter.drawEllipse(QPoint(80, 200), 50, 20);
ellipsePainter.end();</pre>
     </li>
     <li>
      We can also use the
      <strong class="source-inline">
       QPainterPath
      </strong>
      class to define a shape before passing it over to the
      <strong class="source-inline">
       QPainter
      </strong>
      class
      <span class="No-Break">
       for rendering:
      </span>
      <pre class="source-code">
QPainterPath rectPath;
rectPath.addRect(QRect(150, 20, 100, 50));
QPainter pathPainter;
pathPainter.begin(this);
pathPainter.setPen(QPen(Qt::red, 1, Qt::DashDotLine,
Qt::FlatCap, Qt::MiterJoin));
pathPainter.setBrush(Qt::yellow);
pathPainter.drawPath(rectPath);
pathPainter.end();</pre>
     </li>
     <li>
      You can also draw any
      <a id="_idIndexMarker278">
      </a>
      other shapes by using
      <strong class="source-inline">
       QPainterPath
      </strong>
      , such as
      <span class="No-Break">
       an ellipse:
      </span>
      <pre class="source-code">
QPainterPath ellipsePath;
ellipsePath.addEllipse(QPoint(200, 120), 50, 20);
QPainter ellipsePathPainter;
ellipsePathPainter.begin(this);
ellipsePathPainter.setPen(QPen(QColor(79, 106, 25), 5,
Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin));
ellipsePathPainter.setBrush(QColor(122, 163, 39));
ellipsePathPainter.drawPath(ellipsePath);
ellipsePathPainter.end();</pre>
     </li>
     <li>
      <strong class="source-inline">
       QPainter
      </strong>
      can also be used to draw an image file onto the screen. In the following example, we load an image file called
      <strong class="source-inline">
       tux.png
      </strong>
      and draw it on the screen at the
      <strong class="source-inline">
       (100,
      </strong>
      <span class="No-Break">
       <strong class="source-inline">
        150)
       </strong>
      </span>
      <span class="No-Break">
       position:
      </span>
      <pre class="source-code">
QImage image;
image.load("tux.png");
QPainter imagePainter(this);
imagePainter.begin(this);
imagePainter.drawImage(QPoint(100, 150), image);
imagePainter.end();</pre>
     </li>
     <li>
      The final result should look something
      <span class="No-Break">
       like this:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer059">
      <img alt="Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines" src="../images\image/B20976_04_002.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines
    </p>
    <h2 id="_idParaDest-94">
     <a id="_idTextAnchor094">
     </a>
     How it works...
    </h2>
    <p>
     If you want to draw something on screen using
     <strong class="source-inline">
      QPainter
     </strong>
     , all you need to do is tell it what type of graphics it should be drawing (as in text, a vector shape, an image, a polygon) with the desired position and size. The
     <strong class="source-inline">
      QPen
     </strong>
     class determines what the outline of the graphic should
     <a id="_idIndexMarker279">
     </a>
     look like, such as its color, line width, line style (solid, dashed, or dotted), cap style, join style, and so on. On the other hand,
     <strong class="source-inline">
      QBrush
     </strong>
     sets the style of the background of the graphics, such as the background color, pattern (solid color, gradient, dense brush, and crossing diagonal lines),
     <span class="No-Break">
      and pixmap.
     </span>
    </p>
    <p>
     The options for the graphics should be set before calling a
     <strong class="source-inline">
      draw
     </strong>
     function (such as
     <strong class="source-inline">
      drawLine()
     </strong>
     ,
     <strong class="source-inline">
      drawRect()
     </strong>
     , or
     <strong class="source-inline">
      drawEllipse()
     </strong>
     ). If your graphics do not appear on the screen and you see warnings such as
     <strong class="source-inline">
      QPainter::setPen: Painter not active
     </strong>
     and
     <strong class="source-inline">
      QPainter::setBrush: Painter not active
     </strong>
     appearing on the application output window in Qt Creator, it means that the
     <strong class="source-inline">
      QPainter
     </strong>
     class is not currently active and your program will not trigger its paint event. To solve this problem, set the main window as the parent of the
     <strong class="source-inline">
      QPainter
     </strong>
     class. Usually, if you’re writing code in the
     <strong class="source-inline">
      mainwindow.cpp
     </strong>
     file, all you need to do is to put
     <strong class="source-inline">
      this
     </strong>
     in the brackets when initializing
     <strong class="source-inline">
      QPainter
     </strong>
     . For example, note
     <span class="No-Break">
      the following:
     </span>
    </p>
    <pre class="source-code">
QPainter linePainter(this);</pre>
    <p>
     <strong class="source-inline">
      QImage
     </strong>
     can load images from both the computer directories and from the
     <span class="No-Break">
      program resources.
     </span>
    </p>
    <h2 id="_idParaDest-95">
     <a id="_idTextAnchor095">
     </a>
     There’s more…
    </h2>
    <p>
     Think of
     <strong class="source-inline">
      QPainter
     </strong>
     as a robot
     <a id="_idIndexMarker280">
     </a>
     with a pen and an empty canvas. You just have to tell the
     <a id="_idIndexMarker281">
     </a>
     robot what type of shape it should be drawing and its location on the canvas, then the robot will do its job based on
     <span class="No-Break">
      your description.
     </span>
    </p>
    <p>
     To make your life easier, the
     <strong class="source-inline">
      QPainter
     </strong>
     class also provides numerous functions, such as
     <strong class="source-inline">
      drawArc()
     </strong>
     ,
     <strong class="source-inline">
      drawEllipse()
     </strong>
     ,
     <strong class="source-inline">
      drawLine()
     </strong>
     ,
     <strong class="source-inline">
      drawRect()
     </strong>
     , and
     <strong class="source-inline">
      drawPie()
     </strong>
     , which allow you to easily render a predefined shape. In Qt, all the widget classes (including the main window) have an event handler called
     <strong class="source-inline">
      QWidget::paintEvent()
     </strong>
     . This event handler will be triggered whenever the operating system thinks that the main window should re-draw its widgets. Many things can lead to that decision, such as the main window being scaled, a widget changing its state (that is, a button being pressed), or functions such as
     <strong class="source-inline">
      repaint()
     </strong>
     or
     <strong class="source-inline">
      update()
     </strong>
     being invoked manually in the code. Different operating systems may behave differently when it comes to deciding whether or not to trigger the update event on the same set of conditions. If you’re making a program that requires continuous and consistent graphical updates, call
     <strong class="source-inline">
      repaint()
     </strong>
     or
     <strong class="source-inline">
      update()
     </strong>
     manually with
     <span class="No-Break">
      a timer.
     </span>
    </p>
    <h1 id="_idParaDest-96">
     <a id="_idTextAnchor096">
     </a>
     Exporting shapes to SVG files
    </h1>
    <p>
     SVG is an XML-based language for
     <a id="_idIndexMarker282">
     </a>
     describing 2D vector graphics. Qt provides classes for
     <a id="_idIndexMarker283">
     </a>
     saving vector shapes as SVG files. This feature can be used to create a simple vector graphics editor similar to Adobe Illustrator and Inkscape. In the next example, we will continue using the same project file from the
     <span class="No-Break">
      previous example.
     </span>
    </p>
    <h2 id="_idParaDest-97">
     <a id="_idTextAnchor097">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s learn how to create a simple program that displays SVG graphics
     <span class="No-Break">
      on screen:
     </span>
    </p>
    <ol>
     <li>
      First of all, let’s create a
      <a id="_idIndexMarker284">
      </a>
      menu bar by right-clicking the main window widget on the hierarchy window
      <a id="_idIndexMarker285">
      </a>
      and selecting the
      <strong class="bold">
       Create Menu Bar
      </strong>
      option from the pop-up menu. After that, add a
      <strong class="bold">
       File
      </strong>
      option to the menu bar and a
      <strong class="bold">
       Save as SVG
      </strong>
      action
      <span class="No-Break">
       underneath it:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer060">
      <img alt="Figure 4.3 – Create a Save as SVG option on the menu bar" src="../images\image/B20976_04_003.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.3 – Create a Save as SVG option on the menu bar
    </p>
    <ol>
     <li value="2">
      After that, you will see an item called
      <strong class="bold">
       actionSave_as_SVG
      </strong>
      in the
      <strong class="bold">
       Action Editor
      </strong>
      window at the bottom of the Qt Creator window. Right-click on the item and choose
      <strong class="bold">
       Go to slot…
      </strong>
      from the pop-up menu. A window will now appear, which carries a list of slots available for the particular action. Choose the default signal, which is called
      <strong class="source-inline">
       triggered()
      </strong>
      , and click the
      <span class="No-Break">
       <strong class="bold">
        OK
       </strong>
      </span>
      <span class="No-Break">
       button:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer061">
      <img alt="Figure 4.4 – Creating a slot function for the triggered() signal" src="../images\image/B20976_04_004.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.4 – Creating a slot function for the triggered() signal
    </p>
    <ol>
     <li value="3">
      Once you have clicked
      <a id="_idIndexMarker286">
      </a>
      the
      <strong class="bold">
       OK
      </strong>
      button, Qt Creator will switch over to the script editor. You will realize
      <a id="_idIndexMarker287">
      </a>
      that a slot called
      <strong class="source-inline">
       on_actionSave_as_SVG_triggered()
      </strong>
      has been automatically added to your main window class. At the bottom of your
      <strong class="source-inline">
       mainwindow.h
      </strong>
      file, you will see something
      <span class="No-Break">
       like this:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {}</pre>
     </li>
     <li>
      The preceding function is called when you click on the
      <strong class="bold">
       Save as SVG
      </strong>
      option from the menu bar. We will write our code within this function to save all the vector graphics into an SVG file. To do that, first of all, we need to include a class header called
      <strong class="source-inline">
       QSvgGenerator
      </strong>
      at the top of our source file. This header is very important as it’s required for generating SVG files. Then, we also need to include another class header called
      <strong class="source-inline">
       QFileDialog
      </strong>
      , which will be used to open the
      <span class="No-Break">
       save dialog:
      </span>
      <pre class="source-code">
#include &lt;QtSvg/QSvgGenerator&gt;
#include &lt;QFileDialog&gt;</pre>
     </li>
     <li>
      We also need to add the
      <strong class="source-inline">
       svg
      </strong>
      module to our project file,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
QT += core gui <strong class="bold">svg</strong></pre>
     </li>
     <li>
      Then, create a new function called
      <strong class="source-inline">
       paintAll()
      </strong>
      within the
      <strong class="source-inline">
       mainwindow.h
      </strong>
      file, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    virtual void paintEvent(QPaintEvent *event);
<strong class="bold">    void paintAll(QSvgGenerator *generator = 0);</strong></pre>
     </li>
     <li>
      After that, in the
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      file, move all the code from
      <strong class="source-inline">
       paintEvent()
      </strong>
      to the
      <strong class="source-inline">
       paintAll()
      </strong>
      function. Then, replace all the individual
      <strong class="source-inline">
       QPainter
      </strong>
      objects
      <a id="_idIndexMarker288">
      </a>
      with a single, unified
      <strong class="source-inline">
       QPainter
      </strong>
      for drawing all the
      <a id="_idIndexMarker289">
      </a>
      graphics. Also, call the
      <strong class="source-inline">
       begin()
      </strong>
      function before drawing anything and call the
      <strong class="source-inline">
       end()
      </strong>
      function after finishing drawing. The code should look
      <span class="No-Break">
       like this:
      </span>
      <pre class="source-code">
void MainWindow::paintAll(QSvgGenerator *generator) {
    <strong class="bold">QPainter painter;</strong>
<strong class="bold">     if (engine)</strong>
<strong class="bold">         painter.begin(engine);</strong>
<strong class="bold">     else</strong>
<strong class="bold">         painter.begin(this);</strong>
<strong class="bold">     painter.setFont(QFont("Times", 14, QFont::Bold));</strong>
<strong class="bold">     painter.drawText(QPoint(20, 30), "Testing");</strong>
<strong class="bold">     painter.drawLine(QPoint(50, 60), QPoint(100, 100));</strong>
<strong class="bold">     painter.setBrush(Qt::BDiagPattern);</strong>
<strong class="bold">     painter.drawRect(QRect(40, 120, 80, 30));</strong></pre>
     </li>
     <li>
      We go on to create
      <strong class="bold">
       ellipsePen
      </strong>
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <strong class="bold">
        rectPath
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
    QPen ellipsePen;
    ellipsePen.setColor(Qt::red);
ellipsePen.setStyle(Qt::DashDotLine);
    painter.setPen(ellipsePen);
    painter.drawEllipse(QPoint(80, 200), 50, 20);
    QPainterPath rectPath;
    rectPath.addRect(QRect(150, 20, 100, 50));
    painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine, Qt::FlatCap, Qt::MiterJoin));
    painter.setBrush(Qt::yellow);
    painter.drawPath(rectPath);</pre>
     </li>
     <li>
      Then, we go
      <a id="_idIndexMarker290">
      </a>
      on to create
      <strong class="source-inline">
       ellipsePath
      </strong>
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        image
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
    QPainterPath ellipsePath;
    ellipsePath.addEllipse(QPoint(200, 120), 50, 20);
    painter.setPen(QPen(QColor(79, 106, 25), 5, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin));
    painter.setBrush(QColor(122, 163, 39));
    painter.drawPath(ellipsePath);
    QImage image;
    image.load("tux.png");
    painter.drawImage(QPoint(100, 150), image);
    painter.end();
}</pre>
     </li>
     <li>
      Since we have
      <a id="_idIndexMarker291">
      </a>
      moved all the code from
      <strong class="source-inline">
       paintEvent()
      </strong>
      to
      <strong class="source-inline">
       paintAll()
      </strong>
      , we shall now call the
      <strong class="source-inline">
       paintAll()
      </strong>
      function inside
      <strong class="source-inline">
       paintEvent()
      </strong>
      ,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold">paintAll();</strong>
}</pre>
     </li>
     <li>
      Then, we will write the
      <a id="_idIndexMarker292">
      </a>
      code for exporting the graphics as an SVG file. The
      <a id="_idIndexMarker293">
      </a>
      code will be written inside the slot function called
      <strong class="source-inline">
       on_actionSave_as_SVG_triggered()
      </strong>
      , which was generated by Qt. We start by calling the save file dialog and obtain the directory path with the desired filename from
      <span class="No-Break">
       the user:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {
    <strong class="bold">QString filePath = QFileDialog::getSaveFileName(this, «Save SVG», «», «SVG files (*.svg)»);</strong>
<strong class="bold">    if (filePath == "")</strong>
<strong class="bold">        return;</strong>
}</pre>
     </li>
     <li>
      After that, create a
      <strong class="source-inline">
       QSvgGenerator
      </strong>
      object and save the graphics to an SVG file by passing the
      <strong class="source-inline">
       QSvgGenerator
      </strong>
      object to the
      <span class="No-Break">
       <strong class="source-inline">
        paintAll()
       </strong>
      </span>
      <span class="No-Break">
       function:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {
    QString filePath = QFileDialog::getSaveFileName(this, "Save
SVG", "", "SVG files (*.svg)");
    if (filePath == "")
        return;
    <strong class="bold">QSvgGenerator generator;</strong>
<strong class="bold">    generator.setFileName(filePath);</strong>
<strong class="bold">    generator.setSize(QSize(this-&gt;width(), this-&gt;height()));</strong>
<strong class="bold">    generator.setViewBox(QRect(0, 0, this-&gt;width(), this-&gt;height()));</strong>
<strong class="bold">    generator.setTitle("SVG Example");</strong>
<strong class="bold">    generator.setDescription("This SVG file is generated by Qt.");</strong>
<strong class="bold">    paintAll(&amp;generator);</strong>
}</pre>
     </li>
     <li>
      Now, compile and
      <a id="_idIndexMarker294">
      </a>
      run the program and you should be able to
      <a id="_idIndexMarker295">
      </a>
      export the graphics by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       Save
      </strong>
      <span class="No-Break">
       <strong class="bold">
        as SVG
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer062">
      <img alt="Figure 4.5 – Comparing the results between our program and the SVG file on a web browser" src="../images\image/B20976_04_005.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.5 – Comparing the results between our program and the SVG file on a web browser
    </p>
    <h2 id="_idParaDest-98">
     <a id="_idTextAnchor098">
     </a>
     How it works...
    </h2>
    <p>
     By default,
     <strong class="source-inline">
      QPainter
     </strong>
     will use the paint engine from its parent object to draw the graphics assigned to it. If you don’t assign any parent to
     <strong class="source-inline">
      QPainter
     </strong>
     , you can manually assign a paint engine to it, which is what we have done in
     <span class="No-Break">
      this example.
     </span>
    </p>
    <p>
     The reason why we placed the code into
     <strong class="source-inline">
      paintAll()
     </strong>
     is that we want to reuse the same code for two different purposes: for displaying the graphics on the window and exporting the graphics to an SVG
     <a id="_idIndexMarker296">
     </a>
     file. You can see that the default value of the generator variable in the
     <strong class="source-inline">
      paintAll()
     </strong>
     function is set to
     <strong class="source-inline">
      0
     </strong>
     , which means no
     <strong class="source-inline">
      QSvgGenerator
     </strong>
     object is required to run
     <a id="_idIndexMarker297">
     </a>
     the function unless specified. Later on, in the
     <strong class="source-inline">
      paintAll()
     </strong>
     function, we check whether the generator object exists. If it does exist, use it as the paint engine for the painter, as shown in the
     <span class="No-Break">
      following code:
     </span>
    </p>
    <pre class="source-code">
if (engine)
    painter.begin(engine);
else
    painter.begin(this);</pre>
    <p>
     Otherwise, pass the main window to the
     <strong class="source-inline">
      begin()
     </strong>
     function (since we’re writing the code in the
     <strong class="source-inline">
      mainwindow.cpp
     </strong>
     file, we can directly use this to refer to the main window’s pointer) so that it will use the paint engine of the main window itself, which means the graphics will be drawn onto the surface of the main window. In this example, it’s required to use a single
     <strong class="source-inline">
      QPainter
     </strong>
     object to save the graphics into the SVG file. If you use multiple
     <strong class="source-inline">
      QPainter
     </strong>
     objects, the resulting SVG file will contain multiple XML header definitions, and thus the file will be deemed to be invalid by any graphics editor software
     <span class="No-Break">
      out there.
     </span>
    </p>
    <p>
     <strong class="source-inline">
      QFileDialog::getSaveFileName()
     </strong>
     will open up the native save file dialog for the user to choose the save directory and set a desired filename. Once the user is done with that, the full path will be returned as a string, and we will be able to pass that information to the
     <strong class="source-inline">
      QSvgGenerator
     </strong>
     object to export
     <span class="No-Break">
      the graphics.
     </span>
    </p>
    <p>
     Notice that in the previous screenshot, the penguin in the SVG file has been cropped. This is because the canvas size of the SVG was set to follow the size of the main window. To help the poor penguin get its body back, scale the window bigger before exporting the
     <span class="No-Break">
      SVG file.
     </span>
    </p>
    <h2 id="_idParaDest-99">
     <a id="_idTextAnchor099">
     </a>
     There’s more…
    </h2>
    <p>
     SVG defines the graphics in XML format. Since it is a form of vector graphics, SVG files do not lose any quality if they are
     <a id="_idIndexMarker298">
     </a>
     zoomed in on or resized. The SVG format not only allows you to store vector graphics in
     <a id="_idIndexMarker299">
     </a>
     the working file, but it also allows you to store raster graphics and text, which is more or less similar to Adobe Illustrator’s format. The SVG also allows you to group, style, transform, and composite graphical objects into previously
     <span class="No-Break">
      rendered objects.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     You can check out the full specification of SVG graphics
     <span class="No-Break">
      at
     </span>
     <a href="https://www.w3.org/TR/SVG">
      <span class="No-Break">
       https://www.w3.org/TR/SVG
      </span>
     </a>
     <span class="No-Break">
      <span class="P---Callout-Char">
       .
      </span>
     </span>
    </p>
    <h1 id="_idParaDest-100">
     <a id="_idTextAnchor100">
     </a>
     Coordinate transformation
    </h1>
    <p>
     In this example, we will learn
     <a id="_idIndexMarker300">
     </a>
     how to use coordinate transformation and a timer to create a real-time
     <span class="No-Break">
      clock display.
     </span>
    </p>
    <h2 id="_idParaDest-101">
     <a id="_idTextAnchor101">
     </a>
     How to do it…
    </h2>
    <p>
     To create our first graphical clock display, let’s follow
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      First, create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project. Then, open up
      <strong class="source-inline">
       mainwindow.ui
      </strong>
      and remove the
      <strong class="source-inline">
       menuBar
      </strong>
      ,
      <strong class="source-inline">
       mainToolBar
      </strong>
      , and
      <strong class="source-inline">
       statusBar
      </strong>
      as we
      <span class="No-Break">
       did before.
      </span>
     </li>
     <li>
      After that, open up the
      <strong class="source-inline">
       mainwindow.h
      </strong>
      file and include the
      <span class="No-Break">
       following headers:
      </span>
      <pre class="source-code">
#include &lt;QTime&gt;
#include &lt;QTimer&gt;
#include &lt;QPainter&gt;</pre>
     </li>
     <li>
      Then, declare the
      <strong class="source-inline">
       paintEvent()
      </strong>
      function,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold">virtual void paintEvent(QPaintEvent *event);</strong></pre>
     </li>
     <li>
      In the
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      file, create three arrays to store the shapes of the hour hand, minute hand, and
      <a id="_idIndexMarker301">
      </a>
      second hand, where each of the arrays contains three sets
      <span class="No-Break">
       of coordinates:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold">static const QPoint hourHand[3] = {</strong>
<strong class="bold">        QPoint(4, 4),</strong>
<strong class="bold">        QPoint(-4, 4),</strong>
<strong class="bold">        QPoint(0, -40)</strong>
<strong class="bold">    </strong><strong class="bold">};</strong>
<strong class="bold">    static const QPoint minuteHand[3] = {</strong>
<strong class="bold">        QPoint(4, 4),</strong>
<strong class="bold">        QPoint(-4, 4),</strong>
<strong class="bold">        QPoint(0, -70)</strong>
<strong class="bold">    };</strong>
<strong class="bold">    static const QPoint secondHand[3] = {</strong>
<strong class="bold">        QPoint(2, 2),</strong>
<strong class="bold">        QPoint(-2, 2),</strong>
<strong class="bold">        QPoint(0, -90)</strong>
<strong class="bold">    </strong><strong class="bold">};</strong>
}</pre>
     </li>
     <li>
      After that, add the following code below the arrays to create the painter and move it to the center of the main window. Also, we adjust the size of the painter so that it fits nicely in the main window, even when the window is
      <span class="No-Break">
       being resized:
      </span>
      <pre class="source-code">
int side = qMin(width(), height());
QPainter painter(this);
painter.setRenderHint(QPainter::Antialiasing);
painter.translate(width() / 2, height() / 2);
painter.scale(side / 250.0, side / 250.0);</pre>
     </li>
     <li>
      Once you are done with that, we will start drawing the dials by using a for loop. Each dial is rotated by
      <a id="_idIndexMarker302">
      </a>
      an increment of 6 degrees, so 60 dials would complete a full circle. Also, the dial will look slightly longer at every
      <span class="No-Break">
       five minutes:
      </span>
      <pre class="source-code">
for (int i = 0; i &lt; 60; ++i) {
    if ((i % 5) != 0)
        painter.drawLine(92, 0, 96, 0);
    else
        painter.drawLine(86, 0, 96, 0);
    painter.rotate(6.0);
}</pre>
     </li>
     <li>
      Then, we proceed with drawing the hands of the clock. Each hand’s rotation is calculated according to the current time and its respective equivalent location over
      <span class="No-Break">
       360 degrees:
      </span>
      <pre class="source-code">
QTime time = QTime::currentTime();
// Draw hour hand
painter.save();
painter.rotate((time.hour() * 360) / 12);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(hourHand, 3);
painter.restore();</pre>
     </li>
     <li>
      Let’s draw the minute hand of
      <span class="No-Break">
       the clock:
      </span>
      <pre class="source-code">
// Draw minute hand
painter.save();
painter.rotate((time.minute() * 360) / 60);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(minuteHand, 3);
painter.restore();</pre>
     </li>
     <li>
      Then, we also draw the
      <a id="_idIndexMarker303">
      </a>
      hand
      <span class="No-Break">
       for seconds:
      </span>
      <pre class="source-code">
// Draw second hand
painter.save();
painter.rotate((time.second() * 360) / 60);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(secondHand, 3);
painter.restore();</pre>
     </li>
     <li>
      Last, but not least, create a timer to refresh the graphics every second so that the program will work like a
      <span class="No-Break">
       real clock:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold">QTimer* timer = new QTimer(this);</strong>
<strong class="bold">    timer-&gt;start(1000);</strong>
    connect(timer, QTimer::timeout, this, MainWindow::update);
}</pre>
     </li>
     <li>
      Compile and run the
      <a id="_idIndexMarker304">
      </a>
      program now, and you should see something
      <span class="No-Break">
       like this:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer063">
      <img alt="Figure 4.6 – A real-time analog clock displayed on the Qt application" src="../images\image/B20976_04_006.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.6 – A real-time analog clock displayed on the Qt application
    </p>
    <h2 id="_idParaDest-102">
     <a id="_idTextAnchor102">
     </a>
     How it works...
    </h2>
    <p>
     Each of the arrays contains three
     <strong class="source-inline">
      QPoint
     </strong>
     data instances, which form the shape of an elongated triangle. The arrays are then passed to the painter and rendered as a convex polygon using the
     <strong class="source-inline">
      drawConvexPolygon()
     </strong>
     function. Before drawing each of the clock hands, we use
     <strong class="source-inline">
      painter.save()
     </strong>
     to save the state of the
     <strong class="source-inline">
      QPainter
     </strong>
     object and then proceed with drawing the hand using
     <span class="No-Break">
      coordinate transformation.
     </span>
    </p>
    <p>
     Once we’re done with the drawing, we restore the painter to its previous state by calling
     <strong class="source-inline">
      painter.restore()
     </strong>
     . This function will undo all the transformations before
     <strong class="source-inline">
      painter. restore()
     </strong>
     so that the next clock hand will not inherit the transformations of the previous one. Without using
     <strong class="source-inline">
      painter.save()
     </strong>
     and
     <strong class="source-inline">
      painter.restore()
     </strong>
     , we will have to manually change the position, rotation, and scale before drawing the
     <span class="No-Break">
      next hand.
     </span>
    </p>
    <p>
     A good example of not using
     <strong class="source-inline">
      painter.save()
     </strong>
     and
     <strong class="source-inline">
      painter.restore()
     </strong>
     is when drawing the dials. Since each dial’s rotation is an increment of six degrees from the previous one, we don’t need to save the painter’s state at all. We just have to call
     <strong class="source-inline">
      painter.rotate(6.0)
     </strong>
     in a loop and each dial will inherit the previous dial’s rotation. We also use a modulus operator (
     <strong class="source-inline">
      %
     </strong>
     ) to check whether the unit represented by the dial can be divided by five. If it can, then we draw it
     <span class="No-Break">
      slightly longer.
     </span>
    </p>
    <p>
     Without using a timer to
     <a id="_idIndexMarker305">
     </a>
     constantly call the
     <strong class="source-inline">
      update()
     </strong>
     slot, the clock will not function properly. This is because
     <strong class="source-inline">
      paintEvent()
     </strong>
     will not be called by Qt when there is no change to the state of the parent widget, which in this case is the main window. Therefore, we need to manually tell Qt that we need to refresh the graphics by calling
     <strong class="source-inline">
      update()
     </strong>
     <span class="No-Break">
      every second.
     </span>
    </p>
    <p>
     We used the
     <strong class="source-inline">
      painter.setRenderHint(QPainter::Antialiasing)
     </strong>
     function to enable anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will look very jagged
     <span class="No-Break">
      and pixelated:
     </span>
    </p>
    <div>
     <div class="IMG---Figure" id="_idContainer064">
      <img alt="Figure 4.7 – Anti-aliasing produces a smoother result" src="../images\image/B20976_04_007.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.7 – Anti-aliasing produces a smoother result
    </p>
    <h2 id="_idParaDest-103">
     <a id="_idTextAnchor103">
     </a>
     There’s more…
    </h2>
    <p>
     The
     <strong class="source-inline">
      QPainter
     </strong>
     class uses the coordinate system to determine the position and size of the graphics before rendering them on screen. This information can be altered to make the graphics appear at a different position, rotation, and size. This process of altering the coordinate information of a graphic is what we call coordinate transformation. There are
     <a id="_idIndexMarker306">
     </a>
     several types
     <a id="_idIndexMarker307">
     </a>
     of transformation: among
     <a id="_idIndexMarker308">
     </a>
     them
     <a id="_idIndexMarker309">
     </a>
     are
     <strong class="bold">
      translation
     </strong>
     ,
     <strong class="bold">
      rotation
     </strong>
     ,
     <strong class="bold">
      scaling
     </strong>
     ,
     <span class="No-Break">
      and
     </span>
     <span class="No-Break">
      <strong class="bold">
       shearing
      </strong>
     </span>
     <span class="No-Break">
      :
     </span>
    </p>
    <div>
     <div class="IMG---Figure" id="_idContainer065">
      <img alt="Figure 4.8 – Different types of transformations" src="../images\image/B20976_04_008.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.8 – Different types of transformations
    </p>
    <p>
     Qt uses a coordinate system that has its origin at the top-left corner, meaning the
     <em class="italic">
      x
     </em>
     values increase to the right and the
     <em class="italic">
      y
     </em>
     values increase downward. This coordinate system might be different from the coordinate system used by the physical device, such as a computer screen. Qt handles
     <a id="_idIndexMarker310">
     </a>
     this automatically by using the
     <strong class="source-inline">
      QPaintDevice
     </strong>
     class, which maps Qt’s logical coordinates to the
     <span class="No-Break">
      physical coordinates.
     </span>
    </p>
    <p>
     <strong class="source-inline">
      QPainter
     </strong>
     provides four transform operations to perform different types
     <span class="No-Break">
      of transformation:
     </span>
    </p>
    <ul>
     <li>
      <strong class="source-inline">
       QPainter::translate()
      </strong>
      : This offsets the graphic’s position by a given set
      <span class="No-Break">
       of units
      </span>
     </li>
     <li>
      <strong class="source-inline">
       QPainter::rotate()
      </strong>
      : This rotates the graphics around the origin in a
      <span class="No-Break">
       clockwise direction
      </span>
     </li>
     <li>
      <strong class="source-inline">
       QPainter::scale()
      </strong>
      : This offsets the graphic’s size by a
      <span class="No-Break">
       given factor
      </span>
     </li>
     <li>
      <strong class="source-inline">
       QPainter::shear()
      </strong>
      : This twists the graphic’s coordinate system around
      <span class="No-Break">
       the origin
      </span>
     </li>
    </ul>
    <h1 id="_idParaDest-104">
     <a id="_idTextAnchor104">
     </a>
     Displaying images on screen
    </h1>
    <p>
     Qt not only allows us to draw shapes and images on screen, but it also allows us to overlay multiple images on top of
     <a id="_idIndexMarker311">
     </a>
     each other and combine the pixel information from all the layers using different types of algorithms to create very interesting results. In this example, we will learn how to overlay images on top of each other and apply different composition effects
     <span class="No-Break">
      to them.
     </span>
    </p>
    <h2 id="_idParaDest-105">
     <a id="_idTextAnchor105">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s create a simple demo that shows the effect of different image compositions by following
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      First, set up a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and remove the
      <strong class="source-inline">
       menuBar
      </strong>
      ,
      <strong class="source-inline">
       mainToolBar
      </strong>
      , and
      <strong class="source-inline">
       statusBar
      </strong>
      , as we did in the
      <span class="No-Break">
       first recipe.
      </span>
     </li>
     <li>
      Next, add the
      <strong class="source-inline">
       QPainter
      </strong>
      class header to the
      <span class="No-Break">
       <strong class="source-inline">
        mainwindow.h
       </strong>
      </span>
      <span class="No-Break">
       file:
      </span>
      <pre class="source-code">
#include &lt;QPainter&gt;</pre>
     </li>
     <li>
      After that, declare the
      <strong class="source-inline">
       paintEvent()
      </strong>
      virtual function,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
virtual void paintEvent(QPaintEvent* event);</pre>
     </li>
     <li>
      In
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      , we will first load several image files using the
      <span class="No-Break">
       <strong class="source-inline">
        QImage
       </strong>
      </span>
      <span class="No-Break">
       class:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent* event) {
    <strong class="bold">QImage image;</strong>
<strong class="bold">    image.load("checker.png");</strong>
<strong class="bold">    QImage image2;</strong>
<strong class="bold">    image2.load("tux.png");</strong>
<strong class="bold">    QImage image3;</strong>
<strong class="bold">    image3.load("butterfly.png");</strong>
}</pre>
     </li>
     <li>
      Then, create a
      <strong class="source-inline">
       QPainter
      </strong>
      object and use it to draw two pairs of images, where one image is on top of
      <span class="No-Break">
       the other:
      </span>
      <pre class="source-code">
QPainter painter(this);
painter.drawImage(QPoint(10, 10), image);
painter.drawImage(QPoint(10, 10), image2);
painter.drawImage(QPoint(300, 10), image);
painter.drawImage(QPoint(300, 40), image3);</pre>
     </li>
     <li>
      Now, compile and run
      <a id="_idIndexMarker312">
      </a>
      the program and you should see something
      <span class="No-Break">
       like this:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer066">
      <img alt="Figure 4.9 – Displaying images normally" src="../images\image/B20976_04_009.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.9 – Displaying images normally
    </p>
    <ol>
     <li value="7">
      Next, we will set the composition mode before drawing each image
      <span class="No-Break">
       on screen:
      </span>
      <pre class="source-code">
QPainter painter(this);
painter.setCompositionMode(QPainter::CompositionMode_Difference);
painter.drawImage(QPoint(10, 10), image);
painter.setCompositionMode(QPainter::CompositionMode_Multiply);
painter.drawImage(QPoint(10, 10), image2);
painter.setCompositionMode(QPainter::CompositionMode_Xor);
painter.drawImage(QPoint(300, 10), image);
painter.setCompositionMode(QPainter::CompositionMode_SoftLight);
painter.drawImage(QPoint(300, 40), image3);</pre>
     </li>
     <li>
      Compile and run the
      <a id="_idIndexMarker313">
      </a>
      program again and you will now see something
      <span class="No-Break">
       like this:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer067">
      <img alt="Figure 4.10 – Applying different composition modes to the images" src="../images\image/B20976_04_010.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.10 – Applying different composition modes to the images
    </p>
    <h2 id="_idParaDest-106">
     <a id="_idTextAnchor106">
     </a>
     How it works...
    </h2>
    <p>
     When drawing images with Qt, the sequence of calling the
     <strong class="source-inline">
      drawImage()
     </strong>
     function will determine which image is being rendered first and which one is rendered later. This will affect the depth order of the images and yield
     <span class="No-Break">
      different outcomes.
     </span>
    </p>
    <p>
     In the previous example, we called the
     <strong class="source-inline">
      drawImage()
     </strong>
     function four times to draw four different images on screen. The first
     <strong class="source-inline">
      drawImage()
     </strong>
     function renders
     <strong class="source-inline">
      checker.png
     </strong>
     , and the second
     <strong class="source-inline">
      drawImage()
     </strong>
     function renders
     <strong class="source-inline">
      tux.png
     </strong>
     (the penguin). The image that gets rendered later will always appear in front of the others, which is why the penguin is showing in front of the checkered pattern. The same goes for the butterfly and the checkered pattern on the right. The reason why you can still see the checkered pattern even though the butterfly is rendered in front of it is because the butterfly image is not
     <span class="No-Break">
      fully opaque.
     </span>
    </p>
    <p>
     Now, let’s invert the render
     <a id="_idIndexMarker314">
     </a>
     sequence and see what happens. We will try to render the penguin first, followed by the checkered box. The same goes for the other pair of images on the right: the butterfly gets rendered first, followed by the
     <span class="No-Break">
      checkered box:
     </span>
    </p>
    <div>
     <div class="IMG---Figure" id="_idContainer068">
      <img alt="Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes" src="../images\image/B20976_04_011.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes
    </p>
    <p>
     To apply a composition effect to the image, we’ll have to set the painter’s composition mode before drawing the image, by calling the
     <strong class="source-inline">
      painter.setCompositionMode()
     </strong>
     function. You can pick a desired composition mode from the auto-complete menu by
     <span class="No-Break">
      typing
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       QPainter::CompositionMode
      </strong>
     </span>
     <span class="No-Break">
      .
     </span>
    </p>
    <p>
     In the previous example, we applied
     <strong class="source-inline">
      QPainter::CompositionMode_Difference
     </strong>
     to the checkered box on the left, which inverted its color. Next, we applied
     <strong class="source-inline">
      QPainter::CompositionMode_Overlay
     </strong>
     to the penguin, which makes it blend with the checkered pattern, and were able to see both images overlaying each other. On the right-hand side, we applied
     <strong class="source-inline">
      QPainter::CompositionMode_Xor
     </strong>
     to the checkered box, where, if differences exist between the source and destination, colors are shown; otherwise, it will be
     <span class="No-Break">
      rendered black.
     </span>
    </p>
    <p>
     Since it’s comparing differences with the white background, the non-transparent part of the checkered box becomes completely black. We also applied
     <strong class="source-inline">
      QPainter::CompositionMode_SoftLight
     </strong>
     to the butterfly image. This blends the pixels with the background with reduced contrast. If you want to disable the composition mode that
     <a id="_idIndexMarker315">
     </a>
     you’ve just set for the previous rendering before proceeding to the next, simply set it back to the default mode, which
     <span class="No-Break">
      is
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       QPainter::CompositionMode_SourceOver
      </strong>
     </span>
     <span class="No-Break">
      .
     </span>
    </p>
    <h2 id="_idParaDest-107">
     <a id="_idTextAnchor107">
     </a>
     There’s more…
    </h2>
    <p>
     For example, we can overlay multiple images on top of each other and use Qt’s
     <strong class="bold">
      Image Composition
     </strong>
     feature to merge
     <a id="_idIndexMarker316">
     </a>
     them together and calculate the resulting pixels on screen, based on the composition mode we used. This is often used in image editing software such as Photoshop and GIMP to composite
     <span class="No-Break">
      image layers.
     </span>
    </p>
    <p>
     There are more than 30 types of composition
     <a id="_idIndexMarker317">
     </a>
     modes available in Qt. Some of the most commonly used modes are
     <span class="No-Break">
      as follows:
     </span>
    </p>
    <ul>
     <li>
      <strong class="source-inline">
       Clear
      </strong>
      : The pixels in the destination are set to fully transparent, independent of
      <span class="No-Break">
       the source.
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Source
      </strong>
      : The output is the source pixel. This mode is the inverse
      <span class="No-Break">
       of
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        CompositionMode_Destination
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Destination
      </strong>
      : The output is the destination pixel. This means that the blending has no effect. This mode is the inverse
      <span class="No-Break">
       of
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        CompositionMode_Source
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Source Over
      </strong>
      : This is often referred to as
      <strong class="bold">
       alpha blending
      </strong>
      . The alpha of the source is used to blend the pixel on
      <a id="_idIndexMarker318">
      </a>
      top of the destination. This is the default mode used
      <span class="No-Break">
       by
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        QPainter
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Destination Over
      </strong>
      : The output is the blend between the alpha of the destination on top of the source pixels. The opposite of this mode
      <span class="No-Break">
       is
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        CompositionMode_SourceOver
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Source In
      </strong>
      : The output is the source, where the alpha is reduced by that of
      <span class="No-Break">
       the destination.
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Destination In
      </strong>
      : The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse
      <span class="No-Break">
       of
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        CompositionMode_SourceIn
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Source Out
      </strong>
      : The output is the
      <a id="_idIndexMarker319">
      </a>
      source, where the alpha is reduced by the inverse of
      <span class="No-Break">
       the destination.
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Destination Out
      </strong>
      : The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse
      <span class="No-Break">
       of
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        CompositionMode_SourceOut
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Source Atop
      </strong>
      : The source pixel is blended on top of the destination, with the alpha of the source pixel reduced by the alpha of the
      <span class="No-Break">
       destination pixel.
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Destination Atop
      </strong>
      : The destination pixel is blended on top of the source, with the alpha of the source pixel reduced by the alpha of the destination pixel. This mode is the inverse
      <span class="No-Break">
       of
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        CompositionMode_SourceAtop
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      <strong class="source-inline">
       Xor
      </strong>
      : This is short for
      <strong class="source-inline">
       Exclusive OR
      </strong>
      , which is an advanced blending mode that is primarily used for image analysis. Using this is much more complicated with this composition mode. First, the alpha of the source is reduced by the inverse of the destination alpha. Then, the alpha of the destination is reduced by the inverse of the source alpha. Finally, both the source and destination are then merged to produce
      <span class="No-Break">
       the output.
      </span>
     </li>
    </ul>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     For more information, you can visit this
     <span class="No-Break">
      link:
     </span>
     <a href="https://pyside.github.io">
      <span class="No-Break">
       https://pyside.github.io
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <p>
     The following figure shows the outcome of overlaying two images with different
     <span class="No-Break">
      composition modes:
     </span>
    </p>
    <div>
     <div class="IMG---Figure" id="_idContainer069">
      <img alt="Figure 4.12 – Different types of composition modes" src="../images\image/B20976_04_012.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.12 – Different types of composition modes
    </p>
    <h1 id="_idParaDest-108">
     <a id="_idTextAnchor108">
     </a>
     Applying image effects to graphics
    </h1>
    <p>
     Qt provides an easy way to
     <a id="_idIndexMarker320">
     </a>
     add image effects to any graphics drawn using the
     <strong class="source-inline">
      QPainter
     </strong>
     class. In this example, we will learn how to apply different image effects, such as
     <a id="_idIndexMarker321">
     </a>
     drop shadow, blur, colorize, and opacity effects, to a graphic before displaying it
     <span class="No-Break">
      on screen.
     </span>
    </p>
    <h2 id="_idParaDest-109">
     <a id="_idTextAnchor109">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s learn how to apply image effects to text and graphics by following
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      Create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and remove the
      <strong class="source-inline">
       menuBar
      </strong>
      ,
      <strong class="source-inline">
       mainToolBar
      </strong>
      ,
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        StatusBar
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      Create a new resource file by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      and add all the images required by
      <span class="No-Break">
       the project:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer070">
      <img alt="Figure 4.13 – Creating a new Qt resource file" src="../images\image/B20976_04_013.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.13 – Creating a new Qt resource file
    </p>
    <ol>
     <li value="3">
      Next, open up
      <strong class="source-inline">
       mainwindow.ui
      </strong>
      and
      <a id="_idIndexMarker322">
      </a>
      add four labels to the window. Two of
      <a id="_idIndexMarker323">
      </a>
      the labels will be text, and the two others we will load with the images we have just added to the
      <span class="No-Break">
       resource file:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer071">
      <img alt="Figure 4.14 – Application filled with text and images" src="../images\image/B20976_04_014.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.14 – Application filled with text and images
    </p>
    <ol>
     <li value="4">
      You may already notice that
      <a id="_idIndexMarker324">
      </a>
      the font sizes are way bigger than the default size. That can be achieved
      <a id="_idIndexMarker325">
      </a>
      by adding a style sheet to the label widget, for example,
      <span class="No-Break">
       as follows:
      </span>
      <pre class="source-code">
font: 26pt "MS Gothic";</pre>
     </li>
     <li>
      After that, open up
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      and include the following headers at the top of the
      <span class="No-Break">
       source code:
      </span>
      <pre class="source-code">
#include &lt;QGraphicsBlurEffect&gt;
#include &lt;QGraphicsDropShadowEffect&gt;
#include &lt;QGraphicsColorizeEffect&gt;
#include &lt;QGraphicsOpacityEffect&gt;</pre>
     </li>
     <li>
      Then, within the constructor of the
      <strong class="source-inline">
       MainWindow
      </strong>
      class, add the following code to create a
      <strong class="source-inline">
       DropShadowEffect
      </strong>
      , and apply it to one of
      <span class="No-Break">
       the labels:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
ui-&gt;setupUi(this);
<strong class="bold">QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect();</strong>
<strong class="bold">shadow-&gt;setXOffset(4);</strong>
<strong class="bold">shadow-&gt;setYOffset(4);</strong>
<strong class="bold">ui-&gt;label-&gt;setGraphicsEffect(shadow);</strong>
}</pre>
     </li>
     <li>
      Next, we will create
      <strong class="source-inline">
       ColorizedEffect
      </strong>
      and apply it to one of the images, in this case, the
      <a id="_idIndexMarker326">
      </a>
      butterfly. We also set the effect color
      <span class="No-Break">
       to
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker327">
       </a>
      </span>
      <span class="No-Break">
       red:
      </span>
      <pre class="source-code">
QGraphicsColorizeEffect* colorize = new
QGraphicsColorizeEffect();
colorize-&gt;setColor(QColor(255, 0, 0));
ui-&gt;butterfly-&gt;setGraphicsEffect(colorize);</pre>
     </li>
     <li>
      Once we’re done with that, create
      <strong class="source-inline">
       BlurEffect
      </strong>
      and set its radius to
      <strong class="source-inline">
       12
      </strong>
      . Then, apply the graphics effect to the
      <span class="No-Break">
       other label:
      </span>
      <pre class="source-code">
QGraphicsBlurEffect* blur = new QGraphicsBlurEffect();
blur-&gt;setBlurRadius(12);
ui-&gt;label2-&gt;setGraphicsEffect(blur);</pre>
     </li>
     <li>
      Lastly, create an alpha effect and apply it to the penguin image. We set the opacity value to
      <strong class="source-inline">
       0.2
      </strong>
      , which means
      <span class="No-Break">
       20% opacity:
      </span>
      <pre class="source-code">
QGraphicsOpacityEffect* alpha = new QGraphicsOpacityEffect();
alpha-&gt;setOpacity(0.2);
ui-&gt;penguin-&gt;setGraphicsEffect(alpha);</pre>
     </li>
     <li>
      Now, compile and run the program and you should be able to see something
      <span class="No-Break">
       like this:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer072">
      <img alt="Figure 4.15 – Different types of graphics effects being applied to the texts and images" src="../images\image/B20976_04_015.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.15 – Different types of graphics effects being applied to the texts and images
    </p>
    <h2 id="_idParaDest-110">
     <a id="_idTextAnchor110">
     </a>
     How it works...
    </h2>
    <p>
     Each of the graphic effects is a class of its
     <a id="_idIndexMarker328">
     </a>
     own that inherits the
     <strong class="source-inline">
      QGraphicsEffect
     </strong>
     parent class. You can create
     <a id="_idIndexMarker329">
     </a>
     your own custom effect by creating a new class that inherits
     <strong class="source-inline">
      QGraphicsEffect
     </strong>
     and re-implementing some of the functions
     <span class="No-Break">
      in it.
     </span>
    </p>
    <p>
     Each effect has its own set of variables that are specifically created for it. For example, you can set the color of the colorized effect, but there is no such variable in the blur effect. This is because each effect is vastly different from the others, which is also why it needs to be a class of its own rather than using the same class for all the
     <span class="No-Break">
      different effects.
     </span>
    </p>
    <p>
     It’s only possible to add a single graphics effect to a widget at a time. If you add more than one effect, only the last one will be applied to the widget, as it replaces the previous one. Other than that, be aware that if you create a graphics effect, for example, the drop shadow effect, you can’t assign it to two different widgets, as it will only get assigned to the last widget you applied it to. If you need to apply the same type of effect to several different widgets, create a few graphics effects of the same type and apply each of them to their
     <span class="No-Break">
      respective widgets.
     </span>
    </p>
    <h2 id="_idParaDest-111">
     <a id="_idTextAnchor111">
     </a>
     There’s more…
    </h2>
    <p>
     Currently, Qt supports blur, drop shadow, colorize, and opacity effects. These effects can be used by calling the following classes:
     <strong class="source-inline">
      QGraphicsBlurEffect
     </strong>
     ,
     <strong class="source-inline">
      QGraphicsDropShadowEffect
     </strong>
     ,
     <strong class="source-inline">
      QGraphicsColorizeEffect
     </strong>
     , and
     <strong class="source-inline">
      QGraphicsOpacityEffect
     </strong>
     . All these classes are inherited from the
     <strong class="source-inline">
      QGraphicsEffect
     </strong>
     class. You can also create
     <a id="_idIndexMarker330">
     </a>
     your own custom image effect by creating a subclass of
     <strong class="source-inline">
      QGrapicsEffect
     </strong>
     (or any other existing effects) and re-implementing the
     <span class="No-Break">
      <strong class="source-inline">
       draw()
      </strong>
     </span>
     <span class="No-Break">
      function.
     </span>
    </p>
    <p>
     The graphics effect changes only
     <a id="_idIndexMarker331">
     </a>
     the bounding rectangle of the source. If you want to increase the margin of the bounding rectangle, re-implement the virtual
     <strong class="source-inline">
      boundingRectFor()
     </strong>
     function, and call
     <strong class="source-inline">
      updateBoundingRect()
     </strong>
     to notify the framework whenever this
     <span class="No-Break">
      rectangle changes.
     </span>
    </p>
    <h1 id="_idParaDest-112">
     <a id="_idTextAnchor112">
     </a>
     Creating a basic paint program
    </h1>
    <p>
     Since we have learned so much about the
     <strong class="source-inline">
      QPainter
     </strong>
     class and how to use it to display graphics on screen, I guess
     <a id="_idIndexMarker332">
     </a>
     it’s time for us to do something fun where we can put our knowledge
     <span class="No-Break">
      into practice.
     </span>
    </p>
    <p>
     In this recipe, we will learn how to make a basic paint program that allows us to draw lines on a canvas with different brush sizes and colors. We will also learn how to use the
     <strong class="source-inline">
      QImage
     </strong>
     class and mouse events in order to construct the
     <span class="No-Break">
      paint program.
     </span>
    </p>
    <h2 id="_idParaDest-113">
     <a id="_idTextAnchor113">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s start our fun project with the
     <span class="No-Break">
      following steps:
     </span>
    </p>
    <ol>
     <li>
      Again, we start by creating a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and removing the toolbar and status bar. We will keep the menu bar
      <span class="No-Break">
       this time.
      </span>
     </li>
     <li>
      After that, set up the menu bar
      <span class="No-Break">
       like so:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer073">
      <img alt="Figure 4.16 – Setting up the menu bar" src="../images\image/B20976_04_016.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.16 – Setting up the menu bar
    </p>
    <ol>
     <li value="3">
      We will leave the menu bar as it is for the moment, so let’s proceed to the
      <strong class="source-inline">
       mainwindow.h
      </strong>
      file. First, include
      <a id="_idIndexMarker333">
      </a>
      the following header files, as they are required for
      <span class="No-Break">
       the project:
      </span>
      <pre class="source-code">
#include &lt;QPainter&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QFileDialog&gt;</pre>
     </li>
     <li>
      Next, declare the variables that we’ll be using for this project,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
private:
    Ui::MainWindow *ui;
    <strong class="bold">QImage image;</strong>
<strong class="bold">    bool drawing;</strong>
<strong class="bold">    QPoint lastPoint;</strong>
<strong class="bold">    int brushSize;</strong>
<strong class="bold">    QColor brushColor;</strong></pre>
     </li>
     <li>
      Then, declare the event callback functions, which are inherited from the
      <strong class="source-inline">
       QWidget
      </strong>
      class. These functions will be triggered by Qt when the respective event happens. We will override these functions and tell Qt what to do when these events
      <span class="No-Break">
       get called:
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold">virtual void mousePressEvent(QMouseEvent *event);</strong>
<strong class="bold">    virtual void mouseMoveEvent(QMouseEvent *event);</strong>
<strong class="bold">    virtual void mouseReleaseEvent(QMouseEvent *event);</strong>
<strong class="bold">    virtual void paintEvent(QPaintEvent *event);</strong>
<strong class="bold">    virtual void resizeEvent(QResizeEvent *event);</strong></pre>
     </li>
     <li>
      After that, go to the
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      file and add the following code to the class constructor to set up some
      <a id="_idIndexMarker334">
      </a>
      of
      <span class="No-Break">
       the variables:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold">image = QImage(this-&gt;size(), QImage::Format_RGB32);</strong>
<strong class="bold">    </strong><strong class="bold">image.fill(Qt::white);</strong>
<strong class="bold">    drawing = false;</strong>
<strong class="bold">    brushColor = Qt::black;</strong>
<strong class="bold">    brushSize = 2;</strong>
}</pre>
     </li>
     <li>
      Next, we will construct the
      <strong class="source-inline">
       mousePressEvent()
      </strong>
      event and tell Qt what to do when the left mouse button
      <span class="No-Break">
       is pressed:
      </span>
      <pre class="source-code">
void MainWindow::mousePressEvent(QMouseEvent *event) {
    <strong class="bold">if (event-&gt;button() == Qt::LeftButton) {</strong>
<strong class="bold">        drawing = true;</strong>
<strong class="bold">        lastPoint = event-&gt;pos();</strong>
<strong class="bold">    }</strong>
}</pre>
     </li>
     <li>
      Then, we will construct the
      <strong class="source-inline">
       mouseMoveEvent()
      </strong>
      event and tell Qt what to do when the mouse is moving. In this case, we want to draw the lines on the canvas if the left mouse button is
      <a id="_idIndexMarker335">
      </a>
      <span class="No-Break">
       being held:
      </span>
      <pre class="source-code">
void MainWindow::mouseMoveEvent(QMouseEvent *event) {
    <strong class="bold">if ((event-&gt;buttons() &amp; Qt::LeftButton) &amp;&amp; drawing) {</strong>
<strong class="bold">        QPainter painter(&amp;image);</strong>
<strong class="bold">        painter.setPen(QPen(brushColor, brushSize, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));</strong>
<strong class="bold">        painter.drawLine(lastPoint, event-&gt;pos());</strong>
<strong class="bold">lastPoint = event-&gt;pos();</strong>
<strong class="bold">         this-&gt;update();</strong>
<strong class="bold">    }</strong>
}</pre>
     </li>
     <li>
      After that, we will also construct the
      <strong class="source-inline">
       mouseReleaseEvent()
      </strong>
      event, which will be triggered when the mouse button
      <span class="No-Break">
       is released:
      </span>
      <pre class="source-code">
void MainWindow::mouseReleaseEvent(QMouseEvent *event) {
    <strong class="bold">if (event-&gt;button() == Qt::LeftButton) {</strong>
<strong class="bold">        drawing = false;</strong>
<strong class="bold">    }</strong>
}</pre>
     </li>
     <li>
      Once you’re done with that, we will proceed to the
      <strong class="source-inline">
       paintEvent()
      </strong>
      event, which is surprisingly simple compared to the other examples we have seen in
      <span class="No-Break">
       previous sections:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold">QPainter canvasPainter(this);</strong>
<strong class="bold">    canvasPainter.drawImage(this-&gt;rect(), image, image.rect());</strong>
}</pre>
     </li>
     <li>
      Remember how we have a
      <a id="_idIndexMarker336">
      </a>
      menu bar sitting around doing nothing? Let’s right-click on each of the actions below the GUI editor and select
      <strong class="bold">
       Go to slot…
      </strong>
      in the pop-up menu. We want to tell Qt what to do when each of these options on the menu bar
      <span class="No-Break">
       is selected:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer074">
      <img alt="Figure 4.17 – Creating slot function for each of the menu actions" src="../images\image/B20976_04_017.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.17 – Creating slot function for each of the menu actions
    </p>
    <ol>
     <li value="12">
      Then, select the default slot called
      <strong class="source-inline">
       triggered()
      </strong>
      and press the
      <strong class="bold">
       OK
      </strong>
      button. Qt will automatically generate a new slot function in both your
      <strong class="source-inline">
       mainwindow.h
      </strong>
      and
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      files. Once you are done with all the actions, you should see something like this in your
      <span class="No-Break">
       <strong class="source-inline">
        mainwindow.h
       </strong>
      </span>
      <span class="No-Break">
       file:
      </span>
      <pre class="source-code">
private slots:
    void on_actionSave_triggered();
    void on_actionClear_triggered();
    void on_action2px_triggered();
    void on_action5px_triggered();
    void on_action10px_triggered();
    void on_actionBlack_triggered();
    void on_actionWhite_triggered();
    void on_actionRed_triggered();
    void on_actionGreen_triggered();
    void on_actionBlue_triggered();</pre>
     </li>
     <li>
      Next, we will tell Qt what
      <a id="_idIndexMarker337">
      </a>
      to do when each of these slots
      <span class="No-Break">
       is triggered:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_triggered() {
    <strong class="bold">QString filePath = QFileDialog::getSaveFileName(this, «Save Image», «», «PNG (*.png);;JPEG (*.jpg *.jpeg);;All files</strong>
<strong class="bold">(*.*)»);</strong>
<strong class="bold">    if (filePath == "")</strong>
<strong class="bold">        </strong><strong class="bold">return;</strong>
<strong class="bold">    image.save(filePath);</strong>
}
void MainWindow::on_actionClear_triggered() {
    <strong class="bold">image.fill(Qt::white);</strong>
<strong class="bold">    this-&gt;update();</strong>
}</pre>
     </li>
     <li>
      Then, we continue to
      <a id="_idIndexMarker338">
      </a>
      implement the
      <span class="No-Break">
       other slots:
      </span>
      <pre class="source-code">
void MainWindow::on_action2px_triggered() {
    <strong class="bold">brushSize = 2;</strong>
}
void MainWindow::on_action5px_triggered() {
    <strong class="bold">brushSize = 5;</strong>
}
void MainWindow::on_action10px_triggered() {
    <strong class="bold">brushSize = 10;</strong>
}
void MainWindow::on_actionBlack_triggered() {
    <strong class="bold">brushColor = Qt::black;</strong>
}</pre>
     </li>
     <li>
      Finally, we implement the rest of the
      <span class="No-Break">
       slot functions:
      </span>
      <pre class="source-code">
void MainWindow::on_actionWhite_triggered() {
    <strong class="bold">brushColor = Qt::white;</strong>
}
void MainWindow::on_actionRed_triggered() {
    <strong class="bold">brushColor = Qt::red;</strong>
}
void MainWindow::on_actionGreen_triggered() {
    <strong class="bold">brushColor = Qt::green;</strong>
}
void MainWindow::on_actionBlue_triggered() {
    <strong class="bold">brushColor = Qt::blue;</strong>
}</pre>
     </li>
     <li>
      If we compile and run the
      <a id="_idIndexMarker339">
      </a>
      program now, we will get a simple but usable
      <span class="No-Break">
       paint program:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer075">
      <img alt="Figure 4.18 – Our lovely paint program in action!" src="../images\image/B20976_04_018.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.18 – Our lovely paint program in action!
    </p>
    <h2 id="_idParaDest-114">
     <a id="_idTextAnchor114">
     </a>
     How it works...
    </h2>
    <p>
     In this example, we created a
     <strong class="source-inline">
      QImage
     </strong>
     widget when the program started. This widget acts as the canvas and will follow the size of the window whenever the window gets resized. In order to draw something on the canvas, we will need to use the mouse events provided by Qt. These events will tell us the position of the cursor, and we will be able to use this information to change the pixels on
     <span class="No-Break">
      the canvas.
     </span>
    </p>
    <p>
     We use a Boolean variable called
     <strong class="source-inline">
      drawing
     </strong>
     to let the program know whether it should start drawing when a mouse button is pressed. In this case, when the left mouse button is pressed, the
     <strong class="source-inline">
      drawing
     </strong>
     variable will be set to
     <strong class="source-inline">
      true
     </strong>
     . We also save the current cursor position to the
     <strong class="source-inline">
      lastPoint
     </strong>
     variable when the left mouse button is pressed, so that Qt will know where it should start drawing. When the mouse moves, the
     <strong class="source-inline">
      mouseMoveEvent()
     </strong>
     event will be triggered by Qt. This is where we need to check whether the drawing variable is set to
     <strong class="source-inline">
      true
     </strong>
     . If it is, then
     <strong class="source-inline">
      QPainter
     </strong>
     can start drawing the lines onto the
     <strong class="source-inline">
      QImage
     </strong>
     widget based on the brush settings that we provide. The brush settings consist of
     <strong class="source-inline">
      brushColor
     </strong>
     and
     <strong class="source-inline">
      brushSize
     </strong>
     . These settings are saved as variables and can be altered by selecting a different setting from the
     <span class="No-Break">
      menu bar.
     </span>
    </p>
    <p>
     Please remember to call the
     <strong class="source-inline">
      update()
     </strong>
     function when the user is drawing on the canvas. Otherwise, the canvas will remain empty even though we have changed the pixel information of the canvas. We also have to call the
     <strong class="source-inline">
      update()
     </strong>
     function when we select
     <strong class="bold">
      File
     </strong>
     |
     <strong class="bold">
      Clear
     </strong>
     from the menu bar to reset
     <span class="No-Break">
      our canvas.
     </span>
    </p>
    <p>
     In this example, we use
     <strong class="source-inline">
      QImage::save()
     </strong>
     to save the image file, which is very straightforward. We use the file dialog
     <a id="_idIndexMarker340">
     </a>
     to let the user decide where to save the image and its desired filename. Then, we pass the information to
     <strong class="source-inline">
      QImage
     </strong>
     , and it will do the rest by itself. If we don’t specify the file format to the
     <strong class="source-inline">
      QImage::save()
     </strong>
     function,
     <strong class="source-inline">
      QImage
     </strong>
     will try to figure it out by looking at the extension of the
     <span class="No-Break">
      desired filename.
     </span>
    </p>
    <h1 id="_idParaDest-115">
     <a id="_idTextAnchor115">
     </a>
     Rendering a 2D canvas in QML
    </h1>
    <p>
     In all the previous examples
     <a id="_idIndexMarker341">
     </a>
     of this chapter, we have discussed the methods and techniques
     <a id="_idIndexMarker342">
     </a>
     used to render 2D graphics with Qt’s C++ API. However, we have yet to learn how to achieve similar results using the powerful
     <span class="No-Break">
      QML script.
     </span>
    </p>
    <h2 id="_idParaDest-116">
     <a id="_idTextAnchor116">
     </a>
     How to do it…
    </h2>
    <p>
     In this project, we’ll be doing something
     <span class="No-Break">
      quite different:
     </span>
    </p>
    <ol>
     <li>
      As usual, the first step is to create a new project by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      and selecting
      <strong class="bold">
       Qt Quick Application
      </strong>
      as the
      <span class="No-Break">
       project template:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer076">
      <img alt="Figure 4.19 – Creating a new Qt Quick Application project" src="../images\image/B20976_04_019.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.19 – Creating a new Qt Quick Application project
    </p>
    <ol>
     <li value="2">
      Once you are done creating
      <a id="_idIndexMarker343">
      </a>
      the new project, open up
      <strong class="source-inline">
       main.qml
      </strong>
      , which is
      <a id="_idIndexMarker344">
      </a>
      listed under
      <strong class="source-inline">
       qml.qrc
      </strong>
      in the project pane. After that, set an ID for the window and adjust its
      <strong class="source-inline">
       width
      </strong>
      and
      <strong class="source-inline">
       height
      </strong>
      values to larger values,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
import QtQuick
import QtQuick.Window
Window {
    <strong class="bold">id: myWindow</strong>
<strong class="bold">    visible: true</strong>
<strong class="bold">    width: 640</strong>
<strong class="bold">    height: 480</strong>
<strong class="bold">    title: qsTr("Hello World")</strong>
}</pre>
     </li>
     <li>
      Then, add a
      <strong class="source-inline">
       Canvas
      </strong>
      object under
      <strong class="source-inline">
       myWindow
      </strong>
      and call it
      <strong class="source-inline">
       myCanvas
      </strong>
      . After that, we make its
      <strong class="source-inline">
       width
      </strong>
      and
      <strong class="source-inline">
       height
      </strong>
      values the same
      <span class="No-Break">
       as
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        myWindow
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
Window {
    id: myWindow
    visible: true
    width: 640
    height: 480
    <strong class="bold">Canvas {</strong>
<strong class="bold">        id: myCanvas</strong>
<strong class="bold">        width: myWindow.width</strong>
<strong class="bold">        height: myWindow.height</strong>
<strong class="bold">    }</strong>
}</pre>
     </li>
     <li>
      Next, we define what
      <a id="_idIndexMarker345">
      </a>
      will happen when the
      <strong class="source-inline">
       onPaint
      </strong>
      event is triggered; in this
      <a id="_idIndexMarker346">
      </a>
      case, we will draw a cross on
      <span class="No-Break">
       the window:
      </span>
      <pre class="source-code">
Canvas {
    id: myCanvas
    width: myWindow.width
    height: myWindow.height
    <strong class="bold">onPaint: {</strong>
<strong class="bold">        var context = getContext('2d')</strong>
<strong class="bold">        </strong><strong class="bold">context.fillStyle = 'white'</strong>
<strong class="bold">        context.fillRect(0, 0, width, height)</strong>
<strong class="bold">        context.lineWidth = 2</strong>
<strong class="bold">        context.strokeStyle = 'black'</strong></pre>
     </li>
     <li>
      Let’s continue to write
      <a id="_idIndexMarker347">
      </a>
      the code,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
// Draw cross
context.beginPath()
context.moveTo(50, 50)
context.lineTo(100, 100)
context.closePath()
context.stroke()
context.beginPath()
context.moveTo(100, 50)
context.lineTo(50, 100)
context.closePath()
context.stroke()
}
}</pre>
     </li>
     <li>
      After that, we add the
      <a id="_idIndexMarker348">
      </a>
      following code to draw a tick beside
      <span class="No-Break">
       the cross:
      </span>
      <pre class="source-code">
// Draw tick
context.beginPath()
context.moveTo(150, 90)
context.lineTo(158, 100)
context.closePath()
context.stroke()
context.beginPath()
context.moveTo(180, 100)
context.lineTo(210, 50)
context.closePath()
context.stroke()</pre>
     </li>
     <li>
      Then, draw a triangle shape
      <a id="_idIndexMarker349">
      </a>
      by adding the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
// Draw triangle
context.lineWidth = 4
context.strokeStyle = "red"
context.fillStyle = "salmon"
context.beginPath()
context.moveTo(50,150)
context.lineTo(150,150)
context.lineTo(50,250)
context.closePath()
context.fill()
context.stroke()</pre>
     </li>
     <li>
      After that, draw a half
      <a id="_idIndexMarker350">
      </a>
      circle and a full circle with the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
// Draw circle
context.lineWidth = 4
context.strokeStyle = "blue"
context.fillStyle = "steelblue"
var pi = 3.141592653589793
context.beginPath()
context.arc(220, 200, 60, 0, pi, true)
context.closePath()
context.fill()
context.stroke()</pre>
     </li>
     <li>
      Then, we draw
      <span class="No-Break">
       an
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker351">
       </a>
      </span>
      <span class="No-Break">
       arc:
      </span>
      <pre class="source-code">
context.beginPath()
context.arc(220, 280, 60, 0, 2 * pi, true)
context.closePath()
context.fill()
context.stroke()</pre>
     </li>
     <li>
      Finally, we draw a 2D
      <a id="_idIndexMarker352">
      </a>
      image from
      <span class="No-Break">
       a file:
      </span>
      <pre class="source-code">
// Draw image
context.drawImage("tux.png", 280, 10, 150, 174)</pre>
     </li>
     <li>
      However, the preceding code alone will not successfully render an image on screen because you must also load the image file beforehand. Add the following code within the
      <strong class="source-inline">
       Canvas
      </strong>
      object to ask QML to load the image file when the program is started, then call the
      <strong class="source-inline">
       requestPaint()
      </strong>
      signal when the image is loaded so that the
      <strong class="source-inline">
       onPaint()
      </strong>
      event slot will
      <span class="No-Break">
       be triggered:
      </span>
      <pre class="source-code">
onImageLoaded: requestPaint();
onPaint: {
    // The code we added previously
}</pre>
     </li>
     <li>
      Then, open up
      <strong class="source-inline">
       qml.qrc
      </strong>
      by right-clicking it in the project panel and select
      <strong class="bold">
       Open in Editor
      </strong>
      . After that, add the
      <strong class="source-inline">
       tux.png
      </strong>
      image file to our
      <span class="No-Break">
       project resource:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer077">
      <img alt="Figure 4.20 – The tux.png image file is now listed under qml.qrc" src="../images\image/B20976_04_020.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.20 – The tux.png image file is now listed under qml.qrc
    </p>
    <ol>
     <li value="13">
      Now, build and run the
      <a id="_idIndexMarker353">
      </a>
      program and you should get
      <span class="No-Break">
       the
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker354">
       </a>
      </span>
      <span class="No-Break">
       following:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer078">
      <img alt="Figure 4.21 – Tux the penguin is amused by the geometrical shapes" src="../images\image/B20976_04_021.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 4.21 – Tux the penguin is amused by the geometrical shapes
    </p>
    <p>
     In the preceding example, we learned how to draw simple vector shapes on our screen using the
     <strong class="source-inline">
      Canvas
     </strong>
     element. Qt’s built-in modules make the complex rendering process more straightforward
     <span class="No-Break">
      for programmers.
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
