<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   13Demystifying C++ I/O
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_007.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_009.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c13_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c13_1">
      <span aria-label="501" class="calibre17" epub:type="pagebreak" id="Page_501" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c13">
      </span>
      <span class="calibre">
       13
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Demystifying C++ I/O
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c13-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c13-list-0001">
         <li class="calibre9" id="c13-li-0001">
          The concept of streams
         </li>
         <li class="calibre9" id="c13-li-0002">
          How to use streams for input and output of data
         </li>
         <li class="calibre9" id="c13-li-0003">
          The available standard streams provided by the Standard Library
         </li>
         <li class="calibre9" id="c13-li-0004">
          How to use the filesystem support library
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c13-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-149">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c13-sec-0003">
        </span>
        <p class="calibre25" id="c13-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c13-para-0004">
      A program's fundamental job is to accept input and produce output. A program that produces no output of any sort would not be very useful. All languages provide some mechanism for I/O, either as a built-in part of the language or through an OS-specific API. A good I/O system is both flexible and easy to use. Flexible I/O systems support input and output through a variety of devices, such as files and the user console. Files could be standard files but could also be data coming from a variety of sources such as Internet of Things (IoT) devices, web services, and more. It could be weather data from a weather device or stock values from a stockbroker web service. Flexible I/O systems also support reading and writing of different types of data. I/O is error-prone because data coming from a user can be incorrect or the underlying filesystem or other data source can be inaccessible. Thus, a good I/O system is also capable of handling error conditions.
     </p>
     <p class="calibre13" id="c13-para-0005">
      If you are familiar with the C language, you have undoubtedly used
      <code class="calibre21">
       printf
      </code>
      (
      <code class="calibre21">
       )
      </code>
      and
      <code class="calibre21">
       scanf()
      </code>
      . As I/O mechanisms,
      <code class="calibre21">
       printf()
      </code>
      and
      <code class="calibre21">
       scanf()
      </code>
      are certainly flexible. Through escape codes and variable placeholders (similar to format specifiers and replacement fields for
      <code class="calibre21">
       std::format()
      </code>
      ,
      <span aria-label="502" class="calibre20" epub:type="pagebreak" id="Page_502" role="doc-pagebreak">
      </span>
      <code class="calibre21">
       print()
      </code>
      , and
      <code class="calibre21">
       println()
      </code>
      as discussed in
      <a class="calibre5" href="c02.xhtml">
       Chapter 2
      </a>
      , “Working with Strings and String Views”), they can be customized to read in specially formatted data or output any value that the formatting codes permit. Supported types are limited to integer/character values, floating-point values, and strings. However,
      <code class="calibre21">
       printf()
      </code>
      and
      <code class="calibre21">
       scanf()
      </code>
      falter on other measures of good I/O systems. They do not handle errors particularly well. For example, if you tell them to interpret a floating-point number as an integer, they will happily do so. Additionally, they are not flexible enough to handle custom data types, they are not type safe, and in an object-oriented language like C++, they are not at all object oriented.
     </p>
     <p class="calibre13" id="c13-para-0006">
      C++ provides a more refined, more flexible, and object-oriented approach to I/O.
      <i class="calibre18">
       Streams
      </i>
      are encapsulated in classes that result in a user-friendly and safe solution. In this chapter, you will first learn what streams are and then learn how to use streams for data output and input. You will also learn how to use the stream mechanism to read from various sources and write to various destinations, such as the user console, files, and even strings. This chapter covers the most commonly used I/O features.
     </p>
     <p class="calibre13" id="c13-para-0007">
      Almost all examples in this book use
      <code class="calibre21">
       print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      to print text to the user console. An alternative is to use the I/O streaming functionality discussed in this chapter. I recommend using
      <code class="calibre21">
       print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      instead of streaming to standard output, as the former is easier to read, more compact, and more performant. However, this chapter discusses I/O streaming in detail, as it's still important to know how it works in C++ because you'll undoubtedly have to work with code that uses I/O streaming.
     </p>
     <p class="calibre13" id="c13-para-0008">
      The last part of this chapter discusses the filesystem support library provided by the C++ Standard Library. This library allows you to work with paths, directories, and files, and it nicely complements the mechanisms provided for I/O by the streams.
     </p>
    </section>
    <section aria-labelledby="head-2-150" class="calibre2">
     <span class="calibre" id="c13-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-150">
      USING STREAMS
     </h2>
     <p class="calibre13" id="c13-para-0009">
      The stream metaphor takes a bit of getting used to. At first, streams may seem more complex than traditional C-style I/O, such as
      <code class="calibre21">
       printf()
      </code>
      . In reality, they seem complicated initially only because there is a deeper metaphor behind streams than there is behind
      <code class="calibre21">
       printf()
      </code>
      . Don't worry, though: after a few examples, everything will be clear.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-287">
       What Is a Stream, Anyway?
      </h3>
      <p class="calibre13" id="c13-para-0010">
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       , “A Crash Course in C++ and the Standard Library,” compares the
       <code class="calibre21">
        cout
       </code>
       stream to a laundry chute for data. You throw some variables down the stream, and they are written to the user's screen, or
       <i class="calibre18">
        console
       </i>
       . More generally, all streams can be viewed as data chutes. Streams vary in their direction and their associated source or destination. For example, the
       <code class="calibre21">
        cout
       </code>
       stream that you are already familiar with is an output stream, so its direction is “out.” It writes data to the console, so its associated destination is “console.” The
       <code class="calibre21">
        c
       </code>
       in
       <code class="calibre21">
        cout
       </code>
       does not stand for “console” as you might expect but stands for “character” as it's a character-based stream. There is another standard stream called
       <code class="calibre21">
        cin
       </code>
       that accepts input from the user. Its direction is “in,” and its associated source is “console.” As with
       <code class="calibre21">
        cout
       </code>
       , the
       <code class="calibre21">
        c
       </code>
       in
       <code class="calibre21">
        cin
       </code>
       stands for “character.” Both
       <code class="calibre21">
        cout
       </code>
       and
       <code class="calibre21">
        cin
       </code>
       are predefined instances of streams available in the
       <code class="calibre21">
        std
       </code>
       namespace. The following table gives a brief description of all predefined streams defined in
       <code class="calibre21">
        &lt;iostream&gt;
       </code>
       .
      </p>
      <p class="calibre13" id="c13-para-0011">
       <span aria-label="503" class="calibre20" epub:type="pagebreak" id="Page_503" role="doc-pagebreak">
       </span>
       Streams can be
       <i class="calibre18">
        buffered
       </i>
       or
       <i class="calibre18">
        unbuffered
       </i>
       . The difference between them is that a buffered stream does not immediately send the data to the destination. Instead, it buffers, that is collects, incoming data and then sends it in blocks. An unbuffered stream, on the other hand, immediately sends the data to the destination. Buffering is usually done to improve performance, as certain destinations, such as files, perform better when writing bigger blocks at once. Note that you can always force a buffered stream to send all its currently buffered data to the destination by
       <i class="calibre18">
        flushing
       </i>
       its buffer using the
       <code class="calibre21">
        flush()
       </code>
       member function. Buffering and flushing is discussed in a bit more detail later in this chapter.
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          STREAM
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           cin
          </span>
         </td>
         <td class="bgcolor">
          An input stream, reads data from the “input console”
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           cout
          </span>
         </td>
         <td class="bgcolor">
          A buffered output stream, writes data to the “output console”
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           cerr
          </span>
         </td>
         <td class="bgcolor">
          An unbuffered output stream, writes data to the “error console,” which is often the same as the “output console”
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           clog
          </span>
         </td>
         <td class="bgcolor">
          A buffered version of
          <span class="calibre21">
           cerr
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       Remember from
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       that
       <code class="calibre21">
        std::print()
       </code>
       and
       <code class="calibre21">
        println()
       </code>
       by default print to
       <code class="calibre21">
        cout
       </code>
       but that you can pass a stream as first argument to these functions if you want to print to a different stream, for example:
      </p>
      <pre class="calibre26" id="c13-code-0001"><code class="calibre21">println(<b class="calibre14">cerr,</b> "This is an error printed to cerr.");</code></pre>
      <p class="calibre13">
       There are also wide-character,
       <code class="calibre21">
        wchar_t
       </code>
       versions available of these streams that have names starting with
       <code class="calibre21">
        w
       </code>
       :
       <code class="calibre21">
        wcin
       </code>
       ,
       <code class="calibre21">
        wcout
       </code>
       ,
       <code class="calibre21">
        wcerr
       </code>
       , and
       <code class="calibre21">
        wclog
       </code>
       . Wide characters can be used to work with languages that have more characters than, for example, English, such as Chinese. Wide characters are discussed in
       <a class="calibre5" href="c21.xhtml">
        Chapter 21
       </a>
       , “String Localization and Regular Expressions.”
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c13-para-0015">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Every input stream has an associated source. Every output stream has an associated destination
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Another important aspect of streams is that they include data but also have a
       <i class="calibre18">
        current position
       </i>
       . The current position is the position in the stream where the next read or write operation will take place.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c13-para-0017">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Graphical user interface applications normally do not have a console; that is, if you write something to
          </i>
          <code class="calibre21">
           cout
          </code>
          <i class="calibre18">
           , the user will not see it. If you are writing a library, you should never assume the existence of
          </i>
          <code class="calibre21">
           cout
          </code>
          <i class="calibre18">
           ,
          </i>
          <code class="calibre21">
           cin
          </code>
          <i class="calibre18">
           ,
          </i>
          <code class="calibre21">
           cerr
          </code>
          <i class="calibre18">
           , or
          </i>
          <code class="calibre21">
           clog
          </code>
          <i class="calibre18">
           because you never know whether your library will be used in a console or a GUI application.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <span aria-label="504" class="calibre20" epub:type="pagebreak" id="Page_504" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-288">
       Stream Sources and Destinations
      </h3>
      <p class="calibre13" id="c13-para-0018">
       Streams as a concept can be applied to any object that accepts data or emits data. You could write a stream-based network class or stream-based access to a Musical Instrument Digital Interface (MIDI) instrument. In C++, there are four common sources and destinations for streams: consoles, files, strings, and fixed buffer arrays. Fixed buffer array support is introduced with C++23.
      </p>
      <p class="calibre13" id="c13-para-0019">
       You have already seen many examples of user, or console, streams. Console input streams make programs interactive by allowing input from the user at run time. Console output streams provide feedback to the user and output results.
      </p>
      <p class="calibre13" id="c13-para-0020">
       File streams, as the name implies, read data from and write data to a filesystem. File input streams are useful for reading configuration data and saved files or for batch processing file-based data. File output streams are useful for saving state and providing output. If you are familiar with C-style input and output, then file streams subsume the functionality of the C functions
       <code class="calibre21">
        fprintf()
       </code>
       ,
       <code class="calibre21">
        fwrite()
       </code>
       , and
       <code class="calibre21">
        fputs()
       </code>
       for output, and
       <code class="calibre21">
        fscanf()
       </code>
       ,
       <code class="calibre21">
        fread()
       </code>
       , and
       <code class="calibre21">
        fgets()
       </code>
       for input. As these C-style functions are not recommended in C++, they are not further discussed.
      </p>
      <p class="calibre13" id="c13-para-0021">
       String streams are an application of the stream metaphor to the string type. With a string stream, you can treat character data just as you would treat any other stream. For the most part, this is merely a handy syntax for functionality that could be handled through member functions on the
       <code class="calibre21">
        string
       </code>
       class. However, using stream syntax provides opportunities for optimization and can be far more convenient and more efficient than direct use of the
       <code class="calibre21">
        string
       </code>
       class. String streams subsume the functionality of
       <code class="calibre21">
        sprintf()
       </code>
       ,
       <code class="calibre21">
        sprintf_s()
       </code>
       ,
       <code class="calibre21">
        sscanf()
       </code>
       , and other forms of C-style string-formatting functions, not further discussed in this C++ book.
      </p>
      <p class="calibre13" id="c13-para-0022">
       The streams working with fixed buffer arrays allow you to use the stream metaphor on any block of memory, independently of how memory for that buffer was allocated.
      </p>
      <p class="calibre13" id="c13-para-0023">
       The rest of this section deals with console streams (
       <code class="calibre21">
        cin
       </code>
       and
       <code class="calibre21">
        cout
       </code>
       ). Examples of file, string, and fixed buffer array streams are provided later in this chapter. Other types of streams, such as printer output or network I/O, are often platform dependent, so they are not covered in this book.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-289">
       Output with Streams
      </h3>
      <p class="calibre13" id="c13-para-0024">
       Output using streams is introduced in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       . This section briefly revisits some of the basics and introduces material that is more advanced.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0010">
       </span>
       <h4 class="calibre29" id="head-4-233">
        Output Basics
       </h4>
       <p class="calibre13" id="c13-para-0025">
        Output streams are defined in &lt;
        <code class="calibre21">
         ostream
        </code>
        &gt;. There is also &lt;
        <code class="calibre21">
         iostream
        </code>
        &gt;, which in turn includes the functionality for both input streams and output streams. &lt;
        <code class="calibre21">
         iostream
        </code>
        &gt; also declares all predefined stream instances:
        <code class="calibre21">
         cout
        </code>
        ,
        <code class="calibre21">
         cin
        </code>
        ,
        <code class="calibre21">
         cerr
        </code>
        ,
        <code class="calibre21">
         clog
        </code>
        , and the wide versions.
       </p>
       <p class="calibre13">
        The
        <code class="calibre21">
         &lt;&lt;
        </code>
        operator is the simplest way to use output streams. C++ basic types, such as
        <code class="calibre21">
         int
        </code>
        s, pointers,
        <code class="calibre21">
         double
        </code>
        s, and characters, can be output using
        <code class="calibre21">
         &lt;&lt;
        </code>
        . In addition, the C++
        <code class="calibre21">
         string
        </code>
        class is compatible with
        <code class="calibre21">
         &lt;&lt;
        </code>
        , and C-style strings are properly output as well. The following are some examples of using
        <code class="calibre21">
         &lt;&lt;
        </code>
        :
       </p>
       <pre class="calibre26" id="c13-code-0002"><code class="calibre21">int i { 7 };</code>
<code class="calibre21">cout &lt;&lt; i &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<span aria-label="505" class="calibre20" epub:type="pagebreak" id="Page_505" role="doc-pagebreak"></span><code class="calibre21">char ch { 'a' };</code>
<code class="calibre21">cout &lt;&lt; ch &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<code class="calibre21">string myString { "Hello World." };</code>
<code class="calibre21">cout &lt;&lt; myString &lt;&lt; endl;</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c13-code-0003"><code class="calibre21">7</code>
<code class="calibre21">a</code>
<code class="calibre21">Hello World.</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         cout
        </code>
        stream is the built-in stream for writing to the console, or
        <i class="calibre18">
         standard output
        </i>
        . You can “chain” uses of
        <code class="calibre21">
         &lt;&lt;
        </code>
        together to output multiple pieces of data. This is because
        <code class="calibre21">
         operator&lt;&lt;
        </code>
        returns a reference to the stream as its result, so you can immediately use
        <code class="calibre21">
         &lt;&lt;
        </code>
        again on the same stream. Here is an example:
       </p>
       <pre class="calibre26" id="c13-code-0004"><code class="calibre21">int j { 11 };</code>
<code class="calibre21">cout &lt;&lt; "The value of j is " &lt;&lt; j &lt;&lt; "!" &lt;&lt; endl;</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c13-code-0005"><code class="calibre21">The value of j is 11!</code></pre>
       <p class="calibre13">
        C++ streams correctly parse C-style escape sequences, such as strings that contain
        <code class="calibre21">
         \n
        </code>
        . You can also use
        <code class="calibre21">
         std::endl
        </code>
        to start a new line. The difference between using
        <code class="calibre21">
         \n
        </code>
        and
        <code class="calibre21">
         endl
        </code>
        is that
        <code class="calibre21">
         \n
        </code>
        just starts a new line while
        <code class="calibre21">
         endl
        </code>
        also flushes the buffer. Watch out with
        <code class="calibre21">
         endl
        </code>
        because too many flushes might hurt performance. The following example uses
        <code class="calibre21">
         endl
        </code>
        to output and flush several lines of text with just one line of code:
       </p>
       <pre class="calibre26" id="c13-code-0006"><code class="calibre21">cout &lt;&lt; "Line 1" &lt;&lt; endl &lt;&lt; "Line 2" &lt;&lt; endl &lt;&lt; "Line 3" &lt;&lt; endl;</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c13-code-0007"><code class="calibre21">Line 1</code>
<code class="calibre21">Line 2</code>
<code class="calibre21">Line 3</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c13-para-0033">
           <b class="calibre14">
            WARNING
           </b>
           <code class="calibre21">
            endl
           </code>
           <i class="calibre18">
            flushes the destination buffer, so use it judiciously in performance critical code, such as tight loops.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0012">
       </span>
       <h4 class="calibre29" id="head-4-234">
        Member Functions of Output Streams
       </h4>
       <p class="calibre13" id="c13-para-0034">
        The
        <code class="calibre21">
         &lt;&lt;
        </code>
        operator is, without a doubt, the most useful part of output streams. However, there is additional functionality to be explored. If you look through the contents of
        <code class="calibre21">
         &lt;ostream&gt;
        </code>
        , you'll see many lines of overloaded definitions of the
        <code class="calibre21">
         &lt;&lt;
        </code>
        operator to support outputting all kinds of different data types. You'll also find some useful public member functions.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0013">
        </span>
        <h5 class="calibre35" id="head-5-84">
         put() and write()
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          put()
         </code>
         and
         <code class="calibre21">
          write()
         </code>
         are
         <i class="calibre18">
          raw output member functions
         </i>
         . Instead of taking an object or variable that has some defined behavior for output,
         <code class="calibre21">
          put()
         </code>
         accepts a single character, while
         <code class="calibre21">
          write()
         </code>
         accepts a character array. The data passed to these member functions is output as is, without any special formatting
         <span aria-label="506" class="calibre20" epub:type="pagebreak" id="Page_506" role="doc-pagebreak">
         </span>
         or processing. For example, the following code snippet shows how to output a C-style string to the console without using the
         <code class="calibre21">
          &lt;&lt;
         </code>
         operator:
        </p>
        <pre class="calibre26" id="c13-code-0008"><code class="calibre21">const char* test { "hello there" };</code>
<code class="calibre21">cout.write(test, strlen(test));</code></pre>
        <p class="calibre13">
         The next snippet shows how to write a single character to the console by using the
         <code class="calibre21">
          put()
         </code>
         member function:
        </p>
        <pre class="calibre26" id="c13-code-0009"><code class="calibre21">cout.put('a');</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0014">
        </span>
        <h5 class="calibre35" id="head-5-85">
         flush()
        </h5>
        <p class="calibre13">
         When you write to an output stream, the stream does not necessarily write the data to its destination right away. Most output streams
         <i class="calibre18">
          buffer
         </i>
         , or accumulate, data instead of writing it out as soon as it comes in. This is usually done to improve performance. Certain stream destinations, such as files, are much more performant if data is written in larger blocks, instead of, for example, character by character. The stream
         <i class="calibre18">
          flushes
         </i>
         , or writes out, the accumulated data, when one of the following conditions occurs:
        </p>
        <ul class="check" id="c13-list-0002">
         <li class="calibre9" id="c13-li-0005">
          An
          <code class="calibre21">
           endl
          </code>
          manipulator is encountered.
         </li>
         <li class="calibre9" id="c13-li-0006">
          The stream goes out of scope and is destructed.
         </li>
         <li class="calibre9" id="c13-li-0007">
          The stream buffer is full.
         </li>
         <li class="calibre9" id="c13-li-0008">
          You explicitly tell the stream to flush its buffer.
         </li>
         <li class="calibre9" id="c13-li-0009">
          Input is requested from a corresponding input stream (that is, when you make use of
          <code class="calibre21">
           cin
          </code>
          for input,
          <code class="calibre21">
           cout
          </code>
          will flush). In the section “
          <a class="calibre5" href="#c13-sec-0036">
           File Streams
          </a>
          ,” you will learn how to establish this type of link.
         </li>
        </ul>
        <p class="calibre13">
         One way to explicitly tell a stream to flush is to call its
         <code class="calibre21">
          flush()
         </code>
         member function, as in the following code:
        </p>
        <pre class="calibre26" id="c13-code-0010"><code class="calibre21">cout &lt;&lt; "abc";</code>
<code class="calibre21">cout.flush();    <span class="color">// abc is written to the console.</span></code>
<code class="calibre21">cout &lt;&lt; "def";</code>
<code class="calibre21">cout &lt;&lt; endl;    <span class="color">// def is written to the console.</span></code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c13-para-0040">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Not all output streams are buffered. The
            </i>
            <code class="calibre21">
             cerr
            </code>
            <i class="calibre18">
             stream, for example, does not buffer its output.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-235">
        Handling Output Errors
       </h4>
       <p class="calibre13" id="c13-para-0041">
        Output errors can arise in a variety of situations. Perhaps you are trying to open a non-existing file. Maybe a disk error has prevented a write operation from succeeding, for example, because the disk is full. None of the streams' code you have seen up until this point has considered these possibilities, mainly for brevity. However, it is vital that you address any error conditions that occur.
       </p>
       <p class="calibre13">
        <span aria-label="507" class="calibre20" epub:type="pagebreak" id="Page_507" role="doc-pagebreak">
        </span>
        When a stream is in its normal usable state, it is said to be “good.” The
        <code class="calibre21">
         good()
        </code>
        member function can be called directly on a stream to determine whether the stream is currently good:
       </p>
       <pre class="calibre26" id="c13-code-0011"><code class="calibre21">if (cout.good()) {</code>
<code class="calibre21">    cout &lt;&lt; "All good" &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <code class="calibre21">
         good()
        </code>
        provides an easy way to obtain basic information about the validity of the stream, but it does not tell you why the stream is unusable. There is a member function called
        <code class="calibre21">
         bad()
        </code>
        that provides a bit more information. If
        <code class="calibre21">
         bad()
        </code>
        returns
        <code class="calibre21">
         true
        </code>
        , it means that a fatal error has occurred (as opposed to any nonfatal condition like end-of-file,
        <code class="calibre21">
         eof()
        </code>
        ). Another member function,
        <code class="calibre21">
         fail()
        </code>
        , returns
        <code class="calibre21">
         true
        </code>
        if the most recent operation has failed; however, it doesn't say anything about the next operation, which can either succeed or fail as well. For example, after calling
        <code class="calibre21">
         flush()
        </code>
        on an output stream, you could call
        <code class="calibre21">
         fail()
        </code>
        to make sure the flush was successful:
       </p>
       <pre class="calibre26" id="c13-code-0012"><code class="calibre21">cout.flush();</code>
<code class="calibre21">if (cout.fail()) {</code>
<code class="calibre21">    cerr &lt;&lt; "Unable to flush to standard out" &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Streams have a conversion operator to convert to type
        <code class="calibre21">
         bool
        </code>
        . This conversion operator returns the same as calling
        <code class="calibre21">
         !fail()
        </code>
        . So, the previous code snippet can be rewritten as follows:
       </p>
       <pre class="calibre26" id="c13-code-0013"><code class="calibre21">cout.flush();</code>
<code class="calibre21"><b class="calibre14">if (!cout) {</b></code>
<code class="calibre21">    cerr &lt;&lt; "Unable to flush to standard out" &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c13-para-0045">
        Important to know is that both
        <code class="calibre21">
         good()
        </code>
        and
        <code class="calibre21">
         fail()
        </code>
        return
        <code class="calibre21">
         false
        </code>
        if the end-of-file is reached. The relation is as follows:
        <code class="calibre21">
         good() == (!fail() &amp;&amp; !eof())
        </code>
        .
       </p>
       <p class="calibre13">
        You can also tell the streams to throw exceptions when a failure occurs. You then write a
        <code class="calibre21">
         catch
        </code>
        handler to catch
        <code class="calibre21">
         ios_base::failure
        </code>
        exceptions, on which you can use the
        <code class="calibre21">
         what()
        </code>
        member function to get a description of the error, and the
        <code class="calibre21">
         code()
        </code>
        member function to get the error code. However, whether or not you get useful information depends on the Standard Library implementation that you use.
       </p>
       <pre class="calibre26" id="c13-code-0014"><code class="calibre21">cout.exceptions(ios::failbit | ios::badbit | ios::eofbit);</code>
<code class="calibre21">try {</code>
<code class="calibre21">    cout &lt;&lt; "Hello World." &lt;&lt; endl;</code>
<code class="calibre21">} catch (const ios_base::failure&amp; ex) {</code>
<code class="calibre21">    cerr &lt;&lt; "Caught exception: " &lt;&lt; ex.what()</code>
<code class="calibre21">         &lt;&lt; ", error code = " &lt;&lt; ex.code() &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        To reset the error state of a stream, use
        <code class="calibre21">
         clear()
        </code>
        :
       </p>
       <pre class="calibre26" id="c13-code-0015"><code class="calibre21">cout.clear();</code></pre>
       <p class="calibre13" id="c13-para-0048">
        Error checking is performed less frequently for console output streams than for file output or input streams. The member functions discussed here apply for other types of streams as well and are revisited later as each type is discussed.
       </p>
      </section>
      <span aria-label="508" class="calibre20" epub:type="pagebreak" id="Page_508" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0017">
       </span>
       <h4 class="calibre29" id="head-4-236">
        Output Manipulators
       </h4>
       <p class="calibre13" id="c13-para-0049">
        One of the unusual features of streams is that you can throw more than just data down the chute. C++ streams also recognize
        <i class="calibre18">
         manipulators
        </i>
        , objects that make a change to the behavior of the stream instead of, or in addition to, providing data for the stream to work with.
       </p>
       <p class="calibre13">
        You have already seen one manipulator:
        <code class="calibre21">
         endl
        </code>
        . The
        <code class="calibre21">
         endl
        </code>
        manipulator encapsulates data and behavior. It tells the stream to output an end-of-line sequence and to flush its buffer. The following is a non-exhaustive list of some other useful manipulators, many of which are defined in
        <code class="calibre21">
         &lt;ios&gt;
        </code>
        and
        <code class="calibre21">
         &lt;iomanip&gt;
        </code>
        . An example after this list shows how to use them:
       </p>
       <ul class="check" id="c13-list-0003">
        <li class="calibre9" id="c13-li-0010">
         <code class="calibre21">
          boolalpha
         </code>
         and
         <code class="calibre21">
          noboolalpha
         </code>
         : Tells the stream to output
         <code class="calibre21">
          bool
         </code>
         values as
         <i class="calibre18">
          true
         </i>
         and
         <i class="calibre18">
          false
         </i>
         (
         <code class="calibre21">
          boolalpha
         </code>
         ) or
         <i class="calibre18">
          1
         </i>
         and
         <i class="calibre18">
          0
         </i>
         (
         <code class="calibre21">
          noboolalpha
         </code>
         ). The default is
         <code class="calibre21">
          noboolalpha
         </code>
         .
        </li>
        <li class="calibre9" id="c13-li-0011">
         <code class="calibre21">
          hex
         </code>
         ,
         <code class="calibre21">
          oct
         </code>
         , and
         <code class="calibre21">
          dec
         </code>
         : Outputs numbers in hexadecimal, octal, and base 10, respectively.
        </li>
        <li class="calibre9" id="c13-li-0012">
         <code class="calibre21">
          fixed
         </code>
         ,
         <code class="calibre21">
          scientific
         </code>
         , and
         <code class="calibre21">
          defaultfloat
         </code>
         : Outputs fractional numbers using fixed, scientific, or default formatting, respectively.
        </li>
        <li class="calibre9" id="c13-li-0013">
         <code class="calibre21">
          setprecision
         </code>
         : Sets the number of decimal places that are output for fractional numbers using fixed or scientific formatting, or else the total number of digits to output. This is a parameterized manipulator (meaning that it takes an argument).
        </li>
        <li class="calibre9" id="c13-li-0014">
         <code class="calibre21">
          setw
         </code>
         : Sets the field width for outputting data. This is a parameterized manipulator.
        </li>
        <li class="calibre9" id="c13-li-0015">
         <code class="calibre21">
          setfill
         </code>
         : Sets a character as the new fill character for the stream. The fill character pads output according to the width set by
         <code class="calibre21">
          setw
         </code>
         . This is a parameterized manipulator.
        </li>
        <li class="calibre9" id="c13-li-0016">
         <code class="calibre21">
          showpoint
         </code>
         and
         <code class="calibre21">
          noshowpoint
         </code>
         : Forces the stream to always or never show the decimal point for floating-point numbers with no fractional part.
        </li>
        <li class="calibre9" id="c13-li-0017">
         <code class="calibre21">
          put_money
         </code>
         : A parameterized manipulator that writes a formatted monetary value to a stream.
        </li>
        <li class="calibre9" id="c13-li-0018">
         <code class="calibre21">
          put_time
         </code>
         : A parameterized manipulator that writes a formatted time to a stream.
        </li>
        <li class="calibre9" id="c13-li-0019">
         <code class="calibre21">
          quoted
         </code>
         : A parameterized manipulator that encloses a given string with quotes and escapes embedded quotes.
        </li>
       </ul>
       <p class="calibre13">
        All of these manipulators stay in effect for subsequent output to the stream until they are reset, except
        <code class="calibre21">
         setw
        </code>
        , which is active for only the next single output. The following example uses several of these manipulators to customize its output:
       </p>
       <pre class="calibre26" id="c13-code-0016"><code class="calibre21"><span class="color">// Boolean values</span></code>
<code class="calibre21">bool myBool { true };</code>
<code class="calibre21">cout &lt;&lt; "This is the default: " &lt;&lt; myBool &lt;&lt; endl;</code>
<code class="calibre21">cout &lt;&lt; "This should be true: " &lt;&lt; boolalpha &lt;&lt; myBool &lt;&lt; endl;</code>
<code class="calibre21">cout &lt;&lt; "This should be 1: " &lt;&lt; noboolalpha &lt;&lt; myBool &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Simulate println-style "{:6}" with streams</span></code>
<code class="calibre21">int i { 123 };</code>
<code class="calibre21">println("This should be '   123': {:6}", i);</code>
<code class="calibre21">cout &lt;&lt; "This should be '   123': " &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<span aria-label="509" class="calibre20" epub:type="pagebreak" id="Page_509" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Simulate println-style "{:0&gt;6}" with streams</span></code>
<code class="calibre21">println("This should be '000123': {:0&gt;6}", i);</code>
<code class="calibre21">cout &lt;&lt; "This should be '000123': " &lt;&lt; setfill('0') &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Fill with *</span></code>
<code class="calibre21">cout &lt;&lt; "This should be '***123': " &lt;&lt; setfill('*') &lt;&lt; setw(6) &lt;&lt; i &lt;&lt; endl;</code>
<code class="calibre21"><span class="color">// Reset fill character</span></code>
<code class="calibre21">cout &lt;&lt; setfill(' ');</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Floating-point values</span></code>
<code class="calibre21">double dbl { 1.452 };</code>
<code class="calibre21">double dbl2 { 5 };</code>
<code class="calibre21">cout &lt;&lt; "This should be ' 5': " &lt;&lt; setw(2) &lt;&lt; noshowpoint &lt;&lt; dbl2 &lt;&lt; endl;</code>
<code class="calibre21">cout &lt;&lt; "This should be @@1.452: " &lt;&lt; setw(7) &lt;&lt; setfill('@') &lt;&lt; dbl &lt;&lt; endl;</code>
<code class="calibre21"><span class="color">// Reset fill character</span></code>
<code class="calibre21">cout &lt;&lt; setfill(' ');</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Instructs cout to start formatting numbers according to your location.</span></code>
<code class="calibre21"><span class="color">// <a class="calibre5" href="c21.xhtml">Chapter 21</a> explains the details of the imbue() call and the locale object.</span></code>
<code class="calibre21">cout.imbue(locale { "" });</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Format numbers according to your location</span></code>
<code class="calibre21">cout &lt;&lt; "This is 1234567 formatted according to your location: " &lt;&lt; 1234567</code>
<code class="calibre21">     &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Monetary value. What exactly a monetary value means depends on your</span></code>
<code class="calibre21"><span class="color">// location. For example, in the USA, a monetary value of 120000 means 120000</span></code>
<code class="calibre21"><span class="color">// dollar cents, which is 1200.00 dollars.</span></code>
<code class="calibre21">cout &lt;&lt; "This should be a monetary value of 120000, "</code>
<code class="calibre21">     &lt;&lt; "formatted according to your location: "</code>
<code class="calibre21">     &lt;&lt; put_money("120000") &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Date and time</span></code>
<code class="calibre21">time_t t_t { time(nullptr) };     <span class="color">// Get current system time.</span></code>
<code class="calibre21">tm t { *localtime(&amp;t_t) };        <span class="color">// Convert to local time.</span></code>
<code class="calibre21">cout &lt;&lt; "This should be the current date and time "</code>
<code class="calibre21">     &lt;&lt; "formatted according to your location: "</code>
<code class="calibre21">     &lt;&lt; put_time(&amp;t, "%c") &lt;&lt; endl;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Quoted string</span></code>
<code class="calibre21">cout &lt;&lt; "This should be: \"Quoted string with \\\"embedded quotes\\\".\": "</code>
<code class="calibre21">     &lt;&lt; quoted("Quoted string with \"embedded quotes\".") &lt;&lt; endl;</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c13-para-0053">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            With Microsoft Visual C++, this example might give you a security-related error or warning on the call to
           </i>
           <code class="calibre21">
            localtime()
           </code>
           <i class="calibre18">
            . You can either switch to using
           </i>
           <code class="calibre21">
            localtime_s()
           </code>
           <i class="calibre18">
            or temporarily disable this warning using a
           </i>
           <code class="calibre21">
            #pragma
           </code>
           <i class="calibre18">
            . See the downloadable source code archive
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        If you don't care for the concept of manipulators, you can usually get by without them. Streams provide much of the same functionality through equivalent member functions like
        <code class="calibre21">
         precision()
        </code>
        . For example, take the following line:
       </p>
       <pre class="calibre26" id="c13-code-0017"><code class="calibre21">cout &lt;&lt; "This should be '1.2346': " &lt;&lt; setprecision(5) &lt;&lt; 1.23456789 &lt;&lt; endl;</code></pre>
       <p class="calibre13">
        <span aria-label="510" class="calibre20" epub:type="pagebreak" id="Page_510" role="doc-pagebreak">
        </span>
        This can be converted to use a member function call as follows. The advantage of the member function calls is that they return the previous value, allowing you to restore it, if needed.
       </p>
       <pre class="calibre26" id="c13-code-0018"><code class="calibre21">cout.precision(5);</code>
<code class="calibre21">cout &lt;&lt; "This should be '1.2346': " &lt;&lt; 1.23456789 &lt;&lt; endl;</code></pre>
       <p class="calibre13" id="c13-para-0056">
        For a detailed description of all stream member functions and manipulators, consult your favorite Standard Library Reference.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0019">
      </span>
      <h3 class="calibre27" id="head-3-290">
       Input with Streams
      </h3>
      <p class="calibre13" id="c13-para-0057">
       Input streams provide a simple way to read in structured or unstructured data. In this section, the techniques for input are discussed within the context of
       <code class="calibre21">
        cin
       </code>
       , the console input stream.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0020">
       </span>
       <h4 class="calibre29" id="head-4-237">
        Input Basics
       </h4>
       <p class="calibre13">
        There are two easy ways to read data by using an input stream. The first is an analog of the
        <code class="calibre21">
         &lt;&lt;
        </code>
        operator that outputs data to an output stream. The corresponding operator for reading data is
        <code class="calibre21">
         &gt;&gt;
        </code>
        . When you use
        <code class="calibre21">
         &gt;&gt;
        </code>
        to read data from an input stream, the variable you provide is the storage for the received value. For example, the following program reads one word from the user and puts it into a string. Then the string is output back to the console:
       </p>
       <pre class="calibre26" id="c13-code-0019"><code class="calibre21">string userInput;</code>
<code class="calibre21">cin &gt;&gt; userInput;</code>
<code class="calibre21">println("User input was {}.", userInput);</code></pre>
       <p class="calibre13">
        By default, the
        <code class="calibre21">
         &gt;&gt;
        </code>
        operator tokenizes values according to whitespace. For example, if a user runs the previous program and enters
        <code class="calibre21">
         hello there
        </code>
        as input, only the characters up to the first whitespace character (the space character in this instance) are captured into the
        <code class="calibre21">
         userInput
        </code>
        variable. The output would be as follows:
       </p>
       <pre class="calibre26" id="c13-code-0020"><code class="calibre21">User input was hello.</code></pre>
       <p class="calibre13">
        One solution to include whitespace in the input is to use
        <code class="calibre21">
         get()
        </code>
        , which is discussed later in this chapter.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c13-para-0061">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Whitespace characters in C++ are space (
            <code class="calibre21">
             <i class="calibre18">
              '
             </i>
             '
            </code>
            ), form feed
           </i>
           (
           <code class="calibre21">
            '\f'
           </code>
           <i class="calibre18">
            ), line feed (
           </i>
           <code class="calibre21">
            '\n'
           </code>
           <i class="calibre18">
            ), carriage return (
           </i>
           <code class="calibre21">
            '\r'
           </code>
           <i class="calibre18">
            ), horizontal tab (
           </i>
           <code class="calibre21">
            '\t'
           </code>
           <i class="calibre18">
            ), and vertical tab (
           </i>
           <code class="calibre21">
            '\v'
           </code>
           <i class="calibre18">
            ).
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        The
        <code class="calibre21">
         &gt;&gt;
        </code>
        operator works with different variable types, just like the
        <code class="calibre21">
         &lt;&lt;
        </code>
        operator. For example, to read an integer, the code differs only in the type of the variable:
       </p>
       <pre class="calibre26" id="c13-code-0021"><code class="calibre21"><b class="calibre14">int userInput;</b></code>
<code class="calibre21">cin &gt;&gt; userInput;</code>
<code class="calibre21">println("User input was {}.", userInput);</code></pre>
       <p class="calibre13">
        You can use input streams to read in multiple values, mixing and matching types as necessary. For example, the following function, an excerpt from a restaurant reservation system, asks the user for a last name and the number of people in their party:
       </p>
       <pre class="calibre26" id="c13-code-0022"><code class="calibre21">void getReservationData()</code>
<code class="calibre21">{</code>
<span aria-label="511" class="calibre20" epub:type="pagebreak" id="Page_511" role="doc-pagebreak"></span><code class="calibre21">    string guestName;</code>
<code class="calibre21">    int partySize;</code>
<code class="calibre21">    print("Name and number of guests: ");</code>
<code class="calibre21">    cin &gt;&gt; guestName &gt;&gt; partySize;</code>
<code class="calibre21">    println("Thank you, {}.", guestName);</code>
<code class="calibre21">    if (partySize &gt; 10) {</code>
<code class="calibre21">        println("An extra gratuity will apply.");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Remember that the
        <code class="calibre21">
         &gt;&gt;
        </code>
        operator tokenizes values according to whitespace, so
        <code class="calibre21">
         getReservationData()
        </code>
        does not allow you to enter a name with whitespace. A solution using
        <code class="calibre21">
         unget()
        </code>
        is discussed later in this chapter. Note also that the first use of
        <code class="calibre21">
         cout
        </code>
        does not explicitly flush the buffer using
        <code class="calibre21">
         endl
        </code>
        or
        <code class="calibre21">
         flush()
        </code>
        , but still, the text will be written to the console because the use of
        <code class="calibre21">
         cin
        </code>
        immediately flushes the
        <code class="calibre21">
         cout
        </code>
        buffer; they are linked together in this way.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c13-para-0065">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            If you get confused between
            <code class="calibre21">
             &lt;&lt;
            </code>
            and
            <code class="calibre21">
             &gt;&gt;
            </code>
            , just think of the angles as pointing toward their destination. In an output stream,
            <code class="calibre21">
             &lt;&lt;
            </code>
            points toward the stream itself because data is being sent to the stream. In an input stream,
            <code class="calibre21">
             &gt;&gt;
            </code>
            points toward the variables because data is being stored
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0023">
       </span>
       <h4 class="calibre29" id="head-4-238">
        Handling Input Errors
       </h4>
       <p class="calibre13">
        Input streams have a number of member functions to detect unusual circumstances. Most of the error conditions related to input streams occur when there is no data available to read. For example, the end of the stream (referred to as
        <i class="calibre18">
         end-of-file
        </i>
        , even for non–file streams) may have been reached. The most common way of querying the state of an input stream is to access it within a conditional statement. For example, the following loop keeps looping as long as
        <code class="calibre21">
         cin
        </code>
        remains in a good state. This pattern takes advantage of the fact that evaluating an input stream within a conditional context results in
        <code class="calibre21">
         true
        </code>
        only if the stream is not in any error state. Encountering an error causes the stream to evaluate to
        <code class="calibre21">
         false
        </code>
        . The underlying details of the conversion operations required to implement such behavior are explained in
        <a class="calibre5" href="c15.xhtml">
         Chapter 15
        </a>
        , “Overloading C++ Operators.”
       </p>
       <pre class="calibre26" id="c13-code-0023"><code class="calibre21">while (cin) { … }</code></pre>
       <p class="calibre13">
        You can input data at the same time:
       </p>
       <pre class="calibre26" id="c13-code-0024"><code class="calibre21">while (cin &gt;&gt; ch) { … }</code></pre>
       <p class="calibre13" id="c13-para-0068">
        The
        <code class="calibre21">
         good()
        </code>
        ,
        <code class="calibre21">
         bad()
        </code>
        , and
        <code class="calibre21">
         fail()
        </code>
        member functions can be called on input streams, just as on output streams. There is also an
        <code class="calibre21">
         eof()
        </code>
        member function that returns
        <code class="calibre21">
         true
        </code>
        if the stream has reached its end. Similar as for output streams, both
        <code class="calibre21">
         good()
        </code>
        and
        <code class="calibre21">
         fail()
        </code>
        return
        <code class="calibre21">
         false
        </code>
        if the end-of-file is reached. The relation is again as follows:
        <code class="calibre21">
         good() == (!fail() &amp;&amp; !eof())
        </code>
        .
       </p>
       <p class="calibre13" id="c13-para-0069">
        You should get into the habit of checking the stream state after reading data so that you can recover from bad input.
       </p>
       <p class="calibre13">
        The following program shows a common pattern for reading data from a stream and handling errors. The program reads numbers from standard input and displays their sum once end-of-file is reached. Note that in command-line environments, the end-of-file is indicated by the user typing a
        <span aria-label="512" class="calibre20" epub:type="pagebreak" id="Page_512" role="doc-pagebreak">
        </span>
        particular character. In Unix and Linux, it is
        <code class="calibre21">
         Control+D
        </code>
        ; in Windows it is
        <code class="calibre21">
         Control+Z
        </code>
        , both followed by
        <code class="calibre21">
         Enter
        </code>
        . The exact character is operating-system dependent, so you will need to know what your operating system requires.
       </p>
       <pre class="calibre26" id="c13-code-0025"><code class="calibre21">println("Enter numbers on separate lines to add.");</code>
<code class="calibre21">println("Use Control+D followed by Enter to finish (Control+Z in Windows).");</code>
<code class="calibre21">int sum { 0 };</code>
<code class="calibre21"> </code>
<code class="calibre21">if (!cin.good()) {</code>
<code class="calibre21">    println(cerr, "Standard input is in a bad state!");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">while (!cin.bad()) {</code>
<code class="calibre21">    int number;</code>
<code class="calibre21">    cin &gt;&gt; number;</code>
<code class="calibre21">    if (cin.good()) {</code>
<code class="calibre21">        sum += number;</code>
<code class="calibre21">    } else if (cin.eof()) {</code>
<code class="calibre21">        break; <span class="color">// Reached end-of-file.</span></code>
<code class="calibre21">    } else if (cin.fail()) {</code>
<code class="calibre21">        <span class="color">// Failure!</span></code>
<code class="calibre21">        cin.clear(); <span class="color">// Clear the failure state.</span></code>
<code class="calibre21">        string badToken;</code>
<code class="calibre21">        cin &gt;&gt; badToken; <span class="color">// Consume the bad input.</span></code>
<code class="calibre21">        println(cerr, "WARNING: Bad input encountered: {}", badToken);</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21">println("The sum is {}.", sum);</code></pre>
       <p class="calibre13">
        Here is some example output of this program. The
        <code class="calibre21">
         ^Z
        </code>
        characters in the output appear when
        <code class="calibre21">
         Control+Z
        </code>
        is pressed.
       </p>
       <pre class="calibre26" id="c13-code-0026"><code class="calibre21">Enter numbers on separate lines to add.</code>
<code class="calibre21">Use Control+D followed by Enter to finish (Control+Z in Windows).</code>
<code class="calibre21">1</code>
<code class="calibre21">2</code>
<code class="calibre21">test</code>
<code class="calibre21">WARNING: Bad input encountered: test</code>
<code class="calibre21">3</code>
<code class="calibre21">^Z</code>
<code class="calibre21">The sum is 6.</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0024">
       </span>
       <h4 class="calibre29" id="head-4-239">
        Input Member Functions
       </h4>
       <p class="calibre13" id="c13-para-0072">
        Just like output streams, input streams have several member functions that allow a lower level of access than the functionality provided by the more common
        <code class="calibre21">
         &gt;&gt;
        </code>
        operator.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0025">
        </span>
        <h5 class="calibre35" id="head-5-86">
         get()
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          get()
         </code>
         member function allows raw input of data from a stream. The simplest version of
         <code class="calibre21">
          get()
         </code>
         returns the next character in the stream, though other versions exist that read multiple characters at once.
         <code class="calibre21">
          get()
         </code>
         is most commonly used to avoid the automatic tokenization that occurs with
         <span aria-label="513" class="calibre20" epub:type="pagebreak" id="Page_513" role="doc-pagebreak">
         </span>
         the
         <code class="calibre21">
          &gt;&gt;
         </code>
         operator. For example, the following function reads a name, which can be made up of several words, from an input stream until the end of the stream is reached:
        </p>
        <pre class="calibre26" id="c13-code-0027"><code class="calibre21">string readName(istream&amp; stream)</code>
<code class="calibre21">{</code>
<code class="calibre21">    string name;</code>
<code class="calibre21">    while (stream) { <span class="color">// Or: while (!stream.fail()) {</span></code>
<code class="calibre21">        int next { stream.get() };</code>
<code class="calibre21">        if (!stream || next == std::char_traits&lt;char&gt;::eof())</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        name += static_cast&lt;char&gt;(next);<span class="color">// Append character.</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">    return name;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         There are several interesting observations to make about this
         <code class="calibre21">
          readName()
         </code>
         function:
        </p>
        <ul class="check" id="c13-list-0004">
         <li class="calibre9" id="c13-li-0020">
          Its parameter is a reference-to-non-
          <code class="calibre21">
           const
          </code>
          to an
          <code class="calibre21">
           istream
          </code>
          , not a reference-to-
          <code class="calibre21">
           const
          </code>
          . The member functions that read in data from a stream will change the actual stream (most notably, its position), so they are not
          <code class="calibre21">
           const
          </code>
          member functions. Thus, you cannot call them on a reference-to-
          <code class="calibre21">
           const
          </code>
          .
         </li>
         <li class="calibre9" id="c13-li-0021">
          The return value of
          <code class="calibre21">
           get()
          </code>
          is stored in an
          <code class="calibre21">
           int
          </code>
          , not in a
          <code class="calibre21">
           char
          </code>
          , because
          <code class="calibre21">
           get()
          </code>
          can return special non-character values such as
          <code class="calibre21">
           std::char_traits&lt;char&gt;::eof()
          </code>
          (end-of-file).
         </li>
         <li class="calibre9" id="c13-li-0022">
          Newline and other escape characters that are read by
          <code class="calibre21">
           get()
          </code>
          will appear in the
          <code class="calibre21">
           string
          </code>
          returned by
          <code class="calibre21">
           readName()
          </code>
          . If the
          <code class="calibre21">
           Ctrl+D
          </code>
          or
          <code class="calibre21">
           Ctrl+Z
          </code>
          isn't done at the beginning of a line, they too will appear in the returned
          <code class="calibre21">
           string
          </code>
          .
         </li>
        </ul>
        <p class="calibre13">
         <code class="calibre21">
          readName()
         </code>
         is a bit strange because there are two ways to get out of the loop: either the stream can get into a failed state or the end of the stream is reached. A more common pattern for reading from a stream uses a different version of
         <code class="calibre21">
          get()
         </code>
         that takes a reference to a character and returns a reference to the stream. Evaluating an input stream within a conditional context results in
         <code class="calibre21">
          true
         </code>
         only if the stream is not in any error state. The following version of the same function is a bit more concise:
        </p>
        <pre class="calibre26" id="c13-code-0028"><code class="calibre21">string readName(istream&amp; stream)</code>
<code class="calibre21">{</code>
<code class="calibre21">    string name;</code>
<code class="calibre21">    char next;</code>
<code class="calibre21">    while (stream.get(next)) {</code>
<code class="calibre21">        name += next;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return name;</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0026">
        </span>
        <h5 class="calibre35" id="head-5-87">
         unget()
        </h5>
        <p class="calibre13" id="c13-para-0076">
         For most purposes, the correct way to think of an input stream is as a one-way chute. Data falls down the chute and into variables. The
         <code class="calibre21">
          unget()
         </code>
         member function breaks this model in a way by allowing you to push data back up the chute.
        </p>
        <p class="calibre13" id="c13-para-0077">
         A call to
         <code class="calibre21">
          unget()
         </code>
         causes the stream to back up by one position, essentially putting the previous character read back on the stream. You can use the
         <code class="calibre21">
          fail()
         </code>
         member function to see whether
         <code class="calibre21">
          unget()
         </code>
         <span aria-label="514" class="calibre20" epub:type="pagebreak" id="Page_514" role="doc-pagebreak">
         </span>
         was successful or not. For example,
         <code class="calibre21">
          unget()
         </code>
         can fail if the current position is at the beginning of the stream.
        </p>
        <p class="calibre13">
         The
         <code class="calibre21">
          getReservationData()
         </code>
         function shown earlier in this chapter did not allow you to enter a name with whitespace. The following code uses
         <code class="calibre21">
          unget()
         </code>
         to allow whitespace in the name. The code reads character by character and checks whether the character is a digit or not. If the character is not a digit, it is added to
         <code class="calibre21">
          guestName
         </code>
         . If it is a digit, the character is put back into the stream using
         <code class="calibre21">
          unget()
         </code>
         , the loop is stopped, and the
         <code class="calibre21">
          &gt;&gt;
         </code>
         operator is used to input an integer,
         <code class="calibre21">
          partySize
         </code>
         . The
         <code class="calibre21">
          noskipws
         </code>
         input manipulator tells the stream not to skip whitespace; that is, whitespace is read like any other characters.
        </p>
        <pre class="calibre26" id="c13-code-0029"><code class="calibre21">void getReservationData()</code>
<code class="calibre21">{</code>
<code class="calibre21">    print("Name and number of guests: ");</code>
<code class="calibre21">    string guestName;</code>
<code class="calibre21">    int partySize { 0 };</code>
<code class="calibre21">    <span class="color">// Read characters until we find a digit</span></code>
<code class="calibre21">    char ch;</code>
<code class="calibre21">    cin &gt;&gt; noskipws;</code>
<code class="calibre21">    while (cin &gt;&gt; ch) {</code>
<code class="calibre21">        if (isdigit(ch)) {</code>
<code class="calibre21">            cin.unget();</code>
<code class="calibre21">            if (cin.fail()) { println(cerr, "unget() failed."); }</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        guestName += ch;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Read partySize, if the stream is not in error state</span></code>
<code class="calibre21">    if (cin) { cin &gt;&gt; partySize; }</code>
<code class="calibre21">    if (!cin) {</code>
<code class="calibre21">        println(cerr, "Error getting party size.");</code>
<code class="calibre21">        return;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("Thank you '{}', party of {}.", guestName, partySize);</code>
<code class="calibre21">    if (partySize &gt; 10) {</code>
<code class="calibre21">        println("An extra gratuity will apply.");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0027">
        </span>
        <h5 class="calibre35" id="head-5-88">
         putback()
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          putback()
         </code>
         member function, like
         <code class="calibre21">
          unget()
         </code>
         , lets you move backward by one character in an input stream. The difference is that
         <code class="calibre21">
          putback()
         </code>
         takes the character being placed back on the stream as a parameter. Here is an example:
        </p>
        <pre class="calibre26" id="c13-code-0030"><code class="calibre21">char c;</code>
<code class="calibre21">cin &gt;&gt; c;</code>
<code class="calibre21">println("Retrieved {}.", c);</code>
<code class="calibre21"> </code>
<code class="calibre21">cin.putback('e');  <span class="color">// 'e' will be the next character read off the stream.</span></code>
<code class="calibre21">println("Called putback('e').");</code>
<code class="calibre21"> </code>
<code class="calibre21">while (cin &gt;&gt; c) { println("Retrieved {}.", c); }</code></pre>
        <p class="calibre13">
         <span aria-label="515" class="calibre20" epub:type="pagebreak" id="Page_515" role="doc-pagebreak">
         </span>
         The output can be as follows:
        </p>
        <pre class="calibre26" id="c13-code-0031"><code class="calibre21">wow</code>
<code class="calibre21">Retrieved w.</code>
<code class="calibre21">Called putback('e').</code>
<code class="calibre21">Retrieved e.</code>
<code class="calibre21">Retrieved o.</code>
<code class="calibre21">Retrieved w.</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0028">
        </span>
        <h5 class="calibre35" id="head-5-89">
         peek ()
        </h5>
        <p class="calibre13" id="c13-para-0081">
         The
         <code class="calibre21">
          peek()
         </code>
         member function allows you to preview the next value that
         <i class="calibre18">
          would
         </i>
         be returned if you were to call
         <code class="calibre21">
          get()
         </code>
         . To take the chute metaphor perhaps a bit too far, you could think of it as looking up the chute without a value actually falling down it.
        </p>
        <p class="calibre13">
         <code class="calibre21">
          peek()
         </code>
         is ideal for any situation where you need to look ahead before reading a value. For example, the following code implements
         <code class="calibre21">
          getReservationData()
         </code>
         that allows whitespace in the name, but uses
         <code class="calibre21">
          peek()
         </code>
         instead of
         <code class="calibre21">
          unget()
         </code>
         :
        </p>
        <pre class="calibre26" id="c13-code-0032"><code class="calibre21">void getReservationData()</code>
<code class="calibre21">{</code>
<code class="calibre21">    print("Name and number of guests: ");</code>
<code class="calibre21">    string guestName;</code>
<code class="calibre21">    int partySize { 0 };</code>
<code class="calibre21">    <span class="color">// Read characters until we find a digit.</span></code>
<code class="calibre21">    cin &gt;&gt; noskipws;</code>
<code class="calibre21">    while (true) {</code>
<code class="calibre21">        <span class="color">// 'peek' at next character.</span></code>
<code class="calibre21">        char ch { static_cast&lt;char&gt;(cin.peek()) };</code>
<code class="calibre21">        if (!cin) { break; }</code>
<code class="calibre21">        if (isdigit(ch)) {</code>
<code class="calibre21">            <span class="color">// Next character will be a digit, so stop the loop.</span></code>
<code class="calibre21">            break;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        <span class="color">// Next character will be a non-digit, so read it.</span></code>
<code class="calibre21">        cin &gt;&gt; ch;</code>
<code class="calibre21">        if (!cin) { break; }</code>
<code class="calibre21">        guestName += ch;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Read partySize, if the stream is not in error state.</span></code>
<code class="calibre21">    if (cin) { cin &gt;&gt; partySize; }</code>
<code class="calibre21">    if (!cin) {</code>
<code class="calibre21">        println(cerr, "Error getting party size.");</code>
<code class="calibre21">        return;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("Thank you '{}', party of {}.", guestName, partySize);</code>
<code class="calibre21">    if (partySize &gt; 10) {</code>
<code class="calibre21">        println("An extra gratuity will apply.");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c13-sec-0029">
        </span>
        <h5 class="calibre35" id="head-5-90">
         getline()
        </h5>
        <p class="calibre13">
         Obtaining a single line of data from an input stream is so common that a member function exists to do it for you. The
         <code class="calibre21">
          getline()
         </code>
         member function fills a character buffer with a line of data up to the
         <span aria-label="516" class="calibre20" epub:type="pagebreak" id="Page_516" role="doc-pagebreak">
         </span>
         specified size. This specified size includes the
         <code class="calibre21">
          \0
         </code>
         character. Thus, the following code reads a maximum of
         <code class="calibre21">
          BufferSize-1
         </code>
         characters from
         <code class="calibre21">
          cin
         </code>
         or until an end-of-line sequence is read:
        </p>
        <pre class="calibre26" id="c13-code-0033"><code class="calibre21">char buffer[BufferSize] { 0 };</code>
<code class="calibre21">cin.getline(buffer, BufferSize);</code></pre>
        <p class="calibre13" id="c13-para-0084">
         When
         <code class="calibre21">
          getline()
         </code>
         is called, it reads a line from the input stream, up to and including the end-of-line sequence. However, the end-of-line character or characters do not appear in the string. Note that the end-of-line sequence is platform dependent. For example, it can be
         <code class="calibre21">
          \r\n
         </code>
         ,
         <code class="calibre21">
          \n
         </code>
         , or
         <code class="calibre21">
          \n\r
         </code>
         .
        </p>
        <p class="calibre13" id="c13-para-0085">
         There is a form of
         <code class="calibre21">
          get()
         </code>
         that performs the same operation as
         <code class="calibre21">
          getline()
         </code>
         , except that it leaves the newline sequence in the input stream.
        </p>
        <p class="calibre13">
         There is also a non-member function called
         <code class="calibre21">
          std::getline()
         </code>
         that can be used with C++
         <code class="calibre21">
          string
         </code>
         s. It is defined in
         <code class="calibre21">
          &lt;string&gt;
         </code>
         and is in the
         <code class="calibre21">
          std
         </code>
         namespace. It takes a stream and a
         <code class="calibre21">
          string
         </code>
         reference. The advantage of using this version of
         <code class="calibre21">
          getline()
         </code>
         is that it doesn't require you to specify the size of any buffer.
        </p>
        <pre class="calibre26" id="c13-code-0034"><code class="calibre21">string myString;</code>
<code class="calibre21">getline(cin, myString);</code></pre>
        <p class="calibre13">
         Both the
         <code class="calibre21">
          getline()
         </code>
         member function and the
         <code class="calibre21">
          std::getline()
         </code>
         function accept an optional delimiter as last parameter. The default delimiter is
         <code class="calibre21">
          \n
         </code>
         . By changing this delimiter, these functions can be used to read in multiple lines of text until a given delimiter is reached. For example, the following code reads in multiple lines of text until it reads an
         <code class="calibre21">
          @
         </code>
         character:
        </p>
        <pre class="calibre26" id="c13-code-0035"><code class="calibre21">print("Enter multiple lines of text. "</code>
<code class="calibre21">      "Use an @ character to signal the end of the text.\n&gt; ");</code>
<code class="calibre21">string myString;</code>
<code class="calibre21"><b class="calibre14">getline(cin, myString, '@');</b></code>
<code class="calibre21">println("Read text: \"{}\"", myString);</code></pre>
        <p class="calibre13">
         Here is a possible output:
        </p>
        <pre class="calibre26" id="c13-code-0036"><code class="calibre21">Enter multiple lines of text. Use an @ character to signal the end of the text.</code>
<code class="calibre21">&gt; This is some</code>
<code class="calibre21">text on multiple</code>
<code class="calibre21">lines.@</code>
<code class="calibre21">Read text: "This is some</code>
<code class="calibre21">text on multiple</code>
<code class="calibre21">lines."</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c13-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-240">
        Input Manipulators
       </h4>
       <p class="calibre13">
        Just as for output streams, input streams support a number of input manipulators. You've already seen one,
        <code class="calibre21">
         noskipws
        </code>
        , which tells an input stream not to skip any whitespace characters. The following list shows other built-in input manipulators available to you that allow you to customize the way data is read:
       </p>
       <ul class="check" id="c13-list-0005">
        <li class="calibre9" id="c13-li-0023">
         <code class="calibre21">
          boolalpha
         </code>
         and
         <code class="calibre21">
          noboolalpha
         </code>
         : If
         <code class="calibre21">
          boolalpha
         </code>
         is used, the string
         <i class="calibre18">
          false
         </i>
         will be interpreted as the Boolean value
         <code class="calibre21">
          false
         </code>
         ; anything else will be treated as the Boolean value
         <code class="calibre21">
          true
         </code>
         . If
         <code class="calibre21">
          noboolalpha
         </code>
         is set, zero will be interpreted as
         <code class="calibre21">
          false
         </code>
         , anything else as
         <code class="calibre21">
          true
         </code>
         . The default is
         <code class="calibre21">
          noboolalpha
         </code>
         .
        </li>
        <li class="calibre9" id="c13-li-0024">
         <span aria-label="517" class="calibre20" epub:type="pagebreak" id="Page_517" role="doc-pagebreak">
         </span>
         <code class="calibre21">
          dec
         </code>
         ,
         <code class="calibre21">
          hex
         </code>
         , and
         <code class="calibre21">
          oct
         </code>
         : Reads numbers in decimal base 10, hexadecimal, or octal notation, respectively. For example, the decimal base 10 number
         <code class="calibre21">
          207
         </code>
         is
         <code class="calibre21">
          cf
         </code>
         in hexadecimal, and
         <code class="calibre21">
          317
         </code>
         in octal notation.
        </li>
        <li class="calibre9" id="c13-li-0025">
         <code class="calibre21">
          skipws
         </code>
         and
         <code class="calibre21">
          noskipws
         </code>
         : Tells the stream to either skip whitespace when tokenizing or to read in whitespace as its own token. The default is
         <code class="calibre21">
          skipws
         </code>
         .
        </li>
        <li class="calibre9" id="c13-li-0026">
         <code class="calibre21">
          ws
         </code>
         : A handy manipulator that simply skips over the current series of whitespace at the current position in the stream.
        </li>
        <li class="calibre9" id="c13-li-0027">
         <code class="calibre21">
          get_money
         </code>
         : A parameterized manipulator that reads a monetary value from a stream.
        </li>
        <li class="calibre9" id="c13-li-0028">
         <code class="calibre21">
          get_time
         </code>
         : A parameterized manipulator that reads a formatted time from a stream.
        </li>
        <li class="calibre9" id="c13-li-0029">
         <code class="calibre21">
          quoted
         </code>
         : A parameterized manipulator that reads a string enclosed with quotes and in which embedded quotes are escaped. An example of this manipulator is shown later in this chapter.
        </li>
       </ul>
       <p class="calibre13">
        Input is locale aware. For example, the following code enables your system locale for
        <code class="calibre21">
         cin
        </code>
        . Locales are discussed in
        <a class="calibre5" href="c21.xhtml">
         Chapter 21
        </a>
        :
       </p>
       <pre class="calibre26" id="c13-code-0037"><code class="calibre21">cin.imbue(locale { "" });</code>
<code class="calibre21">int i;</code>
<code class="calibre21">cin &gt;&gt; i;</code></pre>
       <p class="calibre13" id="c13-para-0091">
        If your system locale is U.S. English, you can enter
        <code class="calibre21">
         1,000
        </code>
        and it will be parsed as 1000. If you enter
        <code class="calibre21">
         1.000
        </code>
        , it will be parsed as 1. On the other hand, if your system locale is Dutch Belgium, you can enter
        <code class="calibre21">
         1.000
        </code>
        to get the value of 1000, but entering
        <code class="calibre21">
         1,000
        </code>
        will result in 1. In both cases, you can also just enter
        <code class="calibre21">
         1000
        </code>
        without any digit separators to get the value 1000.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0031">
      </span>
      <h3 class="calibre27" id="head-3-291">
       Input and Output with Objects
      </h3>
      <p class="calibre13">
       If you are familiar with the old-school
       <code class="calibre21">
        printf()
       </code>
       function from C for output, you know that it is not flexible and does not support custom types.
       <code class="calibre21">
        printf()
       </code>
       knows about several types of data, but there really isn't a way to give it additional knowledge. For example, consider the following simple class:
      </p>
      <pre class="calibre26" id="c13-code-0038"><code class="calibre21">class Muffin final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        const string&amp; getDescription() const { return m_description; }</code>
<code class="calibre21">        void setDescription(string description)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_description = std::move(description);</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        int getSize() const { return m_size; }</code>
<code class="calibre21">        void setSize(int size) { m_size = size; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        bool hasChocolateChips() const { return m_hasChocolateChips; }</code>
<code class="calibre21">        void setHasChocolateChips(bool hasChips)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_hasChocolateChips = hasChips;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_description;</code>
<span aria-label="518" class="calibre20" epub:type="pagebreak" id="Page_518" role="doc-pagebreak"></span><code class="calibre21">        int m_size { 0 };</code>
<code class="calibre21">        bool m_hasChocolateChips { false };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       To output an object of class
       <code class="calibre21">
        Muffin
       </code>
       by using
       <code class="calibre21">
        printf()
       </code>
       , it would be nice if you could specify it as an argument, perhaps using
       <code class="calibre21">
        %m
       </code>
       as a placeholder:
      </p>
      <pre class="calibre26" id="c13-code-0039"><code class="calibre21">printf("Muffin: %m\n", myMuffin); <span class="color">// BUG! printf doesn't understand Muffin.</span></code></pre>
      <p class="calibre13" id="c13-para-0094">
       Unfortunately, the
       <code class="calibre21">
        printf()
       </code>
       function knows nothing about the
       <code class="calibre21">
        Muffin
       </code>
       type and is unable to output an object of type
       <code class="calibre21">
        Muffin
       </code>
       . Worse still, because of the way the
       <code class="calibre21">
        printf()
       </code>
       function is declared, this will result in a run-time error, not a compile-time error (though a good compiler will give you a warning).
      </p>
      <p class="calibre13">
       The best you can do with
       <code class="calibre21">
        printf()
       </code>
       is to add a new
       <code class="calibre21">
        output()
       </code>
       member function to the
       <code class="calibre21">
        Muffin
       </code>
       class:
      </p>
      <pre class="calibre26" id="c13-code-0040"><code class="calibre21">class Muffin final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void output() const</code>
<code class="calibre21">        {</code>
<code class="calibre21">            printf("%s, size is %d, %s", getDescription().c_str(), getSize(),</code>
<code class="calibre21">                (hasChocolateChips() ? "has chips" : "no chips"));</code>
<code class="calibre21">        }</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Using such a mechanism is cumbersome, however. To output a
       <code class="calibre21">
        Muffin
       </code>
       in the middle of another line of text, you'd need to split the line into two calls with a call to
       <code class="calibre21">
        Muffin::output()
       </code>
       in between, as shown here:
      </p>
      <pre class="calibre26" id="c13-code-0041"><code class="calibre21">printf("The muffin is a ");</code>
<code class="calibre21">myMuffin.output();</code>
<code class="calibre21">printf(" -- yummy!\n");</code></pre>
      <p class="calibre13">
       A much better and modern option is to write a custom
       <code class="calibre21">
        std::formatter
       </code>
       specialization for
       <code class="calibre21">
        Muffin
       </code>
       objects as explained in
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       . The following is a simple custom
       <code class="calibre21">
        formatter
       </code>
       for
       <code class="calibre21">
        Muffin
       </code>
       s. To keep the example concise, this formatter does not support any format specifiers. Thus, the
       <code class="calibre21">
        parse()
       </code>
       abbreviated member function template does not need to parse anything and can just return
       <code class="calibre21">
        begin(context)
       </code>
       .
      </p>
      <pre class="calibre26" id="c13-code-0042"><code class="calibre21">template &lt;&gt;</code>
<code class="calibre21">class std::formatter&lt;Muffin&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        constexpr auto parse(auto&amp; context) { return begin(context); }</code>
<code class="calibre21"> </code>
<code class="calibre21">        auto format(const Muffin&amp; muffin, auto&amp; ctx) const</code>
<code class="calibre21">        {</code>
<code class="calibre21">            ctx.advance:to(format_to(ctx.out(), "{}, size is {}, {}",</code>
<code class="calibre21">                muffin.getDescription(), muffin.getSize(),</code>
<code class="calibre21">                (muffin.hasChocolateChips() ? "has chips" : "no chips")));</code>
<code class="calibre21">            return ctx.out();</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="519" class="calibre20" epub:type="pagebreak" id="Page_519" role="doc-pagebreak">
       </span>
       With this custom formatter, you can use the modern
       <code class="calibre21">
        std::print()
       </code>
       and
       <code class="calibre21">
        println()
       </code>
       functions to print a muffin. Here is an example:
      </p>
      <pre class="calibre26" id="c13-code-0043"><code class="calibre21">println("The muffin is a {} -- yummy!", myMuffin);</code></pre>
      <p class="calibre13" id="c13-para-0099">
       Yet another option to print
       <code class="calibre21">
        Muffin
       </code>
       s is to overload the
       <code class="calibre21">
        &lt;&lt;
       </code>
       operator after which you output a
       <code class="calibre21">
        Muffin
       </code>
       just like you output a
       <code class="calibre21">
        string
       </code>
       —by providing it as an argument to
       <code class="calibre21">
        operator&lt;&lt;
       </code>
       . Additionally, you can overload the
       <code class="calibre21">
        &gt;&gt;
       </code>
       operator so that you can input
       <code class="calibre21">
        Muffin
       </code>
       s from an input stream.
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       covers the details of overloading the
       <code class="calibre21">
        &lt;&lt;
       </code>
       and
       <code class="calibre21">
        &gt;&gt;
       </code>
       operators.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0032">
      </span>
      <h3 class="calibre27" id="head-3-292">
       Custom Manipulators
      </h3>
      <p class="calibre13" id="c13-para-0100">
       The Standard Library comes with a number of built-in stream manipulators, but, if need be, custom manipulators can be written.
      </p>
      <p class="calibre13">
       Writing your own non-parameterized manipulator is easy. Here's a simple example defining a
       <code class="calibre21">
        tab
       </code>
       output manipulator which outputs the tab character to a given stream:
      </p>
      <pre class="calibre26" id="c13-code-0044"><code class="calibre21">ostream&amp; tab(ostream&amp; stream) { return stream &lt;&lt; '\t'; }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    cout &lt;&lt; "Test" &lt;&lt; tab &lt;&lt; "!" &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c13-para-0102">
       Writing custom parameterized manipulators is more complicated. It involves using functionality exposed by
       <code class="calibre21">
        ios_base
       </code>
       , such as
       <code class="calibre21">
        xalloc()
       </code>
       ,
       <code class="calibre21">
        iword()
       </code>
       ,
       <code class="calibre21">
        pword()
       </code>
       , and
       <code class="calibre21">
        register_callback()
       </code>
       . Since such manipulators are rarely needed, this text does not further discuss this topic. Consult your favorite Standard Library reference in case you are interested.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-151" class="calibre2">
     <span class="calibre" id="c13-sec-0033">
     </span>
     <h2 class="calibre6" id="head-2-151">
      STRING STREAMS
     </h2>
     <p class="calibre13" id="c13-para-0103">
      String streams provide a way to use stream semantics with
      <code class="calibre21">
       string
      </code>
      s. In this way, you can have an
      <i class="calibre18">
       in-memory stream
      </i>
      that represents textual data. For example, in a GUI application you might want to use streams to build up textual data, but instead of outputting the text to the console or a file, you might want to display the result in a GUI element like a message box or an edit control. Another example could be that you want to pass a string stream around to different functions, while retaining the current read position, so that each function can process the next part of the stream. String streams are also useful for parsing text, because streams have built-in tokenizing functionality.
     </p>
     <p class="calibre13" id="c13-para-0104">
      The
      <code class="calibre21">
       std::ostringstream
      </code>
      class is used to write data to a
      <code class="calibre21">
       string
      </code>
      , while
      <code class="calibre21">
       std::istringstream
      </code>
      is used to read data from a
      <code class="calibre21">
       string
      </code>
      . The
      <code class="calibre21">
       o
      </code>
      in
      <code class="calibre21">
       ostringstream
      </code>
      stands for output, while the
      <code class="calibre21">
       i
      </code>
      in
      <code class="calibre21">
       istringstream
      </code>
      stands for input. They are both defined in
      <code class="calibre21">
       &lt;sstream&gt;
      </code>
      . Because
      <code class="calibre21">
       ostringstream
      </code>
      and
      <code class="calibre21">
       istringstream
      </code>
      inherit the same behavior as
      <code class="calibre21">
       ostream
      </code>
      and
      <code class="calibre21">
       istream
      </code>
      , working with them is pleasantly similar.
     </p>
     <p class="calibre13">
      The following program requests words from the user and outputs them to a single
      <code class="calibre21">
       ostringstream
      </code>
      , separated by commas and surrounded by double quotes. At the end of the program, the whole stream is turned into a
      <code class="calibre21">
       string
      </code>
      object using the
      <code class="calibre21">
       str()
      </code>
      member function and is written to the console.
      <span aria-label="520" class="calibre20" epub:type="pagebreak" id="Page_520" role="doc-pagebreak">
      </span>
      Input of tokens can be stopped by entering the token “done” or by closing the input stream with
      <code class="calibre21">
       Control+D
      </code>
      (Unix) or
      <code class="calibre21">
       Control+Z
      </code>
      (Windows).
     </p>
     <pre class="calibre26" id="c13-code-0045"><code class="calibre21">println("Enter tokens. "</code>
<code class="calibre21">      "Control+D (Unix) or Control+Z (Windows) followed by Enter to end.");</code>
<code class="calibre21">ostringstream outStream;</code>
<code class="calibre21">bool firstLoop { true };</code>
<code class="calibre21">while (cin) {</code>
<code class="calibre21">    string nextToken;</code>
<code class="calibre21">    print("Next token: ");</code>
<code class="calibre21">    cin &gt;&gt; nextToken;</code>
<code class="calibre21"> </code>
<code class="calibre21">    if (!cin || nextToken == "done") { break; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    if (!firstLoop) { outStream &lt;&lt; ", "; }</code>
<code class="calibre21">    outStream &lt;&lt; '"' &lt;&lt; nextToken &lt;&lt; '"';</code>
<code class="calibre21">    firstLoop = false;</code>
<code class="calibre21">}</code>
<code class="calibre21">println("The end result is: {}", outStream.str());</code></pre>
     <p class="calibre13">
      Reading data from a string stream is similarly familiar. The following function creates and populates a
      <code class="calibre21">
       Muffin
      </code>
      object (see the earlier example) from a string input stream. The stream data is in a fixed format so that the function can easily turn its values into calls to
      <code class="calibre21">
       Muffin
      </code>
      's setters. This fixed format is the description of the muffin between double quotes, followed by the size, followed by true or false depending on whether the muffin has chocolate chips. For example, the following string is a valid muffin:
     </p>
     <pre class="calibre26" id="c13-code-0046"><code class="calibre21">"Raspberry Muffin" 12 true</code></pre>
     <p class="calibre13">
      Here is the implementation. Note the use of the
      <code class="calibre21">
       quoted
      </code>
      manipulator to read a quoted string from the input stream.
     </p>
     <pre class="calibre26" id="c13-code-0047"><code class="calibre21">Muffin createMuffin(istringstream&amp; stream)</code>
<code class="calibre21">{</code>
<code class="calibre21">    Muffin muffin;</code>
<code class="calibre21">    <span class="color">// Assume data is properly formatted:</span></code>
<code class="calibre21">    <span class="color">// "Description" size chips</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    string description;</code>
<code class="calibre21">    int size;</code>
<code class="calibre21">    bool hasChips;</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read all three values. Note that chips is represented</span></code>
<code class="calibre21">    <span class="color">// by the strings "true" and "false".</span></code>
<code class="calibre21">    <b class="calibre14">stream &gt;&gt; quoted(description) &gt;&gt; size &gt;&gt; boolalpha &gt;&gt; hasChips;</b></code>
<code class="calibre21">    if (stream) { <span class="color">// Reading was successful.</span></code>
<code class="calibre21">        muffin.setSize(size);</code>
<code class="calibre21">        muffin.setDescription(description);</code>
<code class="calibre21">        muffin.setHasChocolateChips(hasChips);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return muffin;</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      <span aria-label="521" class="calibre20" epub:type="pagebreak" id="Page_521" role="doc-pagebreak">
      </span>
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c13-para-0109">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Turning an object into a “flattened” type, like a string, is often called marshaling. Marshaling is useful for saving objects to disk or sending them across a network
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c13-para-0110">
      An advantage of string streams over standard C++
      <code class="calibre21">
       string
      </code>
      s is that, in addition to data, they know where the next read or write operation will take place, also called the
      <i class="calibre18">
       current position
      </i>
      .
     </p>
     <p class="calibre13" id="c13-para-0111">
      Another advantage is that string streams support manipulators and locales to enable more powerful formatting compared to
      <code class="calibre21">
       string
      </code>
      s.
     </p>
     <p class="calibre13" id="c13-para-0112">
      Finally, if you need to build up a string by concatenating several smaller strings, using a string stream will be more performant compared to concatenating
      <code class="calibre21">
       string
      </code>
      objects directly.
     </p>
    </section>
    <section aria-labelledby="head-2-152" class="calibre2">
     <span class="calibre" id="c13-sec-0035">
     </span>
     <h2 class="calibre6" id="head-2-152">
      <img alt="C++23" class="calibre15" src="images/icon1.png"/>
      SPAN-BASED STREAMS
     </h2>
     <p class="calibre13" id="c13-para-0114">
      C++23 introduces
      <i class="calibre18">
       span-based streams
      </i>
      , defined in
      <code class="calibre21">
       &lt;spanstream&gt;
      </code>
      , which allow you to use the stream metaphor on any fixed memory buffer you have available. How memory was allocated for that buffer is not important. The most important classes in this context that you'll use are
      <code class="calibre21">
       ispanstream
      </code>
      for input,
      <code class="calibre21">
       ospanstream
      </code>
      for output, and
      <code class="calibre21">
       spanstream
      </code>
      for input and output. Technically, these are
      <code class="calibre21">
       char
      </code>
      instantiations for the class templates
      <code class="calibre21">
       basic_ispanstream
      </code>
      ,
      <code class="calibre21">
       basic_ospanstream
      </code>
      , and
      <code class="calibre21">
       basic_spanstream
      </code>
      . There are also wide-character,
      <code class="calibre21">
       wchar_t
      </code>
      instantiations available called
      <code class="calibre21">
       wispanstream
      </code>
      ,
      <code class="calibre21">
       wospanstream
      </code>
      , and
      <code class="calibre21">
       wspanstream
      </code>
      . Wide characters are mentioned earlier in this chapter and covered in more detail in
      <a class="calibre5" href="c21.xhtml">
       Chapter 21
      </a>
      . This section gives examples of the non-wide-character classes, as the others work very similarly.
     </p>
     <p class="calibre13" id="c13-para-0115">
      The constructors of the span-based stream classes require an
      <code class="calibre21">
       std::span
      </code>
      .
      <a class="calibre5" href="c18_split_000.xhtml">
       Chapter 18
      </a>
      , “Standard Library Containers,” discusses
      <code class="calibre21">
       span
      </code>
      in detail and explains why and when you want to use it, but those details are not important for this section. The use of
      <code class="calibre21">
       span
      </code>
      in the context of span-based streams is straightforward, as you'll see. In a nutshell, a
      <code class="calibre21">
       span
      </code>
      allows you to make a view over a contiguous block of memory. It's a bit similar to how
      <code class="calibre21">
       std::string_view
      </code>
      allows you to create a read-only view over any kind of string, as discussed in
      <a class="calibre5" href="c02.xhtml">
       Chapter 2
      </a>
      . The difference is that a
      <code class="calibre21">
       span
      </code>
      can be a read-only view, but it can also be a writable view allowing modifications to the underlying buffer.
     </p>
     <p class="calibre13">
      Here is an example of using an
      <code class="calibre21">
       ispanstream
      </code>
      to parse data stored in a fixed memory buffer called
      <code class="calibre21">
       fixedBuffer
      </code>
      . To construct a
      <code class="calibre21">
       span
      </code>
      over that buffer, you simply use the
      <code class="calibre21">
       span
      </code>
      constructor and pass it the location of the buffer.
     </p>
     <pre class="calibre26" id="c13-code-0048"><code class="calibre21">char fixedBuffer[] { "11 2.222 Hello" };</code>
<code class="calibre21"><b class="calibre14">ispanstream stream { span { fixedBuffer } };</b></code>
<code class="calibre21">int i;   double d;   string str;</code>
<code class="calibre21">stream &gt;&gt; i &gt;&gt; d &gt;&gt; str;</code>
<code class="calibre21">println("Parsed data: int: {}, double: {}, string: {}", i, d, str);</code></pre>
     <p class="calibre13">
      The output is as follows:
     </p>
     <pre class="calibre26" id="c13-code-0049"><code class="calibre21">Parsed data: int: 11, double: 2.222, string: Hello</code></pre>
     <p class="calibre13">
      <span aria-label="522" class="calibre20" epub:type="pagebreak" id="Page_522" role="doc-pagebreak">
      </span>
      Using an
      <code class="calibre21">
       ospanstream
      </code>
      is similarly straightforward. The following code creates a fixed buffer of 32
      <code class="calibre21">
       char
      </code>
      s, constructs a writable
      <code class="calibre21">
       ospanstream
      </code>
      view over that buffer, uses standard stream insertion operations to output some data to the buffer, and finally prints out the result:
     </p>
     <pre class="calibre26" id="c13-code-0050"><code class="calibre21">char fixedBuffer[32] {};</code>
<code class="calibre21"><b class="calibre14">ospanstream stream { span { fixedBuffer } };</b></code>
<code class="calibre21">stream &lt;&lt; "Hello " &lt;&lt; 2.222 &lt;&lt; ' ' &lt;&lt; 11;</code>
<code class="calibre21">println("Buffer contents: \"{}\"", fixedBuffer);</code></pre>
     <p class="calibre13">
      The output is:
     </p>
     <pre class="calibre26" id="c13-code-0051"><code class="calibre21">Buffer contents: "Hello 2.222 11"</code></pre>
    </section>
    <section aria-labelledby="head-2-153" class="calibre2">
     <span class="calibre" id="c13-sec-0036">
     </span>
     <h2 class="calibre6" id="head-2-153">
      FILE STREAMS
     </h2>
     <p class="calibre13" id="c13-para-0120">
      Files lend themselves well to the stream abstraction because reading and writing files always involves a position in addition to the data. In C++, the
      <code class="calibre21">
       std::ofstream
      </code>
      and
      <code class="calibre21">
       ifstream
      </code>
      classes provide output and input functionality for files. They are defined in
      <code class="calibre21">
       &lt;fstream&gt;
      </code>
      .
     </p>
     <p class="calibre13" id="c13-para-0121">
      When dealing with the filesystem, it is especially important to detect and handle error cases. The file you are working with could be on a network file store that just went offline, or you may be trying to write to a file that is located on a disk that is full. Maybe you are trying to open a file for which the current user does not have permissions. Error conditions can be detected by using the standard error handling mechanisms described earlier.
     </p>
     <p class="calibre13" id="c13-para-0122">
      The only major difference between output file streams and other output streams is that the file stream constructor can take the name of the file and the mode in which you would like to open it. The default mode is write,
      <code class="calibre21">
       ios_base::out
      </code>
      , which starts writing to a file at the beginning, overwriting any existing data. You can also open an output file stream in append mode by specifying the constant
      <code class="calibre21">
       ios_base::app
      </code>
      as the second argument to the file stream constructor. The following table lists the different constants that are available:
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         CONSTANT
        </th>
        <th class="left" scope="col">
         DESCRIPTION
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          ios_base::app
         </span>
        </td>
        <td class="bgcolor">
         Open, and go to the end before each write operation.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          ios_base::ate
         </span>
        </td>
        <td class="bgcolor">
         Open, and go to the end once immediately after opening.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          ios_base::binary
         </span>
        </td>
        <td class="bgcolor">
         Perform input and output in binary mode as opposed to text mode. See the next section.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          ios_base::in
         </span>
        </td>
        <td class="bgcolor">
         Open for input, start reading at the beginning.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          ios_base::out
         </span>
        </td>
        <td class="bgcolor">
         Open for output, start writing at the beginning, overwriting existing data.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          ios_base::trunc
         </span>
        </td>
        <td class="bgcolor">
         Option for
         <span class="calibre21">
          out
         </span>
         . Delete all existing data (truncate).
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         <span class="calibre21">
          ios_base::noreplace
         </span>
        </td>
        <td class="bgcolor">
         Option for
         <code class="calibre21">
          out
         </code>
         . Open in exclusive mode. Open will fail if the file already exists.
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13">
      <span aria-label="523" class="calibre20" epub:type="pagebreak" id="Page_523" role="doc-pagebreak">
      </span>
      Note that modes can be combined. For example, if you want to open a file for output in binary mode, while truncating existing data, you would specify the open mode as follows:
     </p>
     <pre class="calibre26" id="c13-code-0052"><code class="calibre21">ios_base::out | ios_base::binary  | ios_base::trunc</code></pre>
     <p class="calibre13" id="c13-para-0128">
      An
      <code class="calibre21">
       ifstream
      </code>
      automatically includes the
      <code class="calibre21">
       ios_base::in
      </code>
      mode, while an
      <code class="calibre21">
       ofstream
      </code>
      automatically includes the
      <code class="calibre21">
       ios_base::out
      </code>
      mode, even if you don't explicitly specify
      <code class="calibre21">
       in
      </code>
      or
      <code class="calibre21">
       out
      </code>
      as the mode.
     </p>
     <p class="calibre13">
      The following program opens the
      <code class="calibre21">
       test.txt
      </code>
      file and writes the program's arguments to it. The
      <code class="calibre21">
       ifstream
      </code>
      and
      <code class="calibre21">
       ofstream
      </code>
      destructors automatically close the underlying file, so there is no need to explicitly call
      <code class="calibre21">
       close()
      </code>
      .
     </p>
     <pre class="calibre26" id="c13-code-0053"><code class="calibre21">int main(int argc, char* argv[])</code>
<code class="calibre21">{</code>
<code class="calibre21">    ofstream outFile { "test.txt", ios_base::trunc };</code>
<code class="calibre21">    if (!outFile.good()) {</code>
<code class="calibre21">        println(cerr, "Error while opening output file!");</code>
<code class="calibre21">        return -1;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    outFile &lt;&lt; "There were " &lt;&lt; argc &lt;&lt; " arguments to this program." &lt;&lt; endl;</code>
<code class="calibre21">    outFile &lt;&lt; "They are: " &lt;&lt; endl;</code>
<code class="calibre21">    for (int i { 0 }; i &lt; argc; i++) {</code>
<code class="calibre21">        outFile &lt;&lt; argv[i] &lt;&lt; endl;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0037">
      </span>
      <h3 class="calibre27" id="head-3-293">
       Text Mode vs. Binary Mode
      </h3>
      <p class="calibre13" id="c13-para-0130">
       By default, a file stream is opened in
       <i class="calibre18">
        text mode
       </i>
       . If you specify the
       <code class="calibre21">
        ios_base::binary
       </code>
       flag, then the file is opened in
       <i class="calibre18">
        binary mode
       </i>
       .
      </p>
      <p class="calibre13" id="c13-para-0131">
       In binary mode, the exact bytes you ask the stream to write are written to the file. When reading, the bytes are returned to you exactly as they are in the file.
      </p>
      <p class="calibre13" id="c13-para-0132">
       In text mode, there is some hidden conversion happening: each line you write to, or read from, a file ends with
       <code class="calibre21">
        \n
       </code>
       . However, how the end of a line is encoded in a file depends on the operating system. For example, on Windows, a line ends with
       <code class="calibre21">
        \r\n
       </code>
       instead of with a single
       <code class="calibre21">
        \n
       </code>
       character. Therefore, when a file is opened in text mode and you write a line ending with
       <code class="calibre21">
        \n
       </code>
       to it, the underlying implementation automatically converts the
       <code class="calibre21">
        \n
       </code>
       to
       <code class="calibre21">
        \r\n
       </code>
       before writing it to the file. Similarly, when reading a line from the file, the
       <code class="calibre21">
        \r\n
       </code>
       that is read from the file is automatically converted back to
       <code class="calibre21">
        \n
       </code>
       before being returned to you.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0038">
      </span>
      <h3 class="calibre27" id="head-3-294">
       Jumping Around with seek() and tell()
      </h3>
      <p class="calibre13" id="c13-para-0133">
       The
       <code class="calibre21">
        seek
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       and
       <code class="calibre21">
        tell
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       member functions are present on all input and output streams. The
       <code class="calibre21">
        seek
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       member functions let you move to an arbitrary position within an input or output stream. There are several forms of
       <code class="calibre21">
        seek
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       . For an input stream, the member function is called
       <code class="calibre21">
        seekg()
       </code>
       (the
       <i class="calibre18">
        g
       </i>
       is for
       <i class="calibre18">
        get
       </i>
       ), and for an output stream, it is called
       <code class="calibre21">
        seekp()
       </code>
       (the
       <i class="calibre18">
        p
       </i>
       is for
       <i class="calibre18">
        put
       </i>
       ). You might wonder why there is both a
       <code class="calibre21">
        seekg()
       </code>
       and a
       <code class="calibre21">
        seekp()
       </code>
       member function, instead of one
       <code class="calibre21">
        seek()
       </code>
       member function. The reason is that you can have streams that are both input and output, for example, file streams.
       <span aria-label="524" class="calibre20" epub:type="pagebreak" id="Page_524" role="doc-pagebreak">
       </span>
       In that case, the stream needs to remember both a read position and a separate write position. This is also called
       <i class="calibre18">
        bidirectional I/O
       </i>
       and is covered later in this chapter.
      </p>
      <p class="calibre13" id="c13-para-0134">
       There are two overloads of
       <code class="calibre21">
        seekg()
       </code>
       and two of
       <code class="calibre21">
        seekp()
       </code>
       . One overload accepts a single argument, an absolute position, and seeks to this absolute position. The second overload accepts an offset and a position and seeks an offset relative to the given position. Positions are of type
       <code class="calibre21">
        std::streampos
       </code>
       , while offsets are of type
       <code class="calibre21">
        std::streamoff
       </code>
       ; both are measured in bytes. There are three predefined positions available, as shown in the following table:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          POSITION
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           ios_base::beg
          </span>
         </td>
         <td class="bgcolor">
          The beginning of the stream
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           ios_base::end
          </span>
         </td>
         <td class="bgcolor">
          The end of the stream
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           ios_base::cur
          </span>
         </td>
         <td class="bgcolor">
          The current position in the stream
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       For example, to seek to an absolute position in an output stream, you can use the one-parameter overload of
       <code class="calibre21">
        seekp()
       </code>
       , as in the following case, which uses the constant
       <code class="calibre21">
        ios_base::beg
       </code>
       to move to the beginning of the stream:
      </p>
      <pre class="calibre26" id="c13-code-0054"><code class="calibre21">outStream.seekp(ios_base::beg);</code></pre>
      <p class="calibre13">
       Seeking within an input stream is the same, except that the
       <code class="calibre21">
        seekg()
       </code>
       member function is used:
      </p>
      <pre class="calibre26" id="c13-code-0055"><code class="calibre21">inStream.seekg(ios_base::beg);</code></pre>
      <p class="calibre13">
       The two-argument overloads move to a relative position in the stream. The first argument prescribes how many positions to move, and the second argument provides the starting point. To move relative to the beginning of the file, the constant
       <code class="calibre21">
        ios_base::beg
       </code>
       is used. To move relative to the end of the file,
       <code class="calibre21">
        ios_base::end
       </code>
       is used. To move relative to the current position,
       <code class="calibre21">
        ios_base::cur
       </code>
       is used. For example, the following line moves to the second byte from the beginning of the output stream. Note that integers are implicitly converted to type
       <code class="calibre21">
        streampos
       </code>
       and
       <code class="calibre21">
        streamoff
       </code>
       .
      </p>
      <pre class="calibre26" id="c13-code-0056"><code class="calibre21">outStream.seekp(2, ios_base::beg);</code></pre>
      <p class="calibre13">
       The next example moves to the third-to-last byte of an input stream:
      </p>
      <pre class="calibre26" id="c13-code-0057"><code class="calibre21">inStream.seekg(-3, ios_base::end);</code></pre>
      <p class="calibre13" id="c13-para-0140">
       You can also query a stream's current location using the
       <code class="calibre21">
        tell
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       member function, which returns a
       <code class="calibre21">
        streampos
       </code>
       that indicates the current position. You can use this result to remember the current marker position before doing a
       <code class="calibre21">
        seek
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       or to query whether you are in a particular location. There are again separate versions of
       <code class="calibre21">
        tell
       </code>
       <i class="calibre18">
        x
       </i>
       <code class="calibre21">
        ()
       </code>
       for input streams and output streams. Input streams use
       <code class="calibre21">
        tellg()
       </code>
       , and output streams use
       <code class="calibre21">
        tellp()
       </code>
       .
      </p>
      <p class="calibre13">
       The following code checks the position of an input stream to determine whether it is at the beginning:
      </p>
      <pre class="calibre26" id="c13-code-0058"><code class="calibre21">streampos curPos { inStream.tellg() };</code>
<code class="calibre21">if (ios_base::beg == curPos) {</code>
<code class="calibre21">    println("We're at the beginning.");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <span aria-label="525" class="calibre20" epub:type="pagebreak" id="Page_525" role="doc-pagebreak">
       </span>
       The following is a sample program that brings it all together. This program writes into a file called
       <code class="calibre21">
        test.out
       </code>
       and performs the following tests:
      </p>
      <ol class="calibre7" id="c13-list-0006">
       <li class="calibre9" id="c13-li-0030">
        Outputs the string
        <code class="calibre21">
         54321
        </code>
        to the file
       </li>
       <li class="calibre9" id="c13-li-0031">
        Verifies that the marker is at position 5 in the stream
       </li>
       <li class="calibre9" id="c13-li-0032">
        Moves to position 2 in the output stream
       </li>
       <li class="calibre9" id="c13-li-0033">
        Outputs a
        <code class="calibre21">
         0
        </code>
        in position 2 and closes the output stream
       </li>
       <li class="calibre9" id="c13-li-0034">
        Opens an input stream on the
        <code class="calibre21">
         test.out
        </code>
        file
       </li>
       <li class="calibre9" id="c13-li-0035">
        Reads the first token as an integer
       </li>
       <li class="calibre9" id="c13-li-0036">
        Confirms that the value is
        <code class="calibre21">
         54021
        </code>
       </li>
      </ol>
      <pre class="calibre26" id="c13-code-0059"><code class="calibre21">ofstream fout { "test.out" };</code>
<code class="calibre21">if (!fout) {</code>
<code class="calibre21">    println(cerr, "Error opening test.out for writing.");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// 1. Output the string "54321".</span></code>
<code class="calibre21">fout &lt;&lt; "54321";</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// 2. Verify that the marker is at position 5.</span></code>
<code class="calibre21">streampos curPos { fout.tellp() };</code>
<code class="calibre21">if (curPos == 5) {</code>
<code class="calibre21">    println("Test passed: Currently at position 5.");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Test failed: Not at position 5!");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// 3. Move to position 2 in the output stream.</span></code>
<code class="calibre21">fout.seekp(2, ios_base::beg);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// 4. Output a 0 in position 2 and close the output stream.</span></code>
<code class="calibre21">fout &lt;&lt; 0;</code>
<code class="calibre21">fout.close();</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// 5. Open an input stream on test.out.</span></code>
<code class="calibre21">ifstream fin { "test.out" };</code>
<code class="calibre21">if (!fin) {</code>
<code class="calibre21">    println(cerr, "Error opening test.out for reading.");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// 6. Read the first token as an integer.</span></code>
<code class="calibre21">int testVal;</code>
<code class="calibre21">fin &gt;&gt; testVal;</code>
<code class="calibre21">if (!fin) {</code>
<code class="calibre21">    println(cerr,  "Error reading from file.");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="526" class="calibre20" epub:type="pagebreak" id="Page_526" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// 7. Confirm that the value is 54021.</span></code>
<code class="calibre21">const int expected { 54021 };</code>
<code class="calibre21">if (testVal == expected) {</code>
<code class="calibre21">    println("Test passed: Value is {}.", expected);</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Test failed: Value is not {} (it was {}).", expected, testVal);</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0039">
      </span>
      <h3 class="calibre27" id="head-3-295">
       Linking Streams Together
      </h3>
      <p class="calibre13" id="c13-para-0143">
       A link can be established between any input and output streams to give them
       <i class="calibre18">
        flush-on-access
       </i>
       behavior. In other words, when data is requested from an input stream, its linked output stream is automatically flushed. This behavior is available to all streams but is particularly useful for file streams that may be dependent upon each other.
      </p>
      <p class="calibre13" id="c13-para-0144">
       Stream linking is accomplished with the
       <code class="calibre21">
        tie()
       </code>
       member function. To tie an output stream to an input stream, call
       <code class="calibre21">
        tie()
       </code>
       on the input stream, and pass the address of the output stream. To break the link, pass
       <code class="calibre21">
        nullptr
       </code>
       .
      </p>
      <p class="calibre13">
       The following program ties the input stream of one file to the output stream of an entirely different file. You could also tie it to an output stream on the same file, but bidirectional I/O (covered in the next section) is perhaps a more elegant way to read and write the same file simultaneously.
      </p>
      <pre class="calibre26" id="c13-code-0060"><code class="calibre21">ifstream inFile { "input.txt" };  <span class="color">// Note: input.txt must exist.</span></code>
<code class="calibre21">ofstream outFile { "output.txt" };</code>
<code class="calibre21"><span class="color">// Set up a link between inFile and outFile.</span></code>
<code class="calibre21">inFile.tie(&amp;outFile);</code>
<code class="calibre21"><span class="color">// Output some text to outFile. Normally, this would</span></code>
<code class="calibre21"><span class="color">// not flush because std::endl is not send.</span></code>
<code class="calibre21">outFile &lt;&lt; "Hello there!";</code>
<code class="calibre21"><span class="color">// outFile has NOT been flushed.</span></code>
<code class="calibre21"><span class="color">// Read some text from inFile. This will trigger flush() on outFile.</span></code>
<code class="calibre21">string nextToken;</code>
<code class="calibre21">inFile &gt;&gt; nextToken;</code>
<code class="calibre21"><span class="color">// outFile HAS been flushed.</span></code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        flush()
       </code>
       member function is defined on the
       <code class="calibre21">
        ostream
       </code>
       base class, so you can also link an output stream to another output stream. Here's an example:
      </p>
      <pre class="calibre26" id="c13-code-0061"><code class="calibre21">outFile.tie(&amp;anotherOutputFile);</code></pre>
      <p class="calibre13" id="c13-para-0147">
       Such a relationship means that every time you write to one file, the buffered data that has been sent to the other file is flushed. You can use this mechanism to keep two related files synchronized.
      </p>
      <p class="calibre13" id="c13-para-0148">
       One example of this stream linking is the link between
       <code class="calibre21">
        cout
       </code>
       and
       <code class="calibre21">
        cin
       </code>
       . Whenever you try to input data from
       <code class="calibre21">
        cin
       </code>
       ,
       <code class="calibre21">
        cout
       </code>
       is automatically flushed. There is also a link between
       <code class="calibre21">
        cerr
       </code>
       and
       <code class="calibre21">
        cout
       </code>
       , meaning that any output to
       <code class="calibre21">
        cerr
       </code>
       causes
       <code class="calibre21">
        cout
       </code>
       to flush. The
       <code class="calibre21">
        clog
       </code>
       stream, on the other hand, is not linked to
       <code class="calibre21">
        cout
       </code>
       . The wide versions of these streams have similar links.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0040">
      </span>
      <h3 class="calibre27" id="head-3-296">
       Read an Entire File
      </h3>
      <p class="calibre13">
       You can use
       <code class="calibre21">
        getline()
       </code>
       to read the entire contents of a file by specifying
       <code class="calibre21">
        \0
       </code>
       as the delimiter. This works only as long as the file doesn't contain any
       <code class="calibre21">
        \0
       </code>
       characters in its contents. For example:
      </p>
      <pre class="calibre26" id="c13-code-0062"><code class="calibre21">ifstream inputFile { "some_data.txt" };</code>
<span aria-label="527" class="calibre20" epub:type="pagebreak" id="Page_527" role="doc-pagebreak"></span><code class="calibre21">if (inputFile.fail()) {</code>
<code class="calibre21">    println(cerr, "Unable to open file for reading.");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21">string fileContents;</code>
<code class="calibre21"><b class="calibre14">getline(inputFile, fileContents, '\0');</b></code>
<code class="calibre21">println("\"{}\"", fileContents);</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-154" class="calibre2">
     <span class="calibre" id="c13-sec-0041">
     </span>
     <h2 class="calibre6" id="head-2-154">
      BIDIRECTIONAL I/O
     </h2>
     <p class="calibre13" id="c13-para-0150">
      So far, this chapter has discussed input and output streams as two separate but related classes. However, there is such a thing as a stream that performs both input and output: a
      <i class="calibre18">
       bidirectional stream
      </i>
      .
     </p>
     <p class="calibre13" id="c13-para-0151">
      Bidirectional streams derive from
      <code class="calibre21">
       iostream
      </code>
      , which in turn derives from both
      <code class="calibre21">
       istream
      </code>
      and
      <code class="calibre21">
       ostream
      </code>
      , thus serving as an example of useful multiple inheritance. As you would expect, bidirectional streams support both the
      <code class="calibre21">
       &gt;&gt;
      </code>
      operator and the
      <code class="calibre21">
       &lt;&lt;
      </code>
      operator, as well as the member functions of both input streams and output streams.
     </p>
     <p class="calibre13">
      The
      <code class="calibre21">
       fstream
      </code>
      class provides a bidirectional file stream.
      <code class="calibre21">
       fstream
      </code>
      is ideal for applications that need to replace data within a file, because you can read until you find the correct position and then immediately switch to writing. For example, imagine a program that stores a list of mappings between ID numbers and phone numbers. It might use a data file with the following format:
     </p>
     <pre class="calibre26" id="c13-code-0063"><code class="calibre21">123 408-555-0394</code>
<code class="calibre21">124 415-555-3422</code>
<code class="calibre21">263 585-555-3490</code>
<code class="calibre21">100 650-555-3434</code></pre>
     <p class="calibre13">
      A reasonable approach to such a program would be to read in the entire data file when the program opens and rewrite the file, with any modifications, when the program closes. If the data set is huge, however, you might not be able to keep everything in memory. With
      <code class="calibre21">
       iostream
      </code>
      s, you don't have to. You can easily scan through the file to find a record, and you can add new records by opening the file for output in append mode. To modify an existing record, you could use a bidirectional stream, as in the following function that changes the phone number for a given ID:
     </p>
     <pre class="calibre26" id="c13-code-0064"><code class="calibre21">bool changeNumberForID(const string&amp; filename, int id, string_view newNumber)</code>
<code class="calibre21">{</code>
<code class="calibre21">    fstream ioData { filename };</code>
<code class="calibre21">    if (!ioData) {</code>
<code class="calibre21">        println(cerr, "Error while opening file {}.", filename);</code>
<code class="calibre21">        return false;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Loop until the end of file.</span></code>
<code class="calibre21">    while (ioData) {</code>
<code class="calibre21">        <span class="color">// Read the next ID.</span></code>
<code class="calibre21">        int idRead;</code>
<code class="calibre21">        ioData &gt;&gt; idRead;</code>
<code class="calibre21">        if (!ioData) { break; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Check to see if the current record is the one being changed.</span></code>
<code class="calibre21">        if (idRead == id) {</code>
<code class="calibre21">            <span class="color">// Seek the write position to the current read position.</span></code>
<span aria-label="528" class="calibre20" epub:type="pagebreak" id="Page_528" role="doc-pagebreak"></span><code class="calibre21">            ioData.seekp(ioData.tellg());</code>
<code class="calibre21">            <span class="color">// Output a space, then the new number.</span></code>
<code class="calibre21">            ioData &lt;&lt; " " &lt;&lt; newNumber;</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Read the current number to advance the stream.</span></code>
<code class="calibre21">        string number;</code>
<code class="calibre21">        ioData &gt;&gt; number;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13" id="c13-para-0154">
      Of course, an approach like this only works properly if the data is of a fixed size. When the preceding program switched from reading to writing, the output data overwrote other data in the file. To preserve the format of the file and to avoid writing over the next record, the data had to be the exact same size.
     </p>
     <p class="calibre13">
      String streams can also be accessed in a bidirectional manner through the
      <code class="calibre21">
       stringstream
      </code>
      class.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c13-para-0156">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Bidirectional streams have separate pointers for the read position and the write position. When switching between reading and writing, you need to seek the appropriate position
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-155" class="calibre2">
     <span class="calibre" id="c13-sec-0043">
     </span>
     <h2 class="calibre6" id="head-2-155">
      FILESYSTEM SUPPORT LIBRARY
     </h2>
     <p class="calibre13" id="c13-para-0157">
      The C++ Standard Library includes a filesystem support library, defined in
      <code class="calibre21">
       &lt;filesystem&gt;
      </code>
      and living in the
      <code class="calibre21">
       std::filesystem
      </code>
      namespace. It allows you to write portable code to work with the filesystem. You can use it for querying whether something is a directory or a file, iterating over the contents of a directory, manipulating paths, and retrieving information about files such as their size, extension, creation time, and so on. The two most important parts of the library—paths and directory entries—are introduced in the next sections.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0044">
      </span>
      <h3 class="calibre27" id="head-3-297">
       Path
      </h3>
      <p class="calibre13">
       The basic component of the library is a
       <code class="calibre21">
        path
       </code>
       . A
       <code class="calibre21">
        path
       </code>
       can be absolute or relative and can optionally include a filename. For example, the following code defines a couple of
       <code class="calibre21">
        path
       </code>
       s. Note the use of raw string literals, introduced in
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       , to avoid having to escape backslashes:
      </p>
      <pre class="calibre26" id="c13-code-0065"><code class="calibre21">path p1 { R"(D:\Foo\Bar)" };</code>
<code class="calibre21">path p2 { "D:/Foo/Bar" };</code>
<code class="calibre21">path p3 { "D:/Foo/Bar/MyFile.txt" };</code>
<code class="calibre21">path p4 { R"(..\SomeFolder)" };</code>
<code class="calibre21">path p5 { "/usr/lib/X11" };</code></pre>
      <p class="calibre13">
       A
       <code class="calibre21">
        path
       </code>
       can be converted to the native format of the system on which the code is running by calling
       <code class="calibre21">
        string()
       </code>
       . Here's an example:
      </p>
      <pre class="calibre26" id="c13-code-0066"><code class="calibre21">println("{}", p1.string());</code>
<code class="calibre21">println("{}", p2.string());</code></pre>
      <p class="calibre13">
       <span aria-label="529" class="calibre20" epub:type="pagebreak" id="Page_529" role="doc-pagebreak">
       </span>
       The output on Windows, which supports both forward and backward slashes, is as follows:
      </p>
      <pre class="calibre26" id="c13-code-0067"><code class="calibre21">D:\Foo\Bar</code>
<code class="calibre21">D:/Foo/Bar</code></pre>
      <p class="calibre13">
       You can append a component to a
       <code class="calibre21">
        path
       </code>
       with the
       <code class="calibre21">
        append()
       </code>
       member function or with
       <code class="calibre21">
        operator/=
       </code>
       . A platform-dependent path separator is automatically inserted. Here's an example:
      </p>
      <pre class="calibre26" id="c13-code-0068"><code class="calibre21">path p { "D:\\Foo" };</code>
<code class="calibre21"><b class="calibre14">p.append("Bar");</b></code>
<code class="calibre21"><b class="calibre14">p /= "Bar";</b></code>
<code class="calibre21">println("{}", p.string());</code></pre>
      <p class="calibre13" id="c13-para-0162">
       The output on Windows is
       <code class="calibre21">
        D:\Foo\Bar\Bar
       </code>
       .
      </p>
      <p class="calibre13">
       You can use
       <code class="calibre21">
        concat()
       </code>
       or
       <code class="calibre21">
        operator+=
       </code>
       to concatenate a string to an existing
       <code class="calibre21">
        path
       </code>
       . This does not insert any path separator! Here's an example:
      </p>
      <pre class="calibre26" id="c13-code-0069"><code class="calibre21">path p { "D:\\Foo" };</code>
<code class="calibre21"><b class="calibre14">p.concat("Bar");</b></code>
<code class="calibre21"><b class="calibre14">p += "Bar";</b></code>
<code class="calibre21">println("{}", p.string());</code></pre>
      <p class="calibre13">
       The output on Windows now is
       <code class="calibre21">
        D:\FooBarBar
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c13-para-0165">
          <b class="calibre14">
           WARNING
          </b>
          <code class="calibre21">
           append()
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           operator/=
          </code>
          <i class="calibre18">
           automatically insert a platform-dependent path separator, while
          </i>
          <code class="calibre21">
           concat()
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           operator+=
          </code>
          <i class="calibre18">
           do not.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       A range-based
       <code class="calibre21">
        for
       </code>
       loop can be used to iterate over the different components of a
       <code class="calibre21">
        path
       </code>
       . Here is an example:
      </p>
      <pre class="calibre26" id="c13-code-0070"><code class="calibre21">path p { R"(C:\Foo\Bar)" };</code>
<code class="calibre21">for (const auto&amp; component : p) {</code>
<code class="calibre21">    println("{}", component.string());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output on Windows is as follows:
      </p>
      <pre class="calibre26" id="c13-code-0071"><code class="calibre21">C:</code>
<code class="calibre21">\</code>
<code class="calibre21">Foo</code>
<code class="calibre21">Bar</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        path
       </code>
       interface supports operations such as
       <code class="calibre21">
        remove_filename()
       </code>
       ,
       <code class="calibre21">
        replace:filename()
       </code>
       ,
       <code class="calibre21">
        replace:extension()
       </code>
       ,
       <code class="calibre21">
        root_name()
       </code>
       ,
       <code class="calibre21">
        parent_path()
       </code>
       ,
       <code class="calibre21">
        extension()
       </code>
       ,
       <code class="calibre21">
        stem()
       </code>
       ,
       <code class="calibre21">
        filename()
       </code>
       ,
       <code class="calibre21">
        has_extension()
       </code>
       ,
       <code class="calibre21">
        is_absolute()
       </code>
       ,
       <code class="calibre21">
        is_relative()
       </code>
       , and more. A few of these are demonstrated in the following code snippet:
      </p>
      <pre class="calibre26" id="c13-code-0072"><code class="calibre21">path p { R"(C:\Foo\Bar\file.txt)" };</code>
<code class="calibre21">println("{}", p.root_name().string());</code>
<code class="calibre21">println("{}", p.filename().string());</code>
<code class="calibre21">println("{}", p.stem().string());</code>
<code class="calibre21">println("{}", p.extension().string());</code></pre>
      <p class="calibre13">
       <span aria-label="530" class="calibre20" epub:type="pagebreak" id="Page_530" role="doc-pagebreak">
       </span>
       This code produces the following result on Windows:
      </p>
      <pre class="calibre26" id="c13-code-0073"><code class="calibre21">C:</code>
<code class="calibre21">file.txt</code>
<code class="calibre21">file</code>
<code class="calibre21">.txt</code></pre>
      <p class="calibre13" id="c13-para-0170">
       Consult your favorite Standard Library reference for a full list of all available functionality.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-298">
       Directory Entry
      </h3>
      <p class="calibre13" id="c13-para-0171">
       A
       <code class="calibre21">
        path
       </code>
       just represents a directory or a file on a filesystem. A
       <code class="calibre21">
        path
       </code>
       may refer to a non-existing directory or file. If you want to query an actual directory or file on the filesystem, you need to construct a
       <code class="calibre21">
        directory_entry
       </code>
       from a
       <code class="calibre21">
        path
       </code>
       . The
       <code class="calibre21">
        directory_entry
       </code>
       interface supports operations such as
       <code class="calibre21">
        exists()
       </code>
       ,
       <code class="calibre21">
        is_directory()
       </code>
       ,
       <code class="calibre21">
        is_regular_file()
       </code>
       ,
       <code class="calibre21">
        file_size()
       </code>
       ,
       <code class="calibre21">
        last_write_time()
       </code>
       , and others.
      </p>
      <p class="calibre13">
       The following example constructs a
       <code class="calibre21">
        directory_entry
       </code>
       from a
       <code class="calibre21">
        path
       </code>
       to query the size of a file:
      </p>
      <pre class="calibre26" id="c13-code-0074"><code class="calibre21">path myPath { "c:/windows/win.ini" };</code>
<code class="calibre21">directory_entry dirEntry { myPath };</code>
<code class="calibre21">if (dirEntry.exists() &amp;&amp; dirEntry.is_regular_file()) {</code>
<code class="calibre21">    println("File size: {}", dirEntry.file_size());</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-299">
       Helper Functions
      </h3>
      <p class="calibre13" id="c13-para-0173">
       An entire collection of helper functions is available as well. For example, you can use
       <code class="calibre21">
        copy()
       </code>
       to copy files or directories,
       <code class="calibre21">
        create_directory()
       </code>
       to create a new directory on the filesystem,
       <code class="calibre21">
        exists()
       </code>
       to query whether a given directory or file exists,
       <code class="calibre21">
        file_size()
       </code>
       to get the size of a file,
       <code class="calibre21">
        last_write_time()
       </code>
       to get the time the file was last modified,
       <code class="calibre21">
        remove()
       </code>
       to delete a file,
       <code class="calibre21">
        temp_directory_path()
       </code>
       to get a directory suitable for storing temporary files,
       <code class="calibre21">
        space()
       </code>
       to query the available space on a filesystem, and more. Consult a Standard Library reference (see
       <a class="calibre5" href="b02.xhtml">
        Appendix B
       </a>
       , “Annotated Bibliography”) for a full list.
      </p>
      <p class="calibre13">
       The following example prints out the capacity of a filesystem and how much space is still free:
      </p>
      <pre class="calibre26" id="c13-code-0075"><code class="calibre21">space:info s { space("c:\\") };</code>
<code class="calibre21">println("Capacity: {}", s.capacity);</code>
<code class="calibre21">println("Free: {}", s.free);</code></pre>
      <p class="calibre13" id="c13-para-0175">
       You can find more examples of these helper functions in the following section on directory iteration.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c13-sec-0048">
      </span>
      <h3 class="calibre27" id="head-3-300">
       Directory Iteration
      </h3>
      <p class="calibre13">
       If you want to recursively iterate over all files and subdirectories in a given directory, you can use a
       <code class="calibre21">
        recursive_directory_iterator
       </code>
       . To start the iteration process, you need an iterator to the first
       <code class="calibre21">
        directory_entry
       </code>
       . To know when to stop the iteration, you need an end iterator. To create the start iterator, construct a
       <code class="calibre21">
        recursive_directory_iterator
       </code>
       and pass as argument a
       <code class="calibre21">
        path
       </code>
       of the directory over which you want to iterate. To construct the end iterator, default construct a
       <code class="calibre21">
        recursive_directory_iterator
       </code>
       . To get access to the
       <code class="calibre21">
        directory_entry
       </code>
       that an iterator refers to, use the dereferencing operator,
       <code class="calibre21">
        *
       </code>
       . Traversing all elements in the collection is accomplished by simply incrementing the iterator using the ++ operator until it reaches the end iterator. Note that the end
       <span aria-label="531" class="calibre20" epub:type="pagebreak" id="Page_531" role="doc-pagebreak">
       </span>
       iterator is not part of the collection anymore and hence does not refer to a valid
       <code class="calibre21">
        directory_entry
       </code>
       and must not be dereferenced.
      </p>
      <pre class="calibre26" id="c13-code-0076"><code class="calibre21">void printDirectoryStructure(const path&amp; p)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (!exists(p)) { return; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    recursive_directory_iterator begin { p };</code>
<code class="calibre21">    recursive_directory_iterator end { };</code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter) {</code>
<code class="calibre21">        const string spacer(iter.depth() * 2, ' ');</code>
<code class="calibre21"> </code>
<code class="calibre21">        auto&amp; entry { *iter }; <span class="color">// Dereference iter to access directory_entry.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">        if (is_regular_file(entry)) {</code>
<code class="calibre21">            println("{}File: {} ({} bytes)",</code>
<code class="calibre21">                spacer, entry.path().string(), file_size(entry));</code>
<code class="calibre21">        } else if (is_directory(entry)) {</code>
<code class="calibre21">            println("{}Dir: {}", spacer, entry.path().string());</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This function can be called as follows:
      </p>
      <pre class="calibre26" id="c13-code-0077"><code class="calibre21">path p { R"(D:\Foo\Bar)" };</code>
<code class="calibre21">printDirectoryStructure(p);</code></pre>
      <p class="calibre13">
       You can also use a
       <code class="calibre21">
        directory_iterator
       </code>
       to iterate over the contents of a directory and implement the recursion yourself. Here is an example that does the same thing as the previous example but using a
       <code class="calibre21">
        directory_iterator
       </code>
       instead of a
       <code class="calibre21">
        recursive_directory_iterator
       </code>
       :
      </p>
      <pre class="calibre26" id="c13-code-0078"><code class="calibre21">void printDirectoryStructure(const path&amp; p, unsigned level = 0)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (!exists(p)) { return; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    const string spacer(level * 2, ' ');</code>
<code class="calibre21"> </code>
<code class="calibre21">    if (is_regular_file(p)) {</code>
<code class="calibre21">        println("{}File: {} ({} bytes)", spacer, p.string(), file_size(p));</code>
<code class="calibre21">    } else if (is_directory(p)) {</code>
<code class="calibre21">        println("{}Dir: {}", spacer, p.string());</code>
<code class="calibre21">        for (auto&amp; entry : directory_iterator { p }) {</code>
<code class="calibre21">            printDirectoryStructure(entry, level + 1);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-156" class="calibre2">
     <span class="calibre" id="c13-sec-0049">
     </span>
     <h2 class="calibre6" id="head-2-156">
      SUMMARY
     </h2>
     <p class="calibre13" id="c13-para-0179">
      Streams provide a flexible and object-oriented way to perform input and output. The most important message in this chapter, even more important than the use of streams, is the concept of a stream. Some operating systems may have their own file access and I/O facilities, but knowledge of how streams and stream-like libraries work is essential to working with any type of modern I/O system.
     </p>
     <p class="calibre13" id="c13-para-0180">
      <span aria-label="532" class="calibre20" epub:type="pagebreak" id="Page_532" role="doc-pagebreak">
      </span>
      The chapter finished with an introduction to the filesystem support library, which you can use to work with files and directories in a platform-independent manner.
     </p>
    </section>
    <section aria-labelledby="head-2-157" class="calibre2">
     <span class="calibre" id="c13-sec-0050">
     </span>
     <h2 class="calibre6" id="head-2-157">
      EXERCISES
     </h2>
     <p class="calibre13" id="c13-para-0181">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c13-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c13-ex-0001">
        <b class="calibre14">
         Exercise 13-1:
        </b>
        Let's revisit the
        <code class="calibre21">
         Person
        </code>
        class you developed during exercises in previous chapters. Take your implementation from Exercise 9-2 and add an
        <code class="calibre21">
         output()
        </code>
        member function that writes the details of a person to the standard output console.
       </li>
       <li class="calibre9" id="c13-ex-0002">
        <b class="calibre14">
         Exercise 13-2:
        </b>
        The
        <code class="calibre21">
         output()
        </code>
        member function from the previous exercise always writes the details of a person to the standard output console. Change the
        <code class="calibre21">
         output()
        </code>
        member function to have an output stream as parameter and write the details of a person to that stream. Test your new implementation in
        <code class="calibre21">
         main()
        </code>
        by writing a person to the standard output console, a string stream, and a file. Notice how it's possible to output a person to all kinds of different targets (output console, string streams, files, and so on) with a single member function using streams.
       </li>
       <li class="calibre9" id="c13-ex-0003">
        <b class="calibre14">
         Exercise 13-3:
        </b>
        Develop a class called
        <code class="calibre21">
         Database
        </code>
        that stores
        <code class="calibre21">
         Person
        </code>
        s (from Exercise 13-2) in an
        <code class="calibre21">
         std::vector
        </code>
        . Provide an
        <code class="calibre21">
         add()
        </code>
        member function to add a person to the database. Also provide a
        <code class="calibre21">
         save()
        </code>
        member function, accepting the name of a file to which it saves all persons in the database. Any existing contents in the file is removed. Add a
        <code class="calibre21">
         load()
        </code>
        member function, accepting the name of a file from which the database loads all persons. Provide a
        <code class="calibre21">
         clear()
        </code>
        member function to remove all persons from the database. Finally, add a member function
        <code class="calibre21">
         outputAll()
        </code>
        that calls
        <code class="calibre21">
         output()
        </code>
        on all persons in the database. Make sure your implementation works, even if there are spaces in a person's first or last name.
       </li>
       <li class="calibre9" id="c13-ex-0004">
        <b class="calibre14">
         Exercise 13-4:
        </b>
        The
        <code class="calibre21">
         Database
        </code>
        from Exercise 13-3 stores all persons in a single file. To practice the filesystem support library, let's change that to store each person in its own file. Modify the
        <code class="calibre21">
         save()
        </code>
        and
        <code class="calibre21">
         load()
        </code>
        member functions to accept a directory as argument where files should be stored to or loaded from. The
        <code class="calibre21">
         save()
        </code>
        member function saves every person in the database to its own file. The name of each file is the first name of the person followed by an underscore followed by the last name of the person. The extension of the files should be
        <code class="calibre21">
         .person
        </code>
        . If a file already exists, overwrite it. The
        <code class="calibre21">
         load()
        </code>
        member function iterates over all
        <code class="calibre21">
         .person
        </code>
        files in a given directory and loads all of them.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
