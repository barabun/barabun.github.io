<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   5
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_012.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_014.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div class="calibre2" id="_idContainer093">
    <h1 class="chapter-number" id="_idParaDest-117">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor117">
     </a>
     5
    </h1>
    <h1 class="calibre5" id="_idParaDest-118">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor118">
     </a>
     OpenGL Implementation
    </h1>
    <p class="calibre3">
     In this chapter, we will learn
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker355">
     </a>
     how to use
     <strong class="bold">
      Open Graphics Library
     </strong>
     (
     <strong class="bold">
      OpenGL
     </strong>
     ), a powerful rendering
     <strong class="bold">
      application program interface
     </strong>
     (
     <strong class="bold">
      API
     </strong>
     ), and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker356">
     </a>
     combine it with
     <strong class="bold">
      Qt
     </strong>
     . OpenGL is a cross-language, cross-platform API for drawing 2D and 3D graphics on screen through
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker357">
     </a>
     the
     <strong class="bold">
      graphics processing unit
     </strong>
     (
     <strong class="bold">
      GPU
     </strong>
     ) within our computer’s graphics chip. In this chapter, we will be learning about OpenGL 3 instead of 2 because, even though the fixed-function pipeline is easier for beginners to grasp compared to the newer programmable pipeline, it is considered legacy code and has been deprecated by most modern 3D rendering software. Qt 6 supports both versions, so there should be no problem switching over to OpenGL 2 if you need backward compatibility for
     <span>
      your software.
     </span>
    </p>
    <p class="calibre3">
     In this chapter, we’re going to cover the following
     <span>
      main topics:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Setting up OpenGL
      <span>
       in Qt
      </span>
     </li>
     <li class="calibre14">
      <span>
       Hello World!
      </span>
     </li>
     <li class="calibre14">
      Rendering
      <span>
       2D shapes
      </span>
     </li>
     <li class="calibre14">
      Rendering
      <span>
       3D shapes
      </span>
     </li>
     <li class="calibre14">
      Texturing
      <span>
       in OpenGL
      </span>
     </li>
     <li class="calibre14">
      Basic lighting
      <span>
       in OpenGL
      </span>
     </li>
     <li class="calibre14">
      Moving an object using
      <span>
       keyboard controls
      </span>
     </li>
     <li class="calibre14">
      Qt Quick 3D
      <span>
       in QML
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-119">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor119">
     </a>
     Technical requirements
    </h1>
    <p class="calibre3">
     The technical requirements for this chapter include Qt 6.6.1 MinGW 64-bit and Qt Creator 12.0.2. All the code used in this chapter can be downloaded from the following GitHub
     <span>
      repository:
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05">
      <span>
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter05
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-120">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor120">
     </a>
     Setting up OpenGL in Qt
    </h1>
    <p class="calibre3">
     In this
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker358">
     </a>
     recipe, we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker359">
     </a>
     will learn how to set up OpenGL in
     <span>
      Qt 6.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-121">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor121">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Follow these steps to learn how to set up OpenGL
     <span>
      in Qt:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New Project
      </strong>
      . Uncheck the
      <strong class="bold">
       Generate form
      </strong>
      option to avoid generating the
      <strong class="source-inline1">
       mainwindow.ui
      </strong>
      ,
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      , and
      <span>
       <strong class="source-inline1">
        mainwindow.cpp
       </strong>
      </span>
      <span>
       files.
      </span>
     </li>
     <li class="calibre14">
      Open up your project file (
      <strong class="source-inline1">
       .pro
      </strong>
      ) and add the OpenGL module to your project by adding an
      <strong class="source-inline1">
       opengl
      </strong>
      keyword behind
      <strong class="source-inline1">
       QT +=
      </strong>
      ; after that, run
      <strong class="source-inline1">
       qmake
      </strong>
      to reload the
      <span>
       project modules:
      </span>
      <pre class="source-code">
QT += core gui opengl</pre>
     </li>
     <li class="calibre14">
      You also need to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker360">
      </a>
      add another line in your project file so that it will load both the OpenGL and
      <strong class="bold">
       OpenGL Utilities
      </strong>
      (
      <strong class="bold">
       GLU
      </strong>
      ) libraries during startup. Without these two libraries, your program will not be able
      <span>
       to run:
      </span>
      <pre class="source-code">
LIBS += -lopengl32 -lglu32</pre>
     </li>
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       main.cpp
      </strong>
      and replace
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      with the
      <span>
       <strong class="source-inline1">
        QtOpenGL
       </strong>
      </span>
      <span>
       header:
      </span>
      <pre class="source-code">
#include &lt;QtOpenGL&gt;</pre>
     </li>
     <li class="calibre14">
      Remove all of the code related to the
      <strong class="source-inline1">
       MainWindow
      </strong>
      class from your
      <strong class="source-inline1">
       main.cpp
      </strong>
      file
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker361">
      </a>
      and replace it with the code that’s highlighted
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker362">
      </a>
      in the
      <span>
       following snippet:
      </span>
      <pre class="source-code">
#include &lt;QApplication&gt;
#include &lt;QtOpenGL&gt;
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    <strong class="bold1">QOpenGLWindow window;</strong>
    <strong class="bold1">window.setTitle("Hello World!");</strong>
    <strong class="bold1">window.resize(640, 480);</strong>
    <strong class="bold1">window.show();</strong>
    <strong class="bold1">return app.exec();</strong>
}</pre>
     </li>
     <li class="calibre14">
      If you compile and run the project now, you will see an empty window with a black background. Don’t worry about it—your program is now running
      <span>
       on OpenGL:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer080">
      <img alt="Figure 5.1 - An empty OpenGL window" class="calibre4" src="image/B20976_05_001.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.1 - An empty OpenGL window
    </p>
    <h2 class="calibre7" id="_idParaDest-122">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor122">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The
     <strong class="source-inline">
      OpenGL
     </strong>
     module
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker363">
     </a>
     must be added to the project file (
     <strong class="source-inline">
      .pro
     </strong>
     ) in order to access header files that are related to OpenGL, such as
     <strong class="source-inline">
      QtOpenGL
     </strong>
     and
     <strong class="source-inline">
      QOpenGLFunctions
     </strong>
     . We used the
     <strong class="source-inline">
      QOpenGLWindow
     </strong>
     class instead of
     <strong class="source-inline">
      QMainWindow
     </strong>
     for the main
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker364">
     </a>
     window because it is designed to easily create windows that perform OpenGL rendering, and it offers better performance compared to
     <strong class="source-inline">
      QOpenGLWidget
     </strong>
     due to the fact that it has no dependencies in its
     <span>
      widget module.
     </span>
    </p>
    <p class="calibre3">
     We must call
     <strong class="source-inline">
      setSurfaceType(QWindow::OpenGLSurface)
     </strong>
     to tell Qt we would prefer to use OpenGL to render the images to screen instead of
     <strong class="source-inline">
      QPainter
     </strong>
     . The
     <strong class="source-inline">
      QOpenGLWindow
     </strong>
     class provides several virtual functions (
     <strong class="source-inline">
      initializeGL()
     </strong>
     ,
     <strong class="source-inline">
      resizeGL()
     </strong>
     ,
     <strong class="source-inline">
      paintGL()
     </strong>
     , and so on) for us to conveniently set up OpenGL and perform graphics rendering. We will be learning how to use these functions in the
     <span>
      following example.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-123">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor123">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     OpenGL is a
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker365">
     </a>
     cross-language, cross-platform API for drawing 2D and 3D graphics
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker366">
     </a>
     on screen through the GPU within our computer’s graphics chip. Computer graphics technology has been evolving rapidly over the years—so rapidly that the software industry can hardly keep up with
     <span>
      its pace.
     </span>
    </p>
    <p class="calibre3">
     In 2008, the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker367">
     </a>
     Khronos Group, the company that maintains and develops OpenGL, announced the release of the OpenGL 3.0 specification, which created a huge uproar and controversy throughout the industry. That was mainly because OpenGL 3.0 was supposed to deprecate the entire fixed-function pipeline from the OpenGL API, and it was simply an impossible task for the big players to make the sudden switch overnight from a fixed-function pipeline to a programmable pipeline. This resulted in two different major versions of OpenGL
     <span>
      being maintained.
     </span>
    </p>
    <p class="calibre3">
     In this chapter, we will use the newer OpenGL 3 instead of the older, deprecated OpenGL 2. The coding style and syntax are very different between these two versions, which makes the switchover very troublesome. However, the performance improvement will make it worth the time it takes to switch over to
     <span>
      OpenGL 3.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-124">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor124">
     </a>
     Hello World!
    </h1>
    <p class="calibre3">
     In this chapter, we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker368">
     </a>
     will learn how to use OpenGL 3 with Qt 6. Common OpenGL functions such as
     <strong class="source-inline">
      glBegin
     </strong>
     ,
     <strong class="source-inline">
      glVertex2f
     </strong>
     ,
     <strong class="source-inline">
      glColor3f
     </strong>
     ,
     <strong class="source-inline">
      glMatrixMode
     </strong>
     , and
     <strong class="source-inline">
      glLoadIdentity
     </strong>
     have all been removed from OpenGL 3. OpenGL 3 uses
     <strong class="bold">
      vertex buffer objects
     </strong>
     (
     <strong class="bold">
      VBOs
     </strong>
     ) to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker369">
     </a>
     send data to the GPU in batches instead of sending them one by one through functions such as
     <strong class="source-inline">
      glVertex2f()
     </strong>
     , which slows down the rendering while waiting for the CPU to submit the data one by one. Therefore, we will pack all of the data into VBOs and send it all in one huge package to the GPU and instruct the GPU to calculate the resulting pixels through shader programming. We will also be learning how to create simple
     <strong class="bold">
      shader programs
     </strong>
     through
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker370">
     </a>
     a C-like programming
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker371">
     </a>
     language called
     <strong class="bold">
      OpenGL Shading
     </strong>
     <span>
      <strong class="bold">
       Language
      </strong>
     </span>
     <span>
      (
     </span>
     <span>
      <strong class="bold">
       GLSL
      </strong>
     </span>
     <span>
      ).
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-125">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor125">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker372">
     </a>
     by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      We will create a new class called
      <strong class="source-inline1">
       RenderWindow
      </strong>
      , which inherits from the
      <strong class="source-inline1">
       QOpenGLWindow
      </strong>
      class. Go to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File
      </strong>
      , then select
      <strong class="bold">
       C++ Class
      </strong>
      under the
      <strong class="bold">
       Files and Classes
      </strong>
      category. Name the class
      <strong class="source-inline1">
       RenderWindow
      </strong>
      and set its base class as
      <strong class="source-inline1">
       QOpenGLWindow
      </strong>
      . Then, proceed to create the
      <span>
       C++ class:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer081">
      <img alt="Figure 5.2 – Defining your custom render window class" class="calibre4" src="image/B20976_05_002.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.2 – Defining your custom render window class
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Go to the
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      file we just created and add the following headers at the top of the
      <span>
       source code:
      </span>
      <pre class="source-code">
#include &lt;GL/glu.h&gt;
#include &lt;QtOpenGL&gt;
#include &lt;QSurfaceFormat&gt;
#include &lt;QOpenGLFunctions&gt;
#include &lt;QOpenGLWindow&gt;
#include &lt;QOpenGLBuffer&gt;
#include &lt;QOpenGLVertexArrayObject&gt;
#include &lt;QOpenGLShader&gt;
#include &lt;QOpenGLShaderProgram&gt;</pre>
     </li>
     <li class="calibre14">
      We need
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker373">
      </a>
      to create several functions and variables that look
      <span>
       like this:
      </span>
      <pre class="source-code">
class RenderWindow : public QOpenGLWindow {
public:
    RenderWindow();
protected:
    <strong class="bold1">void initializeGL();</strong>
    <strong class="bold1">void paintGL();</strong>
    <strong class="bold1">void paintEvent(QPaintEvent *event);</strong>
    <strong class="bold1">void resizeEvent(QResizeEvent *event);</strong></pre>
     </li>
     <li class="calibre14">
      We will continue and add some
      <span>
       private variables:
      </span>
      <pre class="source-code">
private:
    <strong class="bold1">QOpenGLContext* openGLContext;</strong>
    <strong class="bold1">QOpenGLFunctions* openGLFunctions;</strong>
    <strong class="bold1">QOpenGLShaderProgram* shaderProgram;</strong>
    <strong class="bold1">QOpenGLVertexArrayObject* vao;</strong>
    <strong class="bold1">QOpenGLBuffer* vbo_vertices;</strong>
};</pre>
     </li>
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       renderwindow.cpp
      </strong>
      and define the class constructor as follows. We must tell the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker374">
      </a>
      render window to use the OpenGL surface type; enable
      <strong class="bold">
       core profile
      </strong>
      (rather than
      <strong class="bold">
       compatibility profile
      </strong>
      ) that runs version 3.2; create an OpenGL context; and, finally, apply the profile we just created into
      <span>
       the context:
      </span>
      <pre class="source-code">
RenderWindow::RenderWindow() {
    setSurfaceType(QWindow::OpenGLSurface);
    QSurfaceFormat format;
    format.setProfile(QSurfaceFormat::CoreProfile);
    format.setVersion(3, 2);
    setFormat(format);
    openGLContext = new QOpenGLContext();
    openGLContext-&gt;setFormat(format);
    openGLContext-&gt;create();
    openGLContext-&gt;makeCurrent(this);
}</pre>
     </li>
     <li class="calibre14">
      We need to define the
      <strong class="source-inline1">
       initializeGL()
      </strong>
      function as follows. This function will be called before the rendering starts. First, we
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker375">
      </a>
      define the
      <strong class="bold">
       vertex shader
      </strong>
      and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker376">
      </a>
      the
      <span>
       <strong class="bold">
        fragment shader
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
void RenderWindow::initializeGL() {
    openGLFunctions = openGLContext-&gt;functions();
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec2 posAttr;\n"
    "void main() {\n"
    "gl_Position = vec4(posAttr, 0.0, 1.0); }";
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    "out vec4 col;\n"
    "void main() {\n"
    "col = vec4(1.0, 0.0, 0.0, 1.0); }";</pre>
     </li>
     <li class="calibre14">
      We
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker377">
      </a>
      initiate
      <strong class="source-inline1">
       shaderProgram
      </strong>
      and declare a vertices array. Then, we also create a
      <span>
       <strong class="source-inline1">
        QOpenGLVertexArrayObject
       </strong>
      </span>
      <span>
       object:
      </span>
      <pre class="source-code">
    shaderProgram = new QOpenGLShaderProgram(this);
    shaderProgram-&gt;addShaderFromSourceCode(QOpenGLShader::Vertex, vertexShaderSource);
    shaderProgram-&gt;addShaderFromSourceCode(QOpenGLShader::Fragment, fragmentShaderSource);
    shaderProgram-&gt;link();
// The vertex coordinates of our triangle
    GLfloat vertices[] = {
    -1.0f, -1.0f,
    1.0f, -1.0f,
    0.0f, 1.0f };
    vao = new QOpenGLVertexArrayObject();
    vao-&gt;create();
    vao-&gt;bind();</pre>
     </li>
     <li class="calibre14">
      Let’s continue to write our code by
      <span>
       defining
      </span>
      <span>
       <strong class="source-inline1">
        vbo_vertices
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    vbo_vertices = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_vertices-&gt;create();
    vbo_vertices-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_vertices-&gt;bind();
    vbo_vertices-&gt;allocate(vertices, sizeof(vertices) *
    sizeof(GLfloat));
    vao-&gt;release();
}</pre>
     </li>
     <li class="calibre14">
      We will
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker378">
      </a>
      start by adding some code to the
      <span>
       <strong class="source-inline1">
        paintEvent()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void RenderWindow::paintEvent(QPaintEvent *event) {
    Q_UNUSED(event);
    glViewport(0, 0, width(), height());
    // Clear our screen with corn flower blue color
    glClearColor(0.39f, 0.58f, 0.93f, 1.f);
    glClear(GL_COLOR_BUFFER_BIT);</pre>
     </li>
     <li class="calibre14">
      We will then bind the VAO and shader program before
      <span>
       calling
      </span>
      <span>
       <strong class="source-inline1">
        glDrawArrays()
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    vao-&gt;bind();
    shaderProgram-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("posAttr", 0);
    shaderProgram-&gt;enableAttributeArray(0);
    shaderProgram-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 2);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    shaderProgram-&gt;release();
    vao-&gt;release();
}</pre>
     </li>
     <li class="calibre14">
      You can
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker379">
      </a>
      refresh the viewport whenever the render window is being resized by adding the
      <span>
       following code:
      </span>
      <pre class="source-code">
void RenderWindow::resizeEvent(QResizeEvent *event) {
    Q_UNUSED(event);
    glViewport(0, 0, this-&gt;width(), this-&gt;height());
    this-&gt;update();
}</pre>
     </li>
     <li class="calibre14">
      If you compile and run the project now, you should be able to see a red rectangle being drawn in front of a
      <span>
       blue background:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer082">
      <img alt="Figure 5.3 - Our first triangle rendered in OpenGL" class="calibre4" src="image/B20976_05_003.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.3 - Our first triangle rendered in OpenGL
    </p>
    <h2 class="calibre7" id="_idParaDest-126">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor126">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     We must set the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker380">
     </a>
     OpenGL version to 3.x and the surface format to the core profile so that we can access the newer shader pipeline, which is completely different from the older, deprecated compatibility profile. OpenGL 2.x still exists in the compatibility profile, solely for the sake of allowing OpenGL programs to run on old hardware. The profile that’s created must be applied to the OpenGL context before it
     <span>
      will work.
     </span>
    </p>
    <p class="calibre3">
     In OpenGL 3 and the later versions, most of the calculations are done in the GPU through shader programs, since all of the common fixed functions have now been completely deprecated. Therefore, we created a very simple vertex shader and fragment shader in the
     <span>
      preceding example.
     </span>
    </p>
    <p class="calibre3">
     A shader program consists of three different parts:
     <strong class="bold">
      geometry shader
     </strong>
     (optional), vertex shader, and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker381">
     </a>
     fragment shader. The geometry shader calculates the creation of geometry before passing the data to the vertex shader; the vertex shader handles the position and motion of the vertices before passing the data to the fragment shader; and finally, the fragment shader calculates and displays the resulting pixels on
     <span>
      the screen.
     </span>
    </p>
    <p class="calibre3">
     In the preceding example, we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker382">
     </a>
     only used vertex and fragment shaders and excluded the geometry shader since it is optional. You can save the GLSL code in a text file and load it into your Qt 6 program by calling
     <strong class="source-inline">
      addShaderFromFile()
     </strong>
     , but since our shaders are very simple and short, we just define it directly in our C++
     <span>
      source code.
     </span>
    </p>
    <p class="calibre3">
     After that, we use the VBO to store the vertex positions in bulk before sending it to the GPU. We can also use the VBO to store other information such as normals, texture coordinates, and vertex colors. You can send anything you want to the GPU as long as it matches the input inside your shader code. Then, we add the VBO into a
     <strong class="bold">
      vertex array object
     </strong>
     (
     <strong class="bold">
      VAO
     </strong>
     ) and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker383">
     </a>
     send the whole VAO to the GPU for processing. You can add many different VBOs into the VAO since the VAO is just like any ordinary
     <span>
      C++ array.
     </span>
    </p>
    <p class="calibre3">
     Just like what we have learned in the previous chapters, all drawings happen within the
     <strong class="source-inline">
      paintEvent()
     </strong>
     function, and it will only be called by Qt when it thinks it is necessary to refresh the screen. To force Qt to update the screen, call
     <strong class="source-inline">
      update()
     </strong>
     manually. Also, we must update the viewport whenever the window screen has been resized by calling
     <strong class="source-inline">
      glViewport(x, y ,
     </strong>
     <span>
      <strong class="source-inline">
       width, height)
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-127">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor127">
     </a>
     Rendering 2D shapes
    </h1>
    <p class="calibre3">
     Since we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker384">
     </a>
     have already learned how to draw our first rectangle on screen, we will further enhance it in this section. We will take the previous example and continue
     <span>
      from there.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-128">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor128">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started by following
     <span>
      this example:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      and add two more VBOs, one called
      <strong class="source-inline1">
       vbo_vertices2
      </strong>
      and another called
      <strong class="source-inline1">
       vbo_colors
      </strong>
      , as highlighted in the
      <span>
       following code:
      </span>
      <pre class="source-code">
private:
    QOpenGLContext* openGLContext;
    QOpenGLFunctions* openGLFunctions;
    QOpenGLShaderProgram* shaderProgram;
    QOpenGLVertexArrayObject* vao;
    QOpenGLBuffer* vbo_vertices;
    <strong class="bold1">QOpenGLBuffer* vbo_vertices2;</strong>
    <strong class="bold1">QOpenGLBuffer* vbo_colors;</strong></pre>
     </li>
     <li class="calibre14">
      Open
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker385">
      </a>
      up
      <strong class="source-inline1">
       renderwindow.cpp
      </strong>
      and add the following code to the shader code, as highlighted in the
      <span>
       following snippet:
      </span>
      <pre class="source-code">
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec2 posAttr;\n"
    <strong class="bold1">"layout(location = 1) in vec3 colAttr;\n"</strong>
    <strong class="bold1">"out vec3 fragCol;\n"</strong>
    "void main() {\n"
    <strong class="bold1">"fragCol = colAttr;\n"</strong>
    "gl_Position = vec4(posAttr, 1.0, 1.0); }";</pre>
     </li>
     <li class="calibre14">
      Add the highlighted code to the fragment shader, which looks
      <span>
       like this:
      </span>
      <pre class="source-code">
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    <strong class="bold1">"in vec3 fragCol;\n"</strong>
    "out vec4 col;\n"
    "void main() {\n"
    <strong class="bold1">"col = vec4(fragCol, 1.0); }";</strong></pre>
     </li>
     <li class="calibre14">
      Change
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker386">
      </a>
      the vertices array to something like the following code. What we’re doing here is creating three arrays that keep the vertices of two triangles and their colors so that we can pass them to the fragment shader at a
      <span>
       later stage:
      </span>
      <pre class="source-code">
    GLfloat vertices[] = {
    -0.3f, -0.5f,
    0.8f, -0.4f,
    0.2f, 0.6f };
    GLfloat vertices2[] = {
    0.5f, 0.3f,
    0.4f, -0.8f,
    -0.6f, -0.2f };
    GLfloat colors[] = {
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f };</pre>
     </li>
     <li class="calibre14">
      Since we already initialized
      <strong class="source-inline1">
       vbo_vertices
      </strong>
      in the previous example, this time, we only need to initialize two other VBOs, namely
      <strong class="source-inline1">
       vbo_vertices
      </strong>
      <span>
       and
      </span>
      <span>
       <strong class="source-inline1">
        vbo_colors
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    vbo_vertices2 = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_vertices2-&gt;create();
    vbo_vertices2-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_vertices2-&gt;bind();
    vbo_vertices2-&gt;allocate(vertices2, sizeof(vertices2) *
    sizeof(GLfloat));
    vbo_colors = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_colors-&gt;create();
    vbo_colors-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_colors-&gt;bind();
    vbo_colors-&gt;allocate(colors, sizeof(colors) * sizeof(GLfloat));</pre>
     </li>
     <li class="calibre14">
      Before
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker387">
      </a>
      we start drawing the triangle using
      <strong class="source-inline1">
       glDrawArrays()
      </strong>
      , we must also add the data of
      <strong class="source-inline1">
       vbo_colors
      </strong>
      into our shader’s
      <strong class="source-inline1">
       colAttr
      </strong>
      attribute. Make sure you call
      <strong class="source-inline1">
       bind()
      </strong>
      to set the VBO as the current active VBO, before sending the data to the shader. The location ID (in this case,
      <strong class="source-inline1">
       0
      </strong>
      and
      <strong class="source-inline1">
       1
      </strong>
      ) must match the location ID that’s used in
      <span>
       your shader:
      </span>
      <pre class="source-code">
    <strong class="bold1">vbo_vertices-&gt;bind();</strong>
    shaderProgram-&gt;bindAttributeLocation("posAttr", 0);
    shaderProgram-&gt;enableAttributeArray(0);
    shaderProgram-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 2);
    <strong class="bold1">vbo_colors-&gt;bind();</strong>
    <strong class="bold1">shaderProgram-&gt;bindAttributeLocation("colAttr", 1);</strong>
    <strong class="bold1">shaderProgram-&gt;enableAttributeArray(1);</strong>
    <strong class="bold1">shaderProgram-&gt;setAttributeBuffer(1, GL_FLOAT, 0, 3);</strong>
    glDrawArrays(GL_TRIANGLES, 0, 3);</pre>
     </li>
     <li class="calibre14">
      Right after the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker388">
      </a>
      preceding code, we will send
      <strong class="source-inline1">
       vbo_vertices2
      </strong>
      and
      <strong class="source-inline1">
       vbo_colors
      </strong>
      to the shader attribute and call
      <strong class="source-inline1">
       glDrawArrays()
      </strong>
      again to draw the
      <span>
       second triangle:
      </span>
      <pre class="source-code">
    vbo_vertices2-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("posAttr", 0);
    shaderProgram-&gt;enableAttributeArray(0);
    shaderProgram-&gt;setAttributeBuffer(0, GL_FLOAT, 0, 2);
    vbo_colors-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("colAttr", 1);
    shaderProgram-&gt;enableAttributeArray(1);
    shaderProgram-&gt;setAttributeBuffer(1, GL_FLOAT, 0, 3);
    glDrawArrays(GL_TRIANGLES, 0, 3);</pre>
     </li>
     <li class="calibre14">
      If you build the program now, you should be able to see two triangles on screen, and one of the triangles sitting on top of
      <span>
       the other:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer083">
      <img alt="Figure 5.4 – Two colorful triangles overlapping each other" class="calibre4" src="image/B20976_05_004.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.4 – Two colorful triangles overlapping each other
    </p>
    <h2 class="calibre7" id="_idParaDest-129">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor129">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     The geometric primitive
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker389">
     </a>
     types supported by OpenGL are points, lines, line strips, line loops, polygons, quads, quad strips, triangles, triangle strips, and triangle fans. In this example, we drew two triangles, where each of the shapes is provided with a set of vertices and colors so that OpenGL knows how the shapes should
     <span>
      be rendered.
     </span>
    </p>
    <p class="calibre3">
     The rainbow color effect is created by giving a different color to each of the vertices. OpenGL will automatically interpolate the colors between each vertex and display it on screen. Currently, the shape that gets rendered first will appear at the back of other shapes that get rendered later. This is because we are rendering the shapes in a 2D space and no depth information is involved to check which shape is located at the front and so on. We will learn how to do depth checking in the
     <span>
      following example.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-130">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor130">
     </a>
     Rendering 3D shapes
    </h1>
    <p class="calibre3">
     We learned
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker390">
     </a>
     how to draw simple 2D shapes onscreen in the previous section. However, to fully utilize the OpenGL API, we also need to learn how to use it to render 3D images. In a nutshell, 3D images are simply illusions that are created using 2D shapes, stacked in such a way that it makes them look like
     <span>
      they’re 3D.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-131">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor131">
     </a>
     How to do it...
    </h2>
    <p class="calibre3">
     The main ingredient here is the depth value, which determines which shapes should appear in front of or behind the other shapes. The primitive shape that is positioned behind another surface (with a shallower depth than another shape) will not be rendered (or will be partially rendered). OpenGL provides a simple way to
     <span>
      achieve this:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s continue our project from the previous 2D example. Enable depth testing by adding
      <strong class="source-inline1">
       glEnable(GL_DEPTH_TEST)
      </strong>
      to the
      <strong class="source-inline1">
       initializeGL()
      </strong>
      function
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        renderwindow.cpp
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
void RenderWindow::initializeGL() {
    openGLFunctions = openGLContext-&gt;functions();
    <strong class="bold1">glEnable(GL_DEPTH_TEST);</strong></pre>
     </li>
     <li class="calibre14">
      Since we have enabled
      <strong class="source-inline1">
       GL_DEPTH_TEST
      </strong>
      in the preceding step, we must also set the depth buffer size when setting the
      <span>
       OpenGL profile:
      </span>
      <pre class="source-code">
    QSurfaceFormat format;
    format.setProfile(QSurfaceFormat::CoreProfile);
    format.setVersion(3, 2);
    <strong class="bold1">format.setDepthBufferSize(16);</strong></pre>
     </li>
     <li class="calibre14">
      We will change our vertices array into something longer, which is the vertex information of a 3D cube shape. The vertex coordinates in the next code block are divided into three values per vertex coordinate, which eventually form a 3D cube. It’s not realistic to hardcode the vertices of complex shapes, but achievable for simple shapes like this. We can remove the colors array for now since you are not supplying the color information to the shader this time. We can also
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker391">
      </a>
      remove the
      <strong class="source-inline1">
       vbo_colors
      </strong>
      VBO for the
      <span>
       same reason:
      </span>
      <pre class="source-code">
    GLfloat vertices[] = {
     -1.0f,-1.0f,-1.0f,1.0f,-1.0f,-1.0f,-1.0f,-1.0f, 1.0f,
     1.0f,-1.0f,-1.0f,1.0f,-1.0f, 1.0f,-1.0f,-1.0f, 1.0f,
     -1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,1.0f, 1.0f,-1.0f,
     1.0f, 1.0f,-1.0f,-1.0f, 1.0f, 1.0f,1.0f, 1.0f, 1.0f,
     -1.0f,-1.0f, 1.0f,1.0f,-1.0f, 1.0f,-1.0f, 1.0f, 1.0f,
     1.0f,-1.0f, 1.0f,1.0f, 1.0f, 1.0f,-1.0f, 1.0f, 1.0f,
     -1.0f,-1.0f,-1.0f,-1.0f, 1.0f,-1.0f,1.0f,-1.0f,-1.0f,
     1.0f,-1.0f,-1.0f,-1.0f, 1.0f,-1.0f,1.0f, 1.0f,-1.0f,
     -1.0f,-1.0f, 1.0f,-1.0f, 1.0f,-1.0f,-1.0f,-1.0f,-1.0f,
     -1.0f,-1.0f, 1.0f,-1.0f, 1.0f, 1.0f,-1.0f, 1.0f,-1.0f,
     1.0f,-1.0f, 1.0f,1.0f,-1.0f,-1.0f,1.0f, 1.0f,-1.0f,
     1.0f,-1.0f, 1.0f,1.0f, 1.0f,-1.0f,1.0f, 1.0f, 1.0f
 };</pre>
     </li>
     <li class="calibre14">
      In the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function, we must add
      <strong class="source-inline1">
       GL_DEPTH_BUFFER_BIT
      </strong>
      to the
      <strong class="source-inline1">
       glClear()
      </strong>
      function
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker392">
      </a>
      since we enabled depth checking in
      <strong class="source-inline1">
       initializeGL()
      </strong>
      in the
      <span>
       previous step:
      </span>
      <pre class="source-code">
glClear(GL_<strong class="source-inline2">COLOR</strong>_BUFFER_BIT | <strong class="bold1">GL_DEPTH_BUFFER_BIT</strong>);</pre>
     </li>
     <li class="calibre14">
      After that, we need to send a piece of matrix information to the shader called
      <strong class="bold">
       ModelView-Projection
      </strong>
      (
      <strong class="bold">
       MVP
      </strong>
      ) so that
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker393">
      </a>
      the GPU knows how to render the 3D shapes on a 2D screen. The MVP matrix is the result of multiplication between the projection matrix, view matrix, and model matrix. The multiplication order is very important so that you get the
      <span>
       correct result:
      </span>
      <pre class="source-code">
    QMatrix4x4 matrixMVP;
    QMatrix4x4 model, view, projection;
    model.translate(0, 1, 0);
    model.rotate(45, 0, 1, 0);
    view.lookAt(QVector3D(4, 4, 0), QVector3D(0, 0, 0),
    QVector3D(0, 1, 0));
    projection.perspective(60.0f,
     ((float)this-&gt;width()/(float)this-&gt;height()), 0.1f, 100.0f);
    matrixMVP = projection * view * model;
    shaderProgram-&gt;setUniformValue("matrix", matrixMVP);</pre>
     </li>
     <li class="calibre14">
      Change the last value in
      <strong class="source-inline1">
       glDrawArrays()
      </strong>
      to
      <strong class="source-inline1">
       36
      </strong>
      since we now have 36 triangles in the
      <span>
       cube shape:
      </span>
      <pre class="source-code">
    glDrawArrays(GL_TRIANGLES, 0, 36);</pre>
     </li>
     <li class="calibre14">
      We have to go back to our shader code and change some parts of it, as highlighted in the
      <span>
       following code:
      </span>
      <pre class="source-code">
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec3 posAttr;\n"
    <strong class="bold1">"uniform mat4 matrix;\n"</strong>
    <strong class="bold1">"out vec3 fragPos;\n"</strong>
    "void main() {\n"
    <strong class="bold1">"fragPos = posAttr;\n"</strong>
    <strong class="bold1">"gl_Position = matrix * vec4(posAttr, 1.0); }";</strong>
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    <strong class="bold1">"in vec3 fragPos;\n"</strong>
    "out vec4 col;\n"
    "void main() {\n"
    <strong class="bold1">"col = vec4(fragPos, 1.0); }";</strong></pre>
     </li>
     <li class="calibre14">
      If you build
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker394">
      </a>
      and run the project now, you should see a colorful cube appear on the screen. We use the same vertices array for the color, which gives this
      <span>
       colorful result:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer084">
      <img alt="Figure 5.5 – Colorful 3D cube rendered with OpenGL" class="calibre4" src="image/B20976_05_005.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.5 – Colorful 3D cube rendered with OpenGL
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="9">
      Even though
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker395">
      </a>
      the result looks pretty good, if we want to really show off the 3D effect, it would be by animating the cube. To do that, first, we need to open up
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      and include the following header
      <span>
       to it:
      </span>
      <pre class="source-code">
#include &lt;QElapsedTimer&gt;</pre>
     </li>
     <li class="calibre14">
      Then, add the following variables to
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      . Note that you are allowed to initialize variables in the header file in modern C++ standard, which was not the case back in the older
      <span>
       C++ standard:
      </span>
      <pre class="source-code">
    QElapsedTimer* time;
    int currentTime = 0;
    int oldTime = 0;
    float deltaTime = 0;
    float rotation = 0;</pre>
     </li>
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       renderwindow.cpp
      </strong>
      and add the following highlighted code to the
      <span>
       class constructor:
      </span>
      <pre class="source-code">
    openGLContext = new QOpenGLContext();
    openGLContext-&gt;setFormat(format);
    openGLContext-&gt;create();
    openGLContext-&gt;makeCurrent(this);
    <strong class="bold1">time = new QElapsedTimer();</strong>
    <strong class="bold1">time-&gt;start();</strong></pre>
     </li>
     <li class="calibre14">
      After that, add
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker396">
      </a>
      the following highlighted code to the top of your
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function.
      <strong class="source-inline1">
       deltaTime
      </strong>
      is the value of the elapsed time of each frame, which is used to make animation speed consistent, regardless of frame
      <span>
       rate performance:
      </span>
      <pre class="source-code">
void RenderWindow::paintEvent(QPaintEvent *event) {
    Q_UNUSED(event);
    <strong class="bold1">// Delta time for each frame</strong>
    <strong class="bold1">currentTime = time-&gt;elapsed();</strong>
    <strong class="bold1">deltaTime = (float)(currentTime - oldTime) / 1000.0f;</strong>
    <strong class="bold1">oldTime = currentTime;</strong></pre>
     </li>
     <li class="calibre14">
      Add the following highlighted code on top of your MVP matrix code and apply the
      <strong class="source-inline1">
       rotation
      </strong>
      variable to the
      <strong class="source-inline1">
       rotate()
      </strong>
      function,
      <span>
       like so:
      </span>
      <pre class="source-code">
    rotation += deltaTime * 50;
    QMatrix4x4 matrixMVP;
    QMatrix4x4 model, view, projection;
    model.translate(0, 1, 0);
    model.rotate(rotation, 0, 1, 0);</pre>
     </li>
     <li class="calibre14">
      Call the
      <strong class="source-inline1">
       update()
      </strong>
      function
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker397">
      </a>
      at the end of the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function so that
      <strong class="source-inline1">
       paintEvent()
      </strong>
      will be called again and again at the end of each draw call. Since we are changing the rotation value in the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function, we can give the viewer the illusion of a
      <span>
       rotating cube:
      </span>
      <pre class="source-code">
    glDrawArrays(GL_TRIANGLES, 0, 36);
    shaderProgram-&gt;release();
    vao-&gt;release();
    <strong class="bold1">this-&gt;update();</strong>
}</pre>
     </li>
     <li class="calibre14">
      If you compile and run the program now, you should see a spinning cube in your
      <span>
       render window!
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-132">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor132">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     In any 3D rendering, depth is very important and hence we need to enable the depth testing feature in OpenGL by calling
     <strong class="source-inline">
      glEnable(GL_DEPTH_TEST)
     </strong>
     . When we clear the buffer, we must also specify
     <strong class="source-inline">
      GL_DEPH_BUFFER_BIT
     </strong>
     so that the depth information is also being cleared, in order for the next image to be
     <span>
      rendered correctly.
     </span>
    </p>
    <p class="calibre3">
     We use the MVP matrix in OpenGL so that the GPU knows how to render the 3D graphics correctly. In OpenGL 3 and later versions, OpenGL no longer handles this automatically through fixed functions. Programmers are given the freedom and flexibility to define their own matrices based on their use cases, and then simply supply it to the GPU through a shader for rendering the final image. The model matrix contains the transformation data of the 3D object, namely the position, rotation, and scale of the object. The view matrix, on the other hand, is the camera or view information. Lastly, the projection matrix tells the GPU which projection method to use when projecting the 3D world onto the
     <span>
      2D screen.
     </span>
    </p>
    <p class="calibre3">
     In our example, we used the perspective projection method, which gives a better perception of distance and depth. The opposite of perspective projection is
     <strong class="bold">
      orthographic projection
     </strong>
     , which
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker398">
     </a>
     makes everything look flat
     <span>
      and parallel:
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer085">
      <img alt="Figure 5.6 – Differences between perspective and orthographic views" class="calibre4" src="image/B20976_05_006.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.6 – Differences between perspective and orthographic views
    </p>
    <p class="calibre3">
     In this example, we used a timer to increase the rotation value by 50 by multiplying it with the
     <strong class="source-inline">
      deltaTime
     </strong>
     value. The
     <strong class="source-inline">
      deltaTime
     </strong>
     value varies, depending on your rendering frame rate. However, it makes the resulting animation speed consistent across different hardware that renders at a different
     <span>
      frame rate.
     </span>
    </p>
    <p class="calibre3">
     Remember to call
     <strong class="source-inline">
      update()
     </strong>
     manually so that the screen gets refreshed, otherwise the cube will not
     <span>
      be animated.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-133">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor133">
     </a>
     Texturing in OpenGL
    </h1>
    <p class="calibre3">
     OpenGL allows us to map an image (also referred to as a
     <strong class="bold">
      texture
     </strong>
     ) to a 3D shape or polygon. This process is also called texture mapping. Qt 6 appears to be the best combination
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker399">
     </a>
     with OpenGL in this case because it provides an easy way to load images that belong to one of the common formats (
     <strong class="source-inline">
      BMP
     </strong>
     ,
     <strong class="source-inline">
      JPEG
     </strong>
     ,
     <strong class="source-inline">
      PNG
     </strong>
     ,
     <strong class="source-inline">
      TARGA
     </strong>
     ,
     <strong class="source-inline">
      TIFF
     </strong>
     , and so on), and you do not have to implement it by yourself. We will use the previous example with a spinning cube and try to map it with
     <span>
      a texture!
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-134">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor134">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s follow
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker400">
     </a>
     these steps to learn how to use textures
     <span>
      in OpenGL:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      and add the variables that are highlighted in the following
      <span>
       code block:
      </span>
      <pre class="source-code">
    QOpenGLContext* openGLContext;
    QOpenGLFunctions* openGLFunctions;
    QOpenGLShaderProgram* shaderProgram;
    QOpenGLVertexArrayObject* vao;
    QOpenGLBuffer* vbo_vertices;
    <strong class="bold1">QOpenGLBuffer* vbo_uvs;</strong>
    <strong class="bold1">QOpenGLTexture* texture;</strong></pre>
     </li>
     <li class="calibre14">
      We must call
      <strong class="source-inline1">
       glEnable(GL_TEXTURE_2D)
      </strong>
      in the
      <strong class="source-inline1">
       initializeGL()
      </strong>
      function to enable the texture
      <span>
       mapping feature:
      </span>
      <pre class="source-code">
void RenderWindow::initializeGL()
{
    openGLFunctions = openGLContext-&gt;functions();
    glEnable(GL_DEPTH_TEST);
    <strong class="bold1">glEnable(GL_TEXTURE_2D);</strong></pre>
     </li>
     <li class="calibre14">
      We need to initialize our
      <strong class="source-inline1">
       texture
      </strong>
      variable under the
      <strong class="source-inline1">
       QOpenGLTexture
      </strong>
      class. We will load a texture called
      <strong class="source-inline1">
       brick.jpg
      </strong>
      from our application folder and flip the image by calling
      <strong class="source-inline1">
       mirrored()
      </strong>
      . OpenGL uses a different coordinate system, which is why we need to flip our texture before passing it to the shader. We will
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker401">
      </a>
      also set the
      <strong class="source-inline1">
       min
      </strong>
      and
      <strong class="source-inline1">
       max
      </strong>
      filters to
      <strong class="source-inline1">
       Nearest
      </strong>
      and
      <strong class="source-inline1">
       Linear
      </strong>
      accordingly,
      <span>
       like so:
      </span>
      <pre class="source-code">
    texture = new QOpenGLTexture(QImage(qApp-&gt;applicationDirPath() + "/brick.jpg").mirrored());
    texture-&gt;setMinificationFilter(QOpenGLTexture::Nearest);
    texture-&gt;setMagnificationFilter(QOpenGLTexture::Linear);</pre>
     </li>
     <li class="calibre14">
      Add another
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker402">
      </a>
      array called
      <strong class="source-inline1">
       uvs
      </strong>
      . This is where we save the texture coordinates for our
      <span>
       <strong class="source-inline1">
        cube
       </strong>
      </span>
      <span>
       object:
      </span>
      <pre class="source-code">
    GLfloat uvs[] = {
     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
     1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f,
     0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
     1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 1.0f,
     0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
     0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
     0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,
     0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f,
     1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f,
     1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f
};</pre>
     </li>
     <li class="calibre14">
      We have to amend our vertex shader so that it takes in the texture coordinates for calculating where the texture will be applied to the object’s surface. Here, we simply pass the texture coordinate to the fragment shader
      <span>
       without modifying:
      </span>
      <pre class="source-code">
    static const char *vertexShaderSource =
    "#version 330 core\n"
    "layout(location = 0) in vec3 posAttr;\n"
    "layout(location = 1) in vec2 uvAttr;\n"
    "uniform mat4 matrix;\n"
    "out vec3 fragPos;\n"
    "out vec2 fragUV;\n"
    "void main() {\n"
    "fragPos = posAttr;\n"
    "fragUV = uvAttr;\n"
    "gl_Position = matrix * vec4(posAttr, 1.0); }";</pre>
     </li>
     <li class="calibre14">
      In the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker403">
      </a>
      fragment shader, we create a
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker404">
      </a>
      texture by calling the
      <strong class="source-inline1">
       texture()
      </strong>
      function, which receives the texture coordinate information from
      <strong class="source-inline1">
       fragUV
      </strong>
      and the image sampler
      <span>
       from
      </span>
      <span>
       <strong class="source-inline1">
        tex
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    static const char *fragmentShaderSource =
    "#version 330 core\n"
    "in vec3 fragPos;\n"
    "in vec2 fragUV;\n"
    "uniform sampler2D tex;\n"
    "out vec4 col;\n"
    "void main() {\n"
    "vec4 texCol = texture(tex, fragUV);\n"
    "col = texCol; }";</pre>
     </li>
     <li class="calibre14">
      We have to initialize the VBO for the texture coordinate
      <span>
       as well:
      </span>
      <pre class="source-code">
    vbo_uvs = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_uvs-&gt;create();
    vbo_uvs-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_uvs-&gt;bind();
    vbo_uvs-&gt;allocate(uvs, sizeof(uvs) * sizeof(GLfloat));</pre>
     </li>
     <li class="calibre14">
      In
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker405">
      </a>
      the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function, we
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker406">
      </a>
      must send the texture coordinate information to the shader and then bind the texture before
      <span>
       calling
      </span>
      <span>
       <strong class="source-inline1">
        glDrawArrays()
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    vbo_uvs-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("uvAttr", 1);
    shaderProgram-&gt;enableAttributeArray(1);
    shaderProgram-&gt;setAttributeBuffer(1, GL_FLOAT, 0, 2);
    texture-&gt;bind();
    glDrawArrays(GL_TRIANGLES, 0, 36);</pre>
     </li>
     <li class="calibre14">
      If you compile and run the program now, you should see a brick cube rotating on
      <span>
       the screen:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer086">
      <img alt="Figure 5.7 – Our 3D cube now looks like it was created from bricks" class="calibre4" src="image/B20976_05_007.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.7 – Our 3D cube now looks like it was created from bricks
    </p>
    <h2 class="calibre7" id="_idParaDest-135">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor135">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     Qt 6 makes
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker407">
     </a>
     loading textures a really easy job. All it takes is just a single line of code to load an image file, flip it, and convert it into an
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker408">
     </a>
     OpenGL-compatible texture. The texture coordinates are pieces of information that let OpenGL know how to stick the texture onto the object’s surface before displaying it
     <span>
      on screen.
     </span>
    </p>
    <p class="calibre3">
     The
     <strong class="source-inline">
      min
     </strong>
     and
     <strong class="source-inline">
      max
     </strong>
     filters are filters that make the texture look better when it is applied on a surface that is bigger than what its resolution can cover. The default setting for this is
     <strong class="source-inline">
      GL_NEAREST
     </strong>
     , which
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker409">
     </a>
     stands for
     <strong class="bold">
      nearest neighbor filtering
     </strong>
     . This filter tends to make textures look pixelated when viewed close up. Another common setting is
     <strong class="source-inline">
      GL_LINEAR
     </strong>
     , which stands for
     <strong class="bold">
      bilinear filtering
     </strong>
     . This filter takes two
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker410">
     </a>
     neighboring fragments and interpolates
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker411">
     </a>
     them to create an approximated color, which looks
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker412">
     </a>
     a lot better
     <span>
      than
     </span>
     <span>
      <strong class="source-inline">
       GL_NEAREST
      </strong>
     </span>
     <span>
      :
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer087">
      <img alt="Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR" class="calibre4" src="image/B20976_05_008.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.8 - Differences between GL_NEAREST and GL_LINEAR
    </p>
    <h1 class="calibre5" id="_idParaDest-136">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor136">
     </a>
     Basic lighting in OpenGL
    </h1>
    <p class="calibre3">
     In this
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker413">
     </a>
     example, we will learn how to add a simple point light to our 3D scene by using OpenGL and
     <span>
      Qt 6.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-137">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor137">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker414">
     </a>
     by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Again, we will use the previous example and add a point light near the spinning cube. Open up
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      and add another variable called
      <strong class="source-inline1">
       vbo_normals
      </strong>
      to
      <span>
       the file:
      </span>
      <pre class="source-code">
    QOpenGLBuffer* vbo_uvs;
    <strong class="bold1">QOpenGLBuffer* vbo_normals;</strong>
    QOpenGLTexture* texture;</pre>
     </li>
     <li class="calibre14">
      Open
      <strong class="source-inline1">
       renderwindow.cpp
      </strong>
      and add another array called
      <strong class="source-inline1">
       normals
      </strong>
      to the
      <span>
       <strong class="source-inline1">
        initializeGL()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
    GLfloat normals[] = {
     0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f,
     0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f,
     0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
     0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
     1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
     0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
     -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
     -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
     0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f,
     0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f, -1.0f
};</pre>
     </li>
     <li class="calibre14">
      Initialize
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker415">
      </a>
      the
      <strong class="source-inline1">
       vbo_normals
      </strong>
      VBO
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker416">
      </a>
      in
      <strong class="source-inline1">
       initializeGL()
      </strong>
      by adding the
      <span>
       following code:
      </span>
      <pre class="source-code">
    vbo_normals = new QOpenGLBuffer(QOpenGLBuffer::VertexBuffer);
    vbo_normals-&gt;create();
    vbo_normals-&gt;setUsagePattern(QOpenGLBuffer::StaticDraw);
    vbo_normals-&gt;bind();
    vbo_normals-&gt;allocate(normals, sizeof(normals) * sizeof(GLfloat));</pre>
     </li>
     <li class="calibre14">
      Since
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker417">
      </a>
      the shader we will be writing this
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker418">
      </a>
      time will be much longer than what we used in the previous examples, let’s move the shader code over to text files and load them into the program by
      <span>
       calling
      </span>
      <span>
       <strong class="source-inline1">
        addShaderFromSourceFile()
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    shaderProgram = new QOpenGLShaderProgram(this);
    shaderProgram-&gt;addShaderFromSourceFile(QOpenGLShader::Vertex,
    qApp-&gt;applicationDirPath() + "/vertex.txt");
    shaderProgram-&gt;addShaderFromSourceFile(QOpenGLShader::Fragment,
    qApp-&gt;applicationDirPath() + "/fragment.txt");
shaderProgram-&gt;link();</pre>
     </li>
     <li class="calibre14">
      Once you are done with that, add the following code to the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function to pass the
      <strong class="source-inline1">
       normals
      </strong>
      VBO over to
      <span>
       the shader:
      </span>
      <pre class="source-code">
    vbo_normals-&gt;bind();
    shaderProgram-&gt;bindAttributeLocation("normalAttr", 2);
    shaderProgram-&gt;enableAttributeArray(2);
    shaderProgram-&gt;setAttributeBuffer(2, GL_FLOAT, 0, 3);</pre>
     </li>
     <li class="calibre14">
      Let’s open up the two text files we just created that contain the shader code. First, we need to make some changes to the vertex shader,
      <span>
       like so:
      </span>
      <pre class="source-code">
    #version 330 core
    layout(location = 0) in vec3 posAttr;
    layout(location = 1) in vec2 uvAttr;
    <strong class="bold1">layout(location = 2) in vec3 normalAttr;</strong>
    uniform mat4 matrix;
    out vec3 fragPos;
    out vec2 fragUV;
    <strong class="bold1">out vec3 fragNormal;</strong>
void main() {
    fragPos = posAttr;
    fragUV = uvAttr;
    <strong class="bold1">fragNormal = normalAttr;</strong>
    gl_Position = matrix * vec4(posAttr, 1.0);
}</pre>
     </li>
     <li class="calibre14">
      We will
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker419">
      </a>
      also make some changes to the fragment
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker420">
      </a>
      shader. We will create a function called
      <strong class="source-inline1">
       calcPointLight()
      </strong>
      in the
      <span>
       shader code:
      </span>
      <pre class="source-code">
    #version 330 core
    in vec3 fragPos;
    in vec2 fragUV;
    <strong class="bold1">in vec3 fragNormal;</strong>
    uniform sampler2D tex;
    out vec4 col;
    <strong class="bold1">vec4 calcPointLight() {</strong>
    <strong class="bold1">vec4 texCol = texture(tex, fragUV);</strong>
    <strong class="bold1">vec3 lightPos = vec3(1.0, 2.0, 1.5);</strong>
    <strong class="bold1">vec3 lightDir = normalize(lightPos - fragPos);</strong>
    <strong class="bold1">vec4 lightColor = vec4(1.0, 1.0, 1.0, 1.0);</strong>
    <strong class="bold1">float lightIntensity = 1.0;</strong></pre>
     </li>
     <li class="calibre14">
      Continuing
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker421">
      </a>
      from the preceding
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker422">
      </a>
      code, we calculated the lighting using
      <strong class="source-inline1">
       calcPointLight()
      </strong>
      and output the resulting fragment to the
      <strong class="source-inline1">
       col
      </strong>
      variable,
      <span>
       as follows:
      </span>
      <pre class="source-code">
    // Diffuse
    float diffuseStrength = 1.0;
    float diff = clamp(dot(fragNormal, lightDir), 0.0, 1.0);
    vec4 diffuse = diffuseStrength * diff * texCol * lightColor * lightIntensity;
    return diffuse;
}
void main() {
    vec4 finalColor = calcPointLight();
    col = finalColor;
}</pre>
     </li>
     <li class="calibre14">
      If you compile and run the program now, you should see the lighting
      <span>
       in action:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer088">
      <img alt="Figure 5.9 – Our 3D cube now has shading" class="calibre4" src="image/B20976_05_009.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.9 – Our 3D cube now has shading
    </p>
    <h2 class="calibre7" id="_idParaDest-138">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor138">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     In OpenGL 3
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker423">
     </a>
     and later versions, fixed-function lighting
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker424">
     </a>
     no longer exists. You can no longer call
     <strong class="source-inline">
      glEnable(GL_LIGHT1)
     </strong>
     to add light to your 3D scene. The new method for adding light is to calculate your own lighting in the shader. This gives you the flexibility of creating all types of lights, depending on your needs. The old method has a limitation of up to 16 lights in most hardware but, with the new programmable pipeline, you can have any number of lights in the scene; however, the lighting model will need to be coded entirely by you in the shaders, which is not an
     <span>
      easy task.
     </span>
    </p>
    <p class="calibre3">
     Other than that, we also need to add a surface normal value to every surface of the cube. Surface normal indicates where the surface is facing and is used for lighting calculations. The preceding example is very simplified to let you understand how lighting works in OpenGL. In actual use cases, you may need to pass some variables such as light intensity, light color, and light position from C++ or load it from a material file instead of hardcoding it in the
     <span>
      shader code.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-139">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor139">
     </a>
     Moving an object using keyboard controls
    </h1>
    <p class="calibre3">
     In this section, we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker425">
     </a>
     will be looking at how to move an object in OpenGL using keyboard controls. Qt provides an easy way to detect keyboard events using virtual functions, namely
     <strong class="source-inline">
      keyPressEvent()
     </strong>
     and
     <strong class="source-inline">
      keyReleaseEvent()
     </strong>
     . We will be using the previous example and adding
     <span>
      to it.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-140">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor140">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     To move an
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker426">
     </a>
     object using keyboard controls, follow
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       renderwindow.h
      </strong>
      and declare two floating-point numbers called
      <strong class="source-inline1">
       moveX
      </strong>
      and
      <strong class="source-inline1">
       moveZ
      </strong>
      . Then, declare a
      <strong class="source-inline1">
       QVector3D
      </strong>
      variable
      <span>
       called
      </span>
      <span>
       <strong class="source-inline1">
        movement
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    QElapsedTimer* time;
    int currentTime = 0;
    int oldTime = 0;
    float deltaTime = 0;
    float rotation = 0;
    <strong class="bold1">float moveX = 0;</strong>
    <strong class="bold1">float moveZ = 0;</strong>
    <strong class="bold1">QVector3D movement = QVector3D(0, 0, 0);</strong></pre>
     </li>
     <li class="calibre14">
      We will also declare two functions called
      <strong class="source-inline1">
       keyPressEvent()
      </strong>
      <span>
       and
      </span>
      <span>
       <strong class="source-inline1">
        keyReleaseEvent()
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
protected:
    void initializeGL();
    void paintEvent(QPaintEvent *event);
    void resizeEvent(QResizeEvent *event);
    void keyPressEvent(QKeyEvent *event);
    void keyReleaseEvent(QKeyEvent *event);</pre>
     </li>
     <li class="calibre14">
      We will
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker427">
      </a>
      implement the
      <strong class="source-inline1">
       keyPressEvent()
      </strong>
      function
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        renderwindow.cpp
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
void RenderWindow::keyPressEvent(QKeyEvent *event) {
    if (event-&gt;key() == Qt::Key_W) { moveZ = -10; }
    if (event-&gt;key() == Qt::Key_S) { moveZ = 10; }
    if (event-&gt;key() == Qt::Key_A) { moveX = -10; }
    if (event-&gt;key() == Qt::Key_D) { moveX = 10; }
}</pre>
     </li>
     <li class="calibre14">
      We will also
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker428">
      </a>
      implement the
      <span>
       <strong class="source-inline1">
        keyReleaseEvent()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void RenderWindow::keyReleaseEvent(QKeyEvent *event) {
    if (event-&gt;key() == Qt::Key_W) { moveZ = 0; }
    if (event-&gt;key() == Qt::Key_S) { moveZ = 0; }
    if (event-&gt;key() == Qt::Key_A) { moveX = 0; }
    if (event-&gt;key() == Qt::Key_D) { moveX = 0; }
}</pre>
     </li>
     <li class="calibre14">
      After that, we will comment out the rotation code in
      <strong class="source-inline1">
       paintEvent()
      </strong>
      and add the movement code, as highlighted in the following snippet. We do not want to get distracted by the rotation and just want to focus on
      <span>
       the movement:
      </span>
      <pre class="source-code">
    //rotation += deltaTime * 50;
    movement.setX(movement.x() + moveX * deltaTime);
    movement.setZ(movement.z() + moveZ * deltaTime);
    QMatrix4x4 matrixMVP;
    QMatrix4x4 model, view, projection;
    model.translate(movement.x(), 1, movement.z());</pre>
     </li>
     <li class="calibre14">
      If you
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker429">
      </a>
      compile and run the program now, you should be able to move the cube around by pressing
      <em class="italic">
       W
      </em>
      ,
      <em class="italic">
       A
      </em>
      ,
      <em class="italic">
       S
      </em>
      ,
      <span>
       and
      </span>
      <span>
       <em class="italic">
        D
       </em>
      </span>
      <span>
       .
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-141">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor141">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     What we did here was
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker430">
     </a>
     constantly add the
     <strong class="source-inline">
      moveX
     </strong>
     and
     <strong class="source-inline">
      moveZ
     </strong>
     values’
     <strong class="source-inline">
      movement
     </strong>
     vector’s
     <strong class="source-inline">
      x
     </strong>
     and
     <strong class="source-inline">
      z
     </strong>
     values. When a key is pressed,
     <strong class="source-inline">
      moveX
     </strong>
     and
     <strong class="source-inline">
      moveZ
     </strong>
     will become a positive or negative number, depending on which button is pressed; otherwise, it will be zero. In the
     <strong class="source-inline">
      keyPressEvent()
     </strong>
     function, we checked whether the keyboard button that was pressed was
     <em class="italic">
      W
     </em>
     ,
     <em class="italic">
      A
     </em>
     ,
     <em class="italic">
      S
     </em>
     , or
     <em class="italic">
      D
     </em>
     ; we then set the variables accordingly. To get the full list of key names that are used by Qt,
     <span>
      visit
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="http://doc.qt.io/qt-6/qt.html#Key-enum">
      <span>
       http://doc.qt.io/qt-6/qt.html#Key-enum
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     One way we can create movement input is by holding down the same key and not releasing it. Qt 6 will repeat the key press event after an interval, but it is not very fluid as modern operating systems limit the key press event to prevent double typing. The keyboard input interval varies between different operating systems. You can set the interval by calling
     <strong class="source-inline">
      QApplication::setKeyboardInterval()
     </strong>
     , but this may not work on every operating system. Therefore, we did not go for
     <span>
      this method.
     </span>
    </p>
    <p class="calibre3">
     Instead, we only set
     <strong class="source-inline">
      moveX
     </strong>
     and
     <strong class="source-inline">
      moveZ
     </strong>
     once when the key was pressed or released, and then we constantly apply the value to the movement vector in our game loop so that it is moving continuously without being affected by the
     <span>
      input interval.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-142">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor142">
     </a>
     Qt Quick 3D in QML
    </h1>
    <p class="calibre3">
     In this recipe, we will learn how to render 3D images using
     <span>
      Qt 6.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-143">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor143">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s learn
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker431">
     </a>
     how to use a 3D canvas in QML by following
     <span>
      this example:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s start
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker432">
      </a>
      this example by creating a new project in Qt Creator. This time around, we will go for
      <strong class="bold">
       Qt Quick Application
      </strong>
      and not the other options that we chose in the
      <span>
       previous examples:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer089">
      <img alt="Figure 5.10 – Creating a new Qt Quick Application project" class="calibre4" src="image/B20976_05_010.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.10 – Creating a new Qt Quick Application project
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Once the project is created, you are required to create a resource file by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File
      </strong>
      and selecting
      <strong class="bold">
       Qt
      </strong>
      |
      <strong class="bold">
       Qt Resource File
      </strong>
      under
      <strong class="bold">
       Files and Classes
      </strong>
      and name
      <span>
       it
      </span>
      <span>
       <strong class="source-inline1">
        resource.qrc
       </strong>
      </span>
      <span>
       :
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer090">
      <img alt="Figure 5.11 – Creating a Qt resource file" class="calibre4" src="image/B20976_05_011.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.11 – Creating a Qt resource file
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Add an
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker433">
      </a>
      image file to our project resources—we will be using
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker434">
      </a>
      it in this example. Open up
      <strong class="source-inline1">
       resource.qrc
      </strong>
      with Qt Creator by right-clicking on it in the
      <strong class="bold">
       Projects pane
      </strong>
      and selecting
      <strong class="bold">
       Open in Editor
      </strong>
      . Once the resources file is opened by Qt Creator, click the
      <strong class="bold">
       Add
      </strong>
      button, followed by the
      <strong class="bold">
       Add File
      </strong>
      button, and then select the image file you want from your computer. In my case, I’ve added a
      <strong class="source-inline1">
       brick.jpg
      </strong>
      image, which will be used as the surface texture for our
      <span>
       3D object:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer091">
      <img alt="Figure 5.12 – Adding brick texture into the resource file" class="calibre4" src="image/B20976_05_012.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.12 – Adding brick texture into the resource file
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="4">
      After that, open up
      <strong class="source-inline1">
       main.qml
      </strong>
      using Qt Creator. You will see that there are already a few lines of code written in the file. What it does is basically open up an empty window and nothing else. Let’s start adding our own code to the
      <span>
       <strong class="source-inline1">
        Window
       </strong>
      </span>
      <span>
       object.
      </span>
     </li>
     <li class="calibre14">
      First, import the
      <strong class="source-inline1">
       QtQuick3D
      </strong>
      module to our project and create a
      <strong class="source-inline1">
       View3D
      </strong>
      object under
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker435">
      </a>
      the
      <strong class="source-inline1">
       Window
      </strong>
      object, which we will be using to render a 3D scene
      <span>
       on it:
      </span>
      <pre class="source-code">
import QtQuick
<strong class="bold1">import QtQuick3D</strong>
Window {
    width: 640
    height: 480
    visible: true
    title: qsTr("Hello World")
    <strong class="bold1">View3D {</strong>
        <strong class="bold1">id: view</strong>
        <strong class="bold1">anchors.fill: parent</strong>
    <strong class="bold1">}</strong>
}</pre>
     </li>
     <li class="calibre14">
      After
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker436">
      </a>
      that, set the
      <strong class="source-inline1">
       environment
      </strong>
      variable of the
      <strong class="source-inline1">
       View3D
      </strong>
      object as a new
      <strong class="source-inline1">
       SceneEnvironment
      </strong>
      object. We use this to set the background color of our 3D view to
      <span>
       sky blue:
      </span>
      <pre class="source-code">
environment: SceneEnvironment {
    clearColor: "skyblue"
    backgroundMode: SceneEnvironment.Color
}</pre>
     </li>
     <li class="calibre14">
      After that, we re-create the 3D cube from our previous OpenGL example by declaring a
      <strong class="source-inline1">
       Model
      </strong>
      object inside our 3D view and setting its source as
      <strong class="source-inline1">
       Cube
      </strong>
      . We then rotate it by
      <strong class="source-inline1">
       -30
      </strong>
      units along the y-axis and apply a material to it. After that, we set the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker437">
      </a>
      texture of the material as
      <strong class="source-inline1">
       brick.jpg
      </strong>
      . The keyword
      <strong class="source-inline1">
       qrc:
      </strong>
      here means we are taking the texture from the resource file we
      <span>
       created earlier:
      </span>
      <pre class="source-code">
Model {
    position: Qt.vector3d(0, 0, 0)
    source: "#Cube"
    eulerRotation.y: -30
    materials: PrincipledMaterial {
        baseColorMap: Texture {
            source: "qrc:/brick.jpg"
        }
    }
}</pre>
     </li>
     <li class="calibre14">
      Before we’re able
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker438">
      </a>
      to see our 3D cube clearly, we must create a light source as well as a camera, which helps to render
      <span>
       our scene:
      </span>
      <pre class="source-code">
PerspectiveCamera {
    position: Qt.vector3d(0, 200, 300)
    eulerRotation.x: -30
}
DirectionalLight {
    eulerRotation.x: -10
    eulerRotation.y: -20
}</pre>
     </li>
     <li class="calibre14">
      Once you
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker439">
      </a>
      are done, build and run the project. You should be able to see a 3D cube with a brick texture on
      <span>
       the screen:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer092">
      <img alt="Figure 5.13 – Re-creating the 3D demo in QtQuick3D" class="calibre4" src="image/B20976_05_013.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 5.13 – Re-creating the 3D demo in QtQuick3D
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="10">
      To re-create
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker440">
      </a>
      the spinning animation, let’s add
      <strong class="source-inline1">
       NumberAnimation
      </strong>
      to our
      <span>
       cube model:
      </span>
      <pre class="source-code">
Model {
    position: Qt.vector3d(0, 0, 0)
    source: "#Cube"
    eulerRotation.y: -30
    materials: PrincipledMaterial {
        baseColorMap: Texture {
            source: "qrc:/brick.jpg"
        }
    }
    NumberAnimation on eulerRotation.y {
        duration: 3000
        to: 360
        from: 0
        easing.type:Easing.Linear
        loops: Animation.Infinite
    }
}</pre>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-144">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor144">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     Originally, Qt 5
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker441">
     </a>
     used something called
     <strong class="bold">
      Qt Canvas 3D
     </strong>
     to render 3D
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker442">
     </a>
     scenes in QML, which was based on the
     <strong class="source-inline">
      three.js
     </strong>
     library/API that used WebGL technology to display animated 3D computer graphics in a Qt Quick window. However, this feature has been completely deprecated in Qt 6 and has been since replaced by another
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker443">
     </a>
     module called
     <strong class="bold">
      Qt
     </strong>
     <span>
      <strong class="bold">
       Quick 3D
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     Qt Quick 3D works a lot better than Qt Canvas 3D as it uses native methods for rendering 3D scenes without depending on a third-party library such as
     <strong class="source-inline">
      three.js
     </strong>
     . It also produces better performance and integrates well with any existing Qt
     <span>
      Quick components.
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
