<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   4: Design
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_012.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_014.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="123" epub:type="pagebreak" id="pagebreak_123" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0004" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000088">
      4: Design
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         This chapter begins with a cautionary tale of how software systems can accrue technical debt and eventually decay without good initial designs that are maintained as the software evolves. Then functional requirement gathering is discussed and advice is offered on how best to collect and maintain these requirements. The complementary methods of use case modeling and user story creation are also described in detail. Then a description is offered of how to approach the design of an application programming interface, breaking this up into high-level architecture design and detailed object or class design. Various design principles are discussed, including the SOLID principles, the Liskov substitution principle, the open/closed principle, and the Law of Demeter. To conclude, the topic of function design is covered, including function naming and parameters, as well as the topic of error handling through return codes and exceptions.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Abstraction; Agile development; Architecture; Composition; Exceptions; Functional requirement; Inheritance; Naming; Object modeling; Use case
      </div>
     </section>
     <section>
      <p class="textfl" id="p0010">
       In the preceding chapters, I laid the groundwork and developed the background to let you start designing your own application programming interfaces (APIs). I presented the various qualities that contribute to good API design and discussed standard patterns that apply to the design of maintainable APIs.
      </p>
      <p class="text" id="p0015">
       In this chapter, I put all of this information together and cover the specifics of high-quality API design, from overall architecture planning down to class design and individual function calls. However, good design is worth little if the API doesn't give your users the features they need. I will therefore also talk about defining functional requirements to specify what an API should do. I'll also cover the creation of use cases and user stories as a way to describe the behavior of the API from the user's point of view. These different analysis techniques can be used individually or together, but they should always precede any attempt to design the API: you can't design what you don't understand.
      </p>
      <p class="text" id="p0020">
       <a href="#f0010" id="Bf0010">
        Fig. 4.1
       </a>
       shows the basic workflow for designing an API. This starts with an analysis of the problem, from which you can develop an initial design and then implement a solution for that design. This is a continual and iterative process: new requirements should trigger a reassessment of the design, as should changes from other sources such as major bug fixes. This chapter will focus on the first two stages of this process: analysis and design. The following chapters will deal with the remaining implementation issues such as C++ usage, documentation, and testing.
      </p>
      <p class="text" id="p0025">
       Before I jump into these design topics, however, I will spend some time looking at why good design is so important. This opening section is drawn from experience working on large code bases that have persisted for many years and have had dozens or hundreds of engineers working on them. The lessons learned from witnessing code bases evolve, or devolve, over many years offer compelling motivation to design them well from the start, and—just as important—to maintain high standards from then on. The consequences of not doing so can be very costly. To mix metaphors: good API design is a journey, not a first step.
      </p>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        A case for good design
       </h2>
       <p class="textfl" id="p0030">
        This chapter focuses on the techniques that result in elegant API design. However, it's likely that you've worked on projects with code that doesn't live up to these grand ideals. You've probably worked with legacy systems that have weak cohesion, expose internal details, have no tests, are poorly documented, and exhibit nonorthogonal behavior. Despite this, some of these systems were probably well-designed when they were
        <a id="p124">
        </a>
        <span aria-label="124" epub:type="pagebreak" id="pagebreak_124" role="doc-pagebreak">
        </span>
        originally conceived. However, over time the software decayed, becoming difficult to extend and requiring constant maintenance.
       </p>
       <div class="pageavoid">
        <figure class="fig" id="f0010">
         <img alt="image" height="909" src="../../IMAGES/B9780443222191000088/main.assets/f04-01-9780443222191.jpg" width="2751"/>
         <figcaption class="figleg">
          <a id="cap0010">
          </a>
          <a id="fspara0010">
          </a>
          <span class="fignum">
           <a href="#Bf0010">
            Figure 4.1
           </a>
          </span>
          The stages of application programming interface development, from analysis to design and implementation.
         </figcaption>
        </figure>
       </div>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         Accruing technical debt
        </h3>
        <p class="textfl" id="p0035">
         All large successful companies grew from meager beginnings. A classic example of this is Hewlett Packard, which began with two electrical engineers in a Palo Alto garage in 1939 and eventually grew to become the first technology company in the world to post revenues exceeding $100 billion. The qualities that make a successful startup company are very different from those needed to maintain a multibillion (or trillion) dollar publicly traded corporation. Companies often go through several large organizational changes as they grow, and the same is true of their software practices.
        </p>
        <p class="text" id="p0040">
         A small software startup needs to get its product out as soon as possible to avoid being beaten to market by a competitor or running out of capital. The pressure on a software engineer in this environment is to produce a lot of software, and quickly. Under these conditions, the extra effort required to design and implement long-term APIs can be seen as an unaffordable luxury. This is a fair decision when the options are between getting to market quickly or your company perishing. I once spoke with a software architect for a small startup who forbade the writing of any comments, documentation, or tests because he felt that it would slow the development too much.
        </p>
        <p class="text" id="p0045">
         However, if a piece of software becomes successful, the pressure turns toward providing a stable, easy to use, and well-documented product. New requirements start appearing that necessitate the software to be extended in ways it was never meant to support. And all of this must be built upon the core of a product that was not designed to last for the long term. The result, in the words of Ward Cunningham, is the accrual of technical debt (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib24" id="bib_24">
          Cunningham, 1992
         </a>
         ):
        </p>
        <div>
         <div id="disp0010">
          <p class="quote" epub:type="epigraph" id="p1920" role="doc-epigraph">
           Shipping first time code is like going into debt. A little debt speeds development so long as it is paid back promptly with a rewrite. […] The danger occurs when the debt
           <a id="p125">
           </a>
           <span aria-label="125" epub:type="pagebreak" id="pagebreak_125" role="doc-pagebreak">
           </span>
           is not repaid. Every minute spent on not-quite-right code counts as interest on that debt. Entire engineering organizations can be brought to a stand-still under the debt load of an unconsolidated implementation.
          </p>
         </div>
        </div>
        <p class="text" id="p0050">
         Steve McConnell expanded on this definition to note that there are two types of debt: unintentional and intentional. The former is when software designed with the best of intentions turns out to be error-prone, when a junior engineer writes low-quality code, or when your company buys another company whose software turns out to be a mess. The latter is when a conscious strategic decision is made to cut corners owing to time, cost, or resource constraints, with the intention that the right solution will be put in place after the deadline.
        </p>
        <p class="text" id="p0055">
         The problem, of course, is that there is always another important deadline, so it's perceived that there's never enough time to go back and perform the right fix. As a result, the technical debt gradually accrues: short-term glue code between systems lives on and becomes more deeply embedded, temporary hacks remain in the code and turn into features upon which clients depend, code that was meant only for last-minute demos is shipped as production code, coding conventions and documentation are ignored, and ultimately the original clean design degrades and becomes obfuscated. Robert C. Martin defined four warning signs that a code base is reaching this point (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib59" id="bib_59">
          Martin, 2000
         </a>
         ). Here is a slightly modified version of those indicators:
        </p>
        <div>
         <ol id="ulist0010">
          <li class="bulllist" id="p0060">
           <a id="u0010">
           </a>
           ▪
           <b>
            Fragility.
           </b>
           Software becomes fragile when it has unexpected side effects, or when implementation details are exposed to the point that apparently unconnected parts of the system depend upon the internals of other parts of the system. The result is that changes to one part of the system can cause unexpected failures in seemingly unrelated parts of the code. Engineers are therefore afraid to touch the code and it becomes a burden to maintain.
          </li>
          <li class="bulllist" id="p0065">
           <a id="u0015">
           </a>
           ▪
           <b>
            Rigidity.
           </b>
           A rigid piece of software is one that is resistant to change. In effect, the design becomes brittle to the point that even simple changes cannot be implemented without great effort, normally requiring extensive, time-consuming, and risky refactoring. The result is a viscous code base for which efforts to make new changes are slowed significantly.
          </li>
          <li class="bulllist" id="p0070">
           <a id="u0020">
           </a>
           ▪
           <b>
            Immobility.
           </b>
           A good engineer will spot cases in which code can be reused to improve the maintainability and stability of the software. Immobile code is software that is immune to these efforts, making it difficult to be reused elsewhere. For example, the implementation may be too entangled with its surrounding code or it may be hardcoded with domain-specific knowledge.
          </li>
          <li class="bulllist" id="p0075">
           <a id="u0025">
           </a>
           ▪
           <b>
            Nontransferability.
           </b>
           If only a single engineer in your organization can work on certain parts of the code, then it can be described as nontransferable. Often the owner will be the developer who originally wrote the code, or the last unfortunate person who attempted to clean it up. For many large code bases, it's not possible for every engineer to understand every part of the code deeply, so having areas
           <a id="p126">
           </a>
           <span aria-label="126" epub:type="pagebreak" id="pagebreak_126" role="doc-pagebreak">
           </span>
           that engineers cannot easily dive into and work with effectively is a bad situation for your project.
          </li>
         </ol>
        </div>
        <p class="text" id="p0080">
         The result of these problems is that dependencies between components grow, causing conceptually unrelated parts of the code to rely upon each other's internal implementation details. Over time, this culminates in most program state and logic becoming global or duplicated (
         <a href="#f0015" id="Bf0015">
          Fig. 4.2
         </a>
         ). This is often called spaghetti code or the big ball of mud (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib30" id="bib_30">
          Foote and Yoder, 1997
         </a>
         ).
        </p>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Paying back the debt
        </h3>
        <p class="textfl" id="p0085">
         Ultimately, a company will reach the point where it has accrued so much technical debt that it spends more time maintaining and containing the legacy code base than adding new features for its customers. This often results in a next-generation project, to fix the problems with the old system. For example, when I met the software architect mentioned a few paragraphs back, the company had since grown and become successful, and his team was busily rewriting all of the code that he'd originally designed.
         <a id="p127">
         </a>
        </p>
        <section>
         <a id="sf0015">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="1702" src="../../IMAGES/B9780443222191000088/main.assets/f04-02-9780443222191.jpg" width="2344"/>
           <figcaption class="figleg">
            <a id="cap0015">
            </a>
            <a id="fspara0015">
            </a>
            <span class="fignum">
             <a href="#Bf0015">
              Figure 4.2
             </a>
            </span>
            A decayed tightly coupled system that has devolved into a big ball of mud.
           </figcaption>
          </figure>
         </div>
        </section>
        <div>
         <span aria-label="127" epub:type="pagebreak" id="pagebreak_127" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0090">
         In terms of strategy, there are two extremes for such a next-generation project to consider:
        </p>
        <div>
         <ul class="ce_list" id="olist0010">
          <li class="numlist" id="p0095">
           <a id="o0010">
           </a>
           1.
           <b>
            Evolution
           </b>
           : Design a system that incorporates all new requirements and then iteratively refactor the existing system until it reaches that point.
          </li>
          <li class="numlist" id="p0100">
           <a id="o0015">
           </a>
           2.
           <b>
            Revolution
           </b>
           : Throw away the old code and then design and implement a completely new system from scratch.
          </li>
         </ul>
        </div>
        <p class="text" id="p0105">
         Both options have their pros and cons, and both are difficult. I've heard the problem described as having to change the engine in a car, but the car is traveling at 100 mph and you can't stop the car.
        </p>
        <p class="text" id="p0110">
         In the evolution case, you always have a functional system that can be released. However, you still have to work within the framework of the legacy design, which may no longer be the best way to express the problem. New requirements may have fundamentally changed the optimal workflow for key use cases. A good way to go about the evolution approach is to hide the old ugly code behind new well-designed APIs (e.g., by using the wrapper patterns I presented in
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         , such as Façade), incrementally update all clients to go through these cleaner APIs, and put the code under automated testing (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib31" id="bib_31">
          Fowler et al., 1999
         </a>
         ;
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib29" id="bib_29">
          Feathers, 2004
         </a>
         ).
        </p>
        <p class="text" id="p0115">
         In the revolution case, you're freed from the shackles of old technology and can design a new tool with all of the knowledge you've learned from the old one (although as a pragmatic step, you may still harvest a few key classes from the old system to preserve critical behavior). You can also put new processes in place, such as requiring extensive unit test coverage for all new code, and use the opportunity to switch tools, such as adopting a new bug tracking system or source control management system. However, this option requires a lot more time and effort (i.e., money) to get to the point of a usable system, and in the meantime you either stop all development on the old tool or continue delivering new features in the old system, which keeps raising the bar for the new system to be successful. You must also be mindful of the second-system syndrome, in which the new system fails because it's overengineered and overly ambitious in its goal (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib15" id="bib_15">
          Brooks, 1995
         </a>
         ).
        </p>
        <p class="text" id="p0120">
         In both cases, the need for a next-generation project introduces team dynamic issues and planning complexities. For example, do you keep a single team focused on both the new and old systems? This is desirable from a personnel point of view. However, short-term tactical needs tend to trump long-term strategic development, so it may be hard to sustain the next-generation project in the face of critical bug fixes and maintenance for the old one. Alternatively, if you split the development team in two, this can create a morale problem in which the developers working on the old system feel that they've been classed as second-rate developers and left behind to support a code base with no future.
        </p>
        <p class="text" id="p0125">
         Furthermore, the need for a technical restart can often instigate a business and company reorganization as well. This causes team structures and relationships to be reassessed and reshaped. It can also materially affect people's livelihoods, particularly
         <a id="p128">
         </a>
         <span aria-label="128" epub:type="pagebreak" id="pagebreak_128" role="doc-pagebreak">
         </span>
         when companies decide to downsize as part of refocusing the business. And all of this happens because of poor API design? Well, perhaps that's being a little dramatic. Reorganizations are a natural process in the growth of a company and can happen for many reasons: a structure that works for a startup with 10 people doesn't work for a successful business of 10,000. But the failure of software to react to the needs of the business is certainly one way that reorganizations can be triggered. For instance, in Jun. 2010, I was working at Linden Lab when it laid off 30% of its workforce and underwent a company-wide reorganization, primarily because the software couldn't be evolved fast enough to meet the company's revenue targets.
        </p>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Design for the long term
        </h3>
        <p class="textfl" id="p0130">
         Investing in a large next-generation effort to replace a decayed code base can cost a company millions of dollars. For example, just to pay the salary for a team of 20 developers, testers, writers, and managers for 1 year at an average salary of $100,000 would cost $2,000,000. However, the adoption of good design principles can help to avoid this drastic course of action. Let's start by enumerating some of the reasons why this scenario can arise:
        </p>
        <div>
         <ul class="ce_list" id="olist0015">
          <li class="numlist" id="p0135">
           <a id="o0020">
           </a>
           1. A company simply doesn't create a good software design in the first place because of a belief that it will cost valuable time and money early on.
          </li>
          <li class="numlist" id="p0140">
           <a id="o0025">
           </a>
           2. The engineers on the project are ignorant of good design techniques or believe that they don't apply to their project.
          </li>
          <li class="numlist" id="p0145">
           <a id="o0030">
           </a>
           3. The code was never intended to last very long. For example, it was hastily written for a demo or it was meant to be throw-away prototype code.
          </li>
          <li class="numlist" id="p0150">
           <a id="o0035">
           </a>
           4. The development process for the software project doesn't make technical debt visible, so knowledge of all of the parts of the system that need to be fixed gets lost or forgotten over time. (Agile processes such as Scrum attempt to keep debt visible by using a product backlog).
          </li>
          <li class="numlist" id="p0155">
           <a id="o0040">
           </a>
           5. The system was well-designed at first, but its design gradually degraded over time owing to unregulated growth: for example, letting poor changes be added to the code even if they compromised the design of the system. In the words of Fred Brooks, the system loses its conceptual integrity (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib15">
            Brooks, 1995
           </a>
           ).
          </li>
          <li class="numlist" id="p0160">
           <a id="o0045">
           </a>
           6. Changing requirements often necessitate the design to evolve, too, but the company continually postpones this refactoring work, either intentionally or unintentionally, in preference to short-term fixes, hacks, and glue code.
          </li>
          <li class="numlist" id="p0165">
           <a id="o0050">
           </a>
           7. Bugs are allowed to exist for long periods of time. This is often caused by a drive to add new functionality continually without a focus on the overall quality of the product.
          </li>
          <li class="numlist" id="p0170">
           <a id="o0055">
           </a>
           8. The code has no tests, so regressions creep into the system as engineers modify functionality, and parts of the code base ultimately turn into scary wastelands where engineers fear to make changes.
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p129">
         </a>
        </p>
        <div>
         <span aria-label="129" epub:type="pagebreak" id="pagebreak_129" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0175">
         Let's tackle a few of these problems. First is the perception that good design slows you down too much. Truthfully, it may be the cheapest overall decision to write haphazardly structured software that gets you to market quicker and then to rewrite the code completely once you have a hold on the market. Also, certain aspects of writing good software can indeed appear to be more time-consuming, such as writing the extra code to pimpl your classes or writing automated tests to verify the behavior of your APIs. However, good design doesn't take as long as you might think, and it always pays off in the long run. Keeping a strong separation between interface and implementation pays dividends in the maintainability of your code, even in the short term, and writing automated tests gives you the confidence to change functionality rapidly without breaking existing behavior. It's noteworthy that Michael Feathers defines legacy code as code without tests, making the point that legacy doesn't have to mean old; you could be writing legacy code today (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib29">
          Feathers, 2004
         </a>
         ).
        </p>
        <p class="text" id="p0180">
         The beauty of APIs is that the underlying implementation can be as quick and dirty or as complete and elegant as you need. Good API design is about putting in place a stable logical interface to solve a problem. However, the code behind that API can be simple and inefficient at first. Then you can add more implementation complexity later without breaking that logical design. Related to this, APIs let you isolate problems to specific components. By managing the dependencies between components, you can limit the extent of problems. Conversely, in spaghetti code, in which each component depends upon the internals of other components, behavior becomes nonorthogonal, and bugs in one component can affect other components in nonobvious ways. The important message is therefore to take the time to put a good high-level design in place first, to focus on the dependencies and relationships between components. That is the primary focus of this chapter.
        </p>
        <p class="text" id="p0185">
         Another aspect of the problem is that if you don't continue to keep a high bar for your code quality, then as the code evolves the original design gradually decays. Cutting corners to meet a deadline is okay if you go back and do it right afterward. Remember to keep paying back your technical debt. Code tends to live for a lot longer than you think it will. It's good to remember this fact when you weaken an API, because you may have to support the consequences for a long time to come. It's therefore important to realize the impact of new requirements on the design of the API and to refactor your code to maintain a consistent and up-to-date design. It's equally important to enforce change control on your API so that it doesn't evolve in an unsupervised or chaotic fashion. I'll discuss ways to achieve these goals in
         <a href="../B9780443222191000027/CH0010_383-414_B9780443222191000027.xhtml">
          Chapter 10
         </a>
         , when I talk about API versioning.
        </p>
       </section>
      </section>
      <section>
       <a id="s0030">
       </a>
       <h2 class="h1hd" id="cesectitle0040">
        Gathering functional requirements
       </h2>
       <p class="textfl" id="p0190">
        The first step in producing a good design for a piece of software is to understand what it needs to do. It's amazing how much development time is wasted by engineers building the wrong thing. It's also quite eye-opening to see how often two engineers can hear the
        <a id="p130">
        </a>
        <span aria-label="130" epub:type="pagebreak" id="pagebreak_130" role="doc-pagebreak">
        </span>
        same informal description of a piece of work and come away with two completely different ideas about what it involves. This is not necessarily a bad thing: it's good to have minds that work differently to provide alternative perspectives and solutions. The problem is that the work was not specified in enough detail such that everyone involved could form a shared understanding and work toward the same goal. This is where requirements come in. There are several different types of requirements in the software industry, including:
       </p>
       <div>
        <ol id="ulist0015">
         <li class="bulllist" id="p0195">
          <a id="u0030">
          </a>
          ▪
          <b>
           Business requirements
          </b>
          : describe the value of the software in business terms (i.e., how it advances the needs of the organization)
         </li>
         <li class="bulllist" id="p0200">
          <a id="u0035">
          </a>
          ▪
          <b>
           Functional requirements
          </b>
          : describe the behavior of the software (i.e., what the software is supposed to accomplish)
         </li>
         <li class="bulllist" id="p0205">
          <a id="u0040">
          </a>
          ▪
          <b>
           Nonfunctional requirements
          </b>
          : describe the quality standards that the software must achieve (i.e., how well the software works for users)
         </li>
        </ol>
       </div>
       <p class="text" id="p0210">
        I will concentrate primarily on functional and nonfunctional requirements in the following sections. However, it's still extremely important to ensure that the functionality of your software aligns with the strategic goals of your business. Otherwise, you run the risk of damaging the long-term success of your API.
       </p>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         What are functional requirements?
        </h3>
        <p class="textfl" id="p0215">
         Functional requirements are simply a way to understand what to build so that you don't waste time and money building the wrong thing. In our diagram of the phases of software development (
         <a href="#f0010">
          Fig. 4.1
         </a>
         ), functional requirements sit squarely in the analysis phase.
        </p>
        <p class="text" id="p0220">
         In terms of API development, functional requirements define the intended functionality for the API. These should be developed in collaboration with the clients of the API so that they represent the voice and needs of the user (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib101" id="bib_101">
          Wiegers, 2003
         </a>
         ). Explicitly capturing requirements also lets you agree upon the scope of functionality with the intended users. Of course, the users of an API are also developers, but that doesn't mean that you should assume you know what they want just because you're a developer, too. At times, it may be necessary to second-guess or research requirements yourself. Nevertheless, you should still identify target users of your API—experts in the domain of your API—and drive the functional requirements from their input. For example, you can hold interviews, meetings, or use questionnaires to ask users:
        </p>
        <div>
         <ol id="ulist0020">
          <li class="bulllist" id="p0225">
           <a id="u0045">
           </a>
           ▪ What tasks would they expect to achieve with the API?
          </li>
          <li class="bulllist" id="p0230">
           <a id="u0050">
           </a>
           ▪ What would an optimal workflow be from their perspective?
          </li>
          <li class="bulllist" id="p0235">
           <a id="u0055">
           </a>
           ▪ What are all the potential inputs, including their types and valid ranges?
          </li>
          <li class="bulllist" id="p0240">
           <a id="u0060">
           </a>
           ▪ What are all the expected outputs, including type, format, and ranges?
          </li>
          <li class="bulllist" id="p0245">
           <a id="u0065">
           </a>
           ▪ What file formats or protocols must be supported?
          </li>
          <li class="bulllist" id="p0250">
           <a id="u0070">
           </a>
           ▪ What (if any) mental models do they have for the problem domain?
          </li>
          <li class="bulllist" id="p0255">
           <a id="u0075">
           </a>
           ▪ What domain terminology do they use?
          </li>
         </ol>
        </div>
        <p class="textfl">
         <a id="p131">
         </a>
        </p>
        <div>
         <span aria-label="131" epub:type="pagebreak" id="pagebreak_131" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0260">
         If you're revising or refactoring an existing API, you can also ask developers to comment on the code that they currently must write to use the API. This can help to identify cumbersome workflows and unused parts of an API. You can also ask them how they would prefer to use the API in an ideal world (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib95" id="bib_95">
          Stylos et al., 2008
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <div class="b1textfl" id="bpar0010">
            <i>
             TIP: Functional requirements are used to specify how your API should behave.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0265">
         Functional requirements can also be supported by nonfunctional requirements. These are requirements that define the operational constraints of an API rather than how it behaves. These qualities can be just as critical to a user as the functionality provided by the API. Examples of nonfunctional requirements include aspects such as:
        </p>
        <div>
         <ol id="ulist0025">
          <li class="bulllist" id="p0270">
           <a id="u0080">
           </a>
           ▪
           <b>
            Performance.
           </b>
           Are there constraints on the speed of certain operations?
          </li>
          <li class="bulllist" id="p0275">
           <a id="u0085">
           </a>
           ▪
           <b>
            Platform compatibility.
           </b>
           On which platforms must the code run?
          </li>
          <li class="bulllist" id="p0280">
           <a id="u0090">
           </a>
           ▪
           <b>
            Security.
           </b>
           Are there data security, access, or privacy concerns?
          </li>
          <li class="bulllist" id="p0285">
           <a id="u0095">
           </a>
           ▪
           <b>
            Scalability.
           </b>
           Can the system handle real-world data inputs?
          </li>
          <li class="bulllist" id="p0290">
           <a id="u0100">
           </a>
           ▪
           <b>
            Flexibility.
           </b>
           Will the system need to be extended after release?
          </li>
          <li class="bulllist" id="p0295">
           <a id="u0105">
           </a>
           ▪
           <b>
            Usability.
           </b>
           Can the user easily understand, learn, and use the API?
          </li>
          <li class="bulllist" id="p0300">
           <a id="u0110">
           </a>
           ▪
           <b>
            Concurrency.
           </b>
           Does the system need to use multiple processors?
          </li>
          <li class="bulllist" id="p0305">
           <a id="u0115">
           </a>
           ▪
           <b>
            Cost.
           </b>
           How much will the software cost?
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         Example functional requirements
        </h3>
        <p class="textfl" id="p0310">
         Functional requirements are normally managed in a requirements document in which each requirement is given a unique identifier and a description. A rationale for the requirement may also be provided to explain why it's necessary. It's typical to present the requirements as a concise list of bullet points and to organize the document into different themed sections so that requirements relating to the same part of the system can be colocated.
        </p>
        <p class="text" id="p0315">
         Good functional requirements should be simple, easy to read, unambiguous, verifiable, and free of jargon. It's important that they don't overly specify the technical implementation: functional requirements should document what an API should do and not how it does it. Very often, a client will tell you how a feature should be implemented. It's important instead to get them to tell you what the underlying problem is that they want to solve. There may be better ways to solve the problem than the one solution they're proposing.
        </p>
        <p class="text" id="p0320">
         To illustrate these points, here's an example list of functional requirements for a user interacting with an automated teller machine (ATM):
        </p>
        <div>
         <ul id="ulist0030">
          <li class="unnumlist" id="p0325">
           <a id="u0120">
           </a>
           <b>
            REQ 1.1.
           </b>
           The system shall prevent further interaction if it's out of cash or is unable to communicate with the financial institution.
           <a id="p132">
           </a>
          </li>
          <li>
           <span aria-label="132" epub:type="pagebreak" id="pagebreak_132" role="doc-pagebreak">
           </span>
          </li>
          <li class="unnumlist" id="p0330">
           <a id="u0125">
           </a>
           <b>
            REQ 1.2.
           </b>
           The system shall validate that the inserted card is valid for financial transactions on this ATM.
          </li>
          <li class="unnumlist" id="p0335">
           <a id="u0130">
           </a>
           <b>
            REQ 1.3.
           </b>
           The system shall validate that the PIN number entered by the user is correct.
          </li>
          <li class="unnumlist" id="p0340">
           <a id="u0135">
           </a>
           <b>
            REQ 1.4.
           </b>
           The system shall dispense the requested amount of money, if it is available, and debit the user's account by the same amount.
          </li>
          <li class="unnumlist" id="p0345">
           <a id="u0140">
           </a>
           <b>
            REQ 1.5.
           </b>
           The system shall notify the user if the transaction cannot be completed. In that case, no money shall be taken from the user's account.
          </li>
         </ul>
        </div>
       </section>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         Maintaining the requirements
        </h3>
        <p class="textfl" id="p0350">
         There's no such thing as stable requirements; you should always expect them to change over time. This happens for a variety of reasons, the most common of which is that users (and you) will have a clearer idea of how the system should function as you start building it. You should therefore make sure that you version and date your requirements, so that you can refer to a specific version of the document and know how old it is.
        </p>
        <p class="text" id="p0355">
         On average, 25% of a project's functional requirements will change during development, accounting for 70%–85% of the code that needs to be reworked (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56" id="bib_56">
          McConnell, 2004
         </a>
         ). While it's good to stay in sync with the evolving needs of your clients, you should also make sure that everyone understands the cost of changing requirements. Adding new requirements will cause the project to take longer to deliver. It may also require significant changes to the design, causing a lot of code to be rewritten.
        </p>
        <p class="text" id="p0360">
         In particular, you should be wary of falling into the trap of requirements creep. Any major changes to the functional requirements should trigger a revision of the schedule and costing for the project. In general, any new additions to the requirements should be evaluated against the incremental business value that they deliver. Assessing a new requirement from this pragmatic viewpoint should help to weigh the benefit of the change against the cost of implementing it. Another useful technique when being asked to add a large new requirement without a change to the delivery schedule is to ask which of the existing requirements should be removed so that the new one can be added. This can often help to focus the discussion on the relative priority of the new requirement versus the existing ones.
        </p>
       </section>
      </section>
      <section>
       <a id="s0050">
       </a>
       <h2 class="h1hd" id="cesectitle0060">
        Creating use cases
       </h2>
       <p class="textfl" id="p0365">
        A use case describes the behavior of an API based upon the interactions of a user or another piece of software (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib46" id="bib_46">
         Jacobson, 1992
        </a>
        ). Use cases are essentially a form of functional requirement that specifically captures who does what with an API and for what purpose, rather than simply providing a list of features, behaviors, or implementation notes. Focusing on use cases helps you to design an API from the perspective of the client.
       </p>
       <p class="text" id="p0370">
        It is common to produce both a functional requirement document as well as a set of use cases. For example, use cases can be used to describe an API from the user's
        <a id="p133">
        </a>
        <span aria-label="133" epub:type="pagebreak" id="pagebreak_133" role="doc-pagebreak">
        </span>
        point of view, whereas functional requirements can be used to describe a list of features or the details of an algorithm. However, concentrating on just one of these techniques can often be sufficient, too. In that case, I recommend creating use cases because these resonate most closely with the way a user wants to interact with a system. When using both methods, you can either derive functional requirements from the use cases or vice versa. However, it's more typical to work with your users to produce use cases first and then to derive a list of functional requirements from these use cases.
       </p>
       <div>
        <aside aria-labelledby="b0015" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0015">
          <div class="b1textfl" id="bpar0015">
           <i>
            TIP: Use cases describe the requirements for your API from the perspective of the user.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <p class="text" id="p0375">
        Ken Arnold uses the analogy of driving a car to illustrate the importance of designing an interface based upon its use rather than its implementation details. He notes that you are more likely to come up with a good experience for drivers by asking the question, “How does the user control the car?” instead of “How can the user adjust the rate of fuel pumped into each of the pistons?” (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib4" id="bib_4">
         Arnold, 2005
        </a>
        ).
       </p>
       <section>
        <a id="s0055">
        </a>
        <h3 class="h2hd" id="cesectitle0065">
         Developing use cases
        </h3>
        <p class="textfl" id="p0380">
         Every use case describes a goal that an actor is trying to achieve. An actor is an entity external to the system that initiates interactions, such as a human user, a device, or another piece of software. Each actor may have different roles when interacting with the system. For example, a single actor for a database may take on the role of administrator, developer, or database user. A good way to approach the process of creating use cases is therefore to:
        </p>
        <div>
         <ul class="ce_list" id="olist0020">
          <li class="numlist" id="p0385">
           <a id="o0060">
           </a>
           1. Identify all actors of the system and the roles that each have
          </li>
          <li class="numlist" id="p0390">
           <a id="o0065">
           </a>
           2. Identify all goals that each role needs to accomplish
          </li>
          <li class="numlist" id="p0395">
           <a id="o0070">
           </a>
           3. Create use cases for each goal.
          </li>
         </ul>
        </div>
        <p class="text" id="p0400">
         Each use case should be written in plain language using the vocabulary of the problem domain. It should be named to describe the outcome of value to the actor. Each step of the use case should start with the role followed by an active verb. For example, continuing our ATM example, the following steps describe how to validate a user's PIN number:
        </p>
        <div>
         <ul id="ulist0035">
          <li class="unnumlist" id="p0405">
           <a id="u0145">
           </a>
           <b>
            Step 1.
           </b>
           User inserts ATM card.
          </li>
          <li class="unnumlist" id="p0410">
           <a id="u0150">
           </a>
           <b>
            Step 2.
           </b>
           System validates ATM card is valid for use with the ATM machine.
          </li>
          <li class="unnumlist" id="p0415">
           <a id="u0155">
           </a>
           <b>
            Step 3.
           </b>
           System prompts the user to enter PIN number.
          </li>
          <li class="unnumlist" id="p0420">
           <a id="u0160">
           </a>
           <b>
            Step 4.
           </b>
           User enters PIN number.
          </li>
          <li class="unnumlist" id="p0425">
           <a id="u0165">
           </a>
           <b>
            Step 5.
           </b>
           System checks that the PIN number is correct.
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p134">
         </a>
        </p>
        <div>
         <span aria-label="134" epub:type="pagebreak" id="pagebreak_134" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0060">
        </a>
        <h3 class="h2hd" id="cesectitle0070">
         Use case templates
        </h3>
        <p class="textfl" id="p0430">
         A good use case represents a goal-oriented narrative description of a single unit of behavior. It includes a distinct sequence of steps that describes the workflow to achieve the goal of the use case. It can also provide clear preconditions and postconditions to specify the state of the system before and after the use case (i.e., to state the dependencies between use cases explicitly, as well as the trigger event that causes a use case to be initiated).
        </p>
        <p class="text" id="p0435">
         Use cases can be recorded with different degrees of formality and verbosity. For example, they can be as simple as a few sentences or they can be as formal as structured, cross-referenced specifications that conform to a particular template. They can even be described visually, such as with the Universal Modeling Language (UML) Use Case Diagram (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib18" id="bib_18">
          Cockburn, 2000
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <div class="b1textfl" id="bpar0020">
            <i>
             TIP: Use cases can be simple lists of short goal-oriented descriptions or they can be more formal structured specifications that follow a prescribed template.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0440">
         In the more formal instance, there are many different template formats and styles for representing use cases textually. These templates tend to be very project-specific, and they can be as short or extensive as appropriate for that project. Don't get hung up on the details of your template. It's more important to communicate the requirements clearly than to conform to a rigid notation (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib2" id="bib_2">
          Alexander, 2003
         </a>
         ). Nonetheless, a few common elements of a use case template include:
        </p>
        <div>
         <aside aria-labelledby="b0025" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0025">
           <div class="b1textfl" id="bpar0025">
            <b>
             Name
            </b>
            :
            <i>
             A unique identifier for the use case, often in verb–noun format such as Withdraw Cash or Buy Stamps.
            </i>
           </div>
           <div class="b1text" id="bpar0030">
            <b>
             Version
            </b>
            :
            <i>
             A number to differentiate different versions of the use case.
            </i>
           </div>
           <div class="b1text" id="bpar0035">
            <b>
             Description
            </b>
            :
            <i>
             A brief overview that summarizes the use case in one or two sentences.
            </i>
           </div>
           <div class="b1text" id="bpar0040">
            <b>
             Goal:
            </b>
            <i>
             A description of what the user wants to accomplish.
            </i>
           </div>
           <div class="b1text" id="bpar0045">
            <b>
             Actors
            </b>
            :
            <i>
             The actor roles that want to achieve the goal.
            </i>
           </div>
           <div class="b1text" id="bpar0050">
            <b>
             Stakeholder
            </b>
            :
            <i>
             The individual or organization that has a vested interest in the outcome of the use case (
            </i>
            e.g.,
            <i>
             an ATM User or the bank).
            </i>
           </div>
           <div class="b1text" id="bpar0055">
            <b>
             Basic Course
            </b>
            :
            <i>
             A sequence of steps that describe the typical course of events. This should avoid conditional logic when possible.
            </i>
           </div>
           <div class="b1text" id="bpar0060">
            <b>
             Extensions
            </b>
            :
            <i>
             A list of conditions that cause alternative steps to be taken. This describes what to do if the goal fails (
            </i>
            e.g.,
            <i>
             an invalid PIN number was entered).
            </i>
           </div>
           <div class="b1text" id="bpar0065">
            <b>
             Precondition
            </b>
            :
            <i>
             A list of conditions required for the trigger to execute successfully.
            </i>
           </div>
           <div class="b1text" id="bpar0070">
            <b>
             Trigger
            </b>
            :
            <i>
             The event that causes the use case to be initiated.
            </i>
           </div>
           <div class="b1text" id="bpar0075">
            <b>
             Postcondition
            </b>
            :
            <i>
             Describes the state of the system after the successful execution of the use case.
            </i>
           </div>
           <div class="b1text" id="bpar0080">
            <b>
             Notes
            </b>
            :
            <i>
             Additional information that doesn't fit well into any other category.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p135">
         </a>
        </p>
        <div>
         <span aria-label="135" epub:type="pagebreak" id="pagebreak_135" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         Writing good use cases
        </h3>
        <p class="textfl" id="p0445">
         Writing use cases should be an intuitive process. They are written in plain easy-to-read language to capture the user's perspective on how the API should be used. However, even supposedly intuitive tasks can benefit from general guidelines and words of advice.
        </p>
        <div>
         <ol id="ulist0040">
          <li class="bulllist" id="p0450">
           <a id="u0170">
           </a>
           ▪
           <b>
            Use domain terminology.
           </b>
           Use cases should be described in terms that are natural to the clients of an API. The terms that are used should be familiar to users and should come from the domain being targeted. In effect, users should be able to read use cases and easily understand the scenarios without their appearing too contrived.
          </li>
          <li class="bulllist" id="p0455">
           <a id="u0175">
           </a>
           ▪
           <b>
            Don't overspecify use cases.
           </b>
           Use cases should describe the black-box functionality of a system (i.e., you should avoid specifying implementation details). You should also avoid including too much detail in your use cases. Alistair Cockburn uses the example of inserting coins into a candy machine. Rather than trying to specify different combinations of inserting the correct quantity, such as “person inserts three quarters, or 15 nickels, or a quarter followed by 10 nickels,” you just need to write “person inserts money.”
          </li>
          <li class="bulllist" id="p0460">
           <a id="u0180">
           </a>
           ▪
           <b>
            Use cases don't define all requirements.
           </b>
           Use cases don't encompass all possible forms of requirements gathering. For example, they don't represent system design, lists of features, algorithm specifics, or any other parts of the system that are not user-oriented. Use cases concentrate on behavioral requirements for how the user should interact with the API. You may still wish to compile functional and nonfunctional requirements in addition to use cases.
          </li>
          <li class="bulllist" id="p0465">
           <a id="u0185">
           </a>
           ▪
           <b>
            Use cases don't define a design.
           </b>
           Although you can often create a high-level preliminary design from your use cases, you should not fall into the trap of believing that use cases directly define the best design. That they don't define all requirements is one reason. For example, they don't define performance, security, or network aspects of the API, which can greatly affect the most appropriate design. Also, use cases are written from the perspective of users. You may therefore need to reinterpret their feedback in light of conflicting or imprecise goals rather than treating them too literally (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib66" id="bib_66">
            Meyer, 1997
           </a>
           ).
          </li>
          <li class="bulllist" id="p0470">
           <a id="u0190">
           </a>
           ▪
           <b>
            Don't specify design in use cases.
           </b>
           It's generally accepted that you should avoid describing user interfaces (UI) in use cases, because UI is a design not a requirement and because UI designs are more changeable (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib18">
            Cockburn, 2000
           </a>
           ). Although this axiom is not directly applicable to UI-less API design, it can be extrapolated to our circumstances by stating that you should keep API design specifics out of your use cases. Users may try to propose a particular solution for you to implement, but better solutions to the problem may exist. API design should therefore follow from your use case analysis. In other words, use cases define how a user wants to achieve a goal regardless of the actual design.
           <a id="p136">
           </a>
          </li>
          <li>
           <span aria-label="136" epub:type="pagebreak" id="pagebreak_136" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p0475">
           <a id="u0195">
           </a>
           ▪
           <b>
            Use cases can direct testing.
           </b>
           Use cases are not test plans in themselves because they don't specify specific input and output values. However, they do specify the key workflows that your users expect to be able to achieve. As such, they are a great source to direct automated testing efforts for your API. Writing a suite of tests that verify these key workflows will give you the confidence that you've reached the needs of your users and that you don't break this functionality as you evolve the API in the future.
          </li>
          <li class="bulllist" id="p0480">
           <a id="u0200">
           </a>
           ▪
           <b>
            Expect to iterate.
           </b>
           Don't be too concerned about getting all of your use cases perfect the first time. Use case analysis is a process of discovery; it helps you learn more about the system you want to build. You should therefore look upon it as an iterative process in which you can refine existing use cases as you expand your knowledge of the entire system (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib2">
            Alexander, 2003
           </a>
           ). On the other hand, it's well-known that errors in requirements can significantly affect a project, causing major redesign and reimplementation efforts. This is why the first piece of advice I gave was to avoid making your use cases too detailed.
          </li>
          <li class="bulllist" id="p0485">
           <a id="u0205">
           </a>
           ▪
           <b>
            Don't insist on complete coverage.
           </b>
           For the same reasons that use cases do not encompass all forms of requirements, you should not expect your use cases to express all aspects of your API. However, you also don't need them to cover everything. Some parts of the system may already be well-understood or do not need a user-directed perspective. There's also the logistical concern that you will not have unlimited time and resources to compile exhaustive use cases, so you should focus the effort on the most important user-oriented goals and workflows (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib2">
            Alexander, 2003
           </a>
           ).
          </li>
         </ol>
        </div>
        <p class="text" id="p0490">
         Putting all this information together, I will complete our ATM example by presenting a sample use case for entering a PIN number and use our template from earlier to format the use case:
        </p>
        <div>
         <aside aria-labelledby="b0030" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0030">
           <div class="b1textfl" id="bpar0085">
            <b>
             Name
            </b>
            : Enter PIN
           </div>
           <div class="b1text" id="bpar0090">
            <b>
             Version
            </b>
            : 1.0.
           </div>
           <div class="b1text" id="bpar0095">
            <b>
             Description
            </b>
            : User enters PIN number to validate her bank account information.
           </div>
           <div class="b1text" id="bpar0100">
            <b>
             Goal:
            </b>
            System validates User's PIN number.
           </div>
           <div class="b1text" id="bpar0105">
            <b>
             Stakeholders
            </b>
            .
           </div>
           <div>
            <ul class="ce_list" id="olist0025">
             <li class="b1numlist" id="bpar0110">
              <a id="o0075">
              </a>
              1. User wants to use ATM services.
             </li>
             <li class="b1numlist" id="bpar0115">
              <a id="o0080">
              </a>
              2. Bank wants to validate the User's account.
             </li>
            </ul>
           </div>
           <div class="b1text" id="bpar0120">
            <b>
             Basic Course
            </b>
            .
           </div>
           <div>
            <ul class="ce_list" id="olist0030">
             <li class="b1numlist" id="bpar0125">
              <a id="o0085">
              </a>
              1. System validates that ATM card is valid for use with the ATM machine.
             </li>
             <li class="b1numlist" id="bpar0130">
              <a id="o0090">
              </a>
              2. System prompts the user to enter PIN number.
             </li>
             <li class="b1numlist" id="bpar0135">
              <a id="o0095">
              </a>
              3. User enters PIN number.
             </li>
             <li class="b1numlist" id="bpar0140">
              <a id="o0100">
              </a>
              4. System checks that the PIN number is correct.
             </li>
            </ul>
           </div>
           <div class="b1text" id="bpar0145">
            <b>
             Extensions
            </b>
            .
           </div>
           <div>
            <ul class="ce_list" id="olist0035">
             <li class="b1numlist" id="bpar0150">
              <a id="o0105">
              </a>
              a. System failure to recognize ATM card:
             </li>
             <li class="b1numlist">
              <ul id="olist0040">
               <li class="b1unnumlist1" id="bpar0155">
                <a id="o0110">
                </a>
                <b>
                 a-1
                </b>
                . System displays error message and aborts operation.
               </li>
              </ul>
             </li>
             <li class="b1numlist" id="bpar0160">
              <a id="o0115">
              </a>
              b. User enters invalid PIN:
             </li>
             <li class="b1numlist">
              <ul id="olist0045">
               <li class="b1unnumlist1" id="bpar0165">
                <a id="o0120">
                </a>
                <b>
                 b-1
                </b>
                . System displays error message and lets User retry.
               </li>
              </ul>
             </li>
            </ul>
           </div>
           <div class="b1text" id="bpar0170">
            <b>
             Trigger
            </b>
            : User inserts card into ATM.
           </div>
           <div class="b1text" id="bpar0175">
            <b>
             Postcondition
            </b>
            : User's PIN number is validated for financial transactions.
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p137">
         </a>
        </p>
        <div>
         <span aria-label="137" epub:type="pagebreak" id="pagebreak_137" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         Requirements and agile development
        </h3>
        <p class="textfl" id="p0495">
         Agile development is a general term for software development methods that align with the principles of the Agile Manifesto. Examples include extreme programming (XP), Scrum, and the Dynamic System Development Method. The Agile Manifesto (
         <a href="http://agilemanifesto.org/">
          http://agilemanifesto.org/
         </a>
         ) was written in Feb. 2001 by 17 contributors who wanted to find more lightweight and nimble alternatives to the traditional development processes of the time. It states that the following qualities should be valued when developing software:
        </p>
        <div>
         <ol id="ulist0045">
          <li class="bulllist" id="p0500">
           <a id="u0210">
           </a>
           ▪
           <b>
            Individuals and interactions
           </b>
           over processes and tools
          </li>
          <li class="bulllist" id="p0505">
           <a id="u0215">
           </a>
           ▪
           <b>
            Working software
           </b>
           over comprehensive documentation
          </li>
          <li class="bulllist" id="p0510">
           <a id="u0220">
           </a>
           ▪
           <b>
            Customer collaboration
           </b>
           over contract negotiation
          </li>
          <li class="bulllist" id="p0515">
           <a id="u0225">
           </a>
           ▪
           <b>
            Responding to change
           </b>
           over following a plan
          </li>
         </ol>
        </div>
        <p class="text" id="p0520">
         Agile methodologies therefore deemphasize document-centric processes, instead preferring to iterate on working code. However, this does not mean that they have no requirements. What it means is that the requirements are lightweight and easily changed. Maintaining a large, wordy, formal requirements document would not be considered agile. However, the general concept of use cases is very much a part of agile processes such as Scrum and XP, which emphasize the creation of user stories.
        </p>
        <p class="text" id="p0525">
         A user story is a high-level requirement that contains just enough information for a developer to provide a reasonable estimate of the effort required to implement it. It's conceptually similar to a use case, except that the goal is to keep them very short, normally just a single sentence. So the brief informal use case is more similar to a user story than the formal template-driven or UML use case. Another important distinction is that user stories are not all completed up-front. Many user stories will be added incrementally as the working code evolves. That is, you start writing code for your design early to avoid throwing away specifications that become invalid after you try to implement them.
         <a id="p138">
         </a>
         <span aria-label="138" epub:type="pagebreak" id="pagebreak_138" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0035" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0035">
           <div class="b1textfl" id="bpar0180">
            <i>
             TIP: User stories are a way to capture minimal requirements from users within an agile development process.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0530">
         Another important aspect of user stories is that they are written by project stakeholders, not developers: that is, the customers, vendors, business owners, or support personnel who are interested in the product being developed. Keeping the user story short allows stakeholders to write them in a few minutes. Mike Cohn suggests using a simple format to describe user stories (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib19" id="bib_19">
          Cohn, 2004
         </a>
         ):
        </p>
        <div>
         <ul id="ulist0050">
          <li class="unnumlist" id="p0535">
           <a id="u0230">
           </a>
           As a [
           <i>
            role
           </i>
           ] I want [
           <i>
            something
           </i>
           ] so that [
           <i>
            benefit
           </i>
           ].
          </li>
         </ul>
        </div>
        <p class="text" id="p0540">
         For instance, referring back to our ATM example, here's an example of five different user stories for interacting with a cash machine:
        </p>
        <div>
         <ol id="ulist0055">
          <li class="bulllist" id="p0545">
           <a id="u0235">
           </a>
           ▪ As a customer I want to withdraw cash so that I can buy things.
          </li>
          <li class="bulllist" id="p0550">
           <a id="u0240">
           </a>
           ▪ As a customer I want to transfer money from my savings account to my checking account so I can write checks.
          </li>
          <li class="bulllist" id="p0555">
           <a id="u0245">
           </a>
           ▪ As a customer I want to deposit money into my account so I can increase my account balance.
          </li>
          <li class="bulllist" id="p0560">
           <a id="u0250">
           </a>
           ▪ As a bank business owner I want the customer's identity to be verified securely so that the ATM can protect against fraudulent activities.
          </li>
          <li class="bulllist" id="p0565">
           <a id="u0255">
           </a>
           ▪ As an ATM operator I want to restock the ATM with money so the ATM will have cash for customers to withdraw.
          </li>
         </ol>
        </div>
        <p class="text" id="p0570">
         Given a set of well-written user stories, engineers can estimate the scale of the development effort involved, usually in terms of an abstract quantity like story points, and work on implementing these stories. Stakeholders will also often provide an indication of the priority of a user story, to help prioritize the order of work from the backlog of all stories. Stakeholders then assess the state of the software at regular intervals, such as during a sprint review, and can provide further user stories to focus the next iteration of development. In other words, this implies active user involvement and favors an iterative development style over the creation of large up-front requirements documents.
        </p>
        <p class="text" id="p0575">
         Cohn also presents an easy-to-remember acronym to help you create good user stories: INVEST, in which each letter stands for a quality of a well-written user story (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib19">
          Cohn, 2004
         </a>
         ):
        </p>
        <div>
         <ul id="ulist0060">
          <li class="unnumlist" id="p0580">
           <a id="u0260">
           </a>
           <b>
            I
           </b>
           ndependent
          </li>
          <li class="unnumlist" id="p0585">
           <a id="u0265">
           </a>
           <b>
            N
           </b>
           egotiable
           <a id="p139">
           </a>
          </li>
          <li>
           <span aria-label="139" epub:type="pagebreak" id="pagebreak_139" role="doc-pagebreak">
           </span>
          </li>
          <li class="unnumlist" id="p0590">
           <a id="u0270">
           </a>
           <b>
            V
           </b>
           aluable
          </li>
          <li class="unnumlist" id="p0595">
           <a id="u0275">
           </a>
           <b>
            E
           </b>
           stimable
          </li>
          <li class="unnumlist" id="p0600">
           <a id="u0280">
           </a>
           <b>
            S
           </b>
           mall
          </li>
          <li class="unnumlist" id="p0605">
           <a id="u0285">
           </a>
           <b>
            T
           </b>
           estable
          </li>
         </ul>
        </div>
        <p class="text" id="p0610">
         All of the advice that I offered earlier for writing good use cases applies equally well to user stories. For example, agile processes such as SCRUM and XP do not tell you how to design your API. So you must not forget that once you've built up your backlog of user stories, you still have to go through a separate design process to work out how best to implement those stories.
        </p>
        <p class="text" id="p0615">
         As I reflect on the process for producing 3D feature films at animation studios such as Pixar, I think there are some good analogies to be drawn. Animated movies are developed using a production pipeline where, generally speaking, the output of one department feeds into the next department. The first year or two of a production is driven by the story department, which defines the main characters and overall story arc for the movie. It can also produce physical assets such as storyboards and character studies. Only once these efforts are far enough along does any digital production work happen. I believe that a large part of the success of Pixar movies is due to this up-front emphasis on defining and refining the story elements before the expensive parts of a production are ramped up.
        </p>
        <p class="text" id="p0620">
         The analogy to software development is that a successful project should have a strong product team that defines the users and features of that product up-front. This might include developing assets such as persona modeling, requirements gathering, and use case definition. Only then should any engineers start writing production code. This is not to say that no code ever gets written while the product is being defined. Obviously, there can be prototypes and investigations to address known technical challenges or large risk areas. But there is little point in writing code when you don't even know who your users are and what problems they need to solve.
        </p>
        <p class="text" id="p0625">
         This production pipeline analogy may sound like I'm advocating for a traditional waterfall software development method, but I'm not. The process used for developing the software implementation can be whatever you want, once you've figured out what you have to build. The recommendation to think deeply about your users and product design up-front can still be combined with an agile sprint-based engineering process. And once the big design questions have been figured out, you can start using more agile processes for the design effort, too, such as designing smaller features during one sprint and then having engineers implement them during the next sprint.
        </p>
       </section>
      </section>
      <section>
       <a id="s0075">
       </a>
       <h2 class="h1hd" id="cesectitle0085">
        Elements of API design
       </h2>
       <p class="textfl" id="p0630">
        At last, we can talk about design! The secret to producing a good API design lies in coming up with an appropriate abstraction for the problem domain and then devising appropriate object and class hierarchies to represent that abstraction.
        <a id="p140">
        </a>
       </p>
       <div>
        <span aria-label="140" epub:type="pagebreak" id="pagebreak_140" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p0635">
        An abstraction is just a simplified description of something that can be understood with no knowledge of how it will be implemented programmatically. It tends to emphasize the important characteristics and responsibilities of that thing while ignoring details that are not important to understanding its basic nature. Furthermore, you often find that complex problems exhibit hierarchies, or layers, of abstractions (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib38" id="bib_38">
         Henning, 2009
        </a>
        ).
       </p>
       <p class="text" id="p0640">
        For example, you could describe how a car works at a very high level with six basic components: a fuel system, engine, transmission, driveshaft, axle, and wheels. The fuel system provides the energy to turn the engine, which causes the transmission to rotate, whereas the driveshaft connects the transmission to the axle, allowing power to reach the wheels and ultimately cause the vehicle to move forward. This is one level of abstraction that's useful to understand the most general principles of how a car achieves forward motion. However, you could also offer another level of abstraction that provides more detail for one or more of these components. For example, an internal combustion engine could be described with several interconnected components, including a piston, crankshaft, camshaft, distributor, flywheel, and timing belt. Furthermore, an engine can be categorized as one of several different types, such as an internal combustion engine, an electric engine, a gas/electric hybrid, or a hydrogen fuel cell.
       </p>
       <p class="text" id="p0645">
        Similarly, most designs for complex software systems exhibit structure at multiple levels of detail, and those hierarchies can also be viewed in different ways. Grady Booch suggests that there are two important hierarchical views of any complex system (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib12" id="bib_12">
         Booch et al., 2007
        </a>
        ):
       </p>
       <div>
        <ul class="ce_list" id="olist0050">
         <li class="numlist" id="p0650">
          <a id="o0125">
          </a>
          1.
          <b>
           The object hierarchy
          </b>
          : Describes how different objects cooperate in the system. This represents a structural grouping based upon a part-of relationship between objects (e.g., a piston is part of an engine, which is part of a car).
         </li>
         <li class="numlist" id="p0655">
          <a id="o0130">
          </a>
          2.
          <b>
           The class hierarchy
          </b>
          : Describes the common structure and behavior that is shared between related objects. It deals with the generalization and specialization of object properties. This can be thought of as an is-a hierarchy between objects (e.g., a hybrid engine is a type of car engine).
         </li>
        </ul>
       </div>
       <p class="text" id="p0660">
        Both views are equally important when producing the design for a software system.
        <a href="#f0020" id="Bf0020">
         Fig. 4.3
        </a>
        attempts to illustrate these two concepts, showing a hierarchy of related objects and a hierarchy of classes that inherit behavior and properties.
       </p>
       <p class="text" id="p0665">
        Related to this, it's generally agreed that the design phase of software construction consists of two major activities (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib14" id="bib_14">
         Bourque et al., 2004
        </a>
        ):
       </p>
       <div>
        <ul class="ce_list" id="olist0055">
         <li class="numlist" id="p0670">
          <a id="o0135">
          </a>
          1.
          <b>
           Architecture design.
          </b>
          Describes the top-level structure and organization of a piece of software.
         </li>
         <li class="numlist" id="p0675">
          <a id="o0140">
          </a>
          2.
          <b>
           Detailed design.
          </b>
          Describes individual components of the design to a sufficient level at which they can be implemented.
         </li>
        </ul>
       </div>
       <p class="text" id="p0680">
        Therefore, as a general approach, I suggest defining an object hierarchy to delineate the top-level conceptual structure (or architecture) of your system, and then refine this
        <a id="p141">
        </a>
        <span aria-label="141" epub:type="pagebreak" id="pagebreak_141" role="doc-pagebreak">
        </span>
        with class hierarchies that specify concrete C++ classes for your clients to use. The latter process of defining the classes of your API also involves thinking about the individual functions and arguments that they provide. The rest of this chapter will therefore focus on each of these topics in turn:
       </p>
       <div class="pageavoid">
        <figure class="fig" id="f0020">
         <img alt="image" height="2257" src="../../IMAGES/B9780443222191000088/main.assets/f04-03a-9780443222191.jpg" width="1768"/>
         <figcaption class="figleg">
          <a id="cap0020">
          </a>
          <a id="fspara0020">
          </a>
          <span class="fignum">
           <a href="#Bf0020">
            Figure 4.3
           </a>
          </span>
          A car design shown as (A) a part-of object hierarchy.
         </figcaption>
        </figure>
       </div>
       <div>
        <ul class="ce_list" id="olist0060">
         <li class="numlist" id="p0685">
          <a id="o0145">
          </a>
          1. Architecture design.
         </li>
         <li class="numlist" id="p0690">
          <a id="o0150">
          </a>
          2. Class design.
         </li>
         <li class="numlist" id="p0695">
          <a id="o0155">
          </a>
          3. Function design.
         </li>
        </ul>
       </div>
       <p class="textfl">
        <a id="p142">
        </a>
        <span aria-label="142" epub:type="pagebreak" id="pagebreak_142" role="doc-pagebreak">
        </span>
       </p>
       <div class="pageavoid">
        <figure class="fig" id="f0020a">
         <img alt="image" height="1954" src="../../IMAGES/B9780443222191000088/main.assets/f04-03b-9780443222191.jpg" width="1515"/>
         <figcaption class="figleg">
          <a id="cap0021">
          </a>
          <a id="fspara0021">
          </a>
          <span class="fignum">
           Figure 4.3
          </span>
          (B) an is-a class hierarchy.
          <i>
           Arrows
          </i>
          point from more specific to more general classes.
         </figcaption>
        </figure>
       </div>
       <div>
        <aside aria-labelledby="b0040" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0040">
          <div class="b1textfl" id="bpar0185">
           <i>
            TIP: API design involves developing a top-level architecture and a detailed class hierarchy.
           </i>
          </div>
         </div>
        </aside>
       </div>
      </section>
      <section>
       <a id="s0080">
       </a>
       <h2 class="h1hd" id="cesectitle0090">
        Architecture design
       </h2>
       <p class="textfl" id="p0700">
        Software architecture describes the coarse structure of an entire system: the collection of top-level objects in the API and their relationships to each other. By developing an architecture, you gain an understanding of the different components of the system in the abstract, as well as how they communicate and cooperate with each other.
       </p>
       <p class="text" id="p0705">
        It's important to spend time thinking about the top-level architecture for your API because problems in your architecture can have far-reaching and extensive impact on your system. Consequently, in this Section I will detail the process of producing an architecture for your API and provide insight into how you can decompose a problem domain into an appropriate collection of abstract objects.
        <a id="p143">
        </a>
       </p>
       <div>
        <span aria-label="143" epub:type="pagebreak" id="pagebreak_143" role="doc-pagebreak">
        </span>
       </div>
       <section>
        <a id="s0085">
        </a>
        <h3 class="h2hd" id="cesectitle0095">
         Developing an architecture
        </h3>
        <p class="textfl" id="p0710">
         There's no right or wrong architecture for any given problem. If you give the same set of requirements to two different architects, you'll undoubtedly end up with two different solutions. The important aspect is to produce a well-thought-out purposeful design that delivers a framework to implement the system and resolves trade-offs between the various conflicting requirements and constraints (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib7" id="bib_7">
          Bass et al., 2003
         </a>
         ). At a high level, the process of creating an architecture for an API resolves to four basic steps:
        </p>
        <div>
         <ul class="ce_list" id="olist0065">
          <li class="numlist" id="p0715">
           <a id="o0160">
           </a>
           1. Analyze the functional requirements that affect the architecture.
          </li>
          <li class="numlist" id="p0720">
           <a id="o0165">
           </a>
           2. Identify and account for the constraints on the architecture.
          </li>
          <li class="numlist" id="p0725">
           <a id="o0170">
           </a>
           3. Invent the primary objects in the system and their relationships.
          </li>
          <li class="numlist" id="p0730">
           <a id="o0175">
           </a>
           4. Communicate and document the architecture.
          </li>
         </ul>
        </div>
        <p class="text" id="p0735">
         The first of these steps is fed by the earlier requirements gathering stage (refer back to
         <a href="#f0010">
          Fig. 4.1
         </a>
         ), whether it is based upon a formal functional requirements document, a set of goal-oriented use cases, or a collection of informal user stories. The second step involves capturing and accounting for all factors that place a constraint on the architecture you design. The third step involves defining the high-level object model for the system: the key objects and how they relate to each other. Finally, the architecture should be communicated to the engineers who must implement it.
         <a href="#f0025" id="Bf0025">
          Fig. 4.4
         </a>
         illustrates each of these steps.
        </p>
        <p class="text" id="p0740">
         It's important to stress that this sequence of steps is not a recipe that you perform only once and magically arrive at the perfect architecture. As I've stated, software design
         <a id="p144">
         </a>
         <span aria-label="144" epub:type="pagebreak" id="pagebreak_144" role="doc-pagebreak">
         </span>
         is an iterative process. You will rarely get each step right the first time. On the other hand, the first version of your API is critical because changes after that point will incur a higher cost. It's therefore important to try out your design early on and improve it incrementally before releasing it to clients who will then start to build upon it in their own programs.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0025">
          <img alt="image" height="1552" src="../../IMAGES/B9780443222191000088/main.assets/f04-04-9780443222191.jpg" width="2571"/>
          <figcaption class="figleg">
           <a id="cap0025">
           </a>
           <a id="fspara0025">
           </a>
           <span class="fignum">
            <a href="#Bf0025">
             Figure 4.4
            </a>
           </span>
           The steps to develop an application programming interface architecture: (1) gather user requirements, (2) identify constraints, (3) invent key objects, and (4) communicate design.
          </figcaption>
         </figure>
        </div>
       </section>
       <section>
        <a id="s0090">
        </a>
        <h3 class="h2hd" id="cesectitle0100">
         Architecture constraints
        </h3>
        <p class="textfl" id="p0745">
         APIs aren't designed in a vacuum. There will always be factors that influence and constrain the architecture. Before the design process can proceed in earnest, you must therefore identify and accommodate for these factors. Christine Hofmeister and coauthors refer to this phase as global analysis (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib41" id="bib_41">
          Hofmeister et al., 2009
         </a>
         ). The term global in this respect means that the factors affect the system holistically and that as a group they are often interdependent and contradictory. These factors fall into three basic categories:
        </p>
        <div>
         <ul class="ce_list" id="olist0070">
          <li class="numlist" id="p0750">
           <a id="o0180">
           </a>
           1. Organizational factors, such as:
          </li>
          <li class="numlist">
           <ul class="ce_list" id="olist0075">
            <li class="numlist1" id="p0755">
             <a id="o0185">
             </a>
             a. Budget
            </li>
            <li class="numlist1" id="p0760">
             <a id="o0190">
             </a>
             b. Schedule
            </li>
            <li class="numlist1" id="p0765">
             <a id="o0195">
             </a>
             c. Team size and expertise
            </li>
            <li class="numlist1" id="p0770">
             <a id="o0200">
             </a>
             d. Software development process
            </li>
            <li class="numlist1" id="p0775">
             <a id="o0205">
             </a>
             e. Build vs buy decision on subsystems
            </li>
            <li class="numlist1" id="p0780">
             <a id="o0210">
             </a>
             f. Management focus (e.g., date vs feature vs quality)
            </li>
           </ul>
          </li>
          <li class="numlist" id="p0785">
           <a id="o0215">
           </a>
           2. Environmental factors, such as:
          </li>
          <li class="numlist">
           <ul class="ce_list" id="olist0080">
            <li class="numlist1" id="p0790">
             <a id="o0220">
             </a>
             a. Hardware (e.g., set-top box or mobile device)
            </li>
            <li class="numlist1" id="p0795">
             <a id="o0225">
             </a>
             b. Platform (e.g., Windows, Mac, and Linux)
            </li>
            <li class="numlist1" id="p0800">
             <a id="o0230">
             </a>
             c. Software constraints (e.g., use of other APIs)
            </li>
            <li class="numlist1" id="p0805">
             <a id="o0235">
             </a>
             d. Client/server constraints (e.g., building a Web service)
            </li>
            <li class="numlist1" id="p0810">
             <a id="o0240">
             </a>
             e. Protocol constraints (e.g., POP vs. IMAP for a mail client)
            </li>
            <li class="numlist1" id="p0815">
             <a id="o0245">
             </a>
             f. File format constraints (e.g., must support GIF and JPEG images)
            </li>
            <li class="numlist1" id="p0820">
             <a id="o0250">
             </a>
             g. Database dependencies (e.g., must connect to a remote database)
            </li>
            <li class="numlist1" id="p0825">
             <a id="o0255">
             </a>
             h. Expose versus wrap decision on subsystems
            </li>
            <li class="numlist1" id="p0830">
             <a id="o0260">
             </a>
             i. Development tools
            </li>
           </ul>
          </li>
          <li class="numlist" id="p0835">
           <a id="o0265">
           </a>
           3. Operational factors, such as:
          </li>
          <li class="numlist">
           <ul class="ce_list" id="olist0085">
            <li class="numlist1" id="p0840">
             <a id="o0270">
             </a>
             a. Performance
            </li>
            <li class="numlist1" id="p0845">
             <a id="o0275">
             </a>
             b. Memory use
            </li>
            <li class="numlist1" id="p0850">
             <a id="o0280">
             </a>
             c. Reliability
            </li>
            <li class="numlist1" id="p0855">
             <a id="o0285">
             </a>
             d. Availability
            </li>
            <li class="numlist1" id="p0860">
             <a id="o0290">
             </a>
             e. Concurrency
            </li>
            <li class="numlist1" id="p0865">
             <a id="o0295">
             </a>
             f. Customizability
            </li>
            <li class="numlist1" id="p0870">
             <a id="o0300">
             </a>
             g. Extensibility
            </li>
            <li class="numlist1" id="p0875">
             <a id="o0305">
             </a>
             h. Scriptability
            </li>
            <li class="numlist1" id="p0880">
             <a id="o0310">
             </a>
             i. Security
            </li>
            <li class="numlist1" id="p0885">
             <a id="o0315">
             </a>
             j. Internationalization
            </li>
            <li class="numlist1" id="p0890">
             <a id="o0320">
             </a>
             k. Network bandwidth
            </li>
           </ul>
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p145">
         </a>
        </p>
        <div>
         <span aria-label="145" epub:type="pagebreak" id="pagebreak_145" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0895">
         It's the job of the software architect to prioritize these factors, combined with the user constraints contained within the functional requirements, and to find the best compromises that produce a flexible and efficient design. Designing an API carefully for its intended audience can only serve to improve its usability and success. However, there's no such thing as a perfect design; it's all about trade-offs for the given set of organizational, environmental, and operational constraints. For example, if you are forced to deliver results under an aggressive schedule, then you may have to focus on a simpler design that leverages third-party APIs as much as possible and restricts the number of supported platforms.
        </p>
        <div>
         <aside aria-labelledby="b0045" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0045">
           <div class="b1textfl" id="bpar0190">
            <i>
             TIP: Architecture design is constrained by a multitude of unique organizational, environmental, and operational factors.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0900">
         Some constraints can be negotiated. For example, if one of the client's requirements places undue complexity on the system, the client may be willing to accept an alternative solution that costs less money or can be delivered sooner.
        </p>
        <p class="text" id="p0905">
         In addition to identifying the factors that will affect your initial architecture, you should assess which of these are susceptible to change during development. For example, the first version of the software may not be very extensible, but you know that you will eventually want to move to a plug-in model that lets users add their own functionality. Another common example is internationalization. You may not care about supporting more than one language at first, but later this may become a new requirement and one that can have a deep impact on the code. Your design should therefore anticipate the constraints that you reasonably expect to change in the future. You may be able to come up with a design that can support change, or if that's not feasible, then you may need to think about contingency plans. This is often referred to as design for change (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib76" id="bib_76">
          Parnas, 1979
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0050" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0050">
           <div class="b1textfl" id="bpar0195">
            <i>
             TIP: Always design for change. Change is inevitable.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0910">
         It's also worth thinking about how you can isolate your design from changes in any APIs on which your project will depend. If your use of another API is completely internal, then there's no problem. However, if you need to expose the concepts of a dependent API in your own public interface, then you should consider whether it's possible to limit
         <a id="p146">
         </a>
         <span aria-label="146" epub:type="pagebreak" id="pagebreak_146" role="doc-pagebreak">
         </span>
         the degree to which it's made visible. In some cases, this simply may not be practical. However, in other cases you may be able to provide wrappers for the dependent API so that you do not force your clients to depend upon that API directly. For example, the KDE API is built on top of the Qt library. However, KDE uses a thin wrapper over the Qt API so that users are not directly dependent on the Qt API. As a specific example, KDE offers classes such as
         <span class="inlinecode">
          KApplication
         </span>
         ,
         <span class="inlinecode">
          KObject
         </span>
         , and
         <span class="inlinecode">
          KPushButton
         </span>
         instead of exposing Qt's
         <span class="inlinecode">
          QApplication
         </span>
         ,
         <span class="inlinecode">
          QObject
         </span>
         , and
         <span class="inlinecode">
          QPushButton
         </span>
         classes directly. Wrapping dependent APIs in this way gives you an extra layer of indirection to protect against changes in a dependent API and to work around bugs or platform-specific limitations.
        </p>
        <p class="text" id="p0915">
         Finally, there are some common pitfalls to be aware of when developing an architecture. In particular, if you work at a large organization, you should be aware of Conway's law and its consequences. Conway originally defined his law as (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib20" id="bib_20">
          Conway, 1968
         </a>
         ):
        </p>
        <div>
         <div id="disp0015">
          <p class="quote" epub:type="epigraph" id="p1925" role="doc-epigraph">
           Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.
          </p>
          <p class="dispquotesrc">
           —Melvin E. Conway.
          </p>
         </div>
        </div>
        <p class="text" id="p0920">
         The implication of this law for software design is that if you work in an organization that has many separate groups that need to work together on an overall design, then the resulting design will likely be composed of parts that represent the focus areas of those separate groups. The positive side of this is that at least you have a team of engineers who will work on the problem; but the negative side is that this may not yield the best design to solve the problem. Eric S. Raymond gave an example of Conway's law, stating that “if you have four groups working on a compiler, you'll get a 4-pass compiler.” So, when working on a software architecture for a large system, it's always good to question whether the design that's been developed is the best one to solve the problem, or just a repackaging of components that the constituent teams already own. A specific concern to be aware of is that if those components were developed separately and in isolation, they may not work well together as a coherent whole or fully solve the new problem being worked on.
        </p>
       </section>
       <section>
        <a id="s0095">
        </a>
        <h3 class="h2hd" id="cesectitle0105">
         Identifying the major abstractions
        </h3>
        <p class="textfl" id="p0925">
         Once you've analyzed the requirements and constraints of the system, you are ready to start building a high-level object model. Essentially, this means identifying the major abstractions in the problem domain and decomposing these into a hierarchy of interconnected objects.
         <a href="#f0030" id="Bf0030">
          Fig. 4.5
         </a>
         presents an example of this process. It shows a top-level architecture for the OpenSceneGraph API, an open source 3D graphics tool kit for visual simulation applications (
         <a href="http://www.openscenegraph.org/">
          http://www.openscenegraph.org/
         </a>
         ).
         <a id="p147">
         </a>
        </p>
        <div>
         <span aria-label="147" epub:type="pagebreak" id="pagebreak_147" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0030">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="1372" src="../../IMAGES/B9780443222191000088/main.assets/f04-05-9780443222191.jpg" width="2400"/>
           <figcaption class="figleg">
            <a id="cap0030">
            </a>
            <a id="fspara0030">
            </a>
            <span class="fignum">
             <a href="#Bf0030">
              Figure 4.5
             </a>
            </span>
            Example top-level architecture for the OpenSceneGraph application programming interface.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0930">
         By basing the architecture on actual concepts in the problem domain, your design should remain general and robust to future changes in requirements. Recall that I listed this as the first API quality in
         <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
          Chapter 2
         </a>
         : a good API should model the problem domain. However, decomposing a problem into a set of good abstractions is not an easy task. For well-understood problems such as writing a compiler or a Web server, you can take advantage of the collective knowledge that has been distilled and published by many other designers over time. However, for new problems that have had little or no previous research applied to them, the task of inventing a good classification can be far from obvious.
        </p>
        <p class="text" id="p0935">
         This is not a problem that's unique to computer science. The classification of the biology of our planet into a logical taxonomy has been an area of debate ever since the days of Aristotle. In the 18th century, Carolus Linnaeus proposed a two-kingdom model for life, composed of vegetables and animals. This was later refined in the 19th century to include microscopic life forms. Modern advances in electron microscopy have increased the number of kingdoms to five or six. However, research in the 21st century has contested the traditional view of kingdoms and proposed an alternative supergroup model. Additionally, the topic of deciding which characteristics should be used to create classifications has received much debate. Aristotle classified animals according to their method of reproduction, the binomial system groups organisms by their morphology (similar structure or appearance), whereas Darwinian-inspired taxonomies favor classification by common descent (whether organisms have a common ancestor).
         <a id="p148">
         </a>
        </p>
        <div>
         <span aria-label="148" epub:type="pagebreak" id="pagebreak_148" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0100">
        </a>
        <h3 class="h2hd" id="cesectitle0110">
         Inventing the key objects
        </h3>
        <p class="textfl" id="p0940">
         Despite the difficulty of classifying the major abstractions in a system, I can still offer some advice on how to tackle the problem. Accordingly, here are several techniques that you can draw upon to decompose a system into a set of key objects and identify their relationship to each other (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib12">
          Booch et al., 2007
         </a>
         ):
        </p>
        <div>
         <ol id="ulist0065">
          <li class="bulllist" id="p0945">
           <a id="u0290">
           </a>
           ▪
           <b>
            Natural language.
           </b>
           Using the analogy to natural language, it's been observed that (in general) nouns tend to represent objects, verbs represent functions, and adjectives and possessive nouns represent attributes (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib14">
            Bourque et al., 2004
           </a>
           ). I can illustrate this by returning to our address book API from
           <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
            Chapter 2
           </a>
           . The real-world concepts of an address book and a person are both nouns and make sense to represent key objects in the API, whereas actions such as adding a person to the address book or adding a telephone number for a person are verbs and should be represented as function calls on the objects that they modify. However, a person's name is a possessive noun and makes more sense to be an attribute of the
           <span class="inlinecode">
            Person
           </span>
           object rather than a high-level object in its own right.
          </li>
          <li class="bulllist" id="p0950">
           <a id="u0295">
           </a>
           ▪
           <b>
            Properties.
           </b>
           This technique involves grouping objects that have similar properties or qualities. This can be done using discrete categories in which each object is unambiguously either a member or not, such as red objects versus blue objects. Or it can involve a probabilistic grouping of objects that depends upon how closely each object matches some fuzzy criterion or concept, such as whether a film is categorized as an action or romance story.
          </li>
          <li class="bulllist" id="p0955">
           <a id="u0300">
           </a>
           ▪
           <b>
            Behaviors.
           </b>
           This method groups objects by the dynamic behaviors that they share. This involves determining the set of behaviors in the system and assigning these behaviors to different parts of the system. You can then derive the set of objects by identifying the initiators and participants of these behaviors.
          </li>
          <li class="bulllist" id="p0960">
           <a id="u0305">
           </a>
           ▪
           <b>
            Prototypes.
           </b>
           In this approach, you attempt to discover more general prototypes for the objects that were initially identified. For example, a beanbag, bar stool, and recliner are all types of chair, despite having very different forms and appearance. However, you can classify each of them based upon the degree to which they exhibit affordances of a prototypical chair.
          </li>
          <li class="bulllist" id="p0965">
           <a id="u0310">
           </a>
           ▪
           <b>
            Domains (Shlaer-Mellor).
           </b>
           The Shlaer-Mellor method first partitions a system horizontally to create generic domains and then partitions these vertically by applying a separate analysis to each domain (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib86" id="bib_86">
            Shlaer and Mellor, 1988
           </a>
           ). One of the benefits of this divide-and-conquer approach is that the domains tend to form reusable concepts that can be applied to other design problems. For instance, using our earlier ATM example, a domain could be one of the following:
          </li>
          <li class="bulllist">
           <ol id="ulist0070">
            <li class="bulllist1" id="p0970">
             <a id="u0315">
             </a>
             •
             <b>
              Tangible domains
             </b>
             , such as an ATM machine or a bank note.
            </li>
            <li class="bulllist1" id="p0975">
             <a id="u0320">
             </a>
             •
             <b>
              Role domains
             </b>
             , such as an ATM user or a bank owner.
            </li>
            <li class="bulllist1" id="p0980">
             <a id="u0325">
             </a>
             •
             <b>
              Event domains
             </b>
             , such as a financial transaction.
            </li>
            <li class="bulllist1" id="p0985">
             <a id="u0330">
             </a>
             •
             <b>
              Security domains
             </b>
             , such as authentication and encryption.
             <a id="p149">
             </a>
            </li>
            <li>
             <span aria-label="149" epub:type="pagebreak" id="pagebreak_149" role="doc-pagebreak">
             </span>
            </li>
            <li class="bulllist1" id="p0990">
             <a id="u0335">
             </a>
             •
             <b>
              Interaction domains
             </b>
             , such as PIN entry or a cash withdrawal.
            </li>
            <li class="bulllist1" id="p0995">
             <a id="u0340">
             </a>
             •
             <b>
              Logging domains
             </b>
             , for the system to log information.
            </li>
           </ol>
          </li>
          <li class="bulllist" id="p1000">
           <a id="u0345">
           </a>
           ▪
           <b>
            Domains (Neighbors).
           </b>
           James Neighbors coined the term domain analysis as the technique of uncovering classes and objects that are shared by all applications in the problem domain (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib74" id="bib_74">
            Neighbors, 1980
           </a>
           ). This is done by analyzing related systems in the problem domain to discover areas of commonality and distinctiveness, such as identifying the common elements in all bug tracking systems or general features of all genealogy programs.
          </li>
          <li class="bulllist" id="p1005">
           <a id="u0350">
           </a>
           ▪
           <b>
            Domains (Evans).
           </b>
           A related issue to Neighbors' domain analysis is the term domain-driven design. This was introduced by Eric Evans and seeks to produce designs for complex systems using an evolving model of the core business concepts (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib27" id="bib_27">
            Evans, 2003
           </a>
           ).
          </li>
         </ol>
        </div>
        <div>
         <aside aria-labelledby="b0055" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0055">
           <div class="b1textfl" id="bpar0200">
            <i>
             TIP: Identifying the key objects for an API is hard. Try looking at the problem from different perspectives and keep iterating and refining your model.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1010">
         Most of these techniques work best when you have a well-organized and structured set of use cases from which to work. For example, use cases are normally constructed as sentences where a thing performs some action, often to or on another thing. You can therefore use these as input for a simple natural language analysis by taking the steps of each use case and identifying the subject or object nouns and use these to develop an initial candidate list of objects.
        </p>
        <p class="text" id="p1015">
         Each of these techniques can also involve different degrees of formal methods. For example, natural language analysis it not a very rigorous technique and is often discouraged by proponents of formal design methodologies. That's because natural language is intrinsically ambiguous and may express important concepts of the problem domain imprecisely or neglect significant architectural features. You should therefore be wary of naively translating all nouns in your use cases to key objects. At best, you should treat the result of this analysis as an initial candidate list from which to apply further careful analysis and refinement (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib2">
          Alexander, 2003
         </a>
         ). This refinement can involve identifying any gaps in the model, considering whether there are more general concepts that can be extracted from the list, and attempting to classify similar concepts.
        </p>
        <p class="text" id="p1020">
         In contrast, there are several formal techniques for producing a software design, including textual and graphical notations. One particularly widespread technique is UML (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib13" id="bib_13">
          Booch et al., 2005
         </a>
         ). UML can be used to specify and maintain a software design visually, using a set of graphical diagrams. For instance, UML 2.3 includes 14 distinct types of diagrams to represent the various structural and behavioral aspects of a design (
         <a href="#f0035" id="Bf0035">
          Fig. 4.6
         </a>
         ). As a specific example, UML sequence diagrams portray the sequence of
         <a id="p150">
         </a>
         <span aria-label="150" epub:type="pagebreak" id="pagebreak_150" role="doc-pagebreak">
         </span>
         function calls between objects. These can be used during the analysis phase to represent use cases graphically. Then, during the design phase, the architect can use these formal diagrams to explore the object interactions within the system and flesh out the top-level object model.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0035">
          <img alt="image" height="2190" src="../../IMAGES/B9780443222191000088/main.assets/f04-06-9780443222191.jpg" width="1822"/>
          <figcaption class="figleg">
           <a id="cap0035">
           </a>
           <a id="fspara0035">
           </a>
           <span class="fignum">
            <a href="#Bf0035">
             Figure 4.6
            </a>
           </span>
           The 14 diagram types of Universal Modeling Language (UML) 2.3.
          </figcaption>
         </figure>
        </div>
        <p class="text" id="p1025">
         Formal design notations can also be used to generate actual code. This ranges from the simple translation of class diagrams into their direct source code equivalents to the more comprehensive notion of an executable architecture. The latter is a sufficiently
         <a id="p151">
         </a>
         <span aria-label="151" epub:type="pagebreak" id="pagebreak_151" role="doc-pagebreak">
         </span>
         detailed description of an architecture that can be translated into executable software and run on a target platform. For example, Shlaer-Mellor notation was eventually evolved into a profile of UML called Executable UML (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib63" id="bib_63">
          Mellor and Balcer, 2002
         </a>
         ), which itself became a cornerstone of Model Driven Architecture. The basic principle behind this approach is that a model compiler takes several executable UML models, each of which defines a different cross-cutting concern or domain, and combines these to produce high-level executable code. Proponents of executable architectures note the two-language problem that this entails: having a modeling language (e.g., UML) that gets translated into a separate programming language (e.g., C++, C#, or Java). Many of these proponents therefore posit the need for a single language that can bridge both concerns.
        </p>
       </section>
       <section>
        <a id="s0105">
        </a>
        <h3 class="h2hd" id="cesectitle0115">
         Architectural patterns
        </h3>
        <p class="textfl" id="p1030">
         In
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         , I covered various design patterns that be used to solve recurring problems in software design, such as Singleton, Factory Method, and Observer. These tend to provide solutions that can be implemented at the component level. However, there is a class of software patterns called architectural patterns that describe larger-scale structures and organizations for entire systems. As such, some of these solutions may be useful to you when you are building an API that maps well to a particular architectural pattern. The following list classifies several of the more popular architectural patterns (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib14">
          Bourque et al., 2004
         </a>
         ):
        </p>
        <div>
         <ol id="ulist0075">
          <li class="bulllist" id="p1035">
           <a id="u0355">
           </a>
           ▪
           <b>
            Structural patterns
           </b>
           : Layers, Pipes and Filters, and Blackboard
          </li>
          <li class="bulllist" id="p1040">
           <a id="u0360">
           </a>
           ▪
           <b>
            Interactive systems
           </b>
           : Model-View-Controller (MVC), Model-View-Presenter, and Presentation-Abstraction-Control
          </li>
          <li class="bulllist" id="p1045">
           <a id="u0365">
           </a>
           ▪
           <b>
            Distributed systems
           </b>
           : Client/Server, Three-Tier, Peer-to-Peer, and Broker
          </li>
          <li class="bulllist" id="p1050">
           <a id="u0370">
           </a>
           ▪
           <b>
            Adaptable systems
           </b>
           : Microkernel and Reflection
          </li>
         </ol>
        </div>
        <p class="text" id="p1055">
         Many of these architectural patterns present elegant designs to avoid dependency problems between different parts of your system, such as the MVC pattern that I discussed in
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         . At this point, it's worth noting that another important view of a system's architecture is the physical view of library files and their dependencies. I presented an example of this view back in
         <a href="../B9780443222191000234/CH0001_1-23_B9780443222191000234.xhtml">
          Fig. 1.3
         </a>
         , where I showed the layers of APIs that make up a complex end-user application. Even within a single API you'll likely have different layers of physical architecture, such as those listed subsequently and illustrated in
         <a href="#f0040" id="Bf0040">
          Fig. 4.7
         </a>
         :
        </p>
        <div>
         <ul class="ce_list" id="olist0090">
          <li class="numlist" id="p1060">
           <a id="o0325">
           </a>
           1. API-neutral low-level routines, such as string manipulation routines, math functions, or your threading model
          </li>
          <li class="numlist" id="p1065">
           <a id="o0330">
           </a>
           2. Core business logic that implements the primary function of your API
          </li>
          <li class="numlist" id="p1070">
           <a id="o0335">
           </a>
           3. Plug-in or scripting APIs to allow users to extend the base functionality of the API
          </li>
          <li class="numlist" id="p1075">
           <a id="o0340">
           </a>
           4. Convenience APIs built on top of the core API functionality
          </li>
          <li class="numlist" id="p1080">
           <a id="o0345">
           </a>
           5. A presentation layer to provide a visual display of your API results
          </li>
         </ul>
        </div>
        <p class="text" id="p1085">
         In this case, it's important to impose a strict dependency hierarchy on the different architectural layers of your system; otherwise you will end up with cyclic dependencies
         <a id="p152">
         </a>
         <span aria-label="152" epub:type="pagebreak" id="pagebreak_152" role="doc-pagebreak">
         </span>
         between layers (
         <a href="#f0040">
          Fig. 4.7
         </a>
         ). The same is true for individual components within those layers. The general observation is that lower-level components should not depend upon higher-level components of your architecture. For example, your core business logic cannot depend upon your convenience API because this would introduce a cycle between the two (if your convenience API also calls down into the core business logic). Referring back to the MVC architectural pattern, you will note that View depends upon Model, but not vice versa. David L. Parnas referred to this concept as loop-free hierarchies (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib76">
          Parnas, 1979
         </a>
         ).
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0040">
          <img alt="image" height="1417" src="../../IMAGES/B9780443222191000088/main.assets/f04-07-9780443222191.jpg" width="1860"/>
          <figcaption class="figleg">
           <a id="cap0040">
           </a>
           <a id="fspara0040">
           </a>
           <span class="fignum">
            <a href="#Bf0040">
             Figure 4.7
            </a>
           </span>
           Example architectural layers of an application programming interface (API) showing a cyclic, or circular, dependency between two components.
          </figcaption>
         </figure>
        </div>
        <div>
         <aside aria-labelledby="b0060" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0060">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0015">
            <i>
             SIDEBAR: Menvshared
            </i>
           </div>
           <div class="b1textfl" id="bpar0205">
            <i>
             During my early years at Pixar, we got into a situation where we had many cyclic dependencies between the core suite of animation libraries. These dependencies crept slowly into the system as we worked to meet many tight production deadlines.
            </i>
           </div>
           <div class="b1text" id="bpar0210">
            <i>
             In order to allow the system to continue to compile, we resorted to linking all of this interdependent code into a single huge shared library, called
            </i>
            <span class="inlinecode">
             <i>
              libmenvshared.so
             </i>
            </span>
            <i>
             (pronounced men-vee-shared). This meant that any changes to one of the libraries in this shared library would require the entire shared library to be rebuilt, a process that could take at least 5–10
             <span title='hsp="0.25"'>
             </span>
             min.
            </i>
           </div>
           <div class="b1text" id="bpar0215">
            <i>
             As you can imagine, this became a significant bottleneck to the development team's velocity. In fact, the massive size of the menvshared library even caused linker crashes when we tried porting our code to another platform.
            </i>
           </div>
           <div class="b1text" id="bpar0220">
            <i>
             Thankfully, a brave few engineers were eventually able to tackle this problem, and over many weeks we gradually teased apart the dependencies to finally get rid of menvshared.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p153">
         </a>
        </p>
        <div>
         <span aria-label="153" epub:type="pagebreak" id="pagebreak_153" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1090">
         Cyclic dependencies are bad for many reasons. For example, they mean that you cannot test each component independently and you cannot reuse one component without also pulling in the other. Basically, it's necessary to understand both components to understand either one (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52" id="bib_52">
          Lakos, 1996
         </a>
         ). This can also affect the speed of your development if you're forced to merge several components into one big über-component, as described in the accompanying sidebar. In
         <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
          Chapter 2
         </a>
         I presented various techniques to decouple dependencies, such as callbacks, observers, and notification systems. Fundamentally, an API should be an acyclic hierarchy of logically related components.
        </p>
        <div>
         <aside aria-labelledby="b0065" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0065">
           <div class="b1textfl" id="bpar0225">
            <i>
             TIP: Avoid cyclic dependencies between components of your API.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0110">
        </a>
        <h3 class="h2hd" id="cesectitle0120">
         Communicating the architecture
        </h3>
        <p class="textfl" id="p1095">
         Once an architecture has been developed, it can be documented in various ways. This can range from simple drawings or wiki pages to various formal methods that provide modeling notations for architectures, such as UML or the set of Architecture Description Languages (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib62" id="bib_62">
          Medvidovic and Taylor, 2000
         </a>
         ).
        </p>
        <p class="text" id="p1100">
         Whichever approach you adopt, documenting the architecture is an important factor in communicating the design to engineers. Doing so gives them more information to implement the system according to your vision and ensures that future changes continue to preserve the intent and integrity of the architecture. This is particularly important if the development team is large or geographically distributed.
        </p>
        <p class="text" id="p1105">
         One of the elements you should include in your architecture documentation is a rationale for the overall design: that is, which alternative designs and trade-offs were considered and why the final structure was judged to be superior. This design rationale can be very important for the long-term maintenance of the design and to save future designers from revisiting the same dead ends that you did. In fact, Martin Robillard notes that users of an API often find it difficult to learn and use an API if they don't understand its high-level architecture and design intents (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib83" id="bib_83">
          Robillard, 2009
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0070" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0070">
           <div class="b1textfl" id="bpar0230">
            <i>
             TIP: Describe the high-level architecture and design rationale for your API in the accompanying user documentation.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1110">
         Communication also allows for peer review of the design and for feedback and improvements to be received before the API is released. In fact, implementing design
         <a id="p154">
         </a>
         <span aria-label="154" epub:type="pagebreak" id="pagebreak_154" role="doc-pagebreak">
         </span>
         reviews early in the process to facilitate communication among architects, developers, and clients will help you to produce a more comprehensive and durable design. If the API architect also writes some of the code, then this can be an excellent way to communicate design principles through practical hands-on contribution.
        </p>
        <p class="text" id="p1115">
         Even though modern agile development methods deemphasize document-heavy processes because the design documents are frequently out of date, there is still a place for providing as much documentation about the system architecture as necessary, but no more. Augmenting any documentation with direct communication can be even more productive. This allows for a dialogue between the designer and implementer and can avoid misunderstandings that can happen when reading specifications. Ultimately, it's the jobs of the architect to be a passionate communicator, to be available to answer questions from engineers, and to ensure that the most efficient channels are used to keep architectural communication constantly stimulated (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib28" id="bib_28">
          Faber, 2010
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0075" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0075">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0020">
            <i>
             SIDEBAR: Pitch your story
            </i>
           </div>
           <div class="b1textfl" id="bpar0235">
            <i>
             While working in the R&amp;D department at Pixar, our task as software engineers and managers was to produce powerful yet easy-to-use programs for highly creative artists. We therefore endeavored to communicate our software plans and designs using analogies and terminology familiar to filmmakers.
            </i>
           </div>
           <div class="b1text" id="bpar0240">
            <i>
             For example, our design team was referred to as our Story department, a reference to the department in a film studio that is responsible for the initial planning and structuring of a movie. Our software schedules and system designs were then presented to our production users on standard storyboards. These are physical wood boards with a regular grid of 4×6-inch hand-drawn index cards pinned to them. These boards were presented to artists in a story pitch format, to use filmmaking terminology, thus allowing us to present our material in a meeting style and structure that was familiar to our users. Finally, we also produced several story reels, which were digital movies in which hand-drawn examples of the proposed applications were animated and narrated to show end-user workflows.
            </i>
           </div>
           <div class="b1text" id="bpar0245">
            <i>
             This specific approach worked well in our case to communicate our software plans with talented but nontechnical in-house users. Of course, this format will not be appropriate for all other software projects. However, the central tenet is that you should think deeply about how you can communicate your designs in the most natural and intuitive manner for your users.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
      </section>
      <section>
       <a id="s0115">
       </a>
       <h2 class="h1hd" id="cesectitle0125">
        Class design
       </h2>
       <p class="textfl" id="p1120">
        With a high-level architecture in place, you can start refining the design to describe specific C++ classes and their relationship to other classes. This is the detailed design, in contrast to the top-level architecture design. It involves identifying actual classes that clients will use, how these classes relate to each other, and their major functions and attributes. For sufficiently large systems, this can also involve describing how classes are organized into subsystems.
       </p>
       <p class="text" id="p1125">
        Designing every single class in your API would be overkill for anything but the most trivial system. Instead, you should focus on the major classes that define the most
        <a id="p155">
        </a>
        <span aria-label="155" epub:type="pagebreak" id="pagebreak_155" role="doc-pagebreak">
        </span>
        important functionality. A good rule of thumb is the so-called 80/20 rule (i.e., you should concentrate on 20% of the classes that define 80% of your system's behavior) (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56">
         McConnell, 2004
        </a>
        ).
       </p>
       <div>
        <aside aria-labelledby="b0080" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0080">
          <div class="b1textfl" id="bpar0250">
           <i>
            TIP: Focus on designing 20% of the classes that define 80% of your API's functionality.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <section>
        <a id="s0120">
        </a>
        <h3 class="h2hd" id="cesectitle0130">
         Object-oriented concepts
        </h3>
        <p class="textfl" id="p1130">
         Before I talk more about the details of object-oriented design, let's take a moment to review some of the major object-oriented principles and their representation in C++. It is likely that you're already very familiar with these concepts, but let's briefly summarize them here in the interests of completeness and to ensure that we're on the same page:
        </p>
        <div>
         <ol id="ulist0080">
          <li class="bulllist" id="p1135">
           <a id="u0375">
           </a>
           ▪
           <b>
            Class
           </b>
           : A class is the abstract description, or specification, of an object. It defines the data members and member functions of the object.
          </li>
          <li class="bulllist" id="p1140">
           <a id="u0380">
           </a>
           ▪
           <b>
            Object.
           </b>
           An object is an entity that has state, behavior, and identity (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib12">
            Booch et al., 2007
           </a>
           ). It's an instance of a concrete class created at run time using the
           <span class="inlinecode">
            new
           </span>
           operator in C++. A concrete class is one that is fully specified (e.g., it has no undefined pure virtual member functions).
          </li>
          <li class="bulllist" id="p1145">
           <a id="u0385">
           </a>
           ▪
           <b>
            Encapsulation
           </b>
           : This concept describes the compartmentalization of data and methods as a single object with access control specifications such as public, protected, and private to support hiding implementation details.
          </li>
          <li class="bulllist" id="p1150">
           <a id="u0390">
           </a>
           ▪
           <b>
            Inheritance
           </b>
           : This allows for objects to inherit attributes and behaviors from a parent class, and to introduce their own additional data members and methods. A class that's defined in this way is said to be a derived (or sub) class, of the parent (or base) class. A subclass can override any base class method, although normally you want to do this only when that base class method is declared to be virtual. A pure virtual method (indicated by appending its declaration with “=
           <span title='hsp="0.25"'>
           </span>
           0”) is one where a subclass must provide an implementation of the method for it to be concrete (i.e., to allow instances of it to be created). C++ supports multiple inheritance, meaning that a subclass can inherit from more than one base class. Public inheritance is generally referred to as an is-a relationship between two objects, whereas private inheritance represents a was-a relationship (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
            Lakos, 1996
           </a>
           ).
          </li>
          <li class="bulllist" id="p1155">
           <a id="u0395">
           </a>
           ▪
           <b>
            Composition
           </b>
           : This is an alternative technique to inheritance in which one or more simple objects are combined to create more complex ones. This is done by declaring the simpler objects as member variables inside the more complex object. The has-a relationship is used to describe the case in which a class holds an instance of another type. The holds-a relationship describes a class holding a pointer or reference to the other type.
          </li>
          <li class="bulllist" id="p1160">
           <a id="u0400">
           </a>
           ▪
           <b>
            Polymorphism
           </b>
           : This is the ability of one type to appear as, and to be used like, another type. This allows objects of different types to be used interchangeably if
           <a id="p156">
           </a>
           <span aria-label="156" epub:type="pagebreak" id="pagebreak_156" role="doc-pagebreak">
           </span>
           they conform to the same interface. This is possible because the C++ compiler can delay checking the type of an object until run time, a technique known as late or dynamic binding. The use of templates in C++ can also be used to provide static (compile-time) polymorphism.
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0125">
        </a>
        <h3 class="h2hd" id="cesectitle0135">
         Class design options
        </h3>
        <p class="textfl" id="p1165">
         For the creation of a class, there are many factors to be considered. As Scott Meyers notes, creating a new class involves defining a new type. You should therefore treat class design as type design and approach the task with the same thoughtfulness and attention that the designers of C++ put into the built-in types of the language (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib70" id="bib_70">
          Meyers, 2005
         </a>
         ).
        </p>
        <p class="text" id="p1170">
         Here I list a few of the major questions that you should ask yourself when you embark upon designing a new class. This is not meant to be an exhaustive list, but it should provide a good starting point to help you define the major constraints on your design:
        </p>
        <div>
         <ol id="ulist0085">
          <li class="bulllist" id="p1175">
           <a id="u0405">
           </a>
           ▪
           <b>
            Use of inheritance.
           </b>
           Is it appropriate to add the class to an existing inheritance hierarchy? Should you use public or private inheritance? Should you support multiple inheritance? This affects whether you need to think about which member functions should be virtual.
          </li>
          <li class="bulllist" id="p1180">
           <a id="u0410">
           </a>
           ▪
           <b>
            Use of composition.
           </b>
           Is it more appropriate to hold a related object as a data member rather than inheriting from it directly?
          </li>
          <li class="bulllist" id="p1185">
           <a id="u0415">
           </a>
           ▪
           <b>
            Use of abstract interfaces.
           </b>
           Is the class meant to be an abstract base class, in which subclasses must override various pure virtual member functions?
          </li>
          <li class="bulllist" id="p1190">
           <a id="u0420">
           </a>
           ▪
           <b>
            Use of standard design patterns.
           </b>
           Can you employ a known design pattern to the class design? Doing so lets you benefit from well-thought-out and refined design methodologies and makes your design easier to use by other engineers.
          </li>
          <li class="bulllist" id="p1195">
           <a id="u0425">
           </a>
           ▪
           <b>
            Initialization and destruction model.
           </b>
           Will clients use
           <span class="inlinecode">
            new
           </span>
           and
           <span class="inlinecode">
            delete
           </span>
           or will you use a factory method? Will you override
           <span class="inlinecode">
            new
           </span>
           and
           <span class="inlinecode">
            delete
           </span>
           for your class to customize the memory allocation behavior? Will you use smart pointers?
          </li>
          <li class="bulllist" id="p1200">
           <a id="u0430">
           </a>
           ▪
           <b>
            Defining a copy constructor and assignment operator.
           </b>
           If the class allocates dynamic memory, you need both of these, as well as a destructor. This is called the Rule of Three, which I'll cover in the next chapter on C++ Usage. This will affect how your objects will be copied and passed by value.
          </li>
          <li class="bulllist" id="p1205">
           <a id="u0435">
           </a>
           ▪
           <b>
            Use of templates.
           </b>
           Does your class define a family of types rather than a single type? If so, then you may need to consider the use of templates to generalize your design.
          </li>
          <li class="bulllist" id="p1210">
           <a id="u0440">
           </a>
           ▪
           <b>
            Use of const and explicit.
           </b>
           Define arguments, return results, and methods as
           <span class="inlinecode">
            const
           </span>
           wherever you can. Use the
           <span class="inlinecode">
            explicit
           </span>
           keyword to avoid unexpected type conversions for single-parameter constructors.
          </li>
          <li class="bulllist" id="p1215">
           <a id="u0445">
           </a>
           ▪
           <b>
            Defining operators.
           </b>
           Define any operators that you need for your class, such as
           <span class="inlinecode">
            +
           </span>
           ,
           <span class="inlinecode">
            ∗=
           </span>
           ,
           <span class="inlinecode">
            []
           </span>
           ,
           <span title='hsp="0.25"'>
           </span>
           =
           <span title='hsp="0.25"'>
           </span>
           <span class="inlinecode">
            =
           </span>
           , or
           <span class="inlinecode">
            &lt;&lt;
           </span>
           .
           <a id="p157">
           </a>
          </li>
          <li>
           <span aria-label="157" epub:type="pagebreak" id="pagebreak_157" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p1220">
           <a id="u0450">
           </a>
           ▪
           <b>
            Defining type coercions.
           </b>
           Consider whether you want your class to be automatically coercible to different types and declare the appropriate conversion operators.
          </li>
          <li class="bulllist" id="p1225">
           <a id="u0455">
           </a>
           ▪
           <b>
            Use of friends.
           </b>
           Friends breach the encapsulation of your class and are generally an indication of bad design. Use them as a last resort.
          </li>
          <li class="bulllist" id="p1230">
           <a id="u0460">
           </a>
           ▪
           <b>
            Nonfunctional constraints.
           </b>
           Issues such as performance and memory use can place constraints on the design of your classes.
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0130">
        </a>
        <h3 class="h2hd" id="cesectitle0140">
         The SOLID principles
        </h3>
        <p class="textfl" id="p1235">
         There is a popular acronym used in object-oriented design, called SOLID. This provides a good set of key design principles to consider when building an object model for any system (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib29">
          Feathers, 2004
         </a>
         ). I cover many of the aspects of SOLID throughout this book, but I'll summarize the core principles here:
        </p>
        <div>
         <ol id="ulist0090">
          <li class="bulllist" id="p1240">
           <a id="u0465">
           </a>
           • S = Single responsibility principle. This states that there should only ever be one reason for a class to change (i.e., an object should have only one responsibility). I mentioned this principle earlier in the Qualities chapter when talking about the Don't Repeat Yourself (DRY) principle.
          </li>
          <li class="bulllist" id="p1245">
           <a id="u0470">
           </a>
           • O = Open/closed principle. This states that objects should be open for extension but closed for modification (i.e., that it should be possible to modify the behavior of a class without changing its source code). I'll discuss this principle later in this chapter.
          </li>
          <li class="bulllist" id="p1250">
           <a id="u0475">
           </a>
           • L
           <span title='hsp="0.25"'>
           </span>
           =
           <span title='hsp="0.25"'>
           </span>
           Liskov substitution principle (LSP). This states that an object should be replaceable with a subclass of that object without changing any behavior. I'll also discuss this principle later in this chapter.
          </li>
          <li class="bulllist" id="p1255">
           <a id="u0480">
           </a>
           • I = Interface segregation principle. This states that clients should not have to depend on interfaces they don't use. Essentially, you should split large monolithic interfaces into smaller more specific ones. The goal of this principle is to reduce coupling, which I covered in detail in the earlier chapter on Qualities.
          </li>
          <li class="bulllist" id="p1260">
           <a id="u0485">
           </a>
           • D
           <span title='hsp="0.25"'>
           </span>
           =
           <span title='hsp="0.25"'>
           </span>
           Dependency inversion principle. This states that clients should depend on abstractions, not concrete implementations. The goal of this principle is also to reduce coupling, by having software components depend on abstract interfaces. I covered aspects of loose coupling in the chapter on Qualities and abstract interfaces in the chapter on Patterns.
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0135">
        </a>
        <h3 class="h2hd" id="cesectitle0145">
         Using inheritance
        </h3>
        <p class="textfl" id="p1265">
         By far the biggest design decision that you'll face when designing your classes is when and how to use inheritance. For example, should you use public inheritance, private inheritance, or composition to associate related classes in your API? Because inheritance is such an important topic, and one that is often misused or overused, I will focus on this part of class design over the next few sections. Let's begin with some general design recommendations:
         <a id="p158">
         </a>
         <span aria-label="158" epub:type="pagebreak" id="pagebreak_158" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <ol id="ulist0095">
          <li class="bulllist" id="p1270">
           <a id="u0490">
           </a>
           ▪
           <b>
            Design for inheritance or prohibit it.
           </b>
           The most important decision you can make is to decide whether a class should support subclasses. If it should, then you must think deeply about which methods should be declared as
           <span class="inlinecode">
            virtual
           </span>
           and document their behavior. If the class should not support inheritance, a good way to convey this is to declare a nonvirtual destructor.
          </li>
          <li class="bulllist" id="p1275">
           <a id="u0495">
           </a>
           ▪
           <b>
            Use inheritance only where appropriate.
           </b>
           Deciding whether a class should inherit from another class is a difficult design task. In fact, this is perhaps the most difficult part of software design. I will present some guidance on this topic in the next section when I talk about the LSP.
          </li>
          <li class="bulllist" id="p1280">
           <a id="u0500">
           </a>
           ▪
           <b>
            Avoid deep inheritance trees.
           </b>
           Deep inheritance hierarchies increase complexity and invariably result in designs that are difficult to understand and software that's more prone to failure. The absolute limit of hierarchy depth is obviously subjective, but any more than two or three levels is already getting too complex (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56">
            McConnell, 2004
           </a>
           ).
          </li>
          <li class="bulllist" id="p1285">
           <a id="u0505">
           </a>
           ▪
           <b>
            Use pure virtual member functions to force subclasses to provide an implementation.
           </b>
           A virtual member function can be used to define an interface that includes an optional implementation, whereas a pure virtual member function is used to define only an interface, with no implementation (although it is possible to provide a fallback implementation for a pure virtual method). Of course, a nonvirtual method is used to provide behavior that cannot be changed by subclasses.
          </li>
          <li class="bulllist" id="p1290">
           <a id="u0510">
           </a>
           ▪
           <b>
            Don't add new pure virtual functions to an existing interface.
           </b>
           You should certainly design appropriate abstract interfaces with pure virtual member functions. However, be aware that after you release this interface to users, if you then add a new pure virtual method to the interface, you will break all of your clients' code. That's because client classes that inherit from the abstract interface will no longer be concrete until an implementation for the new pure virtual function is defined.
          </li>
          <li class="bulllist" id="p1295">
           <a id="u0515">
           </a>
           ▪
           <b>
            Don't overdesign.
           </b>
           In
           <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
            Chapter 2, I
           </a>
           stated that a good API should be minimally complete. In other words, you should resist the temptation to add extra levels of abstraction that are currently unnecessary. For example, if you have a base class that's inherited by only a single class in your entire API, this is an indication that you've overdesigned the solution for the current needs of the system.
          </li>
         </ol>
        </div>
        <div>
         <aside aria-labelledby="b0085" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0085">
           <div class="b1textfl" id="bpar0255">
            <i>
             TIP: Avoid deep inheritance hierarchies.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1300">
         Another important consideration is whether to use multiple inheritance (i.e., whether you will design classes that inherit from more than one base class). Bjarne
         <a id="p159">
         </a>
         <span aria-label="159" epub:type="pagebreak" id="pagebreak_159" role="doc-pagebreak">
         </span>
         Stroustrup argued for the addition of multiple inheritance to C++ using the example of a
         <span class="inlinecode">
          TemporarySecretary
         </span>
         class, where this inherits from both a
         <span class="inlinecode">
          Secretary
         </span>
         and a
         <span class="inlinecode">
          Temporary
         </span>
         class (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib3" id="bib_3">
          Alexandrescu, 2001
         </a>
         ). However, opinion is divided in the C++ community on whether multiple inheritance is a good thing. On the one hand, it offers the flexibility to define composite relationships such as the
         <span class="inlinecode">
          TemporarySecretary
         </span>
         example earlier. However, this can come at the cost of subtle semantics and ambiguities, such as the need to use virtual inheritance to deal with the diamond problem, in which a class inherits ambiguously from two or more base classes that themselves inherit from a single common base class.
        </p>
        <p class="text" id="p1305">
         Most languages that allow inheriting from only a single base class still support inheriting from multiple, more constrained types. For example, Java lets you inherit from multiple interface classes, and Ruby lets you inherit from multiple mixins. These are classes that let you inherit an interface (and implementation in the case of a mixin); however, they cannot be instantiated on their own. Similarly, the Swift programming language allows a class to inherit only from a single base class, but a class can conform to multiple protocols, similar to the concept of an interface.
        </p>
        <p class="text" id="p1310">
         Multiple inheritance can be a powerful tool if used correctly (see the C++ Standard Library iostreams classes for a good example). However, in the interest of robust and easy-to-use interfaces, I generally concur with Steve McConnell, who recommends that you should avoid the use of multiple inheritance, except to use abstract interfaces or mixin classes (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56">
          McConnell, 2004
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0090" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0090">
           <div class="b1textfl" id="bpar0260">
            <i>
             TIP: Avoid multiple inheritance, except for interfaces and mixin classes.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1315">
         As a point of interest, the C++11 specification introduced several improvements relating to inheritance. Of relevance here is the ability to explicitly specify your intent to override or hide a virtual method from a base class. This is done using the
         <span class="inlinecode">
          [[override]]
         </span>
         and
         <span class="inlinecode">
          [[hiding]]
         </span>
         attributes, respectively. This functionality is extremely helpful to avoid mistakes such as misspelling the name of a virtual method in a derived class.
        </p>
       </section>
       <section>
        <a id="s0140">
        </a>
        <h3 class="h2hd" id="cesectitle0150">
         Liskov substitution principle
        </h3>
        <p class="textfl" id="p1320">
         This principle, introduced by Barbara Liskov in 1987, provides guidance on whether a class should be designed as a subclass of another class (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib55" id="bib_55">
          Liskov and Zilles, 1974
         </a>
         ). The LSP states that if S is a subclass of T, then objects of type T can be replaced by objects of type S without any change in behavior.
        </p>
        <p class="text" id="p1325">
         At a first glance, this may seem to be a simple restatement of the is-a inheritance relationship, where a class S may be considered a subtype of T if S is a more specific kind of T. However, the LSP is a more restrictive definition than is-a.
         <a id="p160">
         </a>
        </p>
        <div>
         <span aria-label="160" epub:type="pagebreak" id="pagebreak_160" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1330">
         Let's demonstrate this with the classic example of an ellipse shape type:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="892" src="../../IMAGES/B9780443222191000088/main.assets/u04-01-9780443222191.jpg" width="1318"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1335">
         You then decide to add support for a circle class. From a mathematical perspective, a circle is a more specific form of an ellipse, in which the two axes are constrained to be equal. It is therefore tempting to declare a
         <span class="inlinecode">
          Sphere
         </span>
         class to be a subclass of
         <span class="inlinecode">
          Ellipse
         </span>
         . For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000088/main.assets/u04-02-9780443222191.jpg" width="1005"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1340">
         The implementation of
         <span class="inlinecode">
          SetRadius()
         </span>
         can then set the major and minor radii of the underlying ellipse to the same value, to enforce the properties of a circle:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000088/main.assets/u04-03-9780443222191.jpg" width="1073"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1345">
         However, this poses a few problems. The most obvious is that
         <span class="inlinecode">
          Sphere
         </span>
         will also inherit and expose the
         <span class="inlinecode">
          SetMajorRadius()
         </span>
         and
         <span class="inlinecode">
          SetMinorRadius()
         </span>
         methods of
         <span class="inlinecode">
          Ellipse
         </span>
         . These could be used to break the self-consistency of our sphere by letting users change one radius without also changing the other. You could deal with this by overriding the
         <span class="inlinecode">
          SetMajorRadius()
         </span>
         and
         <span class="inlinecode">
          SetMinorRadius()
         </span>
         methods so that each sets both the major and minor radii. However, this poses several issues. First, you must go back and declare
         <span class="inlinecode">
          Ellipse::SetMajorRadius()
         </span>
         and
         <span class="inlinecode">
          Ellipse::SetMinorRadius()
         </span>
         to be virtual, so that you can override them in the
         <span class="inlinecode">
          Circle
         </span>
         class. This should alert you that you're doing something
         <a id="p161">
         </a>
         <span aria-label="161" epub:type="pagebreak" id="pagebreak_161" role="doc-pagebreak">
         </span>
         wrong. Second, you have now created a nonorthogonal API: changing one property has the side effect of changing another property. Third, you have broken the LSP because you cannot replace uses of
         <span class="inlinecode">
          Ellipse
         </span>
         with
         <span class="inlinecode">
          Sphere
         </span>
         without breaking behavior, as the following code demonstrates:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0060">
           <img alt="image" height="833" src="../../IMAGES/B9780443222191000088/main.assets/u04-04-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1350">
         The problem resolves to the fact that you've changed the behavior of functions inherited from the base class.
        </p>
        <p class="text" id="p1355">
         So, if you shouldn't use public inheritance to model a sphere as a kind of ellipse, how should you represent it? There are two main ways that you can correctly build your
         <span class="inlinecode">
          Sphere
         </span>
         class upon the functionality of the
         <span class="inlinecode">
          Ellipse
         </span>
         class: private inheritance and composition.
        </p>
        <div>
         <aside aria-labelledby="b0095" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0095">
           <div class="b1textfl" id="bpar0265">
            <i>
             TIP: The LSP states that it should always be possible to substitute a base class for a derived class without any change in behavior.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <section>
         <a id="s0145">
         </a>
         <h4 class="h3hd" id="cesectitle0155">
          Private inheritance
         </h4>
         <p class="textfl" id="p1360">
          Private inheritance lets you inherit the functionality, but not the public interface, of another class. In essence, all of the public members of the base class become private members of the derived class. This is referred to as a was-a relationship, in contrast to the is-a relationship of public inheritance. For example, you can redefine your
          <span class="inlinecode">
           Sphere
          </span>
          class to inherit privately from
          <span class="inlinecode">
           Ellipse
          </span>
          as:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0065">
            <img alt="image" height="545" src="../../IMAGES/B9780443222191000088/main.assets/u04-05-9780443222191.jpg" width="1040"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1365">
          In this case,
          <span class="inlinecode">
           Sphere
          </span>
          does not expose any of the member functions of
          <span class="inlinecode">
           Ellipse
          </span>
          (i.e., there is no public
          <span class="inlinecode">
           Sphere::SetMajorRadius()
          </span>
          method). This solution therefore does not suffer
          <a id="p162">
          </a>
          <span aria-label="162" epub:type="pagebreak" id="pagebreak_162" role="doc-pagebreak">
          </span>
          from the same problems as the public inheritance approach I discussed earlier. In fact, objects of type
          <span class="inlinecode">
           Sphere
          </span>
          cannot be passed to code that accepts an
          <span class="inlinecode">
           Ellipse
          </span>
          because the
          <span class="inlinecode">
           Ellipse
          </span>
          base type is not publicly accessible.
         </p>
         <p class="text" id="p1370">
          Note that if you do want to expose a public or protected method of
          <span class="inlinecode">
           Ellipse
          </span>
          in
          <span class="inlinecode">
           Sphere,
          </span>
          then you can do this:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0070">
            <img alt="image" height="777" src="../../IMAGES/B9780443222191000088/main.assets/u04-06-9780443222191.jpg" width="1351"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
        </section>
        <section>
         <a id="s0150">
         </a>
         <h4 class="h3hd" id="cesectitle0160">
          Composition
         </h4>
         <p class="textfl" id="p1375">
          Private inheritance is a quick way to fix an interface that violates the LSP if it already uses public inheritance. However, the preferred solution is to use composition. This simply means that instead of class S inheriting from T, S declares T as a private data member (has-a), or S declares a pointer or reference to T as a member variable (holds-a). For example:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0075">
            <img alt="image" height="718" src="../../IMAGES/B9780443222191000088/main.assets/u04-07-9780443222191.jpg" width="1005"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1380">
          Then the definition of the
          <span class="inlinecode">
           SetRadius()
          </span>
          and
          <span class="inlinecode">
           GetRadius()
          </span>
          methods might look like:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0080">
            <img alt="image" height="602" src="../../IMAGES/B9780443222191000088/main.assets/u04-08-9780443222191.jpg" width="1282"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="textfl">
          <a id="p163">
          </a>
         </p>
         <div>
          <span aria-label="163" epub:type="pagebreak" id="pagebreak_163" role="doc-pagebreak">
          </span>
         </div>
         <p class="text" id="p1385">
          In this case, the interface for
          <span class="inlinecode">
           Ellipse
          </span>
          is not exposed in the interface for
          <span class="inlinecode">
           Sphere
          </span>
          . However,
          <span class="inlinecode">
           Sphere
          </span>
          still builds upon the functionality of
          <span class="inlinecode">
           Ellipse
          </span>
          by creating a private instance of
          <span class="inlinecode">
           Ellipse
          </span>
          . Composition therefore provides the functional equivalent of private inheritance. However, there is wide agreement by object-oriented design experts that you should prefer composition over inheritance (
          <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib98" id="bib_98">
           Sutter and Alexandrescu, 2004
          </a>
          ).
         </p>
         <div>
          <aside aria-labelledby="b0100" epub:type="sidebar">
           <div class="box_top_space">
           </div>
           <div class="boxg1" id="b0100">
            <div class="b1textfl" id="bpar0270">
             <i>
              TIP: Prefer composition to inheritance.
             </i>
            </div>
           </div>
          </aside>
         </div>
         <p class="text" id="p1390">
          The main reason for this preference is that inheritance produces a more tightly coupled design. When a class inherits from another type, whether it is public, protected, or private inheritance, the subclass gains access to all public and protected members of the base class, whereas with composition, the class is coupled only to the public members of the other class. Furthermore, if you only hold a pointer to the other object, then your interface can use a forward declaration of the class rather than
          <span class="inlinecode">
           #include
          </span>
          its full definition. This results in greater compile-time insulation and improves the time it takes to compile your code. Finally, you should not force an inheritance relationship when it's not appropriate. Our previous discussion tells us that a sphere should not be treated as an ellipse for the purposes of type inheritance. Note that there may still be a good case for a general
          <span class="inlinecode">
           Shape
          </span>
          type from which all shapes, including
          <span class="inlinecode">
           Circle
          </span>
          and
          <span class="inlinecode">
           Ellipse
          </span>
          , inherit. However, a
          <span class="inlinecode">
           Circle
          </span>
          should not inherit from
          <span class="inlinecode">
           Ellipse
          </span>
          because it exhibits different behavior.
         </p>
        </section>
       </section>
       <section>
        <a id="s0155">
        </a>
        <h3 class="h2hd" id="cesectitle0165">
         The open/closed principle
        </h3>
        <p class="textfl" id="p1395">
         Bertrand Meyer introduced the open/closed principle (OCP) to state the goal that a class should be open for extension but closed for modification (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib66">
          Meyer, 1997
         </a>
         ). Essentially this means that the behavior of a class can be modified without changing its source code. This is a particularly relevant principle for API design because it focuses on the creation of stable interfaces that can last for the long term.
        </p>
        <p class="text" id="p1400">
         The principal idea behind the OCP is that once a class has been completed and released to users, it should be modified only to fix bugs. However, new features or changed functionality should be implemented by creating a new class. This is often achieved by extending the original class through either inheritance or composition. However, as I'll cover later in the book, you can also provide a plug-in system to allow users of your API to extend its basic functionality.
        </p>
        <p class="text" id="p1405">
         As an example of the OCP used to practical effect, the simple factory method I presented in
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         is not closed to modification or open for extensibility. That's because
         <a id="p164">
         </a>
         <span aria-label="164" epub:type="pagebreak" id="pagebreak_164" role="doc-pagebreak">
         </span>
         adding new types to the system requires changing the factory method implementation. As a reminder, here's the code for that simple renderer factory method:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="950" src="../../IMAGES/B9780443222191000088/main.assets/u04-09-9780443222191.jpg" width="2322"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1410">
         By contrast, the extensible renderer factory that I presented later in
         <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
          Chapter 3
         </a>
         allows for the system to be extended without modifying the factory method. This is done by allowing clients to register new types with the system at run time. This second implementation therefore demonstrates the OCP: the original code doesn't need to be changed to extend its functionality.
        </p>
        <p class="text" id="p1415">
         However, when adhered to strictly, the OCP can be difficult to achieve in real-world software projects, and even contradicts some of the principles of good API design that I've advanced here. The constraint never to change the source code of a class after it’s released is often impractical in large-scale complex systems, and the stipulation that any changes in behavior should trigger the creation of new classes can cause the original clean and minimal design to be diluted and fractured. In these cases, the OCP may be considered more of a guiding heuristic rather than a hard-and-fast rule. Also, although a good API should be as extensible as possible, there is a tension between the OCP and the specific advice in this book that you should declare member functions to be virtual in a judicious and restrained manner.
        </p>
        <p class="text" id="p1420">
         Nevertheless, if I restate the OCP to mean that the interface of a class should be closed to change, rather than considering the precise implementation behind that interface to be immutable, then you have a principle that aligns reasonably well with the focus of this book. That is, the maintenance of a stable interface gives you the flexibility to change the underlying implementation without unduly affecting your client's code. Furthermore, the use of extensive regression testing can allow you to make internal code changes without affecting existing behavior on which your users rely. And the use of an appropriate plug-in architecture (see
         <a href="../B9780443222191000040/CH0015_533-564_B9780443222191000040.xhtml">
          Chapter 15
         </a>
         ) can provide your clients with a versatile point of extensibility.
         <a id="p165">
         </a>
         <span aria-label="165" epub:type="pagebreak" id="pagebreak_165" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0105" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0105">
           <div class="b1textfl" id="bpar0275">
            <i>
             TIP: Your API should be closed to incompatible changes in its interface, but open to extensibility of its functionality.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0160">
        </a>
        <h3 class="h2hd" id="cesectitle0170">
         The Law of Demeter
        </h3>
        <p class="textfl" id="p1425">
         The Law of Demeter (LoD), also known as the principle of least knowledge, is a guideline for producing loosely coupled designs. The rule was proposed by Ian Holland based upon experiences developing the Demeter Project at Northeastern University in the late 1980s (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib54" id="bib_54">
          Lieberherr and Holland, 1989
         </a>
         ). It states that each component should have only limited knowledge about other components, and even then only closely related components. This can be expressed more concisely as: only talk to your immediate friends.
        </p>
        <p class="text" id="p1430">
         When applied to object-oriented design, the LoD means that a function can:
        </p>
        <div>
         <ol id="ulist0100">
          <li class="bulllist" id="p1435">
           <a id="u0520">
           </a>
           ▪ Call other functions in the same class
          </li>
          <li class="bulllist" id="p1440">
           <a id="u0525">
           </a>
           ▪ Call functions on data members of the same class
          </li>
          <li class="bulllist" id="p1445">
           <a id="u0530">
           </a>
           ▪ Call functions on any parameters that it accepts
          </li>
          <li class="bulllist" id="p1450">
           <a id="u0535">
           </a>
           ▪ Call functions on any local objects that it creates
          </li>
          <li class="bulllist" id="p1455">
           <a id="u0540">
           </a>
           ▪ Call functions on a global object (but you should never have globals)
          </li>
         </ol>
        </div>
        <p class="text" id="p1460">
         By corollary, you should never call a function on an object that you obtained via another function call. For example, you should avoid chaining function calls such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000088/main.assets/u04-10-9780443222191.jpg" width="1283"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1465">
         One way to avoid this practice involves refactoring object A so that it provides direct access to the functionality in object B, thus allowing you to do the following:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000088/main.assets/u04-11-9780443222191.jpg" width="900"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1470">
         Alternatively, you could refactor the calling code so that it has an actual object B to invoke the required function directly. This can be done either by storing an instance or reference to object B in
         <span class="inlinecode">
          MyClass
         </span>
         or by passing object B into the function that needs it. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000088/main.assets/u04-12-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p166">
         </a>
        </p>
        <div>
         <span aria-label="166" epub:type="pagebreak" id="pagebreak_166" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1475">
         The downside of this technique is that you introduce lots of thin wrapper methods into your classes, increase the parameter count of your functions, or increase the size of your objects. However, the benefit is that you end up with more loosely coupled classes in which the dependencies on other objects are made explicit. This makes the code much easier to refactor or evolve in the future. In fact, the latter solution of explicitly passing an object into a function has clear parallels with the technique of dependency injection. Also, another application of the LoD involves creating a single method in object A that aggregates calls to multiple methods of object B, which resonates well with the Façade design pattern.
        </p>
        <div>
         <aside aria-labelledby="b0110" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0110">
           <div class="b1textfl" id="bpar0280">
            <i>
             TIP: The LoD states that you should call functions only in your own class or on immediately related objects.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0165">
        </a>
        <h3 class="h2hd" id="cesectitle0175">
         Class naming
        </h3>
        <p class="textfl" id="p1480">
         While I've been largely concerned with the details of object-oriented design in these latest sections, once you've developed an appropriate collection of classes, an equally critical task is the development of expressive and consistent names for these classes. Accordingly, here are some guidelines for naming your classes:
        </p>
        <div>
         <ol id="ulist0105">
          <li class="bulllist" id="p1485">
           <a id="u0545">
           </a>
           ▪ Simple class names should be powerful, descriptive, and self-explanatory. Moreover, they should make sense in the problem domain being modeled and they should be named after the thing they are modeling (e.g.,
           <span class="inlinecode">
            Customer
           </span>
           ,
           <span class="inlinecode">
            Bookmark
           </span>
           , or
           <span class="inlinecode">
            Document)
           </span>
           . As I've already noted, class names tend to form the nouns of your system: the principal objects of your design.
          </li>
          <li class="bulllist" id="p1490">
           <a id="u0550">
           </a>
           ▪ Joshua Bloch states that good names drive good designs. Therefore, a class should do one thing and do it well, and a class name should instantly convey its purpose (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib11" id="bib_11">
            Bloch, 2008
           </a>
           ). If a class is difficult to name, that's usually a sign that your design is lacking. Kent Beck offers an example in which he originally used the generic compound name
           <span class="inlinecode">
            DrawingObject
           </span>
           for an object in a graphical drawing system, but later refined this to the more expressive term
           <span class="inlinecode">
            Figure
           </span>
           by referring to the field of typography (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib9" id="bib_9">
            Beck, 2007
           </a>
           ).
          </li>
          <li class="bulllist" id="p1495">
           <a id="u0555">
           </a>
           ▪ Sometimes it's necessary to use a compound name to convey greater specificity and precision, such as
           <span class="inlinecode">
            TextStyle
           </span>
           ,
           <span class="inlinecode">
            SelectionManager
           </span>
           , or
           <span class="inlinecode">
            LevelEditor
           </span>
           . However, if you're using more than two or three words, then this can indicate that your design is too confusing or complex.
          </li>
          <li class="bulllist" id="p1500">
           <a id="u0560">
           </a>
           ▪ Interfaces and abstract base classes tend to represent adjectives in your object model. They can therefore be named as such:
           <span class="inlinecode">
            Renderable
           </span>
           ,
           <span class="inlinecode">
            Clonable
           </span>
           , or
           <span class="inlinecode">
            Observable
           </span>
           . Alternatively, it's common to prefix interface classes with the uppercase letter I: for example,
           <span class="inlinecode">
            IRenderer
           </span>
           and
           <span class="inlinecode">
            IObserver
           </span>
           .
           <a id="p167">
           </a>
          </li>
          <li>
           <span aria-label="167" epub:type="pagebreak" id="pagebreak_167" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p1505">
           <a id="u0565">
           </a>
           ▪ Avoid cryptic abbreviations. Good class names should be obvious and consistent. Don't force your users to try and remember which names you've abbreviated and which you have not. I will revisit this point later when I discuss function naming.
          </li>
          <li class="bulllist" id="p1510">
           <a id="u0570">
           </a>
           ▪ You should include some form of namespace for your top-level symbols, such as classes and free functions, so that your names don't clash with those in other APIs that your clients may be using. This can be done either via the C++
           <span class="inlinecode">
            namespace
           </span>
           keyword or through the use of a short prefix. For example, all OpenGL function calls start with gl and all Qt classes begin with Q.
          </li>
         </ol>
        </div>
       </section>
      </section>
      <section>
       <a id="s0170">
       </a>
       <h2 class="h1hd" id="cesectitle0180">
        Function design
       </h2>
       <p class="textfl" id="p1515">
        The lowest granularity of API design is how you represent the individual function calls and their parameters. Although this may seem like an obvious exercise and not worth covering in much detail, there are many function-level issues that affect good API design. After all, function calls are the most used part of an API: they are how your clients access the API's behavior.
       </p>
       <section>
        <a id="s0175">
        </a>
        <h3 class="h2hd" id="cesectitle0185">
         Function design options
        </h3>
        <p class="textfl" id="p1520">
         There are many interface options you can control when designing a function call (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
          Lakos, 1996
         </a>
         ). First, for free functions you should consider the following alternatives:
        </p>
        <div>
         <ol id="ulist0110">
          <li class="bulllist" id="p1525">
           <a id="u0575">
           </a>
           ▪ Static vs. nonstatic function
          </li>
          <li class="bulllist" id="p1530">
           <a id="u0580">
           </a>
           ▪ Pass arguments by value, reference, or pointer
          </li>
          <li class="bulllist" id="p1535">
           <a id="u0585">
           </a>
           ▪ Pass arguments as const or nonconst
          </li>
          <li class="bulllist" id="p1540">
           <a id="u0590">
           </a>
           ▪ Use of optional arguments with default values
          </li>
          <li class="bulllist" id="p1545">
           <a id="u0595">
           </a>
           ▪ Return result by value, reference, or pointer
          </li>
          <li class="bulllist" id="p1550">
           <a id="u0600">
           </a>
           ▪ Return result as
           <span class="inlinecode">
            const
           </span>
           ,
           <span class="inlinecode">
            constexpr
           </span>
           ,
           <span class="inlinecode">
            consteval
           </span>
           , or nonconst
          </li>
          <li class="bulllist" id="p1555">
           <a id="u0605">
           </a>
           ▪ Operator or nonoperator function
          </li>
          <li class="bulllist" id="p1560">
           <a id="u0610">
           </a>
           ▪ Use of exception specifications
          </li>
          <li class="bulllist" id="p1565">
           <a id="u0615">
           </a>
           ▪ Use of attributes such as
           <span class="inlinecode">
            [[noreturn]]
           </span>
           or
           <span class="inlinecode">
            [[deprecated]]
           </span>
          </li>
         </ol>
        </div>
        <p class="text" id="p1570">
         For member functions, you should consider all those free function options as well as:
        </p>
        <div>
         <ol id="ulist0115">
          <li class="bulllist" id="p1575">
           <a id="u0620">
           </a>
           ▪ Virtual vs. nonvirtual member function
          </li>
          <li class="bulllist" id="p1580">
           <a id="u0625">
           </a>
           ▪ Pure virtual vs. nonpure virtual member function
          </li>
          <li class="bulllist" id="p1585">
           <a id="u0630">
           </a>
           ▪ Const vs. nonconst member function
          </li>
          <li class="bulllist" id="p1590">
           <a id="u0635">
           </a>
           ▪ Public, protected, or private member function
          </li>
          <li class="bulllist" id="p1595">
           <a id="u0640">
           </a>
           ▪ Use of the explicit keyword for nondefault constructors
          </li>
         </ol>
        </div>
        <p class="text" id="p1600">
         In addition to these options that control the logical interface of a function, there are a couple of organizational attributes that you can specify for a function, such as:
        </p>
        <div>
         <ol id="ulist0120">
          <li class="bulllist" id="p1605">
           <a id="u0645">
           </a>
           ▪ Friend vs. nonfriend function
          </li>
          <li class="bulllist" id="p1610">
           <a id="u0650">
           </a>
           ▪ Inline vs. noninline function
          </li>
         </ol>
        </div>
        <p class="textfl">
         <a id="p168">
         </a>
        </p>
        <div>
         <span aria-label="168" epub:type="pagebreak" id="pagebreak_168" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1615">
         The proper application of these options can make a large impact on the quality of your API. For example, you should declare member functions as const wherever possible to advertise that they don't modify the object (see
         <a href="../B9780443222191000106/CH0006_209-250_B9780443222191000106.xhtml">
          Chapter 6
         </a>
         on C++ Usage for more details). Passing objects as const references can reduce the amount of memory copying that your API introduces (see
         <a href="../B9780443222191000052/CH0008_329-365_B9780443222191000052.xhtml">
          Chapter 8
         </a>
         on Performance). The use of the
         <span class="inlinecode">
          explicit
         </span>
         keyword can avoid unexpected side effects for nondefault constructors (see
         <a href="../B9780443222191000106/CH0006_209-250_B9780443222191000106.xhtml">
          Chapter 6
         </a>
         ), and inlining your functions can sometimes offer a performance advantage at the cost of exposing implementation details and breaking binary compatibility (see
         <a href="../B9780443222191000052/CH0008_329-365_B9780443222191000052.xhtml">
          Chapters 8
         </a>
         and
         <a href="../B9780443222191000027/CH0010_383-414_B9780443222191000027.xhtml">
          10
         </a>
         ).
        </p>
       </section>
       <section>
        <a id="s0180">
        </a>
        <h3 class="h2hd" id="cesectitle0190">
         Function naming
        </h3>
        <p class="textfl" id="p1620">
         Function names tend to form the verbs of your system, describing actions to be performed or values to be returned. Here are some guidelines for naming your free and member functions:
        </p>
        <div>
         <ol id="ulist0125">
          <li class="bulllist" id="p1625">
           <a id="u0655">
           </a>
           ▪ Methods that are used to set or return some value should fully describe that quantity using standard prefixes such as
           <span class="inlinecode">
            Get
           </span>
           and
           <span class="inlinecode">
            Set
           </span>
           . For example, a function that returns the zoom factor for a Web view might be called
           <span class="inlinecode">
            GetZoomFactor()
           </span>
           or, less expressively, just
           <span class="inlinecode">
            ZoomFactor()
           </span>
           . If a getter function may perform nontrivial work to return its result, you may want to reflect that in its name (e.g., by using a prefix of
           <span class="inlinecode">
            Find
           </span>
           or
           <span class="inlinecode">
            Calculate
           </span>
           instead of
           <span class="inlinecode">
            Get
           </span>
           ).
          </li>
          <li class="bulllist" id="p1630">
           <a id="u0660">
           </a>
           ▪ Functions that answer yes or no queries should use an appropriate prefix to indicate this behavior, such as
           <span class="inlinecode">
            Is
           </span>
           ,
           <span class="inlinecode">
            Are
           </span>
           , or
           <span class="inlinecode">
            Has
           </span>
           , and should return a bool result: for example,
           <span class="inlinecode">
            IsEnabled()
           </span>
           ,
           <span class="inlinecode">
            ArePerpendicular()
           </span>
           , or
           <span class="inlinecode">
            HasChildren()
           </span>
           . As an alternative, the C++ Standard Library tends to drop the initial verb, as can be seen in functions such as
           <span class="inlinecode">
            empty()
           </span>
           instead of
           <span class="inlinecode">
            IsEmpty()
           </span>
           . However, although terser, this naming style is ambiguous because it could also be interpreted as an operation that empties the container (unless you're astute enough to notice the const method decorator). The Standard Library scheme therefore fails the qualities of discoverability and difficulty to misuse.
          </li>
          <li class="bulllist" id="p1635">
           <a id="u0665">
           </a>
           ▪ Methods that are used to perform some action should be named with a strong verb: for example,
           <span class="inlinecode">
            Enable()
           </span>
           ,
           <span class="inlinecode">
            Print()
           </span>
           , or
           <span class="inlinecode">
            Save()
           </span>
           . If you are naming a free function, rather than a method of a class, then you should include the name of the object to which the action will be applied: for example,
           <span class="inlinecode">
            FileOpen()
           </span>
           ,
           <span class="inlinecode">
            FormatString()
           </span>
           , or
           <span class="inlinecode">
            MakeVector3d()
           </span>
           .
          </li>
          <li class="bulllist" id="p1640">
           <a id="u0670">
           </a>
           ▪ Method names should describe everything that the routine does. For example, if a routine in an image processing library performs a sharpening filter on an image and saves it to disk, the method should be called something like
           <span class="inlinecode">
            SharpenAndSaveImage()
           </span>
           instead of just
           <span class="inlinecode">
            SharpenImage()
           </span>
           . If this makes your method names too long, then this may indicate that they're performing too many tasks and should be split up (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56">
            McConnell, 2004
           </a>
           ).
           <a id="p169">
           </a>
          </li>
          <li>
           <span aria-label="169" epub:type="pagebreak" id="pagebreak_169" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p1645">
           <a id="u0675">
           </a>
           ▪ Avoid abbreviations. Names should be self-explanatory and memorable, but the use of abbreviations can introduce confusing or obscure terminology. For example, the user has to remember if you are using
           <span class="inlinecode">
            GetCurrentValue()
           </span>
           ,
           <span class="inlinecode">
            GetCurrValue()
           </span>
           ,
           <span class="inlinecode">
            GetCurValue()
           </span>
           , or
           <span class="inlinecode">
            GetCurVal()
           </span>
           . Some software projects specify an explicit list of accepted abbreviations that must be followed, but in general it's simply easier for your users if they don't have to remember lists like this.
          </li>
          <li class="bulllist" id="p1650">
           <a id="u0680">
           </a>
           ▪ Use consistent capitalization rules. You'll see that I favor
           <span class="inlinecode">
            CamelCase
           </span>
           in this book, but you may prefer
           <span class="inlinecode">
            camelCase
           </span>
           or
           <span class="inlinecode">
            snake_case
           </span>
           for your own projects. You should also be consistent about how you include acronyms in your function names: for example, if a function that parses an XML file is called
           <span class="inlinecode">
            ParseXMLFile()
           </span>
           or
           <span class="inlinecode">
            ParseXmlFile()
           </span>
           . The former style preserves the familiar uppercase form of acronyms, but it can cause confusion when there are multiple acronyms (e.g., should
           <span class="inlinecode">
            SendHTTPSXML()
           </span>
           be interpreted as “Send HTTPS XML” or “Send HTTP SXML”?). The capitalization approach makes these cases clearer: e.g.,
           <span class="inlinecode">
            SendHttpsXml()
           </span>
           .
          </li>
          <li class="bulllist" id="p1655">
           <a id="u0685">
           </a>
           ▪ Functions should not begin with an underscore character (
           <span class="inlinecode">
            _
           </span>
           ). The C++ standard states that global symbols starting with an underscore are reserved for internal compiler use. The same is true for all symbols that contain a double underscore or begin with an underscore followed by an uppercase letter. Although you can find legal combinations of leading underscore names that navigate these rules, it's generally best to simply avoid this practice in your function names (some developers use this convention to indicate a private member).
          </li>
          <li class="bulllist" id="p1660">
           <a id="u0690">
           </a>
           ▪ Methods that form natural pairs should use the correct complementary terminology. For example,
           <span class="inlinecode">
            OpenWindow()
           </span>
           should be paired with
           <span class="inlinecode">
            CloseWindow()
           </span>
           , not
           <span class="inlinecode">
            DismissWindow()
           </span>
           . The use of precise opposite terms makes it clearer to the user that one method performs the opposite function of another method (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56">
            McConnell, 2004
           </a>
           ). This list provides some common complementary terms:
          </li>
         </ol>
        </div>
        <div>
         <div class="pageavoid">
          <p class="tnum">
          </p>
          <table class="tbody" id="t0010">
           <tbody>
            <tr>
             <th class="tb" scope="row">
              Add/Remove
             </th>
             <td class="tb">
              Begin/End
             </td>
             <td class="tb">
              Create/Destroy
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              Enable/Disable
             </th>
             <td class="tb">
              Insert/Delete
             </td>
             <td class="tb">
              Lock/Unlock
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              Next/Previous
             </th>
             <td class="tb">
              Open/Close
             </td>
             <td class="tb">
              Push/Pop
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              Send/Receive
             </th>
             <td class="tb">
              Show/Hide
             </td>
             <td class="tb">
              Source/Target
             </td>
            </tr>
           </tbody>
          </table>
         </div>
        </div>
       </section>
       <section>
        <a id="s0185">
        </a>
        <h3 class="h2hd" id="cesectitle0195">
         Function parameters
        </h3>
        <p class="textfl" id="p1665">
         The use of good parameter names can also have a big impact on the discoverability of your API. For example, compare these two signatures for the standard C function
         <span class="inlinecode">
          strstr()
         </span>
         , which searches for the first occurrence of a substring within another string:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000088/main.assets/u04-13-9780443222191.jpg" width="1561"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p170">
         </a>
        </p>
        <div>
         <span aria-label="170" epub:type="pagebreak" id="pagebreak_170" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1670">
         and,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000088/main.assets/u04-14-9780443222191.jpg" width="1908"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1675">
         I think you'll agree that the second signature gives a much better indication of how to use the function, simply by using descriptive parameter names.
        </p>
        <p class="text" id="p1680">
         Another factor is to make sure that you use the right data type for your parameters. For example, when you have methods that perform linear algebra calculations, you should prefer using double-precision floats to avoid a loss of precision errors that are inherent in single-precision operations. Similarly, you should never use a floating-point data type to represent monetary values because of the potential for rounding errors (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib8" id="bib_8">
          Beck, 2002
         </a>
         ).
        </p>
        <p class="text" id="p1685">
         When passing an array of items into a function, you should either try to use a dynamic container, such as an
         <span class="inlinecode">
          std::vector
         </span>
         , or a static container of known size, such as an
         <span class="inlinecode">
          std::array
         </span>
         or
         <span class="inlinecode">
          double[3]
         </span>
         . Avoid having parameters that make assumptions about the size of an array. For example, the following function is a bad design because the user doesn't know how big the bounding box structure should be, which could lead to memory errors if the client provides an array that's too small:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000088/main.assets/u04-15-9780443222191.jpg" width="1665"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1690">
         There's also a balance to be sought in terms of the number of parameters that you specify for each function. Too many parameters can make the call more difficult to understand and to maintain. It can also imply greater coupling and may suggest that it’s time to refactor the function. Therefore, wherever possible, you should try to minimize the number of parameters in your public functions. In this regard, we have the often-cited research from the field of cognitive science, which states that the number of items we can hold in our short-term working memory is seven plus or minus 2 (Miller, 1956). This may suggest that you should not exceed around five to seven parameters; otherwise the user will find it difficult to remember all of the options. Indeed, Joshua Bloch suggests that five or more parameters are too many (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib11">
          Bloch, 2008
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0115" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0115">
           <div class="b1textfl" id="bpar0285">
            <i>
             TIP: Avoid long parameter lists.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p171">
         </a>
        </p>
        <div>
         <span aria-label="171" epub:type="pagebreak" id="pagebreak_171" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1695">
         For functions with many required parameters, you should consider whether an abstraction can be introduced to represent groupings of those parameters. For example, consider the following function that sets a 3D bounding box:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000088/main.assets/u04-16-9780443222191.jpg" width="2220"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1700">
         A better representation for this interface would be to introduce the concept of a 3D point, and then the bounding box can be defined with just two parameters, i.e.,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0125">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000088/main.assets/u04-17-9780443222191.jpg" width="1871"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1705">
         For functions that accept many optional parameters, you may consider passing the arguments using a struct or map instead. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0130">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000088/main.assets/u04-18-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1710">
         This technique is also a good way to deal with argument lists that may change over the life of the API. A newer version of the API can simply add new fields to the end of the structure without changing the signature of the
         <span class="inlinecode">
          OpenWindow()
         </span>
         function. You can also add a version field (set by the constructor) to allow binary compatible changes to the structure: the
         <span class="inlinecode">
          OpenWindow()
         </span>
         function can then check the version field to determine what information is included in the structure. Other options include using a field that records the size of the structure in bytes, or simply using a different structure.
        </p>
        <div>
         <aside aria-labelledby="b0120" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0120">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0025">
            <i>
             SIDEBAR: Reducing parameter lists
            </i>
           </div>
           <div class="b1textfl" id="bpar0290">
            <i>
             All the way back in the 1980s, the Commodore Amiga platform provided an extensive set of stable and well-designed APIs to build applications that run under AmigaOS. The original routine to open a new screen on the Amiga takes a single argument: a structure containing all of the necessary information to specify that screen:
            </i>
           </div>
           <div>
            <div class="pageavoid">
             <figure class="fig" id="f0135">
              <img alt="image" class="box_img" height="81" src="../../IMAGES/B9780443222191000088/main.assets/u04-19-9780443222191.jpg" width="1802"/>
              <figcaption class="figleg">
              </figcaption>
             </figure>
            </div>
           </div>
           <div class="b1textfl">
            <i>
             The
            </i>
            <span class="inlinecode">
             <i>
              NewScreen
             </i>
            </span>
            <i>
             structure looks like:
            </i>
           </div>
           <div>
            <div class="pageavoid">
             <figure class="fig" id="f0140">
              <img alt="image" class="box_img" height="707" src="../../IMAGES/B9780443222191000088/main.assets/u04-20-9780443222191.jpg" width="1698"/>
              <figcaption class="figleg">
              </figcaption>
             </figure>
            </div>
           </div>
           <div class="b1text" id="bpar0300">
            <i>
             In Version 36 of the AmigaOS APIs, new functionality was added to this function. This was done by introducing the notion of tag lists, essentially an arbitrarily long list of keyword/value pairs. To support this new extensible scheme, a V36-only function was added to allow the explicit specification of these tag lists:
            </i>
           </div>
           <div>
            <div class="pageavoid">
             <figure class="fig" id="f0145">
              <img alt="image" class="box_img" height="139" src="../../IMAGES/B9780443222191000088/main.assets/u04-21-9780443222191.jpg" width="2011"/>
              <figcaption class="figleg">
              </figcaption>
             </figure>
            </div>
           </div>
           <div class="b1text" id="bpar0305">
            <i>
             However, to maintain backward compatibility, it was also possible to pass a new
            </i>
            <span class="inlinecode">
             <i>
              ExtNewScreen
             </i>
            </span>
            <i>
             structure to the
            </i>
            <span class="inlinecode">
             <i>
              OpenScreen()
             </i>
            </span>
            <i>
             function:
            </i>
           </div>
           <div>
            <div class="pageavoid">
             <figure class="fig" id="f0150">
              <img alt="image" class="box_img" height="81" src="../../IMAGES/B9780443222191000088/main.assets/u04-22-9780443222191.jpg" width="1904"/>
              <figcaption class="figleg">
              </figcaption>
             </figure>
            </div>
           </div>
           <div class="b1text" id="bpar0310">
            <i>
             This extended structure looks like:
            </i>
           </div>
           <div>
            <div class="pageavoid">
             <figure class="fig" id="f0155">
              <img alt="image" class="box_img" height="776" src="../../IMAGES/B9780443222191000088/main.assets/u04-23-9780443222191.jpg" width="1698"/>
              <figcaption class="figleg">
              </figcaption>
             </figure>
            </div>
           </div>
           <div class="b1text" id="bpar0315">
            <i>
             When passing this new structure to
            </i>
            <span class="inlinecode">
             <i>
              OpenScreen()
             </i>
            </span>
            <i>
             you had to set the
            </i>
            <span class="inlinecode">
             <i>
              NS_EXTENDED
             </i>
            </span>
            <i>
             bit of the
            </i>
            <span class="inlinecode">
             <i>
              Type
             </i>
            </span>
            <i>
             field to indicate that the structure included an
            </i>
            <span class="inlinecode">
             <i>
              Extension
             </i>
            </span>
            <i>
             field at the end. In this way, you could pass either the old or the new form to newer versions of AmigaOS, but older versions of
            </i>
            <span class="inlinecode">
             <i>
              amiga.lib
             </i>
            </span>
            <i>
             would safely ignore the new data.
            </i>
           </div>
           <div class="b1text" id="bpar0320">
            <i>
             Note that this is a plain C API, which cannot support function overloading, so the two versions of the
            </i>
            <span class="inlinecode">
             <i>
              OpenScreen()
             </i>
            </span>
            <i>
             function were not specified in the same version of the API. Newer versions of the API would specify the
            </i>
            <span class="inlinecode">
             <i>
              ExtNewScreen
             </i>
            </span>
            <i>
             signature, although code that tried to pass an older
            </i>
            <span class="inlinecode">
             <i>
              NewScreen
             </i>
            </span>
            <i>
             structure would still compile fine under a C compiler (perhaps with a warning). In C++, this type mismatch would cause a compile error, but in that case you could simply provide two overloaded versions of
            </i>
            <span class="inlinecode">
             <i>
              OpenScreen()
             </i>
            </span>
            <i>
             .
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p172">
         </a>
        </p>
        <div>
         <span aria-label="172" epub:type="pagebreak" id="pagebreak_172" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1715">
         Taking this one step further, you can hide all of the public member variables and allow the values to be accessed only via getter/setter functions. The Qt API refers to this as a property-based API. It's also known more generally as the Named Parameter Idiom. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0160">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000088/main.assets/u04-24-9780443222191.jpg" width="969"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1720">
         This lets you reduce the number of parameters required for functions; in this case, the
         <span class="inlinecode">
          start()
         </span>
         function requires no parameters at all. The use of functions to set parameter values also offers the following benefits:
        </p>
        <div>
         <ol id="ulist0130">
          <li class="bulllist" id="p1725">
           <a id="u0695">
           </a>
           ▪ Values can be specified in any order because the function calls are order-independent.
          </li>
          <li class="bulllist" id="p1730">
           <a id="u0700">
           </a>
           ▪ The purpose of each value is more evident, because you must use a named function to set the value: e.g.,
           <span class="inlinecode">
            setInterval()
           </span>
           .
          </li>
          <li class="bulllist" id="p1735">
           <a id="u0705">
           </a>
           ▪ Optional parameters are supported simply by not calling the appropriate function.
          </li>
          <li class="bulllist" id="p1740">
           <a id="u0710">
           </a>
           ▪ The constructor can define reasonable default values for all settings.
          </li>
          <li class="bulllist" id="p1745">
           <a id="u0715">
           </a>
           ▪ Adding new parameters is backward compatible because no existing functions need to change signature. Only new functions are added.
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0190">
        </a>
        <h3 class="h2hd" id="cesectitle0200">
         Error handling
        </h3>
        <p class="textfl" id="p1750">
         A large amount of the code that application developers write is purely to handle error conditions. The actual amount of error handling code that's written will depend greatly upon the particular application. However, it's been estimated that up to 90% of an application's code is related to handling exceptional or error conditions (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56">
          McConnell, 2004
         </a>
         ). This is therefore an important area of API design that will be used frequently by your clients. In fact, it's included in Ken Pugh's Three Laws of Interfaces (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib79" id="bib_79">
          Pugh, 2006
         </a>
         ):
        </p>
        <div>
         <ul class="ce_list" id="olist0095">
          <li class="numlist" id="p1755">
           <a id="o0350">
           </a>
           1. An interface's implementation shall do what its methods say it does.
          </li>
          <li class="numlist" id="p1760">
           <a id="o0355">
           </a>
           2. An interface's implementation shall do no harm.
          </li>
          <li class="numlist" id="p1765">
           <a id="o0360">
           </a>
           3. If an interface's implementation is unable to perform its responsibilities, it shall notify its caller.
          </li>
         </ul>
        </div>
        <p class="text" id="p1770">
         Accordingly, the three main ways of dealing with error conditions in your API are:
        </p>
        <div>
         <ul class="ce_list" id="olist0100">
          <li class="numlist" id="p1775">
           <a id="o0365">
           </a>
           1. Returning error codes
          </li>
          <li class="numlist" id="p1780">
           <a id="o0370">
           </a>
           2. Throwing exceptions
          </li>
          <li class="numlist" id="p1785">
           <a id="o0375">
           </a>
           3. Aborting the program
          </li>
         </ul>
        </div>
        <p class="text" id="p1790">
         The last of these is an extreme course of action that should be avoided at all costs, and indeed it violates the third of Pugh's three laws, although there are far too many
         <a id="p174">
         </a>
         <span aria-label="174" epub:type="pagebreak" id="pagebreak_174" role="doc-pagebreak">
         </span>
         examples of libraries out there that call
         <span class="inlinecode">
          abort()
         </span>
         or
         <span class="inlinecode">
          exit()
         </span>
         . As for the first two cases, different engineers have various proclivities toward each of these techniques. I will not take a side on the exceptions versus error code debate here, but rather I'll attempt to present the arguments and drawbacks impartially for each option. Whichever technique you select for your API, the most important issues are that you use a consistent error reporting scheme and that it is well-documented.
        </p>
        <div>
         <aside aria-labelledby="b0125" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0125">
           <div class="b1textfl" id="bpar0325">
            <i>
             TIP: Use a consistent and well-documented error handling mechanism.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1795">
         The error codes approach involves returning a numeric code to indicate the success or failure of a function. Normally this error code is returned as the direct result of a function. For example, many Win32 functions return errors using the
         <span class="inlinecode">
          HRESULT
         </span>
         data type. This is a single 32-bit value that encodes the severity of the failure, the subsystem responsible for the error, and an actual error code. The C Standard Library also provides examples of nonorthogonal error reporting design, such as the functions
         <span class="inlinecode">
          read()
         </span>
         ,
         <span class="inlinecode">
          waitpid()
         </span>
         , and
         <span class="inlinecode">
          ioctl()
         </span>
         that set the value of the
         <span class="inlinecode">
          errno
         </span>
         global variable as a side effect. OpenGL provides a similar error reporting mechanism via an error checking function called
         <span class="inlinecode">
          glGetError()
         </span>
         .
        </p>
        <p class="text" id="p1800">
         The use of error codes produces client code that looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0165">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000088/main.assets/u04-25-9780443222191.jpg" width="1075"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1805">
         As an alternative, you can use C++'s exception capabilities to signal a failure in your implementation code. This is done by throwing an object for your clients to catch in their code. For example, several of the Boost libraries throw exceptions to communicate error conditions to the client, such as the
         <span class="inlinecode">
          boost::iostreams
         </span>
         and
         <span class="inlinecode">
          boost::program_options
         </span>
         libraries. The use of exceptions in your API results in client code such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0170">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000088/main.assets/u04-26-9780443222191.jpg" width="1214"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p175">
         </a>
        </p>
        <div>
         <span aria-label="175" epub:type="pagebreak" id="pagebreak_175" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1810">
         The error codes technique provides a simple, explicit, and robust way to report errors for individual function calls. It's also the only option if you're developing an API that must be accessible from plain C programs. The main dilemma comes when you wish to return a result as well as an error code. One way to deal with this is to return the error code as the function result and use an out parameter to fill in the result value. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0175">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000088/main.assets/u04-27-9780443222191.jpg" width="1630"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1815">
         Dynamic scripting languages such as Python handle this more elegantly by making it easy to return multiple values as a tuple. However, this is still an option for modern C++ code. Since C++11, you can use
         <span class="inlinecode">
          std::tuple
         </span>
         to return multiple results from a function. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0180">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000088/main.assets/u04-28-9780443222191.jpg" width="2010"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1820">
         And as of C++17, your clients can use structured binding to make this even easier to use: i.e.,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0185">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000088/main.assets/u04-29-9780443222191.jpg" width="1628"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1825">
         Even better, since C++23, you can use
         <span class="inlinecode">
          std::expected
         </span>
         to return either a valid object or an error. You can refer to the section on Expected Values in the C++ Revisions chapter for more details about
         <span class="inlinecode">
          std::expected
         </span>
         . In the meantime, here's an example of what the syntax looks like:
         <a id="p176">
         </a>
         <span aria-label="176" epub:type="pagebreak" id="pagebreak_176" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0190">
           <img alt="image" height="486" src="../../IMAGES/B9780443222191000088/main.assets/u04-30-9780443222191.jpg" width="1906"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1830">
         By comparison, exceptions let your clients separate their error handling code from the normal flow of control, making for more readable code. They offer the benefit of being able to catch one or more errors in a sequence of several function calls without having to check every single return code, and they let you handle an error higher up in the call stack instead of at the exact point of failure. An exception can also carry more information than a simple error code. For example, C++ Standard Library exceptions include a human-readable description of the failure, accessible via a
         <span class="inlinecode">
          what()
         </span>
         method. Also, most debuggers provide a way to break if an exception is thrown, making it easier to debug problems. Finally, exceptions are the only way to report failures in a constructor.
        </p>
        <p class="text" id="p1835">
         However, this flexibility does come with a cost. Although the use of exceptions should have no cost when an exception is not thrown, handling an exception when it is thrown can be an expensive operation owing to the run-time stack unwinding behavior. Also, an uncaught exception can cause your clients' programs to abort, resulting in data loss and frustration for their end users. Writing exception-safe code is difficult, and if not done correctly it can lead to resource leaks. Typically, the use of exceptions is an all-or-nothing proposition, meaning that if any part of an application uses exceptions, then the entire application must be prepared to handle exceptions correctly. This means that the use of exceptions in your API also requires your clients to write exception-safe code. It's noteworthy that Google forbids the use of exceptions in their C++ coding conventions because most of their existing code is not tolerant of exceptions. However, as a counterexample, the C++ Standard Library makes extensive use of exceptions to signal errors, so any modern C++ developer who uses the Standard Library must already be prepared to handle exceptions in their code.
        </p>
        <p class="text" id="p1840">
         If you do opt to use exceptions to signal unexpected situations in your code, here are some best practices to observe:
        </p>
        <div>
         <ol id="ulist0135">
          <li class="bulllist" id="p1845">
           <a id="u0720">
           </a>
           ▪ Derive your own exceptions from
           <span class="inlinecode">
            std::exception
           </span>
           and define a
           <span class="inlinecode">
            what()
           </span>
           method to describe the failure.
          </li>
          <li class="bulllist" id="p1850">
           <a id="u0725">
           </a>
           ▪ Consider the level of exception safety you will provide. There are four main types of exception guarantees (or Abrahams guarantees) you can offer (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib93" id="bib_93">
            Stroustrup, 2001
           </a>
           ):
          </li>
          <li class="bulllist">
           <ol id="ulist0140">
            <li class="bulllist1" id="p1855">
             <a id="u0730">
             </a>
             • No-throw guarantee: Ensures that the function never throws an exception. If an error occurs within the function, it will be handled internally and not be exposed to clients. This is also known as failure transparency.
            </li>
            <li class="bulllist1" id="p1860">
             <a id="u0735">
             </a>
             • Strong exception safety: An operation that fails will have no side effects and any original values will be left intact. This is also known as commit or rollback semantics.
            </li>
            <li class="bulllist1" id="p1865">
             <a id="u0740">
             </a>
             • Basic exception safety: An operation that fails may have side effects, but all invariants will be preserved (i.e., the object should still contain valid values after the error is thrown and no resources should be leaked).
            </li>
            <li class="bulllist1" id="p1870">
             <a id="u0745">
             </a>
             • No exception safety: No guarantees are made in the case of an error (i.e., data may be corrupted, incorrect values may be returned, or memory may be leaked).
            </li>
           </ol>
          </li>
          <li class="bulllist">
           <a id="p177">
           </a>
          </li>
          <li>
           <span aria-label="177" epub:type="pagebreak" id="pagebreak_177" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p1875">
           <a id="u0750">
           </a>
           ▪ Consider using RAII techniques to maintain exception safety (i.e., to ensure that resources get cleaned up correctly when an exception is thrown).
          </li>
          <li class="bulllist" id="p1880">
           <a id="u0755">
           </a>
           ▪ Make sure that you document all the exceptions that can be thrown by a function in its comments.
          </li>
          <li class="bulllist" id="p1885">
           <a id="u0760">
           </a>
           ▪ You might be tempted to use exception specifications, such as the
           <span class="inlinecode">
            throw()
           </span>
           specifier, to document the exceptions that a function may throw. However, be aware that these constraints will be enforced by the compiler at run time, if at all, and that they can affect optimizations such as the ability to inline a function. Also, note that some of this functionality was removed in C++17. As a result, most C++ engineers steer clear of exception specifications such as:
          </li>
          <li>
           <div class="pageavoid">
            <figure class="fig" id="f0195">
             <img alt="image" height="139" src="../../IMAGES/B9780443222191000088/main.assets/u04-31-9780443222191.jpg" width="1943"/>
             <figcaption class="figleg">
             </figcaption>
            </figure>
           </div>
          </li>
          <li class="bulllist" id="p1890">
           <a id="u0765">
           </a>
           ▪ Create exceptions for the set of logical errors that can be encountered, not a unique exception for every individual physical error that you raise.
          </li>
          <li class="bulllist" id="p1895">
           <a id="u0770">
           </a>
           ▪ If you handle exceptions in your own code, then you should catch the exception by reference (as in the previous example) to avoid calling the copy constructor for the thrown object. Also, try to avoid the
           <span class="inlinecode">
            catch(...)
           </span>
           syntax because some compilers also throw an exception when a programming error arises, such as an
           <span class="inlinecode">
            assert()
           </span>
           or segmentation fault.
          </li>
          <li class="bulllist" id="p1900">
           <a id="u0775">
           </a>
           ▪ If you have an exception that multiply inherits from more than one base exception class, you should use virtual inheritance to avoid ambiguities and subtle errors in your client's code where they attempt to catch your exceptions.
          </li>
          <li class="bulllist" id="p1905">
           <a id="u0780">
           </a>
           ▪ Note that on Windows, exceptions cannot cross a DLL boundary with different run times. In that case, any use of exceptions should be contained within the DLL and any public API calls should catch all exceptions and return the error using a different technique, such as an error code or an output parameter.
          </li>
         </ol>
        </div>
        <div>
         <aside aria-labelledby="b0130" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0130">
           <div class="b1textfl" id="bpar0330">
            <i>
             TIP: Derive your own exceptions from
            </i>
            <span class="inlinecode">
             <i>
              std::exception
             </i>
            </span>
            <i>
             .
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1910">
         In terms of error reporting best practices, your API should fail as fast as possible once an error occurs, and it should clean up any intermediate state, such as releasing resource that were allocated immediately before the error. However, you should also try to avoid returning an exceptional value such as
         <span class="inlinecode">
          nullptr
         </span>
         when it's not necessary. Doing so causes your clients to write more code to check for these cases. For example, if you have a function that returns a list of items, consider returning an empty list instead of
         <span class="inlinecode">
          nullptr
         </span>
         in exceptional cases. This requires your clients to write less code and reduces the chance that your clients will dereference a
         <span class="inlinecode">
          nullptr
         </span>
         .
         <a id="p178">
         </a>
        </p>
        <div>
         <span aria-label="178" epub:type="pagebreak" id="pagebreak_178" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1915">
         Also, any error code or exception description should represent the actual failure. Invent a new error code or exception if existing ones do not accurately describe the error. You'll infuriate your users if they waste time trying to debug the wrong problem because your error reporting was inaccurate or plain wrong. You should also give them as much information as possible to track down the error. For example, if a file cannot be opened, then include the filename in the error description and the cause of the failure (e.g., lack of permissions, file not found, or out of disk space).
        </p>
        <div>
         <aside aria-labelledby="b0135" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0135">
           <div class="b1textfl" id="bpar0335">
            <i>
             TIP: Fail quickly and cleanly with accurate and thorough diagnostic details.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
