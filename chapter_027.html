<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   16Overview of the C++ Standard Library
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_026.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_028.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c16_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c16_1">
      <span aria-label="619" epub:type="pagebreak" id="Page_619" role="doc-pagebreak">
      </span>
      <span id="c16">
      </span>
      <span class="chapterNumber">
       16
      </span>
      <br/>
      <span class="chapterTitle">
       Overview of the C++ Standard Library
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c16-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c16-list-0001">
         <li id="c16-li-0001">
          The coding principles used throughout the Standard Library
         </li>
         <li id="c16-li-0002">
          A high-level overview of the functionality provided by the Standard Library
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c16-fea-0001">
        </span>
        <h3 id="head-2-184">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p id="c16-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <code>
           <a href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c16-para-0005">
      The most important library that you will use as a C++ programmer is the C++ Standard Library. As its name implies, this library is part of the C++ standard, so any standards-conforming compiler should include it. The Standard Library is not monolithic: it includes several disparate components, some of which you have been using already. You may even have assumed they were part of the core language. All Standard Library classes and functions are declared in the
      <code>
       std
      </code>
      namespace, or a subnamespace of
      <code>
       std
      </code>
      .
     </p>
     <p id="c16-para-0006">
      The heart of the C++ Standard Library is its generic
      <i>
       containers
      </i>
      and
      <i>
       algorithms
      </i>
      . Some people still call this subset of the library the Standard Template Library, or STL for short, because originally it was based on a third-party library called the Standard Template Library, which used templates abundantly. However, STL is not a term defined by the C++ standard itself, so this book does not use it. The power of the Standard Library is that it provides generic containers and generic algorithms in such a way that most of the algorithms work on most of the containers, no matter what type of data the containers store. Performance is an important aspect of the
      <span aria-label="620" epub:type="pagebreak" id="Page_620" role="doc-pagebreak">
      </span>
      Standard Library. The goal is to make the Standard Library containers and algorithms as fast as, or faster than, handwritten code.
     </p>
     <p>
      The C++ Standard Library also includes most of the C headers that are part of the C11 standard, but with new names. For example, you can access the functionality from the C
      <code>
       &lt;stdio.h&gt;
      </code>
      header by including
      <code>
       &lt;cstdio&gt;
      </code>
      . The former puts everything in the global namespace, while the latter puts everything in the
      <code>
       std
      </code>
      namespace. Though, technically, the former is allowed to put things in the
      <code>
       std
      </code>
      namespace as well, and the latter is allowed to additionally put things in the global namespace. The C11 headers
      <code>
       &lt;stdnoreturn.h&gt;
      </code>
      ,
      <code>
       &lt;threads.h&gt;
      </code>
      , and their
      <code>
       &lt;c…&gt;
      </code>
      equivalents are not included in the C++ standard. The
      <code>
       &lt;stdatomic.h&gt;
      </code>
      header from C11 has been available since C++23, but no equivalent
      <code>
       &lt;cstdatomic&gt;
      </code>
      is provided. Furthermore, C++17 has deprecated, and C++20 has removed the following C headers:
     </p>
     <ul class="check1" id="c16-list-0002">
      <li id="c16-li-0003">
       <code>
        &lt;ccomplex&gt;
       </code>
       and
       <code>
        &lt;ctgmath&gt;
       </code>
       : Replace the use of these with
       <code>
        &lt;complex&gt;
       </code>
       and/or
       <code>
        &lt;cmath&gt;
       </code>
       .
      </li>
      <li id="c16-li-0004">
       <code>
        &lt;ciso646&gt;
       </code>
       ,
       <code>
        &lt;cstdalign&gt;
       </code>
       , and
       <code>
        &lt;cstdbool&gt;
       </code>
       : These headers were useless in C++ as these were either empty or defined macros that are keywords in C++.
      </li>
     </ul>
     <p>
      C headers are not guaranteed to be importable. Use
      <code>
       #include
      </code>
      instead of
      <code>
       import
      </code>
      to get access to the functionality defined by them.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c16-para-0009">
         <b>
          NOTE
         </b>
         <i>
          If there is a C++ equivalent of functionality provided by a C header, it is recommended to use the C++ equivalent
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c16-para-0010">
      A C++ programmer who wants to claim language expertise is expected to be familiar with the Standard Library. You can save yourself immeasurable time and energy by incorporating Standard Library containers and algorithms into your programs instead of writing and debugging your own versions. Now is the time to master this Standard Library.
     </p>
     <p id="c16-para-0011">
      This first chapter on the Standard Library provides a general overview of the available functionality. The next few chapters go into more detail on several aspects of the Standard Library, including containers, iterators, generic algorithms, predefined function object classes, regular expressions, random number generation, and much more. Additionally,
      <a href="c25.xhtml">
       Chapter 25
      </a>
      , “Customizing and Extending the Standard Library,” is dedicated to customizing and extending the library with your own Standard Library–compliant algorithms and data structures.
     </p>
     <p id="c16-para-0012">
      Despite the depth of material found in this and the following chapters, the Standard Library is too large for this book to cover exhaustively. You should read these chapters to learn about the Standard Library, but keep in mind that they don't mention every member function and data member that the various classes provide or show you the prototypes of every algorithm.
      <a href="b03.xhtml">
       Appendix C
      </a>
      , “Standard Library Header Files,” summarizes all the header files in the Standard Library. Consult your favorite Standard Library Reference for a complete reference of all provided functionality.
     </p>
    </section>
    <section aria-labelledby="head-2-185">
     <span id="c16-sec-0005">
     </span>
     <h2 id="head-2-185">
      CODING PRINCIPLES
     </h2>
     <p id="c16-para-0013">
      The Standard Library makes heavy use of the C++ features called
      <i>
       templates
      </i>
      and
      <i>
       operator overloading
      </i>
      .
     </p>
     <span aria-label="621" epub:type="pagebreak" id="Page_621" role="doc-pagebreak">
     </span>
     <section>
      <span id="c16-sec-0006">
      </span>
      <h3 id="head-3-356">
       Use of Templates
      </h3>
      <p id="c16-para-0014">
       Templates are used to allow
       <i>
        generic programming
       </i>
       . They make it possible to write code that can work with all kinds of objects, even objects unknown to the programmer when writing the code. The obligation of the programmer writing the template code is to specify the requirements of the classes that define these objects, for example, that they have an operator for comparison or a copy constructor, or whatever is deemed appropriate, and then making sure the code that is written uses only those required capabilities. The obligation of the programmer creating the objects is to supply those operators and member functions that the template requires.
      </p>
      <p id="c16-para-0015">
       Unfortunately, many programmers consider templates to be the most difficult part of C++ and, for that reason, tend to avoid them. However, even if you never write your own templates, you need to understand their syntax and capabilities to use the Standard Library. Templates are described in detail in
       <a href="c12.xhtml">
        Chapter 12
       </a>
       , “Writing Generic Code with Templates.” If you skipped that chapter and are not familiar with templates, I suggest you first read
       <a href="c12.xhtml">
        Chapter 12
       </a>
       and then come back to learn more about the Standard Library.
      </p>
     </section>
     <section>
      <span id="c16-sec-0007">
      </span>
      <h3 id="head-3-357">
       Use of Operator Overloading
      </h3>
      <p id="c16-para-0016">
       Operator overloading is another feature used extensively by the C++ Standard Library.
       <a href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” has a whole section devoted to operator overloading. Make sure you read that section and understand it before tackling this and subsequent chapters. In addition,
       <a href="c15.xhtml">
        Chapter 15
       </a>
       , “Overloading C++ Operators,” presents much more detail on the subject of operator overloading, but those details are not required to understand the following chapters.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-186">
     <span id="c16-sec-0008">
     </span>
     <h2 id="head-2-186">
      OVERVIEW OF THE C++ STANDARD LIBRARY
     </h2>
     <p id="c16-para-0017">
      This section introduces the various components of the Standard Library from a design perspective. You will learn what facilities are available for you to use, but you will not learn many coding details. Those details are covered in other chapters.
     </p>
     <section>
      <span id="c16-sec-0009">
      </span>
      <h3 id="head-3-358">
       Strings
      </h3>
      <p>
       C++ provides a built-in
       <code>
        string
       </code>
       class, defined in
       <code>
        &lt;string&gt;
       </code>
       . This C++
       <code>
        string
       </code>
       class is superior in almost every way compared to C-style strings of character arrays. It handles the memory management; provides some bounds checking, assignment semantics, and comparisons; and supports manipulations such as concatenation, substring extraction, and substring or character replacement.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c16-para-0019">
          <b>
           NOTE
          </b>
          <i>
           Technically,
          </i>
          <code>
           std::string
          </code>
          <i>
           is a type alias for a
          </i>
          <code>
           char
          </code>
          <i>
           instantiation of the
          </i>
          <code>
           std::basic_string
          </code>
          <i>
           class template. However, you need not worry about these details; you can use
           <code>
            string
           </code>
           as if it were a bona fide nontemplate class
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c16-para-0020">
       The Standard Library also provides a
       <code>
        string_view
       </code>
       class, defined in
       <code>
        &lt;string_view&gt;
       </code>
       . It is a read-only view of any kind of string representation and can be used as a drop-in replacement for
       <code>
        const string&amp;
       </code>
       , but without the overhead. It never copies strings!
      </p>
      <p id="c16-para-0021">
       <span aria-label="622" epub:type="pagebreak" id="Page_622" role="doc-pagebreak">
       </span>
       C++ provides support for
       <i>
        Unicode
       </i>
       and
       <i>
        localization
       </i>
       . Unicode allows you to write programs that work with text in different languages, such as Arabic, Chinese, Japanese, and so on. Locales, defined in
       <code>
        &lt;locale&gt;
       </code>
       , allow you to format data such as numbers and dates according to the rules of a certain country or region.
      </p>
      <p id="c16-para-0022">
       C++ includes a powerful type-safe string formatting library, accessed through
       <code>
        std::format
       </code>
       (
       <code>
        )
       </code>
       and defined in
       <code>
        &lt;format&gt;
       </code>
       . The library is extensible and allows you to add support for your own custom types. C++23 adds helper functions
       <code>
        std::print()
       </code>
       and
       <code>
        println()
       </code>
       to make it easier to print formatted text to the console.
      </p>
      <p id="c16-para-0023">
       In case you missed it,
       <a href="c02.xhtml">
        Chapter 2
       </a>
       , “Working with Strings and String Views,” provides all the details of the
       <code>
        string
       </code>
       and
       <code>
        string_view
       </code>
       classes and the string formatting library, while
       <a href="c21.xhtml">
        Chapter 21
       </a>
       , “String Localization and Regular Expressions,” discusses Unicode and localization.
      </p>
     </section>
     <section>
      <span id="c16-sec-0011">
      </span>
      <h3 id="head-3-359">
       Regular Expressions
      </h3>
      <p id="c16-para-0024">
       Regular expressions are available through functionality provided by
       <code>
        &lt;regex&gt;
       </code>
       . They make it easy to perform
       <i>
        pattern-matching
       </i>
       , often used in text processing. Pattern-matching allows you to search for special patterns in strings and optionally to replace them with a new pattern. Regular expressions are discussed in
       <a href="c21.xhtml">
        Chapter 21
       </a>
       .
      </p>
     </section>
     <section>
      <span id="c16-sec-0012">
      </span>
      <h3 id="head-3-360">
       I/O Streams
      </h3>
      <p id="c16-para-0025">
       C++ includes a model for input and output called
       <i>
        streams
       </i>
       . The C++ library provides routines for reading and writing built-in types from and to files, console/keyboard, and strings. C++ also provides the facilities for coding your own routines for reading and writing your own objects. Most of the I/O functionality is defined in
       <code>
        &lt;fstream&gt;
       </code>
       ,
       <code>
        &lt;iomanip&gt;
       </code>
       ,
       <code>
        &lt;ios&gt;
       </code>
       ,
       <code>
        &lt;iosfwd&gt;
       </code>
       ,
       <code>
        &lt;iostream&gt;
       </code>
       ,
       <code>
        &lt;istream&gt;
       </code>
       ,
       <code>
        &lt;ostream&gt;
       </code>
       ,
       <code>
        &lt;sstream&gt;
       </code>
       ,
       <code>
        &lt;streambuf&gt;
       </code>
       , and
       <code>
        &lt;strstream&gt;
       </code>
       . C++23 introduces span-based streams, defined in
       <code>
        &lt;spanstream&gt;
       </code>
       .
       <a href="c01.xhtml">
        Chapter 1
       </a>
       , “A Crash Course in C++ and the Standard Library,” reviews the basics of I/O streams, and
       <a href="c13.xhtml">
        Chapter 13
       </a>
       , “Demystifying C++ I/O,” discusses streams in detail.
      </p>
     </section>
     <section>
      <span id="c16-sec-0013">
      </span>
      <h3 id="head-3-361">
       Smart Pointers
      </h3>
      <p id="c16-para-0026">
       One of the problems faced in robust programming is knowing when to delete an object. There are several failures that can happen. A first problem is not deleting the object at all (failing to free the storage). These are known as
       <i>
        memory leaks
       </i>
       , where objects accumulate and take up space but are not used. Another problem is where a piece of code deletes the storage while another piece of code is still pointing to that storage, resulting in pointers to storage that either is no longer in use or has been reallocated for another purpose. These are known as
       <i>
        dangling pointers
       </i>
       . Yet another problem is when one piece of code frees the storage and another piece of code attempts to free the same storage again. This is known as
       <i>
        double deletion
       </i>
       .
      </p>
      <p id="c16-para-0027">
       All of these problems tend to result in program failures of some sort. Some failures are readily detected and might crash your application; others cause the program to produce erroneous results. Most of these errors are difficult to discover and repair.
      </p>
      <p id="c16-para-0028">
       C++ addresses all these problems with smart pointers:
       <code>
        unique_ptr
       </code>
       ,
       <code>
        shared_ptr
       </code>
       , and
       <code>
        weak_ptr
       </code>
       , all defined in
       <code>
        &lt;memory&gt;
       </code>
       . These smart pointers are discussed in
       <a href="c07.xhtml">
        Chapter 7
       </a>
       , “Memory Management.”
      </p>
     </section>
     <span aria-label="623" epub:type="pagebreak" id="Page_623" role="doc-pagebreak">
     </span>
     <section>
      <span id="c16-sec-0014">
      </span>
      <h3 id="head-3-362">
       Exceptions
      </h3>
      <p id="c16-para-0029">
       The C++ language supports exceptions, which allow functions to pass errors of various types up to calling functions. The C++ Standard Library provides a class hierarchy of exceptions that you can use in your code as is, or that you can derive from to create your own exception types. Most of the exception support is defined in
       <code>
        &lt;exception&gt;
       </code>
       ,
       <code>
        &lt;stdexcept&gt;
       </code>
       , and
       <code>
        &lt;system_error&gt;
       </code>
       .
       <a href="c14.xhtml">
        Chapter 14
       </a>
       , “Handling Errors,” covers the details of exceptions and the standard exception classes.
      </p>
     </section>
     <section>
      <span id="c16-sec-0015">
      </span>
      <h3 id="head-3-363">
       Standard Integer Types
      </h3>
      <p id="c16-para-0030">
       The
       <code>
        &lt;cstdint&gt;
       </code>
       header file defines a number of standard integer types such as
       <code>
        int
        <i>
         x
        </i>
        _t
       </code>
       and
       <code>
        uint
        <i>
         x
        </i>
        _t
       </code>
       with
       <i>
        <code>
         x
        </code>
       </i>
       equal to 8, 16, 32, or 64. It also includes macros specifying minimum and maximum values of those types. These integer types are discussed in the context of writing cross-platform code in
       <a href="c34.xhtml">
        Chapter 34
       </a>
       , “Developing Cross-Platform and Cross-Language Applications.”
      </p>
     </section>
     <section>
      <span id="c16-sec-0016">
      </span>
      <h3 id="head-3-364">
       Numerics Library
      </h3>
      <p id="c16-para-0031">
       The C++ Standard Library provides a collection of mathematical utility classes and functions.
      </p>
      <p id="c16-para-0032">
       A whole range of common mathematical functions is available, such as
       <code>
        abs()
       </code>
       ,
       <code>
        remainder()
       </code>
       ,
       <code>
        fma()
       </code>
       ,
       <code>
        exp()
       </code>
       ,
       <code>
        log()
       </code>
       ,
       <code>
        pow()
       </code>
       ,
       <code>
        sqrt()
       </code>
       ,
       <code>
        sin()
       </code>
       ,
       <code>
        atan2()
       </code>
       ,
       <code>
        sinh()
       </code>
       ,
       <code>
        erf()
       </code>
       ,
       <code>
        tgamma()
       </code>
       ,
       <code>
        ceil()
       </code>
       ,
       <code>
        floor()
       </code>
       , and more. The library also supports a number of mathematical special functions to work with Legendre polynomials, beta functions, elliptic integrals, Bessel functions, cylindrical Neumann functions, and so on. These special functions have established names and notations and are often used in mathematical analysis, functional analysis, geometry, physics, and other applications. The
       <code>
        lerp()
       </code>
       function calculates a linear interpolation or extrapolation:
       <code>
        lerp(a,b,t)
       </code>
       calculates
       <i>
        a
       </i>
       +
       <i>
        t
       </i>
       (
       <i>
        b
       </i>
       -
       <i>
        a
       </i>
       ). Linear interpolation calculates a certain value between given data points, while extrapolation calculates values that are either lower or higher than the minimum or maximum data point. Most of these functions are defined in
       <code>
        &lt;cmath&gt;
       </code>
       , some in
       <code>
        &lt;cstdlib&gt;
       </code>
       .
      </p>
      <p id="c16-para-0033">
       <code>
        &lt;numeric&gt;
       </code>
       defines
       <code>
        gcd()
       </code>
       and
       <code>
        lcm()
       </code>
       that calculate the
       <i>
        greatest common divisor
       </i>
       and
       <i>
        least common multiple
       </i>
       of two integer types, respectively. The
       <code>
        midpoint()
       </code>
       function calculates the midpoint of two values (integers, floating-point numbers, or pointers).
      </p>
      <p id="c16-para-0034">
       Starting with C++23, quite a few of these functions are marked as
       <code>
        constexpr
       </code>
       (see
       <a href="c09.xhtml">
        Chapter 9
       </a>
       ), so they can be used to perform compile-time computations. Consult your favorite Standard Library reference to learn exactly which functions are
       <code>
        constexpr
       </code>
       .
      </p>
      <p id="c16-para-0035">
       There is a complex number class called
       <code>
        complex
       </code>
       , defined in
       <code>
        &lt;complex&gt;
       </code>
       , which provides an abstraction for working with numbers that contain both real and imaginary components.
      </p>
      <p id="c16-para-0036">
       The compile-time rational arithmetic library provides a
       <code>
        ratio
       </code>
       class template, defined in
       <code>
        &lt;ratio&gt;
       </code>
       . This
       <code>
        ratio
       </code>
       class template can exactly represent any finite rational number defined by a numerator and denominator. This library is discussed in
       <a href="c22.xhtml">
        Chapter 22
       </a>
       , “Date and Time Utilities.”
      </p>
      <p id="c16-para-0037">
       The Standard Library also contains a class called
       <code>
        valarray
       </code>
       , defined in
       <code>
        &lt;valarray&gt;
       </code>
       , which is similar to
       <code>
        vector
       </code>
       but is more optimized for high-performance numerical applications. The library provides several related classes to represent the concept of vector slices. From these building blocks, it is possible to build classes to perform matrix mathematics. There is no built-in matrix class; however, there
       <span aria-label="624" epub:type="pagebreak" id="Page_624" role="doc-pagebreak">
       </span>
       are third-party libraries like Boost that include matrix support. The
       <code>
        valarray
       </code>
       class is not further discussed in this book.
      </p>
      <p id="c16-para-0038">
       A selection of often-used mathematical constants is available, all defined in
       <code>
        &lt;numbers&gt;
       </code>
       in the
       <code>
        std::numbers
       </code>
       namespace. Here are just a few of the available constants:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          CONSTANT
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
         <th class="left bgcolor2" scope="col">
          APPROXIMATION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           pi
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          The value of pi (π)
         </td>
         <td class="left bor1 bgcolor3">
          3.141592653589793
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           inv_pi
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          The inverse of pi
         </td>
         <td class="left bor1 bgcolor3">
          0.3183098861837907
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           sqrt2
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          The square root of 2
         </td>
         <td class="left bor1 bgcolor3">
          1.4142135623730951
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           e
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Euler's number e
         </td>
         <td class="left bor1 bgcolor3">
          2.718281828459045
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           phi
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          The golden ratio
         </td>
         <td class="left bor1 bgcolor3">
          1.618033988749895
         </td>
        </tr>
       </tbody>
      </table>
     </section>
     <section>
      <span id="c16-sec-0017">
      </span>
      <h3 id="head-3-365">
       Integer Comparisons
      </h3>
      <p id="c16-para-0040">
       The following comparison functions are available:
       <code>
        std::cmp_equal()
       </code>
       ,
       <code>
        cmp_not_equal()
       </code>
       ,
       <code>
        cmp_less()
       </code>
       ,
       <code>
        cmp_less_equal()
       </code>
       ,
       <code>
        cmp_greater()
       </code>
       , and
       <code>
        cmp_greater_equal()
       </code>
       , all defined in
       <code>
        &lt;utility&gt;
       </code>
       . These perform comparisons of two integers and are safe to use on mixed signed and unsigned comparisons.
      </p>
      <p>
       For example, the following code compares the signed value
       <code>
        -1
       </code>
       and the unsigned value
       <code>
        0u
       </code>
       using
       <code>
        operator&gt;
       </code>
       . The output is
       <code>
        1
       </code>
       (= true), because the -1 is first converted to an unsigned integer and hence becomes a big number such as 4,294,967,295, which is definitely greater than 0:
      </p>
      <pre id="c16-code-0001"><code>println("{}", (-1&gt; 0u));            <span class="color3">// true</span></code></pre>
      <p>
       Use
       <code>
        cmp_greater()
       </code>
       to get the correct output:
      </p>
      <pre id="c16-code-0002"><code>println("{}", <b>cmp_greater</b>(-1, 0u));  <span class="color3">// false</span></code></pre>
     </section>
     <section>
      <span id="c16-sec-0018">
      </span>
      <h3 id="head-3-366">
       Bit Manipulation
      </h3>
      <p id="c16-para-0043">
       The Standard Library supports the following functions to work with bits, all defined in
       <code>
        &lt;bit&gt;
       </code>
       . All of these functions require an unsigned integral type as first argument:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          FUNCTION
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           has_single_bit()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns
          <code>
           true
          </code>
          if a given value contains only a single bit, that is, is an integral power of two.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           bit_ceil()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns the smallest integral power of two greater than or equal to a given value.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           bit_floor()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns the largest integral power of two smaller than or equal to a given value.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           bit_width()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns the number of bits needed to store a given value.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           rotl()
          </code>
          <br/>
          <code>
           rotr()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Rotates the bits of a given value to the left or right respectively over a given number of positions.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           countl_zero()
          </code>
          <br/>
          <code>
           countl_one()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns the number of consecutive zero or one bits respectively in a given value starting from the left, that is, starting with the most-significant bit.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           countr_zero()
          </code>
          <br/>
          <code>
           countr_one()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns the number of consecutive zero or one bits, respectively, in a given value starting from the right, that is, starting with the least-significant bit.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           popcount()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns the number of one bits in a given value.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <img alt="C++23" src="../images\images/icon1.png"/>
          <code>
           byteswap()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Reverses the individual bytes of integral types.
          <span aria-label="625" epub:type="pagebreak" id="Page_625" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       Here are a few examples:
      </p>
      <pre id="c16-code-0003"><code>println("{}", <b>popcount</b>(0b10101010u)); <span class="color3">// 4</span></code>
<code> </code>
<code>uint8_t value { 0b11101011u };</code>
<code>println("{}", <b>countl_one</b>(value));     <span class="color3">// 3</span></code>
<code>println("{}", <b>countr_one</b>(value));     <span class="color3">// 2</span></code>
<code> </code>
<code>value = 0b10001000u;</code>
<code>println("{:08b}", <b>rotl</b>(value, 2));    <span class="color3">// 00100010</span></code>
<code> </code>
<code>value = 0b00001011u;</code>
<code>println("bit_ceil({0:08b} = {0}) = {1:08b} = {1}",</code>
<code>    value, <b>bit_ceil</b>(value));          <span class="color3">// bit_ceil(00001011 = 11) = 00010000 = 16</span></code>
<code>println("bit_floor({0:08b} = {0}) = {1:08b} = {1}",</code>
<code>    value, <b>bit_floor</b>(value));         <span class="color3">// bit_floor(00001011 = 11) = 00001000 = 8</span></code>
<code> </code>
<code>uint32_t before { 0x12345678u };</code>
<code>println("{:x}", before);              <span class="color3">// 12345678</span></code>
<code>uint32_t after { <b>byteswap</b>(before) };  <span class="color3">// C++23 std::byteswap().</span></code>
<code>println("{:x}", after);               <span class="color3">// 78563412</span></code></pre>
     </section>
     <section>
      <span id="c16-sec-0019">
      </span>
      <h3 id="head-3-367">
       Time and Date Utilities
      </h3>
      <p id="c16-para-0055">
       The Standard Library includes the chrono library, defined in
       <code>
        &lt;chrono&gt;
       </code>
       . This library makes it easy to work with dates and time, to time certain durations, and more. The library supports calendars to work with dates, and time zones, including functionality to convert times between different time zones. The
       <code>
        &lt;ctime&gt;
       </code>
       header provides a number of C-style time and date utilities.
      </p>
      <p id="c16-para-0056">
       <a href="c22.xhtml">
        Chapter 22
       </a>
       discusses the time and date utilities in detail.
      </p>
     </section>
     <section>
      <span id="c16-sec-0020">
      </span>
      <h3 id="head-3-368">
       Random Numbers
      </h3>
      <p id="c16-para-0057">
       C++ already has support for generating pseudo-random numbers for a long time with the
       <code>
        srand()
       </code>
       and
       <code>
        rand()
       </code>
       functions. However, those functions provide only low-quality basic random numbers. For example, you cannot change the distribution of the generated random numbers.
      </p>
      <p id="c16-para-0058">
       <span aria-label="626" epub:type="pagebreak" id="Page_626" role="doc-pagebreak">
       </span>
       Since C++11, a powerful random number generation library is available. This library is defined in
       <code>
        &lt;random&gt;
       </code>
       and comes with
       <i>
        random number engines
       </i>
       ,
       <i>
        random number engine adapters
       </i>
       , and
       <i>
        random number distributions
       </i>
       . These can be used to generate high-quality random numbers and support different distributions, such as normal distributions, negative exponential distributions, and so on.
      </p>
      <p id="c16-para-0059">
       Consult
       <a href="c23.xhtml">
        Chapter 23
       </a>
       , “Random Number Facilities,” for details on this library.
      </p>
     </section>
     <section>
      <span id="c16-sec-0021">
      </span>
      <h3 id="head-3-369">
       Initializer Lists
      </h3>
      <p id="c16-para-0060">
       Initializer lists are defined in
       <code>
        &lt;initializer_list&gt;
       </code>
       . They make it easy to write functions that can accept a variable number of arguments and are discussed in
       <a href="c01.xhtml">
        Chapter 1
       </a>
       .
      </p>
     </section>
     <section>
      <span id="c16-sec-0022">
      </span>
      <h3 id="head-3-370">
       Pair and Tuple
      </h3>
      <p id="c16-para-0061">
       <code>
        &lt;utility&gt;
       </code>
       defines the
       <code>
        pair
       </code>
       class template, which can store two elements of possibly different types. This is known as storing
       <i>
        heterogeneous
       </i>
       elements. All Standard Library containers discussed further in this chapter store
       <i>
        homogeneous
       </i>
       elements, meaning that all the elements in the container must have the same type. A
       <code>
        pair
       </code>
       allows you to store exactly two elements of completely unrelated types in one object. The
       <code>
        pair
       </code>
       class template is introduced in
       <a href="c01.xhtml">
        Chapter 1
       </a>
       .
      </p>
      <p id="c16-para-0062">
       <code>
        tuple
       </code>
       , defined in
       <code>
        &lt;tuple&gt;
       </code>
       , is a generalization of
       <code>
        pair
       </code>
       . It is a sequence with a fixed size that can have heterogeneous elements. The number and type of elements for a
       <code>
        tuple
       </code>
       instantiation is fixed at compile time. Tuples are discussed in
       <a href="c24.xhtml">
        Chapter 24
       </a>
       , “Additional Vocabulary Types.”
      </p>
     </section>
     <section>
      <span id="c16-sec-0023">
      </span>
      <h3 id="head-3-371">
       Vocabulary Types
      </h3>
      <p id="c16-para-0063">
       <i>
        Vocabulary types
       </i>
       are types that you will use all the time, just as much as primitive types such as
       <code>
        int
       </code>
       and
       <code>
        double
       </code>
       . Using vocabulary types makes your code safer, more efficient, and easier to write, read, and maintain. Examples of vocabulary types discussed earlier in this book are
       <code>
        vector
       </code>
       ,
       <code>
        optional
       </code>
       ,
       <code>
        string
       </code>
       ,
       <code>
        unique_ptr
       </code>
       ,
       <code>
        shared_ptr
       </code>
       , and so on.
      </p>
      <p>
       <a href="c24.xhtml">
        Chapter 24
       </a>
       discusses the following additional vocabulary types:
      </p>
      <ul class="check1" id="c16-list-0003">
       <li id="c16-li-0005">
        <b>
         <code>
          variant
         </code>
        </b>
        , defined in
        <code>
         &lt;variant&gt;
        </code>
        , can hold a single value of one of a given set of types.
       </li>
       <li id="c16-li-0006">
        <b>
         <code>
          any
         </code>
        </b>
        , defined in
        <code>
         &lt;any&gt;
        </code>
        , can hold a single value of any type.
       </li>
       <li id="c16-li-0007">
        <b>
         <code>
          tuple
         </code>
        </b>
        , defined in
        <code>
         &lt;tuple&gt;
        </code>
        , is a generalization of
        <code>
         pair
        </code>
        . It can store any number of values, each with its own specific type.
       </li>
       <li id="c16-li-0008">
        <b>
         <code>
          optional
         </code>
        </b>
        , defined in
        <code>
         &lt;optional&gt;
        </code>
        , holds a value of a specific type or nothing. It can be used for class data members, function parameters, return types of a function, and so on, if you want to allow for values to be optional. It is introduced in
        <a href="c01.xhtml">
         Chapter 1
        </a>
        .
        <a href="c24.xhtml">
         Chapter 24
        </a>
        explains that
        <code>
         optional
        </code>
        s support monadic operations, allowing you to easily chain operations on
        <code>
         optional
        </code>
        s without having to worry whether an
        <code>
         optional
        </code>
        is empty before applying another operation to it.
       </li>
      </ul>
      <ul class="check1" id="c16-list-0004">
       <li id="c16-li-0009">
        <img alt="C++23" src="../images\images/icon1.png"/>
        <b>
         <code>
          expected
         </code>
        </b>
        , defined in
        <code>
         &lt;expected&gt;
        </code>
        , holds a value of a specific type, or an error value of a, possibly different, type. This can be useful as the return type of a function because it allows the function to return either the requested data back to the caller or the reason why something went wrong.
       </li>
      </ul>
     </section>
     <span aria-label="627" epub:type="pagebreak" id="Page_627" role="doc-pagebreak">
     </span>
     <section>
      <span id="c16-sec-0024">
      </span>
      <h3 id="head-3-372">
       Function Objects
      </h3>
      <p id="c16-para-0066">
       A class that implements a function call operator is called a
       <i>
        function object
       </i>
       . Function objects can, for example, be used as predicates for certain Standard Library algorithms.
       <code>
        &lt;functional&gt;
       </code>
       defines a number of predefined function objects and supports creating new function objects based on existing ones.
      </p>
      <p id="c16-para-0067">
       Function objects are discussed in detail in
       <a href="c19.xhtml">
        Chapter 19
       </a>
       , “Function Pointers, Function Objects, and Lambda Expressions.”
      </p>
     </section>
     <section>
      <span id="c16-sec-0025">
      </span>
      <h3 id="head-3-373">
       Filesystem
      </h3>
      <p id="c16-para-0068">
       Everything for the filesystem support library is defined in
       <code>
        &lt;filesystem&gt;
       </code>
       and lives in the
       <code>
        std::filesystem
       </code>
       namespace. It allows you to write portable code to work with a filesystem. You can use it for querying whether something is a directory or a file, iterating over the contents of a directory, manipulating paths, and retrieving information about files such as their size, extension, creation time, and so on. The filesystem support library is discussed in
       <a href="c13.xhtml">
        Chapter 13
       </a>
       .
      </p>
     </section>
     <section>
      <span id="c16-sec-0026">
      </span>
      <h3 id="head-3-374">
       Multithreading
      </h3>
      <p id="c16-para-0069">
       All major CPU vendors are selling processors with multiple cores. They are being used for everything from servers to consumer computers and even smartphones. If you want your software to take advantage of all these cores, then you need to write multithreaded code. The Standard Library provides a couple of basic building blocks for writing such code. Individual threads can be created using the
       <code>
        thread
       </code>
       class from
       <code>
        &lt;thread&gt;
       </code>
       . The library also defines
       <code>
        jthread
       </code>
       , a thread that can be cancelled and that automatically performs a join operation when it is destructed.
      </p>
      <p id="c16-para-0070">
       In multithreaded code you need to take care that several threads are not reading and writing to the same piece of data at the same time, because that will cause data races. To prevent this, you can use atomics, defined in
       <code>
        &lt;atomic&gt;
       </code>
       , which give you thread-safe atomic access to a piece of data. Other thread synchronization mechanisms are provided by
       <code>
        &lt;condition_variable&gt;
       </code>
       and
       <code>
        &lt;mutex&gt;
       </code>
       . There is also support for the following synchronization primitives: semaphores (
       <code>
        &lt;semaphore&gt;
       </code>
       ), latches (
       <code>
        &lt;latch&gt;
       </code>
       ), and barriers (
       <code>
        &lt;barrier&gt;
       </code>
       ).
      </p>
      <p id="c16-para-0071">
       If you just need to calculate something, possibly on a different thread, and get the result back with proper exception handling, you can use
       <code>
        async
       </code>
       and
       <code>
        future
       </code>
       . These are defined in
       <code>
        &lt;future&gt;
       </code>
       and are easier to use than directly using
       <code>
        thread
       </code>
       or
       <code>
        jthread
       </code>
       .
      </p>
      <p id="c16-para-0072">
       Writing multithreaded code is discussed in detail in
       <a href="c27.xhtml">
        Chapter 27
       </a>
       , “Multithreaded Programming with C++.”
      </p>
     </section>
     <section>
      <span id="c16-sec-0027">
      </span>
      <h3 id="head-3-375">
       Type Traits
      </h3>
      <p id="c16-para-0073">
       Type traits are defined in
       <code>
        &lt;type_traits&gt;
       </code>
       and provide information about types at compile time. They are useful when writing advanced templates and are discussed in
       <a href="c26.xhtml">
        Chapter 26
       </a>
       , “Advanced Templates.”
      </p>
     </section>
     <section>
      <span id="c16-sec-0028">
      </span>
      <h3 id="head-3-376">
       Standard Library Feature-Test Macros
      </h3>
      <p>
       <i>
        Feature-test macros
       </i>
       are available for Standard Library features. These are similar to the feature-test macros for core language features (discussed in
       <a href="c11.xhtml">
        Chapter 11
       </a>
       , “Modules, Header Files, and
       <span aria-label="628" epub:type="pagebreak" id="Page_628" role="doc-pagebreak">
       </span>
       Miscellaneous Topics”) and allow you to verify whether a certain feature is supported by your Standard Library implementation. All these macros start with
       <code>
        __cpp_lib_
       </code>
       . The following lists a few examples. Consult your favorite Standard Library Reference for a complete list of all possible Standard Library feature-test macros.
      </p>
      <ul class="check1" id="c16-list-0005">
       <li id="c16-li-0010">
        <code>
         __cpp_lib_concepts
        </code>
       </li>
       <li id="c16-li-0011">
        <code>
         __cpp_lib_ranges
        </code>
       </li>
       <li id="c16-li-0012">
        <code>
         __cpp_lib_scoped_lock
        </code>
       </li>
       <li id="c16-li-0013">
        <code>
         __cpp_lib_atomic_float
        </code>
       </li>
       <li id="c16-li-0014">
        <code>
         __cpp_lib_constexpr_vector
        </code>
       </li>
       <li id="c16-li-0015">
        <code>
         __cpp_lib_constexpr_tuple
        </code>
       </li>
       <li id="c16-li-0016">
        <code>
         __cpp_lib_filesystem
        </code>
       </li>
       <li id="c16-li-0017">
        <code>
         __cpp_lib_three_way_comparison
        </code>
       </li>
       <li id="c16-li-0018">
        …
       </li>
      </ul>
      <p id="c16-para-0075">
       The value of such a macro is a number representing the month and year when a specific feature was added or updated. The date is formatted as
       <code>
        YYYYMM
       </code>
       . For example, the value of
       <code>
        __cpp_lib_filesystem
       </code>
       is 201703, i.e., March 2017.
      </p>
      <p>
       As
       <a href="c11.xhtml">
        Chapter 11
       </a>
       explains, the core language feature-test macros are always available for you to use, without having to include any header. However, the Standard Library feature-test macros are defined in
       <code>
        &lt;version&gt;
       </code>
       . As all feature-test macros are macros, you know from
       <a href="c11.xhtml">
        Chapter 11
       </a>
       that importing the named module
       <code>
        std
       </code>
       or
       <code>
        std.compat
       </code>
       will not make those macros available to your code.
       <a href="c11.xhtml">
        Chapter 11
       </a>
       also explains that all C++ headers, such as
       <code>
        &lt;version&gt;
       </code>
       , are importable; thus, you have two options to get access to the macros defined in
       <code>
        &lt;version&gt;
       </code>
       :
      </p>
      <pre id="c16-code-0004"><code>import &lt;version&gt;;</code></pre>
      <p>
       or
      </p>
      <pre id="c16-code-0005"><code>#include &lt;version&gt;</code></pre>
      <p>
       Here is a full example:
      </p>
      <pre id="c16-code-0006"><code>import std;</code>
<code><b>import &lt;version&gt;;</b> <span class="color3">// Important to get access to the feature-test macros!</span></code>
<code>using namespace std;</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>#ifdef __cpp_lib_constexpr_vector</code>
<code>    println("std::vector is constexpr!");</code>
<code>#else</code>
<code>    println("Bummer! std::vector is NOT constexpr!");</code>
<code>#endif</code>
<code>}</code></pre>
      <p>
       <span aria-label="629" epub:type="pagebreak" id="Page_629" role="doc-pagebreak">
       </span>
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c16-para-0080">
          <b>
           NOTE
          </b>
          <i>
           You will rarely need these feature-test macros, unless you are writing cross-platform and cross-compiler code. In that case, you might want to know if certain functionality is supported by a given Standard Library implementation so that you can provide fallback code in case a feature is missing
          </i>
          .
          <a href="c34.xhtml">
           <i>
            Chapter
           </i>
           34
          </a>
          <i>
           , “Developing Cross-Platform and Cross-Language Applications,” discusses cross-platform development
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c16-sec-0030">
      </span>
      <h3 id="head-3-377">
       &lt;version&gt;
      </h3>
      <p id="c16-para-0081">
       <code>
        &lt;version&gt;
       </code>
       can be used to query for implementation-dependent information about the C++ Standard Library that you are using. What exactly your
       <code>
        &lt;version&gt;
       </code>
       provides depends on your library implementation. The following could possibly be exposed: version number, release date, and copyright notice.
      </p>
      <p id="c16-para-0082">
       Additionally, as explained in the previous section,
       <code>
        &lt;version&gt;
       </code>
       exposes all Standard Library feature-test macros.
      </p>
     </section>
     <section>
      <span id="c16-sec-0031">
      </span>
      <h3 id="head-3-378">
       Source Location
      </h3>
      <p id="c16-para-0083">
       <code>
        std::source:location
       </code>
       , defined in
       <code>
        &lt;source:location&gt;
       </code>
       , can be used to query information about your source code, such as filename, function name, line number, and column number, and replaces the old C-style macros
       <code>
        __FILE__
       </code>
       and
       <code>
        __LINE__
       </code>
       . Example use cases are to provide source code information when logging messages or when throwing exceptions.
       <a href="c14.xhtml">
        Chapter 14
       </a>
       gives an example of both these use cases.
      </p>
     </section>
     <section>
      <span id="c16-sec-0032">
      </span>
      <h3 id="head-3-379">
       <img alt="C++23" src="../images\images/icon1.png"/>
       Stack Trace
      </h3>
      <p id="c16-para-0085">
       <code>
        &lt;stacktrace&gt;
       </code>
       defines the
       <code>
        std::stacktrace
       </code>
       and
       <code>
        std::stacktrace:entry
       </code>
       classes. These can be used to get a stack trace at any given moment in time and to iterate and inspect each individual entry, known as a
       <i>
        frame
       </i>
       . See
       <a href="c14.xhtml">
        Chapter 14
       </a>
       for an example.
      </p>
     </section>
     <section>
      <span id="c16-sec-0033">
      </span>
      <h3 id="head-3-380">
       Containers
      </h3>
      <p id="c16-para-0086">
       The Standard Library provides implementations of commonly used data structures such as linked lists and queues. When you use C++, you should not need to write such data structures again. The data structures are implemented using a concept called
       <i>
        containers
       </i>
       , which store information called
       <i>
        elements
       </i>
       , in a way that implements the data structure (linked list, queue, and so on) appropriately. Different data structures have different insertion, deletion, and access behavior and performance characteristics. It is important to be familiar with the available data structures so that you can choose the most appropriate one for any given task.
      </p>
      <p>
       All the containers in the Standard Library are class templates, so you can use them to store any type, from built-in types such as
       <code>
        int
       </code>
       and
       <code>
        double
       </code>
       to your own classes. Each container instance stores objects of only one type; that is, they are
       <i>
        homogeneous collections
       </i>
       . If you need non-fixed-sized
       <span aria-label="630" epub:type="pagebreak" id="Page_630" role="doc-pagebreak">
       </span>
       heterogeneous collections, you can wrap each element in an
       <code>
        std::any
       </code>
       instance and store those
       <code>
        any
       </code>
       instances in a container. Alternatively, you can store
       <code>
        std::variant
       </code>
       instances in a container. A
       <code>
        variant
       </code>
       can be used if the number of different required types is limited and known at compile time. Or you can create a class that has multiple derived classes, and each derived class can wrap an object of your required type. Both
       <code>
        any
       </code>
       and
       <code>
        variant
       </code>
       are discussed in
       <a href="c24.xhtml">
        Chapter 24
       </a>
       .
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c16-para-0088">
          <b>
           NOTE
          </b>
          <i>
           The C++ Standard Library containers are homogeneous: they allow elements of only one type in each container
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c16-para-0089">
       The C++ standard specifies the
       <i>
        interface
       </i>
       , but not the
       <i>
        implementation
       </i>
       , of each container and algorithm. Thus, different vendors are free to provide different implementations. However, the standard also specifies performance requirements as part of the interface, which the implementations must meet.
      </p>
      <p id="c16-para-0090">
       This section provides an overview of the various containers available in the Standard Library.
      </p>
      <section>
       <span id="c16-sec-0035">
       </span>
       <h4 id="head-4-253">
        Sequential Containers
       </h4>
       <p id="c16-para-0091">
        The Standard Library provides five sequential containers:
        <code>
         vector
        </code>
        ,
        <code>
         list
        </code>
        ,
        <code>
         forward_list
        </code>
        ,
        <code>
         deque
        </code>
        , and
        <code>
         array
        </code>
        .
       </p>
       <section>
        <span id="c16-sec-0036">
        </span>
        <h5 id="head-5-91">
         vector
        </h5>
        <p>
         <code>
          vector
         </code>
         is defined in
         <code>
          &lt;vector&gt;
         </code>
         and stores a sequence of elements while providing random access to these elements. You can think of a
         <code>
          vector
         </code>
         as an array of elements that grows dynamically as you insert elements and additionally provides some bounds checking. Like an array, the elements of a
         <code>
          vector
         </code>
         are stored in contiguous memory.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0093">
            <b>
             NOTE
            </b>
            <i>
             A
            </i>
            <code>
             vector
            </code>
            <i>
             in C++ is a synonym for a dynamic array: an array that grows and shrinks automatically in response to the number of elements it stores.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c16-para-0094">
         <code>
          vector
         </code>
         provides fast element insertion and deletion (amortized constant time) at the end of the
         <code>
          vector
         </code>
         . Amortized constant time insertion means that most of the time insertions are done in constant time
         <i>
          O
         </i>
         (1) (
         <a href="c04.xhtml">
          Chapter 4
         </a>
         , “Designing Professional C++ Programs,” explains big-O notation). However, sometimes the
         <code>
          vector
         </code>
         needs to grow in size to accommodate new elements, which has a complexity of
         <i>
          O
         </i>
         (
         <i>
          N
         </i>
         ). On average, this results in
         <i>
          O
         </i>
         (1) complexity or amortized constant time. Details are explained in
         <a href="c18.xhtml">
          Chapter 18
         </a>
         , “Standard Library Containers.” A
         <code>
          vector
         </code>
         has slower (linear time) insertion and deletion anywhere else, because the operation must move all the elements “up” or “down” by one to make room for the new element or to fill the space left by the deleted element. Like arrays,
         <code>
          vector
         </code>
         s provide fast (constant time) access to any of their elements.
        </p>
        <p>
         Even though inserting and removing elements in the middle of a
         <code>
          vector
         </code>
         requires moving other elements up or down, a
         <code>
          vector
         </code>
         should be your default container! Often, a
         <code>
          vector
         </code>
         will be faster than, for example, a linked list, even for inserting and removing elements in the middle. The reason is that a
         <span aria-label="631" epub:type="pagebreak" id="Page_631" role="doc-pagebreak">
         </span>
         <code>
          vector
         </code>
         is stored contiguously in memory, while a linked list is scattered around in memory. Computers are extremely efficient to work with contiguous data, which makes
         <code>
          vector
         </code>
         operations fast. You should only use something like a linked list if a performance profiler (discussed in
         <a href="c29.xhtml">
          Chapter 29
         </a>
         , “Writing Efficient C++”) tells you that it performs better than a
         <code>
          vector
         </code>
         .
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0096">
            <b>
             NOTE
            </b>
            <i>
             The
            </i>
            <code>
             vector
            </code>
            <i>
             container should be your default container.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c16-para-0097">
         There is a template specialization available for
         <code>
          vector&lt;bool&gt;
         </code>
         to store Boolean values in a
         <code>
          vector
         </code>
         . This specialization optimizes space allocation for the Boolean elements; however, the standard does not specify how an implementation of
         <code>
          vector&lt;bool&gt;
         </code>
         should optimize space. The difference between the
         <code>
          vector&lt;bool&gt;
         </code>
         specialization and the
         <code>
          bitset
         </code>
         discussed later in this chapter is that the
         <code>
          bitset
         </code>
         container is of fixed size, while
         <code>
          vector&lt;bool&gt;
         </code>
         automatically grows or shrinks when needed.
        </p>
       </section>
       <section>
        <span id="c16-sec-0039">
        </span>
        <h5 id="head-5-92">
         list
        </h5>
        <p id="c16-para-0098">
         <code>
          list
         </code>
         is a
         <i>
          doubly linked list
         </i>
         structure and is defined in
         <code>
          &lt;list&gt;
         </code>
         . Like an array or
         <code>
          vector
         </code>
         , it stores a sequence of elements. However, unlike an array or
         <code>
          vector
         </code>
         , the elements of a
         <code>
          list
         </code>
         are not necessarily contiguous in memory. Instead, each element in the
         <code>
          list
         </code>
         specifies where to find the next and previous elements in the
         <code>
          list
         </code>
         (usually via pointers), which is why it's called a
         <i>
          doubly linked list
         </i>
         .
        </p>
        <p id="c16-para-0099">
         The performance characteristics of a
         <code>
          list
         </code>
         are the exact opposite of a
         <code>
          vector
         </code>
         . They provide slow (linear time) element lookup and access, but quick (constant time) insertion and deletion of elements once the relevant position has been found. Still, as discussed in the previous section, a
         <code>
          vector
         </code>
         is usually faster than a
         <code>
          list
         </code>
         . Use a profiler (discussed in
         <a href="c29.xhtml">
          Chapter 29
         </a>
         ) to be sure.
        </p>
       </section>
       <section>
        <span id="c16-sec-0040">
        </span>
        <h5 id="head-5-93">
         forward_list
        </h5>
        <p id="c16-para-0100">
         <code>
          forward_list
         </code>
         , defined in
         <code>
          &lt;forward_list&gt;
         </code>
         , is a
         <i>
          singly linked list
         </i>
         , compared to the
         <code>
          list
         </code>
         container, which is doubly linked.
         <code>
          forward_list
         </code>
         supports forward iteration only and requires a bit less memory than a
         <code>
          list
         </code>
         . Like
         <code>
          list
         </code>
         ,
         <code>
          forward_list
         </code>
         allows constant-time insertion and deletion anywhere once the relevant position has been found, and there is no fast random access to elements.
        </p>
       </section>
       <section>
        <span id="c16-sec-0041">
        </span>
        <h5 id="head-5-94">
         deque
        </h5>
        <p id="c16-para-0101">
         The name
         <code>
          deque
         </code>
         is an abbreviation for a
         <i>
          double-ended queue
         </i>
         . A
         <code>
          deque
         </code>
         , defined in
         <code>
          &lt;deque&gt;
         </code>
         , provides quick (constant time) element access. It also provides fast (constant time) insertion and deletion at both ends of the sequence, but it provides slow (linear time) insertion and deletion in the middle of the sequence. The elements of a
         <code>
          deque
         </code>
         are not stored contiguously in memory, and thus a
         <code>
          deque
         </code>
         might be slower than a
         <code>
          vector
         </code>
         .
        </p>
        <p id="c16-para-0102">
         You could use a
         <code>
          deque
         </code>
         instead of a
         <code>
          vector
         </code>
         when you need to insert or remove elements from either end of the sequence but still need fast access to all elements. However, this requirement does not apply to many programming problems; in most cases, a
         <code>
          vector
         </code>
         is recommended.
        </p>
       </section>
       <section>
        <span id="c16-sec-0042">
        </span>
        <h5 id="head-5-95">
         array
        </h5>
        <p>
         <code>
          array
         </code>
         , defined in
         <code>
          &lt;array&gt;
         </code>
         , is a replacement for standard C-style arrays. Sometimes you know the exact number of elements in your container up front, and you don't need the flexibility of a
         <code>
          vector
         </code>
         <span aria-label="632" epub:type="pagebreak" id="Page_632" role="doc-pagebreak">
         </span>
         or a
         <code>
          list
         </code>
         , which are able to grow dynamically to accommodate new elements. An
         <code>
          array
         </code>
         is perfect for such fixed-sized collections, and it has a bit less overhead compared to a
         <code>
          vector
         </code>
         ; it's basically a thin wrapper around standard C-style arrays. There are a number of advantages in using
         <code>
          array
         </code>
         s instead of standard C-style arrays: they always know their own size and do not automatically get cast to a pointer to avoid certain types of bugs. Also,
         <code>
          array
         </code>
         s do not provide insertion or deletion; they have a fixed size. The advantage of having a fixed size is that this allows an
         <code>
          array
         </code>
         to be allocated on the stack, rather than always demanding access to the free store as
         <code>
          vector
         </code>
         does. Access to elements is very fast (constant time), just as with
         <code>
          vector
         </code>
         s.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0104">
            <b>
             NOTE
            </b>
            <i>
             The
            </i>
            <code>
             vector
            </code>
            <i>
             ,
            </i>
            <code>
             list
            </code>
            <i>
             ,
            </i>
            <code>
             forward_list
            </code>
            <i>
             ,
             <code>
              deque
             </code>
             , and
            </i>
            <code>
             array
            </code>
            <i>
             containers are called sequential containers because they store a sequence of elements.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section>
       <span id="c16-sec-0044">
       </span>
       <h4 id="head-4-254">
        Sequential Views
       </h4>
       <p id="c16-para-0105">
        The Standard Library provides two sequential views:
        <code>
         span
        </code>
        and
        <code>
         mdspan
        </code>
        .
       </p>
       <section>
        <span id="c16-sec-0045">
        </span>
        <h5 id="head-5-96">
         span
        </h5>
        <p>
         A
         <code>
          span
         </code>
         , defined in
         <code>
          &lt;span&gt;
         </code>
         , represents a view on a contiguous sequence of data. It can be either a read-only view or a view with read/write access to the underlying elements. A
         <code>
          span
         </code>
         allows you to write a single function that can work with data coming from, for example,
         <code>
          vector
         </code>
         s,
         <code>
          array
         </code>
         s, C-style arrays, and so on.
         <a href="c18.xhtml">
          Chapter 18
         </a>
         discusses
         <code>
          span
         </code>
         in more detail.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0107">
            <b>
             NOTE
            </b>
            <i>
             When writing a function accepting, for example, a
            </i>
            <code>
             const vector&lt;T&gt;&amp;
            </code>
            <i>
             , consider accepting a
            </i>
            <code>
             span&lt;const T&gt;
            </code>
            <i>
             instead, so the function can work with views and subviews of data sequences coming from
            </i>
            <code>
             vector
            </code>
            <i>
             s,
            </i>
            <code>
             array
            </code>
            <i>
             s, C-style arrays, and more
            </i>
            .
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section>
        <span id="c16-sec-0047">
        </span>
        <h5 id="head-5-97">
         <img alt="C++23" src="../images\images/icon1.png"/>
         mdspan
        </h5>
        <p id="c16-para-0109">
         An
         <code>
          mdspan
         </code>
         , defined in
         <code>
          &lt;mdspan&gt;
         </code>
         , is similar to a
         <code>
          span
         </code>
         but represents a multidimensional view on a contiguous sequence of data. Just as a
         <code>
          span
         </code>
         , it can be a read-only view or a view with read/write access to the underlying elements.
         <a href="c18.xhtml">
          Chapter 18
         </a>
         discusses
         <code>
          mdspan
         </code>
         in more detail.
        </p>
       </section>
      </section>
      <section>
       <span id="c16-sec-0048">
       </span>
       <h4 id="head-4-255">
        Container Adapters
       </h4>
       <p id="c16-para-0110">
        The Standard Library provides three nonassociative container adapters:
        <code>
         queue
        </code>
        ,
        <code>
         priority_queue
        </code>
        , and
        <code>
         stack
        </code>
        .
       </p>
       <section>
        <span id="c16-sec-0049">
        </span>
        <h5 id="head-5-98">
         queue
        </h5>
        <p id="c16-para-0111">
         The name
         <code>
          queue
         </code>
         comes directly from the definition of the English word
         <i>
          queue
         </i>
         , which means a line of people or objects. The
         <code>
          queue
         </code>
         container is defined in
         <code>
          &lt;queue&gt;
         </code>
         and provides standard
         <i>
          first in, first
          <span aria-label="633" epub:type="pagebreak" id="Page_633" role="doc-pagebreak">
          </span>
          out
         </i>
         (or FIFO) semantics. A
         <code>
          queue
         </code>
         is a container in which you insert elements at one end and take them out at the other end. Both insertion (amortized constant time) and removal (constant time) of elements are quick.
        </p>
        <p id="c16-para-0112">
         You should use a
         <code>
          queue
         </code>
         structure when you want to model real-life “first-come, first-served” semantics. For example, consider a bank. As customers arrive at the bank, they get in line. As tellers become available, they serve the next customer in line, thus providing “first-come, first-served” behavior. You could implement a bank simulation by storing customer objects in a
         <code>
          queue
         </code>
         . As customers arrive at the bank, they are added to the end of the
         <code>
          queue
         </code>
         . As tellers serve customers, they start with customers at the front of the
         <code>
          queue
         </code>
         .
        </p>
       </section>
       <section>
        <span id="c16-sec-0050">
        </span>
        <h5 id="head-5-99">
         priority_queue
        </h5>
        <p id="c16-para-0113">
         A
         <code>
          priority_queue
         </code>
         , also defined in
         <code>
          &lt;queue&gt;
         </code>
         , provides
         <code>
          queue
         </code>
         functionality in which each element has a priority. Elements are removed from the queue in priority order. In the case of priority ties, the order in which elements are removed is undefined.
         <code>
          priority_queue
         </code>
         insertion and deletion are generally slower than simple
         <code>
          queue
         </code>
         insertion and deletion, because the elements must be reordered to support the priority ordering.
        </p>
        <p id="c16-para-0114">
         You can use
         <code>
          priority_queue
         </code>
         s to model “queues with exceptions.” For example, in the earlier bank simulation, suppose that customers with business accounts take priority over regular customers. Many real-life banks implement this behavior with two separate lines: one for business customers and one for everyone else. Any customers in the business queue are taken before customers in the other line. However, banks could also provide this behavior with a single line in which business customers move to the front of the line ahead of any non-business customers. In your program, you could use a
         <code>
          priority_queue
         </code>
         in which customers have one of two priorities: business or regular. All business customers would be serviced before all regular customers.
        </p>
       </section>
       <section>
        <span id="c16-sec-0051">
        </span>
        <h5 id="head-5-100">
         stack
        </h5>
        <p id="c16-para-0115">
         <code>
          &lt;stack&gt;
         </code>
         defines the
         <code>
          stack
         </code>
         class, which provides standard
         <i>
          first-in, last-out
         </i>
         (FILO) semantics, also known as
         <i>
          last-in, first-out
         </i>
         (LIFO). Like a
         <code>
          queue
         </code>
         , elements are inserted and removed from the container. However, in a
         <code>
          stack
         </code>
         , the most recent element inserted is the first one removed. The name
         <code>
          stack
         </code>
         derives from a visualization of this structure as a stack of objects in which only the top object is visible. When you add an object to the stack, you hide all the objects underneath it.
        </p>
        <p>
         The
         <code>
          stack
         </code>
         container provides fast (constant time) insertion and removal of elements. You should use the
         <code>
          stack
         </code>
         structure when you want FILO semantics. For example, an error-processing tool might want to store errors on a
         <code>
          stack
         </code>
         so that the most recent error is the first one available for a human administrator to read. Processing errors in a FILO order is often useful because newer errors sometimes obviate older ones.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0117">
            <b>
             NOTE
            </b>
            <i>
             Technically, the
            </i>
            <code>
             queue
            </code>
            <i>
             ,
            </i>
            <code>
             priority_queue
            </code>
            <i>
             , and
            </i>
            <code>
             stack
            </code>
            <i>
             containers are container adapters. They are simple interfaces built on top of one of the standard sequential containers
            </i>
            <code>
             vector
            </code>
            <i>
             ,
            </i>
            <code>
             list
            </code>
            <i>
             , or
            </i>
            <code>
             deque
            </code>
            <i>
             .
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <span aria-label="634" epub:type="pagebreak" id="Page_634" role="doc-pagebreak">
      </span>
      <section>
       <span id="c16-sec-0053">
       </span>
       <h4 id="head-4-256">
        Ordered Associative Containers
       </h4>
       <p id="c16-para-0118">
        The Standard Library provides four ordered associative containers:
        <code>
         set
        </code>
        ,
        <code>
         multiset
        </code>
        ,
        <code>
         map
        </code>
        , and
        <code>
         multimap
        </code>
        . They are called
        <i>
         sorted
        </i>
        or
        <i>
         ordered associative containers
        </i>
        because they sort their elements.
       </p>
       <section>
        <span id="c16-sec-0054">
        </span>
        <h5 id="head-5-101">
         set
        </h5>
        <p id="c16-para-0119">
         The
         <code>
          set
         </code>
         class template is defined in
         <code>
          &lt;set&gt;
         </code>
         , and, as the name suggests, it is a set of elements, loosely analogous to the notion of a mathematical set: each element is unique, and there is at most one instance of the element in the set. One difference between the mathematical concept of set and
         <code>
          set
         </code>
         as implemented in the Standard Library is that in the Standard Library the elements are kept in an order. The reason for the order is that an order makes it much faster to verify whether a certain element is already in a
         <code>
          set
         </code>
         . When a client enumerates the elements, they'll come out in the ordering imposed by the type's
         <code>
          operator&lt;
         </code>
         or a user-defined comparator. The
         <code>
          set
         </code>
         provides logarithmic insertion, deletion, and lookup. This means that, in theory, insertions and deletions are faster than for a
         <code>
          vector
         </code>
         but slower than for a
         <code>
          list
         </code>
         ; while lookups are faster than for a
         <code>
          list
         </code>
         , but slower than for a
         <code>
          vector
         </code>
         . As always, use a profiler to make sure which container is faster for your use case.
        </p>
        <p id="c16-para-0120">
         You could use a
         <code>
          set
         </code>
         when you need the elements to be in an order, to have equal amounts of insertion/deletion and lookups, and you want to optimize performance for both as much as possible. For example, an inventory-tracking program in a busy bookstore might want to use a
         <code>
          set
         </code>
         to store the books. The list of books in stock must be updated whenever books arrive or are sold, so insertion and deletion should be quick. Customers also need the ability to look for a specific book, so the program should provide fast lookup as well.
        </p>
        <p>
         Elements in a
         <code>
          set
         </code>
         cannot be modified, because this could invalidate the order of the elements. If you need to change an element, remove that element first and insert a new one with the new value.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0122">
            <b>
             NOTE
            </b>
            <i>
             A
            </i>
            <code>
             set
            </code>
            <i>
             could be an option instead of a
            </i>
            <code>
             vector
            </code>
            <i>
             or
            </i>
            <code>
             list
            </code>
            <i>
             if you need order and want equal performance for insertion, deletion, and lookup. It could also be an option if you want to enforce that there are no duplicate elements.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c16-para-0123">
         A
         <code>
          set
         </code>
         does not allow duplicate elements. That is, each element in a
         <code>
          set
         </code>
         must be unique.
        </p>
       </section>
       <section>
        <span id="c16-sec-0056">
        </span>
        <h5 id="head-5-102">
         multiset
        </h5>
        <p id="c16-para-0124">
         The
         <code>
          multiset
         </code>
         class template, also defined in
         <code>
          &lt;set&gt;
         </code>
         , is almost identical to
         <code>
          set
         </code>
         , except that a
         <code>
          multiset
         </code>
         can store duplicate elements.
        </p>
       </section>
       <section>
        <span id="c16-sec-0057">
        </span>
        <h5 id="head-5-103">
         map
        </h5>
        <p id="c16-para-0125">
         <code>
          &lt;map&gt;
         </code>
         defines the
         <code>
          map
         </code>
         class template, which is an
         <i>
          associative array
         </i>
         . You can use it as an array in which the index can be any type, for example, a
         <code>
          string
         </code>
         . A
         <code>
          map
         </code>
         stores key/value pairs and keeps its elements in sorted order, based on the keys, not the values. It also provides an
         <code>
          operator[]
         </code>
         , which a
         <code>
          set
         </code>
         does not provide. In most other respects, it is identical to a
         <code>
          set
         </code>
         . You could use a
         <code>
          map
         </code>
         when you want to associate keys and values. For example, in the earlier bookstore example, you might want to store the books in a
         <code>
          map
         </code>
         where the key is the ISBN number of the book and the value is a
         <code>
          Book
         </code>
         object containing detailed information for that specific book.
        </p>
       </section>
       <span aria-label="635" epub:type="pagebreak" id="Page_635" role="doc-pagebreak">
       </span>
       <section>
        <span id="c16-sec-0058">
        </span>
        <h5 id="head-5-104">
         multimap
        </h5>
        <p>
         <code>
          &lt;map&gt;
         </code>
         also defines the
         <code>
          multimap
         </code>
         class template, which is virtually identical to
         <code>
          map
         </code>
         , except that a
         <code>
          multimap
         </code>
         can store elements with duplicate keys.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c16-para-0127">
            <b>
             NOTE
            </b>
            <i>
             The
            </i>
            <code>
             set
            </code>
            <i>
             ,
            </i>
            <code>
             multiset
            </code>
            <i>
             ,
            </i>
            <code>
             map
            </code>
            <i>
             , and
            </i>
            <code>
             multimap
            </code>
            <i>
             containers are called associative containers because they associate keys and values. This term might be slightly confusing when applied to
             <code>
              set
             </code>
             s and
            </i>
            <code>
             multiset
            </code>
            <i>
             s, because for these the keys are themselves the values
            </i>
            .
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section>
       <span id="c16-sec-0060">
       </span>
       <h4 id="head-4-257">
        Unordered Associative Containers/Hash Tables
       </h4>
       <p>
        The Standard Library supports
        <i>
         hash tables
        </i>
        , also called
        <i>
         unordered associative containers
        </i>
        . There are four unordered associative containers:
       </p>
       <ul class="check1" id="c16-list-0006">
        <li id="c16-li-0019">
         <code>
          unordered_map
         </code>
         and
         <code>
          unordered_multimap
         </code>
        </li>
        <li id="c16-li-0020">
         <code>
          unordered_set
         </code>
         and
         <code>
          unordered_multiset
         </code>
        </li>
       </ul>
       <p id="c16-para-0129">
        The first two containers are defined in
        <code>
         &lt;unordered_map&gt;
        </code>
        , while the latter two are defined in
        <code>
         &lt;unordered_set&gt;
        </code>
        . Better names would have been
        <code>
         hash_map
        </code>
        ,
        <code>
         hash_set
        </code>
        , and so on. Unfortunately, hash tables were not part of the C++ Standard Library before C++11, which means a lot of third-party libraries implemented hash tables themselves by using names with “hash” as a prefix, like
        <code>
         hash_map
        </code>
        . Because of this, the C++ standard committee decided to use the prefix “unordered” instead of “hash” to avoid name clashes.
       </p>
       <p id="c16-para-0130">
        These unordered associative containers behave similar to their ordered counterparts. An
        <code>
         unordered_map
        </code>
        is similar to a standard
        <code>
         map
        </code>
        except that the standard
        <code>
         map
        </code>
        sorts its elements, while the
        <code>
         unordered_map
        </code>
        doesn't sort its elements.
       </p>
       <p id="c16-para-0131">
        Insertion, deletion, and lookup with these unordered associative containers can be done on average in constant time. In a worst-case scenario, it will be in linear time. Lookup of elements in an unordered container can be much faster than with a normal
        <code>
         map
        </code>
        or
        <code>
         set
        </code>
        , especially when there are a lot of elements in the container.
       </p>
       <p id="c16-para-0132">
        <a href="c18.xhtml">
         Chapter 18
        </a>
        explains how these unordered associative containers work and why they are called hash tables.
       </p>
      </section>
      <section>
       <span id="c16-sec-0061">
       </span>
       <h4 id="head-4-258">
        <img alt="C++23" src="../images\images/icon1.png"/>
        Flat Associative Container Adapters
       </h4>
       <p>
        C++23 introduces four flat associative container adapters:
       </p>
       <ul class="check1" id="c16-list-0007">
        <li id="c16-li-0021">
         <code>
          flat_map
         </code>
         and
         <code>
          flat_multimap
         </code>
         defined in
         <code>
          &lt;flat_map&gt;
         </code>
        </li>
        <li id="c16-li-0022">
         <code>
          flat_set
         </code>
         and
         <code>
          flat_multiset
         </code>
         defined in
         <code>
          &lt;flat_set&gt;
         </code>
        </li>
       </ul>
       <p id="c16-para-0135">
        These are adapters on top of sequential containers and provide an associative container interface. The adapted sequential containers must support random-access iterators, such as
        <code>
         vector
        </code>
        and
        <code>
         deque
        </code>
        . The
        <code>
         flat_map
        </code>
        and
        <code>
         flat_multimap
        </code>
        adapters require two underlying sequential containers, one to store
        <span aria-label="636" epub:type="pagebreak" id="Page_636" role="doc-pagebreak">
        </span>
        the keys and another one to store the values.
        <code>
         flat_set
        </code>
        and
        <code>
         flat_multiset
        </code>
        require only one underlying sequential container to store their keys.
       </p>
       <p id="c16-para-0136">
        The interface provided by these adapters is almost identical to their ordered counterpart associative container. The only difference is that the flat adapters don't provide any of the node-related member functions, as the flat adapters are not node-based data structures. Besides that, they are almost an immediate drop-in replacement for their ordered counterparts.
       </p>
       <p id="c16-para-0137">
        <a href="c18.xhtml">
         Chapter 18
        </a>
        gives more details about these flat associative container adapters.
       </p>
      </section>
      <section>
       <span id="c16-sec-0062">
       </span>
       <h4 id="head-4-259">
        bitset
       </h4>
       <p id="c16-para-0138">
        C and C++ programmers commonly store a set of flags in a single
        <code>
         int
        </code>
        or
        <code>
         long
        </code>
        , using one bit for each flag. Bits are set and accessed with the bitwise operators:
        <code>
         &amp;
        </code>
        ,
        <code>
         |
        </code>
        ,
        <code>
         ^
        </code>
        ,
        <code>
         ˜
        </code>
        ,
        <code>
         &lt;&lt;
        </code>
        , and
        <code>
         &gt;&gt;
        </code>
        . The C++ Standard Library provides a
        <code>
         bitset
        </code>
        class that abstracts this bit field manipulation, so you shouldn't need to use the bit manipulation operators anymore for such use cases.
       </p>
       <p id="c16-para-0139">
        <code>
         &lt;bitset&gt;
        </code>
        defines the
        <code>
         bitset
        </code>
        container, but this is not a container in the normal sense, in that it does not implement a specific data structure in which you insert and remove elements. A
        <code>
         bitset
        </code>
        has a fixed size. You can think of them as a sequence of Boolean values that you can read and write. However, unlike the C-style way of handling bits, the
        <code>
         bitset
        </code>
        is not limited to the size of an
        <code>
         int
        </code>
        or other elementary data types. Thus, you can have a 40-bit
        <code>
         bitset
        </code>
        or a 213-bit
        <code>
         bitset
        </code>
        . The implementation will use as much storage as it needs to implement
        <i>
         N
        </i>
        bits when you declare your
        <code>
         bitset
        </code>
        with
        <code>
         bitset&lt;N&gt;
        </code>
        .
       </p>
      </section>
      <section>
       <span id="c16-sec-0063">
       </span>
       <h4 id="head-4-260">
        Summary of Standard Library Containers
       </h4>
       <span aria-label="637" epub:type="pagebreak" id="Page_637" role="doc-pagebreak">
       </span>
       <span aria-label="638" epub:type="pagebreak" id="Page_638" role="doc-pagebreak">
       </span>
       <p id="c16-para-0140">
        The following table summarizes the containers provided by the Standard Library. It uses the big-O notation introduced in
        <a href="c04.xhtml">
         Chapter 4
        </a>
        to present the performance characteristics on a container of
        <i>
         N
        </i>
        elements. An N/A entry in the table means that the operation is not part of the container semantics:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           TYPE
          </th>
          <th class="left bgcolor2" scope="col">
           INSERT PERFORMANCE
          </th>
          <th class="bgcolor2" scope="colgroup">
           DELETE PERFORMANCE
          </th>
          <th class="left bgcolor2" scope="col">
           LOOKUP PERFORMANCE
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            vector
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sequential
          </td>
          <td class="left bor1 bgcolor3">
           Amortized
           <i>
            O
           </i>
           (1) at the end;
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ) otherwise.
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (1) at the end;
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ) otherwise.
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1)
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           This should be your default container. Only use another container after using a profiler to confirm it is faster than a
           <code>
            vector
           </code>
           .
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            list
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sequential
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1) at the beginning and the end, and once you are at the position where you want to insert the element.
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (1) at the beginning and the end, and once you are at the position where you want to delete the element.
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1) to access the first or last element;
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ) otherwise.
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           Rarely. You should use a
           <code>
            vector
           </code>
           , unless a profiler tells you a
           <code>
            list
           </code>
           is faster for your use case.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            forward_list
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sequential
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1) at the beginning, and once you are at the position where you want to insert the element.
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (1) at the beginning, and once you are at the position where you want to delete the element.
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1) to access the first element;
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ) otherwise.
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           Rarely. You should use a
           <code>
            vector
           </code>
           , unless a profiler tells you a
           <code>
            forward_list
           </code>
           is faster for your use case.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            deque
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sequential
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1) at the beginning or end;
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ) otherwise.
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (1) at the beginning or end;
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ) otherwise.
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1)
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           Not usually needed; use a
           <code>
            vector
           </code>
           instead.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            array
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sequential
          </td>
          <td class="left bor1 bgcolor3">
           N/A
          </td>
          <td class="bgcolor3">
           N/A
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1)
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you need a fixed-size array to replace a standard C-style array.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            queue
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Container adapter
          </td>
          <td class="left bor1 bgcolor3">
           Depends on the underlying container;
           <i>
            O
           </i>
           (1) for
           <code>
            list
           </code>
           and
           <code>
            deque
           </code>
           .
          </td>
          <td class="bgcolor3">
           Depends on the underlying container;
           <i>
            O
           </i>
           (1) for
           <code>
            list
           </code>
           and
           <code>
            deque
           </code>
           .
          </td>
          <td class="left bor1 bgcolor3">
           N/A
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a FIFO structure.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            priority_queue
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Container adapter
          </td>
          <td class="left bor1 bgcolor3">
           Depends on the underlying container; amortized
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           )) for
           <code>
            vector
           </code>
           ,
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           )) for
           <code>
            deque
           </code>
           .
          </td>
          <td class="bgcolor3">
           Depends on the underlying container;
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           )) for
           <code>
            vector
           </code>
           and
           <code>
            deque
           </code>
           .
          </td>
          <td class="left bor1 bgcolor3">
           N/A
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a queue with priority.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            stack
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Container adapter
          </td>
          <td class="left bor1 bgcolor3">
           Depends on the underlying container;
           <i>
            O
           </i>
           (1) for
           <code>
            list
           </code>
           and
           <code>
            deque
           </code>
           , amortized
           <i>
            O
           </i>
           (1) for
           <code>
            vector
           </code>
           .
          </td>
          <td class="bgcolor3">
           Depends on the underlying container;
           <i>
            O
           </i>
           (1) for
           <code>
            list
           </code>
           ,
           <code>
            vector
           </code>
           , and
           <code>
            deque
           </code>
           .
          </td>
          <td class="left bor1 bgcolor3">
           N/A
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a FILO/LIFO structure.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            set
           </code>
           <br/>
           <code>
            multiset
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sorted associative
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a sorted collection of elements with equal lookup, insertion, and deletion times. Use a
           <code>
            set
           </code>
           when you want a collection of elements without duplicates.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            map
           </code>
           <br/>
           <code>
            multimap
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sorted associative
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a sorted collection to associate keys with values, that is, an associative array, with equal lookup, insertion, and deletion times.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            unordered_map
           </code>
           <br/>
           <code>
            unordered_multimap
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Unordered associative / hash table
          </td>
          <td class="left bor1 bgcolor3">
           Average case
           <i>
            O
           </i>
           (1); worst case
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ).
          </td>
          <td class="bgcolor3">
           Average case
           <i>
            O
           </i>
           (1); worst case
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ).
          </td>
          <td class="left bor1 bgcolor3">
           Average case
           <i>
            O
           </i>
           (1); worst case
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ).
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want to associate keys with values with equal lookup, insertion, and deletion times, and you don't require the elements to be sorted. Performance can be better than with a normal
           <code>
            map
           </code>
           , but that depends on the elements.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            unordered_set
           </code>
           <br/>
           <code>
            unordered_multiset
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Unordered associative/hash table
          </td>
          <td class="left bor1 bgcolor3">
           Average case
           <i>
            O
           </i>
           (1); worst case
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ).
          </td>
          <td class="bgcolor3">
           Average case
           <i>
            O
           </i>
           (1); worst case
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ).
          </td>
          <td class="left bor1 bgcolor3">
           Average case
           <i>
            O
           </i>
           (1); worst case
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           ).
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a collection of elements with equal lookup, insertion, and deletion times, and you don't require the elements to be sorted. Performance can be better than with a normal
           <code>
            set
           </code>
           , but that depends on the elements.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <img alt="C++23" src="../images\images/icon1.png"/>
           <code>
            flat_set
           </code>
           <br/>
           <code>
            flat_multiset
           </code>
          </td>
          <td class="bgcolor3">
           Flat set associative container adapter
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           )
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           )
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a sorted collection of elements. Because the adapters use underlying sequential containers that have very cache-friendly memory layout, the performance is often better than the corresponding ordered container.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <img alt="C++23" src="../images\images/icon1.png"/>
           <code>
            flat_map
           </code>
           <br/>
           <code>
            flat_multimap
           </code>
          </td>
          <td class="bgcolor3">
           Flat map associative container adapter
          </td>
          <td class="bgcolor3">
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           )
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (
           <i>
            N
           </i>
           )
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (log(
           <i>
            N
           </i>
           ))
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a sorted collection to associate keys with values. Because the adapters use underlying sequential containers that have very cache-friendly memory layout, the performance is often better than the corresponding ordered container.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3" rowspan="2">
           <code>
            bitset
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Special
          </td>
          <td class="left bor1 bgcolor3">
           N/A
          </td>
          <td class="bgcolor3">
           N/A
          </td>
          <td class="left bor1 bgcolor3">
           <i>
            O
           </i>
           (1)
          </td>
         </tr>
         <tr>
          <td class="bgcolor3" colspan="4">
           <b>
            When to Use:
           </b>
           When you want a collection of flags.
           <span aria-label="639" epub:type="pagebreak" id="Page_639" role="doc-pagebreak">
           </span>
          </td>
         </tr>
        </tbody>
       </table>
       <p>
        Note that
        <code>
         string
        </code>
        s are technically containers as well. Thus, some of the algorithms described in the material that follows also work on
        <code>
         string
        </code>
        s.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c16-para-0158">
           <b>
            NOTE
           </b>
           <code>
            vector
           </code>
           <i>
            should be your default container! In practice, insertion and deletion in a
           </i>
           <code>
            vector
           </code>
           <i>
            are often faster than in a
           </i>
           <code>
            list
           </code>
           <i>
            or
           </i>
           <code>
            forward_list
           </code>
           <i>
            . This is because of how memory and caches work on modern CPUs and because of the fact that for a
           </i>
           <code>
            list
           </code>
           <i>
            or
           </i>
           <code>
            forward_list
           </code>
           <i>
            , you first need to iterate to the position where you want to insert or delete an element. Memory for a
            <code>
             list
            </code>
            or
           </i>
           <code>
            forward_list
           </code>
           <i>
            might be fragmented, so iteration is much slower than for a
           </i>
           <code>
            vector
           </code>
           <i>
            .
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section>
      <span id="c16-sec-0065">
      </span>
      <h3 id="head-3-381">
       Algorithms
      </h3>
      <p>
       In addition to containers, the Standard Library provides implementations of many generic algorithms. An
       <i>
        algorithm
       </i>
       is a strategy for performing a particular task, such as sorting or searching. These algorithms are implemented as function templates, so they work on most of the different container types. Note that the algorithms are not generally part of the containers. The Standard Library takes the approach of separating the
       <i>
        data
       </i>
       (containers) from the
       <i>
        functionality
       </i>
       (algorithms). Although this approach seems counter to the spirit of object-oriented programming, it is necessary in order to support generic programming in the Standard Library. The guiding principle of
       <i>
        orthogonality
       </i>
       maintains that algorithms and containers are independent, with (almost) any algorithm working with (almost) any container.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c16-para-0160">
          <b>
           NOTE
          </b>
          <i>
           Although the algorithms and containers are theoretically independent, some containers provide certain algorithms in the form of class member functions because the generic algorithms do not perform well on those particular containers. For example,
          </i>
          <code>
           set
          </code>
          <i>
           provides its own
          </i>
          <code>
           find()
          </code>
          <i>
           algorithm that is faster than the generic
          </i>
          <code>
           find()
          </code>
          <i>
           algorithm. You should use the container-specific member function form of an algorithm, if provided, because it is generally more efficient or appropriate for the container at hand.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c16-para-0161">
       Note that the generic algorithms do not work directly on containers; instead, they either use iterators or work on ranges, both discussed in detail in
       <a href="c17.xhtml">
        Chapter 17
       </a>
       , “Understanding Iterators and the Ranges Library.”
      </p>
      <p id="c16-para-0162">
       <span aria-label="640" epub:type="pagebreak" id="Page_640" role="doc-pagebreak">
       </span>
       This section gives an overview of what kinds of algorithms are available in the Standard Library without going into detail.
       <a href="c20.xhtml">
        Chapter 20
       </a>
       , “Mastering Standard Library Algorithms,” discusses a selection of algorithms with coding examples. For the exact prototypes of all the available algorithms, consult your favorite Standard Library reference.
      </p>
      <p>
       There are more than 100 algorithms in the Standard Library. The following sections divide these algorithms into different categories. The algorithms are defined in
       <code>
        &lt;algorithm&gt;
       </code>
       unless otherwise noted. Note that whenever the following algorithms are specified as working on a “sequence” of elements, that sequence is presented to the algorithm via iterators.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c16-para-0164">
          <b>
           NOTE
          </b>
          <i>
           When examining the list of algorithms, remember that the Standard Library is designed with generality in mind, so it adds generality that might never be used but that, if required, would be essential. You may not need every algorithm or need to worry about the more obscure parameters that are there for anticipated generality. It is important only to be aware of what's available in case you ever find it useful
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <section>
       <span id="c16-sec-0068">
       </span>
       <h4 id="head-4-261">
        Non-modifying Sequence Algorithms
       </h4>
       <p id="c16-para-0165">
        The non-modifying algorithms are those that look at a sequence of elements and return some information about the elements. As “non-modifying” algorithms, they cannot change the values of elements or the order of elements within the sequence. This category contains three types of algorithms: searching, comparing, and counting. The following sections briefly summarize the various non-modifying algorithms. With these algorithms, you should rarely need to write a
        <code>
         for
        </code>
        loop to iterate over a sequence of values.
       </p>
       <section>
        <span id="c16-sec-0069">
        </span>
        <h5 id="head-5-105">
         Searching Algorithms
        </h5>
        <p id="c16-para-0166">
         These algorithms do not require the sequence to be sorted.
         <i>
          N
         </i>
         is the size of the sequence to search in, and
         <i>
          M
         </i>
         is the size of the pattern to find:
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            NAME
           </th>
           <th class="left bgcolor2" scope="col">
            SYNOPSIS
           </th>
           <th class="left bgcolor2" scope="col">
            COMPLEXITY
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             adjacent_find()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Finds the first instance of two consecutive elements that are equal to each other or are equivalent to each other as specified by a predicate.
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             N
            </i>
            )
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             find()
            </code>
            <br/>
            <code>
             find_if()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Finds the first element that matches a value or causes a predicate to return
            <code>
             true
            </code>
            .
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             N
            </i>
            )
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             find_first_of()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Like
            <code>
             find
            </code>
            , but searches for one of several elements at the same time.
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             N*M
            </i>
            )
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             find_if_not()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Finds the first element that causes a predicate to return
            <code>
             false
            </code>
            .
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             N
            </i>
            )
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             find_end()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Finds the last subsequence in a sequence that matches another sequence or whose elements are equivalent, as specified by a predicate.
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             M*
            </i>
            (
            <i>
             N
            </i>
            -
            <i>
             M
            </i>
            ))
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             search()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Finds the first subsequence in a sequence that matches another sequence or whose elements are equivalent, as specified by a predicate
            <a href="#c16-note-0001" id="R_c16-note-0001">
             <sup>
              1
             </sup>
            </a>
            .
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             N*M
            </i>
            )
            <a href="#c16-note-0001">
             <sup>
              1
             </sup>
            </a>
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             search_n()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Finds the first instance of
            <i>
             n
            </i>
            consecutive elements that are equal to a given value or relate to that value according to a predicate.
           </td>
           <td class="left bor1 bgcolor3">
            <i>
             O
            </i>
            (
            <i>
             N
            </i>
            )
            <span aria-label="641" epub:type="pagebreak" id="Page_641" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
        <p class="tableFootnote" id="c16-note-0001">
         <a href="#R_c16-note-0001" role="doc-backlink">
          <sup>
           1
          </sup>
         </a>
         <code>
          search()
         </code>
         accepts an optional extra parameter to specify the searching algorithm to use (
         <code>
          default_searcher
         </code>
         ,
         <code>
          boyer_moore_searcher
         </code>
         , or
         <code>
          boyer_moore_horspool_searcher
         </code>
         ). With the Boyer–Moore searchers, the worst-case complexity is
         <i>
          O
         </i>
         (
         <i>
          N
         </i>
         +
         <i>
          M
         </i>
         ) when the pattern is not found, and
         <i>
          O
         </i>
         (
         <i>
          N*M
         </i>
         ) when the pattern is found.
        </p>
       </section>
       <section>
        <span id="c16-sec-0070">
        </span>
        <h5 id="head-5-106">
         Comparison Algorithms
        </h5>
        <p id="c16-para-0171">
         The following comparison algorithms are provided. None of them requires the source sequences to be ordered. All of them have a linear worst-case complexity:
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            NAME
           </th>
           <th class="left bgcolor2" scope="col">
            SYNOPSIS
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             equal()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Determines whether two sequences are equal by checking whether parallel elements are equal or match a predicate.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             mismatch()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Returns the first element in each sequence that does not match the element in the same location in the other sequence.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             lexicographical_compare()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Compares two sequences to determine their “lexicographical” ordering. This algorithm compares each element of the first sequence with its equivalent element in the second. If one element is less than the other, that sequence is lexicographically first. If the elements are equal, it compares the next elements in order.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             lexicographical_compare_three_way()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Compares two sequences to determine their “lexicographical” ordering using three-way comparisons and returns a comparison category type (
            <code>
             strong_ordering
            </code>
            ,
            <code>
             weak_ordering
            </code>
            , or
            <code>
             partial_ordering
            </code>
            ).
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             all_of()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Returns
            <code>
             true
            </code>
            if a given predicate returns
            <code>
             true
            </code>
            for all the elements in the sequence or if the sequence is empty;
            <code>
             false
            </code>
            otherwise.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             any_of()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Returns
            <code>
             true
            </code>
            if a given predicate returns
            <code>
             true
            </code>
            for at least one element in the sequence;
            <code>
             false
            </code>
            otherwise.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             none_of()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Returns
            <code>
             true
            </code>
            if a given predicate returns
            <code>
             false
            </code>
            for all the elements in the sequence or if the sequence is empty;
            <code>
             false
            </code>
            otherwise.
            <span aria-label="642" epub:type="pagebreak" id="Page_642" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
       </section>
       <section>
        <span id="c16-sec-0071">
        </span>
        <h5 id="head-5-107">
         Counting Algorithms
        </h5>
        <p id="c16-para-0173">
         The following counting algorithms are available. None of them requires the source sequences to be ordered. All of them have a linear worst-case complexity:
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            NAME
           </th>
           <th class="left bgcolor2" scope="col">
            SYNOPSIS
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             count()
            </code>
            <br/>
            <code>
             count_if()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Counts the number of elements matching a value or that cause a predicate to return
            <code>
             true
            </code>
            .
           </td>
          </tr>
         </tbody>
        </table>
       </section>
      </section>
      <section>
       <span id="c16-sec-0072">
       </span>
       <h4 id="head-4-262">
        Modifying Sequence Algorithms
       </h4>
       <p id="c16-para-0177">
        The modifying algorithms modify some or all of the elements in a sequence. Some of them modify elements
        <i>
         in place
        </i>
        so that the original sequence changes. Others copy the results to a different sequence so that the original sequence remains unchanged. All of them have a linear worst-case complexity. The following table summarizes the modifying algorithms:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            copy()
           </code>
           <br/>
           <code>
            copy_backward()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Copies elements from one sequence to another.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            copy_if()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Copies elements for which a predicate returns
           <code>
            true
           </code>
           from one sequence to another.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            copy_n()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Copies
           <i>
            n
           </i>
           elements from one sequence to another.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            fill()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sets all elements in the sequence to a new value.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            fill_n()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sets the first
           <i>
            n
           </i>
           elements in the sequence to a new value.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            generate()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Calls a given function to generate a new value for each element in the sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            generate_n()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Calls a given function to generate a new value for the first
           <i>
            n
           </i>
           elements in the sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            move()
           </code>
           <br/>
           <code>
            move_backward()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Moves elements from one sequence to another using efficient move semantics (see
           <a href="c09.xhtml">
            Chapter 9
           </a>
           ).
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            remove()
           </code>
           <br/>
           <code>
            remove_if()
           </code>
           <br/>
           <code>
            remove_copy()
           </code>
           <br/>
           <code>
            remove_copy_if()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Removes all elements that match a given value or that cause a predicate to return
           <code>
            true
           </code>
           , either in place or by copying the results to a different sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            <code>
             replace()
            </code>
            <br/>
            <code>
             replace:if()
            </code>
            <br/>
            <code>
             replace:copy()
            </code>
            <br/>
            <code>
             replace:copy_if()
            </code>
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Replaces all elements matching a value or that cause a predicate to return
           <code>
            true
           </code>
           with a new element, either in place or by copying the results to a different sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            <code>
             reverse()
            </code>
            <br/>
            <code>
             reverse_copy()
            </code>
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Reverses the order of the elements in the sequence, either in place or by copying the results to a different sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            <code>
             rotate()
            </code>
            <br/>
            <code>
             rotate_copy()
            </code>
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Swaps the first and second “halves” of the sequence, either in place or by copying the results to a different sequence. The two subsequences to be swapped need not be equal in size.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            sample()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Selects
           <i>
            n
           </i>
           random elements from the sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            <code>
             shift_left()
            </code>
            <br/>
            <code>
             shift_right()
            </code>
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Shifts the elements in a sequence left or right by a given number of positions. Elements are moved to their new position. Elements that fall of either end of the sequence are removed.
           <code>
            shift_left()
           </code>
           returns an iterator to the end of the new sequence;
           <code>
            shift_right()
           </code>
           returns an iterator to the beginning of the new sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            <code>
             shuffle()
            </code>
            <br/>
            <code>
             random_shuffle()
            </code>
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Shuffles the sequence by randomly reordering the elements. It is possible to specify the properties of the random number generator used for shuffling.
           <code>
            random_shuffle()
           </code>
           is deprecated since C++14, and is removed starting with C++17.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            transform()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Calls a unary function on each element of a sequence or a binary function on parallel elements of two sequences, and stores the results in a destination sequence. If the source and destination sequences are the same, the transformation happens in-place.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            <code>
             unique()
            </code>
            <br/>
            <code>
             unique_copy()
            </code>
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Removes consecutive duplicates from the sequence, either in place or by copying results to a different sequence.
           <span aria-label="643" epub:type="pagebreak" id="Page_643" role="doc-pagebreak">
           </span>
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0073">
       </span>
       <h4 id="head-4-263">
        Operational Algorithms
       </h4>
       <p id="c16-para-0201">
        Operational algorithms execute a function on individual elements of a sequence. There are two operational algorithms provided. Both have a linear complexity and do not require the source sequence to be ordered:
       </p>
       <p>
        <span aria-label="644" epub:type="pagebreak" id="Page_644" role="doc-pagebreak">
        </span>
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            for_each()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Executes a function on each element in the sequence. The sequence is specified with a begin and end iterator.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            for_each_n()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Similar to
           <code>
            for_each()
           </code>
           but only processes the first
           <i>
            n
           </i>
           elements in the sequence. The sequence is specified by a begin iterator and a number of elements (
           <i>
            n
           </i>
           ).
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0074">
       </span>
       <h4 id="head-4-264">
        Swap Algorithms
       </h4>
       <p id="c16-para-0203">
        The C++ Standard Library provides the following swap algorithms:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            iter_swap()
           </code>
           <br/>
           <code>
            swap_ranges()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Swaps two elements or sequences of elements.
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0075">
       </span>
       <h4 id="head-4-265">
        Partitioning Algorithms
       </h4>
       <p id="c16-para-0207">
        A sequence is partitioned on a certain predicate, if all elements for which the predicate returns
        <code>
         true
        </code>
        are before all elements for which it returns
        <code>
         false
        </code>
        . The first element in the sequence that does not satisfy the predicate is called the
        <i>
         partition point
        </i>
        . The Standard Library provides the following partition algorithms:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
          <th class="left bgcolor2" scope="col">
           COMPLEXITY
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            is_partitioned()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns
           <code>
            true
           </code>
           if all elements for which a predicate returns
           <code>
            true
           </code>
           are before all elements for which it returns
           <code>
            false
           </code>
           .
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            partition()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sorts the sequence such that all elements for which a predicate returns
           <code>
            true
           </code>
           are before all elements for which it returns
           <code>
            false
           </code>
           , without preserving the original order of the elements within each partition.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            stable_partition()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sorts the sequence such that all elements for which a predicate returns
           <code>
            true
           </code>
           are before all elements for which it returns
           <code>
            false
           </code>
           , while preserving the original order of the elements within each partition.
          </td>
          <td class="left bor1 bgcolor3">
           Linear logarithmic
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            partition_copy()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Copies elements from one sequence to two different sequences. The target sequence is selected based on the result of a predicate, either
           <code>
            true
           </code>
           or
           <code>
            false
           </code>
           .
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            partition_point()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns an iterator such that all elements before this iterator return
           <code>
            true
           </code>
           for a predicate and all elements after this iterator return
           <code>
            false
           </code>
           for that predicate.
          </td>
          <td class="left bor1 bgcolor3">
           Logarithmic
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <span aria-label="645" epub:type="pagebreak" id="Page_645" role="doc-pagebreak">
      </span>
      <section>
       <span id="c16-sec-0076">
       </span>
       <h4 id="head-4-266">
        Sorting Algorithms
       </h4>
       <p id="c16-para-0209">
        The Standard Library provides several different sorting algorithms with varying performance guarantees:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
          <th class="left bgcolor2" scope="col">
           COMPLEXITY
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            is_sorted()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns
           <code>
            true
           </code>
           if a sequence is sorted,
           <code>
            false
           </code>
           otherwise.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            is_sorted_until()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Finds the largest sorted subrange starting at the beginning of the given range of elements.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            nth_element()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Relocates the
           <i>
            n
           </i>
           <sup>
            th
           </sup>
           element of the sequence such that the element in the position pointed to by
           <i>
            n
           </i>
           <sup>
            th
           </sup>
           is the element that would be in that position if the whole range were sorted, and it rearranges all elements such that all elements preceding the
           <i>
            n
           </i>
           <sup>
            th
           </sup>
           element are less than the new
           <i>
            n
           </i>
           <sup>
            th
           </sup>
           element, and the ones following it are greater than the new
           <i>
            n
           </i>
           <sup>
            th
           </sup>
           element.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            partial_sort()
           </code>
           <br/>
           <code>
            partial_sort_copy()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Partially sorts the sequence: the first
           <i>
            n
           </i>
           elements (specified by iterators) are sorted; the rest are not. They are sorted either in place or by copying them to a new sequence.
          </td>
          <td class="left bor1 bgcolor3">
           Linear logarithmic
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            stable_sort()
           </code>
           <br/>
           <code>
            sort()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Sorts elements in place, either preserving the order of duplicate elements (stable) or not.
          </td>
          <td class="left bor1 bgcolor3">
           Linear logarithmic
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0077">
       </span>
       <h4 id="head-4-267">
        Binary Search Algorithms
       </h4>
       <p id="c16-para-0215">
        The following binary search algorithms are normally used on sorted sequences. Technically, they only require the sequence to be at least partitioned on the element that is searched for. This could, for example, be achieved by applying
        <code>
         std::partition()
        </code>
        . A sorted sequence also meets this requirement. All these algorithms have logarithmic complexity:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            lower_bound()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Finds the first element in a sequence not less than (that is, greater or equal to) a given value.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            upper_bound()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Finds the first element in a sequence greater than a given value.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            equal_range()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns a
           <code>
            pair
           </code>
           containing the result of both
           <code>
            lower_bound()
           </code>
           and
           <code>
            upper_bound()
           </code>
           .
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            binary_search()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns
           <code>
            true
           </code>
           if a given value is found in a sequence;
           <code>
            false
           </code>
           otherwise.
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0078">
       </span>
       <h4 id="head-4-268">
        Set Algorithms on Sorted Sequences
       </h4>
       <p id="c16-para-0217">
        Set algorithms are special modifying algorithms that perform set operations on sequences. They are most appropriate on sequences from
        <code>
         set
        </code>
        containers, but work on sorted sequences from most containers:
       </p>
       <p>
        <span aria-label="646" epub:type="pagebreak" id="Page_646" role="doc-pagebreak">
        </span>
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
          <th class="left bgcolor2" scope="col">
           COMPLEXITY
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            includes()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Determines whether every element from one sorted sequence is in another sorted sequence.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            set_union()
           </code>
           <br/>
           <code>
            set_intersection()
           </code>
           <br/>
           <code>
            set_difference()
           </code>
           <br/>
           <code>
            set_symmetric_difference()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Performs the specified set operation on two sorted sequences, copying results to a third sorted sequence.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0079">
       </span>
       <h4 id="head-4-269">
        Other Algorithms on Sorted Sequences
       </h4>
       <p id="c16-para-0223">
        The Standard Library provides the following additional algorithms that work on sorted sequences:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
          <th class="left bgcolor2" scope="col">
           COMPLEXITY
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            inplace:merge()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Merges two sorted sequences in place.
          </td>
          <td class="left bor1 bgcolor3">
           Linear logarithmic
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            merge()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Merges two sorted sequences by copying them to a new sequence.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0080">
       </span>
       <h4 id="head-4-270">
        Heap Algorithms
       </h4>
       <p id="c16-para-0225">
        A
        <i>
         heap
        </i>
        is a standard data structure in which the elements of an array or sequence are ordered in a semi-sorted fashion so that finding the “top” element is quick. For example, a heap data structure is typically used to implement a
        <code>
         priority_queue
        </code>
        . Six algorithms allow you to work with heaps:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
          <th class="left bgcolor2" scope="col">
           COMPLEXITY
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            is_heap()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns
           <code>
            true
           </code>
           if a range of elements is a heap,
           <code>
            false
           </code>
           otherwise.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            is_heap_until()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Finds the largest subrange that is a heap, starting at the beginning of the given range of elements.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            make_heap()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Creates a heap from a range of elements.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            push_heap()
           </code>
           <br/>
           <code>
            pop_heap()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Adds an element to, or removes an element from, a heap.
          </td>
          <td class="left bor1 bgcolor3">
           Logarithmic
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            sort_heap()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Converts a heap into a range of ascending sorted elements.
          </td>
          <td class="left bor1 bgcolor3">
           Linear logarithmic
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0081">
       </span>
       <h4 id="head-4-271">
        Minimum/Maximum Algorithms
       </h4>
       <p id="c16-para-0229">
        The following algorithms are provided to find minimum and maximum elements and to clamp values:
       </p>
       <p>
        <span aria-label="647" epub:type="pagebreak" id="Page_647" role="doc-pagebreak">
        </span>
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            clamp()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Makes sure a value (
           <i>
            v
           </i>
           ) is between a given minimum (
           <i>
            lo
           </i>
           ) and maximum (
           <i>
            hi
           </i>
           ). Returns a reference to
           <i>
            lo
           </i>
           if
           <i>
            v
           </i>
           &lt;
           <i>
            lo
           </i>
           ; returns a reference to
           <i>
            hi
           </i>
           if
           <i>
            v
           </i>
           &gt;
           <i>
            hi
           </i>
           ; otherwise returns a reference to
           <i>
            v
           </i>
           .
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            min()
           </code>
           <br/>
           <code>
            max()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns the minimum or maximum of two or more values.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            minmax()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns the minimum and maximum of two or more values as a
           <code>
            pair
           </code>
           .
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            min_element()
           </code>
           <br/>
           <code>
            max_element()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns the minimum or maximum element in a sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            minmax_element()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns the minimum and maximum element in a sequence as a
           <code>
            pair
           </code>
           .
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0082">
       </span>
       <h4 id="head-4-272">
        Numerical Processing Algorithms
       </h4>
       <p id="c16-para-0235">
        The following numerical processing algorithms are defined in
        <code>
         &lt;numeric&gt;
        </code>
        . None of them require the source sequences to be ordered. All of them have a linear complexity:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            iota()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Fills a sequence with successively incrementing values starting with a given value.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            adjacent_difference()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Generates a new sequence in which each element is the difference (or other binary operation) of the second and first of each adjacent pair of elements in the source sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            partial_sum()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Generates a new sequence in which each element is the sum (or other binary operation) of an element and all its preceding elements in the source sequence.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            exclusive_scan()
           </code>
           <br/>
           <code>
            inclusive_scan()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           These are similar to
           <code>
            partial_sum()
           </code>
           . An inclusive scan is identical to a partial sum if the given summation operation is associative. However,
           <code>
            inclusive_scan()
           </code>
           sums in a nondeterministic order, while
           <code>
            partial_sum()
           </code>
           left to right, so for nonassociative summation operations the result of the former is nondeterministic. The
           <code>
            exclusive_scan()
           </code>
           algorithm also sums in a nondeterministic order.
           <br/>
           For
           <code>
            inclusive_scan()
           </code>
           , the
           <i>
            i
           </i>
           <sup>
            th
           </sup>
           element is included in the
           <i>
            i
           </i>
           <sup>
            th
           </sup>
           sum, just as for
           <code>
            partial_sum()
           </code>
           . For
           <code>
            exclusive_scan()
           </code>
           , the
           <i>
            i
           </i>
           <sup>
            th
           </sup>
           element is not included in the
           <i>
            i
           </i>
           <sup>
            th
           </sup>
           sum.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            transform_exclusive_scan()
           </code>
           <br/>
           <code>
            transform_inclusive_scan()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Applies a transformation to each element in a sequence, then performs an exclusive/inclusive scan.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            accumulate()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           “Accumulates” the values of all the elements in a sequence. The default behavior is to sum the elements, but the caller can supply a different binary function instead.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            inner_product()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Similar to
           <code>
            accumulate()
           </code>
           , but works on two sequences. This algorithm calls a binary function (multiplication by default) on parallel elements in the sequences, accumulating the result using another binary function (addition by default). If the sequences represent mathematical vectors, the algorithm calculates the dot product of the vectors.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            reduce()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Similar to
           <code>
            accumulate()
           </code>
           , but supports parallel execution. The order of evaluation for
           <code>
            reduce()
           </code>
           is nondeterministic, while it's from left to right for
           <code>
            accumulate()
           </code>
           . This means that the behavior of the former is nondeterministic if the given binary operation is not associative or not commutative.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            transform_reduce()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Applies a transformation to each element in a sequence, then performs a
           <code>
            reduce()
           </code>
           .
           <span aria-label="648" epub:type="pagebreak" id="Page_648" role="doc-pagebreak">
           </span>
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0083">
       </span>
       <h4 id="head-4-273">
        Permutation Algorithms
       </h4>
       <p id="c16-para-0243">
        A
        <i>
         permutation
        </i>
        of a sequence contains the same elements but in a different order. The following algorithms are provided to work with permutations:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           NAME
          </th>
          <th class="left bgcolor2" scope="col">
           SYNOPSIS
          </th>
          <th class="left bgcolor2" scope="col">
           COMPLEXITY
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            is_permutation()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Returns
           <code>
            true
           </code>
           if the elements in one range are a permutation of the elements in another range.
          </td>
          <td class="left bor1 bgcolor3">
           Quadratic
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            next_permutation()
           </code>
           <br/>
           <code>
            prev_permutation()
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           Modifies the sequence by transforming it into its “next” or “previous” lexicographical permutation. Successive calls to one or the other will permute the sequence into all possible permutations of its elements, if you start with a properly sorted sequence. This algorithm returns
           <code>
            false
           </code>
           if no more permutations exist.
          </td>
          <td class="left bor1 bgcolor3">
           Linear
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <section>
       <span id="c16-sec-0084">
       </span>
       <h4 id="head-4-274">
        Choosing an Algorithm
       </h4>
       <p id="c16-para-0247">
        The number and capabilities of the algorithms might overwhelm you at first. It can be difficult to see how to apply them in the beginning. However, now that you have an idea of the available options, you are better able to tackle your program designs. The following chapters cover the details of how to use these algorithms in your code.
       </p>
      </section>
     </section>
     <span aria-label="649" epub:type="pagebreak" id="Page_649" role="doc-pagebreak">
     </span>
     <section>
      <span id="c16-sec-0085">
      </span>
      <h3 id="head-3-382">
       Ranges Library
      </h3>
      <p id="c16-para-0248">
       The ranges library makes it easier and more elegant to work with sequences of elements. Ranges provide nicer and easier-to-read syntax and eliminate the possibility of mismatching begin/end iterators. Additionally, range adapters allow you to lazily transform and filter underlying sequences, and range factories are provided to build up ranges.
      </p>
      <p id="c16-para-0249">
       Most algorithms discussed in the previous sections have variants that work with ranges in addition to iterators. Those variants are often called
       <i>
        range-based algorithms
       </i>
       or
       <i>
        constrained algorithms
       </i>
       because they have proper template type parameter constraints in the form of concepts. This allows the compiler to issue better error messages if such a constrained algorithm is used wrongly.
      </p>
      <p id="c16-para-0250">
       Additionally, C++23 introduces the following algorithms that are available only in a constrained variant. All of them have a linear complexity.
      </p>
      <p id="c16-para-7761">
       <img alt="C++23" src="../images\images/icon1.png"/>
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          NAME
         </th>
         <th class="left bgcolor2" scope="col">
          SYNOPSIS
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           contains()
          </code>
          <br/>
          <code>
           contains_subrange()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns
          <code>
           true
          </code>
          if a given range contains a given value, respectively, a given subrange,
          <code>
           false
          </code>
          otherwise.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           starts_with()
          </code>
          <br/>
          <code>
           ends_with()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Returns
          <code>
           true
          </code>
          if a given range starts, respectively, ends with another given range,
          <code>
           false
          </code>
          otherwise.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           find_last()
          </code>
          <br/>
          <code>
           find_last_if()
          </code>
          <br/>
          <code>
           find_last_if_not()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Finds the last element in a given range that either matches a given value, or for which a given predicate returns
          <code>
           true
          </code>
          , or for which a given predicate returns
          <code>
           false
          </code>
          . The result is a subrange starting at the found element until the end of the range.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           fold_left()
          </code>
          <br/>
          <code>
           fold_left_first()
          </code>
          <br/>
          <code>
           fold_right()
          </code>
          <br/>
          <code>
           fold_right_last()
          </code>
          <br/>
          <code>
           fold_left_with_iter()
          </code>
          <br/>
          <code>
           fold_left_first_with_iter()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Folds the elements of a given range left or right.
          <code>
           fold_left()
          </code>
          and
          <code>
           fold_right()
          </code>
          accept an initial value as one of their arguments, and return the result of the fold operation.
          <code>
           fold_left_first()
          </code>
          uses the first element in a given range as the starting value, while
          <code>
           fold_right_last()
          </code>
          uses the last element in a given range as the starting value. Both of these return an
          <code>
           optional
          </code>
          containing the result, or an empty
          <code>
           optional
          </code>
          if applied to an empty range. The last two variants return an instance of
          <code>
           fold_left_with_iter_result
          </code>
          , respectively,
          <code>
           fold_left_first_with_iter_result
          </code>
          that you can use to inspect the result of the fold operation.
         </td>
        </tr>
       </tbody>
      </table>
      <p id="c16-para-0266">
       The ranges library is defined in
       <code>
        &lt;ranges&gt;
       </code>
       and lives in the
       <code>
        std::ranges
       </code>
       namespace.
       <a href="c17.xhtml">
        Chapter 17
       </a>
       discusses the ranges library, while
       <a href="c20.xhtml">
        Chapter 20
       </a>
       discusses unconstrained and constrained algorithms with coding examples.
      </p>
     </section>
     <span aria-label="650" epub:type="pagebreak" id="Page_650" role="doc-pagebreak">
     </span>
     <section>
      <span id="c16-sec-0086">
      </span>
      <h3 id="head-3-383">
       What's Missing from the Standard Library
      </h3>
      <p>
       The Standard Library is powerful, but it's not perfect. Here are two examples of missing functionality:
      </p>
      <ul class="check1" id="c16-list-0008">
       <li id="c16-li-0023">
        The Standard Library does not guarantee any thread safety for accessing containers simultaneously from multiple threads.
       </li>
       <li id="c16-li-0024">
        The Standard Library does not provide any generic tree or graph structures. Although
        <code>
         map
        </code>
        and
        <code>
         set
        </code>
        are generally implemented as balanced binary trees, the Standard Library does not expose this implementation in the interface. If you need a tree or graph structure for something like writing a parser, you need to implement your own or find an implementation in another library.
       </li>
      </ul>
      <p id="c16-para-0268">
       It is important to keep in mind that the Standard Library is
       <i>
        extensible
       </i>
       . You can write your own containers and algorithms that work with existing algorithms and containers. So, if the Standard Library doesn't provide exactly what you need, consider writing your desired code such that it works with the Standard Library.
       <a href="c25.xhtml">
        Chapter 25
       </a>
       covers the topic of customizing and extending the Standard Library with custom algorithms and custom containers. Alternatively, you can consider buying or licensing a Standard Library-compliant third-party library that provides the required functionality. See
       <a href="c04.xhtml">
        Chapter 4
       </a>
       , “Designing Professional C++ Programs,” for a discussion on using third-party libraries and licensing options.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-187">
     <span id="c16-sec-0087">
     </span>
     <h2 id="head-2-187">
      SUMMARY
     </h2>
     <p id="c16-para-0269">
      This chapter provided an overview of the C++ Standard Library, which is the most important library that you will use in your code. It subsumes the C library and includes additional facilities for strings, I/O, error handling, and other tasks. It also includes generic containers, algorithms, and the ranges library. The following chapters describe the Standard Library in more detail.
     </p>
    </section>
    <section aria-labelledby="head-2-188">
     <span id="c16-sec-0088">
     </span>
     <h2 id="head-2-188">
      EXERCISES
     </h2>
     <p id="c16-para-0270">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c16-exsec-0001">
      </span>
      <ol class="none">
       <li id="c16-ex-0001">
        <b>
         Exercise 16-1:
        </b>
        The C++ Standard Library provides a whole selection of containers for you to choose from. What should be your preferred container and why?
       </li>
       <li id="c16-ex-0002">
        <b>
         Exercise 16-2:
        </b>
        What are the differences between a
        <code>
         map
        </code>
        and an
        <code>
         unordered_map
        </code>
        ?
       </li>
       <li id="c16-ex-0003">
        <b>
         Exercise 16-3:
        </b>
        What are vocabulary types? Besides the vocabulary types already used earlier in this book, this chapter introduced a few additional vocabulary types provided by the C++ Standard Library. What are they?
       </li>
       <li id="c16-ex-0004">
        <span aria-label="651" epub:type="pagebreak" id="Page_651" role="doc-pagebreak">
        </span>
        <b>
         Exercise 16-4:
        </b>
        A self-service restaurant usually has a spring-loaded mechanism containing plates. As a customer, you take a plate from the top. When plates are cleaned and ready to be used again, they are placed on top of any remaining plates in the mechanism. How would you model such a system in C++?
       </li>
       <li id="c16-ex-0005">
        <b>
         Exercise 16-5:
        </b>
        What is a partition?
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
