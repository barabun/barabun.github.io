<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   15Overloading C++ Operators
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_026.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_028.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c15_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c15_1">
      <span aria-label="577" class="calibre17" epub:type="pagebreak" id="Page_577" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c15">
      </span>
      <span class="calibre">
       15
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Overloading C++ Operators
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c15-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c15-list-0001">
         <li class="calibre9" id="c15-li-0001">
          What operator overloading is
         </li>
         <li class="calibre9" id="c15-li-0002">
          Rationale for overloading operators
         </li>
         <li class="calibre9" id="c15-li-0003">
          Limitations, caveats, and choices in operator overloading
         </li>
         <li class="calibre9" id="c15-li-0004">
          Summary of operators you can, cannot, and should not overload
         </li>
         <li class="calibre9" id="c15-li-0005">
          How to overload unary plus, unary minus, increment, and decrement
         </li>
         <li class="calibre9" id="c15-li-0006">
          How to overload the I/O stream operators (
          <code class="calibre21">
           operator&lt;&lt;
          </code>
          and
          <code class="calibre21">
           operator&gt;&gt;
          </code>
          )
         </li>
         <li class="calibre9" id="c15-li-0007">
          How to overload the subscripting (array index) operator
         </li>
         <li class="calibre9" id="c15-li-0008">
          How to write multidimensional subscripting operators
         </li>
         <li class="calibre9" id="c15-li-0009">
          How to overload the function call operator
         </li>
         <li class="calibre9" id="c15-li-0010">
          How to overload the dereferencing operators (
          <code class="calibre21">
           *
          </code>
          and
          <code class="calibre21">
           -&gt;
          </code>
          )
         </li>
         <li class="calibre9" id="c15-li-0011">
          How to write conversion operators
         </li>
         <li class="calibre9" id="c15-li-0012">
          How to overload the memory allocation and deallocation operators
         </li>
         <li class="calibre9" id="c15-li-0013">
          How to define your own user-defined literal operators
         </li>
         <li class="calibre9" id="c15-li-0014">
          The available standard literal operators
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30" id="head-2-171">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c15-sec-0003">
        </span>
        <p class="calibre25" id="c15-para-0004">
         Please note that all the code examples for this chapter are available as part of the chapter's code download on this book's website at
         <code class="calibre21">
          <code class="calibre21">
           <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c15-para-0005">
      <span aria-label="578" class="calibre20" epub:type="pagebreak" id="Page_578" role="doc-pagebreak">
      </span>
      C++ allows you to redefine the meanings of operators, such as
      <code class="calibre21">
       +
      </code>
      ,
      <code class="calibre21">
       -
      </code>
      , and
      <code class="calibre21">
       =
      </code>
      , for your classes. Many object-oriented languages do not provide this capability, so you might be tempted to disregard its usefulness in C++. However, it is instrumental for making your classes behave similarly to built-in types such as
      <code class="calibre21">
       int
      </code>
      s and
      <code class="calibre21">
       double
      </code>
      s. It is even possible to write classes that look like arrays, functions, or pointers.
     </p>
     <p class="calibre13" id="c15-para-0006">
      <a class="calibre5" href="c05.xhtml">
       Chapter 5
      </a>
      , “Designing with Classes,” and
      <a class="calibre5" href="c06.xhtml">
       Chapter 6
      </a>
      , “Designing for Reuse,” introduce object-oriented design and operator overloading, respectively.
      <a class="calibre5" href="c08.xhtml">
       Chapter 8
      </a>
      , “Gaining Proficiency with Classes and Objects,” and
      <a class="calibre5" href="c09.xhtml">
       Chapter 9
      </a>
      , “Mastering Classes and Objects,” present the syntax details for objects and for basic operator overloading. This chapter picks up operator overloading where
      <a class="calibre5" href="c09.xhtml">
       Chapter 9
      </a>
      left off.
     </p>
    </section>
    <section aria-labelledby="head-2-172" class="calibre2">
     <span class="calibre" id="c15-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-172">
      OVERVIEW OF OPERATOR OVERLOADING
     </h2>
     <p class="calibre13" id="c15-para-0007">
      As
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library,” explains, operators in C++ are symbols such as
      <code class="calibre21">
       +
      </code>
      ,
      <code class="calibre21">
       &lt;
      </code>
      ,
      <code class="calibre21">
       *
      </code>
      , and
      <code class="calibre21">
       &lt;&lt;
      </code>
      . They work on built-in types such as
      <code class="calibre21">
       int
      </code>
      and
      <code class="calibre21">
       double
      </code>
      to allow you to perform arithmetic, logical, and other operations. There are also operators such as
      <code class="calibre21">
       -&gt;
      </code>
      and
      <code class="calibre21">
       *
      </code>
      that allow you to dereference pointers. The concept of operators in C++ is broad, and even includes
      <code class="calibre21">
       []
      </code>
      (array index),
      <code class="calibre21">
       ()
      </code>
      (function call), casting, and the memory allocation and deallocation operators. Operator overloading allows you to change the behavior of language operators for your classes. However, this capability comes with rules, limitations, and choices.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-327">
       Why Overload Operators?
      </h3>
      <p class="calibre13" id="c15-para-0008">
       Before learning how to overload operators, you probably want to know why you would ever want to do so. The reasons vary for the different operators, but the general guiding principle is to make your classes behave like built-in types. The closer your classes are to built-in types, the easier they will be for clients to use. For example, if you want to write a class to represent fractions, it's quite helpful to have the ability to define what
       <code class="calibre21">
        +
       </code>
       ,
       <code class="calibre21">
        -
       </code>
       ,
       <code class="calibre21">
        *
       </code>
       , and
       <code class="calibre21">
        /
       </code>
       mean when applied to objects of that class.
      </p>
      <p class="calibre13" id="c15-para-0009">
       Another reason to overload operators is to gain greater control over the behavior in your program. For example, you can overload memory allocation and deallocation operators for your classes to specify exactly how memory should be distributed and reclaimed for each new object.
      </p>
      <p class="calibre13" id="c15-para-0010">
       It's important to emphasize that operator overloading doesn't necessarily make things easier for you as the class developer; its main purpose is to make things easier for users of the class.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-328">
       Limitations to Operator Overloading
      </h3>
      <p class="calibre13">
       Here is a list of things you cannot do when you overload operators:
      </p>
      <ul class="check" id="c15-list-0002">
       <li class="calibre9" id="c15-li-0015">
        You cannot add new operator symbols. You can only redefine the meanings of operators already in the language. The table in the section “
        <a class="calibre5" href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        ” later in this chapter lists all of the operators that you can overload.
       </li>
       <li class="calibre9" id="c15-li-0016">
        There are a few operators that you cannot overload, such as
        <code class="calibre21">
         .
        </code>
        and
        <code class="calibre21">
         .*
        </code>
        (member access in an object),
        <code class="calibre21">
         ::
        </code>
        (scope resolution operator), and
        <code class="calibre21">
         ?:
        </code>
        (the conditional operator). The table lists all the operators that you
        <i class="calibre18">
         can
        </i>
        overload. The operators that you can't overload are usually not those you would care to overload anyway, so you shouldn't find this restriction limiting.
       </li>
       <li class="calibre9" id="c15-li-0017">
        <span aria-label="579" class="calibre20" epub:type="pagebreak" id="Page_579" role="doc-pagebreak">
        </span>
        The
        <i class="calibre18">
         arity
        </i>
        describes the number of arguments, or
        <i class="calibre18">
         operands
        </i>
        , associated with the operator. You can change the arity only for the function call, new, and delete operators, and, since C++23, also for the subscripting operator (array index),
        <code class="calibre21">
         []
        </code>
        . For all other operators, you cannot change the arity. Unary operators, such as
        <code class="calibre21">
         ++
        </code>
        , work on only one operand. Binary operators, such as
        <code class="calibre21">
         /
        </code>
        , work on two operands.
       </li>
       <li class="calibre9" id="c15-li-0018">
        You cannot change the
        <i class="calibre18">
         precedence
        </i>
        nor the
        <i class="calibre18">
         associativity
        </i>
        of an operator. The precedence is used to decide which operators need to be executed before other operators, while the associativity can be either left-to-right or right-to-left and specifies in which order operators of the same precedence are executed. Again, this constraint shouldn't be cause for concern in most programs because there are rarely benefits to changing the order of evaluation, but, in certain domains, it's something to keep in mind. For example, if you are writing a class to represent mathematical vectors and would like to overload the
        <code class="calibre21">
         ^
        </code>
        operator to be able to raise a vector to a certain power, then keep in mind that
        <code class="calibre21">
         ^
        </code>
        has lower precedence compared to many other operators such as
        <code class="calibre21">
         +
        </code>
        . For instance, suppose
        <code class="calibre21">
         x
        </code>
        and
        <code class="calibre21">
         y
        </code>
        are mathematical vectors, writing
        <code class="calibre21">
         x^3+y
        </code>
        will be evaluated as
        <code class="calibre21">
         x^(3+y)
        </code>
        and not as
        <code class="calibre21">
         (x^3)+y
        </code>
        as you probably intended.
       </li>
       <li class="calibre9" id="c15-li-0019">
        You cannot redefine operators for built-in types. The operator must be a member function in a class, or at least one of the arguments to a global overloaded operator function must be a user-defined type (for example, a class). This means that you can't do something ridiculous, such as redefine
        <code class="calibre21">
         +
        </code>
        for
        <code class="calibre21">
         int
        </code>
        s to mean subtraction (though you could do so for your own classes). The one exception to this rule is the memory allocation and deallocation operators; you can replace the global operators for all memory allocations in your program.
       </li>
      </ul>
      <p class="calibre13" id="c15-para-0012">
       Some of the operators already mean two different things. For example,
       <code class="calibre21">
        operator-
       </code>
       can be used as a binary operator (as in
       <code class="calibre21">
        x=y-z;
       </code>
       ) or as a unary operator (as in
       <code class="calibre21">
        x=-y;
       </code>
       ). The
       <code class="calibre21">
        *
       </code>
       operator can be used for multiplication or for dereferencing a pointer. The &lt;&lt; operator is the stream insertion operator or the left-shift operator, depending on the context. For such dual-meaning operators, you can overload both meanings.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0007">
      </span>
      <h3 class="calibre27" id="head-3-329">
       Choices in Operator Overloading
      </h3>
      <p class="calibre13">
       When you overload an operator, you write a global function or member function with the name
       <code class="calibre21">
        operatorX
       </code>
       , where
       <code class="calibre21">
        X
       </code>
       is the symbol for some operator, and with optional whitespace between
       <code class="calibre21">
        operator
       </code>
       and
       <code class="calibre21">
        X
       </code>
       . For example,
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       declares
       <code class="calibre21">
        operator+
       </code>
       for
       <code class="calibre21">
        SpreadsheetCell
       </code>
       objects like this:
      </p>
      <pre class="calibre26" id="c15-code-0001"><code class="calibre21">SpreadsheetCell operator+(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs);</code></pre>
      <p class="calibre13" id="c15-para-0014">
       The following sections describe several choices involved in each overloaded operator you write.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0008">
       </span>
       <h4 class="calibre29" id="head-4-245">
        Member Function or Global Function
       </h4>
       <p class="calibre13" id="c15-para-0015">
        First, you must decide whether your operator should be a member function of your class or a global function. The latter can be a
        <code class="calibre21">
         friend
        </code>
        of the class, although that should be a last resort — adding
        <code class="calibre21">
         friend
        </code>
        s to a class should be limited as much as possible, as they can access
        <code class="calibre21">
         private
        </code>
        data members directly and thus circumvent the data-hiding principle.
       </p>
       <p class="calibre13" id="c15-para-0016">
        How do you choose between a member function or a global function? First, you need to understand the difference between these two choices. When the operator is a member function of a class, the
        <span aria-label="580" class="calibre20" epub:type="pagebreak" id="Page_580" role="doc-pagebreak">
        </span>
        left-hand side of the operator expression must always be an object of that class. If you write a global function, the left-hand side can be an object of a different type.
       </p>
       <p class="calibre13">
        There are three different types of operators:
       </p>
       <ul class="check" id="c15-list-0003">
        <li class="calibre9" id="c15-li-0020">
         <b class="calibre14">
          Operators that must be member functions.
         </b>
         The C++ language requires some operators to be member functions of a class because they don't make sense outside of a class. For example,
         <code class="calibre21">
          operator=
         </code>
         is tied so closely to the class that it can't exist anywhere else. The table in the section “
         <a class="calibre5" href="#c15-sec-0013">
          Summary of Overloadable Operators
         </a>
         ” lists those operators that must be member functions. Most operators do not impose this requirement.
        </li>
        <li class="calibre9" id="c15-li-0021">
         <b class="calibre14">
          Operators that must be global functions.
         </b>
         Whenever you need to allow the left-hand side of the operator to be a variable of a different type than your class, you must make the operator a global function. This rule applies specifically to the
         <code class="calibre21">
          &lt;&lt;
         </code>
         and
         <code class="calibre21">
          &gt;&gt;
         </code>
         insertion and extraction streaming operators, where the left-hand side is an
         <code class="calibre21">
          iostream
         </code>
         object, not an object of your class. It also applies to commutative operators like binary
         <code class="calibre21">
          +
         </code>
         and
         <code class="calibre21">
          –
         </code>
         , which should allow variables that are not objects of your class on the left-hand side. A global function is required if implicit conversions are desired for the left operand of a binary operator.
         <a class="calibre5" href="c09.xhtml">
          Chapter 9
         </a>
         discusses this problem.
        </li>
        <li class="calibre9" id="c15-li-0022">
         <b class="calibre14">
          Operators that can be either member functions or global functions.
         </b>
         There is some disagreement in the C++ community on whether it's better to write member functions or global functions to overload operators. However, I recommend the following rule: make every operator a member function unless you must make it a global function, as described previously. One major advantage to this rule is that member functions can be
         <code class="calibre21">
          virtual
         </code>
         , while global functions obviously cannot. Therefore, when you plan to write overloaded operators in an inheritance tree, you should make them member functions if possible.
        </li>
       </ul>
       <p class="calibre13" id="c15-para-0018">
        When you write an overloaded operator as a member function, you should mark it
        <code class="calibre21">
         const
        </code>
        if it doesn't change the object. That way, it can be called on
        <code class="calibre21">
         const
        </code>
        objects.
       </p>
       <p class="calibre13" id="c15-para-0019">
        When you write an overloaded operator as a global function, put it in the same namespace that contains the class for which the operator is written.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0009">
       </span>
       <h4 class="calibre29" id="head-4-246">
        Choosing Argument Types
       </h4>
       <p class="calibre13" id="c15-para-0020">
        You are somewhat limited in your choice of argument types because, as stated earlier, for most operators you cannot change the number of arguments. For example,
        <code class="calibre21">
         operator/
        </code>
        must always have two arguments if it is a global function, and one argument if it's a member function. The compiler issues an error if it differs from this standard. In this sense, the operator functions are different from normal functions, which you can overload with any number of parameters. Additionally, although you can write the operator for whichever types you want, the choice is usually constrained by the class for which you are writing the operator. For example, if you want to implement addition for class
        <code class="calibre21">
         T
        </code>
        , you don't write an
        <code class="calibre21">
         operator+
        </code>
        that takes two
        <code class="calibre21">
         string
        </code>
        s! The real choice arises when you try to determine whether to take parameters by value or by reference and whether to make them
        <code class="calibre21">
         const
        </code>
        .
       </p>
       <p class="calibre13" id="c15-para-0021">
        The choice of value versus reference is easy: you should take every non-primitive parameter type by reference, unless the function always makes a copy of the passed object, see
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        .
       </p>
       <p class="calibre13" id="c15-para-0022">
        <span aria-label="581" class="calibre20" epub:type="pagebreak" id="Page_581" role="doc-pagebreak">
        </span>
        The
        <code class="calibre21">
         const
        </code>
        decision is also trivial: mark every parameter
        <code class="calibre21">
         const
        </code>
        unless you actually modify it. The table in the section “
        <a class="calibre5" href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        ” shows sample prototypes for each operator, with the arguments marked
        <code class="calibre21">
         const
        </code>
        and reference as appropriate.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0010">
       </span>
       <h4 class="calibre29" id="head-4-247">
        Choosing Return Types
       </h4>
       <p class="calibre13" id="c15-para-0023">
        C++ doesn't determine overload resolution based on return type. Thus, you can specify any return type you want when you write overloaded operators. However, just because you
        <i class="calibre18">
         can
        </i>
        do something doesn't mean you
        <i class="calibre18">
         should
        </i>
        do it. This flexibility implies that you could write confusing code in which comparison operators return pointers, and arithmetic operators return
        <code class="calibre21">
         bool
        </code>
        s. However, you shouldn't do that. Instead, you should write your overloaded operators such that they return the same types as the operators do for the built-in types. If you write a comparison operator, return a
        <code class="calibre21">
         bool
        </code>
        . If you write an arithmetic operator, return an object representing the result. Sometimes the return type is not obvious at first. For example, as
        <a class="calibre5" href="c08.xhtml">
         Chapter 8
        </a>
        mentions,
        <code class="calibre21">
         operator=
        </code>
        should return a reference to the object on which it's called in order to support chained assignments. Other operators have similarly tricky return types, all of which are summarized in the table in the section “
        <a class="calibre5" href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        .”
       </p>
       <p class="calibre13" id="c15-para-0024">
        The same choices of reference and
        <code class="calibre21">
         const
        </code>
        apply to return types as well. However, for return values, the choices are more difficult. The general rule for value or reference is to return a reference if you can; otherwise, return a value. How do you know when you can return a reference? This choice applies only to operators that return objects: the choice is moot for the comparison operators that return
        <code class="calibre21">
         bool
        </code>
        , the conversion operators that have no return type, and the function call operator, which may return any type you want. If your operator constructs a new object, then you must return that new object by value. If it does not construct a new object, you can return a reference to the object on which the operator is called, or one of its arguments. The table in the section “
        <a class="calibre5" href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        ” shows examples.
       </p>
       <p class="calibre13" id="c15-para-0025">
        A return value that can be modified as an
        <i class="calibre18">
         lvalue
        </i>
        (e.g., on the left-hand side of an assignment expression) must be non-
        <code class="calibre21">
         const
        </code>
        . Otherwise, it should be
        <code class="calibre21">
         const
        </code>
        . More operators than you might expect require that you return lvalues, including all of the assignment operators (
        <code class="calibre21">
         operator=
        </code>
        ,
        <code class="calibre21">
         operator+=
        </code>
        ,
        <code class="calibre21">
         operator-=
        </code>
        , and so on).
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-248">
        Choosing Behavior
       </h4>
       <p class="calibre13" id="c15-para-0026">
        You can provide whichever implementation you want in an overloaded operator. For example, you could write an
        <code class="calibre21">
         operator+
        </code>
        that launches a game of Scrabble. However, as
        <a class="calibre5" href="c06.xhtml">
         Chapter 6
        </a>
        describes, you should generally constrain your implementations to provide behaviors that clients expect. Write
        <code class="calibre21">
         operator+
        </code>
        so that it performs addition, or something like addition, such as string concatenation. This chapter explains how you
        <i class="calibre18">
         should
        </i>
        implement your overloaded operators. In exceptional circumstances, you might want to differ from these recommendations; but, in general, you should follow the standard patterns.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0012">
      </span>
      <h3 class="calibre27" id="head-3-330">
       Operators You Shouldn't Overload
      </h3>
      <p class="calibre13" id="c15-para-0027">
       Some operators should not be overloaded, even though it is permitted. Specifically, the address-of operator (
       <code class="calibre21">
        operator&amp;
       </code>
       ) is not particularly useful to overload and leads to confusion if you do because
       <span aria-label="582" class="calibre20" epub:type="pagebreak" id="Page_582" role="doc-pagebreak">
       </span>
       <span aria-label="583" class="calibre20" epub:type="pagebreak" id="Page_583" role="doc-pagebreak">
       </span>
       you are changing fundamental language behavior (taking addresses of variables) in potentially unexpected ways. The entire Standard Library, which uses operator overloading extensively, never overloads the address-of operator.
      </p>
      <p class="calibre13" id="c15-para-0028">
       Additionally, you should avoid overloading the binary Boolean operators
       <code class="calibre21">
        operator&amp;&amp;
       </code>
       and
       <code class="calibre21">
        ||
       </code>
       because you lose C++'s short-circuit evaluation rules. Short-circuiting is not possible in that case because all operands need to be evaluated before they can be passed to your overloaded operator function. If your class needs logical operators, provide
       <code class="calibre21">
        operator&amp;
       </code>
       and
       <code class="calibre21">
        |
       </code>
       instead.
      </p>
      <p class="calibre13">
       Finally, you should not overload the comma operator (
       <code class="calibre21">
        operator,
       </code>
       ). Yes, you read that correctly: there really is a comma operator in C++. It's also called the
       <i class="calibre18">
        sequencing operator
       </i>
       , and is used to separate two expressions in a single statement, while guaranteeing that they are evaluated left to right. The following snippet demonstrates the comma operator:
      </p>
      <pre class="calibre26" id="c15-code-0002"><code class="calibre21">int x { 1 };</code>
<code class="calibre21">println("{}", (++x, 2 * x)); <span class="color">// Increments x to 2, doubles it, and prints 4.</span></code></pre>
      <p class="calibre13" id="c15-para-0030">
       There is rarely a good reason to overload the comma operator.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0013">
      </span>
      <span aria-label="584" class="calibre20" epub:type="pagebreak" id="Page_584" role="doc-pagebreak">
      </span>
      <span aria-label="585" class="calibre20" epub:type="pagebreak" id="Page_585" role="doc-pagebreak">
      </span>
      <h3 class="calibre27" id="head-3-331">
       Summary of Overloadable Operators
      </h3>
      <p class="calibre13" id="c15-para-0031">
       The following table lists the operators you can overload, specifies whether they should be member functions of the class or global functions, summarizes when you should (or should not) overload them, and provides sample prototypes showing the proper parameter and return value types. Operators that cannot be overloaded, such as
       <code class="calibre21">
        .
       </code>
       ,
       <code class="calibre21">
        .*
       </code>
       ,
       <code class="calibre21">
        ::
       </code>
       , and
       <code class="calibre21">
        ?:
       </code>
       are not in this list.
      </p>
      <p class="calibre13" id="c15-para-0032">
       This table is a useful reference for the future when you want to write an overloaded operator. You're bound to forget which return type you should use and whether or not the function should be a member function.
      </p>
      <p class="calibre13" id="c15-para-0033">
       In this table,
       <code class="calibre21">
        T
       </code>
       is the name of the class for which the overloaded operator is written, and
       <code class="calibre21">
        E
       </code>
       is a different type. The sample prototypes given are not exhaustive; often there are other combinations of
       <code class="calibre21">
        T
       </code>
       and
       <code class="calibre21">
        E
       </code>
       possible for a given operator:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          OPERATOR
         </th>
         <th class="left" scope="col">
          NAME OR CATEGORY
         </th>
         <th class="left" scope="col">
          MEMBER FUNCTION OR GLOBAL FUNCTION
         </th>
         <th class="left" scope="col">
          WHEN TO OVERLOAD
         </th>
         <th class="left" scope="col">
          SAMPLE PROTOTYPES
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator+
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator-
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator*
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator/
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator%
          </code>
         </td>
         <td class="left1">
          Binary arithmetic
         </td>
         <td class="left1">
          Global function recommended
         </td>
         <td class="left1">
          Whenever you want to provide these operations for your class
         </td>
         <td class="left1">
          <code class="calibre21">
           T operator+(const T&amp;, const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           T operator+(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator-
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator+
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator˜
          </code>
         </td>
         <td class="left1">
          Unary arithmetic and bitwise operators
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you want to provide these operations for your class
         </td>
         <td class="left1">
          <code class="calibre21">
           T operator-() const;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator++
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator--
          </code>
         </td>
         <td class="left1">
          Pre-increment and pre-decrement
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you overload
          <code class="calibre21">
           +=
          </code>
          and
          <code class="calibre21">
           -=
          </code>
          taking an arithmetic argument (
          <code class="calibre21">
           int
          </code>
          ,
          <code class="calibre21">
           long
          </code>
          , …)
         </td>
         <td class="left1">
          <code class="calibre21">
           T&amp; operator++();
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator++
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator--
          </code>
         </td>
         <td class="left1">
          Post-increment and post-decrement
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you overload
          <code class="calibre21">
           +=
          </code>
          and
          <code class="calibre21">
           -=
          </code>
          taking an arithmetic argument (
          <code class="calibre21">
           int
          </code>
          ,
          <code class="calibre21">
           long
          </code>
          , …)
         </td>
         <td class="left1">
          <code class="calibre21">
           T operator++(int);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator=
          </code>
         </td>
         <td class="left1">
          Assignment operator
         </td>
         <td class="left1">
          Member function required
         </td>
         <td class="left1">
          Whenever your class has dynamically allocated resources, or members that are references
         </td>
         <td class="left1">
          <code class="calibre21">
           T&amp; operator=(const T&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator+=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator-=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator*=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator/=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator%=
          </code>
         </td>
         <td class="left1">
          Shorthand / compound arithmetic assignment operator
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you overload the binary arithmetic operators and your class is not designed to be immutable
         </td>
         <td class="left1">
          <code class="calibre21">
           T&amp; operator+=(const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           T&amp; operator+=(const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&lt;&lt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&gt;&gt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&amp;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator|
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator^
          </code>
         </td>
         <td class="left1">
          Binary bitwise operators
         </td>
         <td class="left1">
          Global function recommended
         </td>
         <td class="left1">
          Whenever you want to provide these operations
         </td>
         <td class="left1">
          <code class="calibre21">
           T operator&lt;&lt;(const T&amp;, const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           T operator&lt;&lt;(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&lt;&lt;=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&gt;&gt;=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&amp;=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator|=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator^=
          </code>
         </td>
         <td class="left1">
          Shorthand / compound bitwise assignment operator
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you overload the binary bitwise operators and your class is not designed to be immutable
         </td>
         <td class="left1">
          <code class="calibre21">
           T&amp; operator&lt;&lt;=(const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           T&amp; operator&lt;&lt;=(const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&lt;=&gt;
          </code>
         </td>
         <td class="left1">
          Three-way comparison operator
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you want to provide comparison support for your class; if possible, this should be defaulted using
          <code class="calibre21">
           =default
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           auto operator&lt;=&gt;(const T&amp;) const = default;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           partial_ordering operator&lt;=&gt;(const E&amp;) const;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator==
          </code>
         </td>
         <td class="left1">
          Binary equality operator
         </td>
         <td class="left1">
          Post-C++20: member function recommended
          <br class="calibre12"/>
          Pre-C++20: global function recommended
         </td>
         <td class="left1">
          Whenever you want to provide comparison support for your class, and you cannot default the three-way comparison operator
         </td>
         <td class="left1">
          <code class="calibre21">
           bool operator==(const T&amp;) const;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator==(const E&amp;) const;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator==(const T&amp;, const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator==(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator!=
          </code>
         </td>
         <td class="left1">
          Binary inequality operator
         </td>
         <td class="left1">
          Post-C++20: member function recommended
          <br class="calibre12"/>
          Pre-C++20: global function recommended
         </td>
         <td class="left1">
          Post-C++20: not needed as the compiler automatically provides
          <code class="calibre21">
           !=
          </code>
          when
          <code class="calibre21">
           ==
          </code>
          is supported
          <br class="calibre12"/>
          Pre-C++20: Whenever you want to provide comparison support for your class
         </td>
         <td class="left1">
          <code class="calibre21">
           bool operator!=(const T&amp;) const;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator!=(const E&amp;) const;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator!=(const T&amp;, const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator!=(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&lt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&gt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&lt;=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&gt;=
          </code>
         </td>
         <td class="left1">
          Binary comparison operators
         </td>
         <td class="left1">
          Global function recommended
         </td>
         <td class="left1">
          Whenever you want to provide these operations; not needed when
          <code class="calibre21">
           &lt;=&gt;
          </code>
          is provided
         </td>
         <td class="left1">
          <code class="calibre21">
           bool operator&lt;(const T&amp;, const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           bool operator&lt;(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&lt;&lt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator&gt;&gt;
          </code>
         </td>
         <td class="left1">
          I/O stream operators (insertion and extraction)
         </td>
         <td class="left1">
          Global function required
         </td>
         <td class="left1">
          Whenever you want to provide these operations
         </td>
         <td class="left1">
          <code class="calibre21">
           ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           istream&amp; operator&gt;&gt;(istream&amp;, T&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator!
          </code>
         </td>
         <td class="left1">
          Boolean negation operator
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Rarely; use
          <code class="calibre21">
           bool
          </code>
          or
          <code class="calibre21">
           void*
          </code>
          conversion instead
         </td>
         <td class="left1">
          <code class="calibre21">
           bool operator!() const;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&amp;&amp;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator||
          </code>
         </td>
         <td class="left1">
          Binary Boolean operators
         </td>
         <td class="left1">
          Global function recommended
         </td>
         <td class="left1">
          Rarely, if ever, because you lose short-circuiting; it's better to overload
          <code class="calibre21">
           &amp;
          </code>
          and
          <code class="calibre21">
           |
          </code>
          instead, as these never short-circuit
         </td>
         <td class="left1">
          <code class="calibre21">
           bool operator&amp;&amp;(const T&amp;, const T&amp;);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator[]
          </code>
         </td>
         <td class="left1">
          Subscripting (array index) operator
         </td>
         <td class="left1">
          Member function required
         </td>
         <td class="left1">
          When you want to support subscripting
         </td>
         <td class="left1">
          <code class="calibre21">
           E&amp; operator[](size_t);
           <br class="calibre12"/>
           const E&amp; operator[](size_t) const;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator()
          </code>
         </td>
         <td class="left1">
          Function call operator
         </td>
         <td class="left1">
          Member function required
         </td>
         <td class="left1">
          When you want objects to behave like function pointers
         </td>
         <td class="left1">
          Return type and parameters can vary; see later examples in this chapter
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator type()
          </code>
         </td>
         <td class="left1">
          Conversion, or cast, operators (separate operator for each type)
         </td>
         <td class="left1">
          Member function required
         </td>
         <td class="left1">
          When you want to provide conversions from your class to other types
         </td>
         <td class="left1">
          <code class="calibre21">
           operator double() const;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator ""_
           <i class="calibre18">
            x
           </i>
          </code>
         </td>
         <td class="left1">
          User-defined literal operator
         </td>
         <td class="left1">
          Global function required
         </td>
         <td class="left1">
          When you want to support user-defined literals
         </td>
         <td class="left1">
          <code class="calibre21">
           T operator""_i(long double d);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator new
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator new[]
          </code>
         </td>
         <td class="left1">
          Memory allocation routines
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          When you want to control memory allocation for your classes (rarely)
         </td>
         <td class="left1">
          <code class="calibre21">
           void* operator new(size_t size);
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           void* operator new[](size_t size);
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator delete
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator delete[]
          </code>
         </td>
         <td class="left1">
          Memory deallocation routines
         </td>
         <td class="left1">
          Member function recommended
         </td>
         <td class="left1">
          Whenever you overload the memory allocation routines (rarely)
         </td>
         <td class="left1">
          <code class="calibre21">
           void operator delete(void* ptr) noexcept;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           void operator delete[](void* ptr) noexcept;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator*
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           operator-&gt;
          </code>
         </td>
         <td class="left1">
          Dereferencing operators
         </td>
         <td class="left1">
          Member function recommended for
          <code class="calibre21">
           operator*
          </code>
          <br class="calibre12"/>
          Member function required for
          <code class="calibre21">
           operator-&gt;
          </code>
         </td>
         <td class="left1">
          Useful for smart pointers
         </td>
         <td class="left1">
          <code class="calibre21">
           E&amp; operator*() const;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           E* operator-&gt;() const;
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator&amp;
          </code>
         </td>
         <td class="left1">
          Address-of operator
         </td>
         <td class="left1">
          N/A
         </td>
         <td class="left1">
          Never
         </td>
         <td class="left1">
          N/A
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator-&gt;*
          </code>
         </td>
         <td class="left1">
          Dereference pointer-to-member
         </td>
         <td class="left1">
          N/A
         </td>
         <td class="left1">
          Never
         </td>
         <td class="left1">
          N/A
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           operator,
          </code>
         </td>
         <td class="left1">
          Comma operator
         </td>
         <td class="left1">
          N/A
         </td>
         <td class="left1">
          Never
         </td>
         <td class="left1">
          N/A
          <span aria-label="586" class="calibre20" epub:type="pagebreak" id="Page_586" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0014">
      </span>
      <h3 class="calibre27" id="head-3-332">
       Rvalue References
      </h3>
      <p class="calibre13">
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       discusses move semantics and rvalue references. It demonstrates these by defining move assignment operators, which are used by the compiler in cases where the source object is a temporary object that will be destroyed after the assignment, or an object that is explicitly moved from using
       <code class="calibre21">
        std::move()
       </code>
       . The normal assignment operator from the preceding table has the following prototype:
      </p>
      <pre class="calibre26" id="c15-code-0003"><code class="calibre21">T&amp; operator=(const T&amp;);</code></pre>
      <p class="calibre13">
       The move assignment operator has almost the same prototype, but uses an rvalue reference. It modifies the argument so it cannot be passed as
       <code class="calibre21">
        const
       </code>
       . See
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       for details.
      </p>
      <pre class="calibre26" id="c15-code-0004"><code class="calibre21">T&amp; operator=(T&amp;&amp;) noexcept;</code></pre>
      <p class="calibre13">
       <span aria-label="587" class="calibre20" epub:type="pagebreak" id="Page_587" role="doc-pagebreak">
       </span>
       The preceding table does not include sample prototypes with rvalue references. However, for most operators it can make sense to write both a version using normal lvalue references and a version using rvalue references. Whether or not it does make sense depends on implementation details of your class. The
       <code class="calibre21">
        operator=
       </code>
       is one example from
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       . Another example is
       <code class="calibre21">
        operator+
       </code>
       to prevent unnecessary memory allocations. The
       <code class="calibre21">
        std::string
       </code>
       class from the Standard Library, for example, implements an
       <code class="calibre21">
        operator+
       </code>
       using rvalue references as follows (simplified):
      </p>
      <pre class="calibre26" id="c15-code-0005"><code class="calibre21">string operator+(string&amp;&amp; lhs, string&amp;&amp; rhs);</code></pre>
      <p class="calibre13">
       The implementation of this operator reuses memory of one of the arguments because they are being passed as rvalue references, meaning both are temporary objects that will be destroyed when this
       <code class="calibre21">
        operator+
       </code>
       is finished. The implementation of this
       <code class="calibre21">
        operator+
       </code>
       has the following effect depending on the size and the capacity of both operands:
      </p>
      <pre class="calibre26" id="c15-code-0006"><code class="calibre21">return move(lhs.append(rhs));</code></pre>
      <p class="calibre13">
       or
      </p>
      <pre class="calibre26" id="c15-code-0007"><code class="calibre21">return move(rhs.insert(0, lhs));</code></pre>
      <p class="calibre13">
       In fact,
       <code class="calibre21">
        string
       </code>
       defines several
       <code class="calibre21">
        operator+
       </code>
       overloads accepting two
       <code class="calibre21">
        string
       </code>
       s as arguments and different combinations of lvalue and rvalue references. Here is a list (simplified):
      </p>
      <pre class="calibre26" id="c15-code-0008"><code class="calibre21">string operator+(const string&amp; lhs, const string&amp; rhs); <span class="color">// No memory reuse.</span></code>
<code class="calibre21">string operator+(string&amp;&amp; lhs, const string&amp; rhs); <span class="color">// Can reuse memory of lhs.</span></code>
<code class="calibre21">string operator+(const string&amp; lhs, string&amp;&amp; rhs); <span class="color">// Can reuse memory of rhs.</span></code>
<code class="calibre21">string operator+(string&amp;&amp; lhs, string&amp;&amp; rhs); <span class="color">// Can reuse memory of lhs or rhs.</span></code></pre>
      <p class="calibre13" id="c15-para-0119">
       Reusing memory of one of the rvalue reference arguments is implemented in the same way as it is explained for move assignment operators in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0015">
      </span>
      <h3 class="calibre27" id="head-3-333">
       Precedence and Associativity
      </h3>
      <p class="calibre13" id="c15-para-0120">
       In statements containing multiple operators, the
       <i class="calibre18">
        precedence
       </i>
       of the operators is used to decide which operators need to be executed before other operators. For example,
       <code class="calibre21">
        *
       </code>
       and
       <code class="calibre21">
        /
       </code>
       are always executed before
       <code class="calibre21">
        +
       </code>
       and
       <code class="calibre21">
        -
       </code>
       .
      </p>
      <p class="calibre13" id="c15-para-0121">
       The
       <i class="calibre18">
        associativity
       </i>
       can be either left-to-right or right-to-left and specifies in which order operators of the same precedence are executed.
      </p>
      <p class="calibre13" id="c15-para-0122">
       The following table lists the precedence and associativity of all available C++ operators, including those that you cannot overload and operators you haven't seen mentioned in this book yet. Operators with a lower precedence number are executed before operators with a higher precedence number. In the table,
       <code class="calibre21">
        T
       </code>
       represents a type, while
       <code class="calibre21">
        x
       </code>
       ,
       <code class="calibre21">
        y
       </code>
       , and
       <code class="calibre21">
        z
       </code>
       represent objects:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          PRECEDENCE
         </th>
         <th class="left" scope="col">
          OPERATOR
         </th>
         <th class="left" scope="col">
          ASSOCIATIVITY
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          1
         </td>
         <td class="left1">
          <code class="calibre21">
           ::
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          2
         </td>
         <td class="left1">
          <code class="calibre21">
           x++ x-- x() x[] T() T{} . -&gt;
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          3
         </td>
         <td class="left1">
          <code class="calibre21">
           ++x --x +x -x ! ˜ *x &amp;x (T)
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           sizeof co_await new delete new[] delete[]
          </code>
         </td>
         <td class="left1">
          Right-to-left
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          4
         </td>
         <td class="left1">
          <code class="calibre21">
           .* -&gt;*
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          5
         </td>
         <td class="left1">
          <code class="calibre21">
           x*y x/y x%y
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          6
         </td>
         <td class="left1">
          <code class="calibre21">
           x+y x-y
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          7
         </td>
         <td class="left1">
          <code class="calibre21">
           &lt;&lt; &gt;&gt;
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          8
         </td>
         <td class="left1">
          <code class="calibre21">
           &lt;=&gt;
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          9
         </td>
         <td class="left1">
          <code class="calibre21">
           &lt; &lt;= &gt; &gt;=
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          10
         </td>
         <td class="left1">
          <code class="calibre21">
           == !=
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          11
         </td>
         <td class="left1">
          <code class="calibre21">
           x&amp;y
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          12
         </td>
         <td class="left1">
          <code class="calibre21">
           ^
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          13
         </td>
         <td class="left1">
          <code class="calibre21">
           |
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          14
         </td>
         <td class="left1">
          <code class="calibre21">
           &amp;&amp;
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          15
         </td>
         <td class="left1">
          <code class="calibre21">
           ||
          </code>
         </td>
         <td class="left1">
          Left-to-right
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          16
         </td>
         <td class="left1">
          <code class="calibre21">
           x?y:z throw co_yield
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           = += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
          </code>
         </td>
         <td class="left1">
          Right-to-left
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          17
         </td>
         <td class="left1">
          <code class="calibre21">
           ,
          </code>
         </td>
         <td class="left1">
          Left-to-right
          <span aria-label="588" class="calibre20" epub:type="pagebreak" id="Page_588" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0016">
      </span>
      <h3 class="calibre27" id="head-3-334">
       Relational Operators
      </h3>
      <p class="calibre13">
       The following set of function templates for relational operators are defined in
       <code class="calibre21">
        &lt;utility&gt;
       </code>
       in the
       <code class="calibre21">
        std::rel_ops
       </code>
       namespace:
      </p>
      <pre class="calibre26" id="c15-code-0009"><code class="calibre21">template&lt;class T&gt; bool operator!=(const T&amp; a, const T&amp; b);<span class="color">// Needs operator==</span></code>
<code class="calibre21">template&lt;class T&gt; bool operator&gt;(const T&amp; a, const T&amp; b); <span class="color">// Needs operator&lt;</span></code>
<code class="calibre21">template&lt;class T&gt; bool operator&lt;=(const T&amp; a, const T&amp; b);<span class="color">// Needs operator&lt;</span></code>
<code class="calibre21">template&lt;class T&gt; bool operator&gt;=(const T&amp; a, const T&amp; b);<span class="color">// Needs operator&lt;</span></code></pre>
      <p class="calibre13" id="c15-para-0129">
       These function templates define the operators
       <code class="calibre21">
        !=
       </code>
       ,
       <code class="calibre21">
        &gt;
       </code>
       ,
       <code class="calibre21">
        &lt;=
       </code>
       , and
       <code class="calibre21">
        &gt;=
       </code>
       in terms of the
       <code class="calibre21">
        ==
       </code>
       and
       <code class="calibre21">
        &lt;
       </code>
       operators for any class. So, if you implement
       <code class="calibre21">
        operator==
       </code>
       and
       <code class="calibre21">
        &lt;
       </code>
       for your class, you get the other relational operators for free with these templates.
      </p>
      <p class="calibre13" id="c15-para-0130">
       However, there are a lot of problems with this technique. A first problem is that those operators might be created for all classes that you use in relational operations, not only for your own class.
      </p>
      <p class="calibre13" id="c15-para-0131">
       A second problem with this technique is that utility templates such as
       <code class="calibre21">
        std::greater&lt;T&gt;
       </code>
       (discussed in
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       , “Function Pointers, Function Objects, and Lambda Expressions”) do not work with those automatically generated relational operators.
      </p>
      <p class="calibre13" id="c15-para-0132">
       Yet another problem with these is that implicit conversions won't work.
      </p>
      <p class="calibre13">
       <span aria-label="589" class="calibre20" epub:type="pagebreak" id="Page_589" role="doc-pagebreak">
       </span>
       Finally, with C++20's three-way comparison operator and the fact that C++20 has deprecated the
       <code class="calibre21">
        std::rel_ops
       </code>
       namespace, there is no longer any reason to still use
       <code class="calibre21">
        rel_ops
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0134">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Never use
           <code class="calibre21">
            std::rel_ops
           </code>
           ; it has been deprecated since C++20! Instead, to add support for all six comparison operators to a class, just explicitly default or implement
          </i>
          <code class="calibre21">
           operator&lt;=&gt;
          </code>
          <i class="calibre18">
           and possibly
          </i>
          <code class="calibre21">
           operator==
          </code>
          <i class="calibre18">
           for the class. See
           <a class="calibre5" href="c09.xhtml">
            Chapter 9
           </a>
           for details.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0018">
      </span>
      <h3 class="calibre27" id="head-3-335">
       Alternative Notation
      </h3>
      <p class="calibre13" id="c15-para-0135">
       C++ supports the following alternative notations for a selection of operators. These were mainly used in the old days when using character sets that didn't include certain characters such as ˜, |, and ^.
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          OPERATOR
         </th>
         <th class="left" scope="col">
          ALTERNATIVE NOTATION
         </th>
         <th class="calibre39" scope="col">
         </th>
         <th class="left" scope="col">
          OPERATOR
         </th>
         <th class="left" scope="col">
          ALTERNATIVE NOTATION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           &amp;&amp;
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           and
          </code>
         </td>
         <td class="calibre40">
         </td>
         <td class="left1">
          <code class="calibre21">
           !=
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           not_eq
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           &amp;=
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           and_eq
          </code>
         </td>
         <td class="calibre40">
         </td>
         <td class="left1">
          <code class="calibre21">
           ||
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           or
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           &amp;
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           bitand
          </code>
         </td>
         <td class="calibre40">
         </td>
         <td class="left1">
          <code class="calibre21">
           |=
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           or_eq
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           |
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           bitor
          </code>
         </td>
         <td class="calibre40">
         </td>
         <td class="left1">
          <code class="calibre21">
           ^
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           xor
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           ˜
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           compl
          </code>
         </td>
         <td class="calibre40">
         </td>
         <td class="left1">
          <code class="calibre21">
           ^=
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           xor_eq
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           !
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           not
          </code>
         </td>
         <td class="calibre40">
         </td>
         <td class="left1">
         </td>
         <td class="left1">
         </td>
        </tr>
       </tbody>
      </table>
     </section>
    </section>
    <section aria-labelledby="head-2-173" class="calibre2">
     <span class="calibre" id="c15-sec-0019">
     </span>
     <h2 class="calibre6" id="head-2-173">
      OVERLOADING THE ARITHMETIC OPERATORS
     </h2>
     <p class="calibre13" id="c15-para-0137">
      <a class="calibre5" href="c09.xhtml">
       Chapter 9
      </a>
      shows how to write the binary arithmetic operators and the shorthand arithmetic assignment operators, but it does not cover how to overload the other arithmetic operators.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0020">
      </span>
      <h3 class="calibre27" id="head-3-336">
       Overloading Unary Minus and Unary Plus
      </h3>
      <p class="calibre13">
       C++ has several unary arithmetic operators. Two of these are unary minus and unary plus. Here is an example of these operators using
       <code class="calibre21">
        int
       </code>
       s:
      </p>
      <pre class="calibre26" id="c15-code-0010"><code class="calibre21">int i, j { 4 };</code>
<code class="calibre21">i = -j;    <span class="color">// Unary minus</span></code>
<code class="calibre21">i = +i;    <span class="color">// Unary plus</span></code>
<code class="calibre21">j = +(-i); <span class="color">// Apply unary plus to the result of applying unary minus to i.</span></code>
<code class="calibre21">j = -(-i); <span class="color">// Apply unary minus to the result of applying unary minus to i.</span></code></pre>
      <p class="calibre13" id="c15-para-0139">
       Unary minus negates the operand, while unary plus returns the operand directly. Note that you can apply unary plus or unary minus to the result of unary plus or unary minus. These operators don't change the object on which they are called so you should make them
       <code class="calibre21">
        const
       </code>
       .
      </p>
      <p class="calibre13">
       <span aria-label="590" class="calibre20" epub:type="pagebreak" id="Page_590" role="doc-pagebreak">
       </span>
       Here is an example of a unary
       <code class="calibre21">
        operator-
       </code>
       as a member function for a
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class. Unary plus is usually an identity operation, so this class doesn't overload it.
      </p>
      <pre class="calibre26" id="c15-code-0011"><code class="calibre21">SpreadsheetCell SpreadsheetCell::operator-() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return SpreadsheetCell { -getValue() };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        operator-
       </code>
       doesn't change the operand, so this member function must construct a new
       <code class="calibre21">
        SpreadsheetCell
       </code>
       with the negated value and return it. Hence, it can't return a reference. You can use this operator as follows:
      </p>
      <pre class="calibre26" id="c15-code-0012"><code class="calibre21">SpreadsheetCell c1 { 4 };</code>
<code class="calibre21">SpreadsheetCell c3 { -c1 };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0021">
      </span>
      <h3 class="calibre27" id="head-3-337">
       Overloading Increment and Decrement
      </h3>
      <p class="calibre13">
       There are several ways to add 1 to a variable:
      </p>
      <pre class="calibre26" id="c15-code-0013"><code class="calibre21">i = i + 1;</code>
<code class="calibre21">i = 1 + i;</code>
<code class="calibre21">i += 1;</code>
<code class="calibre21">++i;</code>
<code class="calibre21">i++;</code></pre>
      <p class="calibre13" id="c15-para-0143">
       The last two forms are called the
       <i class="calibre18">
        increment
       </i>
       operators. The first of these is
       <i class="calibre18">
        prefix increment
       </i>
       , which adds 1 to the variable and then returns the newly incremented value for use in the rest of the expression. The second is
       <i class="calibre18">
        postfix increment
       </i>
       , which also adds 1 to the variable but returns the old (non-incremented) value for use in the rest of the expression. The decrement operators work similarly.
      </p>
      <p class="calibre13" id="c15-para-0144">
       The two possible meanings for
       <code class="calibre21">
        operator++
       </code>
       and
       <code class="calibre21">
        operator--
       </code>
       (prefix and postfix) present a problem when you want to overload them. When you write an overloaded
       <code class="calibre21">
        operator++
       </code>
       , for example, how do you specify whether you are overloading the prefix or the postfix version? C++ introduced a hack to allow you to make this distinction: the prefix versions of
       <code class="calibre21">
        operator++
       </code>
       and
       <code class="calibre21">
        operator--
       </code>
       take no arguments, while the postfix versions take one unused argument of type
       <code class="calibre21">
        int
       </code>
       .
      </p>
      <p class="calibre13">
       The prototypes of these overloaded operators for the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class look like this:
      </p>
      <pre class="calibre26" id="c15-code-0014"><code class="calibre21">SpreadsheetCell&amp; operator++();   <span class="color">// Prefix</span></code>
<code class="calibre21">SpreadsheetCell operator++(int); <span class="color">// Postfix</span></code>
<code class="calibre21">SpreadsheetCell&amp; operator--();   <span class="color">// Prefix</span></code>
<code class="calibre21">SpreadsheetCell operator--(int); <span class="color">// Postfix</span></code></pre>
      <p class="calibre13" id="c15-para-0146">
       The return value in the prefix forms is the same as the end value of the operand, so prefix increment and decrement can return a reference to the object on which they are called. The postfix versions of increment and decrement, however, return values that are different from the end values of the operands, so they cannot return references.
      </p>
      <p class="calibre13">
       Here are the implementations for
       <code class="calibre21">
        operator++
       </code>
       :
      </p>
      <pre class="calibre26" id="c15-code-0015"><code class="calibre21">SpreadsheetCell&amp; SpreadsheetCell::operator++()</code>
<code class="calibre21">{</code>
<code class="calibre21">    set(getValue() + 1);</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="591" class="calibre20" epub:type="pagebreak" id="Page_591" role="doc-pagebreak"></span><code class="calibre21">SpreadsheetCell SpreadsheetCell::operator++(int)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto oldCell { *this }; <span class="color">// Save current value</span></code>
<code class="calibre21">    ++(*this);              <span class="color">// Increment using prefix ++</span></code>
<code class="calibre21">    return oldCell;         <span class="color">// Return the old value</span></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0149">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           It is recommended to implement the postfix operator in terms of the prefix operator
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       The implementations for
       <code class="calibre21">
        operator--
       </code>
       are virtually identical. Now you can increment and decrement
       <code class="calibre21">
        SpreadsheetCell
       </code>
       objects to your heart's content:
      </p>
      <pre class="calibre26" id="c15-code-0016"><code class="calibre21">SpreadsheetCell c1 { 4 };</code>
<code class="calibre21">SpreadsheetCell c2 { 4 };</code>
<code class="calibre21">c1++;</code>
<code class="calibre21">++c2;</code></pre>
      <p class="calibre13" id="c15-para-0151">
       Increment and decrement operators also work on pointers. When you write classes that are smart pointers, for example, you can overload
       <code class="calibre21">
        operator++
       </code>
       and
       <code class="calibre21">
        operator--
       </code>
       to provide pointer incrementing and decrementing.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-174" class="calibre2">
     <span class="calibre" id="c15-sec-0023">
     </span>
     <h2 class="calibre6" id="head-2-174">
      OVERLOADING THE BITWISE AND BINARY LOGICAL OPERATORS
     </h2>
     <p class="calibre13" id="c15-para-0152">
      The bitwise operators are similar to the arithmetic operators, and the bitwise shorthand assignment operators are similar to the arithmetic shorthand assignment operators. However, they are significantly less common, so no examples are shown here. The table in the section “
      <a class="calibre5" href="#c15-sec-0013">
       Summary of Overloadable Operators
      </a>
      ” shows sample prototypes, so you should be able to implement them easily if the need ever arises.
     </p>
     <p class="calibre13" id="c15-para-0153">
      The logical operators are trickier. It's not recommended to overload
      <code class="calibre21">
       &amp;&amp;
      </code>
      and
      <code class="calibre21">
       ||
      </code>
      . These operators don't really apply to individual types: they aggregate results of Boolean expressions. Additionally, when overloading these operators, you lose the short-circuit evaluation, because both the left-hand side and the right-hand side have to be evaluated before they can be bound to the parameters of your overloaded operator
      <code class="calibre21">
       &amp;&amp;
      </code>
      and
      <code class="calibre21">
       ||
      </code>
      . Thus, it rarely, if ever, makes sense to overload them for specific types.
     </p>
    </section>
    <section aria-labelledby="head-2-175" class="calibre2">
     <span class="calibre" id="c15-sec-0024">
     </span>
     <h2 class="calibre6" id="head-2-175">
      OVERLOADING THE INSERTION AND EXTRACTION OPERATORS
     </h2>
     <p class="calibre13">
      In C++, you use operators not only for arithmetic operations but also for reading from, and writing to, streams. For example, when you write
      <code class="calibre21">
       int
      </code>
      s and
      <code class="calibre21">
       string
      </code>
      s to
      <code class="calibre21">
       cout
      </code>
      , you use the insertion operator
      <code class="calibre21">
       &lt;&lt;
      </code>
      :
     </p>
     <pre class="calibre26" id="c15-code-0017"><code class="calibre21">int number { 10 };</code>
<code class="calibre21">cout &lt;&lt; "The number is " &lt;&lt; number &lt;&lt; endl;</code></pre>
     <p class="calibre13">
      <span aria-label="592" class="calibre20" epub:type="pagebreak" id="Page_592" role="doc-pagebreak">
      </span>
      When you read from streams, you use the extraction operator
      <code class="calibre21">
       &gt;&gt;
      </code>
      :
     </p>
     <pre class="calibre26" id="c15-code-0018"><code class="calibre21">int number;</code>
<code class="calibre21">string str;</code>
<code class="calibre21">cin &gt;&gt; number &gt;&gt; str;</code></pre>
     <p class="calibre13">
      You can write insertion and extraction operators that work on your classes as well, so that you can read and write them like this:
     </p>
     <pre class="calibre26" id="c15-code-0019"><code class="calibre21">SpreadsheetCell myCell, anotherCell, aThirdCell;</code>
<code class="calibre21">cin &gt;&gt; myCell &gt;&gt; anotherCell &gt;&gt; aThirdCell;</code>
<code class="calibre21">cout &lt;&lt; myCell &lt;&lt; " " &lt;&lt; anotherCell &lt;&lt; " " &lt;&lt; aThirdCell &lt;&lt; endl;</code></pre>
     <p class="calibre13" id="c15-para-0157">
      Before you write the insertion and extraction operators, you need to decide how you want to stream your class out and how you want to read it in. In this example, the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      s simply read and write a single
      <code class="calibre21">
       double
      </code>
      value.
     </p>
     <p class="calibre13">
      The object on the left of an extraction or insertion operator is an
      <code class="calibre21">
       istream
      </code>
      or
      <code class="calibre21">
       ostream
      </code>
      (such as
      <code class="calibre21">
       cin
      </code>
      or
      <code class="calibre21">
       cout
      </code>
      ), not a
      <code class="calibre21">
       SpreadsheetCell
      </code>
      object. Because you can't add a member function to the
      <code class="calibre21">
       istream
      </code>
      or
      <code class="calibre21">
       ostream
      </code>
      classes, you must write the extraction and insertion operators as global functions. The declaration of these functions looks like this:
     </p>
     <pre class="calibre26" id="c15-code-0020"><code class="calibre21">export std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const SpreadsheetCell&amp; cell);</code>
<code class="calibre21">export std::istream&amp; operator&gt;&gt;(std::istream&amp; istr, SpreadsheetCell&amp; cell);</code></pre>
     <p class="calibre13" id="c15-para-0159">
      By making the insertion operator take a reference to an
      <code class="calibre21">
       ostream
      </code>
      as its first parameter, you allow it to be used for file output streams, string output streams,
      <code class="calibre21">
       cout
      </code>
      ,
      <code class="calibre21">
       cerr
      </code>
      ,
      <code class="calibre21">
       clog
      </code>
      , and more. See
      <a class="calibre5" href="c13.xhtml">
       Chapter 13
      </a>
      , “Demystifying C++ I/O,” for details on streams. Similarly, by making the extraction operator take a reference to an
      <code class="calibre21">
       istream
      </code>
      , you make it work with any input stream, such as a file input stream, string input stream, and
      <code class="calibre21">
       cin
      </code>
      .
     </p>
     <p class="calibre13" id="c15-para-0160">
      The second parameter to
      <code class="calibre21">
       operator&lt;&lt;
      </code>
      and
      <code class="calibre21">
       operator&gt;&gt;
      </code>
      is a reference to the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      object that you want to write or read. The insertion operator doesn't change the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      it writes, so the parameter is of type reference-to-
      <code class="calibre21">
       const
      </code>
      . The extraction operator, however, modifies the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      object, requiring the parameter to be a reference-to-non-
      <code class="calibre21">
       const
      </code>
      .
     </p>
     <p class="calibre13">
      Both operators return a reference to the stream they were given as their first parameter so that calls to the operator can be nested. Remember that the operator syntax is shorthand for calling the global
      <code class="calibre21">
       operator&gt;&gt;
      </code>
      or
      <code class="calibre21">
       operator&lt;&lt;
      </code>
      functions explicitly. Consider this line:
     </p>
     <pre class="calibre26" id="c15-code-0021"><code class="calibre21">cin&gt;&gt; myCell&gt;&gt; anotherCell&gt;&gt; aThirdCell;</code></pre>
     <p class="calibre13">
      This line is shorthand for:
     </p>
     <pre class="calibre26" id="c15-code-0022"><code class="calibre21">operator&gt;&gt;(operator&gt;&gt;(operator&gt;&gt;(cin, myCell), anotherCell), aThirdCell);</code></pre>
     <p class="calibre13" id="c15-para-0163">
      As you can see, the return value of the first call to
      <code class="calibre21">
       operator&gt;&gt;
      </code>
      is used as input to the next call. Thus, you must return the stream reference so that it can be used in the next nested call. Otherwise, the nesting won't compile.
     </p>
     <p class="calibre13">
      Here are the implementations for
      <code class="calibre21">
       operator&lt;&lt;
      </code>
      and
      <code class="calibre21">
       &gt;&gt;
      </code>
      for the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      class:
     </p>
     <pre class="calibre26" id="c15-code-0023"><code class="calibre21">ostream&amp; operator&lt;&lt;(ostream&amp; ostr, const SpreadsheetCell&amp; cell)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ostr &lt;&lt; cell.getValue();</code>
<code class="calibre21">    return ostr;</code>
<code class="calibre21">}</code>
<code class="calibre21"><span aria-label="593" class="calibre20" epub:type="pagebreak" id="Page_593" role="doc-pagebreak"></span> </code>
<code class="calibre21">istream&amp; operator &gt;&gt;(istream&amp; istr, SpreadsheetCell&amp; cell)</code>
<code class="calibre21">{</code>
<code class="calibre21">    double value;</code>
<code class="calibre21">    istr &gt;&gt; value;</code>
<code class="calibre21">    cell.set(value);</code>
<code class="calibre21">    return istr;</code>
<code class="calibre21">}</code></pre>
    </section>
    <section aria-labelledby="head-2-176" class="calibre2">
     <span class="calibre" id="c15-sec-0025">
     </span>
     <h2 class="calibre6" id="head-2-176">
      OVERLOADING THE SUBSCRIPTING OPERATOR
     </h2>
     <p class="calibre13">
      Pretend for a few minutes that you have never heard of the
      <code class="calibre21">
       vector
      </code>
      or
      <code class="calibre21">
       array
      </code>
      class templates in the Standard Library, and so you have decided to write your own dynamically allocated array class. This class would allow you to set and retrieve elements at specified indices and would take care of all memory allocation “behind the scenes.” A first stab at the class definition for a dynamically allocated array might look like this:
     </p>
     <pre class="calibre26" id="c15-code-0024"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Array</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Creates an array with a default size that will grow as needed.</span></code>
<code class="calibre21">        Array();</code>
<code class="calibre21">        virtual ˜Array();</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Disallow copy constructor and copy assignment.</span></code>
<code class="calibre21">        Array&amp; operator=(const Array&amp; rhs) = delete;</code>
<code class="calibre21">        Array(const Array&amp; src) = delete;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Move constructor and move assignment operator.</span></code>
<code class="calibre21">        Array(Array&amp;&amp; src) noexcept;</code>
<code class="calibre21">        Array&amp; operator=(Array&amp;&amp; rhs) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns the value at index x. Throws an exception of type</span></code>
<code class="calibre21">        <span class="color">// out_of_range if index x does not exist in the array.</span></code>
<code class="calibre21">        const T&amp; getElementAt(std::size_t x) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Sets the value at index x. If index x is out of range,</span></code>
<code class="calibre21">        <span class="color">// allocates more space to make it in range.</span></code>
<code class="calibre21">        void setElementAt(std::size_t x, const T&amp; value);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns the number of elements in the array.</span></code>
<code class="calibre21">        std::size_t getSize() const noexcept;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        static constexpr std::size_t AllocSize { 4 };</code>
<code class="calibre21">        void resize(std::size_t newSize);</code>
<code class="calibre21">        T* m_elements { nullptr };</code>
<code class="calibre21">        std::size_t m_size { 0 };</code>
<code class="calibre21">};</code></pre>
     <p class="calibre13" id="c15-para-0166">
      The interface supports setting and accessing elements. It provides random-access guarantees: a client could create a default array and set elements
      <code class="calibre21">
       1
      </code>
      ,
      <code class="calibre21">
       100
      </code>
      and
      <code class="calibre21">
       1000
      </code>
      without worrying about memory management.
     </p>
     <p class="calibre13">
      <span aria-label="594" class="calibre20" epub:type="pagebreak" id="Page_594" role="doc-pagebreak">
      </span>
      Here are the implementations of the member functions:
     </p>
     <pre class="calibre26" id="c15-code-0025"><code class="calibre21">template &lt;typename T&gt; Array&lt;T&gt;::Array()</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_elements = new T[AllocSize] {}; <span class="color">// Elements are zero-initialized!</span></code>
<code class="calibre21">    m_size = AllocSize;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; Array&lt;T&gt;::˜Array()</code>
<code class="calibre21">{</code>
<code class="calibre21">    delete[] m_elements;</code>
<code class="calibre21">    m_elements = nullptr;</code>
<code class="calibre21">    m_size = 0;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; Array&lt;T&gt;::Array(Array&amp;&amp; src) noexcept</code>
<code class="calibre21">    : m_elements { std::exchange(src.m_elements, nullptr) }</code>
<code class="calibre21">    , m_size { std::exchange(src.m_size, 0) }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; Array&lt;T&gt;&amp; Array&lt;T&gt;::operator=(Array&lt;T&gt;&amp;&amp; rhs) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (this == &amp;rhs) { return *this; }</code>
<code class="calibre21">    delete[] m_elements;</code>
<code class="calibre21">    m_elements = std::exchange(rhs.m_elements, nullptr);</code>
<code class="calibre21">    m_size = std::exchange(rhs.m_size, 0);</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; void Array&lt;T&gt;::resize(std::size_t newSize)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Create new bigger array with zero-initialized elements.</span></code>
<code class="calibre21">    auto newArray { std::make_unique&lt;T[]&gt;(newSize) };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// The new size is always bigger than the old size (m_size).</span></code>
<code class="calibre21">    for (std::size_t i { 0 }; i &lt; m_size; ++i) {</code>
<code class="calibre21">        <span class="color">// Copy the elements from the old array to the new one.</span></code>
<code class="calibre21">        newArray[i] = m_elements[i];</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Delete the old array, and set the new array.</span></code>
<code class="calibre21">    delete[] m_elements;</code>
<code class="calibre21">    m_size = newSize;</code>
<code class="calibre21">    m_elements = newArray.release();</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; const T&amp; Array&lt;T&gt;::getElementAt(std::size_t x) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x &gt;= m_size) { throw std::out_of_range { "" }; }</code>
<code class="calibre21">    return m_elements[x];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="595" class="calibre20" epub:type="pagebreak" id="Page_595" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename T&gt; void Array&lt;T&gt;::setElementAt(std::size_t x, const T&amp; val)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x &gt;= m_size) {</code>
<code class="calibre21">        <span class="color">// Allocate AllocSize past the element the client wants.</span></code>
<code class="calibre21">        resize(x + AllocSize);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    m_elements[x] = val;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; std::size_t Array&lt;T&gt;::getSize() const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_size;</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13" id="c15-para-0168">
      Pay attention to the exception-safe implementation of the
      <code class="calibre21">
       resize()
      </code>
      member function. First, it creates a new array of appropriate size using
      <code class="calibre21">
       make_unique()
      </code>
      and stores it in a
      <code class="calibre21">
       unique_ptr
      </code>
      . Then, all elements are copied from the old array to the new array. If anything goes wrong while copying the values, the
      <code class="calibre21">
       unique_ptr
      </code>
      cleans up the newly allocated memory automatically. Finally, when both the allocation of the new array and copying all the elements is successful, that is, no exceptions have been thrown, only then do we delete the old
      <code class="calibre21">
       m_elements
      </code>
      array and assign the new array to it. The last line has to use
      <code class="calibre21">
       release()
      </code>
      to release the ownership of the new array from the
      <code class="calibre21">
       unique_ptr
      </code>
      ; otherwise, the array would get destroyed when the destructor for the
      <code class="calibre21">
       unique_ptr
      </code>
      is called.
     </p>
     <p class="calibre13" id="c15-para-0169">
      To guarantee strong exception safety (see
      <a class="calibre5" href="c14.xhtml">
       Chapter 14
      </a>
      , “Handling Errors”),
      <code class="calibre21">
       resize()
      </code>
      copies elements from the old array to the newly allocated array.
      <a class="calibre5" href="c26.xhtml">
       Chapter 26
      </a>
      , “Advanced Templates,” discusses and implements a
      <code class="calibre21">
       move_assign_if_noexcept()
      </code>
      helper function. This helper function can be used in the implementation of
      <code class="calibre21">
       resize()
      </code>
      so that elements are moved from the old array to the new array, but only if the move assignment operator of the element type is marked as
      <code class="calibre21">
       noexcept
      </code>
      . If that's not the case, the elements are copied. With that change, whether elements are moved or copied, strong exception safety remains guaranteed.
     </p>
     <p class="calibre13">
      Here is a small example of how you could use this class:
     </p>
     <pre class="calibre26" id="c15-code-0026"><code class="calibre21">Array&lt;int&gt; myArray;</code>
<code class="calibre21">for (size_t i { 0 }; i &lt; 20; i += 2) {</code>
<code class="calibre21">    myArray.setElementAt(i, 100);</code>
<code class="calibre21">}</code>
<code class="calibre21">for (size_t i { 0 }; i &lt; 20; ++i) {</code>
<code class="calibre21">    print("{} ", myArray.getElementAt(i));</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      The output is as follows:
     </p>
     <pre class="calibre26" id="c15-code-0027"><code class="calibre21">100 0 100 0 100 0 100 0 100 0 100 0 100 0 100 0 100 0 100 0</code></pre>
     <p class="calibre13">
      As you can see, you never have to tell the array how much space you need. It allocates as much space as it requires to store the elements you give it.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c15-para-0173">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          This is not a memory efficient implementation. If you create an array and only assign a value to the element with index 4000, then it allocates memory for 4004 elements, all zero initialized except for the element with index 4000
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c15-para-0174">
      <span aria-label="596" class="calibre20" epub:type="pagebreak" id="Page_596" role="doc-pagebreak">
      </span>
      However, it's inconvenient to always have to use the
      <code class="calibre21">
       setElementAt()
      </code>
      and
      <code class="calibre21">
       getElementAt()
      </code>
      member functions.
     </p>
     <p class="calibre13">
      This is where the overloaded subscripting operator comes in. You can add an
      <code class="calibre21">
       operator[]
      </code>
      to the class as follows:
     </p>
     <pre class="calibre26" id="c15-code-0028"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Array</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">T&amp; operator[](std::size_t x);</b></code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13">
      Here is the implementation:
     </p>
     <pre class="calibre26" id="c15-code-0029"><code class="calibre21">template &lt;typename T&gt; T&amp; Array&lt;T&gt;::operator[](std::size_t x)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x &gt;= m_size) {</code>
<code class="calibre21">        <span class="color">// Allocate AllocSize past the element the client wants.</span></code>
<code class="calibre21">        resize(x + AllocSize);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return m_elements[x];</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      With this change, you can use conventional array index notation like this:
     </p>
     <pre class="calibre26" id="c15-code-0030"><code class="calibre21">Array&lt;int&gt; myArray;</code>
<code class="calibre21">for (size_t i { 0 }; i &lt; 20; i += 2) {</code>
<code class="calibre21">    <b class="calibre14">myArray[i] = 100;</b></code>
<code class="calibre21">}</code>
<code class="calibre21">for (size_t i { 0 }; i &lt; 20; ++i) {</code>
<code class="calibre21">    <b class="calibre14">print("{} ", myArray[i]);</b></code>
<code class="calibre21">}</code></pre>
     <p class="calibre13" id="c15-para-0178">
      The
      <code class="calibre21">
       operator[]
      </code>
      can be used to both set and get elements because it returns a reference to the element at location
      <code class="calibre21">
       x
      </code>
      . This reference can be used to assign to that element. When
      <code class="calibre21">
       operator[]
      </code>
      is used on the left-hand side of an assignment statement, the assignment actually changes the value at location
      <code class="calibre21">
       x
      </code>
      in the
      <code class="calibre21">
       m_elements
      </code>
      array.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0027">
      </span>
      <h3 class="calibre27" id="head-3-338">
       Providing Read-Only Access with operator[]
      </h3>
      <p class="calibre13">
       Although it's sometimes convenient for
       <code class="calibre21">
        operator[]
       </code>
       to return an element that can serve as an lvalue, you don't always want that behavior. It would be nice to be able to provide read-only access to the elements of the array as well, by returning a reference-to-
       <code class="calibre21">
        const
       </code>
       . To provide for this, you need two
       <code class="calibre21">
        operator[]
       </code>
       overloads: one returning a reference-to-non-
       <code class="calibre21">
        const
       </code>
       and one returning a reference-to-
       <code class="calibre21">
        const
       </code>
       :
      </p>
      <pre class="calibre26" id="c15-code-0031"><code class="calibre21">T&amp; operator[](std::size_t x);</code>
<code class="calibre21"><b class="calibre14">const T&amp; operator[](std::size_t x) const;</b></code></pre>
      <p class="calibre13" id="c15-para-0180">
       Remember that you can't overload a member function or operator based only on the return type, so the second overload returns a reference-to-
       <code class="calibre21">
        const
       </code>
       <i class="calibre18">
        and
       </i>
       is marked as
       <code class="calibre21">
        const
       </code>
       .
      </p>
      <p class="calibre13">
       <span aria-label="597" class="calibre20" epub:type="pagebreak" id="Page_597" role="doc-pagebreak">
       </span>
       Here is the implementation of the
       <code class="calibre21">
        const operator[]
       </code>
       . It throws an exception if the index is out of range instead of trying to allocate new space. It doesn't make sense to allocate new space when you're only trying to read the element value.
      </p>
      <pre class="calibre26" id="c15-code-0032"><code class="calibre21">template &lt;typename T&gt; const T&amp; Array&lt;T&gt;::operator[](std::size_t x) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x &gt;= m_size) { throw std::out_of_range { "" }; }</code>
<code class="calibre21">    return m_elements[x];</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The following code demonstrates these two forms of
       <code class="calibre21">
        operator[]
       </code>
       :
      </p>
      <pre class="calibre26" id="c15-code-0033"><code class="calibre21">void printArray(const Array&lt;int&gt;&amp; arr)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; arr.getSize(); ++i) {</code>
<code class="calibre21">        print("{} ", arr[i]);  <span class="color">// Calls the const operator[] because arr is</span></code>
<code class="calibre21">                               <span class="color">// a const object.</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Array&lt;int&gt; myArray;</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; 20; i += 2) {</code>
<code class="calibre21">        myArray[i] = 100; <span class="color">// Calls the non-const operator[] because</span></code>
<code class="calibre21">                          <span class="color">// myArray is a non-const object.</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">    printArray(myArray);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c15-para-0183">
       Note that the
       <code class="calibre21">
        const operator[]
       </code>
       is called in
       <code class="calibre21">
        printArray()
       </code>
       only because the parameter
       <code class="calibre21">
        arr
       </code>
       is
       <code class="calibre21">
        const
       </code>
       . If
       <code class="calibre21">
        arr
       </code>
       were not
       <code class="calibre21">
        const
       </code>
       , the non-
       <code class="calibre21">
        const operator[]
       </code>
       would be called, despite that the result is not modified.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        const operator[]
       </code>
       is called for
       <code class="calibre21">
        const
       </code>
       objects, so it cannot grow the size of the array. The current implementation throws an exception when the given index is out of bounds. An alternative would be to return a zero-initialized element instead of throwing. This can be done as follows:
      </p>
      <pre class="calibre26" id="c15-code-0034"><code class="calibre21">template &lt;typename T&gt; const T&amp; Array&lt;T&gt;::operator[](std::size_t x) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x &gt;= m_size) {</code>
<code class="calibre21">        static T nullValue { T{} };</code>
<code class="calibre21">        return nullValue;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return m_elements[x];</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        nullValue static
       </code>
       variable is initialized using the zero-initialization syntax
       <code class="calibre21">
        T{}
       </code>
       . It's up to you and your specific use case whether you opt for the throwing version or the version returning a null value.
       <span aria-label="598" class="calibre20" epub:type="pagebreak" id="Page_598" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0186">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Zero-initialization constructs objects with the default constructor and initializes primitive integer types (such as
          </i>
          <code class="calibre21">
           char
          </code>
          <i class="calibre18">
           ,
          </i>
          <code class="calibre21">
           int
          </code>
          <i class="calibre18">
           , and so on) to zero, primitive floating-point types to 0.0, and pointer types to
          </i>
          <code class="calibre21">
           nullptr
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0029">
      </span>
      <h3 class="calibre27" id="head-3-339">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Multidimensional Subscripting Operator
      </h3>
      <p class="calibre13" id="c15-para-0188">
       Starting with C++23, a subscripting operator can support multidimensional indexing. The syntax is straightforward. Instead of writing a subscripting operator accepting a single index parameter, you write a subscripting operator with as many index parameters as dimensions you need.
      </p>
      <p class="calibre13">
       To demonstrate, let's revisit the
       <code class="calibre21">
        Grid
       </code>
       class template from
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       , “Writing Generic Code with Templates.” Its interface contains a
       <code class="calibre21">
        const
       </code>
       and non-
       <code class="calibre21">
        const
       </code>
       overload of an
       <code class="calibre21">
        at(x,y)
       </code>
       member function. These
       <code class="calibre21">
        at()
       </code>
       member functions can be replaced with two-dimensional
       <code class="calibre21">
        const
       </code>
       and non-
       <code class="calibre21">
        const
       </code>
       subscripting operators as follows:
      </p>
      <pre class="calibre26" id="c15-code-0035"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">class Grid</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        std::optional&lt;T&gt;&amp; <b class="calibre14">operator[](std::size_t x, std::size_t y)</b>;</code>
<code class="calibre21">        const std::optional&lt;T&gt;&amp; <b class="calibre14">operator[](std::size_t x, std::size_t y)</b> const;</code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The syntax simply specifies two parameters,
       <code class="calibre21">
        x
       </code>
       and
       <code class="calibre21">
        y
       </code>
       , for these two-dimensional subscripting operators. The implementations are almost identical to the implementations of the original
       <code class="calibre21">
        at()
       </code>
       member functions:
      </p>
      <pre class="calibre26" id="c15-code-0036"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">const std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::<b class="calibre14">operator[](std::size_t x, std::size_t y)</b> const</code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x + y * m_width];</code>
<code class="calibre21">}</code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::<b class="calibre14">operator[](std::size_t x, std::size_t y)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return const_cast&lt;std::optional&lt;T&gt;&amp;&gt;(std::as_const(*this)<b class="calibre14">[x, y]</b>);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Here is an example of these new operators in action:
      </p>
      <pre class="calibre26" id="c15-code-0037"><code class="calibre21">Grid&lt;int&gt; myIntGrid { 4, 4 };</code>
<code class="calibre21">int counter { 0 };</code>
<code class="calibre21">for (size_t y { 0 }; y &lt; myIntGrid.getHeight(); ++y) {</code>
<code class="calibre21">    for (size_t x { 0 }; x &lt; myIntGrid.getWidth(); ++x) {</code>
<code class="calibre21">        <b class="calibre14">myIntGrid[x, y]</b> = ++counter;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21">for (size_t y { 0 }; y &lt; myIntGrid.getHeight(); ++y) {</code>
<code class="calibre21">    for (size_t x { 0 }; x &lt; myIntGrid.getWidth(); ++x) {</code>
<code class="calibre21">        print("{:3} ", <b class="calibre14">myIntGrid[x, y]</b>.value_or(0));</code>
<span aria-label="599" class="calibre20" epub:type="pagebreak" id="Page_599" role="doc-pagebreak"></span><code class="calibre21">    }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is:
      </p>
      <pre class="calibre26" id="c15-code-0038"><code class="calibre21">  1   2   3   4 </code>
<code class="calibre21">  5   6   7   8 </code>
<code class="calibre21">  9  10  11  12 </code>
<code class="calibre21"> 13  14  15  16</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0030">
      </span>
      <h3 class="calibre27" id="head-3-340">
       Non-integral Array Indices
      </h3>
      <p class="calibre13" id="c15-para-0193">
       It is a natural extension of the paradigm of “indexing” into a collection to provide a key of some sort; a
       <code class="calibre21">
        vector
       </code>
       (or in general, any linear array) is a special case where the “key” is just a position in the array. Think of the argument of
       <code class="calibre21">
        operator[]
       </code>
       as providing a mapping between two domains: the domain of keys and the domain of values. Thus, you can write an
       <code class="calibre21">
        operator[]
       </code>
       that uses any type as its index. This type does not need to be an integer type. This is done for the Standard Library associative containers, like
       <code class="calibre21">
        std::map
       </code>
       , which are discussed in
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       , “Standard Library Containers.”
      </p>
      <p class="calibre13" id="c15-para-0194">
       For example, you could create an
       <i class="calibre18">
        associative array
       </i>
       in which you use
       <code class="calibre21">
        string
       </code>
       keys instead of integral indices. The
       <code class="calibre21">
        operator[]
       </code>
       for such a class would accept a
       <code class="calibre21">
        string
       </code>
       , or better yet
       <code class="calibre21">
        string_view
       </code>
       , as an argument. Implementing such a class is an exercise for you at the end of this chapter.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0031">
      </span>
      <h3 class="calibre27" id="head-3-341">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       static Subscripting Operator
      </h3>
      <p class="calibre13">
       With C++23, the subscripting operator can be marked as
       <code class="calibre21">
        static
       </code>
       as long as the implementation of the operator does not require access to
       <code class="calibre21">
        this
       </code>
       , or, in other words, does not need access to non-
       <code class="calibre21">
        static
       </code>
       data members and non-
       <code class="calibre21">
        static
       </code>
       member functions. This allows the compiler to better optimize the code as it doesn't need to worry about any
       <code class="calibre21">
        this
       </code>
       pointer. Here is an example where
       <code class="calibre21">
        operator[]
       </code>
       is marked as
       <code class="calibre21">
        static
       </code>
       ,
       <code class="calibre21">
        constexpr
       </code>
       (see
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       ), and
       <code class="calibre21">
        noexcept
       </code>
       (
       <a class="calibre5" href="c14.xhtml">
        Chapter 14
       </a>
       ):
      </p>
      <pre class="calibre26" id="c15-code-0039"><code class="calibre21">enum class Figure { Diamond, Heart, Spade, Club };</code>
<code class="calibre21"> </code>
<code class="calibre21">class FigureEnumToString</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">static constexpr string_view operator[](Figure figure) noexcept</b></code>
<code class="calibre21">        {</code>
<code class="calibre21">            switch (figure) {</code>
<code class="calibre21">                case Figure::Diamond: return "Diamond";</code>
<code class="calibre21">                case Figure::Heart:   return "Heart";</code>
<code class="calibre21">                case Figure::Spade:   return "Spade";</code>
<code class="calibre21">                case Figure::Club:    return "Club";</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Figure f { Figure::Spade };</code>
<span aria-label="600" class="calibre20" epub:type="pagebreak" id="Page_600" role="doc-pagebreak"></span><code class="calibre21">    FigureEnumToString converter;</code>
<code class="calibre21">    println("{}", <b class="calibre14">converter[f]</b>);</code>
<code class="calibre21">    println("{}", <b class="calibre14">FigureEnumToString{}[f]</b>);</code>
<code class="calibre21">}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-177" class="calibre2">
     <span class="calibre" id="c15-sec-0032">
     </span>
     <h2 class="calibre6" id="head-2-177">
      OVERLOADING THE FUNCTION CALL OPERATOR
     </h2>
     <p class="calibre13">
      C++ allows you to overload the function call operator, written as
      <code class="calibre21">
       operator()
      </code>
      . If you write an
      <code class="calibre21">
       operator()
      </code>
      for your class, you can use objects of that class as if they were function pointers. An object of a class with a function call operator is called a
      <i class="calibre18">
       function object
      </i>
      , or
      <i class="calibre18">
       functor
      </i>
      , for short. Here is an example of a simple class with an overloaded
      <code class="calibre21">
       operator()
      </code>
      and a class member function with the same behavior:
     </p>
     <pre class="calibre26" id="c15-code-0040"><code class="calibre21">class Squarer</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        int operator()(int value) const; <span class="color">// Overloaded function call operator.</span></code>
<code class="calibre21">        int doSquare(int value) const;   <span class="color">// Normal member function.</span></code>
<code class="calibre21">};</code>
<code class="calibre21"><span class="color">// Implementation of overloaded function call operator.</span></code>
<code class="calibre21">int Squarer::operator()(int value) const { return doSquare(value); }</code>
<code class="calibre21"><span class="color">// Implementation of normal member function.</span></code>
<code class="calibre21">int Squarer::doSquare(int value) const { return value * value; }</code></pre>
     <p class="calibre13">
      Here is an example of code that uses the function call operator, contrasted with a call to the normal member function of the class:
     </p>
     <pre class="calibre26" id="c15-code-0041"><code class="calibre21">int x { 3 };</code>
<code class="calibre21">Squarer square;</code>
<code class="calibre21">int xSquared { <b class="calibre14">square(x)</b> };                     <span class="color">// Call the function call operator.</span></code>
<code class="calibre21">int xSquaredAgain { <b class="calibre14">square.doSquare(xSquared)</b> };<span class="color">// Call the normal member function.</span></code>
<code class="calibre21">println("{} squared is {}, and squared again is {}.", x, xSquared, xSquaredAgain);</code></pre>
     <p class="calibre13">
      The output is as follows:
     </p>
     <pre class="calibre26" id="c15-code-0042"><code class="calibre21">3 squared is 9, and squared again is 81.</code></pre>
     <p class="calibre13" id="c15-para-0200">
      At first, the function call operator probably seems a little strange. Why would you want to write a special member function for a class to make objects of the class look like function pointers? Why wouldn't you just write a global function or a standard member function of a class?
     </p>
     <p class="calibre13" id="c15-para-0201">
      The advantage of function objects over standard member functions of objects is simple: these objects can sometimes masquerade as function pointers; that is, you can pass function objects as callback functions to other functions. This is discussed in more detail in
      <a class="calibre5" href="c19.xhtml">
       Chapter 19
      </a>
      .
     </p>
     <p class="calibre13">
      The advantages of function objects over global functions are more intricate. There are two main benefits:
     </p>
     <ul class="check" id="c15-list-0004">
      <li class="calibre9" id="c15-li-0023">
       Objects can retain information in their data members between repeated calls to their function call operators. For example, a function object might be used to keep a running sum of numbers collected from each call to the function call operator.
      </li>
      <li class="calibre9" id="c15-li-0024">
       <span aria-label="601" class="calibre20" epub:type="pagebreak" id="Page_601" role="doc-pagebreak">
       </span>
       You can customize the behavior of a function object by setting data members. For example, you could write a function object to compare an argument to the function call operator against a data member. This data member could be configurable so that the object could be customized for whatever comparison you want.
      </li>
     </ul>
     <p class="calibre13" id="c15-para-0203">
      Of course, you could implement either of the preceding benefits with global or
      <code class="calibre21">
       static
      </code>
      variables. However, function objects provide a cleaner way to do it, and besides, using global or
      <code class="calibre21">
       static
      </code>
      variables should be avoided and can cause problems in a multithreaded application. The true benefits of function objects are demonstrated with the Standard Library in
      <a class="calibre5" href="c20.xhtml">
       Chapter 20
      </a>
      , “Mastering Standard Library Algorithms.”
     </p>
     <p class="calibre13">
      By following the normal member function overloading rules, you can write as many
      <code class="calibre21">
       operator()
      </code>
      s for your classes as you want. For example, you could add an
      <code class="calibre21">
       operator()
      </code>
      to the
      <code class="calibre21">
       Squarer
      </code>
      class that takes a
      <code class="calibre21">
       double
      </code>
      :
     </p>
     <pre class="calibre26" id="c15-code-0043"><code class="calibre21">int operator()(int value) const;</code>
<code class="calibre21"><b class="calibre14">double operator()(double value) const;</b></code></pre>
     <p class="calibre13">
      This
      <code class="calibre21">
       double
      </code>
      overload can be implemented as follows:
     </p>
     <pre class="calibre26" id="c15-code-0044"><code class="calibre21">double Squarer::operator()(double value) const { return value * value; }</code></pre>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0033">
      </span>
      <h3 class="calibre27" id="head-3-342">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       static Function Call Operator
      </h3>
      <p class="calibre13" id="c15-para-0207">
       Starting with C++23, a function call operator can be marked as
       <code class="calibre21">
        static
       </code>
       if its implementation does not require access to
       <code class="calibre21">
        this
       </code>
       , or, in other words, does not need access to non-
       <code class="calibre21">
        static
       </code>
       data members and non-
       <code class="calibre21">
        static
       </code>
       member functions. This is similar to how subscripting operators, discussed earlier in this chapter, can be marked as
       <code class="calibre21">
        static
       </code>
       , and doing so allows the compiler to better optimize the code.
      </p>
      <p class="calibre13">
       Here is an example, a reduced
       <code class="calibre21">
        Squarer
       </code>
       functor with a
       <code class="calibre21">
        static
       </code>
       ,
       <code class="calibre21">
        constexpr
       </code>
       , and
       <code class="calibre21">
        noexcept
       </code>
       function call operator:
      </p>
      <pre class="calibre26" id="c15-code-0045"><code class="calibre21">class Squarer</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">static constexpr int operator()(int value) noexcept</b></code>
<code class="calibre21">        {</code>
<code class="calibre21">            return value * value;</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       This functor can be used as follows:
      </p>
      <pre class="calibre26" id="c15-code-0046"><code class="calibre21">int x { 3 };</code>
<code class="calibre21">int xSquared { <b class="calibre14">Squarer::operator()(x)</b> };</code>
<code class="calibre21">int xSquaredAgain { <b class="calibre14">Squarer{}(xSquared)</b> };</code>
<code class="calibre21">println("{} squared is {}, and squared again is {}.", x, xSquared, xSquaredAgain);</code></pre>
      <p class="calibre13" id="c15-para-0210">
       Another benefit of
       <code class="calibre21">
        static
       </code>
       function call operators is that you can easily take their address, for example,
       <code class="calibre21">
        &amp;Squarer::operator()
       </code>
       , which allows you to use them as if they were function pointers. This can improve the performance when working with the Standard Library algorithms discussed in
       <span aria-label="602" class="calibre20" epub:type="pagebreak" id="Page_602" role="doc-pagebreak">
       </span>
       detail in
       <a class="calibre5" href="c20.xhtml">
        Chapter 20
       </a>
       . Quite a few of those algorithms accept a callable, such as a functor, to customize their behavior. If your functor has a
       <code class="calibre21">
        static
       </code>
       function call operator, then passing the address of that function call operator to such algorithms allows the compiler to generate more performant code than with a non-
       <code class="calibre21">
        static
       </code>
       function call operator. The reason is that with a
       <code class="calibre21">
        static
       </code>
       function call operator, the compiler doesn't need to worry about any
       <code class="calibre21">
        this
       </code>
       pointer.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-178" class="calibre2">
     <span class="calibre" id="c15-sec-0034">
     </span>
     <h2 class="calibre6" id="head-2-178">
      OVERLOADING THE DEREFERENCING OPERATORS
     </h2>
     <p class="calibre13">
      You can overload three dereferencing operators:
      <code class="calibre21">
       *
      </code>
      ,
      <code class="calibre21">
       -&gt;
      </code>
      , and
      <code class="calibre21">
       -&gt;*
      </code>
      . Ignoring
      <code class="calibre21">
       -&gt;*
      </code>
      for the moment (I'll come back to it later), consider the built-in meanings of
      <code class="calibre21">
       *
      </code>
      and
      <code class="calibre21">
       -&gt;
      </code>
      . The
      <code class="calibre21">
       *
      </code>
      operator dereferences a pointer to give you direct access to its value, while
      <code class="calibre21">
       -&gt;
      </code>
      is shorthand for a
      <code class="calibre21">
       *
      </code>
      dereference followed by a
      <code class="calibre21">
       .
      </code>
      member selection. The following code shows the equivalences:
     </p>
     <pre class="calibre26" id="c15-code-0047"><code class="calibre21">SpreadsheetCell* cell { new SpreadsheetCell };</code>
<code class="calibre21">(*cell).set(5); <span class="color">// Dereference plus member selection.</span></code>
<code class="calibre21">cell-&gt;set(5);   <span class="color">// Shorthand arrow dereference and member selection together.</span></code></pre>
     <p class="calibre13">
      You can overload the dereferencing operators for your classes to make objects of the classes behave like pointers. The main use of this capability is for implementing smart pointers, introduced in
      <a class="calibre5" href="c07.xhtml">
       Chapter 7
      </a>
      , “Memory Management.” It is also useful for iterators, which the Standard Library uses extensively. Iterators are discussed in
      <a class="calibre5" href="c17.xhtml">
       Chapter 17
      </a>
      , “Understanding Iterators and the Ranges Library.” This chapter teaches you the basic mechanics for overloading the relevant operators in the context of a simple smart pointer class template.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c15-para-0213">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          C++ has two standard smart pointers called
         </i>
         <code class="calibre21">
          std::unique_ptr
         </code>
         <i class="calibre18">
          and
         </i>
         <code class="calibre21">
          shared_ptr
         </code>
         <i class="calibre18">
          . You should use these standard smart pointers instead of writing your own. The example here is given only to demonstrate how to write dereferencing operators
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13">
      Here is an example of a smart pointer class template definition, without the dereferencing operators filled in yet:
     </p>
     <pre class="calibre26" id="c15-code-0048"><code class="calibre21">export template &lt;typename T&gt; class Pointer</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Pointer(T* ptr) : m_ptr { ptr } {}</code>
<code class="calibre21">        virtual ˜Pointer() { reset(); }</code>
<code class="calibre21">        <span class="color">// Disallow copy constructor and copy assignment.</span></code>
<code class="calibre21">        Pointer(const Pointer&amp; src) = delete;</code>
<code class="calibre21">        Pointer&amp; operator=(const Pointer&amp; rhs) = delete;</code>
<code class="calibre21">        <span class="color">// Allow move construction.</span></code>
<code class="calibre21">        Pointer(Pointer&amp;&amp; src) noexcept : m_ptr{ std::exchange(src.m_ptr, nullptr)}</code>
<code class="calibre21">        { }</code>
<code class="calibre21">        <span class="color">// Allow move assignment.</span></code>
<code class="calibre21">        Pointer&amp; operator=(Pointer&amp;&amp; rhs) noexcept</code>
<code class="calibre21">        {</code>
<code class="calibre21">            if (this != &amp;rhs) {</code>
<span aria-label="603" class="calibre20" epub:type="pagebreak" id="Page_603" role="doc-pagebreak"></span><code class="calibre21">                reset();</code>
<code class="calibre21">                m_ptr = std::exchange(rhs.m_ptr, nullptr);</code>
<code class="calibre21">            }</code>
<code class="calibre21">            return *this;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Dereferencing operators will go here…</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void reset()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            delete m_ptr;</code>
<code class="calibre21">            m_ptr = nullptr;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        T* m_ptr { nullptr };</code>
<code class="calibre21">};</code></pre>
     <p class="calibre13" id="c15-para-0215">
      This smart pointer is about as simple as you can get. All it does is store a dumb raw pointer, and the storage pointed to by the pointer is deleted when the smart pointer is destroyed. The implementation is equally simple: the constructor takes a raw pointer, which is stored as the only data member in the class. The destructor frees the storage referenced by the pointer.
     </p>
     <p class="calibre13">
      You want to be able to use the smart pointer class template like this:
     </p>
     <pre class="calibre26" id="c15-code-0049"><code class="calibre21">Pointer&lt;int&gt; smartInt { new int };</code>
<code class="calibre21">*smartInt = 5; <span class="color">// Dereference the smart pointer.</span></code>
<code class="calibre21">println("{} ", *smartInt);</code>
<code class="calibre21"> </code>
<code class="calibre21">Pointer&lt;SpreadsheetCell&gt; smartCell { new SpreadsheetCell };</code>
<code class="calibre21">smartCell-&gt;set(5); <span class="color">// Dereference and member select the set() member function.</span></code>
<code class="calibre21">println("{} ", smartCell-&gt;getValue());</code></pre>
     <p class="calibre13">
      As you can see from this example, you have to provide implementations of
      <code class="calibre21">
       operator*
      </code>
      and
      <code class="calibre21">
       operator-&gt;
      </code>
      for this class. These are implemented in the next two sections.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c15-para-0218">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          You should rarely, if ever, write an implementation of just one of
         </i>
         <code class="calibre21">
          operator*
         </code>
         <i class="calibre18">
          and
         </i>
         <code class="calibre21">
          operator-&gt;
         </code>
         <i class="calibre18">
          . You should almost always write both operators together. It would confuse the users of your class if you failed to provide both
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0037">
      </span>
      <h3 class="calibre27" id="head-3-343">
       Implementing operator*
      </h3>
      <p class="calibre13" id="c15-para-0219">
       When you dereference a pointer, you expect to be able to access the memory to which the pointer points. If that memory contains a simple type such as an
       <code class="calibre21">
        int
       </code>
       , you should be able to change its value directly. If the memory contains a more complicated type, such as an object, you should be able to access its data members or member functions with the
       <code class="calibre21">
        .
       </code>
       operator.
      </p>
      <p class="calibre13">
       To provide these semantics, you should return a reference from
       <code class="calibre21">
        operator*
       </code>
       . For the
       <code class="calibre21">
        Pointer
       </code>
       class this is done as follows:
      </p>
      <pre class="calibre26" id="c15-code-0050"><code class="calibre21">export template &lt;typename T&gt; class Pointer</code>
<code class="calibre21">{</code>
<span aria-label="604" class="calibre20" epub:type="pagebreak" id="Page_604" role="doc-pagebreak"></span><code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">T&amp; operator*() { return *m_ptr; }</b></code>
<code class="calibre21">        <b class="calibre14">const T&amp; operator*() const { return *m_ptr; }</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c15-para-0221">
       As you can see,
       <code class="calibre21">
        operator*
       </code>
       returns a reference to the object or variable to which the underlying raw pointer points. As with overloading the subscripting operators earlier in this chapter, it's useful to provide both
       <code class="calibre21">
        const
       </code>
       and non-
       <code class="calibre21">
        const
       </code>
       overloads of the member function, which return a reference-to-
       <code class="calibre21">
        const
       </code>
       and a reference-to-non-
       <code class="calibre21">
        const
       </code>
       , respectively.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0038">
      </span>
      <h3 class="calibre27" id="head-3-344">
       Implementing operator–&gt;
      </h3>
      <p class="calibre13">
       The arrow operator is a bit trickier. The result of applying the arrow operator should be a member or member function of an object. However, to implement it like that, you would have to be able to implement the equivalent of
       <code class="calibre21">
        operator*
       </code>
       followed by
       <code class="calibre21">
        operator.
       </code>
       ; C++ doesn't allow you to overload
       <code class="calibre21">
        operator.
       </code>
       for good reason: it's impossible to write a single prototype that allows you to capture any possible member or member function selection. Therefore, C++ treats
       <code class="calibre21">
        operator-&gt;
       </code>
       as a special case. Consider this line:
      </p>
      <pre class="calibre26" id="c15-code-0051"><code class="calibre21">smartCell-&gt;set(5);</code></pre>
      <p class="calibre13">
       C++ translates this to the following:
      </p>
      <pre class="calibre26" id="c15-code-0052"><code class="calibre21">(smartCell.operator-&gt;())-&gt;set(5);</code></pre>
      <p class="calibre13">
       As you can see, C++ applies another
       <code class="calibre21">
        operator-&gt;
       </code>
       to whatever you return from your overloaded
       <code class="calibre21">
        operator-&gt;
       </code>
       . Therefore, you must return a pointer, like this:
      </p>
      <pre class="calibre26" id="c15-code-0053"><code class="calibre21">export template &lt;typename T&gt; class Pointer</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">T* operator-&gt;() { return m_ptr; }</b></code>
<code class="calibre21">        <b class="calibre14">const T* operator-&gt;() const { return m_ptr; }</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c15-para-0225">
       You may find it confusing that
       <code class="calibre21">
        operator*
       </code>
       and
       <code class="calibre21">
        operator-&gt;
       </code>
       are asymmetric, but once you see them a few times, you'll get used to it.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0039">
      </span>
      <h3 class="calibre27" id="head-3-345">
       What in the World Are operator.* and operator–&gt;*?
      </h3>
      <p class="calibre13" id="c15-para-0226">
       It's perfectly legitimate in C++ to take the address of class data members and member functions to obtain pointers to them. However, you can't access a non-
       <code class="calibre21">
        static
       </code>
       data member or call a non-
       <code class="calibre21">
        static
       </code>
       member function without an object. The whole point of class data members and member functions is that they exist on a per-object basis. Thus, when you want to call the member function or access the data member via the pointer, you must dereference the pointer in the context of an object. The syntax details for using
       <code class="calibre21">
        operator.*
       </code>
       and
       <code class="calibre21">
        -&gt;*
       </code>
       is deferred until
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       , as it requires knowledge of how to define function pointers.
      </p>
      <p class="calibre13" id="c15-para-0227">
       C++ does not allow you to overload
       <code class="calibre21">
        operator.*
       </code>
       (just as you can't overload
       <code class="calibre21">
        operator.
       </code>
       ), but you could overload
       <code class="calibre21">
        operator-&gt;*
       </code>
       . However, it is tricky, and, given that most C++ programmers don't
       <span aria-label="605" class="calibre20" epub:type="pagebreak" id="Page_605" role="doc-pagebreak">
       </span>
       even know that you can access member functions and data members through pointers, it's probably not worth the trouble. The
       <code class="calibre21">
        shared_ptr
       </code>
       smart pointer in the Standard Library, for example, does not overload
       <code class="calibre21">
        operator-&gt;*
       </code>
       .
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-179" class="calibre2">
     <span class="calibre" id="c15-sec-0040">
     </span>
     <h2 class="calibre6" id="head-2-179">
      WRITING CONVERSION OPERATORS
     </h2>
     <p class="calibre13">
      Going back to the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      example, consider these two lines of code:
     </p>
     <pre class="calibre26" id="c15-code-0054"><code class="calibre21">SpreadsheetCell cell { 1.23 };</code>
<code class="calibre21">double d1 { cell }; <span class="color">// DOES NOT COMPILE!</span></code></pre>
     <p class="calibre13">
      A
      <code class="calibre21">
       SpreadsheetCell
      </code>
      contains a
      <code class="calibre21">
       double
      </code>
      representation, so it seems logical that you could assign it to a
      <code class="calibre21">
       double
      </code>
      variable. Well, you can't. The compiler tells you that it doesn't know how to convert a
      <code class="calibre21">
       SpreadsheetCell
      </code>
      to a
      <code class="calibre21">
       double
      </code>
      . You might be tempted to try forcing the compiler to do what you want, like this:
     </p>
     <pre class="calibre26" id="c15-code-0055"><code class="calibre21">double d1 { (double)cell }; <span class="color">// STILL DOES NOT COMPILE!</span></code></pre>
     <p class="calibre13" id="c15-para-0230">
      First, the preceding code still doesn't compile because the compiler still doesn't know
      <i class="calibre18">
       how
      </i>
      to convert the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      to a
      <code class="calibre21">
       double
      </code>
      . It already knew from the first line what you wanted it to do, and it would do it if it could. Second, it's a bad idea in general to add gratuitous casts to your program.
     </p>
     <p class="calibre13">
      If you want to allow this kind of conversion, you must tell the compiler how to perform it. Specifically, you can write a conversion operator to convert
      <code class="calibre21">
       SpreadsheetCell
      </code>
      s to
      <code class="calibre21">
       double
      </code>
      s. The prototype looks like this:
     </p>
     <pre class="calibre26" id="c15-code-0056"><code class="calibre21">operator double() const;</code></pre>
     <p class="calibre13">
      The name of the function is
      <code class="calibre21">
       operator double
      </code>
      . It has no return type because the return type is specified by the name of the operator:
      <code class="calibre21">
       double
      </code>
      . It is
      <code class="calibre21">
       const
      </code>
      because it doesn't change the object on which it is called. The implementation looks like this:
     </p>
     <pre class="calibre26" id="c15-code-0057"><code class="calibre21">SpreadsheetCell::operator double() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return getValue();</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      That's all you need to do to write a conversion operator from
      <code class="calibre21">
       SpreadsheetCell
      </code>
      to
      <code class="calibre21">
       double
      </code>
      . Now the compiler accepts the following lines and does the right thing at run time:
     </p>
     <pre class="calibre26" id="c15-code-0058"><code class="calibre21">SpreadsheetCell cell { 1.23 };</code>
<code class="calibre21">double d1 { cell }; <span class="color">// Works as expected</span></code></pre>
     <p class="calibre13">
      You can write conversion operators for any type with this same syntax. For example, here is an
      <code class="calibre21">
       std::string
      </code>
      conversion operator for
      <code class="calibre21">
       SpreadsheetCell
      </code>
      :
     </p>
     <pre class="calibre26" id="c15-code-0059"><code class="calibre21">operator std::string() const;</code></pre>
     <p class="calibre13">
      And here is an implementation:
     </p>
     <pre class="calibre26" id="c15-code-0060"><code class="calibre21">SpreadsheetCell::operator std::string() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return doubleToString(getValue());</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      <span aria-label="606" class="calibre20" epub:type="pagebreak" id="Page_606" role="doc-pagebreak">
      </span>
      Now you can convert a
      <code class="calibre21">
       SpreadsheetCell
      </code>
      to a
      <code class="calibre21">
       string
      </code>
      . However, due to the constructors provided by
      <code class="calibre21">
       string
      </code>
      , the following does not work:
     </p>
     <pre class="calibre26" id="c15-code-0061"><code class="calibre21">string str { cell };</code></pre>
     <p class="calibre13">
      Instead, you can either use normal assignment syntax instead of uniform initialization, or use an explicit
      <code class="calibre21">
       static_cast()
      </code>
      as follows:
     </p>
     <pre class="calibre26" id="c15-code-0062"><code class="calibre21">string str1 = cell;</code>
<code class="calibre21">string str2 { static_cast&lt;string&gt;(cell) };</code></pre>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-346">
       Operator auto
      </h3>
      <p class="calibre13">
       Instead of explicitly specifying the type that a conversion operator returns, you can specify
       <code class="calibre21">
        auto
       </code>
       and let the compiler deduce it for you. For example, the
       <code class="calibre21">
        double
       </code>
       conversion operator of
       <code class="calibre21">
        SpreadsheetCell
       </code>
       could be written as follows:
      </p>
      <pre class="calibre26" id="c15-code-0063"><code class="calibre21">operator auto() const { return getValue(); }</code></pre>
      <p class="calibre13" id="c15-para-0239">
       There is one caveat, the implementation of member functions with
       <code class="calibre21">
        auto
       </code>
       return type deduction must be visible to users of the class. Hence, this example puts the implementation directly in the class definition.
      </p>
      <p class="calibre13">
       Also, remember from
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       that
       <code class="calibre21">
        auto
       </code>
       strips away reference and
       <code class="calibre21">
        const
       </code>
       qualifiers. So, if your operator
       <code class="calibre21">
        auto
       </code>
       returns a reference to a type
       <code class="calibre21">
        T
       </code>
       , then the deduced type will be
       <code class="calibre21">
        T
       </code>
       returned by value, resulting in a copy being made. If needed, you can explicitly add reference and
       <code class="calibre21">
        const
       </code>
       qualifiers; here's an example:
      </p>
      <pre class="calibre26" id="c15-code-0064"><code class="calibre21">operator const auto&amp;() const { <span class="color">/* … */</span> }</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0042">
      </span>
      <h3 class="calibre27" id="head-3-347">
       Solving Ambiguity Problems with Explicit Conversion Operators
      </h3>
      <p class="calibre13">
       Writing the
       <code class="calibre21">
        double
       </code>
       conversion operator for the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       object introduces an
       <i class="calibre18">
        ambiguity
       </i>
       problem. Consider this line:
      </p>
      <pre class="calibre26" id="c15-code-0065"><code class="calibre21">SpreadsheetCell cell { 6.6 };</code>
<code class="calibre21"><b class="calibre14">double d1 { cell + 3.4 };</b> <span class="color">// DOES NOT COMPILE IF YOU DEFINE operator double()</span></code></pre>
      <p class="calibre13" id="c15-para-0242">
       This line now fails to compile. It worked before you wrote
       <code class="calibre21">
        operator double()
       </code>
       , so what's the problem now? The issue is that the compiler doesn't know if it should convert
       <code class="calibre21">
        cell
       </code>
       to a
       <code class="calibre21">
        double
       </code>
       with
       <code class="calibre21">
        operator double()
       </code>
       and perform
       <code class="calibre21">
        double
       </code>
       addition, or convert
       <code class="calibre21">
        3.4
       </code>
       to a
       <code class="calibre21">
        SpreadsheetCell
       </code>
       with the
       <code class="calibre21">
        double
       </code>
       constructor and perform
       <code class="calibre21">
        SpreadsheetCell
       </code>
       addition. Before you wrote
       <code class="calibre21">
        operator double()
       </code>
       , the compiler had only one choice: convert
       <code class="calibre21">
        3.4
       </code>
       to a
       <code class="calibre21">
        SpreadsheetCell
       </code>
       with the
       <code class="calibre21">
        double
       </code>
       constructor and perform
       <code class="calibre21">
        SpreadsheetCell
       </code>
       addition. However, now the compiler could do either. It doesn't want to make a choice you might not like, so it refuses to make any choice at all.
      </p>
      <p class="calibre13">
       The usual pre-C++11 solution to this conundrum is to make the constructor in question
       <code class="calibre21">
        explicit
       </code>
       so that the automatic conversion using that constructor is prevented (see
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       ). However, you don't want that constructor to be
       <code class="calibre21">
        explicit
       </code>
       because you generally like the automatic conversion of
       <code class="calibre21">
        double
       </code>
       s to
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s. Since C++11, you can solve this problem by making the
       <code class="calibre21">
        double
       </code>
       conversion operator
       <code class="calibre21">
        explicit
       </code>
       instead of the constructor:
      </p>
      <pre class="calibre26" id="c15-code-0066"><code class="calibre21"><b class="calibre14">explicit operator double() const;</b></code></pre>
      <p class="calibre13">
       <span aria-label="607" class="calibre20" epub:type="pagebreak" id="Page_607" role="doc-pagebreak">
       </span>
       With this change the following line compiles fine:
      </p>
      <pre class="calibre26" id="c15-code-0067"><code class="calibre21">double d1 { cell + 3.4 };  <span class="color">// 10</span></code></pre>
      <p class="calibre13" id="c15-para-0245">
       The operator
       <code class="calibre21">
        auto
       </code>
       as discussed in the previous section can also be marked as
       <code class="calibre21">
        explicit
       </code>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-348">
       Conversions for Boolean Expressions
      </h3>
      <p class="calibre13">
       Sometimes it is useful to be able to use objects in Boolean expressions. For example, programmers often use pointers in conditional statements like this:
      </p>
      <pre class="calibre26" id="c15-code-0068"><code class="calibre21">if (ptr != nullptr) { <span class="color">/* Perform some dereferencing action. */</span> }</code></pre>
      <p class="calibre13">
       Sometimes they write shorthand conditions such as this:
      </p>
      <pre class="calibre26" id="c15-code-0069"><code class="calibre21">if (ptr) { <span class="color">/* Perform some dereferencing action. */</span> }</code></pre>
      <p class="calibre13">
       Other times, you see code as follows:
      </p>
      <pre class="calibre26" id="c15-code-0070"><code class="calibre21">if (!ptr) { <span class="color">/* Do something. */</span> }</code></pre>
      <p class="calibre13">
       Currently, none of the preceding expressions compile with the
       <code class="calibre21">
        Pointer
       </code>
       smart pointer class template defined earlier. To make them work, we can add a conversion operator to the class to convert it to a pointer type. Then, the comparisons to
       <code class="calibre21">
        nullptr
       </code>
       , as well as the object alone in an
       <code class="calibre21">
        if
       </code>
       statement, will trigger the conversion to the pointer type. The usual pointer type for the conversion operator is
       <code class="calibre21">
        void*
       </code>
       , because that's a pointer type with which you cannot do much except test it in Boolean expressions. Here is the implementation:
      </p>
      <pre class="calibre26" id="c15-code-0071"><code class="calibre21">operator void*() const { return m_ptr; }</code></pre>
      <p class="calibre13">
       Now the following code compiles and does what you expect:
      </p>
      <pre class="calibre26" id="c15-code-0072"><code class="calibre21">void process(const Pointer&lt;SpreadsheetCell&gt;&amp; p)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (p != nullptr) { println("not nullptr"); }</code>
<code class="calibre21">    if (p != 0)       { println("not 0"); }</code>
<code class="calibre21">    if (p)            { println("not nullptr"); }</code>
<code class="calibre21">    if (!p)           { println("nullptr"); }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Pointer&lt;SpreadsheetCell&gt; smartCell { nullptr };</code>
<code class="calibre21">    process(smartCell);</code>
<code class="calibre21">    println("");</code>
<code class="calibre21"> </code>
<code class="calibre21">    Pointer&lt;SpreadsheetCell&gt; anotherSmartCell { new SpreadsheetCell { 5.0 } };</code>
<code class="calibre21">    process(anotherSmartCell);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c15-code-0073"><code class="calibre21">nullptr</code>
<code class="calibre21"> </code>
<code class="calibre21">not nullptr</code>
<code class="calibre21">not 0</code>
<code class="calibre21">not nullptr</code></pre>
      <p class="calibre13">
       <span aria-label="608" class="calibre20" epub:type="pagebreak" id="Page_608" role="doc-pagebreak">
       </span>
       Another alternative is to overload
       <code class="calibre21">
        operator bool()
       </code>
       as follows instead of
       <code class="calibre21">
        operator void*()
       </code>
       . After all, you're using the object in a Boolean expression; why not convert it directly to a
       <code class="calibre21">
        bool
       </code>
       ?
      </p>
      <pre class="calibre26" id="c15-code-0074"><code class="calibre21">operator bool() const { return m_ptr != nullptr; }</code></pre>
      <p class="calibre13">
       The following comparisons still work:
      </p>
      <pre class="calibre26" id="c15-code-0075"><code class="calibre21">if (p != 0)    { println("not 0"); }</code>
<code class="calibre21">if (p)         { println("not nullptr"); }</code>
<code class="calibre21">if (!p)        { println("nullptr"); }</code></pre>
      <p class="calibre13">
       However, with
       <code class="calibre21">
        operator bool()
       </code>
       , the following comparison with
       <code class="calibre21">
        nullptr
       </code>
       results in a compilation error:
      </p>
      <pre class="calibre26" id="c15-code-0076"><code class="calibre21">if (p != nullptr) { println("not nullptr"); }  <span class="color">// Error</span></code></pre>
      <p class="calibre13">
       This is because
       <code class="calibre21">
        nullptr
       </code>
       has its own type called
       <code class="calibre21">
        nullptr_t
       </code>
       , which is not automatically converted to the integer 0 (
       <code class="calibre21">
        false
       </code>
       ). The compiler cannot find an
       <code class="calibre21">
        operator!=
       </code>
       that takes a
       <code class="calibre21">
        Pointer
       </code>
       object and a
       <code class="calibre21">
        nullptr_t
       </code>
       object. You could implement such an
       <code class="calibre21">
        operator!=
       </code>
       as a
       <code class="calibre21">
        friend
       </code>
       of the
       <code class="calibre21">
        Pointer
       </code>
       class:
      </p>
      <pre class="calibre26" id="c15-code-0077"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Pointer</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        template &lt;typename T&gt;</code>
<code class="calibre21">        friend bool operator!=(const Pointer&lt;T&gt;&amp; lhs, std::nullptr_t rhs);</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">bool operator!=(const Pointer&lt;T&gt;&amp; lhs, std::nullptr_t rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return lhs.m_ptr != rhs;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       However, after implementing this
       <code class="calibre21">
        operator!=
       </code>
       , the following comparison stops working, because the compiler no longer knows which
       <code class="calibre21">
        operator!=
       </code>
       to use:
      </p>
      <pre class="calibre26" id="c15-code-0078"><code class="calibre21">if (p != 0)    { println("not 0"); }</code></pre>
      <p class="calibre13">
       From this example, you might conclude that the
       <code class="calibre21">
        operator bool()
       </code>
       technique only seems appropriate for objects that don't represent pointers and for which conversion to a pointer type really doesn't make sense. Unfortunately, even then, adding a conversion operator to
       <code class="calibre21">
        bool
       </code>
       presents some other unanticipated consequences. C++ applies
       <i class="calibre18">
        promotion
       </i>
       rules to silently convert
       <code class="calibre21">
        bool
       </code>
       to
       <code class="calibre21">
        int
       </code>
       whenever the opportunity arises. Therefore, with the
       <code class="calibre21">
        operator bool()
       </code>
       , the following code compiles and runs:
      </p>
      <pre class="calibre26" id="c15-code-0079"><code class="calibre21">Pointer&lt;SpreadsheetCell&gt; anotherSmartCell { new SpreadsheetCell { 5.0 } };</code>
<code class="calibre21">int i { anotherSmartCell }; <span class="color">// Converts Pointer to bool to int.</span></code></pre>
      <p class="calibre13" id="c15-para-0258">
       That's usually not behavior that you expect or desire. To prevent such assignments, you could explicitly delete the conversion operators to
       <code class="calibre21">
        int
       </code>
       ,
       <code class="calibre21">
        long
       </code>
       ,
       <code class="calibre21">
        long long
       </code>
       , and so on. However, this is getting messy. So, many programmers prefer
       <code class="calibre21">
        operator void*()
       </code>
       instead of
       <code class="calibre21">
        operator bool()
       </code>
       .
      </p>
      <p class="calibre13" id="c15-para-0259">
       As you can see, there is a design element to overloading operators. Your decisions about which operators to overload directly influence the ways in which clients can use your classes.
      </p>
     </section>
    </section>
    <span aria-label="609" class="calibre20" epub:type="pagebreak" id="Page_609" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-180" class="calibre2">
     <span class="calibre" id="c15-sec-0044">
     </span>
     <h2 class="calibre6" id="head-2-180">
      OVERLOADING THE MEMORY ALLOCATION AND DEALLOCATION OPERATORS
     </h2>
     <p class="calibre13">
      C++ gives you the ability to redefine the way memory allocation and deallocation work in your programs. You can provide this customization both on the global level and the class level. This capability is most useful when you are worried about memory fragmentation, which can occur if you allocate and deallocate a lot of small objects. For example, instead of going to the default C++ memory allocation each time you need memory, you could write a memory pool allocator that reuses fixed-size chunks of memory. This section explains the subtleties of the memory allocation and deallocation routines and shows you how to customize them. With these tools, you should be able to write your own allocator if the need ever arises.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c15-para-0261">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          Unless you know a lot about memory allocation strategies, attempts to overload the memory allocation routines are rarely worth the trouble. Don't overload them just because it sounds like a neat idea. Only do so if you have a genuine requirement and the necessary knowledge
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-349">
       How new and delete Really Work
      </h3>
      <p class="calibre13">
       One of the trickiest aspects of C++ is the details of
       <code class="calibre21">
        new
       </code>
       and
       <code class="calibre21">
        delete
       </code>
       . Consider this line of code:
      </p>
      <pre class="calibre26" id="c15-code-0080"><code class="calibre21">SpreadsheetCell* cell { new SpreadsheetCell {} };</code></pre>
      <p class="calibre13" id="c15-para-0263">
       The part
       <code class="calibre21">
        new SpreadsheetCell{}
       </code>
       is called the
       <i class="calibre18">
        new-expression
       </i>
       . It does two things. First, it allocates space for the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       object by making a call to
       <code class="calibre21">
        operator new
       </code>
       . Second, it calls the constructor for the object. Only after the constructor has completed does it return the pointer to you.
      </p>
      <p class="calibre13">
       <code class="calibre21">
        delete
       </code>
       works analogously. Consider this line of code:
      </p>
      <pre class="calibre26" id="c15-code-0081"><code class="calibre21">delete cell;</code></pre>
      <p class="calibre13" id="c15-para-0265">
       This line is called the
       <i class="calibre18">
        delete-expression
       </i>
       . It first calls the destructor for
       <code class="calibre21">
        cell
       </code>
       and then calls
       <code class="calibre21">
        operator delete
       </code>
       to free the memory.
      </p>
      <p class="calibre13" id="c15-para-0266">
       You can overload
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       to control memory allocation and deallocation, but you cannot overload the new-expression or the delete-expression. Thus, you can customize the actual memory allocation and deallocation, but not the calls to the constructor and destructor.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0047">
       </span>
       <h4 class="calibre29" id="head-4-249">
        The New-Expression and operator new
       </h4>
       <p class="calibre13">
        There are six different forms of the
        <i class="calibre18">
         new-expression
        </i>
        , each of which has a corresponding
        <code class="calibre21">
         operator new
        </code>
        . Earlier chapters in this book already show four new-expressions:
        <code class="calibre21">
         new
        </code>
        ,
        <code class="calibre21">
         new[]
        </code>
        ,
        <code class="calibre21">
         new(nothrow)
        </code>
        , and
        <code class="calibre21">
         new(nothrow)[]
        </code>
        . The following list shows the corresponding four
        <code class="calibre21">
         operator new
        </code>
        overloads defined in
        <code class="calibre21">
         &lt;new&gt;
        </code>
        :
       </p>
       <pre class="calibre26" id="c15-code-0082"><code class="calibre21">void* operator new(std::size_t size);</code>
<code class="calibre21">void* operator new[](std::size_t size);</code>
<code class="calibre21">void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21">void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;</code></pre>
       <p class="calibre13">
        <span aria-label="610" class="calibre20" epub:type="pagebreak" id="Page_610" role="doc-pagebreak">
        </span>
        There are two special new-expressions that don't do any allocation but invoke the constructor on an already allocated piece of memory. These are called
        <i class="calibre18">
         placement new operators
        </i>
        (including both single and array forms). They allow you to construct an object in pre-allocated memory like this:
       </p>
       <pre class="calibre26" id="c15-code-0083"><code class="calibre21">void* ptr { allocateMemorySomehow() };</code>
<code class="calibre21">SpreadsheetCell* cell { new (ptr) SpreadsheetCell {} };</code></pre>
       <p class="calibre13">
        The two corresponding
        <code class="calibre21">
         operator new
        </code>
        overloads for these look as follows; however, the C++ standard forbids you to overload them:
       </p>
       <pre class="calibre26" id="c15-code-0084"><code class="calibre21">void* operator new(std::size_t size, void* p) noexcept;</code>
<code class="calibre21">void* operator new[](std::size_t size, void* p) noexcept;</code></pre>
       <p class="calibre13" id="c15-para-0270">
        This feature is a bit obscure, but it's important to know that it exists. It can come in handy if you want to implement memory pools by reusing memory without freeing it in between. This allows you to construct and destruct instances of an object without re-allocating memory for each new instance.
        <a class="calibre5" href="c29.xhtml">
         Chapter 29
        </a>
        , “Writing Efficient C++,” gives an example of a memory pool implementation.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0048">
       </span>
       <h4 class="calibre29" id="head-4-250">
        The Delete-Expression and operator delete
       </h4>
       <p class="calibre13" id="c15-para-0271">
        There are only two different forms of the
        <i class="calibre18">
         delete-expression
        </i>
        that you can call:
        <code class="calibre21">
         delete
        </code>
        , and
        <code class="calibre21">
         delete[]
        </code>
        ; there are no
        <code class="calibre21">
         nothrow
        </code>
        or placement forms. However, there are all six overloads of
        <code class="calibre21">
         operator delete
        </code>
        . Why the asymmetry? The two
        <code class="calibre21">
         nothrow
        </code>
        and two placement overloads are used only if an exception is thrown from a constructor. In that case, the
        <code class="calibre21">
         operator delete
        </code>
        is called that matches the
        <code class="calibre21">
         operator new
        </code>
        that was used to allocate the memory prior to the constructor call. However, if you delete a pointer normally,
        <code class="calibre21">
         delete
        </code>
        calls
        <code class="calibre21">
         operator delete
        </code>
        and
        <code class="calibre21">
         delete[]
        </code>
        calls
        <code class="calibre21">
         operator delete[]
        </code>
        (never the
        <code class="calibre21">
         nothrow
        </code>
        or placement forms). Practically, this doesn't really matter because the C++ standard says that throwing an exception from
        <code class="calibre21">
         delete
        </code>
        (for example, from a destructor called by
        <code class="calibre21">
         delete
        </code>
        ) results in undefined behavior. This means
        <code class="calibre21">
         delete
        </code>
        should never throw an exception anyway, so the
        <code class="calibre21">
         nothrow
        </code>
        overload of
        <code class="calibre21">
         operator delete
        </code>
        is superfluous. Also, placement
        <code class="calibre21">
         delete
        </code>
        should be a no-op, because placement
        <code class="calibre21">
         new
        </code>
        doesn't allocate any memory, so there's nothing to free.
       </p>
       <p class="calibre13">
        Here are the prototypes for the six
        <code class="calibre21">
         operator delete
        </code>
        overloads corresponding to the six
        <code class="calibre21">
         operator new
        </code>
        overloads:
       </p>
       <pre class="calibre26" id="c15-code-0085"><code class="calibre21">void operator delete(void* ptr) noexcept;</code>
<code class="calibre21">void operator delete[](void* ptr) noexcept;</code>
<code class="calibre21">void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21">void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21">void operator delete(void* ptr, void*) noexcept;</code>
<code class="calibre21">void operator delete[](void* ptr, void*) noexcept;</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0049">
      </span>
      <h3 class="calibre27" id="head-3-350">
       Overloading operator new and operator delete
      </h3>
      <p class="calibre13">
       You can replace the global
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       routines if you want. These functions are called for every new-expression and delete-expression in the program, unless there are more specific routines in individual classes. However, to quote Bjarne Stroustrup, “… replacing the global
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       is not for the fainthearted” (
       <i class="calibre18">
        The C++ Programming Language
       </i>
       , third edition, Addison-Wesley, 1997). I don't recommend it either!
       <span aria-label="611" class="calibre20" epub:type="pagebreak" id="Page_611" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0274">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           If you fail to heed my advice and decide to replace the global
          </i>
          <code class="calibre21">
           operator new
          </code>
          <i class="calibre18">
           , keep in mind that you cannot put any code in the operator that makes a call to
          </i>
          <code class="calibre21">
           new
          </code>
          <i class="calibre18">
           because this will cause an infinite recursion. For example, you cannot write a message to the console with
          </i>
          <code class="calibre21">
           print()
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       A more useful technique is to overload
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       for specific classes. These overloaded operators will be called only when you allocate and deallocate objects of that particular class. Here is an example of a class that overloads the four non-placement forms of
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       :
      </p>
      <pre class="calibre26" id="c15-code-0086"><code class="calibre21">export class MemoryDemo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        virtual ˜MemoryDemo() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void* operator new(std::size_t size);</code>
<code class="calibre21">        void operator delete(void* ptr) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void* operator new[](std::size_t size);</code>
<code class="calibre21">        void operator delete[](void* ptr) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21">        void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21">        void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Here are implementations of these operators that simply write out a message to the standard output and pass the arguments through to calls to the global versions of the operators. Note that
       <code class="calibre21">
        nothrow
       </code>
       is actually a variable of type
       <code class="calibre21">
        nothrow_t
       </code>
       .
      </p>
      <pre class="calibre26" id="c15-code-0087"><code class="calibre21">void* MemoryDemo::operator new(size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator new");</code>
<code class="calibre21">    return ::operator new(size);</code>
<code class="calibre21">}</code>
<code class="calibre21">void MemoryDemo::operator delete(void* ptr) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator delete");</code>
<code class="calibre21">    ::operator delete(ptr);</code>
<code class="calibre21">}</code>
<code class="calibre21">void* MemoryDemo::operator new[](size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator new[]");</code>
<code class="calibre21">    return ::operator new[](size);</code>
<code class="calibre21">}</code>
<code class="calibre21">void MemoryDemo::operator delete[](void* ptr) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator delete[]");</code>
<code class="calibre21">    ::operator delete[](ptr);</code>
<code class="calibre21">}</code>
<span aria-label="612" class="calibre20" epub:type="pagebreak" id="Page_612" role="doc-pagebreak"></span><code class="calibre21">void* MemoryDemo::operator new(size_t size, const nothrow_t&amp;) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator new nothrow");</code>
<code class="calibre21">    return ::operator new(size, nothrow);</code>
<code class="calibre21">}</code>
<code class="calibre21">void MemoryDemo::operator delete(void* ptr, const nothrow_t&amp;) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator delete nothrow");</code>
<code class="calibre21">    ::operator delete(ptr, nothrow);</code>
<code class="calibre21">}</code>
<code class="calibre21">void* MemoryDemo::operator new[](size_t size, const nothrow_t&amp;) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator new[] nothrow");</code>
<code class="calibre21">    return ::operator new[](size, nothrow);</code>
<code class="calibre21">}</code>
<code class="calibre21">void MemoryDemo::operator delete[](void* ptr, const nothrow_t&amp;) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator delete[] nothrow");</code>
<code class="calibre21">    ::operator delete[](ptr, nothrow);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Here is some code that allocates and frees objects of this class in several ways:
      </p>
      <pre class="calibre26" id="c15-code-0088"><code class="calibre21">MemoryDemo* mem { new MemoryDemo{} };</code>
<code class="calibre21">delete mem;</code>
<code class="calibre21">mem = new MemoryDemo[10];</code>
<code class="calibre21">delete [] mem;</code>
<code class="calibre21">mem = new (nothrow) MemoryDemo{};</code>
<code class="calibre21">delete mem;</code>
<code class="calibre21">mem = new (nothrow) MemoryDemo[10];</code>
<code class="calibre21">delete [] mem;</code></pre>
      <p class="calibre13">
       Here is the output from running the program:
      </p>
      <pre class="calibre26" id="c15-code-0089"><code class="calibre21">operator new</code>
<code class="calibre21">operator delete</code>
<code class="calibre21">operator new[]</code>
<code class="calibre21">operator delete[]</code>
<code class="calibre21">operator new nothrow</code>
<code class="calibre21">operator delete</code>
<code class="calibre21">operator new[] nothrow</code>
<code class="calibre21">operator delete[]</code></pre>
      <p class="calibre13">
       These implementations of
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       are obviously trivial and not particularly useful. They are intended only to give you an idea of the syntax in case you ever want to implement nontrivial versions of them.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0280">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Whenever you overload
          </i>
          <code class="calibre21">
           operator new
          </code>
          <i class="calibre18">
           , overload the corresponding form of
          </i>
          <code class="calibre21">
           operator delete
          </code>
          <i class="calibre18">
           . Otherwise, memory will be allocated as you specify but freed according to the built-in semantics, which may not be compatible
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <span aria-label="613" class="calibre20" epub:type="pagebreak" id="Page_613" role="doc-pagebreak">
       </span>
       It might seem overkill to overload all the various forms of
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       . However, it's generally a good idea to do so to prevent inconsistencies in memory allocations. If you don't want to provide implementations for certain overloads, you can explicitly delete these using
       <code class="calibre21">
        =delete
       </code>
       to prevent anyone from using them. See the next section for more information.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0282">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Overload all forms of
          </i>
          <code class="calibre21">
           operator new
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           operator delete
          </code>
          <i class="calibre18">
           , or explicitly delete overloads that you don't want to get used, to prevent inconsistencies in the memory allocations
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0053">
      </span>
      <h3 class="calibre27" id="head-3-351">
       Explicitly Deleting or Defaulting operator new and operator delete
      </h3>
      <p class="calibre13">
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       shows how you can explicitly delete or default a constructor or assignment operator. Explicitly deleting or defaulting is not limited to constructors and assignment operators. For example, the following class deletes
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        new[]
       </code>
       , which means that objects of this class cannot be dynamically allocated using
       <code class="calibre21">
        new
       </code>
       or
       <code class="calibre21">
        new[]
       </code>
       :
      </p>
      <pre class="calibre26" id="c15-code-0090"><code class="calibre21">class MyClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void* operator new(std::size_t) = delete;</code>
<code class="calibre21">        void* operator new[](std::size_t) = delete;</code>
<code class="calibre21">        void* operator new(std::size_t, const std::nothrow_t&amp;) noexcept = delete;</code>
<code class="calibre21">        void* operator new[](std::size_t, const std::nothrow_t&amp;) noexcept = delete;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Using this class as follows results in compilation errors:
      </p>
      <pre class="calibre26" id="c15-code-0091"><code class="calibre21">MyClass* p1 { new MyClass };</code>
<code class="calibre21">MyClass* p2 { new MyClass[2] };</code>
<code class="calibre21">MyClass* p3 { new (std::nothrow) MyClass };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0054">
      </span>
      <h3 class="calibre27" id="head-3-352">
       Overloading operator new and operator delete with Extra Parameters
      </h3>
      <p class="calibre13" id="c15-para-0285">
       In addition to overloading the standard forms of
       <code class="calibre21">
        operator new
       </code>
       , you can write your own versions with extra parameters. These extra parameters can be useful for passing various flags or counters to your memory allocation routines. For instance, some runtime libraries use this in debug mode to provide the filename and line number where an object is allocated, so when there is a memory leak, the offending line that did the allocation can be identified.
      </p>
      <p class="calibre13">
       As an example, here are the prototypes for an additional
       <code class="calibre21">
        operator new
       </code>
       and
       <code class="calibre21">
        operator delete
       </code>
       with an extra integer parameter for the
       <code class="calibre21">
        MemoryDemo
       </code>
       class:
      </p>
      <pre class="calibre26" id="c15-code-0092"><code class="calibre21">void* operator new(std::size_t size, int extra);</code>
<code class="calibre21">void operator delete(void* ptr, int extra) noexcept;</code></pre>
      <p class="calibre13">
       <span aria-label="614" class="calibre20" epub:type="pagebreak" id="Page_614" role="doc-pagebreak">
       </span>
       The implementations are as follows:
      </p>
      <pre class="calibre26" id="c15-code-0093"><code class="calibre21">void* MemoryDemo::operator new(std::size_t size, int extra)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator new with extra int: {}", extra);</code>
<code class="calibre21">    return ::operator new(size);</code>
<code class="calibre21">}</code>
<code class="calibre21">void MemoryDemo::operator delete(void* ptr, int extra) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator delete with extra int: {}", extra);</code>
<code class="calibre21">    return ::operator delete(ptr);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       When you write an overloaded
       <code class="calibre21">
        operator new
       </code>
       with extra parameters, the compiler automatically allows the corresponding new-expression. The extra arguments to
       <code class="calibre21">
        new
       </code>
       are passed with function call syntax (as with
       <code class="calibre21">
        nothrow
       </code>
       overloads). So, you can now write code like this:
      </p>
      <pre class="calibre26" id="c15-code-0094"><code class="calibre21">MemoryDemo* memp { new(5) MemoryDemo{} };</code>
<code class="calibre21">delete memp;</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c15-code-0095"><code class="calibre21">operator new with extra int: 5</code>
<code class="calibre21">operator delete</code></pre>
      <p class="calibre13" id="c15-para-0290">
       When you define an
       <code class="calibre21">
        operator new
       </code>
       with extra parameters, you should also define the corresponding
       <code class="calibre21">
        operator delete
       </code>
       with the same extra parameters. However, you cannot call this
       <code class="calibre21">
        operator delete
       </code>
       with extra parameters yourself; it will be called only when you use your
       <code class="calibre21">
        operator new
       </code>
       with extra parameters and the constructor of your object throws an exception.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0055">
      </span>
      <h3 class="calibre27" id="head-3-353">
       Overloading operator delete with Size of Memory as Parameter
      </h3>
      <p class="calibre13">
       An alternate form of
       <code class="calibre21">
        operator delete
       </code>
       gives you the size of the memory that should be freed as well as the pointer. Simply declare the prototype for
       <code class="calibre21">
        operator delete
       </code>
       with an extra size parameter.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c15-para-0292">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           If a class declares two overloads of
          </i>
          <code class="calibre21">
           operator delete
          </code>
          <i class="calibre18">
           with one overload taking the size as a parameter and the other doesn't, the overload without the size parameter will always get called. If you want the overload with the size parameter to be used, write only that overload.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       You can replace
       <code class="calibre21">
        operator delete
       </code>
       with an overload that takes a size for any of the overloads of
       <code class="calibre21">
        operator delete
       </code>
       independently. Here is the
       <code class="calibre21">
        MemoryDemo
       </code>
       class definition with the first
       <code class="calibre21">
        operator delete
       </code>
       modified to take the size of the memory to be deleted:
      </p>
      <pre class="calibre26" id="c15-code-0096"><code class="calibre21">export class MemoryDemo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        void* operator new(std::size_t size);</code>
<code class="calibre21">        <b class="calibre14">void operator delete(void* ptr, std::size_t size) noexcept;</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="615" class="calibre20" epub:type="pagebreak" id="Page_615" role="doc-pagebreak">
       </span>
       The implementation of this
       <code class="calibre21">
        operator delete
       </code>
       again simply calls the global
       <code class="calibre21">
        operator delete
       </code>
       :
      </p>
      <pre class="calibre26" id="c15-code-0097"><code class="calibre21">void MemoryDemo::operator delete(void* ptr, size_t size) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("operator delete with size {}", size);</code>
<code class="calibre21">    ::operator delete(ptr, size);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c15-para-0295">
       This capability is useful only if you are writing a complicated memory allocation and deallocation scheme for your classes.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-181" class="calibre2">
     <span class="calibre" id="c15-sec-0057">
     </span>
     <h2 class="calibre6" id="head-2-181">
      OVERLOADING USER-DEFINED LITERAL OPERATORS
     </h2>
     <p class="calibre13">
      C++ has a number of built-in literal types that you can use in your code. Here are some examples:
     </p>
     <ul class="check" id="c15-list-0005">
      <li class="calibre9" id="c15-li-0025">
       <code class="calibre21">
        'a'
       </code>
       : Character
      </li>
      <li class="calibre9" id="c15-li-0026">
       <code class="calibre21">
        "A string"
       </code>
       : Zero-terminated sequence of characters, C-style string
      </li>
      <li class="calibre9" id="c15-li-0027">
       <code class="calibre21">
        3.14f
       </code>
       :
       <code class="calibre21">
        float
       </code>
       single-precision floating-point value
      </li>
      <li class="calibre9" id="c15-li-0028">
       <code class="calibre21">
        0xabc
       </code>
       : Hexadecimal value
      </li>
     </ul>
     <p class="calibre13" id="c15-para-0297">
      C++ also allows you to define your own literals, and the Standard Library does exactly that; it provides a number of additional literal types to construct Standard Library objects. Let's take a look at these first and then see how you can define your own.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0058">
      </span>
      <h3 class="calibre27" id="head-3-354">
       Standard Library Literals
      </h3>
      <p class="calibre13" id="c15-para-0298">
       The C++ Standard Library defines the following standard literals. Note that these literals do not start with an underscore:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          LITERAL
         </th>
         <th class="left" scope="col">
          CREATES INSTANCES OF …
         </th>
         <th class="left" scope="col">
          EXAMPLE
         </th>
         <th class="left" scope="col">
          REQUIRES NAMESPACE
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           s
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           string
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           auto myString { "Hello"s };
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           string_literals
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           sv
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           string_view
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           auto myStringView { "Hello"sv };
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           string_view_literals
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           h,
           <code class="calibre21">
            min
           </code>
           ,
           <code class="calibre21">
            s
           </code>
           ,
           <code class="calibre21">
            ms
           </code>
           ,
           <code class="calibre21">
            us
           </code>
           ,
           <code class="calibre21">
            ns
           </code>
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           chrono::duration
           <a class="calibre5" href="#c15-note-0001" id="R_c15-note-0001">
            <sup class="calibre22">
             1
            </sup>
           </a>
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           auto myDuration { 42min };
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           chrono_literals
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           y,
           <code class="calibre21">
            d
           </code>
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           chrono::year
          </code>
          and
          <code class="calibre21">
           day
          </code>
          <sup class="calibre22">
           <a class="calibre5" href="#c15-note-0001">
            <code class="calibre21">
             1
            </code>
           </a>
          </sup>
         </td>
         <td class="left1">
          <code class="calibre21">
           auto thisYear { 2024y };
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           chrono_literals
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           i,
           <code class="calibre21">
            il
           </code>
           ,
           <code class="calibre21">
            if
           </code>
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           complex&lt;T&gt;
          </code>
          with
          <code class="calibre21">
           T
          </code>
          equal to
          <code class="calibre21">
           double
          </code>
          ,
          <code class="calibre21">
           long double
          </code>
          ,
          <code class="calibre21">
           float
          </code>
          , respectively
         </td>
         <td class="left1">
          <code class="calibre21">
           auto myComplexNumber { 1.3i };
          </code>
         </td>
         <td class="left1">
          <code class="calibre21">
           complex_literals
          </code>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="tablefootnote" id="c15-note-0001">
       <a class="calibre5" href="#R_c15-note-0001" role="doc-backlink">
        <sup class="calibre41">
         1
        </sup>
       </a>
       Discussed in
       <a class="calibre5" href="c22.xhtml">
        Chapter 22
       </a>
       , “Date and Time Utilities.”
      </p>
      <p class="calibre13">
       <span aria-label="616" class="calibre20" epub:type="pagebreak" id="Page_616" role="doc-pagebreak">
       </span>
       Technically, all of these are defined in subnamespaces of
       <code class="calibre21">
        std::literals
       </code>
       , for example
       <code class="calibre21">
        std::literals::string_literals
       </code>
       . However, both
       <code class="calibre21">
        string_literals
       </code>
       and
       <code class="calibre21">
        literals
       </code>
       are inline namespaces that automatically make their contents available in their parent namespace. Hence, if you want to use
       <code class="calibre21">
        s
       </code>
       string literals, you can use any of the following
       <code class="calibre21">
        using
       </code>
       directives:
      </p>
      <pre class="calibre26" id="c15-code-0098"><code class="calibre21">using namespace std;</code>
<code class="calibre21">using namespace std::literals;</code>
<code class="calibre21">using namespace std::string_literals;</code>
<code class="calibre21">using namespace std::literals::string_literals;</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c15-sec-0059">
      </span>
      <h3 class="calibre27" id="head-3-355">
       User-Defined Literals
      </h3>
      <p class="calibre13" id="c15-para-0302">
       User-defined literals should start with exactly one underscore. Some examples are
       <code class="calibre21">
        _i
       </code>
       ,
       <code class="calibre21">
        _s
       </code>
       ,
       <code class="calibre21">
        _km
       </code>
       ,
       <code class="calibre21">
        _miles
       </code>
       ,
       <code class="calibre21">
        _K
       </code>
       , and so on.
      </p>
      <p class="calibre13" id="c15-para-0303">
       User-defined literals are implemented by writing
       <i class="calibre18">
        literal operators
       </i>
       . A literal operator can work in
       <i class="calibre18">
        raw
       </i>
       or
       <i class="calibre18">
        cooked
       </i>
       mode. In raw mode, your literal operator receives a sequence of characters, while in cooked mode your literal operator receives a specific interpreted type. For example, take the C++ literal
       <code class="calibre21">
        123
       </code>
       . A raw literal operator receives this as a sequence of characters
       <code class="calibre21">
        '1'
       </code>
       ,
       <code class="calibre21">
        '2'
       </code>
       ,
       <code class="calibre21">
        '3'
       </code>
       . A cooked literal operator receives this as the integer 123. The literal
       <code class="calibre21">
        0x23
       </code>
       is received by a raw operator as the characters
       <code class="calibre21">
        '0'
       </code>
       ,
       <code class="calibre21">
        'x'
       </code>
       ,
       <code class="calibre21">
        '2'
       </code>
       ,
       <code class="calibre21">
        '3'
       </code>
       , while a cooked operator receives the integer 35. A literal such as
       <code class="calibre21">
        3.14
       </code>
       is received by a raw operator as
       <code class="calibre21">
        '3'
       </code>
       ,
       <code class="calibre21">
        '.'
       </code>
       ,
       <code class="calibre21">
        '1'
       </code>
       ,
       <code class="calibre21">
        '4'
       </code>
       , while a cooked operator receives the floating-point value 3.14.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0060">
       </span>
       <h4 class="calibre29" id="head-4-251">
        Cooked-Mode Literal Operator
       </h4>
       <p class="calibre13">
        A cooked-mode literal operator should have either of the following:
       </p>
       <ul class="check" id="c15-list-0006">
        <li class="calibre9" id="c15-li-0029">
         <b class="calibre14">
          To process numeric values:
         </b>
         One parameter of type
         <code class="calibre21">
          unsigned long long
         </code>
         ,
         <code class="calibre21">
          long double
         </code>
         ,
         <code class="calibre21">
          char
         </code>
         ,
         <code class="calibre21">
          wchar_t
         </code>
         ,
         <code class="calibre21">
          char8_t
         </code>
         ,
         <code class="calibre21">
          char16_t
         </code>
         , or
         <code class="calibre21">
          char32_t
         </code>
        </li>
        <li class="calibre9" id="c15-li-0030">
         <b class="calibre14">
          To process strings:
         </b>
         Two parameters where the first is a C-style string and the second is the length of the string, for instance,
         <code class="calibre21">
          (const char* str
         </code>
         ,
         <code class="calibre21">
          std::size_t len)
         </code>
        </li>
       </ul>
       <p class="calibre13">
        For example, the following code defines a
        <code class="calibre21">
         Length
        </code>
        class storing a length in meters. The constructor is
        <code class="calibre21">
         private
        </code>
        because users should only be able to construct a
        <code class="calibre21">
         Length
        </code>
        instance using the provided user-defined literals. The code provides cooked literal operators for user-defined literal operators
        <code class="calibre21">
         _km
        </code>
        and
        <code class="calibre21">
         _m
        </code>
        . Both of these are friends of
        <code class="calibre21">
         Length
        </code>
        so that they can access the
        <code class="calibre21">
         private
        </code>
        constructor. There must not be any space between the
        <code class="calibre21">
         ""
        </code>
        and the underscore of these operators.
       </p>
       <pre class="calibre26" id="c15-code-0099"><code class="calibre21"><span class="color">// A class representing a length. The length is always stored in meters.</span></code>
<code class="calibre21">class Length</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        long double getMeters() const { return m_length; }</code>
<code class="calibre21">        <span class="color">// The user-defined literals _km and _m are friends of Length so they</span></code>
<code class="calibre21">        <span class="color">// can use the private constructor.</span></code>
<code class="calibre21">        friend Length operator ""_km(long double d);</code>
<code class="calibre21">        friend Length operator ""_m(long double d);</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Private constructor because users should only be able to construct a</span></code>
<code class="calibre21">        <span class="color">// Length using the provided user-defined literals.</span></code>
<code class="calibre21">        Length(long double length) : m_length { length } {}</code>
<code class="calibre21">        long double m_length;</code>
<span aria-label="617" class="calibre20" epub:type="pagebreak" id="Page_617" role="doc-pagebreak"></span><code class="calibre21">};</code>
<code class="calibre21">Length operator ""_km(long double d) <span class="color">// Cooked _km literal operator</span></code>
<code class="calibre21">{</code>
<code class="calibre21">    return Length { d * 1000 }; <span class="color">// Convert to meters.</span></code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">Length operator ""_m(long double d) // Cooked _m literal operator</span></code>
<code class="calibre21">{</code>
<code class="calibre21">    return Length { d };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        These literal operators can be used as follows:
       </p>
       <pre class="calibre26" id="c15-code-0100"><code class="calibre21">Length d1 { 1.2_km };</code>
<code class="calibre21">auto d2 { 1.2_m };</code>
<code class="calibre21">println("d1 = {}m; d2 = {}m", d1.getMeters(), d2.getMeters());</code></pre>
       <p class="calibre13">
        Here is the output:
       </p>
       <pre class="calibre26" id="c15-code-0101"><code class="calibre21">d1 = 1200m; d2 = 1.2m</code></pre>
       <p class="calibre13">
        To demonstrate the variant of a cooked literal operator accepting a
        <code class="calibre21">
         const char*
        </code>
        and a
        <code class="calibre21">
         size_t
        </code>
        , we can re-create the standard string literal,
        <code class="calibre21">
         s
        </code>
        , provided by the Standard Library, to construct an
        <code class="calibre21">
         std::string
        </code>
        . Let's call the literal
        <code class="calibre21">
         _s
        </code>
        .
       </p>
       <pre class="calibre26" id="c15-code-0102"><code class="calibre21">string operator ""_s(const char* str, size_t len)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return string { str, len };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        This literal operator can be used as follows:
       </p>
       <pre class="calibre26" id="c15-code-0103"><code class="calibre21">string str1 { "Hello World"_s };</code>
<code class="calibre21">auto str2 { "Hello World"_s };   <span class="color">// str2 has as type string</span></code></pre>
       <p class="calibre13">
        Without the
        <code class="calibre21">
         _s
        </code>
        literal operator, the
        <code class="calibre21">
         auto
        </code>
        type deduction would result in
        <code class="calibre21">
         const char*
        </code>
        :
       </p>
       <pre class="calibre26" id="c15-code-0104"><code class="calibre21">auto str3 { "Hello World" };     <span class="color">// str3 has as type const char*</span></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c15-sec-0061">
       </span>
       <h4 class="calibre29" id="head-4-252">
        Raw-Mode Literal Operator
       </h4>
       <p class="calibre13">
        A raw-mode literal operator requires one parameter of type
        <code class="calibre21">
         const char*
        </code>
        , a zero-terminated C-style string. The following example defines the earlier literal operator
        <code class="calibre21">
         _m
        </code>
        as a raw literal operator:
       </p>
       <pre class="calibre26" id="c15-code-0105"><code class="calibre21">Length operator ""_m(const char* str)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Implementation omitted; it requires parsing the C-style string</span></code>
<code class="calibre21">    <span class="color">// converting it to a long double, and constructing a Length.</span></code>
<code class="calibre21">    <span class="color">…</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Using this raw-mode literal operator is the same as using the cooked version.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c15-para-0313">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Raw-mode literal operators work only with non-string literals. For example,
           </i>
           <code class="calibre21">
            1.23_m
           </code>
           <i class="calibre18">
            could be implemented with a raw-mode literal operator, but
           </i>
           <code class="calibre21">
            "1.23"_m
           </code>
           <i class="calibre18">
            cannot. The latter one requires a cooked-mode literal with two parameters: the zero-terminated string and its length.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
    </section>
    <span aria-label="618" class="calibre20" epub:type="pagebreak" id="Page_618" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-182" class="calibre2">
     <span class="calibre" id="c15-sec-0063">
     </span>
     <h2 class="calibre6" id="head-2-182">
      SUMMARY
     </h2>
     <p class="calibre13" id="c15-para-0314">
      This chapter summarized the rationale for operator overloading and provided examples and explanations for overloading the various categories of operators. Ideally, this chapter taught you to appreciate the power that it gives you. Throughout this book, operator overloading is used to provide abstractions and easy-to-use class interfaces.
     </p>
     <p class="calibre13" id="c15-para-0315">
      Now it's time to start delving into the C++ Standard Library. The next chapter starts with an overview of the functionality provided by the C++ Standard Library, followed by chapters that go deeper into specific features of the library.
     </p>
    </section>
    <section aria-labelledby="head-2-183" class="calibre2">
     <span class="calibre" id="c15-sec-0064">
     </span>
     <h2 class="calibre6" id="head-2-183">
      EXERCISES
     </h2>
     <p class="calibre13" id="c15-para-0316">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c15-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c15-ex-0001">
        <b class="calibre14">
         Exercise 15-1:
        </b>
        Implement an
        <code class="calibre21">
         AssociativeArray
        </code>
        class template. The class should store a number of elements in a
        <code class="calibre21">
         vector
        </code>
        , where each element consists of a key and a value. The key is always a
        <code class="calibre21">
         string
        </code>
        , while the type of the value can be specified using a template type parameter. Provide overloaded subscripting operators so that elements can be retrieved based on their key. Test your implementation in your
        <code class="calibre21">
         main()
        </code>
        function. Note: this exercise is just to practice implementing subscripting operators using non-integral indices. In practice, you should just use the
        <code class="calibre21">
         std::map
        </code>
        class template provided by the Standard Library and discussed in
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        for such an associative array.
       </li>
       <li class="calibre9" id="c15-ex-0002">
        <b class="calibre14">
         Exercise 15-2:
        </b>
        Take your
        <code class="calibre21">
         Person
        </code>
        class implementation from Exercise 13-2 and add implementations of the insertion and extraction operators to it. Make sure that your extraction operator can read back what your insertion operator writes out.
       </li>
       <li class="calibre9" id="c15-ex-0003">
        <b class="calibre14">
         Exercise 15-3:
        </b>
        Add a
        <code class="calibre21">
         string
        </code>
        conversion operator to your solution of Exercise 15-2. The operator simply returns a
        <code class="calibre21">
         string
        </code>
        constructed from the first and last name of the person.
       </li>
       <li class="calibre9" id="c15-ex-0004">
        <b class="calibre14">
         Exercise 15-4:
        </b>
        Start from your solution of Exercise 15-3 and add a user-defined literal operator
        <code class="calibre21">
         _p
        </code>
        that constructs a
        <code class="calibre21">
         Person
        </code>
        from a string literal. It should support spaces in last names, but not in first names. For example,
        <code class="calibre21">
         "Peter Van Weert"_p
        </code>
        should result in a
        <code class="calibre21">
         Person
        </code>
        object with first name Peter and last name Van Weert.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
