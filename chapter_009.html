<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   1A Crash Course in C++ and the Standard Library
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_008.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_010.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c01_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c01_1">
      <span aria-label="3" class="calibre17" epub:type="pagebreak" id="Page_3" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c01">
      </span>
      <span class="calibre">
       1
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       A Crash Course in C++ and the Standard Library
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c01-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c01-list-0001">
         <li class="calibre9" id="c01-li-0001">
          A brief overview of the most important parts and syntax of the C++ language and the C++ Standard Library
         </li>
         <li class="calibre9" id="c01-li-0002">
          How to write a basic class
         </li>
         <li class="calibre9" id="c01-li-0003">
          How scope resolution works
         </li>
         <li class="calibre9" id="c01-li-0004">
          What uniform initialization is
         </li>
         <li class="calibre9" id="c01-li-0005">
          The use of
          <code class="calibre21">
           const
          </code>
         </li>
         <li class="calibre9" id="c01-li-0006">
          What pointers, references, exceptions, and type aliases are
         </li>
         <li class="calibre9" id="c01-li-0007">
          Basics of type inference
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c01-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-52">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <section class="calibre2">
         <span class="calibre" id="c01-sec-0003">
         </span>
         <p class="calibre25" id="c01-para-0004">
          Please note that all the code examples for this chapter are available as a part of the chapter's code download on this book's website at
          <code class="calibre21">
           <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
          on the Download Code tab.
         </p>
        </section>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c01-para-0005">
      The goal of this chapter is to cover briefly the most important parts of C++ so that you have a foundation of knowledge before embarking on the rest of this book. This chapter is not a comprehensive lesson in the C++ programming language or the Standard Library. Certain basic points, such as what a program is and what recursion is, are not covered. Esoteric points, such as the definition of a
      <code class="calibre21">
       union
      </code>
      , or the
      <code class="calibre21">
       volatile
      </code>
      keyword, are also omitted. Certain parts of the C language that are less relevant in C++ are also left out, as are parts of C++ that get in-depth coverage in later chapters.
     </p>
     <p class="calibre13" id="c01-para-0006">
      <span aria-label="4" class="calibre20" epub:type="pagebreak" id="Page_4" role="doc-pagebreak">
      </span>
      This chapter aims to cover the parts of C++ that programmers encounter every day. For example, if you're fairly new to C++ and don't understand what a reference variable is, you'll learn about that kind of variable here. You'll also learn the basics of how to use the functionality available in the Standard Library, such as
      <code class="calibre21">
       vector
      </code>
      containers,
      <code class="calibre21">
       optional
      </code>
      values,
      <code class="calibre21">
       string
      </code>
      objects, and more. These modern constructs from the Standard Library are briefly introduced in this chapter so that they can be used throughout examples in this book from the beginning.
     </p>
     <p class="calibre13" id="c01-para-0007">
      If you already have significant experience with C++, skim this chapter to make sure that there aren't any fundamental parts of the language on which you need to brush up. If you're new to C++, read this chapter carefully and make sure you understand the examples. If you need additional introductory information, consult the titles listed in
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography.”
     </p>
    </section>
    <section aria-labelledby="head-2-53" class="calibre2">
     <span class="calibre" id="c01-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-53">
      C++ CRASH COURSE
     </h2>
     <p class="calibre13" id="c01-para-0008">
      The C++ language is often viewed as a “better C” or a “superset of C.” It was mainly designed to be an object-oriented C, commonly called as “C with classes.” Later on, many of the annoyances and rough edges of the C language were addressed as well. Because C++ is based on C, some of the syntax you'll see in this section will look familiar to you if you are an experienced C programmer. The two languages certainly have their differences, though. As evidence, the C23 standard specification document is a little fewer than 800 pages in size, while the C++23 standard specification document is more than 2,000 pages. So, if you're a C programmer but also if you are coming from other languages such as Java, C#, Python, and so on, be on the lookout for new or unfamiliar syntax!
     </p>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-61">
       The Obligatory “Hello, World” Program
      </h3>
      <p class="calibre13">
       In all its glory, the following code is the simplest C++ program you're likely to encounter. If you are using an older version of C++, then
       <code class="calibre21">
        import std;
       </code>
       and
       <code class="calibre21">
        std::println()
       </code>
       might not work. In that case, you'll need to use alternatives discussed shortly.
      </p>
      <pre class="calibre26" id="c01-code-0001"><code class="calibre21"><span class="color">// 01_helloworld.cpp</span></code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::println("Hello, World!"); </code>
<code class="calibre21">    return 0;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This code, as you might expect, prints the message “Hello, World!” on the screen. It is a simple program and unlikely to win any awards, but it does exhibit the following important concepts about the format of a C++ program:
      </p>
      <ul class="check" id="c01-list-0002">
       <li class="calibre9" id="c01-li-0008">
        Comments
       </li>
       <li class="calibre9" id="c01-li-0009">
        Importing modules
       </li>
       <li class="calibre9" id="c01-li-0010">
        The
        <code class="calibre21">
         main()
        </code>
        function
       </li>
       <li class="calibre9" id="c01-li-0011">
        Printing text
       </li>
       <li class="calibre9" id="c01-li-0012">
        Returning from a function
       </li>
      </ul>
      <p class="calibre13" id="c01-para-0011">
       These concepts are briefly explained in upcoming sections.
      </p>
      <span aria-label="5" class="calibre20" epub:type="pagebreak" id="Page_5" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0006">
       </span>
       <h4 class="calibre29" id="head-4-7">
        Comments
       </h4>
       <p class="calibre13">
        The first line of the program is a
        <i class="calibre18">
         comment
        </i>
        , a message that exists for the programmer only and is ignored by the compiler. In C++, there are two ways to delineate a comment. You can use two forward slashes to indicate that whatever follows on that line is a comment:
       </p>
       <pre class="calibre26" id="c01-code-0002"><code class="calibre21"><span class="color">// 01_helloworld.cpp</span></code></pre>
       <p class="calibre13">
        The same behavior (this is to say, none) can be achieved by using a
        <i class="calibre18">
         multiline comment
        </i>
        . Multiline comments start with
        <code class="calibre21">
         /*
        </code>
        and end with
        <code class="calibre21">
         */
        </code>
        . The following code shows a multiline comment in action (or, more appropriately, inaction):
       </p>
       <pre class="calibre26" id="c01-code-0003"><code class="calibre21"><span class="color">/* This is a multiline comment.</span></code>
<code class="calibre21">   <span class="color">The compiler will ignore it.</span></code>
<code class="calibre21"> <span class="color">*/</span></code></pre>
       <p class="calibre13" id="c01-para-0014">
        Comments are covered in detail in
        <a class="calibre5" href="c03.xhtml">
         Chapter 3
        </a>
        , “Coding with Style.”
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0007">
       </span>
       <h4 class="calibre29" id="head-4-8">
        Importing Modules
       </h4>
       <p class="calibre13">
        Support for
        <i class="calibre18">
         modules
        </i>
        was one of the big four new features of C++20, replacing the old mechanism of
        <i class="calibre18">
         header files
        </i>
        . If you want to use functionality from a module, you simply import that module. This is done with an
        <code class="calibre21">
         import
        </code>
        declaration. Starting with C++23, you can get access to the entire C++ Standard Library by importing a single
        <i class="calibre18">
         standard named module
        </i>
        called
        <code class="calibre21">
         std
        </code>
        . The first line of the “Hello, World” application imports this standard module:
       </p>
       <pre class="calibre26" id="c01-code-0004"><code class="calibre21">import std;</code></pre>
       <p class="calibre13" id="c01-para-0016">
        If the program did not import that module, it would be unable to perform its only task of printing text.
       </p>
       <p class="calibre13">
        Without C++23's standard named module support, you have to explicitly import all individual header files that your code requires. As there are more than 100 header files in the Standard Library, it's not always obvious to know which specific header you need to import to use a certain feature. As a reference,
        <a class="calibre5" href="b03.xhtml">
         Appendix C
        </a>
        , “Standard Library Header Files,” lists all header files of the C++ Standard Library including a short description of their contents. For example, instead of importing the standard named module
        <code class="calibre21">
         std
        </code>
        in the “Hello, World” application, you can import only those header files that the code really needs. In this example, the code only needs to import
        <code class="calibre21">
         &lt;print&gt;
        </code>
        to get access to the text printing functionality. Notice that when importing the named module
        <code class="calibre21">
         std
        </code>
        , you don't use angle brackets, but when importing individual header files, you need to use angle brackets as follows:
       </p>
       <pre class="calibre26" id="c01-code-0005"><code class="calibre21">import &lt;print&gt;;</code></pre>
       <p class="calibre13" id="c01-para-0018">
        Since this is a book about C++23, this book uses modules everywhere. All functionality provided by the C++ Standard Library is provided in well-defined header files. Most examples in this book simply import the
        <code class="calibre21">
         std
        </code>
        named module, instead of individual header files, but the text always mentions in which header file certain functionality is provided.
       </p>
       <p class="calibre13">
        Modules are not limited to Standard Library functionality. You can write your own modules to provide custom types and functionality, as you will learn throughout this book.
        <span aria-label="6" class="calibre20" epub:type="pagebreak" id="Page_6" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0020">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            If your compiler does not yet have full support for modules, you can replace explicit header file
           </i>
           <code class="calibre21">
            import
           </code>
           <i class="calibre18">
            declarations with
           </i>
           <code class="calibre21">
            #include
           </code>
           <i class="calibre18">
            preprocessor directives, discussed in an upcoming section.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0009">
       </span>
       <h4 class="calibre29" id="head-4-9">
        How the Compiler Processes Your Source Code
       </h4>
       <p class="calibre13">
        In short, building a C++ program is a three-step process. Technically, there are a few more phases in the compilation process, but this simplified view is sufficient for now.
       </p>
       <ol class="calibre7" id="c01-list-0003">
        <li class="calibre9" id="c01-li-0013">
         First, the code is run through a
         <i class="calibre18">
          preprocessor
         </i>
         , which recognizes meta-information about the code and handles preprocessor directives, such as
         <code class="calibre21">
          #include
         </code>
         directives. A source file in which all preprocessor directives are handled is called a
         <i class="calibre18">
          translation unit
         </i>
         .
        </li>
        <li class="calibre9" id="c01-li-0014">
         Next, all translation units are independently
         <i class="calibre18">
          compiled
         </i>
         , or translated, into machine-readable
         <i class="calibre18">
          object files
         </i>
         in which references to functions and so on are not yet defined.
        </li>
        <li class="calibre9" id="c01-li-0015">
         Resolving those references is done in the final phase by the
         <i class="calibre18">
          linker
         </i>
         , which links all object files together into the final
         <i class="calibre18">
          executable
         </i>
         .
        </li>
       </ol>
       <p class="calibre13" id="c01-para-1001">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0023">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Starting with C++23, the standard mandates that C++ compilers accept source code files saved with UTF-8 encoding.
            <a class="calibre5" href="c21.xhtml">
             Chapter 21
            </a>
            , “String Localization and Regular Expressions,” discusses different encodings, including UTF-8. I recommend configuring your toolchain to use UTF-8. This will improve portability of your files between different platforms and will allow you to use non-English characters in your source files
           </i>
           .
          </p>
          <p class="calibre25" id="c01-para-0024">
           <i class="calibre18">
            To enable UTF-8 support with Microsoft Visual C++, add the
           </i>
           <code class="calibre21">
            /utf-8
           </code>
           <i class="calibre18">
            option to the Additional Options setting under Project Properties ➪ Configuration Properties
           </i>
           ➪ C/C++ ➪
           <i class="calibre18">
            Command Line. For GCC, use the command-line option
           </i>
           <code class="calibre21">
            -finput-charset=UTF-8
           </code>
           <i class="calibre18">
            . Clang assumes all files are UTF-8 by default
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-10">
        Preprocessor Directives
       </h4>
       <p class="calibre13">
        If your compiler does not yet support modules, then instead of importing modules or header files, you need to
        <code class="calibre21">
         #include
        </code>
        header files. That is, explicit
        <code class="calibre21">
         import
        </code>
        declarations such as
        <code class="calibre21">
         import &lt;print&gt;;
        </code>
        , need to be replaced with
        <code class="calibre21">
         #include
        </code>
        preprocessor directives as follows:
       </p>
       <pre class="calibre26" id="c01-code-0006"><code class="calibre21">#include &lt;print&gt;</code></pre>
       <p class="calibre13" id="c01-para-0026">
        Directives aimed at the preprocessor start with the
        <code class="calibre21">
         #
        </code>
        character, as in
        <code class="calibre21">
         #include &lt;print&gt;
        </code>
        . In this case, the
        <code class="calibre21">
         #include
        </code>
        directive tells the preprocessor to take everything from the
        <code class="calibre21">
         &lt;print&gt;
        </code>
        header file and copy it into the current file. The
        <code class="calibre21">
         &lt;print&gt;
        </code>
        header provides the functionality to print text to the screen.
       </p>
       <p class="calibre13" id="c01-para-0027">
        <a class="calibre5" href="c11.xhtml">
         Chapter 11
        </a>
        , “Modules, Header Files, and Miscellaneous Topics,” discusses preprocessor directives in a bit more detail. But, as mentioned, this book uses modules instead of old-style header files.
       </p>
      </section>
      <span aria-label="7" class="calibre20" epub:type="pagebreak" id="Page_7" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0012">
       </span>
       <h4 class="calibre29" id="head-4-11">
        The main() Function
       </h4>
       <p class="calibre13">
        <code class="calibre21">
         main()
        </code>
        is, of course, where the program starts. The return type of
        <code class="calibre21">
         main()
        </code>
        is an
        <code class="calibre21">
         int
        </code>
        , indicating the result status of the program. The
        <code class="calibre21">
         main()
        </code>
        function either takes no parameters or takes two parameters as follows:
       </p>
       <pre class="calibre26" id="c01-code-0007"><code class="calibre21">int main(int argc, char** argv)</code></pre>
       <p class="calibre13" id="c01-para-0029">
        <code class="calibre21">
         argc
        </code>
        gives the number of arguments passed to the program, and
        <code class="calibre21">
         argv
        </code>
        contains those arguments. Note that
        <code class="calibre21">
         argv[0]
        </code>
        can be the program name, but it might as well be an empty string, so do not rely on it; instead, use platform-specific functionality to retrieve the program name. The important thing to remember is that the actual arguments contained in
        <code class="calibre21">
         argv
        </code>
        start at index 1.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0013">
       </span>
       <h4 class="calibre29" id="head-4-12">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        Printing Text
       </h4>
       <p class="calibre13" id="c01-para-0031">
        Before C++23, you would use
        <i class="calibre18">
         I/O streams
        </i>
        to output text to the screen. Streams are briefly covered in the next section and in detail in
        <a class="calibre5" href="c13.xhtml">
         Chapter 13
        </a>
        , “Demystifying C++ I/O.” However, C++23 introduces a new, easier-to-use mechanism to print text to the screen, which is used in almost every code snippet in this book:
        <code class="calibre21">
         std::print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        , both defined in
        <code class="calibre21">
         &lt;print&gt;
        </code>
        .
       </p>
       <p class="calibre13">
        <a class="calibre5" href="c02.xhtml">
         Chapter 2
        </a>
        , “Working with Strings and String Views,” discusses the
        <code class="calibre21">
         std::print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        string formatting and printing functions in detail. However, their basic use is straightforward and introduced here so that they can already be used in upcoming code snippets. In its most basic form,
        <code class="calibre21">
         println()
        </code>
        can be used to print a line of text that automatically ends with a new line:
       </p>
       <pre class="calibre26" id="c01-code-0008"><code class="calibre21">std::println("Hello, World!"); </code></pre>
       <p class="calibre13">
        The first argument to
        <code class="calibre21">
         println()
        </code>
        is a format string, which can contain replacement fields to be replaced with values passed in as second and subsequent arguments. You indicate where a replacement field goes by including curly brackets,
        <code class="calibre21">
         {}
        </code>
        , for each field to be included. For example:
       </p>
       <pre class="calibre26" id="c01-code-0009"><code class="calibre21">std::println("There are {} ways I love you.", 219);</code></pre>
       <p class="calibre13">
        In this example, the number 219 is inserted into the string, so the output is:
       </p>
       <pre class="calibre26" id="c01-code-0010"><code class="calibre21">There are 219 ways I love you.</code></pre>
       <p class="calibre13">
        You can have as many replacement fields as needed, for example:
       </p>
       <pre class="calibre26" id="c01-code-0011"><code class="calibre21">std::println("{} + {} = {}", 2, 4, 6);</code></pre>
       <p class="calibre13">
        In this example, each field is applied in order, so the resulting output is:
       </p>
       <pre class="calibre26" id="c01-code-0012"><code class="calibre21">2 + 4 = 6</code></pre>
       <p class="calibre13" id="c01-para-0037">
        There is much more to be said about the format of replacement fields, but that's for
        <a class="calibre5" href="c02.xhtml">
         Chapter 2
        </a>
        .
       </p>
       <p class="calibre13" id="c01-para-0038">
        If you use
        <code class="calibre21">
         print()
        </code>
        instead of
        <code class="calibre21">
         println()
        </code>
        , the printed text will not end with a new line character.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0014">
       </span>
       <h4 class="calibre29" id="head-4-13">
        I/O Streams
       </h4>
       <p class="calibre13" id="c01-para-0039">
        If your compiler does not yet support the C++23
        <code class="calibre21">
         std::print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        functions, you have to rewrite them using I/O streams.
       </p>
       <p class="calibre13">
        <i class="calibre18">
         I/O streams
        </i>
        are covered in depth in
        <a class="calibre5" href="c13.xhtml">
         Chapter 13
        </a>
        , but the basics of output and input are simple. Think of an output stream as a laundry chute for data. Anything you toss into it will be output appropriately.
        <code class="calibre21">
         std::cout
        </code>
        is the chute corresponding to the user console, or
        <i class="calibre18">
         standard out
        </i>
        . There are other
        <span aria-label="8" class="calibre20" epub:type="pagebreak" id="Page_8" role="doc-pagebreak">
        </span>
        chutes, including
        <code class="calibre21">
         std::cerr
        </code>
        , which outputs to the error console. The
        <code class="calibre21">
         &lt;&lt;
        </code>
        operator tosses data down the chute. Output streams allow multiple types of data to be sent down the stream sequentially on a single line of code. The following code outputs text, followed by a number, followed by more text:
       </p>
       <pre class="calibre26" id="c01-code-0013"><code class="calibre21">std::cout &lt;&lt; "There are " &lt;&lt; 219 &lt;&lt; " ways I love you." &lt;&lt; std::endl;</code></pre>
       <p class="calibre13">
        Starting with C++20, though, it is recommended to use
        <code class="calibre21">
         std::format()
        </code>
        , defined in
        <code class="calibre21">
         &lt;format&gt;
        </code>
        , to perform string formatting. The
        <code class="calibre21">
         format()
        </code>
        function uses the same concept of replacement fields as
        <code class="calibre21">
         print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        and is discussed in detail in
        <a class="calibre5" href="c02.xhtml">
         Chapter 2
        </a>
        . However, using it to rewrite the previous statement is easy enough:
       </p>
       <pre class="calibre26" id="c01-code-0014"><code class="calibre21">std::cout &lt;&lt; <b class="calibre14">std::format("There are {} ways I love you.", 219)</b> &lt;&lt; std::endl;</code></pre>
       <p class="calibre13">
        Thus, if your compiler doesn't support
        <code class="calibre21">
         print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        yet, you can easily rewrite such statements to use
        <code class="calibre21">
         cout
        </code>
        ,
        <code class="calibre21">
         format()
        </code>
        , and
        <code class="calibre21">
         endl
        </code>
        . For example, suppose you have the following statement:
       </p>
       <pre class="calibre26" id="c01-code-0015"><code class="calibre21">std::println("{} + {} = {}", 2, 4, 6);</code></pre>
       <p class="calibre13">
        In this statement, replace
        <code class="calibre21">
         println()
        </code>
        with
        <code class="calibre21">
         format()
        </code>
        , stream the result to
        <code class="calibre21">
         cout
        </code>
        , and add an output of
        <code class="calibre21">
         endl
        </code>
        :
       </p>
       <pre class="calibre26" id="c01-code-0016"><code class="calibre21"><b class="calibre14">std::cout &lt;&lt; std::format</b>("{} + {} = {}", 2, 4, 6) <b class="calibre14">&lt;&lt; std::endl</b>;</code></pre>
       <p class="calibre13" id="c01-para-0044">
        <code class="calibre21">
         std::endl
        </code>
        represents an end-of-line sequence. When the output stream encounters
        <code class="calibre21">
         std::endl
        </code>
        , it will output everything that has been sent down the chute so far and move to the next line. An alternate way of representing the end of a line is by using the
        <code class="calibre21">
         \n
        </code>
        character. The
        <code class="calibre21">
         \n
        </code>
        character is an
        <i class="calibre18">
         escape sequence
        </i>
        , which refers to a new-line character. Escape sequences can be used within any quoted string of text. The following table shows the most common ones:
       </p>
       <table border="1" class="calibre31">
        <thead class="calibre32">
         <tr class="calibre33">
          <th class="left" scope="col">
           ESCAPE SEQUENCE
          </th>
          <th class="left" scope="col">
           MEANING
          </th>
         </tr>
        </thead>
        <tbody class="calibre34">
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            \n
           </code>
          </td>
          <td class="left1">
           New line: moves the cursor to the beginning of the next line
          </td>
         </tr>
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            \r
           </code>
          </td>
          <td class="left1">
           Carriage return: moves the cursor to the beginning of the current line, but does not advance to the next line
          </td>
         </tr>
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            \t
           </code>
          </td>
          <td class="left1">
           Tab
          </td>
         </tr>
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            \\
           </code>
          </td>
          <td class="left1">
           Backslash character
          </td>
         </tr>
         <tr class="calibre33">
          <td class="left1">
           <code class="calibre21">
            \"
           </code>
          </td>
          <td class="left1">
           Quotation mark
          </td>
         </tr>
        </tbody>
       </table>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0046">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Keep in mind that
           </i>
           <code class="calibre21">
            endl
           </code>
           <i class="calibre18">
            inserts a new line into the stream and flushes everything currently in its buffers down the chute. Overusing
           </i>
           <code class="calibre21">
            endl
           </code>
           <i class="calibre18">
            , for example in a loop, is not recommended because it will have a performance impact. On the other hand, inserting
           </i>
           <code class="calibre21">
            \n
           </code>
           <i class="calibre18">
            into the stream also inserts a new line but does not automatically flush the buffers.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        By default,
        <code class="calibre21">
         print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        print text to the standard output console,
        <code class="calibre21">
         std::cout
        </code>
        . You can print to the error console,
        <code class="calibre21">
         std::cerr
        </code>
        , as follows:
       </p>
       <pre class="calibre26" id="c01-code-0017"><code class="calibre21">std::println(<b class="calibre14">std::cerr,</b> "Error: {}", 6);</code></pre>
       <p class="calibre13">
        <span aria-label="9" class="calibre20" epub:type="pagebreak" id="Page_9" role="doc-pagebreak">
        </span>
        Streams can also be used to accept input from the user. The simplest way to do so is to use the
        <code class="calibre21">
         &gt;&gt;
        </code>
        operator with an input stream. The
        <code class="calibre21">
         std::cin
        </code>
        input stream accepts keyboard input from the user. Here is an example:
       </p>
       <pre class="calibre26" id="c01-code-0018"><code class="calibre21">import std;</code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    int value;</code>
<code class="calibre21">    std::cin &gt;&gt; value;</code>
<code class="calibre21">    std::println("You entered {}", value);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0049">
        The
        <code class="calibre21">
         &gt;&gt;
        </code>
        operator stops input when it encounters a space character after reading a value. That also means you cannot use the operator to read text containing spaces. Additionally, user input can be tricky because you never know what kind of data the user will enter.
        <a class="calibre5" href="c13.xhtml">
         Chapter 13
        </a>
        discusses input streams in detail, including how to read text with embedded spaces.
       </p>
       <p class="calibre13" id="c01-para-0050">
        If you're new to C++ and coming from a C background, you're probably wondering what has been done with the trusty old
        <code class="calibre21">
         printf()
        </code>
        and
        <code class="calibre21">
         scanf()
        </code>
        functions. While these functions can still be used in C++, I strongly recommend using the modern
        <code class="calibre21">
         print()
        </code>
        ,
        <code class="calibre21">
         println()
        </code>
        , and
        <code class="calibre21">
         format()
        </code>
        functions and the streams library instead, mainly because the
        <code class="calibre21">
         printf()
        </code>
        and
        <code class="calibre21">
         scanf()
        </code>
        family of functions do not provide any type safety.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-14">
        Returning from a Function
       </h4>
       <p class="calibre13">
        The last line in the “Hello, World” program is as follows:
       </p>
       <pre class="calibre26" id="c01-code-0019"><code class="calibre21">    return 0;</code></pre>
       <p class="calibre13" id="c01-para-0052">
        Since this is the
        <code class="calibre21">
         main()
        </code>
        function, returning from it returns control to the operating system. When doing so, it passes the value 0, which usually signals to the operating system that there were no errors while executing the program. For error cases, you can return non-zero values.
       </p>
       <p class="calibre13" id="c01-para-0053">
        A
        <code class="calibre21">
         return
        </code>
        statement in
        <code class="calibre21">
         main()
        </code>
        is optional. If you don't write one, the compiler will implicitly add a
        <code class="calibre21">
         return 0;
        </code>
        for you.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-62">
       Namespaces
      </h3>
      <p class="calibre13" id="c01-para-0054">
       <i class="calibre18">
        Namespaces
       </i>
       address the problem of naming conflicts between different pieces of code. For example, you might be writing some code that has a function called
       <code class="calibre21">
        foo()
       </code>
       . One day, you decide to start using a third-party library, which also has a
       <code class="calibre21">
        foo()
       </code>
       function. The compiler has no way of knowing which version of
       <code class="calibre21">
        foo()
       </code>
       you are referring to within your code. You can't change the library's function name, and it would be a big pain to change your own.
      </p>
      <p class="calibre13">
       Namespaces come to the rescue in such scenarios because you can define the context in which names are defined. To place code in a namespace, enclose it within a namespace block. Here's an example:
      </p>
      <pre class="calibre26" id="c01-code-0020"><code class="calibre21">namespace mycode {</code>
<code class="calibre21">    void foo()</code>
<code class="calibre21">    {</code>
<code class="calibre21">        std::println("foo() called in the mycode namespace");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <span aria-label="10" class="calibre20" epub:type="pagebreak" id="Page_10" role="doc-pagebreak">
       </span>
       By placing your version of
       <code class="calibre21">
        foo()
       </code>
       in the namespace
       <code class="calibre21">
        mycode
       </code>
       , you are isolating it from the
       <code class="calibre21">
        foo()
       </code>
       function provided by the third-party library. To call the namespace-enabled version of
       <code class="calibre21">
        foo()
       </code>
       , prepend the namespace onto the function name by using
       <code class="calibre21">
        ::
       </code>
       , also called the
       <i class="calibre18">
        scope resolution operator
       </i>
       , as follows:
      </p>
      <pre class="calibre26" id="c01-code-0021"><code class="calibre21">mycode::foo();    <span class="color">// Calls the "foo" function in the "mycode" namespace</span></code></pre>
      <p class="calibre13">
       Any code that falls within a
       <code class="calibre21">
        mycode
       </code>
       namespace block can call other code within the same namespace without explicitly prepending the namespace. This implicit namespace is useful in making the code more readable. You can also avoid prepending of namespaces with a
       <code class="calibre21">
        using
       </code>
       <i class="calibre18">
        directive
       </i>
       . This directive tells the compiler that the subsequent code is making use of names in the specified namespace. The namespace is thus implied for the code that follows:
      </p>
      <pre class="calibre26" id="c01-code-0022"><code class="calibre21">using namespace mycode;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    foo();  <span class="color">// Implies mycode::foo();</span></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0059">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The
          </i>
          <code class="calibre21">
           main()
          </code>
          <i class="calibre18">
           function must never be put in a namespace. It must be in the global namespace.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c01-para-0060">
       A single source file can contain multiple
       <code class="calibre21">
        using
       </code>
       directives, but beware of overusing this shortcut. In the extreme case, if you declare that you're using every namespace known to humanity, you're effectively eliminating namespaces entirely! Name conflicts will again result if you are using two namespaces that contain the same names. It is also important to know in which namespace your code is operating so that you don't end up accidentally calling the wrong version of a function.
      </p>
      <p class="calibre13">
       You've seen the namespace syntax before—you used it in the “Hello, World” program, where
       <code class="calibre21">
        println
       </code>
       is a name defined in the
       <code class="calibre21">
        std
       </code>
       namespace. You can write “Hello, World” with a
       <code class="calibre21">
        using
       </code>
       directive as shown here:
      </p>
      <pre class="calibre26" id="c01-code-0023"><code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">using namespace std;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">println(</b>"<b class="calibre14">Hello, World!</b>"<b class="calibre14">);</b></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0063">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Most code snippets in this book assume a
           <code class="calibre21">
            using
           </code>
           directive for the
          </i>
          <code class="calibre21">
           std
          </code>
          <i class="calibre18">
           namespace so that everything from the C++ Standard Library can be used without the need to qualify it with
          </i>
          <code class="calibre21">
           std::
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       A
       <code class="calibre21">
        using
       </code>
       <i class="calibre18">
        declaration
       </i>
       can be used to refer to a particular item within a namespace. For example, if the only part of the
       <code class="calibre21">
        std
       </code>
       namespace that you want to use unqualified is
       <code class="calibre21">
        print
       </code>
       , you can use the following
       <code class="calibre21">
        using
       </code>
       declaration:
      </p>
      <pre class="calibre26" id="c01-code-0024"><code class="calibre21">using std::print;</code></pre>
      <p class="calibre13">
       <span aria-label="11" class="calibre20" epub:type="pagebreak" id="Page_11" role="doc-pagebreak">
       </span>
       Subsequent code can refer to
       <code class="calibre21">
        print
       </code>
       without prepending the namespace, but other items in the
       <code class="calibre21">
        std
       </code>
       namespace, such as
       <code class="calibre21">
        println
       </code>
       , still need to be explicit:
      </p>
      <pre class="calibre26" id="c01-code-0025"><code class="calibre21">using std::print;</code>
<code class="calibre21"><b class="calibre14">print("Hello, ");</b></code>
<code class="calibre21"><b class="calibre14">std::println("World!");</b></code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0067">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Never put a
           <code class="calibre21">
            using
           </code>
           directive or
           <code class="calibre21">
            using
           </code>
           declaration in a header file at global scope; otherwise, you force it on everyone who includes your header file. Putting it in a smaller scope, for instance at namespace or class scope, is OK, even in a header file. It's also perfectly fine to put a
          </i>
          <code class="calibre21">
           using
          </code>
          <i class="calibre18">
           directive or declaration in a module interface file, as long as you don't export it. However, this book always fully qualifies all types in module interface files, as I think it makes it easier to understand an interface. Module interface files and exporting entities from modules are explained later in this chapter.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0021">
       </span>
       <h4 class="calibre29" id="head-4-15">
        Nested Namespace
       </h4>
       <p class="calibre13">
        A
        <i class="calibre18">
         nested namespace
        </i>
        is a namespace inside another one. Each namespace is separated by a double colon. Here's an example:
       </p>
       <pre class="calibre26" id="c01-code-0026"><code class="calibre21">namespace MyLibraries::Networking::FTP {</code>
<code class="calibre21">    <span class="color">/* … */</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        This compact syntax was not available before C++17 in which case you had to resort to the following:
       </p>
       <pre class="calibre26" id="c01-code-0027"><code class="calibre21">namespace MyLibraries {</code>
<code class="calibre21">    namespace Networking {</code>
<code class="calibre21">        namespace FTP {</code>
<code class="calibre21">            <span class="color">/* … */</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0022">
       </span>
       <h4 class="calibre29" id="head-4-16">
        Namespace Alias
       </h4>
       <p class="calibre13">
        A
        <i class="calibre18">
         namespace alias
        </i>
        can be used to give a new and possibly shorter name to another namespace. Here's an example:
       </p>
       <pre class="calibre26" id="c01-code-0028"><code class="calibre21">namespace MyFTP = MyLibraries::Networking::FTP;</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0023">
      </span>
      <h3 class="calibre27" id="head-3-63">
       Literals
      </h3>
      <p class="calibre13">
       Literals are used to write numbers or strings in your code. C++ supports a couple of standard literals. Integral numbers can be written using the following literals (the examples represent the same number, 123):
      </p>
      <ul class="check" id="c01-list-0004">
       <li class="calibre9" id="c01-li-0016">
        Decimal literal,
        <code class="calibre21">
         123
        </code>
       </li>
       <li class="calibre9" id="c01-li-0017">
        Octal literal,
        <code class="calibre21">
         0173
        </code>
        (starts with a zero)
       </li>
       <li class="calibre9" id="c01-li-0018">
        <span aria-label="12" class="calibre20" epub:type="pagebreak" id="Page_12" role="doc-pagebreak">
        </span>
        Hexadecimal literal,
        <code class="calibre21">
         0x7B
        </code>
        (starts with 0x)
       </li>
       <li class="calibre9" id="c01-li-0019">
        Binary literal,
        <code class="calibre21">
         0b1111011
        </code>
        (starts with 0b)
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0073">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Never put a zero,
          </i>
          <code class="calibre21">
           0
          </code>
          <i class="calibre18">
           , in front of a numerical literal, unless it's an octal literal!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Other examples of literals in C++ include the following:
      </p>
      <ul class="check" id="c01-list-0005">
       <li class="calibre9" id="c01-li-0020">
        A floating-point value (such as
        <code class="calibre21">
         3.14f
        </code>
        )
       </li>
       <li class="calibre9" id="c01-li-0021">
        A double floating-point value (such as
        <code class="calibre21">
         3.14
        </code>
        )
       </li>
       <li class="calibre9" id="c01-li-0022">
        A hexadecimal floating-point literal (such as
        <code class="calibre21">
         0x3.ABCp-10
        </code>
        and
        <code class="calibre21">
         0Xb.cp12l
        </code>
        )
       </li>
       <li class="calibre9" id="c01-li-0023">
        A single character (such as
        <code class="calibre21">
         'a'
        </code>
        )
       </li>
       <li class="calibre9" id="c01-li-0024">
        A zero-terminated array of characters (such as
        <code class="calibre21">
         "character array"
        </code>
        )
       </li>
      </ul>
      <p class="calibre13" id="c01-para-0075">
       A literal can have a suffix, such as the
       <code class="calibre21">
        f
       </code>
       in
       <code class="calibre21">
        3.14f
       </code>
       , to force a certain type. In this case,
       <code class="calibre21">
        3.14f
       </code>
       results in a
       <code class="calibre21">
        float
       </code>
       , while
       <code class="calibre21">
        3.14
       </code>
       results in a
       <code class="calibre21">
        double
       </code>
       .
      </p>
      <p class="calibre13">
       Single quote characters can be used as digit separators in numeric literals. For example:
      </p>
      <ul class="check" id="c01-list-0006">
       <li class="calibre9" id="c01-li-0025">
        <code class="calibre21">
         23'456'789
        </code>
       </li>
       <li class="calibre9" id="c01-li-0026">
        <code class="calibre21">
         2'34'56'789
        </code>
       </li>
       <li class="calibre9" id="c01-li-0027">
        <code class="calibre21">
         0.123'456f
        </code>
       </li>
      </ul>
      <p class="calibre13">
       Multiple string literals separated only by whitespace are automatically concatenated into a single string. For example:
      </p>
      <pre class="calibre26" id="c01-code-0029"><code class="calibre21">    std::println("Hello, "</code>
<code class="calibre21">                 "World!"); </code></pre>
      <p class="calibre13">
       is equivalent to:
      </p>
      <pre class="calibre26" id="c01-code-0030"><code class="calibre21">    std::println("Hello, World!"); </code></pre>
      <p class="calibre13" id="c01-para-0079">
       It is also possible to define your own type of literals, which is an advanced feature explained in
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       , “Overloading C++ Operators.”
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0025">
      </span>
      <h3 class="calibre27" id="head-3-64">
       Variables
      </h3>
      <p class="calibre13">
       In C++,
       <i class="calibre18">
        variables
       </i>
       can be declared just about anywhere in your code and can be used anywhere in the current block below the line where they are declared. Variables can be declared without being given a value. These uninitialized variables generally end up with a semi-random value based on whatever is in memory at that time, and they are therefore the source of countless bugs. Variables in C++ can alternatively be assigned an initial value when they are declared. The code that follows shows both flavors of variable declaration, both using
       <code class="calibre21">
        int
       </code>
       s, which represent integer values:
      </p>
      <pre class="calibre26" id="c01-code-0031"><code class="calibre21">int uninitializedInt;</code>
<code class="calibre21">int initializedInt { 7 };</code>
<span aria-label="13" class="calibre20" epub:type="pagebreak" id="Page_13" role="doc-pagebreak"></span><code class="calibre21">println("{} is a random value", uninitializedInt);</code>
<code class="calibre21">println("{} was assigned as an initial value", initializedInt);</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0082">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Most compilers will issue a warning or an error when code is using uninitialized variables. Some compilers will generate code that will report an error at run time
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       The
       <code class="calibre21">
        initializedInt
       </code>
       variable is initialized using the
       <i class="calibre18">
        uniform initialization
       </i>
       syntax. You can also use the following assignment syntax for initializing variables:
      </p>
      <pre class="calibre26" id="c01-code-0032"><code class="calibre21">int initializedInt = 7;</code></pre>
      <p class="calibre13" id="c01-para-0084">
       Uniform initialization was introduced with the C++11 standard in 2011. It is recommended to use uniform initialization instead of the old assignment syntax, so that's the syntax used in this book. The section “
       <a class="calibre5" href="c01_split_001.xhtml#c01-sec-0085">
        Uniform Initialization
       </a>
       ” later in this chapter goes deeper in on the benefits and why it is recommended.
      </p>
      <p class="calibre13" id="c01-para-0085">
       Variables in C++ are strongly typed; that is, they always have a specific type. C++ comes with a whole set of built-in types that you can use out of the box. The following table shows the most common types:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          TYPE
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
         <th class="left" scope="col">
          USAGE
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0033"><code class="calibre21">(signed) int</code>
<code class="calibre21">signed</code></pre>
         </td>
         <td class="left1">
          Positive and negative integers; the range depends on the compiler (usually 4 bytes)
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0034"><code class="calibre21">int i {-7};</code>
<code class="calibre21">signed int i {-6};</code>
<code class="calibre21">signed i {-5};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0035"><code class="calibre21">(signed) short (int)</code></pre>
         </td>
         <td class="left1">
          Short integer (usually 2 bytes)
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0036"><code class="calibre21">short s {13};</code>
<code class="calibre21">short int s {14};</code>
<code class="calibre21">signed short s {15};</code>
<code class="calibre21">signed short int s {16};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0037"><code class="calibre21">(signed) long (int)</code></pre>
         </td>
         <td class="left1">
          Long integer (usually 4 bytes)
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0038"><code class="calibre21">long l {-7L};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0039"><code class="calibre21">(signed) long long (int)</code></pre>
         </td>
         <td class="left1">
          Long long integer; the range depends on the compiler but is at least the same as for
          <code class="calibre21">
           long
          </code>
          (usually 8 bytes)
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0040"><code class="calibre21">long long ll {14LL};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0041"><code class="calibre21">unsigned (int)</code>
<code class="calibre21">unsigned short (int)</code>
<code class="calibre21">unsigned long (int)</code>
<code class="calibre21">unsigned long long (int)</code></pre>
         </td>
         <td class="left1">
          Limits the preceding types to values &gt;= 0
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0042"><code class="calibre21">unsigned int i {2U};</code>
<code class="calibre21">unsigned j {5U};</code>
<code class="calibre21">unsigned short s {23U};</code>
<code class="calibre21">unsigned long l {54UL};</code>
<code class="calibre21">unsigned long long ll</code>
<code class="calibre21">    {140ULL};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0043"><code class="calibre21">float</code></pre>
         </td>
         <td class="left1">
          Single precision floating-point numbers
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0044"><code class="calibre21">float f {7.2f};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0045"><code class="calibre21">double</code></pre>
         </td>
         <td class="left1">
          Double precision floating-point numbers; precision is at least the same as for
          <code class="calibre21">
           float
          </code>
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0046"><code class="calibre21">double d {7.2};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0047"><code class="calibre21">long double</code></pre>
         </td>
         <td class="left1">
          Long double precision floating-point numbers; precision is at least the same as for
          <code class="calibre21">
           double
          </code>
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0048"><code class="calibre21">long double d {16.98L};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0049"><code class="calibre21">char</code>
<code class="calibre21">unsigned char</code>
<code class="calibre21">signed char</code></pre>
         </td>
         <td class="left1">
          A single character
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0050"><code class="calibre21">char ch {'m'};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0051"><code class="calibre21">char8_t</code>
<code class="calibre21">char16_t</code>
<code class="calibre21">char32_t</code></pre>
         </td>
         <td class="left1">
          A single
          <i class="calibre18">
           n
          </i>
          -bit UTF-
          <i class="calibre18">
           n
          </i>
          -encoded Unicode character where
          <i class="calibre18">
           n
          </i>
          can be 8, 16, or 32
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0052"><code class="calibre21">char8_t c8 {u8'm'};</code>
<code class="calibre21">char16_t c16 {u'm'};</code>
<code class="calibre21">char32_t c32 {U'm'};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0053"><code class="calibre21">wchar_t</code></pre>
         </td>
         <td class="left1">
          A single wide character; the size depends on the compiler
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0054"><code class="calibre21">wchar_t w {L'm'};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <pre class="pre" id="c01-code-0055"><code class="calibre21">bool</code></pre>
         </td>
         <td class="left1">
          A Boolean type that can have one of two values:
          <code class="calibre21">
           true
          </code>
          or
          <code class="calibre21">
           false
          </code>
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0056"><code class="calibre21">bool b {true};</code></pre>
          <span aria-label="14" class="calibre20" epub:type="pagebreak" id="Page_14" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c01-para-0114">
       The range of
       <code class="calibre21">
        signed
       </code>
       and
       <code class="calibre21">
        unsigned
       </code>
       integer and
       <code class="calibre21">
        char
       </code>
       types is as follows:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          TYPE
         </th>
         <th class="left" scope="col">
          SIGNED
         </th>
         <th class="left" scope="col">
          UNSIGNED
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           char
          </code>
         </td>
         <td class="left1">
          -128 to 127
         </td>
         <td class="left1">
          0 to 255
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          2-byte integers
         </td>
         <td class="left1">
          -32,768 to 32,767
         </td>
         <td class="left1">
          0 to 65,535
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          4-byte integers
         </td>
         <td class="left1">
          -2,147,483,648 to 2,147,483,647
         </td>
         <td class="left1">
          0 to 4,294,967,295
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          8-byte integers
         </td>
         <td class="left1">
          -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
         </td>
         <td class="left1">
          0 to 18,446,744,073,709,551,615
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c01-para-0116">
       Type
       <code class="calibre21">
        char
       </code>
       is a different type compared to both the
       <code class="calibre21">
        signed char
       </code>
       and
       <code class="calibre21">
        unsigned char
       </code>
       types. It should be used only to represent characters. Depending on your compiler, it can be either signed or unsigned, so you should not rely on it being signed or unsigned.
      </p>
      <p class="calibre13" id="c01-para-0117">
       The range and precision of floating-point types is discussed in the section “
       <a class="calibre5" href="c01_split_000.xhtml#c01-sec-0031">
        Floating-Point Numbers
       </a>
       ” later in this chapter.
      </p>
      <p class="calibre13">
       Related to
       <code class="calibre21">
        char
       </code>
       ,
       <code class="calibre21">
        &lt;cstddef&gt;
       </code>
       provides the
       <code class="calibre21">
        std::byte
       </code>
       type representing a single byte. Before C++17, a
       <code class="calibre21">
        char
       </code>
       or
       <code class="calibre21">
        unsigned char
       </code>
       was used to represent a byte, but those types make it look like you are working with characters.
       <code class="calibre21">
        std::byte
       </code>
       on the other hand clearly states your intention, that is, a single byte of memory. A
       <code class="calibre21">
        byte
       </code>
       can be initialized as follows:
      </p>
      <pre class="calibre26" id="c01-code-0057"><code class="calibre21">std::byte b { 42 };</code></pre>
      <p class="calibre13">
       <span aria-label="15" class="calibre20" epub:type="pagebreak" id="Page_15" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0120">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           C++ does not provide a basic string type. However, a standard implementation of a string is provided as part of the Standard Library, as briefly discussed later in this chapter and in detail in
           <a class="calibre5" href="c02.xhtml">
            Chapter 2
           </a>
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0028">
       </span>
       <h4 class="calibre29" id="head-4-17">
        Numerical Limits
       </h4>
       <p class="calibre13" id="c01-para-0121">
        C++ provides a standard way to obtain information about numeric limits, such as the maximum possible value for an integer on the current platform. In C, you could access constants, such as
        <code class="calibre21">
         INT_MAX
        </code>
        . While those are still available in C++, it's recommended to use the
        <code class="calibre21">
         std::numeric_limits
        </code>
        class template defined in
        <code class="calibre21">
         &lt;limits&gt;
        </code>
        . Class templates are discussed later in this book, but those details are not important to understand how to use
        <code class="calibre21">
         numeric_limits
        </code>
        . For now, you just need to know that, since it is a class template, you have to specify the type you are interested in between a set of angle brackets. For example, to get numeric limits for integers, you write
        <code class="calibre21">
         std::numeric_limits&lt;int&gt;
        </code>
        . Consult a Standard Library reference (see
        <a class="calibre5" href="b02.xhtml">
         Appendix B
        </a>
        ) to learn exactly what kind of information you can query using
        <code class="calibre21">
         numeric_limits
        </code>
        .
       </p>
       <p class="calibre13">
        Here are a few examples:
       </p>
       <pre class="calibre26" id="c01-code-0058"><code class="calibre21">println("int:");</code>
<code class="calibre21">println("Max int value: {}", numeric_limits&lt;int&gt;::max());</code>
<code class="calibre21">println("Min int value: {}", numeric_limits&lt;int&gt;::min());</code>
<code class="calibre21">println("Lowest int value: {}", numeric_limits&lt;int&gt;::lowest());</code>
<code class="calibre21">        </code>
<code class="calibre21">println("\ndouble:");</code>
<code class="calibre21">println("Max double value: {}", numeric_limits&lt;double&gt;::max());</code>
<code class="calibre21">println("Min double value: {}", numeric_limits&lt;double&gt;::min());</code>
<code class="calibre21">println("Lowest double value: {}", numeric_limits&lt;double&gt;::lowest());</code></pre>
       <p class="calibre13">
        The output of this code snippet on my system is as follows:
       </p>
       <pre class="calibre26" id="c01-code-0059"><code class="calibre21">int:</code>
<code class="calibre21">Max int value: 2147483647</code>
<code class="calibre21">Min int value: -2147483648</code>
<code class="calibre21">Lowest int value: -2147483648</code>
<code class="calibre21"> </code>
<code class="calibre21">double:</code>
<code class="calibre21">Max double value: 1.7976931348623157e+308</code>
<code class="calibre21">Min double value: 2.2250738585072014e-308</code>
<code class="calibre21">Lowest double value: -1.7976931348623157e+308</code></pre>
       <p class="calibre13" id="c01-para-0124">
        Note the differences between
        <code class="calibre21">
         min()
        </code>
        and
        <code class="calibre21">
         lowest()
        </code>
        . For an integer, the minimum value equals the lowest value. However, for floating-point types, the minimum value is the smallest positive value that can be represented, while the lowest value is the most negative value representable, which equals
        <code class="calibre21">
         -max()
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0029">
       </span>
       <h4 class="calibre29" id="head-4-18">
        Zero Initialization
       </h4>
       <p class="calibre13" id="c01-para-0125">
        Variables can be initialized to zero with
        <code class="calibre21">
         {0}
        </code>
        , or with a
        <i class="calibre18">
         zero initializer
        </i>
        ,
        <code class="calibre21">
         {}
        </code>
        . Zero initialization initializes primitive integer types (such as
        <code class="calibre21">
         char
        </code>
        ,
        <code class="calibre21">
         int
        </code>
        , and so on) to zero, primitive floating-point types to 0.0, pointer types to
        <code class="calibre21">
         nullptr
        </code>
        , and constructs objects with the default constructor (discussed later).
       </p>
       <p class="calibre13">
        <span aria-label="16" class="calibre20" epub:type="pagebreak" id="Page_16" role="doc-pagebreak">
        </span>
        Here is an example of zero initializing a
        <code class="calibre21">
         float
        </code>
        and an
        <code class="calibre21">
         int
        </code>
        :
       </p>
       <pre class="calibre26" id="c01-code-0060"><code class="calibre21">float myFloat {};</code>
<code class="calibre21">int myInt {};</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-19">
        Casting
       </h4>
       <p class="calibre13">
        Variables can be converted to other types by
        <i class="calibre18">
         casting
        </i>
        them. For example, a
        <code class="calibre21">
         float
        </code>
        can be cast to an
        <code class="calibre21">
         int
        </code>
        . C++ provides three ways to
        <i class="calibre18">
         explicitly
        </i>
        change the type of a variable. The first method is a holdover from C; it is not recommended but, unfortunately, still commonly used. The second method is rarely used. The third method is the most verbose but is also the cleanest one and is therefore recommended.
       </p>
       <pre class="calibre26" id="c01-code-0061"><code class="calibre21">float myFloat { 3.14f };</code>
<code class="calibre21">int i1 { (int)myFloat };                <span class="color">// method 1</span></code>
<code class="calibre21">int i2 { int(myFloat) };                <span class="color">// method 2</span></code>
<code class="calibre21">int i3 { static_cast&lt;int&gt;(myFloat) };   <span class="color">// method 3</span></code></pre>
       <p class="calibre13">
        The resulting integer will be the value of the floating-point number with the fractional part truncated.
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        , “Discovering Inheritance Techniques,” describes the different casting methods in more detail. In some contexts, variables can be automatically cast, or
        <i class="calibre18">
         coerced
        </i>
        . For example, a
        <code class="calibre21">
         short
        </code>
        can be automatically converted into a
        <code class="calibre21">
         long
        </code>
        because a
        <code class="calibre21">
         long
        </code>
        represents the same type of data with at least the same precision:
       </p>
       <pre class="calibre26" id="c01-code-0062"><code class="calibre21">long someLong { someShort };          <span class="color">// no explicit cast needed</span></code></pre>
       <p class="calibre13" id="c01-para-0129">
        When automatically casting variables, you need to be aware of the potential loss of data. For example, casting a
        <code class="calibre21">
         float
        </code>
        to an
        <code class="calibre21">
         int
        </code>
        throws away the fractional part of the number, and the resulting integer can even be completely wrong if the floating-point value represents a number bigger than the maximum representable integer value. Most compilers will issue a warning or even an error if you assign a
        <code class="calibre21">
         float
        </code>
        to an
        <code class="calibre21">
         int
        </code>
        without an explicit cast. If you are certain that the left-hand side type is fully compatible with the right-hand side type, it's OK to cast implicitly.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0031">
       </span>
       <h4 class="calibre29" id="head-4-20">
        Floating-Point Numbers
       </h4>
       <p class="calibre13" id="c01-para-0130">
        Working with floating-point numbers can be more complicated than working with integral types. You need to keep a few things in mind. Calculations with floating-point values that are orders of magnitude different can cause errors. Furthermore, calculating the difference between two floating-point numbers that are almost identical will cause the loss of precision. Also keep in mind that a lot of decimal values cannot be represented exactly as floating-point numbers. However, going deeper in on the numerical problems with using floating-point numbers and how to write numerical stable floating-point algorithms is outside the scope of this book, as these topics warrant a whole book on their own.
       </p>
       <p class="calibre13">
        There are several special floating-point numbers:
       </p>
       <ul class="check" id="c01-list-0007">
        <li class="calibre9" id="c01-li-0028">
         <b class="calibre14">
          +/-infinity:
         </b>
         Represents positive and negative infinity, for example the result of dividing a non-zero number by zero
        </li>
        <li class="calibre9" id="c01-li-0029">
         <b class="calibre14">
          NaN:
         </b>
         Abbreviation for not-a-number, for example the result of dividing zero by zero, a mathematically undefined result
        </li>
       </ul>
       <p class="calibre13" id="c01-para-0132">
        <span aria-label="17" class="calibre20" epub:type="pagebreak" id="Page_17" role="doc-pagebreak">
        </span>
        To check whether a given floating-point number is not-a-number, use
        <code class="calibre21">
         std::isnan()
        </code>
        . To check for infinity, use
        <code class="calibre21">
         std::isinf()
        </code>
        . Both functions are defined in
        <code class="calibre21">
         &lt;cmath&gt;
        </code>
        .
       </p>
       <p class="calibre13" id="c01-para-0133">
        To obtain one of these special floating-point values, use
        <code class="calibre21">
         numeric_limits
        </code>
        , for example
        <code class="calibre21">
         std::numeric_limits&lt;double&gt;::infinity()
        </code>
        .
       </p>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0032">
        </span>
        <h5 class="calibre35" id="head-5-1">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         Extended Floating-Point Types
        </h5>
        <p class="calibre13" id="c01-para-0135">
         As mentioned in the section on variables earlier, C++ provides the following
         <i class="calibre18">
          standard floating-point types
         </i>
         :
         <code class="calibre21">
          float
         </code>
         ,
         <code class="calibre21">
          double
         </code>
         , and
         <code class="calibre21">
          long double
         </code>
         .
        </p>
        <p class="calibre13" id="c01-para-0136">
         C++23 introduces the following
         <i class="calibre18">
          extended floating-point types
         </i>
         that have become popular in certain domains. Support for these is optional, and not all compilers provide these types.
        </p>
        <table border="1" class="calibre31">
         <thead class="calibre32">
          <tr class="calibre33">
           <th class="left" scope="col">
            TYPE
           </th>
           <th class="left" scope="col">
            DESCRIPTION
           </th>
           <th class="left" scope="col">
            LITERAL SUFFIX
           </th>
          </tr>
         </thead>
         <tbody class="calibre34">
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float16_t
            </code>
           </td>
           <td class="left1">
            16-bit format from the IEEE 754 standard.
           </td>
           <td class="left1">
            <code class="calibre21">
             F16
            </code>
            or
            <code class="calibre21">
             f16
            </code>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float32_t
            </code>
           </td>
           <td class="left1">
            32-bit format from the IEEE 754 standard.
           </td>
           <td class="left1">
            <code class="calibre21">
             F32
            </code>
            or
            <code class="calibre21">
             f32
            </code>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float64_t
            </code>
           </td>
           <td class="left1">
            64-bit format from the IEEE 754 standard.
           </td>
           <td class="left1">
            <code class="calibre21">
             F64
            </code>
            or
            <code class="calibre21">
             f64
            </code>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float128_t
            </code>
           </td>
           <td class="left1">
            128-bit format from the IEEE 754 standard.
           </td>
           <td class="left1">
            <code class="calibre21">
             F128
            </code>
            or
            <code class="calibre21">
             f128
            </code>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::bfloat16_t
            </code>
           </td>
           <td class="left1">
            Brain floating point.
            <a aria-describedby="c01-note-0001" class="calibre5" epub:type="noteref" href="c01_split_001.xhtml#c01-note-0001" id="R_c01-note-0001" role="doc-noteref">
             <sup class="calibre22">
              1
             </sup>
            </a>
            Used in certain AI domains.
           </td>
           <td class="left1">
            <code class="calibre21">
             BF16
            </code>
            or
            <code class="calibre21">
             bf16
            </code>
           </td>
          </tr>
         </tbody>
        </table>
        <p class="calibre13" id="c01-para-0138">
         Most of the time, the standard types,
         <code class="calibre21">
          float
         </code>
         ,
         <code class="calibre21">
          double
         </code>
         , and
         <code class="calibre21">
          long double
         </code>
         , are enough. From these,
         <code class="calibre21">
          double
         </code>
         should be your default type. Using
         <code class="calibre21">
          float
         </code>
         can trigger loss of precision, and, depending on your use case, this might or might not be acceptable.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0033">
        </span>
        <h5 class="calibre35" id="head-5-2">
         Range and Accuracy of Floating-Point Types
        </h5>
        <p class="calibre13" id="c01-para-0139">
         Floating-point types have a limited range and a limited precision. The following table gives detailed specifications of all standard and extended floating-point types supported by C++. However, the specifications of the standard types,
         <code class="calibre21">
          float
         </code>
         ,
         <code class="calibre21">
          double
         </code>
         , and
         <code class="calibre21">
          long double
         </code>
         , are not specified exactly by the C++ standard. The standard says only that
         <code class="calibre21">
          long double
         </code>
         should have at least the same precision as
         <code class="calibre21">
          double
         </code>
         , and
         <code class="calibre21">
          double
         </code>
         should have at least the same precision as
         <code class="calibre21">
          float
         </code>
         . For these three types, the table shows values commonly used by compilers.
        </p>
        <table border="1" class="calibre31">
         <thead class="calibre32">
          <tr class="calibre33">
           <th class="left" scope="col">
            TYPE
           </th>
           <th class="left" scope="col">
            NAME
           </th>
           <th class="left" scope="col">
            MANTISSA BITS
           </th>
           <th class="left" scope="col">
            DECIMAL DIGITS
           </th>
           <th class="left" scope="col">
            EXPONENT BITS
           </th>
           <th class="left" scope="col">
            MIN
           </th>
           <th class="left" scope="col">
            MAX
           </th>
          </tr>
         </thead>
         <tbody class="calibre34">
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             float
            </code>
           </td>
           <td class="left1">
            Single precision
           </td>
           <td class="left1">
            24
           </td>
           <td class="left1">
            7.22
           </td>
           <td class="left1">
            8
           </td>
           <td class="left1">
            1.18x10
            <sup class="calibre22">
             -38
            </sup>
           </td>
           <td class="left1">
            3.40x10
            <sup class="calibre22">
             38
            </sup>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             double
            </code>
           </td>
           <td class="left1">
            Double precision
           </td>
           <td class="left1">
            53
           </td>
           <td class="left1">
            15.95
           </td>
           <td class="left1">
            11
           </td>
           <td class="left1">
            2.23x10
            <sup class="calibre22">
             -308
            </sup>
           </td>
           <td class="left1">
            1.80x10
            <sup class="calibre22">
             308
            </sup>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             long double
            </code>
           </td>
           <td class="left1">
            Extended precision
           </td>
           <td class="left1">
            64
           </td>
           <td class="left1">
            19.27
           </td>
           <td class="left1">
            15
           </td>
           <td class="left1">
            3.36x10
            <sup class="calibre22">
             −4932
            </sup>
           </td>
           <td class="left1">
            1.19x10
            <sup class="calibre22">
             4932
            </sup>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float16_t
            </code>
           </td>
           <td class="left1">
            Half precision
           </td>
           <td class="left1">
            11
           </td>
           <td class="left1">
            3.31
           </td>
           <td class="left1">
            5
           </td>
           <td class="left1">
            6.10x10
            <sup class="calibre22">
             -5
            </sup>
           </td>
           <td class="left1">
            65504
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float32_t
            </code>
           </td>
           <td class="left1">
            Single precision
           </td>
           <td class="left1">
            24
           </td>
           <td class="left1">
            7.22
           </td>
           <td class="left1">
            8
           </td>
           <td class="left1">
            1.18x10
            <sup class="calibre22">
             -38
            </sup>
           </td>
           <td class="left1">
            3.40x10
            <sup class="calibre22">
             38
            </sup>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float64_t
            </code>
           </td>
           <td class="left1">
            Double precision
           </td>
           <td class="left1">
            53
           </td>
           <td class="left1">
            15.95
           </td>
           <td class="left1">
            11
           </td>
           <td class="left1">
            2.23x10
            <sup class="calibre22">
             -308
            </sup>
           </td>
           <td class="left1">
            1.80x10
            <sup class="calibre22">
             308
            </sup>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::float128_t
            </code>
           </td>
           <td class="left1">
            Quadruple precision
           </td>
           <td class="left1">
            113
           </td>
           <td class="left1">
            34.02
           </td>
           <td class="left1">
            15
           </td>
           <td class="left1">
            3.36x10
            <sup class="calibre22">
             −4932
            </sup>
           </td>
           <td class="left1">
            1.19x10
            <sup class="calibre22">
             4932
            </sup>
           </td>
          </tr>
          <tr class="calibre33">
           <td class="left1">
            <code class="calibre21">
             std::bfloat16_t
            </code>
           </td>
           <td class="left1">
            Brain floating point
           </td>
           <td class="left1">
            8
           </td>
           <td class="left1">
            2.41
           </td>
           <td class="left1">
            8
           </td>
           <td class="left1">
            1.18x10
            <sup class="calibre22">
             -38
            </sup>
           </td>
           <td class="left1">
            3.40x10
            <sup class="calibre22">
             38
            </sup>
            <span aria-label="18" class="calibre20" epub:type="pagebreak" id="Page_18" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0034">
      </span>
      <h3 class="calibre27" id="head-3-65">
       Operators
      </h3>
      <p class="calibre13" id="c01-para-0141">
       What good is a variable if you don't have a way to change it? The following table shows common
       <i class="calibre18">
        operators
       </i>
       used in C++ and sample code that makes use of them. Operators in C++ can be
       <i class="calibre18">
        binary
       </i>
       (operate on two expressions),
       <i class="calibre18">
        unary
       </i>
       (operate on a single expression), or even
       <i class="calibre18">
        ternary
       </i>
       (operate on three expressions). There is only one ternary operator in C++, and it is explained in the section “
       <a class="calibre5" href="c01_split_000.xhtml#c01-sec-0045">
        The Conditional Operator
       </a>
       ” later in this chapter. Furthermore,
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       , “Overloading C++ Operators,” is reserved for operators and explains how you can add support for these operators to your own custom types.
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          OPERATOR
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
         <th class="left" scope="col">
          USAGE
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           =
          </code>
         </td>
         <td class="left1">
          Binary operator to assign the value on the right to the expression on the left.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0063"><code class="calibre21">int i;</code>
<code class="calibre21">i = 3;</code>
<code class="calibre21">int j;</code>
<code class="calibre21">j = i;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           !
          </code>
         </td>
         <td class="left1">
          Unary operator to complement the true/false (non-0/0) status of an expression.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0064"><code class="calibre21">bool b {!true};</code>
<code class="calibre21">bool b2 {!b};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           +
          </code>
         </td>
         <td class="left1">
          Binary operator for addition.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0065"><code class="calibre21">int i {3 + 2};</code>
<code class="calibre21">int j {i + 5};</code>
<code class="calibre21">int k {i + j};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           <code class="calibre21">
            -
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            *
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            /
           </code>
          </code>
         </td>
         <td class="left1">
          Binary operators for subtraction, multiplication, and division.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0066"><code class="calibre21">int i {5 – 1};</code>
<code class="calibre21">int j {5 * 2};</code>
<code class="calibre21">int k {j / i};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           %
          </code>
         </td>
         <td class="left1">
          Binary operator for the remainder of a division operation. This is also referred to as the
          <i class="calibre18">
           mod
          </i>
          or
          <i class="calibre18">
           modulo
          </i>
          operator. For example: 5%2=1.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0067"><code class="calibre21">int rem {5 % 2};</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           ++
          </code>
         </td>
         <td class="left1">
          Unary operator to increment an expression by 1. If the operator occurs after the expression, or
          <i class="calibre18">
           post-increment
          </i>
          , the result of the expression is the unincremented value. If the operator occurs before the expression, or
          <i class="calibre18">
           pre-increment
          </i>
          , the result of the expression is the new value.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0068"><code class="calibre21">i++;</code>
<code class="calibre21">++i;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           --
          </code>
         </td>
         <td class="left1">
          Unary operator to decrement an expression by 1.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0069"><code class="calibre21">i--;</code>
<code class="calibre21">--i;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           <code class="calibre21">
            +=
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            -=
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            *=
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            /=
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            %=
           </code>
          </code>
         </td>
         <td class="left1">
          Shorthand syntax for:
          <pre class="pre" id="c01-code-0070"><code class="calibre21">i = i + (j);</code>
<code class="calibre21">i = i - (j);</code>
<code class="calibre21">i = i * (j);</code>
<code class="calibre21">i = i / (j);</code>
<code class="calibre21">i = i % (j);</code></pre>
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0071"><code class="calibre21">i += j;</code>
<code class="calibre21">i -= j;</code>
<code class="calibre21">i *= j;</code>
<code class="calibre21">i /= j;</code>
<code class="calibre21">i %= j;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           <code class="calibre21">
            &amp;
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            &amp;=
           </code>
          </code>
         </td>
         <td class="left1">
          Takes the raw bits of one expression and performs a bitwise AND with the other expression.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0072"><code class="calibre21">i = j &amp; k;</code>
<code class="calibre21">j &amp;= k;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           <code class="calibre21">
            |
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            |=
           </code>
          </code>
         </td>
         <td class="left1">
          Takes the raw bits of one expression and performs a bitwise OR with the other expression.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0073"><code class="calibre21">i = j | k;</code>
<code class="calibre21">j |= k;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           <code class="calibre21">
            &lt;&lt;
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            &gt;&gt;
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            &lt;&lt;=
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            &gt;&gt;=
           </code>
          </code>
         </td>
         <td class="left1">
          Takes the raw bits of an expression and “shifts” each bit left (
          <code class="calibre21">
           &lt;&lt;
          </code>
          ) or right (
          <code class="calibre21">
           &gt;&gt;
          </code>
          ) the specified number of places.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0074"><code class="calibre21">i = i &lt;&lt; 1;</code>
<code class="calibre21">i = i &gt;&gt; 4;</code>
<code class="calibre21">i &lt;&lt;= 1;</code>
<code class="calibre21">i&gt;&gt;= 4;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           <code class="calibre21">
            ^
           </code>
           <br class="calibre12"/>
           <code class="calibre21">
            ^=
           </code>
          </code>
         </td>
         <td class="left1">
          Performs a bitwise exclusive or, also called XOR operation, on two expressions.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0075"><code class="calibre21">i = i ^ j;</code>
<code class="calibre21">i ^= j;</code></pre>
          <span aria-label="19" class="calibre20" epub:type="pagebreak" id="Page_19" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c01-para-0175">
       Operators of the form
       <code class="calibre21">
        <i class="calibre18">
         op
        </i>
        =
       </code>
       , e.g.,
       <code class="calibre21">
        +=
       </code>
       , are called
       <i class="calibre18">
        compound assignment operators
       </i>
       .
      </p>
      <p class="calibre13" id="c01-para-0176">
       When a binary operator is applied to two operands of different types, the compiler inserts an
       <i class="calibre18">
        implicit conversion
       </i>
       to convert one of them to the other before applying the operator. You can also use
       <i class="calibre18">
        explicit conversions
       </i>
       to convert one type to another using
       <code class="calibre21">
        static_cast()
       </code>
       .
      </p>
      <p class="calibre13" id="c01-para-0177">
       For implicit conversions, the compiler has certain rules to decide which type it converts to which other type. For example, for a binary operation with a small integer type and a larger integer type, the smaller type will be converted to the larger one. However, the results might not always be as you would expect. Thus, I recommend being careful with implicit conversions and using explicit conversions to make sure the compiler does what you intend.
      </p>
      <p class="calibre13">
       <span aria-label="20" class="calibre20" epub:type="pagebreak" id="Page_20" role="doc-pagebreak">
       </span>
       The following code snippet shows the most common variable types and operators in action. It also shows explicit conversions and explains why they are necessary. If you are unsure about how variables and operators work, try to figure out what the output of this program will be, and then run it to confirm your answer.
      </p>
      <pre class="calibre26" id="c01-code-0076"><code class="calibre21">int someInteger { 256 };</code>
<code class="calibre21">short someShort;</code>
<code class="calibre21">long someLong;</code>
<code class="calibre21">float someFloat;</code>
<code class="calibre21">double someDouble;</code>
<code class="calibre21"> </code>
<code class="calibre21">someInteger++;</code>
<code class="calibre21">someInteger *= 2;</code>
<code class="calibre21"><span class="color">// Conversion from larger integer type to smaller integer type</span></code>
<code class="calibre21"><span class="color">// can cause a warning or error, hence static_cast() is required.</span></code>
<code class="calibre21">someShort = static_cast&lt;short&gt;(someInteger);</code>
<code class="calibre21">someLong = someShort * 10000;</code>
<code class="calibre21">someFloat = someLong + 0.785f;</code>
<code class="calibre21"><span class="color">// To make sure the division is performed with double precision,</span></code>
<code class="calibre21"><span class="color">// someFloat is explicitly converted to double first.</span></code>
<code class="calibre21">someDouble = static_cast&lt;double&gt;(someFloat) / 100000;</code>
<code class="calibre21">println("{}", someDouble);</code></pre>
      <p class="calibre13">
       The C++ compiler has a recipe for the order in which expressions are evaluated. If you have a complicated expression with many operators, the order of execution may not be obvious. For that reason, it's probably better to break up a complicated expression into several smaller expressions, or explicitly group subexpressions by using parentheses. For example, the following line of code might be confusing unless you happen to know the exact evaluation order of the operators:
      </p>
      <pre class="calibre26" id="c01-code-0077"><code class="calibre21">int i { 34 + 8 * 2 + 21 / 7 % 2 };</code></pre>
      <p class="calibre13">
       Adding parentheses makes it clear which operations are happening first:
      </p>
      <pre class="calibre26" id="c01-code-0078"><code class="calibre21">int i { 34 + (8 * 2) + ( (21 / 7) % 2 ) };</code></pre>
      <p class="calibre13" id="c01-para-0181">
       For those of you playing along at home, both approaches are equivalent and end up with
       <code class="calibre21">
        i
       </code>
       equal to 51. If you assumed that C++ evaluated expressions from left to right, your answer would have been 1. C++ evaluates
       <code class="calibre21">
        /
       </code>
       ,
       <code class="calibre21">
        *
       </code>
       , and
       <code class="calibre21">
        %
       </code>
       first (in left-to-right order), followed by addition and subtraction, then bitwise operators. Parentheses let you explicitly tell the compiler that a certain operation should be evaluated first.
      </p>
      <p class="calibre13">
       Formally, the evaluation order of operators is expressed by their
       <i class="calibre18">
        precedence
       </i>
       . Operators with a higher precedence are executed before operators with a lower precedence. The following list shows the precedence of the operators from the previous table. Operators higher in the list have higher precedence and hence are executed before operators lower in the list.
      </p>
      <ul class="check" id="c01-list-0008">
       <li class="calibre9" id="c01-li-0030">
        <code class="calibre21">
         ++ −−
        </code>
        (postfix)
       </li>
       <li class="calibre9" id="c01-li-0031">
        <code class="calibre21">
         ! ++ −−
        </code>
        (prefix)
       </li>
       <li class="calibre9" id="c01-li-0032">
        <code class="calibre21">
         * / %
        </code>
       </li>
       <li class="calibre9" id="c01-li-0033">
        <code class="calibre21">
         + −
        </code>
       </li>
       <li class="calibre9" id="c01-li-0034">
        <code class="calibre21">
         &lt;&lt; &gt;&gt;
        </code>
       </li>
       <li class="calibre9" id="c01-li-0035">
        <code class="calibre21">
         &amp;
        </code>
       </li>
       <li class="calibre9" id="c01-li-0036">
        <span aria-label="21" class="calibre20" epub:type="pagebreak" id="Page_21" role="doc-pagebreak">
        </span>
        <code class="calibre21">
         ^
        </code>
       </li>
       <li class="calibre9" id="c01-li-0037">
        <code class="calibre21">
         |
        </code>
       </li>
       <li class="calibre9" id="c01-li-0038">
        <code class="calibre21">
         = += -= *= /= %= &amp;= |= ^= &lt;&lt;= &gt;&gt;=
        </code>
       </li>
      </ul>
      <p class="calibre13" id="c01-para-0183">
       This is only a selection of the available C++ operators.
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       gives a complete overview of all available operators, including their precedence.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0035">
      </span>
      <h3 class="calibre27" id="head-3-66">
       Enumerations
      </h3>
      <p class="calibre13">
       An integer really represents a single value from a larger set of values—the entire sequence of integral numbers.
       <i class="calibre18">
        Enumerations
       </i>
       are types that let you define your own sequences so that you can declare variables with values in that sequence. For example, in a chess program, you
       <i class="calibre18">
        could
       </i>
       represent each piece as an
       <code class="calibre21">
        int
       </code>
       , with constants for the piece types, as shown in the following code. The integers representing the types are marked
       <code class="calibre21">
        const
       </code>
       to indicate that they can never change.
      </p>
      <pre class="calibre26" id="c01-code-0079"><code class="calibre21">const int PieceTypeKing { 0 };</code>
<code class="calibre21">const int PieceTypeQueen { 1 };</code>
<code class="calibre21">const int PieceTypeRook { 2 };</code>
<code class="calibre21">const int PieceTypePawn { 3 };</code>
<code class="calibre21"><span class="color">//etc.</span></code>
<code class="calibre21">int myPiece { PieceTypeKing };</code></pre>
      <p class="calibre13" id="c01-para-0185">
       This representation can become dangerous. Since a piece is just an
       <code class="calibre21">
        int
       </code>
       , what would happen if another programmer added code to increment the value of a piece? By adding 1, a king becomes a queen, which really makes no sense. Worse still, someone could come in and give a piece a value of -1, which has no corresponding constant.
      </p>
      <p class="calibre13">
       <i class="calibre18">
        Strongly typed enumerations
       </i>
       solve these problems by tightly defining the range of values for a variable. The following code declares a new type,
       <code class="calibre21">
        PieceType
       </code>
       , which has four possible values, called
       <i class="calibre18">
        enumerators
       </i>
       , representing four of the chess pieces:
      </p>
      <pre class="calibre26" id="c01-code-0080"><code class="calibre21">enum class PieceType { King, Queen, Rook, Pawn };</code></pre>
      <p class="calibre13">
       This new type can be used as follows:
      </p>
      <pre class="calibre26" id="c01-code-0081"><code class="calibre21">PieceType piece { PieceType::King };</code></pre>
      <p class="calibre13">
       Behind the scenes, an enumeration is just an integer value. The underlying values for
       <code class="calibre21">
        King
       </code>
       ,
       <code class="calibre21">
        Queen
       </code>
       ,
       <code class="calibre21">
        Rook
       </code>
       , and
       <code class="calibre21">
        Pawn
       </code>
       are 0, 1, 2, and 3, respectively. It's possible to specify the integer values for enumerators yourself. The syntax is as follows:
      </p>
      <pre class="calibre26" id="c01-code-0082"><code class="calibre21">enum class PieceType</code>
<code class="calibre21">{</code>
<code class="calibre21">    King = 1,</code>
<code class="calibre21">    Queen,</code>
<code class="calibre21">    Rook = 10,</code>
<code class="calibre21">    Pawn</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c01-para-0189">
       If you do not assign a value to an enumerator, the compiler automatically assigns it a value that is the previous enumerator incremented by 1. If you do not assign a value to the first enumerator, the compiler assigns it the value 0. So, in this example,
       <code class="calibre21">
        King
       </code>
       has the integer value 1,
       <code class="calibre21">
        Queen
       </code>
       has the value 2 assigned by the compiler,
       <code class="calibre21">
        Rook
       </code>
       has the value 10, and
       <code class="calibre21">
        Pawn
       </code>
       has the value 11 assigned automatically by the compiler.
      </p>
      <p class="calibre13">
       <span aria-label="22" class="calibre20" epub:type="pagebreak" id="Page_22" role="doc-pagebreak">
       </span>
       Even though enumerators are internally represented by integer values, they are not automatically converted to integers, which means the following is illegal:
      </p>
      <pre class="calibre26" id="c01-code-0083"><code class="calibre21">int underlyingValue { piece };</code></pre>
      <p class="calibre13">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Starting with C++23, you can use
       <code class="calibre21">
        std::to_underlying()
       </code>
       . For example:
      </p>
      <pre class="calibre26" id="c01-code-0084"><code class="calibre21">int underlyingValue { to_underlying(piece) };</code></pre>
      <p class="calibre13">
       By default, the underlying type of an enumerator is an integer, but this can be changed as follows:
      </p>
      <pre class="calibre26" id="c01-code-0085"><code class="calibre21">enum class PieceType <b class="calibre14">: unsigned long</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    King = 1,</code>
<code class="calibre21">    Queen,</code>
<code class="calibre21">    Rook = 10,</code>
<code class="calibre21">    Pawn</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       For an
       <code class="calibre21">
        enum class
       </code>
       , the enumerator names are not automatically exported to the enclosing scope. This means they cannot clash with other names already defined in the parent scope. As a result, different strongly typed enumerations can have enumerators with the same name. For example, the following two enumerations are perfectly legal:
      </p>
      <pre class="calibre26" id="c01-code-0086"><code class="calibre21">enum class State { <b class="calibre14">Unknown</b>, Started, Finished };</code>
<code class="calibre21">enum class Error { None, BadInput, DiskFull, <b class="calibre14">Unknown</b> };</code></pre>
      <p class="calibre13">
       A big benefit of this is that you can give short names to the enumerators, for example,
       <code class="calibre21">
        Unknown
       </code>
       instead of
       <code class="calibre21">
        UnknownState
       </code>
       and
       <code class="calibre21">
        UnknownError
       </code>
       . However, it also means that you either have to fully qualify enumerators, or use a
       <code class="calibre21">
        using enum
       </code>
       or
       <code class="calibre21">
        using
       </code>
       declaration. Here's an example of a
       <code class="calibre21">
        using enum
       </code>
       declaration:
      </p>
      <pre class="calibre26" id="c01-code-0087"><code class="calibre21">using enum PieceType;</code>
<code class="calibre21">PieceType piece { King };</code></pre>
      <p class="calibre13">
       A
       <code class="calibre21">
        using
       </code>
       declaration can be used if you want to avoid having to fully qualify specific enumerators. For example, in the following code snippet,
       <code class="calibre21">
        King
       </code>
       can be used without full qualification, but other enumerators still need to be fully qualified:
      </p>
      <pre class="calibre26" id="c01-code-0088"><code class="calibre21">using PieceType::King;</code>
<code class="calibre21">PieceType piece { King };</code>
<code class="calibre21">piece = PieceType::Queen;</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0198">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Even though
          </i>
          C++
          <i class="calibre18">
           allows you to avoid fully qualifying enumerators, I recommend using this feature judiciously. At least try to minimize the scope of the
          </i>
          <code class="calibre21">
           using enum
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           using
          </code>
          <i class="calibre18">
           declaration because if this scope is too big, you risk reintroducing name clashes. The section on the
          </i>
          <code class="calibre21">
           switch
          </code>
          <i class="calibre18">
           statement later in this chapter shows a properly scoped use of a
          </i>
          <code class="calibre21">
           using enum
          </code>
          <i class="calibre18">
           declaration.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0037">
       </span>
       <h4 class="calibre29" id="head-4-21">
        Old-Style Enumerations
       </h4>
       <p class="calibre13">
        New code should always use the strongly typed enumerations explained in the previous section. However, in legacy code bases, you might find
        <i class="calibre18">
         old-style enumerations
        </i>
        , also known as
        <i class="calibre18">
         unscoped
         <span aria-label="23" class="calibre20" epub:type="pagebreak" id="Page_23" role="doc-pagebreak">
         </span>
         enumerations
        </i>
        :
        <code class="calibre21">
         enum
        </code>
        instead of
        <code class="calibre21">
         enum class
        </code>
        . Here is the previous
        <code class="calibre21">
         PieceType
        </code>
        defined as an old-style enumeration:
       </p>
       <pre class="calibre26" id="c01-code-0089"><code class="calibre21">enum PieceType { PieceTypeKing, PieceTypeQueen, PieceTypeRook, PieceTypePawn };</code></pre>
       <p class="calibre13">
        The enumerators of such old-style enumerations are exported to the enclosing scope. This means that in the parent scope you can use the names of the enumerators without fully qualifying them, for example:
       </p>
       <pre class="calibre26" id="c01-code-0090"><code class="calibre21">PieceType myPiece { PieceTypeQueen };</code></pre>
       <p class="calibre13">
        This of course also means that they can clash with other names already defined in the parent scope resulting in a compilation error. Here's an example:
       </p>
       <pre class="calibre26" id="c01-code-0091"><code class="calibre21">bool ok { false };</code>
<code class="calibre21">enum Status { error, ok };</code></pre>
       <p class="calibre13">
        This code snippet does not compile because the name
        <code class="calibre21">
         ok
        </code>
        is first defined to be a Boolean variable, and later the same name is used as the name of an enumerator. Visual C++ 2022 emits the following error:
       </p>
       <pre class="calibre26" id="c01-code-0092"><code class="calibre21">error C2365: 'ok': redefinition; previous definition was 'data variable'</code></pre>
       <p class="calibre13" id="c01-para-0203">
        Hence, you should make sure such old-style enumerations have enumerators with unique names, such as
        <code class="calibre21">
         PieceTypeQueen
        </code>
        , instead of simply
        <code class="calibre21">
         Queen
        </code>
        .
       </p>
       <p class="calibre13">
        These old-style enumerations are not strongly typed, meaning they are not
        <i class="calibre18">
         type safe
        </i>
        . They are always interpreted as integers, and thus you can inadvertently compare enumerators from completely different enumerations, or pass an enumerator of the wrong enumeration to a function.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0205">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Always use strongly typed
           </i>
           <code class="calibre21">
            enum class
           </code>
           <i class="calibre18">
            enumerations instead of old-style, unscoped, type-unsafe
           </i>
           <code class="calibre21">
            enum
           </code>
           <i class="calibre18">
            enumerations.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0039">
      </span>
      <h3 class="calibre27" id="head-3-67">
       Structs
      </h3>
      <p class="calibre13">
       <i class="calibre18">
        Structs
       </i>
       let you encapsulate one or more existing types into a new type. The classic example of a struct is a database record. If you are building a personnel system to keep track of employee information, you might want to store the first initial, last initial, employee number, and salary for each employee. A struct that contains all of this information is shown in the
       <code class="calibre21">
        employee.cppm
       </code>
       <i class="calibre18">
        module interface file
       </i>
       that follows. This is your first self-written module in this book. Module interface files usually have
       <code class="calibre21">
        .cppm
       </code>
       as extension. The first line in the module interface file is a
       <i class="calibre18">
        module declaration
       </i>
       and states that this file is defining a module called
       <code class="calibre21">
        employee
       </code>
       . Furthermore, a module needs to explicitly state what it
       <i class="calibre18">
        exports
       </i>
       , i.e., what will be visible when this module is imported somewhere else. Exporting a type from a module is done with the
       <code class="calibre21">
        export
       </code>
       keyword in front of, for example, a
       <code class="calibre21">
        struct
       </code>
       .
      </p>
      <pre class="calibre26" id="c01-code-0093"><code class="calibre21">export module employee;</code>
<code class="calibre21"> </code>
<code class="calibre21">export struct Employee {</code>
<code class="calibre21">    char firstInitial;</code>
<code class="calibre21">    char lastInitial;</code>
<code class="calibre21">    int employeeNumber;</code>
<code class="calibre21">    int salary;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="24" class="calibre20" epub:type="pagebreak" id="Page_24" role="doc-pagebreak">
       </span>
       A variable declared with type
       <code class="calibre21">
        Employee
       </code>
       has all of these
       <i class="calibre18">
        fields
       </i>
       built in. The individual fields of a struct can be accessed by using the
       <code class="calibre21">
        .
       </code>
       operator. The example that follows creates and then outputs the record for an employee. Just as with the standard named module
       <code class="calibre21">
        std
       </code>
       , you don't use angle brackets when importing custom modules.
      </p>
      <pre class="calibre26" id="c01-code-0094"><code class="calibre21">import std;</code>
<code class="calibre21">import employee; <span class="color">// Import our employee module</span></code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Create and populate an employee.</span></code>
<code class="calibre21">    Employee anEmployee;</code>
<code class="calibre21">    anEmployee.firstInitial = 'J';</code>
<code class="calibre21">    anEmployee.lastInitial = 'D';</code>
<code class="calibre21">    anEmployee.employeeNumber = 42;</code>
<code class="calibre21">    anEmployee.salary = 80000;</code>
<code class="calibre21">    <span class="color">// Output the values of an employee.</span></code>
<code class="calibre21">    println("Employee: {}{}", anEmployee.firstInitial,</code>
<code class="calibre21">        anEmployee.lastInitial);</code>
<code class="calibre21">    println("Number: {}", anEmployee.employeeNumber);</code>
<code class="calibre21">    println("Salary: ${}", anEmployee.salary);</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0040">
      </span>
      <h3 class="calibre27" id="head-3-68">
       Conditional Statements
      </h3>
      <p class="calibre13" id="c01-para-0208">
       <i class="calibre18">
        Conditional statements
       </i>
       let you execute code based on whether something is true. As shown in the following sections, there are two main types of conditional statements in C++:
       <code class="calibre21">
        if
       </code>
       /
       <code class="calibre21">
        else
       </code>
       statements and
       <code class="calibre21">
        switch
       </code>
       statements.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0041">
       </span>
       <h4 class="calibre29" id="head-4-22">
        if/else Statements
       </h4>
       <p class="calibre13">
        The most common conditional statement is the
        <code class="calibre21">
         if
        </code>
        statement, which can be accompanied by an
        <code class="calibre21">
         else
        </code>
        . If the condition given inside the
        <code class="calibre21">
         if
        </code>
        statement is true, the line or block of code is executed. If not, execution continues with the
        <code class="calibre21">
         else
        </code>
        case if present or with the code following the conditional statement. The following code shows a
        <i class="calibre18">
         cascading if statement
        </i>
        , a fancy way of saying that the
        <code class="calibre21">
         if
        </code>
        statement has an
        <code class="calibre21">
         else
        </code>
        statement that in turn has another
        <code class="calibre21">
         if
        </code>
        statement, and so on:
       </p>
       <pre class="calibre26" id="c01-code-0095"><code class="calibre21">if (i&gt; 4) {</code>
<code class="calibre21">    <span class="color">// Do something.</span></code>
<code class="calibre21">} else if (i&gt; 2) {</code>
<code class="calibre21">    <span class="color">// Do something else.</span></code>
<code class="calibre21">} else {</code>
<code class="calibre21">    <span class="color">// Do something else.</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0210">
        The expression between the parentheses of an
        <code class="calibre21">
         if
        </code>
        statement must be a Boolean value or evaluate to a Boolean value. A value of 0 evaluates to
        <code class="calibre21">
         false
        </code>
        , while any non-zero value evaluates to
        <code class="calibre21">
         true
        </code>
        . For example,
        <code class="calibre21">
         if(0)
        </code>
        is equivalent to
        <code class="calibre21">
         if(false)
        </code>
        . Logical evaluation operators, described later, provide ways of evaluating expressions to result in a
        <code class="calibre21">
         true
        </code>
        or
        <code class="calibre21">
         false
        </code>
        Boolean value.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0042">
        </span>
        <h5 class="calibre35" id="head-5-3">
         Initializers for if Statements
        </h5>
        <p class="calibre13">
         C++ allows you to include an initializer inside an
         <code class="calibre21">
          if
         </code>
         statement using the following syntax:
        </p>
        <pre class="calibre26" id="c01-code-0096"><span aria-label="25" class="calibre20" epub:type="pagebreak" id="Page_25" role="doc-pagebreak"></span><code class="calibre21">if (<b class="calibre14">&lt;initializer&gt;;</b> &lt;conditional_expression&gt;) {</code>
<code class="calibre21">    &lt;if_body&gt;</code>
<code class="calibre21">} else if (&lt;else_if_expression&gt;) {</code>
<code class="calibre21">    &lt;else_if_body&gt;</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    &lt;else_body&gt;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c01-para-0212">
         Any variable introduced in the
         <code class="calibre21">
          &lt;initializer&gt;
         </code>
         is available only in the
         <code class="calibre21">
          &lt;conditional_expression&gt;
         </code>
         , in the
         <code class="calibre21">
          &lt;if_body&gt;
         </code>
         , in all
         <code class="calibre21">
          &lt;else_if_expression&gt;
         </code>
         s and
         <code class="calibre21">
          &lt;else_if_body&gt;
         </code>
         s, and in the
         <code class="calibre21">
          &lt;else_body&gt;
         </code>
         . Such variables are not available outside the
         <code class="calibre21">
          if
         </code>
         statement.
        </p>
        <p class="calibre13">
         It is too early in this book to give a useful example of this feature, but here is an example of how it could be employed:
        </p>
        <pre class="calibre26" id="c01-code-0097"><code class="calibre21">if (Employee employee { getEmployee() }; employee.salary&gt; 1000) { … }</code></pre>
        <p class="calibre13" id="c01-para-0214">
         In this example, the initializer gets an employee by calling the
         <code class="calibre21">
          getEmployee()
         </code>
         function. Functions are discussed later in this chapter. The condition checks whether the salary of the retrieved employee exceeds 1000. Only in that case is the body of the
         <code class="calibre21">
          if
         </code>
         statement executed. More concrete examples will be given throughout this book.
        </p>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0043">
       </span>
       <h4 class="calibre29" id="head-4-23">
        switch Statements
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         switch
        </code>
        statement is an alternate syntax for performing actions based on the value of an expression. In C++, the expression of a
        <code class="calibre21">
         switch
        </code>
        statement must be of an integral type, a type convertible to an integral type, an enumeration, or a strongly typed enumeration, and must be compared to constants. Each constant value represents a “case.” If the expression matches the case, the subsequent lines of code are executed until a
        <code class="calibre21">
         break
        </code>
        statement is reached. You can also provide a
        <code class="calibre21">
         default
        </code>
        case, which is matched if none of the other cases matches. The following pseudocode shows a common use of the
        <code class="calibre21">
         switch
        </code>
        statement:
       </p>
       <pre class="calibre26" id="c01-code-0098"><code class="calibre21">switch (menuItem) {</code>
<code class="calibre21">    case OpenMenuItem:</code>
<code class="calibre21">        <span class="color">// Code to open a file</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">    case SaveMenuItem:</code>
<code class="calibre21">        <span class="color">// Code to save a file</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">    default:</code>
<code class="calibre21">        <span class="color">// Code to give an error message</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        A
        <code class="calibre21">
         switch
        </code>
        statement can always be converted into
        <code class="calibre21">
         if/else
        </code>
        statements. The previous
        <code class="calibre21">
         switch
        </code>
        statement can be converted as follows:
       </p>
       <pre class="calibre26" id="c01-code-0099"><code class="calibre21">if (menuItem == OpenMenuItem) {</code>
<code class="calibre21">    <span class="color">// Code to open a file</span></code>
<code class="calibre21">} else if (menuItem == SaveMenuItem) {</code>
<code class="calibre21">    <span class="color">// Code to save a file</span></code>
<code class="calibre21">} else {</code>
<code class="calibre21">    <span class="color">// Code to give an error message</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0217">
        <span aria-label="26" class="calibre20" epub:type="pagebreak" id="Page_26" role="doc-pagebreak">
        </span>
        <code class="calibre21">
         switch
        </code>
        statements are generally used when you want to do something based on more than one specific value of an expression, as opposed to some test on the expression. In such a case, the
        <code class="calibre21">
         switch
        </code>
        statement avoids cascading
        <code class="calibre21">
         if
        </code>
        /
        <code class="calibre21">
         else
        </code>
        statements. If you need to inspect only one value, an
        <code class="calibre21">
         if
        </code>
        or
        <code class="calibre21">
         if
        </code>
        /
        <code class="calibre21">
         else
        </code>
        statement is fine.
       </p>
       <p class="calibre13">
        Once a
        <code class="calibre21">
         case
        </code>
        expression matching the
        <code class="calibre21">
         switch
        </code>
        condition is found, all statements that follow it are executed until a
        <code class="calibre21">
         break
        </code>
        statement is reached. This execution continues even if another
        <code class="calibre21">
         case
        </code>
        expression is encountered, which is called
        <i class="calibre18">
         fallthrough
        </i>
        . In the following example, a single set of statements is executed for both
        <code class="calibre21">
         Mode::Standard
        </code>
        and
        <code class="calibre21">
         Default
        </code>
        . If mode is
        <code class="calibre21">
         Custom
        </code>
        , then
        <code class="calibre21">
         value
        </code>
        is first changed from 42 to 84, after which the
        <code class="calibre21">
         Standard
        </code>
        and
        <code class="calibre21">
         Default
        </code>
        statements are executed. In other words, the
        <code class="calibre21">
         Custom
        </code>
        case falls through until it eventually reaches a
        <code class="calibre21">
         break
        </code>
        statement or the end of the
        <code class="calibre21">
         switch
        </code>
        statement. This code snippet also shows a nice example of using a properly scoped
        <code class="calibre21">
         using enum
        </code>
        declaration to avoid having to write
        <code class="calibre21">
         Mode::Custom
        </code>
        ,
        <code class="calibre21">
         Mode::Standard
        </code>
        , and
        <code class="calibre21">
         Mode::Default
        </code>
        for the different
        <code class="calibre21">
         case
        </code>
        labels.
       </p>
       <pre class="calibre26" id="c01-code-0100"><code class="calibre21">enum class Mode { Default, Custom, Standard };</code>
<code class="calibre21"> </code>
<code class="calibre21">int value { 42 };</code>
<code class="calibre21">Mode mode { <span class="color">/* … */</span> };</code>
<code class="calibre21">switch (mode) {</code>
<code class="calibre21">    using enum Mode;</code>
<code class="calibre21"> </code>
<code class="calibre21">    case Custom:</code>
<code class="calibre21">        value = 84;</code>
<code class="calibre21">    case Standard:</code>
<code class="calibre21">    case Default:</code>
<code class="calibre21">        <span class="color">// Do something with value …</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Fallthrough can be a source of bugs, for example if you accidentally forget a
        <code class="calibre21">
         break
        </code>
        statement. Because of this, some compilers give a warning if a fallthrough is detected in a
        <code class="calibre21">
         switch
        </code>
        statement, unless the case is empty. In the previous example, no compiler will give a warning that the
        <code class="calibre21">
         Standard
        </code>
        case falls through to the
        <code class="calibre21">
         Default
        </code>
        case, but a compiler might give a warning for the
        <code class="calibre21">
         Custom
        </code>
        case fallthrough. To prevent this warning and to make it clear to a reader and the compiler that the fallthrough is intentional, you can use a
        <code class="calibre21">
         [[fallthrough]]
        </code>
        attribute as follows:
       </p>
       <pre class="calibre26" id="c01-code-0101"><code class="calibre21">switch (mode) {</code>
<code class="calibre21">    using enum Mode;</code>
<code class="calibre21"> </code>
<code class="calibre21">    case Custom:</code>
<code class="calibre21">        value = 84;</code>
<code class="calibre21">        <b class="calibre14">[[fallthrough]];</b></code>
<code class="calibre21">    case Standard:</code>
<code class="calibre21">    case Default:</code>
<code class="calibre21">        <span class="color">// Do something with value …</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Surrounding the statements following a
        <code class="calibre21">
         case
        </code>
        expression with braces is often optional, but sometimes necessary, for example, when defining variables. Here is an example:
       </p>
       <pre class="calibre26" id="c01-code-0102"><code class="calibre21">switch (mode) {</code>
<code class="calibre21">    using enum Mode;</code>
<code class="calibre21"> </code>
<span aria-label="27" class="calibre20" epub:type="pagebreak" id="Page_27" role="doc-pagebreak"></span><code class="calibre21">    case Custom:</code>
<code class="calibre21">        <b class="calibre14">{</b></code>
<code class="calibre21">            <b class="calibre14">int someVariable { 42 };</b></code>
<code class="calibre21">            value = someVariable * 2;</code>
<code class="calibre21">            [[fallthrough]];</code>
<code class="calibre21">        <b class="calibre14">}</b></code>
<code class="calibre21">    case Standard:</code>
<code class="calibre21">    case Default:</code>
<code class="calibre21">        <span class="color">// Do something with value …</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0221">
        When using a
        <code class="calibre21">
         switch
        </code>
        statement for enumerations, most compilers issue a warning when you don't handle all different enumerators, either by explicitly writing cases for each enumerator or by writing cases for only a selection of the enumerators in combination with a
        <code class="calibre21">
         default
        </code>
        case. However, it's recommended not to include a
        <code class="calibre21">
         default
        </code>
        case in a
        <code class="calibre21">
         switch
        </code>
        statement switching on enumerations. Instead, you should explicitly list all enumerators. The reason is that this makes the code less error prone for when you later add more enumerators to the enumeration. In that case, if you forget to add any new enumerator to specific
        <code class="calibre21">
         switch
        </code>
        statements, the compiler will issue a warning instead of silently handling the new enumerator using the
        <code class="calibre21">
         default
        </code>
        case.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0044">
        </span>
        <h5 class="calibre35" id="head-5-4">
         Initializers for switch Statements
        </h5>
        <p class="calibre13">
         Just as for
         <code class="calibre21">
          if
         </code>
         statements, you can use initializers with
         <code class="calibre21">
          switch
         </code>
         statements. The syntax is as follows:
        </p>
        <pre class="calibre26" id="c01-code-0103"><code class="calibre21">switch (<b class="calibre14">&lt;initializer&gt;;</b> &lt;expression&gt;) { 
&lt;body&gt; }</code></pre>
        <p class="calibre13" id="c01-para-0223">
         Any variables introduced in the
         <code class="calibre21">
          &lt;initializer&gt;
         </code>
         are available only in the
         <code class="calibre21">
          &lt;expression&gt;
         </code>
         and in the
         <code class="calibre21">
          &lt;body&gt;
         </code>
         . They are not available outside the
         <code class="calibre21">
          switch
         </code>
         statement.
        </p>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0045">
      </span>
      <h3 class="calibre27" id="head-3-69">
       The Conditional Operator
      </h3>
      <p class="calibre13">
       C++ has one operator that takes three arguments, known as a
       <i class="calibre18">
        ternary operator
       </i>
       . It is used as a shorthand conditional expression of the form “if [
       <i class="calibre18">
        something
       </i>
       ] then [
       <i class="calibre18">
        perform action
       </i>
       ], otherwise [
       <i class="calibre18">
        perform some other action
       </i>
       ].” The conditional operator is represented by a
       <code class="calibre21">
        ?
       </code>
       and a
       <code class="calibre21">
        :
       </code>
       . The following code outputs “yes” if the variable
       <code class="calibre21">
        i
       </code>
       is greater than 2, and “no” otherwise:
      </p>
      <pre class="calibre26" id="c01-code-0104"><code class="calibre21">println("{}", (i&gt; 2) ? "yes" : "no");</code></pre>
      <p class="calibre13">
       The parentheses around
       <code class="calibre21">
        i &gt; 2
       </code>
       are optional, so the following is equivalent:
      </p>
      <pre class="calibre26" id="c01-code-0105"><code class="calibre21">println("{}", i&gt; 2 ? "yes" : "no");</code></pre>
      <p class="calibre13" id="c01-para-0226">
       The advantage of the conditional operator is that it is an expression, not a statement like the
       <code class="calibre21">
        if
       </code>
       and
       <code class="calibre21">
        switch
       </code>
       statements. Hence, a conditional operator can occur within almost any context. In the preceding example, the conditional operator is used within code that performs output. A convenient way to remember how the syntax is used is to treat the question mark as though the statement that comes before it really is a question. For example, “Is
       <code class="calibre21">
        i
       </code>
       greater than 2? If so, the result is ‘yes'; if not, the result is ‘no.'”
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-70">
       Logical Evaluation Operators
      </h3>
      <p class="calibre13" id="c01-para-0227">
       You have already seen a
       <i class="calibre18">
        logical evaluation operator
       </i>
       without a formal definition. The
       <code class="calibre21">
        &gt;
       </code>
       operator compares two values. The result is
       <code class="calibre21">
        true
       </code>
       if the value on the left is greater than the value on the right. All logical evaluation operators follow this pattern—they all result in a
       <code class="calibre21">
        true
       </code>
       or
       <code class="calibre21">
        false
       </code>
       .
      </p>
      <p class="calibre13" id="c01-para-0228">
       <span aria-label="28" class="calibre20" epub:type="pagebreak" id="Page_28" role="doc-pagebreak">
       </span>
       The following table shows common logical evaluation operators:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          OP
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
         <th class="left" scope="col">
          USAGE
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           &lt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           &lt;=
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           &gt;
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           &gt;=
          </code>
         </td>
         <td class="left1">
          Determines if the left-hand side is less than, less than or equal to, greater than, or greater than or equal to the right-hand side.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0106"><code class="calibre21">if (i &lt; 0) {</code>
<code class="calibre21"> print("i is negative");</code>
<code class="calibre21">}</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           ==
          </code>
         </td>
         <td class="left1">
          Determines if the left-hand side equals the right-hand side. Don't confuse this with the = (assignment) operator!
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0107"><code class="calibre21">if (i == 3) {</code>
<code class="calibre21"> print("i is 3");</code>
<code class="calibre21">}</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           !=
          </code>
         </td>
         <td class="left1">
          Not equals. The result of the statement is
          <code class="calibre21">
           true
          </code>
          if the left-hand side does not equal the right-hand side.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0108"><code class="calibre21">if (i != 3) {</code>
<code class="calibre21"> print("i is not 3");</code>
<code class="calibre21">}</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           &lt;=&gt;
          </code>
         </td>
         <td class="left1">
          Three-way comparison operator, also called the spaceship operator. Explained in more detail in the next section.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0109"><code class="calibre21">result = i &lt;=&gt; 0;</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           !
          </code>
         </td>
         <td class="left1">
          Logical NOT. This complements the
          <code class="calibre21">
           true/
          </code>
          <code class="calibre21">
           false
          </code>
          status of a Boolean expression. This is a unary operator.
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0110"><code class="calibre21">if (!bool1) {</code>
<code class="calibre21"> print("bool1 is false");</code>
<code class="calibre21">}</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           &amp;&amp;
          </code>
         </td>
         <td class="left1">
          Logical AND. The result is
          <code class="calibre21">
           true
          </code>
          if both parts of the expression are
          <code class="calibre21">
           true
          </code>
          .
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0111"><code class="calibre21">if (bool1 &amp;&amp; bool2) {</code>
<code class="calibre21"> print("both are true");</code>
<code class="calibre21">}</code></pre>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           ||
          </code>
         </td>
         <td class="left1">
          Logical OR. The result is
          <code class="calibre21">
           true
          </code>
          if either part of the expression is
          <code class="calibre21">
           true
          </code>
          .
         </td>
         <td class="left1">
          <pre class="pre" id="c01-code-0112"><code class="calibre21">if (bool1 || bool2) {</code>
<code class="calibre21"> print("at least one is true");</code>
<code class="calibre21">}</code></pre>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       C++ uses
       <i class="calibre18">
        short-circuit logic
       </i>
       when evaluating logical expressions. That means that once the final result is certain, the rest of the expression won't be evaluated. For example, if you are performing logical OR operations of several Boolean expressions, as shown in the following code, the result is known to be
       <code class="calibre21">
        true
       </code>
       as soon as one of them is found to be
       <code class="calibre21">
        true
       </code>
       . The rest won't even be checked.
      </p>
      <pre class="calibre26" id="c01-code-0113"><code class="calibre21">bool result { bool1 || bool2 || (i&gt; 7) || (27 / 13 % i + 1) &lt; 2 };</code></pre>
      <p class="calibre13" id="c01-para-0243">
       In this example, if
       <code class="calibre21">
        bool1
       </code>
       is found to be
       <code class="calibre21">
        true
       </code>
       , the entire expression must be
       <code class="calibre21">
        true
       </code>
       , so the other parts aren't evaluated. In this way, the language saves your code from doing unnecessary work. It can, however, be a source of hard-to-find bugs if the later subexpressions in some way influence the state of the program (for example, by calling a separate function).
      </p>
      <p class="calibre13">
       The following code shows a statement using
       <code class="calibre21">
        &amp;&amp;
       </code>
       that short-circuits after the second term because 0 always evaluates to
       <code class="calibre21">
        false
       </code>
       :
      </p>
      <pre class="calibre26" id="c01-code-0114"><code class="calibre21">bool result { bool1 &amp;&amp; 0 &amp;&amp; (i&gt; 7) &amp;&amp; !done };</code></pre>
      <p class="calibre13" id="c01-para-0245">
       <span aria-label="29" class="calibre20" epub:type="pagebreak" id="Page_29" role="doc-pagebreak">
       </span>
       Short-circuiting can be beneficial for performance. You can put less resource intensive tests first so that more expensive tests are not even executed when the logic short-circuits. It is also useful in the context of pointers to avoid parts of the expression to be executed when a pointer is not valid. Pointers and short-circuiting with pointers are discussed later in this chapter.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-71">
       Three-Way Comparisons
      </h3>
      <p class="calibre13">
       The
       <i class="calibre18">
        three-way comparison operator
       </i>
       can be used to determine the order of two values. It is also called the
       <i class="calibre18">
        spaceship operator
       </i>
       because its sign,
       <code class="calibre21">
        &lt;=&gt;
       </code>
       , resembles a spaceship. With a single expression, it tells you whether a value is equal, less than, or greater than another value. Because it has to return more than just
       <code class="calibre21">
        true
       </code>
       or
       <code class="calibre21">
        false
       </code>
       , it cannot return a Boolean type. Instead, it returns an enumeration-like type, defined in
       <code class="calibre21">
        &lt;compare&gt;
       </code>
       in the
       <code class="calibre21">
        std
       </code>
       namespace. If the operands are integral types, the result is a
       <i class="calibre18">
        strong ordering
       </i>
       and can be one of the following:
      </p>
      <ul class="check" id="c01-list-0009">
       <li class="calibre9" id="c01-li-0039">
        <b class="calibre14">
         <code class="calibre21">
          strong_ordering::less
         </code>
         :
        </b>
        First operand less than second
       </li>
       <li class="calibre9" id="c01-li-0040">
        <b class="calibre14">
         <code class="calibre21">
          strong_ordering::greater
         </code>
         :
        </b>
        First operand greater than second
       </li>
       <li class="calibre9" id="c01-li-0041">
        <b class="calibre14">
         <code class="calibre21">
          strong_ordering::equal
         </code>
         :
        </b>
        First operand equal to second
       </li>
      </ul>
      <p class="calibre13">
       Here is an example of its use:
      </p>
      <pre class="calibre26" id="c01-code-0115"><code class="calibre21">int i { 11 };</code>
<code class="calibre21">strong_ordering result { i &lt;=&gt; 0 };</code>
<code class="calibre21">if (result == strong_ordering::less) { println("less"); }</code>
<code class="calibre21">if (result == strong_ordering::greater) { println("greater"); }</code>
<code class="calibre21">if (result == strong_ordering::equal) { println("equal"); }</code></pre>
      <p class="calibre13">
       Certain types don't have a total ordering. For example, not-a-number floating-point values are never equal, less than, or greater than any other floating-point value. Thus, such comparisons result in a
       <i class="calibre18">
        partial ordering
       </i>
       :
      </p>
      <ul class="check" id="c01-list-0010">
       <li class="calibre9" id="c01-li-0042">
        <code class="calibre21">
         partial_ordering::less
        </code>
        : First operand less than second
       </li>
       <li class="calibre9" id="c01-li-0043">
        <code class="calibre21">
         partial_ordering::greater:
        </code>
        First operand greater than second
       </li>
       <li class="calibre9" id="c01-li-0044">
        <code class="calibre21">
         partial_ordering::equivalent:
        </code>
        First operand equivalent to second, meaning
        <code class="calibre21">
         !(a&lt;b) &amp;&amp; !(b&lt;a)
        </code>
        ; for example, -0.0 is equivalent to +0.0, but they are not equal
       </li>
       <li class="calibre9" id="c01-li-0045">
        <code class="calibre21">
         partial_ordering::unordered:
        </code>
        If one or both of the operands is not-a-number
       </li>
      </ul>
      <p class="calibre13" id="c01-para-0249">
       If you really need a strong ordering of your floating-point values, e.g., if you know they are never not-a-number, you can use
       <code class="calibre21">
        std::strong_order()
       </code>
       , which always produces an
       <code class="calibre21">
        std::strong_ordering
       </code>
       result.
      </p>
      <p class="calibre13">
       There is also a
       <i class="calibre18">
        weak ordering
       </i>
       , which is an additional ordering type that you can choose from to implement three-way comparisons for your own types. With a weak ordering, all values are ordered, i.e., there is no
       <code class="calibre21">
        unordered
       </code>
       result, but the ordering is not strong, meaning there can be non-equal values that are equivalent. An example is ordering strings with case-insensitive comparisons. In that case,
       <span aria-label="30" class="calibre20" epub:type="pagebreak" id="Page_30" role="doc-pagebreak">
       </span>
       the strings “Hello World” and “hello world” are certainly not equal, but they are equivalent. Here are the different results of a weak ordering:
      </p>
      <ul class="check" id="c01-list-0011">
       <li class="calibre9" id="c01-li-0046">
        <code class="calibre21">
         weak_ordering::less:
        </code>
        First operand less than second
       </li>
       <li class="calibre9" id="c01-li-0047">
        <code class="calibre21">
         weak_ordering::greater:
        </code>
        First operand greater than second
       </li>
       <li class="calibre9" id="c01-li-0048">
        <code class="calibre21">
         weak_ordering::equivalent:
        </code>
        First operand equivalent to second
       </li>
      </ul>
      <p class="calibre13" id="c01-para-0251">
       The three different types of ordering support certain implicit conversions. A
       <code class="calibre21">
        strong_ordering
       </code>
       can be converted implicitly to a
       <code class="calibre21">
        partial_ordering
       </code>
       or a
       <code class="calibre21">
        weak_ordering
       </code>
       . A
       <code class="calibre21">
        weak_ordering
       </code>
       can be converted implicitly to a
       <code class="calibre21">
        partial_ordering
       </code>
       .
      </p>
      <p class="calibre13" id="c01-para-0252">
       For primitive types, using the three-way comparison operator doesn't gain you much compared to just performing individual comparisons using the
       <code class="calibre21">
        ==
       </code>
       ,
       <code class="calibre21">
        &lt;
       </code>
       , and
       <code class="calibre21">
        &gt;
       </code>
       operators. However, it becomes useful with objects that are more expensive to compare. With the three-way comparison operator, such objects can be ordered with a single operator, instead of potentially having to call two individual comparison operators, triggering two expensive comparisons.
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” explains how to add support for three-way comparisons to your own types.
      </p>
      <p class="calibre13">
       Finally,
       <code class="calibre21">
        &lt;compare&gt;
       </code>
       provides
       <i class="calibre18">
        named comparison functions
       </i>
       to interpret the result of an ordering. These functions are
       <code class="calibre21">
        std::is_eq()
       </code>
       ,
       <code class="calibre21">
        is_neq()
       </code>
       ,
       <code class="calibre21">
        is_lt()
       </code>
       ,
       <code class="calibre21">
        is_lteq()
       </code>
       ,
       <code class="calibre21">
        is_gt()
       </code>
       , and
       <code class="calibre21">
        is_gteq()
       </code>
       returning
       <code class="calibre21">
        true
       </code>
       if an ordering represents
       <code class="calibre21">
        ==
       </code>
       ,
       <code class="calibre21">
        !=
       </code>
       ,
       <code class="calibre21">
        &lt;
       </code>
       ,
       <code class="calibre21">
        &lt;=
       </code>
       ,
       <code class="calibre21">
        &gt;
       </code>
       , or
       <code class="calibre21">
        &gt;=
       </code>
       respectively,
       <code class="calibre21">
        false
       </code>
       otherwise. Here is an example:
      </p>
      <pre class="calibre26" id="c01-code-0116"><code class="calibre21">int i { 11 };</code>
<code class="calibre21">strong_ordering result { i &lt;=&gt; 0 };</code>
<code class="calibre21">if (is_lt(result)) { println("less"); }</code>
<code class="calibre21">if (is_gt(result)) { println("greater"); }</code>
<code class="calibre21">if (is_eq(result)) { println("equal"); }</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0048">
      </span>
      <h3 class="calibre27" id="head-3-72">
       Functions
      </h3>
      <p class="calibre13" id="c01-para-0254">
       For programs of any significant size, placing all the code inside of
       <code class="calibre21">
        main()
       </code>
       is unmanageable. To make programs easier to understand, you need to break up, or
       <i class="calibre18">
        decompose
       </i>
       , code into concise functions.
      </p>
      <p class="calibre13">
       In C++, you first declare a function to make it available for other code to use. If the function is used only inside a particular file, you generally declare and define the function in that source file. If the function is for use by other modules or files, you export a declaration for the function from a module interface file, while the function's definition can be either in the same module interface file or in a module implementation file (discussed later).
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0256">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Function declarations are often called function prototypes or function headers to emphasize that they represent how the function can be accessed, but not the code behind it. The term function signature is used to denote the combination of the function name and its parameter list, but without the return type
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <span aria-label="31" class="calibre20" epub:type="pagebreak" id="Page_31" role="doc-pagebreak">
       </span>
       A function declaration is shown in the following code. This example has a return type of
       <code class="calibre21">
        void
       </code>
       , indicating that the function does not provide a result to the caller. The caller must provide two arguments for the function to work with—an integer and a character.
      </p>
      <pre class="calibre26" id="c01-code-0117"><code class="calibre21">void myFunction(int i, char c);</code></pre>
      <p class="calibre13">
       Without an actual definition to match this function declaration, the link stage of the compilation process will fail because code that makes use of the function will be calling nonexistent code. The following definition prints the values of the two parameters:
      </p>
      <pre class="calibre26" id="c01-code-0118"><code class="calibre21">void myFunction(int i, char c)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("The value of i is {}.", i);</code>
<code class="calibre21">    println("The value of c is {}.", c);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Elsewhere in the program, you can make calls to
       <code class="calibre21">
        myFunction()
       </code>
       and pass in arguments for the two parameters. Some sample function calls are shown here:
      </p>
      <pre class="calibre26" id="c01-code-0119"><code class="calibre21">int someInt { 6 };</code>
<code class="calibre21">char someChar { 'c' };</code>
<code class="calibre21">myFunction(8, 'a');</code>
<code class="calibre21">myFunction(someInt, 'b');</code>
<code class="calibre21">myFunction(5, someChar);</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0261">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           In
          </i>
          C++,
          <i class="calibre18">
           unlike
          </i>
          C,
          <i class="calibre18">
           a function that takes no parameters just has an empty parameter list. It is not necessary to use
          </i>
          <code class="calibre21">
           void
          </code>
          <i class="calibre18">
           to indicate that no parameters are taken. However, you must still use
          </i>
          <code class="calibre21">
           void
          </code>
          <i class="calibre18">
           to indicate when no value is returned.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       C++ functions can also
       <i class="calibre18">
        return
       </i>
       a value to the caller. The following function adds two numbers and returns the result:
      </p>
      <pre class="calibre26" id="c01-code-0120"><code class="calibre21">int addNumbers(int number1, int number2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return number1 + number2;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This function can be called as follows:
      </p>
      <pre class="calibre26" id="c01-code-0121"><code class="calibre21">int sum { addNumbers(5, 3) };</code></pre>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0051">
       </span>
       <h4 class="calibre29" id="head-4-24">
        Function Return Type Deduction
       </h4>
       <p class="calibre13">
        You can ask the compiler to figure out the return type of a function automatically. To make use of this functionality, just specify
        <code class="calibre21">
         auto
        </code>
        as the return type.
       </p>
       <pre class="calibre26" id="c01-code-0122"><code class="calibre21"><b class="calibre14">auto addNumbers(int number1, int number2)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return number1 + number2;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0265">
        The compiler deduces the return type based on the expressions used for the
        <code class="calibre21">
         return
        </code>
        statements in the body of the function. There can be multiple
        <code class="calibre21">
         return
        </code>
        statements, but they must all resolve to exactly the same type as the compiler will never insert any implicit conversions to deduce the return type of a
        <span aria-label="32" class="calibre20" epub:type="pagebreak" id="Page_32" role="doc-pagebreak">
        </span>
        function. Such a function can even include recursive calls (calls to itself), but the first
        <code class="calibre21">
         return
        </code>
        statement in the function must be a non-recursive call.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0052">
       </span>
       <h4 class="calibre29" id="head-4-25">
        Current Function's Name
       </h4>
       <p class="calibre13">
        Every function has a local predefined variable
        <code class="calibre21">
         __func__
        </code>
        containing the name of the current function. One use of this variable could be for logging purposes.
       </p>
       <pre class="calibre26" id="c01-code-0123"><code class="calibre21">int addNumbers(int number1, int number2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">println("Entering function {}", __func__);</b></code>
<code class="calibre21">    return number1 + number2;</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0053">
       </span>
       <h4 class="calibre29" id="head-4-26">
        Function Overloading
       </h4>
       <p class="calibre13" id="c01-para-0267">
        Overloading a function means providing several functions with the same name but with a different set of parameters. Only specifying different return types is not enough, as the returned value can be ignored when calling the function; instead, the number and/or types of the parameters must be different.
       </p>
       <p class="calibre13">
        Suppose you want to provide versions of
        <code class="calibre21">
         addNumbers()
        </code>
        that work with integers and with
        <code class="calibre21">
         double
        </code>
        s. Without overloading, you would have to come up with unique names, for example:
       </p>
       <pre class="calibre26" id="c01-code-0124"><code class="calibre21">int <b class="calibre14">addNumbersInts</b>(int a, int b) { return a + b; }</code>
<code class="calibre21">double <b class="calibre14">addNumbersDoubles</b>(double a, double b) { return a + b; }</code></pre>
       <p class="calibre13">
        With function overloading, you don't need to come up with different names for the different versions of a function. The following code snippet defines two functions called
        <code class="calibre21">
         addNumbers()
        </code>
        , one defined for integers, the other defined for
        <code class="calibre21">
         double
        </code>
        s:
       </p>
       <pre class="calibre26" id="c01-code-0125"><code class="calibre21">int <b class="calibre14">addNumbers</b>(int a, int b) { return a + b; }</code>
<code class="calibre21">double <b class="calibre14">addNumbers</b>(double a, double b) { return a + b; }</code></pre>
       <p class="calibre13">
        When calling
        <code class="calibre21">
         addNumbers()
        </code>
        , the compiler automatically selects the correct function overload based on the provided arguments. This process is called
        <i class="calibre18">
         overload resolution
        </i>
        .
       </p>
       <pre class="calibre26" id="c01-code-0126"><code class="calibre21">println("{}", addNumbers(1, 2));         <span class="color">// Calls the integer version</span></code>
<code class="calibre21">println("{}", addNumbers(1.11, 2.22));   <span class="color">// Calls the double version</span></code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0054">
      </span>
      <h3 class="calibre27" id="head-3-73">
       Attributes
      </h3>
      <p class="calibre13" id="c01-para-0271">
       Attributes are a mechanism to add optional and/or vendor-specific information into source code. Before attributes were standardized in C++, vendors decided how to specify such information. Examples are
       <code class="calibre21">
        __attribute__
       </code>
       ,
       <code class="calibre21">
        __declspec
       </code>
       , and so on. Since C++11, there is standardized support for attributes by using the double square brackets syntax
       <code class="calibre21">
        [[
       </code>
       <i class="calibre18">
        attribute
       </i>
       <code class="calibre21">
        ]]
       </code>
       .
      </p>
      <p class="calibre13" id="c01-para-0272">
       Earlier in this chapter, the
       <code class="calibre21">
        [[fallthrough]]
       </code>
       attribute is introduced to prevent a compiler warning when fallthrough in a
       <code class="calibre21">
        switch case
       </code>
       statement is intentional. The C++ standard defines a couple more standard attributes.
      </p>
      <span aria-label="33" class="calibre20" epub:type="pagebreak" id="Page_33" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0055">
       </span>
       <h4 class="calibre29" id="head-4-27">
        [[nodiscard]]
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         [[nodiscard]]
        </code>
        attribute can be used on a function that returns a value. The compiler will then issue a warning if the return value from that function is not used by the calling function. Here is an example:
       </p>
       <pre class="calibre26" id="c01-code-0127"><code class="calibre21">[[nodiscard]] int func() { return 42; }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    func();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The compiler issues a warning similar to the following:
       </p>
       <pre class="calibre26" id="c01-code-0128"><code class="calibre21">warning C4834: discarding return value of function with 'nodiscard' attribute</code></pre>
       <p class="calibre13" id="c01-para-0275">
        This feature can, for example, be used for functions that return error codes. By adding the
        <code class="calibre21">
         [[nodiscard]]
        </code>
        attribute to such functions, the error codes returned from them cannot be ignored.
       </p>
       <p class="calibre13" id="c01-para-0276">
        More general, the
        <code class="calibre21">
         [[nodiscard]]
        </code>
        attribute can be used on classes, structs, functions, and enumerations. An example of applying the attribute to an entire class is when you have a class representing error conditions. By applying
        <code class="calibre21">
         [[nodiscard]]
        </code>
        to such a class, the compiler will issue a warning for every function call that returns such an error condition and where the caller doesn't do anything with it.
       </p>
       <p class="calibre13">
        A reason can be provided for the
        <code class="calibre21">
         [[nodiscard]]
        </code>
        attribute in the form of a string. This reason is then displayed in the warning messages generated by the compiler if the returned value is ignored by the caller of the function. Here is an example:
       </p>
       <pre class="calibre26" id="c01-code-0129"><code class="calibre21">[[nodiscard("Some explanation")]] int func();</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0056">
       </span>
       <h4 class="calibre29" id="head-4-28">
        [[maybe_unused]]
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         [[maybe_unused]]
        </code>
        attribute can be used to suppress the compiler from issuing a warning when something is unused, as in this example:
       </p>
       <pre class="calibre26" id="c01-code-0130"><code class="calibre21">int func(int param1, int param2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return 42;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        If the compiler warning level is set high enough, this function definition results in two compiler warnings. For example, Microsoft Visual C++ gives these warnings:
       </p>
       <pre class="calibre26" id="c01-code-0131"><code class="calibre21">warning C4100: 'param2': unreferenced formal parameter</code>
<code class="calibre21">warning C4100: 'param1': unreferenced formal parameter</code></pre>
       <p class="calibre13">
        By using the
        <code class="calibre21">
         [[maybe_unused]]
        </code>
        attribute, you can suppress such warnings:
       </p>
       <pre class="calibre26" id="c01-code-0132"><code class="calibre21">int func(int param1, <b class="calibre14">[[maybe_unused]]</b> int param2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return 42;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        In this case, the second parameter is marked with the attribute suppressing its warning. The compiler now only issues a warning for
        <code class="calibre21">
         param1
        </code>
        :
       </p>
       <pre class="calibre26" id="c01-code-0133"><code class="calibre21">warning C4100: 'param1': unreferenced formal parameter</code></pre>
       <p class="calibre13" id="c01-para-0282">
        <span aria-label="34" class="calibre20" epub:type="pagebreak" id="Page_34" role="doc-pagebreak">
        </span>
        The
        <code class="calibre21">
         [[maybe_unused]]
        </code>
        attribute can be used on classes, structs, non-
        <code class="calibre21">
         static
        </code>
        data members, unions,
        <code class="calibre21">
         typedef
        </code>
        s, type aliases, variables, functions, enumerations, and enumerators. Some of these terms you might not know yet but are discussed later in this book.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0057">
       </span>
       <h4 class="calibre29" id="head-4-29">
        [[noreturn]]
       </h4>
       <p class="calibre13">
        Adding a
        <code class="calibre21">
         [[noreturn]]
        </code>
        attribute to a function means that it never returns control to the caller. Typically, the function either causes some kind of termination (process termination or thread termination) or throws an exception. Exceptions are discussed later in this chapter. With this attribute, the compiler can avoid giving certain warnings or errors because it now knows more about the intent of the function. Here is an example:
       </p>
       <pre class="calibre26" id="c01-code-0134"><code class="calibre21">import std;</code>
<code class="calibre21">using namespace std; </code>
<code class="calibre21"> </code>
<code class="calibre21">[[noreturn]] void forceProgramTermination()</code>
<code class="calibre21">{</code>
<code class="calibre21">    exit(1);  <span class="color">// Defined in &lt;cstdlib&gt;</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">bool isDongleAvailable()</code>
<code class="calibre21">{</code>
<code class="calibre21">    bool isAvailable { false };</code>
<code class="calibre21">    <span class="color">// Check whether a licensing dongle is available…</span></code>
<code class="calibre21">    return isAvailable;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">bool isFeatureLicensed(int featureId)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (!isDongleAvailable()) {</code>
<code class="calibre21">        <span class="color">// No licensing dongle found, abort program execution!</span></code>
<code class="calibre21">        forceProgramTermination();</code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        <span class="color">// Dongle available, perform license check of the given feature…</span></code>
<code class="calibre21">        bool isLicensed { featureId == 42 };</code>
<code class="calibre21">        return isLicensed;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    bool isLicensed { isFeatureLicensed(42) };</code>
<code class="calibre21">    println("{}", isLicensed);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        This code snippet compiles fine without any warnings or errors. However, if you remove the
        <code class="calibre21">
         [[noreturn]]
        </code>
        attribute, the compiler generates the following warning (output from Visual C++):
       </p>
       <pre class="calibre26" id="c01-code-0135"><code class="calibre21">warning C4715: 'isFeatureLicensed': not all control paths return a value</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0058">
       </span>
       <h4 class="calibre29" id="head-4-30">
        [[deprecated]]
       </h4>
       <p class="calibre13">
        <code class="calibre21">
         [[deprecated]]
        </code>
        can be used to mark something as deprecated, which means you can still use it, but its use is discouraged. This attribute accepts an optional argument that can be used to explain the reason for the deprecation, as in this example:
       </p>
       <pre class="calibre26" id="c01-code-0136"><code class="calibre21">[[deprecated("Unsafe function, please use xyz")]] void func();</code></pre>
       <p class="calibre13">
        <span aria-label="35" class="calibre20" epub:type="pagebreak" id="Page_35" role="doc-pagebreak">
        </span>
        If you use this deprecated function, you'll get a compilation error or warning. For example, GCC gives the following warning:
       </p>
       <pre class="calibre26" id="c01-code-0137"><code class="calibre21">warning: 'void func()' is deprecated: Unsafe function, please use xyz</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0059">
       </span>
       <h4 class="calibre29" id="head-4-31">
        [[likely]] and [[unlikely]]
       </h4>
       <p class="calibre13">
        The likelihood attributes
        <code class="calibre21">
         [[likely]]
        </code>
        and
        <code class="calibre21">
         [[unlikely]]
        </code>
        can be used to help the compiler in optimizing code. These attributes can, for example, be used to mark branches of
        <code class="calibre21">
         if
        </code>
        and
        <code class="calibre21">
         switch
        </code>
        statements according to how likely it is that a branch will be taken. However, these attributes are rarely required. Compilers and hardware these days have powerful branch prediction to figure it out themselves, but in certain cases, such as performance critical code, you might have to help the compiler. The syntax is as follows:
       </p>
       <pre class="calibre26" id="c01-code-0138"><code class="calibre21">int value { <span class="color">/* … */</span> };</code>
<code class="calibre21">if (value&gt; 11) [[unlikely]] { <span class="color">/* Do something … */</span> }</code>
<code class="calibre21">else { <span class="color">/* Do something else … */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">switch (value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    [[likely]] case 1:</code>
<code class="calibre21">        <span class="color">// Do something …</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">    case 2:</code>
<code class="calibre21">        <span class="color">// Do something …</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">    [[unlikely]] case 12:</code>
<code class="calibre21">        <span class="color">// Do something …</span></code>
<code class="calibre21">        break;</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0060">
       </span>
       <h4 class="calibre29" id="head-4-32">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        [[assume]]
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         [[assume]]
        </code>
        attribute allows the compiler to assume that certain expressions are true without evaluating them at run time. The compiler can use such assumptions to better optimize the code. As an example, let's look at the following function:
       </p>
       <pre class="calibre26" id="c01-code-0139"><code class="calibre21">int divideBy32(int x)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return x / 32;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The function accepts a signed integer, so the compiler has to produce code to make sure the division works for both positive and negative numbers. If you are sure that
        <code class="calibre21">
         x
        </code>
        will never be negative, and for some reason you cannot make
        <code class="calibre21">
         x
        </code>
        of type
        <code class="calibre21">
         unsigned
        </code>
        , you can add an assumption as follows:
       </p>
       <pre class="calibre26" id="c01-code-0140"><code class="calibre21">int divideBy32(int x)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">[[assume(x &gt;= 0)]];</b></code>
<code class="calibre21">    return x / 32;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0291">
        With this assumption in place, the compiler can omit any code to handle negative numbers and optimize the division into a single instruction, a simple right shift of five bits.
       </p>
      </section>
     </section>
     <span aria-label="36" class="calibre20" epub:type="pagebreak" id="Page_36" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0061">
      </span>
      <h3 class="calibre27" id="head-3-74">
       C-Style Arrays
      </h3>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0293">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           This section briefly explains C-style arrays, as you will encounter them in legacy code. However, in C++, it is best to avoid C-style arrays and instead use Standard Library functionality, such as
          </i>
          <code class="calibre21">
           std::array
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           vector
          </code>
          <i class="calibre18">
           , discussed in the following two sections.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <i class="calibre18">
        Arrays
       </i>
       hold a series of values, all of the same type, each of which can be accessed by its position in the array. In C++, you must provide the size of the array when the array is declared. You cannot give a variable as the size—it must be a constant, or a
       <i class="calibre18">
        constant expression (constexpr)
       </i>
       . Constant expressions are discussed in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       . The code that follows shows the declaration of an array of three integers followed by three lines to initialize the elements to 0:
      </p>
      <pre class="calibre26" id="c01-code-0141"><code class="calibre21">int myArray[3];</code>
<code class="calibre21">myArray[0] = 0;</code>
<code class="calibre21">myArray[1] = 0;</code>
<code class="calibre21">myArray[2] = 0;</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0296">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           In
          </i>
          C++,
          <i class="calibre18">
           the first element of an array is always at position 0, not position 1! The last position of the array is always the size of the array minus 1!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       The “Loops” section later in this chapter discusses how you could use loops to initialize each element of an array. However, instead of using loops or the previous initialization mechanism, you can also accomplish
       <i class="calibre18">
        zero initialization
       </i>
       with the following one-liner:
      </p>
      <pre class="calibre26" id="c01-code-0142"><code class="calibre21">int myArray[3] = { 0 };</code></pre>
      <p class="calibre13">
       You can even drop the 0.
      </p>
      <pre class="calibre26" id="c01-code-0143"><code class="calibre21">int myArray[3] = {};</code></pre>
      <p class="calibre13">
       Finally, the equal sign is optional as well, so you can write this:
      </p>
      <pre class="calibre26" id="c01-code-0144"><code class="calibre21">int myArray[3] {};</code></pre>
      <p class="calibre13">
       An array can be initialized with an initializer list, in which case the compiler deduces the size of the array automatically. Here's an example:
      </p>
      <pre class="calibre26" id="c01-code-0145"><code class="calibre21">int myArray[] { 1, 2, 3, 4 }; <span class="color">// The compiler creates an array of 4 elements.</span></code></pre>
      <p class="calibre13">
       If you do specify the size of the array and the initializer list has fewer elements than the given size, the remaining elements are set to 0. For example, the following code sets only the first element in the array to the value 2 and sets all others to 0:
      </p>
      <pre class="calibre26" id="c01-code-0146"><code class="calibre21">int myArray[3] { 2 };</code></pre>
      <p class="calibre13">
       <span aria-label="37" class="calibre20" epub:type="pagebreak" id="Page_37" role="doc-pagebreak">
       </span>
       To get the size of a stack-based C-style array, you can use the
       <code class="calibre21">
        std::size()
       </code>
       function, defined in
       <code class="calibre21">
        &lt;array&gt;
       </code>
       . It returns an
       <code class="calibre21">
        std::size_t
       </code>
       , which is an unsigned integer type defined in
       <code class="calibre21">
        &lt;cstddef&gt;
       </code>
       . Here is an example:
      </p>
      <pre class="calibre26" id="c01-code-0147"><code class="calibre21">std::size_t arraySize { std::size(myArray) };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0304">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           In legacy code, you might see
          </i>
          <code class="calibre21">
           size_t
          </code>
          <i class="calibre18">
           being used without the
          </i>
          <code class="calibre21">
           std
          </code>
          <i class="calibre18">
           namespace qualification, without a
          </i>
          <code class="calibre21">
           using namespace std
          </code>
          <i class="calibre18">
           directive, and without a
          </i>
          <code class="calibre21">
           using std::size_t
          </code>
          <i class="calibre18">
           declaration. This does not work any longer when you use
          </i>
          <code class="calibre21">
           import std
          </code>
          <i class="calibre18">
           , as that imports everything into the
          </i>
          <code class="calibre21">
           std
          </code>
          <i class="calibre18">
           namespace. Hence, you need either to use
          </i>
          <code class="calibre21">
           std::size_t
          </code>
          <i class="calibre18">
           or to use a proper
          </i>
          <code class="calibre21">
           using
          </code>
          <i class="calibre18">
           directive or declaration. Alternatively,
           <a class="calibre5" href="c11.xhtml">
            Chapter 11
           </a>
           explains that you can import the named module
          </i>
          <code class="calibre21">
           std.compat
          </code>
          <i class="calibre18">
           instead of
          </i>
          <code class="calibre21">
           std
          </code>
          <i class="calibre18">
           , but this is not recommended for new code
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0306">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           C++23 introduces a literal suffix
          </i>
          <code class="calibre21">
           uz
          </code>
          <i class="calibre18">
           for type
          </i>
          <code class="calibre21">
           std::size_t
          </code>
          <i class="calibre18">
           , for example,
          </i>
          <code class="calibre21">
           42uz
          </code>
          <i class="calibre18">
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       An older trick to get the size of a stack-based C-style array was to use the
       <code class="calibre21">
        sizeof
       </code>
       operator. The
       <code class="calibre21">
        sizeof
       </code>
       operator returns the size of its argument in bytes. To get the number of elements in a stack-based array, you divide the size in bytes of the array by the size in bytes of the first element. Here's an example:
      </p>
      <pre class="calibre26" id="c01-code-0148"><code class="calibre21">std::size_t arraySize { sizeof(myArray) / sizeof(myArray[0]) };</code></pre>
      <p class="calibre13">
       The preceding examples show a one-dimensional array of integers, which you can think of as a line of integers, each with its own numbered compartment. C++ allows multidimensional arrays. You might think of a two-dimensional array as a checkerboard, where each location has a position along the x-axis and a position along the y-axis. Three-dimensional arrays can be pictured as a cube, while higher-dimensional arrays are harder to visualize. The following code shows the syntax for creating a two-dimensional array of characters for a tic-tac-toe board and then putting an “o” in the center square:
      </p>
      <pre class="calibre26" id="c01-code-0149"><code class="calibre21">char ticTacToeBoard[3][3];</code>
<code class="calibre21">ticTacToeBoard[1][1] = 'o';</code></pre>
      <p class="calibre13" id="c01-para-0309">
       <a class="calibre5" href="c01_split_000.xhtml#c01-fig-0001" id="R_c01-fig-0001">
        Figure 1.1
       </a>
       shows a visual representation of this board with the position of each square.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0066">
      </span>
      <h3 class="calibre27" id="head-3-75">
       std::array
      </h3>
      <p class="calibre13" id="c01-para-0310">
       The arrays discussed in the previous section come from C and still work in C++. However, C++ has a special type for fixed-size containers called
       <code class="calibre21">
        std::array
       </code>
       , defined in
       <code class="calibre21">
        &lt;array&gt;
       </code>
       . It's basically a thin wrapper around C-style arrays.
      </p>
      <figure class="calibre36">
       <img alt="A table of three rows and three columns. The first row holds ticTacToeBoard 0 0, 0 1, and 0 2. The second row has ticTacToeBoard 1 0, 1 1, and 1 2. The third row holds ticTacToeBoard 2 0, 2 1, and 2 2." class="center" src="images/c01f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="c01_split_000.xhtml#R_c01-fig-0001" id="c01-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 1.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c01-para-0311">
       <span aria-label="38" class="calibre20" epub:type="pagebreak" id="Page_38" role="doc-pagebreak">
       </span>
       There are a number of advantages to using
       <code class="calibre21">
        std::array
       </code>
       s instead of C-style arrays. They always know their own size, are not automatically cast to a pointer to avoid certain types of bugs, and have iterators to easily loop over the elements. Iterators are discussed in detail in
       <a class="calibre5" href="c17.xhtml">
        Chapter 17
       </a>
       , “Understanding Iterators and the Ranges Library.”
      </p>
      <p class="calibre13">
       The following example demonstrates how to use the
       <code class="calibre21">
        array
       </code>
       container. The
       <code class="calibre21">
        array
       </code>
       type is a
       <i class="calibre18">
        class template
       </i>
       accepting a number of
       <i class="calibre18">
        class template parameters
       </i>
       that allow you to specify how many elements you want to store in the container and their type. You provide
       <i class="calibre18">
        class template arguments
       </i>
       for class template parameters by specifying them between the angle brackets after
       <code class="calibre21">
        array
       </code>
       , as in
       <code class="calibre21">
        array&lt;int,3&gt;
       </code>
       .
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       , “Writing Generic Code with Templates,” discusses templates in detail. However, for now, just remember that you have to specify two arguments between the angle brackets; the first represents the type of the elements in the array, and the second represents the size of the array.
      </p>
      <pre class="calibre26" id="c01-code-0150"><code class="calibre21">array&lt;int, 3&gt; arr { 9, 8, 7 };</code>
<code class="calibre21">println("Array size = {}", arr.size());</code>
<code class="calibre21">println("2nd element = {}", arr[1]);</code></pre>
      <p class="calibre13">
       C++ supports
       <i class="calibre18">
        class template argument deduction
       </i>
       (CTAD), as discussed in detail in
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       . For now, it's enough to remember that this allows you to avoid having to specify the template arguments between angle brackets for certain class templates. CTAD works only when using an initializer because the compiler uses this initializer to automatically deduce the template arguments. This works for
       <code class="calibre21">
        std::array
       </code>
       , allowing you to define the previous array as follows:
      </p>
      <pre class="calibre26" id="c01-code-0151"><code class="calibre21">array arr { 9, 8, 7 };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0315">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           C-style arrays and
          </i>
          <code class="calibre21">
           std::array
          </code>
          <i class="calibre18">
           s have a fixed size, which must be known at compile time. They cannot grow or shrink at run time.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c01-para-0316">
       If you want an array with a dynamic size, it is recommended to use
       <code class="calibre21">
        std::vector
       </code>
       , as explained in the next section. A
       <code class="calibre21">
        vector
       </code>
       automatically increases in size when you add new elements to it.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0068">
      </span>
      <h3 class="calibre27" id="head-3-76">
       std::vector
      </h3>
      <p class="calibre13">
       The C++ Standard Library provides a number of different non-fixed-size containers that can be used to store information.
       <code class="calibre21">
        std::vector
       </code>
       , declared in
       <code class="calibre21">
        &lt;vector&gt;
       </code>
       , is an example of such a container. The
       <code class="calibre21">
        vector
       </code>
       class replaces the concept of C-style arrays with a much more flexible and safer mechanism.
       <span aria-label="39" class="calibre20" epub:type="pagebreak" id="Page_39" role="doc-pagebreak">
       </span>
       As a user, you need not worry about memory management, as a
       <code class="calibre21">
        vector
       </code>
       automatically allocates enough memory to hold its elements. A
       <code class="calibre21">
        vector
       </code>
       is dynamic, meaning that elements can be added and removed at run time.
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       , “Standard Library Containers,” goes into more detail regarding containers, but the basic use of a
       <code class="calibre21">
        vector
       </code>
       is straightforward, which is why it's introduced in the beginning of this book so that it can be used in examples. The following code demonstrates the basic functionality of
       <code class="calibre21">
        vector
       </code>
       :
      </p>
      <pre class="calibre26" id="c01-code-0152"><code class="calibre21"><span class="color">// Create a vector of integers.</span></code>
<code class="calibre21">vector&lt;int&gt; myVector { 11, 22 };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Add some more integers to the vector using push_back().</span></code>
<code class="calibre21">myVector.push_back(33);</code>
<code class="calibre21">myVector.push_back(44);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Access elements.</span></code>
<code class="calibre21">println("1st element: {}", myVector[0]);</code></pre>
      <p class="calibre13" id="c01-para-0318">
       <code class="calibre21">
        myVector
       </code>
       is declared as
       <code class="calibre21">
        vector&lt;int&gt;
       </code>
       . The angle brackets are required to specify the template arguments, just as with
       <code class="calibre21">
        std::array
       </code>
       . A
       <code class="calibre21">
        vector
       </code>
       is a generic container. It can contain almost any type of object, but all elements in a
       <code class="calibre21">
        vector
       </code>
       must be of the same type. This type is specified between the angle brackets. Templates are discussed in detail in
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       and
       <a class="calibre5" href="c26.xhtml">
        Chapter 26
       </a>
       , “Advanced Templates.”
      </p>
      <p class="calibre13">
       Just as
       <code class="calibre21">
        std::array
       </code>
       , the
       <code class="calibre21">
        vector
       </code>
       class template supports CTAD, allowing you to define
       <code class="calibre21">
        myVector
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c01-code-0153"><code class="calibre21">vector myVector { 11, 22 };</code></pre>
      <p class="calibre13">
       Again, an initializer is required for CTAD to work. The following is illegal:
      </p>
      <pre class="calibre26" id="c01-code-0154"><code class="calibre21">vector myVector;</code></pre>
      <p class="calibre13" id="c01-para-0321">
       To add elements to a
       <code class="calibre21">
        vector
       </code>
       , you can use the
       <code class="calibre21">
        push_back()
       </code>
       member function. Individual elements can be accessed using a similar syntax as for arrays, i.e.,
       <code class="calibre21">
        operator[]
       </code>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0069">
      </span>
      <h3 class="calibre27" id="head-3-77">
       std::pair
      </h3>
      <p class="calibre13">
       The
       <code class="calibre21">
        std::pair
       </code>
       class template is defined in
       <code class="calibre21">
        &lt;utility&gt;
       </code>
       . It groups together two values of possibly different types. The values are accessible through the
       <code class="calibre21">
        first
       </code>
       and
       <code class="calibre21">
        second
       </code>
       public data members. Here is an example:
      </p>
      <pre class="calibre26" id="c01-code-0155"><code class="calibre21">pair&lt;double, int&gt; myPair { 1.23, 5 };</code>
<code class="calibre21">println("{} {}", myPair.first, myPair.second);</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        pair
       </code>
       also supports CTAD, so you can define
       <code class="calibre21">
        myPair
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c01-code-0156"><code class="calibre21">pair myPair { 1.23, 5 };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0325">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           While you could write a function returning an
          </i>
          <code class="calibre21">
           std::pair
          </code>
          <i class="calibre18">
           , it is recommended to write a small
          </i>
          <code class="calibre21">
           struct
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           class
          </code>
          <i class="calibre18">
           containing the two values and return that from the function. The downside of returning a
          </i>
          <code class="calibre21">
           pair
          </code>
          <i class="calibre18">
           is that client code must use
          </i>
          <code class="calibre21">
           first
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           second
          </code>
          <i class="calibre18">
           to access the two values. By returning a proper
          </i>
          <code class="calibre21">
           struct
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           class
          </code>
          <i class="calibre18">
           , you can give more meaningful names to the two values
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <span aria-label="40" class="calibre20" epub:type="pagebreak" id="Page_40" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0071">
      </span>
      <h3 class="calibre27" id="head-3-78">
       std::optional
      </h3>
      <p class="calibre13" id="c01-para-0326">
       <code class="calibre21">
        std::optional
       </code>
       , defined in
       <code class="calibre21">
        &lt;optional&gt;
       </code>
       , holds a value of a specific type, or nothing. It is introduced already in this first chapter as it is a useful type to use in some of the examples throughout the book.
      </p>
      <p class="calibre13" id="c01-para-0327">
       Basically,
       <code class="calibre21">
        optional
       </code>
       can be used for parameters of a function if you want to allow for values to be optional. It is also often used as a return type from a function if the function can either return something or not. This removes the need to return “special” values from functions such as
       <code class="calibre21">
        nullptr
       </code>
       ,
       <code class="calibre21">
        -1
       </code>
       ,
       <code class="calibre21">
        EOF
       </code>
       , and so on. It also removes the need to write the function as returning a Boolean, representing success or failure, while storing the actual result of the function in an argument passed to the function as an output parameter (a parameter of type reference-to-non-
       <code class="calibre21">
        const
       </code>
       , discussed later in this chapter).
      </p>
      <p class="calibre13" id="c01-para-0328">
       The
       <code class="calibre21">
        optional
       </code>
       type is a class template, so you have to specify the actual type that you need between angle brackets, as in
       <code class="calibre21">
        optional&lt;int&gt;
       </code>
       . This syntax is similar to how you specify the type stored in a
       <code class="calibre21">
        vector
       </code>
       , for example
       <code class="calibre21">
        vector&lt;int&gt;
       </code>
       .
      </p>
      <p class="calibre13">
       Here is an example of a function returning an
       <code class="calibre21">
        optional
       </code>
       :
      </p>
      <pre class="calibre26" id="c01-code-0157"><code class="calibre21">optional&lt;int&gt; getData(bool giveIt)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (giveIt) {</code>
<code class="calibre21">        return 42;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return nullopt;  <span class="color">// or simply return {};</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You can call this function as follows:
      </p>
      <pre class="calibre26" id="c01-code-0158"><code class="calibre21">optional&lt;int&gt; data1 { getData(true) };</code>
<code class="calibre21">optional&lt;int&gt; data2 { getData(false) };</code></pre>
      <p class="calibre13">
       To determine whether an
       <code class="calibre21">
        optional
       </code>
       has a value, use the
       <code class="calibre21">
        has_value()
       </code>
       member function, or simply use the
       <code class="calibre21">
        optional
       </code>
       in an
       <code class="calibre21">
        if
       </code>
       statement:
      </p>
      <pre class="calibre26" id="c01-code-0159"><code class="calibre21">println("data1.has_value = {}", data1.has_value());</code>
<code class="calibre21">if (!data2) {</code>
<code class="calibre21">    println("data2 has no value.");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       If an
       <code class="calibre21">
        optional
       </code>
       has a value, you can retrieve it with
       <code class="calibre21">
        value()
       </code>
       or with the dereferencing operator *. This operator is discussed in detail later in this chapter in the context of pointers.
      </p>
      <pre class="calibre26" id="c01-code-0160"><code class="calibre21">println("data1.value = {}", data1.value());</code>
<code class="calibre21">println("data1.value = {}", *data1);</code></pre>
      <p class="calibre13" id="c01-para-0333">
       If you call
       <code class="calibre21">
        value()
       </code>
       on an empty
       <code class="calibre21">
        optional
       </code>
       , an
       <code class="calibre21">
        std::bad_optional_access
       </code>
       exception is thrown. Exceptions are introduced later in this chapter.
      </p>
      <p class="calibre13">
       <code class="calibre21">
        value_or()
       </code>
       can be used to return either the value of an
       <code class="calibre21">
        optional
       </code>
       or another value when the
       <code class="calibre21">
        optional
       </code>
       is empty:
      </p>
      <pre class="calibre26" id="c01-code-0161"><code class="calibre21">println("data2.value = {}", data2.value_or(0));</code></pre>
      <p class="calibre13" id="c01-para-0335">
       You cannot store a reference (discussed later in this chapter) in an
       <code class="calibre21">
        optional
       </code>
       , so
       <code class="calibre21">
        optional&lt;T&amp;&gt;
       </code>
       does not work. Instead, you can store a pointer in an
       <code class="calibre21">
        optional
       </code>
       .
      </p>
     </section>
     <span aria-label="41" class="calibre20" epub:type="pagebreak" id="Page_41" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0072">
      </span>
      <h3 class="calibre27" id="head-3-79">
       Structured Bindings
      </h3>
      <p class="calibre13" id="c01-para-0336">
       A
       <i class="calibre18">
        structured binding
       </i>
       allows you to declare multiple variables that are initialized with elements from a data structure such as an
       <code class="calibre21">
        array
       </code>
       ,
       <code class="calibre21">
        struct
       </code>
       , or
       <code class="calibre21">
        pair
       </code>
       .
      </p>
      <p class="calibre13">
       Assume you have the following
       <code class="calibre21">
        std::array
       </code>
       :
      </p>
      <pre class="calibre26" id="c01-code-0162"><code class="calibre21">array values { 11, 22, 33 };</code></pre>
      <p class="calibre13">
       You can declare three variables,
       <code class="calibre21">
        x
       </code>
       ,
       <code class="calibre21">
        y
       </code>
       , and
       <code class="calibre21">
        z
       </code>
       , initialized with the three values from the array as follows. You have to use the
       <code class="calibre21">
        auto
       </code>
       keyword for structured bindings, i.e., you cannot, for example, specify
       <code class="calibre21">
        int
       </code>
       instead of
       <code class="calibre21">
        auto
       </code>
       .
      </p>
      <pre class="calibre26" id="c01-code-0163"><code class="calibre21">auto [x, y, z] { values };</code></pre>
      <p class="calibre13" id="c01-para-0339">
       The number of variables declared with the structured binding has to match the number of values in the expression on the right.
      </p>
      <p class="calibre13">
       Structured bindings also work with
       <code class="calibre21">
        struct
       </code>
       s if all non-static members are public. Here's an example:
      </p>
      <pre class="calibre26" id="c01-code-0164"><code class="calibre21">struct Point { double m_x, m_y, m_z; };</code>
<code class="calibre21">Point point;</code>
<code class="calibre21">point.m_x = 1.0; point.m_y = 2.0; point.m_z = 3.0;</code>
<code class="calibre21">auto [x, y, z] { point };</code></pre>
      <p class="calibre13">
       As a final example, the following code snippet decomposes the elements of a
       <code class="calibre21">
        pair
       </code>
       into separate variables:
      </p>
      <pre class="calibre26" id="c01-code-0165"><code class="calibre21">pair myPair { "hello", 5 };</code>
<code class="calibre21">auto [theString, theInt] { myPair };  <span class="color">// Decompose using structured bindings.</span></code>
<code class="calibre21">println("theString: {}", theString);</code>
<code class="calibre21">println("theInt: {}", theInt);</code></pre>
      <p class="calibre13" id="c01-para-0342">
       It is also possible to create a set of references-to-non-
       <code class="calibre21">
        const
       </code>
       or references-to-
       <code class="calibre21">
        const
       </code>
       using the structured bindings syntax, by using
       <code class="calibre21">
        auto&amp;
       </code>
       or
       <code class="calibre21">
        const auto&amp;
       </code>
       instead of
       <code class="calibre21">
        auto
       </code>
       . Both references-to-non-
       <code class="calibre21">
        const
       </code>
       and references-to-
       <code class="calibre21">
        const
       </code>
       are discussed later in this chapter.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0073">
      </span>
      <h3 class="calibre27" id="head-3-80">
       Loops
      </h3>
      <p class="calibre13" id="c01-para-0343">
       Computers are great for doing the same thing over and over. C++ provides four looping mechanisms: the
       <code class="calibre21">
        while
       </code>
       loop,
       <code class="calibre21">
        do
       </code>
       /
       <code class="calibre21">
        while
       </code>
       loop,
       <code class="calibre21">
        for
       </code>
       loop, and
       <i class="calibre18">
        range-based
       </i>
       <code class="calibre21">
        for
       </code>
       loop.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0074">
       </span>
       <h4 class="calibre29" id="head-4-33">
        The while Loop
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         while
        </code>
        loop lets you perform a block of code repeatedly as long as an expression evaluates to
        <code class="calibre21">
         true
        </code>
        . For example, the following completely silly code prints “This is silly.” five times:
       </p>
       <pre class="calibre26" id="c01-code-0166"><code class="calibre21">int i { 0 };</code>
<code class="calibre21">while (i &lt; 5) {</code>
<code class="calibre21">    println("This is silly.");</code>
<code class="calibre21">    ++i;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0345">
        <span aria-label="42" class="calibre20" epub:type="pagebreak" id="Page_42" role="doc-pagebreak">
        </span>
        The keyword
        <code class="calibre21">
         break
        </code>
        can be used within a loop to immediately get out of the loop and resume execution of the program starting at the line of code following the loop. The keyword
        <code class="calibre21">
         continue
        </code>
        can be used to return to the top of the loop and reevaluate the
        <code class="calibre21">
         while
        </code>
        expression. However, using
        <code class="calibre21">
         continue
        </code>
        in loops is often considered poor style because it causes the execution of a program to jump around somewhat haphazardly, so use it sparingly.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0075">
       </span>
       <h4 class="calibre29" id="head-4-34">
        The do/while Loop
       </h4>
       <p class="calibre13">
        C++ has a variation on the
        <code class="calibre21">
         while
        </code>
        loop called
        <code class="calibre21">
         do
        </code>
        /
        <code class="calibre21">
         while
        </code>
        . It works similarly to the
        <code class="calibre21">
         while
        </code>
        loop, except that the code to be executed comes first, and the conditional check for whether to continue happens at the end. In this way, you can use a loop when you want a block of code to always be executed at least once and possibly additional times based on some condition. The example that follows prints the statement, “This is silly.” once, even though the condition ends up being false:
       </p>
       <pre class="calibre26" id="c01-code-0167"><code class="calibre21">int i { 100 };</code>
<code class="calibre21">do {</code>
<code class="calibre21">    println("This is silly.");</code>
<code class="calibre21">    ++i;</code>
<code class="calibre21">} while (i &lt; 5);</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0076">
       </span>
       <h4 class="calibre29" id="head-4-35">
        The for Loop
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         for
        </code>
        loop provides another syntax for looping. Any
        <code class="calibre21">
         for
        </code>
        loop can be converted to a
        <code class="calibre21">
         while
        </code>
        loop, and vice versa. However, the
        <code class="calibre21">
         for
        </code>
        loop syntax is often more convenient because it looks at a loop in terms of a starting expression, an ending condition, and a statement to execute at the end of every iteration. In the following code,
        <code class="calibre21">
         i
        </code>
        is initialized to 0; the loop continues as long as
        <code class="calibre21">
         i
        </code>
        is less than 5; and at the end of every iteration,
        <code class="calibre21">
         i
        </code>
        is incremented by 1. This code does the same thing as the
        <code class="calibre21">
         while
        </code>
        loop example earlier but is more readable because the starting value, ending condition, and per-iteration statements are all visible on one line.
       </p>
       <pre class="calibre26" id="c01-code-0168"><code class="calibre21">for (int i { 0 }; i &lt; 5; ++i) {</code>
<code class="calibre21">    println("This is silly.");</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0077">
       </span>
      </section>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
