<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   14Handling Errors
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_008.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_010.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c14_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c14_1">
      <span aria-label="533" class="calibre17" epub:type="pagebreak" id="Page_533" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c14">
      </span>
      <span class="calibre">
       14
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Handling Errors
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c14-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c14-list-0001">
         <li class="calibre9" id="c14-li-0001">
          How to handle errors in C++, including pros and cons of exceptions
         </li>
         <li class="calibre9" id="c14-li-0002">
          The syntax of exceptions
         </li>
         <li class="calibre9" id="c14-li-0003">
          Exception class hierarchies and handling exceptions polymorphically
         </li>
         <li class="calibre9" id="c14-li-0004">
          How to rethrow caught exceptions
         </li>
         <li class="calibre9" id="c14-li-0005">
          Stack unwinding and cleanup
         </li>
         <li class="calibre9" id="c14-li-0006">
          How to embed, inside a custom exception, the exact source code location where an exception occurred
         </li>
         <li class="calibre9" id="c14-li-0007">
          How to embed the entire stack trace, also known as call stack, in a custom exception
         </li>
         <li class="calibre9" id="c14-li-0008">
          Common error-handling situations
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c14-fea-0002">
        </span>
        <h3 class="calibre30" id="head-2-158">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c14-sec-0003">
        </span>
        <p class="calibre25" id="c14-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c14-para-0004">
      Inevitably, your C++ programs will encounter errors during execution. The program might be unable to open a file, the network connection might go down, or the user might enter an incorrect value, to name a few possibilities. The C++ language provides a feature called
      <i class="calibre18">
       exceptions
      </i>
      to handle these
      <i class="calibre18">
       exceptional
      </i>
      but not
      <i class="calibre18">
       unexpected
      </i>
      situations.
     </p>
     <p class="calibre13" id="c14-para-0005">
      <span aria-label="534" class="calibre20" epub:type="pagebreak" id="Page_534" role="doc-pagebreak">
      </span>
      Most code examples in this book so far have generally ignored error conditions for brevity. This chapter rectifies that simplification by teaching you how to incorporate error handling into your programs from their beginnings. It focuses on C++ exceptions, including the details of their syntax, and describes how to employ them effectively to create well-designed error-handling programs.
     </p>
     <p class="calibre13" id="c14-para-0006">
      The chapter also discusses how you can write your own exception classes. This includes discussing how to automatically embed both, the exact location in your source code where an exception occurred, as well as the full stack trace at the moment the exception was raised. Both of these help tremendously in diagnosing any errors.
     </p>
    </section>
    <section aria-labelledby="head-2-159" class="calibre2">
     <span class="calibre" id="c14-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-159">
      ERRORS AND EXCEPTIONS
     </h2>
     <p class="calibre13" id="c14-para-0007">
      No program exists in isolation; they all depend on external facilities such as interfaces with the operating system, networks and file systems, external code such as third-party libraries, and user input. Each of these areas can introduce situations that require you to respond to problems your program may encounter. These potential problems can be referred to with the general term
      <i class="calibre18">
       exceptional situations
      </i>
      . Even perfectly written programs encounter errors and exceptional situations. Thus, anyone who writes professional computer programs must include error-handling capabilities. Some languages, such as C, do not include many specific language facilities for error handling. Programmers using these languages generally rely on return values from functions and other ad hoc approaches. Other languages, such as Java, enforce the use of a language feature called
      <i class="calibre18">
       exceptions
      </i>
      as an error-handling mechanism. C++ lies between these extremes. It provides language support for exceptions but does not require their use. However, you can't ignore exceptions entirely in C++ because a few basic facilities, such as memory allocation routines, use them by default, and several classes from the Standard Library use exceptions as well.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-301">
       What Are Exceptions, Anyway?
      </h3>
      <p class="calibre13" id="c14-para-0008">
       <i class="calibre18">
        Exceptions
       </i>
       are a mechanism for a piece of code to notify another piece of code of an “exceptional” situation or error condition without progressing through the normal code paths. The code that encounters the error
       <i class="calibre18">
        throws
       </i>
       the exception, and the code that handles the exception
       <i class="calibre18">
        catches
       </i>
       it. Exceptions do not follow the fundamental rule of step-by-step execution to which you are accustomed. When a piece of code throws an exception, the program control immediately stops executing code step-by-step and transitions to the exception handler, which could be anywhere from the next line in the same function to several function calls up the stack. If you like sports analogies, you can think of the code that throws an exception as an outfielder throwing a baseball back to the infield, where the nearest infielder (closest exception handler) catches it.
       <a class="calibre5" href="#c14-fig-0001" id="R_c14-fig-0001">
        Figure 14.1
       </a>
       shows a hypothetical stack of three function calls. Function
       <code class="calibre21">
        A()
       </code>
       has the exception handler. It calls function
       <code class="calibre21">
        B()
       </code>
       , which calls function
       <code class="calibre21">
        C()
       </code>
       , which throws the exception.
      </p>
      <figure class="calibre36">
       <img alt="Three frames are stacked on top of each other. The top frame is an A parentheses stack frame and features an icon of a hand holding something. The middle frame is a B parentheses stack frame. The bottom frame is a C parentheses stack frame." class="center" src="images/c14f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c14-fig-0001" id="c14-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 14.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c14-para-0009">
       <a class="calibre5" href="#c14-fig-0002" id="R_c14-fig-0002">
        Figure 14.2
       </a>
       shows the handler catching the exception. The stack frames for
       <code class="calibre21">
        C()
       </code>
       and
       <code class="calibre21">
        B()
       </code>
       have been removed, leaving only
       <code class="calibre21">
        A()
       </code>
       .
      </p>
      <span aria-label="535" class="calibre20" epub:type="pagebreak" id="Page_535" role="doc-pagebreak">
      </span>
      <figure class="calibre36">
       <img alt="The image depicts a hand holding a grid-like structure between the thumb and index finger. The structure represents an A parentheses stack frame." class="center" src="images/c14f002.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c14-fig-0002" id="c14-fig-0002" role="doc-backlink">
           <b class="calibre14">
            FIGURE 14.2
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c14-para-0010">
       Most modern programming languages, such as C# and Java, have support for exceptions, so it's no surprise that C++ has full-fledged support for them as well. However, if you are coming from C, then exceptions are something new; but once you get used to them, you probably don't want to go back.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-302">
       Why Exceptions in C++ Are a Good Thing
      </h3>
      <p class="calibre13" id="c14-para-0011">
       As mentioned earlier, run-time errors in programs are inevitable. Despite that fact, error handling in most C and C++ programs is messy and ad hoc. The de facto C error-handling standard, which was carried over into many C++ programs, uses integer function return codes, and the
       <code class="calibre21">
        errno
       </code>
       macro to signify errors. Each thread has its own
       <code class="calibre21">
        errno
       </code>
       value.
       <code class="calibre21">
        errno
       </code>
       acts as a thread-local integer variable that functions can use to communicate errors back to calling functions.
      </p>
      <p class="calibre13" id="c14-para-0012">
       Unfortunately, the integer return codes and
       <code class="calibre21">
        errno
       </code>
       are used inconsistently. Some functions might choose to return 0 for success and -1 for an error. If they return -1, they also set
       <code class="calibre21">
        errno
       </code>
       to an error code. Other functions return 0 for success and nonzero for an error, with the actual return value specifying the error code. These functions do not use
       <code class="calibre21">
        errno
       </code>
       . Still others return 0 for failure instead of for success, presumably because 0 always evaluates to
       <code class="calibre21">
        false
       </code>
       in C and C++.
      </p>
      <p class="calibre13" id="c14-para-0013">
       These inconsistencies can cause problems because programmers encountering a new function often assume that its return codes are the same as other similar functions. That is not always true. For example, on the Solaris 11 operating system, there are two different libraries of synchronization objects: the Portable Operating System Interface (POSIX) version and the Solaris version. The function to initialize a semaphore in the POSIX version is called
       <code class="calibre21">
        sem_init()
       </code>
       , and the function to initialize a semaphore in the Solaris version is called
       <code class="calibre21">
        sema_init()
       </code>
       . As if that weren't confusing enough, the two functions handle error codes differently!
       <code class="calibre21">
        sem_init()
       </code>
       returns -1 and sets
       <code class="calibre21">
        errno
       </code>
       on error, while
       <code class="calibre21">
        sema_init()
       </code>
       returns the error code directly as a positive integer and does not set
       <code class="calibre21">
        errno
       </code>
       .
      </p>
      <p class="calibre13" id="c14-para-0014">
       Another problem is that the return type of functions in C++ can be of only one type, so if you need to return both an error and a value, you must find an alternative mechanism. One solution is to return an
       <code class="calibre21">
        std::pair
       </code>
       or
       <code class="calibre21">
        tuple
       </code>
       , an object that you can use to store two or more types. The
       <code class="calibre21">
        pair
       </code>
       class is introduced in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       , “A Crash Course in C++ and the Standard Library,” while
       <code class="calibre21">
        tuple
       </code>
       is discussed in the upcoming chapters that cover the Standard Library. Starting with C++23, you can return an
       <code class="calibre21">
        std::expected
       </code>
       from a function, which can contain either the result of the function or an error if something went wrong.
       <a class="calibre5" href="c24.xhtml">
        Chapter 24
       </a>
       , “Additional Vocabulary Types,” discusses
       <code class="calibre21">
        expected
       </code>
       in detail. Another choice is to define your own struct or class that contains several values and return an instance of that struct or class from your function. Yet another option is to return the value or error through a reference parameter or to make the error code one possible value of the return type, such as a
       <code class="calibre21">
        nullptr
       </code>
       pointer. In all these solutions, the caller is responsible for explicitly checking for any errors returned from the function, and if it doesn't handle the error itself, it should propagate the error to its caller. Unfortunately, this often results in the loss of critical details about the error.
      </p>
      <p class="calibre13" id="c14-para-0015">
       C programmers may be familiar with a mechanism known as
       <code class="calibre21">
        setjmp()/longjmp()
       </code>
       . This mechanism cannot be used correctly in C++, because it bypasses scoped destructors on the stack. You should avoid it at all costs, even in C programs; therefore, this book does not explain the details of how to use it.
      </p>
      <p class="calibre13">
       <span aria-label="536" class="calibre20" epub:type="pagebreak" id="Page_536" role="doc-pagebreak">
       </span>
       Exceptions provide an easier, more consistent, and safer mechanism for error handling. There are several specific advantages of exceptions over the ad hoc approaches in C and C++:
      </p>
      <ul class="check" id="c14-list-0002">
       <li class="calibre9" id="c14-li-0009">
        When return codes are used as an error reporting mechanism, you might forget to check the return code and properly handle it either locally or by propagating it upward. The
        <code class="calibre21">
         [[nodiscard]]
        </code>
        attribute, introduced in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        , offers a possible solution to prevent return codes from being ignored, but it's not foolproof either. Exceptions cannot be forgotten or ignored: if your program fails to catch an exception, it terminates.
       </li>
       <li class="calibre9" id="c14-li-0010">
        When integer return codes are used, they generally do not contain sufficient information. You can use exceptions to pass as much information as you want from the code that finds the error to the code that handles it. Exceptions can also be used to communicate information other than errors, though many developers, including myself, consider that an abuse of the exception mechanism.
       </li>
       <li class="calibre9" id="c14-li-0011">
        Exception handling can skip levels of the call stack. That is, a function can handle an error that occurred several function calls down the stack, without error-handling code in the intermediate functions. Return codes require each level of the call stack to clean up explicitly after the previous level and to explicitly propagate the error code.
       </li>
      </ul>
      <p class="calibre13" id="c14-para-0017">
       In some compilers in the past, exception handling added a tiny amount of overhead to any function that had an exception handler. For most modern compilers there is a trade-off in that there is almost no, or even zero, overhead in the non-throwing case, and only some slight overhead when you actually throw something. This trade-off is not a bad thing. Exceptions should not be used for controlling the standard execution flow of a program, such as returning a value from a function. Exceptions should be used only to handle exceptional events that are generally not encountered in normal program use, for example, a failure while reading from a file on disk. All this means that using exceptions actually results in faster code for the non-error case compared to an implementation using error return codes.
      </p>
      <p class="calibre13" id="c14-para-0018">
       Exception handling is not enforced in C++. In Java, for example, it is enforced. A Java function that does not specify a list of exceptions that it can possibly throw is not allowed to throw any exceptions. In C++, it is just the opposite: a function can throw any exception it wants, unless it specifies that it will not throw any exceptions using the
       <code class="calibre21">
        noexcept
       </code>
       keyword, which is discussed later in this chapter!
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0007">
      </span>
      <h3 class="calibre27" id="head-3-303">
       Recommendation
      </h3>
      <p class="calibre13" id="c14-para-0019">
       I recommend exceptions as a useful mechanism for error handling. I feel that the structure and error-handling formalization that exceptions provide outweigh the less desirable aspects. Thus, the remainder of this chapter focuses on exceptions. Also, many popular libraries, such as the Standard Library and Boost, use exceptions, so you need to be prepared to handle them.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-160" class="calibre2">
     <span class="calibre" id="c14-sec-0008">
     </span>
     <h2 class="calibre6" id="head-2-160">
      EXCEPTION MECHANICS
     </h2>
     <p class="calibre13">
      Exceptional situations arise frequently in file input and output. The following is a function to open a file, read a list of integers from the file, and return the integers in an
      <code class="calibre21">
       std::vector
      </code>
      data structure. The lack of error handling should jump out at you:
     </p>
     <pre class="calibre26" id="c14-code-0001"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<span aria-label="537" class="calibre20" epub:type="pagebreak" id="Page_537" role="doc-pagebreak"></span><code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    <span class="color">// Read the integers one-by-one and add them to a vector.</span></code>
<code class="calibre21">    vector&lt;int&gt; integers;</code>
<code class="calibre21">    int temp;</code>
<code class="calibre21">    while (inputStream &gt;&gt; temp) {</code>
<code class="calibre21">        integers.push_back(temp);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return integers;</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      The following line keeps reading values from the
      <code class="calibre21">
       ifstream
      </code>
      until the end of the file is reached or until an error occurs:
     </p>
     <pre class="calibre26" id="c14-code-0002"><code class="calibre21">while (inputStream&gt;&gt; temp) {</code></pre>
     <p class="calibre13" id="c14-para-0022">
      If the
      <code class="calibre21">
       &gt;&gt;
      </code>
      operator encounters an error, it sets the fail bit of the
      <code class="calibre21">
       ifstream
      </code>
      object. In that case, the
      <code class="calibre21">
       bool()
      </code>
      conversion operator returns
      <code class="calibre21">
       false
      </code>
      , and the
      <code class="calibre21">
       while
      </code>
      loop terminates. Streams are discussed in more detail in
      <a class="calibre5" href="c13.xhtml">
       Chapter 13
      </a>
      , “Demystifying C++ I/O.”
     </p>
     <p class="calibre13">
      You might use
      <code class="calibre21">
       readIntegerFile()
      </code>
      like this:
     </p>
     <pre class="calibre26" id="c14-code-0003"><code class="calibre21">const string filename { "IntegerFile.txt" };</code>
<code class="calibre21">vector&lt;int&gt; myInts { readIntegerFile(filename) };</code>
<code class="calibre21">println("{} ", myInts);</code></pre>
     <p class="calibre13" id="c14-para-0024">
      The rest of this section shows how to add error handling with exceptions, but first, we need to delve a bit deeper into how you throw and catch exceptions.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-304">
       Throwing and Catching Exceptions
      </h3>
      <p class="calibre13" id="c14-para-0025">
       Using exceptions consists of providing two parts in your program: a
       <code class="calibre21">
        try/catch
       </code>
       construct to handle an exception, and a
       <code class="calibre21">
        throw
       </code>
       statement that throws an exception. Both must be present in some form to make exceptions work. However, in many cases, the
       <code class="calibre21">
        throw
       </code>
       happens deep inside some library (including the C++ runtime), and the programmer never sees it, but still has to react to it using a
       <code class="calibre21">
        try/catch
       </code>
       construct.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        try/catch
       </code>
       construct looks like this:
      </p>
      <pre class="calibre26" id="c14-code-0004"><code class="calibre21">try {</code>
<code class="calibre21">    <span class="color">// … code which may result in an exception being thrown</span></code>
<code class="calibre21">} catch (exception-type1 exception-name) {</code>
<code class="calibre21">    <span class="color">// … code which responds to the exception of type 1</span></code>
<code class="calibre21">} catch (exception-type2 exception-name) {</code>
<code class="calibre21">    <span class="color">// … code which responds to the exception of type 2</span></code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// … remaining code</span></code></pre>
      <p class="calibre13" id="c14-para-0027">
       The code that may result in an exception being thrown might contain a
       <code class="calibre21">
        throw
       </code>
       directly. It might also be calling a function that either directly throws an exception or calls—by some unknown number of layers of calls—a function that throws an exception.
      </p>
      <p class="calibre13" id="c14-para-0028">
       If no exception is thrown, no code from any
       <code class="calibre21">
        catch
       </code>
       block is executed, and the “remaining code” that follows will follow the last statement executed in the
       <code class="calibre21">
        try
       </code>
       block.
      </p>
      <p class="calibre13" id="c14-para-0029">
       <span aria-label="538" class="calibre20" epub:type="pagebreak" id="Page_538" role="doc-pagebreak">
       </span>
       If an exception is thrown, any code following the
       <code class="calibre21">
        throw
       </code>
       or following the call that resulted in the
       <code class="calibre21">
        throw
       </code>
       is not executed; instead, control immediately goes to the right
       <code class="calibre21">
        catch
       </code>
       block, depending on the type of the exception that is thrown.
      </p>
      <p class="calibre13" id="c14-para-0030">
       If the
       <code class="calibre21">
        catch
       </code>
       block does not do a control transfer—for example, by returning from the function, throwing a new exception, or rethrowing the caught exception—then the “remaining code” is executed after the last statement of that
       <code class="calibre21">
        catch
       </code>
       block.
      </p>
      <p class="calibre13">
       The simplest example to demonstrate exception handling is avoiding division-by-zero. The following example throws an exception of type
       <code class="calibre21">
        std::invalid_argument
       </code>
       , defined in
       <code class="calibre21">
        &lt;stdexcept&gt;
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0005"><code class="calibre21">double safeDivide(double num, double den)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (den == 0) { throw invalid_argument { "Divide by zero" }; }</code>
<code class="calibre21">    return num / den;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        println("{}", safeDivide(5, 2));</code>
<code class="calibre21">        println("{}", safeDivide(10, 0));</code>
<code class="calibre21">        println("{}", safeDivide(3, 3));</code>
<code class="calibre21">    } catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">        println("Caught exception: {}", e.what());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c14-code-0006"><code class="calibre21">2.5</code>
<code class="calibre21">Caught exception: Divide by zero</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        throw
       </code>
       is a keyword in C++ and is the only way to throw an exception. In the code snippet we throw a new instance of
       <code class="calibre21">
        invalid_argument
       </code>
       . It is one of the standard exceptions provided by the C++ Standard Library. All Standard Library exceptions form a hierarchy, which is discussed later in this chapter. Each class in the hierarchy supports a
       <code class="calibre21">
        what()
       </code>
       member function that returns a
       <code class="calibre21">
        const char*
       </code>
       string describing the exception. This is the string you provide in the constructor of the exception.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0034">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Even though the return type of
          </i>
          <code class="calibre21">
           what()
          </code>
          <i class="calibre18">
           is
          </i>
          <code class="calibre21">
           const char*
          </code>
          <i class="calibre18">
           , exceptions can support Unicode strings if you encode them using UTF-8. See
           <a class="calibre5" href="c21.xhtml">
            Chapter 21
           </a>
           , “String Localization and Regular Expressions,” for details on Unicode strings.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Let's go back to the
       <code class="calibre21">
        readIntegerFile()
       </code>
       function. The most likely problem to occur is for the file open to fail. That's a perfect situation for throwing an exception. The following code throws an exception of type
       <code class="calibre21">
        std::exception
       </code>
       , defined in
       <code class="calibre21">
        &lt;exception&gt;
       </code>
       , if the file fails to open:
      </p>
      <pre class="calibre26" id="c14-code-0007"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    <b class="calibre14">if (inputStream.fail()) {</b></code>
<span aria-label="539" class="calibre20" epub:type="pagebreak" id="Page_539" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// We failed to open the file: throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">throw exception {};</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the integers one-by-one and add them to a vector.</span></code>
<code class="calibre21">    vector&lt;int&gt; integers;</code>
<code class="calibre21">    int temp;</code>
<code class="calibre21">    while (inputStream &gt;&gt; temp) {</code>
<code class="calibre21">        integers.push_back(temp);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return integers;</code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0037">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Always document the possible exceptions a function can throw in its code documentation, because users of the function need to know which exceptions might get thrown so they can properly handle them
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c14-para-0038">
       If the function fails to open the file and executes the
       <code class="calibre21">
        throw exception{};
       </code>
       statement, the rest of the function is skipped, and control transitions to the nearest exception handler.
      </p>
      <p class="calibre13">
       Throwing exceptions in your code is most useful when you also write code that handles them. Exception handling is a way to “try” a block of code, with another block of code designated to react to any problems that might occur. In the following
       <code class="calibre21">
        main()
       </code>
       function, the
       <code class="calibre21">
        catch
       </code>
       statement reacts to any exception of type
       <code class="calibre21">
        exception
       </code>
       that was thrown within the
       <code class="calibre21">
        try
       </code>
       block by printing an error message. If a
       <code class="calibre21">
        try
       </code>
       block finishes without throwing an exception, the
       <code class="calibre21">
        catch
       </code>
       blocks are skipped. You can think of
       <code class="calibre21">
        try
       </code>
       /
       <code class="calibre21">
        catch
       </code>
       blocks as glorified
       <code class="calibre21">
        if
       </code>
       statements:
       <i class="calibre18">
        if
       </i>
       an exception is thrown in the
       <code class="calibre21">
        try
       </code>
       block,
       <i class="calibre18">
        then
       </i>
       execute a
       <code class="calibre21">
        catch
       </code>
       block,
       <i class="calibre18">
        else
       </i>
       skip all
       <code class="calibre21">
        catch
       </code>
       blocks.
      </p>
      <pre class="calibre26" id="c14-code-0008"><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    const string filename { "IntegerFile.txt" };</code>
<code class="calibre21">    vector&lt;int&gt; myInts;</code>
<code class="calibre21">    <b class="calibre14">try {</b></code>
<code class="calibre21">        myInts = readIntegerFile(filename);</code>
<code class="calibre21">    <b class="calibre14">} catch (const exception&amp; e) {</b></code>
<code class="calibre21">        <b class="calibre14">println(cerr, "Unable to open file {}", filename);</b></code>
<code class="calibre21">        <b class="calibre14">return 1;</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">    println("{} ", myInts);</code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0041">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Although by default streams do not throw exceptions, you can tell the streams to throw exceptions for error conditions by calling their
          </i>
          <code class="calibre21">
           exceptions()
          </code>
          <i class="calibre18">
           member function. However, most compilers give useless information in the stream exceptions they throw. For such compilers, it might be better to deal with the stream state directly instead of using exceptions. This book does not use stream exceptions.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <span aria-label="540" class="calibre20" epub:type="pagebreak" id="Page_540" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0013">
      </span>
      <h3 class="calibre27" id="head-3-305">
       Exception Types
      </h3>
      <p class="calibre13">
       You can throw an exception of any type. The earlier example throws an object of type
       <code class="calibre21">
        std::exception
       </code>
       , but exceptions do not need to be objects. You could throw a simple
       <code class="calibre21">
        int
       </code>
       like this:
      </p>
      <pre class="calibre26" id="c14-code-0009"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    if (inputStream.fail()) {</code>
<code class="calibre21">        <span class="color">// We failed to open the file: throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">throw 5;</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You would then need to change the
       <code class="calibre21">
        catch
       </code>
       statement as follows:
      </p>
      <pre class="calibre26" id="c14-code-0010"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21"><b class="calibre14">} catch (int e) {</b></code>
<code class="calibre21">    <b class="calibre14">println(cerr, "Unable to open file {} (Error Code {})", filename, e);</b></code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Alternatively, you could throw a
       <code class="calibre21">
        const char*
       </code>
       C-style string. This technique is sometimes useful because the string can contain information about the exception:
      </p>
      <pre class="calibre26" id="c14-code-0011"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    if (inputStream.fail()) {</code>
<code class="calibre21">        <span class="color">// We failed to open the file: throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">throw "Unable to open file";</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       When you catch the
       <code class="calibre21">
        const char*
       </code>
       exception, you can print the result as follows:
      </p>
      <pre class="calibre26" id="c14-code-0012"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21"><b class="calibre14">} catch (const char* e) {</b></code>
<code class="calibre21">    <b class="calibre14">println(cerr, "{}", e);</b></code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Despite the previous examples, keep the following in mind:
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature2">
         <h1 class="calibre3">
          NOTE
         </h1>
         <p class="calibre25">
          <i class="calibre18">
           You should generally throw objects rather than other data types as exceptions for two reasons:
          </i>
         </p>
         <ul class="check4" id="c14-list-0003">
          <li class="calibre9" id="c14-li-0012">
           <i class="calibre18">
            Objects convey information by their class name.
           </i>
          </li>
          <li class="calibre9" id="c14-li-0013">
           <i class="calibre18">
            Objects can store all kinds of information, including strings that describe the exception.
           </i>
          </li>
         </ul>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c14-para-0048">
       <span aria-label="541" class="calibre20" epub:type="pagebreak" id="Page_541" role="doc-pagebreak">
       </span>
       The C++ Standard Library defines a number of predefined exception classes structured in a class hierarchy, discussed later in this chapter. Additionally, you can write your own exception classes and fit them in the standard hierarchy, as you'll also learn later in this chapter.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0015">
      </span>
      <h3 class="calibre27" id="head-3-306">
       Catching Exception Objects as Reference-to-const
      </h3>
      <p class="calibre13">
       In the earlier example in which
       <code class="calibre21">
        readIntegerFile()
       </code>
       throws an object of type
       <code class="calibre21">
        exception
       </code>
       , the
       <code class="calibre21">
        catch
       </code>
       handler looks like this:
      </p>
      <pre class="calibre26" id="c14-code-0013"><code class="calibre21">} catch (const exception&amp; e) {</code></pre>
      <p class="calibre13">
       However, there is no requirement to catch objects as reference-to-
       <code class="calibre21">
        const
       </code>
       . You could catch the object by value like this:
      </p>
      <pre class="calibre26" id="c14-code-0014"><code class="calibre21">} catch (exception e) {</code></pre>
      <p class="calibre13">
       Alternatively, you could catch the object as reference-to-non-
       <code class="calibre21">
        const
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0015"><code class="calibre21">} catch (exception&amp; e) {</code></pre>
      <p class="calibre13" id="c14-para-0052">
       Also, as you saw in the
       <code class="calibre21">
        const char*
       </code>
       example earlier, you can catch pointers to exceptions, as long as pointers to exceptions are thrown.
      </p>
      <p class="calibre13">
       Still, I recommend sticking with the following advice:
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0054">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Always throw objects as exceptions, and always catch exception objects as reference-to-
          </i>
          <code class="calibre21">
           const
          </code>
          <i class="calibre18">
           ! This avoids object slicing (see
           <a class="calibre5" href="c10_split_000.xhtml">
            Chapter 10
           </a>
           , “Discovering Inheritance Techniques”), which could happen when you catch exception objects by value. Capturing by reference-to-non-
          </i>
          <code class="calibre21">
           const
          </code>
          <i class="calibre18">
           is not recommended either, as caught exceptions are normally never modified.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-307">
       Throwing and Catching Multiple Exceptions
      </h3>
      <p class="calibre13">
       Failure to open the file is not the only problem
       <code class="calibre21">
        readIntegerFile()
       </code>
       could encounter. Reading the data from the file can cause an error if it is formatted incorrectly. Here is an implementation of
       <code class="calibre21">
        readIntegerFile()
       </code>
       that throws an exception if it cannot either open the file or read the data correctly. This time, it uses a
       <code class="calibre21">
        runtime_error
       </code>
       , derived from
       <code class="calibre21">
        exception
       </code>
       and which allows you to specify a descriptive string in its constructor. The
       <code class="calibre21">
        runtime_error
       </code>
       exception class is defined in
       <code class="calibre21">
        &lt;stdexcept&gt;
       </code>
       .
      </p>
      <pre class="calibre26" id="c14-code-0016"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    if (inputStream.fail()) {       // We failed to open the file: throw an exception.</code>
<code class="calibre21">        <b class="calibre14">throw runtime_error { "Unable to open the file." };</b></code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the integers one-by-one and add them to a vector.</span></code>
<code class="calibre21">    vector&lt;int&gt; integers;</code>
<code class="calibre21">    int temp;</code>
<code class="calibre21">    while (inputStream &gt;&gt; temp) {</code>
<code class="calibre21">        integers.push_back(temp);</code>
<code class="calibre21">    }</code>
<code class="calibre21"><span aria-label="542" class="calibre20" epub:type="pagebreak" id="Page_542" role="doc-pagebreak"></span> </code>
<code class="calibre21">    <b class="calibre14">if (!inputStream.eof()) {</b></code>
<code class="calibre21">        <span class="color">// We did not reach the end-of-file.</span></code>
<code class="calibre21">        <span class="color">// This means that some error occurred while reading the file.</span></code>
<code class="calibre21">        <span class="color">// Throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">throw runtime_error { "Error reading the file." };</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    return integers;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Your code in
       <code class="calibre21">
        main()
       </code>
       does not need to change much because it already catches an exception of type
       <code class="calibre21">
        exception
       </code>
       , from which
       <code class="calibre21">
        runtime_error
       </code>
       derives. However, that exception could now be thrown in two different situations, so we use the
       <code class="calibre21">
        what()
       </code>
       member function to get a proper description of the caught exception:
      </p>
      <pre class="calibre26" id="c14-code-0017"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21">} catch (const exception&amp; e) {</code>
<code class="calibre21">    <b class="calibre14">println(cerr, "{}", e.what());</b></code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Alternatively, you could throw two different types of exceptions from
       <code class="calibre21">
        readIntegerFile()
       </code>
       . Here is an implementation of
       <code class="calibre21">
        readIntegerFile()
       </code>
       that throws an exception object of class
       <code class="calibre21">
        invalid_argument
       </code>
       if the file cannot be opened, and an object of class
       <code class="calibre21">
        runtime_error
       </code>
       if the integers cannot be read. Both
       <code class="calibre21">
        invalid_argument
       </code>
       and
       <code class="calibre21">
        runtime_error
       </code>
       are classes defined in
       <code class="calibre21">
        &lt;stdexcept&gt;
       </code>
       as part of the C++ Standard Library.
      </p>
      <pre class="calibre26" id="c14-code-0018"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    if (inputStream.fail()) {</code>
<code class="calibre21">        <span class="color">// We failed to open the file: throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">throw invalid_argument { "Unable to open the file." };</b></code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the integers one-by-one and add them to a vector.</span></code>
<code class="calibre21">    vector&lt;int&gt; integers;</code>
<code class="calibre21">    int temp;</code>
<code class="calibre21">    while (inputStream &gt;&gt; temp) {</code>
<code class="calibre21">        integers.push_back(temp);</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    if (!inputStream.eof()) {</code>
<code class="calibre21">        <span class="color">// We did not reach the end-of-file.</span></code>
<code class="calibre21">        <span class="color">// This means that some error occurred while reading the file.</span></code>
<code class="calibre21">        <span class="color">// Throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">throw runtime_error { "Error reading the file." };</b></code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    return integers;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0058">
       <span aria-label="543" class="calibre20" epub:type="pagebreak" id="Page_543" role="doc-pagebreak">
       </span>
       There are no public default constructors for
       <code class="calibre21">
        invalid_argument
       </code>
       and
       <code class="calibre21">
        runtime_error
       </code>
       , only
       <code class="calibre21">
        string
       </code>
       constructors, so you always must pass a string as argument.
      </p>
      <p class="calibre13">
       Now,
       <code class="calibre21">
        main()
       </code>
       can catch both
       <code class="calibre21">
        invalid_argument
       </code>
       and
       <code class="calibre21">
        runtime_error
       </code>
       exceptions with two
       <code class="calibre21">
        catch
       </code>
       statements:
      </p>
      <pre class="calibre26" id="c14-code-0019"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21"><b class="calibre14">} catch (const invalid_argument&amp; e) {</b></code>
<code class="calibre21">    <b class="calibre14">println(cerr, "{}", e.what());</b></code>
<code class="calibre21">    <b class="calibre14">return 1;</b></code>
<code class="calibre21"><b class="calibre14">} catch (const runtime_error&amp; e) {</b></code>
<code class="calibre21">    <b class="calibre14">println(cerr, "{}", e.what());</b></code>
<code class="calibre21">    <b class="calibre14">return 2;</b></code>
<code class="calibre21"><b class="calibre14">}</b></code></pre>
      <p class="calibre13" id="c14-para-0060">
       If an exception is thrown inside the
       <code class="calibre21">
        try
       </code>
       block, the compiler matches the type of the exception to the proper
       <code class="calibre21">
        catch
       </code>
       handler. So, if
       <code class="calibre21">
        readIntegerFile()
       </code>
       is unable to open the file and throws an
       <code class="calibre21">
        invalid_argument
       </code>
       object, it is caught by the first
       <code class="calibre21">
        catch
       </code>
       statement. If
       <code class="calibre21">
        readIntegerFile()
       </code>
       is unable to read the file properly and throws a
       <code class="calibre21">
        runtime_error
       </code>
       , then the second
       <code class="calibre21">
        catch
       </code>
       statement catches the exception.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c14-sec-0018">
       </span>
       <h4 class="calibre29" id="head-4-241">
        Matching and const
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         const
        </code>
        -ness specified in the type of the exception you want to catch makes no difference for matching purposes. That is, this line matches any exception of type
        <code class="calibre21">
         runtime_error
        </code>
        :
       </p>
       <pre class="calibre26" id="c14-code-0020"><code class="calibre21">} catch (const runtime_error&amp; e) {</code></pre>
       <p class="calibre13">
        The following line also matches any exception of type
        <code class="calibre21">
         runtime_error
        </code>
        :
       </p>
       <pre class="calibre26" id="c14-code-0021"><code class="calibre21">} catch (runtime_error&amp; e) {</code></pre>
       <p class="calibre13" id="c14-para-0063">
        Still, it's advised to always catch exception objects as reference-to-
        <code class="calibre21">
         const
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c14-sec-0019">
       </span>
       <h4 class="calibre29" id="head-4-242">
        Matching Any Exception
       </h4>
       <p class="calibre13">
        You can write a
        <code class="calibre21">
         catch
        </code>
        -all block that matches any possible exception with the special syntax shown in the following example:
       </p>
       <pre class="calibre26" id="c14-code-0022"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21"><b class="calibre14">} catch (…) {</b></code>
<code class="calibre21">    println(cerr, "Error reading or opening file {}", filename);</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c14-para-0065">
        The three dots are not a typo. They are a wildcard that matches any exception type. The downside of using a
        <code class="calibre21">
         catch
        </code>
        -all block is that you don't get any details of the caught exception. When you are calling poorly documented code, this technique could be useful to ensure that you catch all possible exceptions. But even then, what would you possibly be able to do to recover from an unknown exception?
       </p>
       <p class="calibre13">
        One useful use case of a
        <code class="calibre21">
         catch
        </code>
        -all block is to log that an exception was thrown and then rethrow the exception. The following example shows how you can write
        <code class="calibre21">
         catch
        </code>
        handlers that explicitly handle
        <code class="calibre21">
         invalid_argument
        </code>
        and
        <code class="calibre21">
         runtime_error
        </code>
        exceptions, as well as how to include a
        <code class="calibre21">
         catch
        </code>
        -all handler
        <span aria-label="544" class="calibre20" epub:type="pagebreak" id="Page_544" role="doc-pagebreak">
        </span>
        for all other exceptions. In any
        <code class="calibre21">
         catch
        </code>
        block, you can rethrow the currently caught exception using just the
        <code class="calibre21">
         throw
        </code>
        keyword without any arguments. There is more to say about rethrowing exceptions, but that has to wait until later in this chapter.
       </p>
       <pre class="calibre26" id="c14-code-0023"><code class="calibre21">try {</code>
<code class="calibre21">    <span class="color">// Code that can throw exceptions.</span></code>
<code class="calibre21">} catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">    <span class="color">// Handle invalid_argument exception.</span></code>
<code class="calibre21">} catch (const runtime_error&amp; e) {</code>
<code class="calibre21">    <span class="color">// Handle runtime_error exception.</span></code>
<code class="calibre21">} catch (…) {</code>
<code class="calibre21">    <span class="color">// Handle all other exceptions.</span></code>
<code class="calibre21">    <span class="color">// Log that an exception occurred…</span></code>
<code class="calibre21">    throw; <span class="color">// Rethrow the caught exception.</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c14-para-0067">
        In situations where you have complete information about the set of thrown exceptions, a
        <code class="calibre21">
         catch
        </code>
        -all block is not recommended because it handles every exception type identically. It's better to match exception types explicitly and take appropriate, targeted actions.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0020">
      </span>
      <h3 class="calibre27" id="head-3-308">
       Uncaught Exceptions
      </h3>
      <p class="calibre13">
       If your program throws an exception that is not caught anywhere, the program terminates. Basically, there is a
       <code class="calibre21">
        try/catch
       </code>
       construct around the call to your
       <code class="calibre21">
        main()
       </code>
       function, which catches all unhandled exceptions and behaves like the following pseudocode:
      </p>
      <pre class="calibre26" id="c14-code-0024"><code class="calibre21">try {</code>
<code class="calibre21">    main(argc, argv);</code>
<code class="calibre21">} catch (…) {</code>
<code class="calibre21">    <span class="color">// Issue error message and terminate program.</span></code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Normal termination code.</span></code></pre>
      <p class="calibre13">
       However, this behavior is usually not what you want. The point of exceptions is to give your program a chance to handle and correct undesirable or unexpected situations.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0070">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           You should catch and handle all exceptions thrown in your programs, as far as possible
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       It is also possible to change the behavior of your program if there is an uncaught exception. When the program encounters an uncaught exception, it calls the built-in
       <code class="calibre21">
        terminate()
       </code>
       function, which calls
       <code class="calibre21">
        abort()
       </code>
       from
       <code class="calibre21">
        &lt;cstdlib&gt;
       </code>
       to kill the program. You can set your own
       <code class="calibre21">
        terminate_handler
       </code>
       by calling
       <code class="calibre21">
        set_terminate()
       </code>
       with a pointer to a function that takes no arguments and returns no value.
       <code class="calibre21">
        terminate()
       </code>
       ,
       <code class="calibre21">
        set_terminate()
       </code>
       , and
       <code class="calibre21">
        terminate_handler
       </code>
       are all declared in
       <code class="calibre21">
        &lt;exception&gt;
       </code>
       . The following pseudocode shows a high-level overview of how it works:
      </p>
      <pre class="calibre26" id="c14-code-0025"><code class="calibre21">try {</code>
<code class="calibre21">    main(argc, argv);</code>
<span aria-label="545" class="calibre20" epub:type="pagebreak" id="Page_545" role="doc-pagebreak"></span><code class="calibre21">} catch (…) {</code>
<code class="calibre21">    if (terminate_handler != nullptr) {</code>
<code class="calibre21">        terminate_handler();</code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        terminate();</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Normal termination code.</span></code></pre>
      <p class="calibre13" id="c14-para-0072">
       Before you get too excited about this feature, you should know that your callback function must still terminate the program using either
       <code class="calibre21">
        abort()
       </code>
       or
       <code class="calibre21">
        _Exit()
       </code>
       . It can't just ignore the error. Both
       <code class="calibre21">
        abort()
       </code>
       and _
       <code class="calibre21">
        Exit()
       </code>
       are defined in
       <code class="calibre21">
        &lt;cstdlib&gt;
       </code>
       and terminate the application without cleaning up resources. For example, destructors of objects won't get called. The
       <code class="calibre21">
        _Exit()
       </code>
       function accepts an integer argument that is returned to the operating system and can be used to determine how a process exited. A value of
       <code class="calibre21">
        0
       </code>
       or
       <code class="calibre21">
        EXIT_SUCCESS
       </code>
       means the program exited without any error; otherwise, the program terminated abnormally. The
       <code class="calibre21">
        abort()
       </code>
       function does not accept any arguments. Additionally, there is an
       <code class="calibre21">
        exit()
       </code>
       function that also accepts an integer that is returned to the operating system and that does clean up resources by calling destructors, but it's not recommended to call
       <code class="calibre21">
        exit()
       </code>
       from a
       <code class="calibre21">
        terminate_handler
       </code>
       .
      </p>
      <p class="calibre13">
       A
       <code class="calibre21">
        terminate_handler
       </code>
       can be used to print a helpful error message before exiting. Here is an example of a
       <code class="calibre21">
        main()
       </code>
       function that doesn't catch the exceptions thrown by
       <code class="calibre21">
        readIntegerFile()
       </code>
       . Instead, it sets the
       <code class="calibre21">
        terminate_handler
       </code>
       to a custom callback. This callback prints an error message and terminates the process by calling
       <code class="calibre21">
        _Exit()
       </code>
       . Note the use of the
       <code class="calibre21">
        [[noreturn]]
       </code>
       attribute, introduced in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       .
      </p>
      <pre class="calibre26" id="c14-code-0026"><code class="calibre21"><b class="calibre14">[[noreturn]] void myTerminate()</b></code>
<code class="calibre21"><b class="calibre14">{</b></code>
<code class="calibre21">    <b class="calibre14">println(cerr, "Uncaught exception!");</b></code>
<code class="calibre21">    <b class="calibre14">_Exit(1);</b></code>
<code class="calibre21"><b class="calibre14">}</b></code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">set_terminate(myTerminate);</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    const string filename { "IntegerFile.txt" };</code>
<code class="calibre21">    vector&lt;int&gt; myInts { readIntegerFile(filename) };</code>
<code class="calibre21">    println("{} ", myInts);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0074">
       Although not shown in this example,
       <code class="calibre21">
        set_terminate()
       </code>
       returns the old
       <code class="calibre21">
        terminate_handler
       </code>
       when it sets the new one. The
       <code class="calibre21">
        terminate_handler
       </code>
       applies program-wide, so it's considered good style to restore the old
       <code class="calibre21">
        terminate_handler
       </code>
       when you have completed the code that needed the new
       <code class="calibre21">
        terminate_handler
       </code>
       . In this case, the entire program needs the new
       <code class="calibre21">
        terminate_handler
       </code>
       , so there's no point in restoring it.
      </p>
      <p class="calibre13">
       While it's important to know about
       <code class="calibre21">
        set_terminate()
       </code>
       , it's not an effective exception-handling approach. It's recommended to catch and handle each exception individually to provide more precise error handling.
       <span aria-label="546" class="calibre20" epub:type="pagebreak" id="Page_546" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0076">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           In professionally written software, a
          </i>
          <code class="calibre21">
           terminate_handler
          </code>
          <i class="calibre18">
           is usually set up to create a crash dump before terminating the process. A crash dump usually contains information such as the call stack and local variables at the time the uncaught exception was thrown. Such a crash dump can then be loaded into a debugger and allows you to figure out what the uncaught exception was and what caused it. However, writing crash dumps is platform dependent and therefore not further discussed in this book.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0023">
      </span>
      <h3 class="calibre27" id="head-3-309">
       noexcept Specifier
      </h3>
      <p class="calibre13">
       By default, a function is allowed to throw any exception it likes. However, it is possible to mark a function with the
       <code class="calibre21">
        noexcept
       </code>
       specifier, a C++ keyword, to state that it will not throw any exceptions. For example, the following function is marked as
       <code class="calibre21">
        noexcept
       </code>
       , so it is not allowed to throw any exceptions:
      </p>
      <pre class="calibre26" id="c14-code-0027"><code class="calibre21">void printValues(const vector&lt;int&gt;&amp; values) noexcept;</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0079">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           A function marked with
          </i>
          <code class="calibre21">
           noexcept
          </code>
          <i class="calibre18">
           must not throw any exceptions.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c14-para-0080">
       When a function marked as
       <code class="calibre21">
        noexcept
       </code>
       throws an exception anyway, C++ calls
       <code class="calibre21">
        terminate()
       </code>
       to terminate the application.
      </p>
      <p class="calibre13" id="c14-para-0081">
       When you override a
       <code class="calibre21">
        virtual
       </code>
       member function in a derived class, you are allowed to mark the overridden member function as
       <code class="calibre21">
        noexcept
       </code>
       , even if the version in the base class is not
       <code class="calibre21">
        noexcept
       </code>
       . The opposite is not allowed.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0025">
      </span>
      <h3 class="calibre27" id="head-3-310">
       noexcept(expression) Specifier
      </h3>
      <p class="calibre13" id="c14-para-0082">
       The
       <code class="calibre21">
        noexcept(expression)
       </code>
       specifier marks a function as
       <code class="calibre21">
        noexcept
       </code>
       if and only if the given expression returns
       <code class="calibre21">
        true
       </code>
       . In other words,
       <code class="calibre21">
        noexcept
       </code>
       equals
       <code class="calibre21">
        noexcept(true)
       </code>
       , and
       <code class="calibre21">
        noexcept(false)
       </code>
       is the opposite of
       <code class="calibre21">
        noexcept(true)
       </code>
       ; that is, a member function marked with
       <code class="calibre21">
        noexcept(false)
       </code>
       can throw any exception it wants, which is the default.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0026">
      </span>
      <h3 class="calibre27" id="head-3-311">
       noexcept(expression) Operator
      </h3>
      <p class="calibre13" id="c14-para-0083">
       The
       <code class="calibre21">
        noexcept(expression)
       </code>
       operator returns
       <code class="calibre21">
        true
       </code>
       if the given expression is
       <code class="calibre21">
        noexcept
       </code>
       . This evaluation happens at compile time.
      </p>
      <p class="calibre13">
       Here's an example:
      </p>
      <pre class="calibre26" id="c14-code-0028"><code class="calibre21">void f1() noexcept {}</code>
<code class="calibre21">void f2() noexcept(false) {}</code>
<code class="calibre21">void f3() noexcept(noexcept(f1())) {}</code>
<code class="calibre21">void f4() noexcept(noexcept(f2())) {}</code>
<code class="calibre21"><span aria-label="547" class="calibre20" epub:type="pagebreak" id="Page_547" role="doc-pagebreak"></span> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("{} {} {} {}", noexcept(f1()),</code>
<code class="calibre21">                           noexcept(f2()),</code>
<code class="calibre21">                           noexcept(f3()),</code>
<code class="calibre21">                           noexcept(f4()));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output of this code snippet is
       <code class="calibre21">
        true false true false
       </code>
       :
      </p>
      <ul class="check" id="c14-list-0004">
       <li class="calibre9" id="c14-li-0014">
        <code class="calibre21">
         noexcept(f1())
        </code>
        is
        <code class="calibre21">
         true
        </code>
        because
        <code class="calibre21">
         f1()
        </code>
        is explicitly marked with a
        <code class="calibre21">
         noexcept
        </code>
        specifier.
       </li>
       <li class="calibre9" id="c14-li-0015">
        <code class="calibre21">
         noexcept(f2())
        </code>
        is
        <code class="calibre21">
         false
        </code>
        because
        <code class="calibre21">
         f2()
        </code>
        is explicitly marked as such using a
        <code class="calibre21">
         noexcept(expression)
        </code>
        specifier.
       </li>
       <li class="calibre9" id="c14-li-0016">
        <code class="calibre21">
         noexcept(f3())
        </code>
        is
        <code class="calibre21">
         true
        </code>
        because
        <code class="calibre21">
         f3()
        </code>
        is marked as
        <code class="calibre21">
         noexcept
        </code>
        but only if
        <code class="calibre21">
         f1()
        </code>
        is
        <code class="calibre21">
         noexcept
        </code>
        which it is.
       </li>
       <li class="calibre9" id="c14-li-0017">
        <code class="calibre21">
         noexcept(f4())
        </code>
        is
        <code class="calibre21">
         false
        </code>
        because
        <code class="calibre21">
         f4()
        </code>
        is marked as
        <code class="calibre21">
         noexcept
        </code>
        but only if
        <code class="calibre21">
         f2()
        </code>
        is
        <code class="calibre21">
         noexcept
        </code>
        which it isn't.
       </li>
      </ul>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0027">
      </span>
      <h3 class="calibre27" id="head-3-312">
       Throw Lists
      </h3>
      <p class="calibre13">
       Older versions of C++ allowed you to specify the exceptions a function intended to throw. This specification was called the
       <i class="calibre18">
        throw list
       </i>
       or the
       <i class="calibre18">
        exception specification
       </i>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0087">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           C++11 has deprecated, and C++17 has removed support for exception specifications, apart from
          </i>
          <code class="calibre21">
           noexcept
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           throw
           <i class="calibre18">
            ()
           </i>
          </code>
          <i class="calibre18">
           . The latter was equivalent to
          </i>
          <code class="calibre21">
           noexcept
          </code>
          <i class="calibre18">
           . Since C++20, support for
          </i>
          <code class="calibre21">
           throw()
          </code>
          <i class="calibre18">
           has been removed as well.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c14-para-0088">
       Because C++17 has officially removed support for exception specifications, this book does not further discuss them.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-161" class="calibre2">
     <span class="calibre" id="c14-sec-0029">
     </span>
     <h2 class="calibre6" id="head-2-161">
      EXCEPTIONS AND POLYMORPHISM
     </h2>
     <p class="calibre13" id="c14-para-0089">
      As described earlier, you can actually throw any type of exception. However, classes are the most useful types of exceptions. In fact, exception classes are usually written in a hierarchy so that you can employ polymorphism when you catch the exceptions.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0030">
      </span>
      <h3 class="calibre27" id="head-3-313">
       The Standard Exception Hierarchy
      </h3>
      <p class="calibre13" id="c14-para-0090">
       You've already seen several exceptions from the C++ standard exception hierarchy:
       <code class="calibre21">
        exception
       </code>
       ,
       <code class="calibre21">
        runtime_error
       </code>
       , and
       <code class="calibre21">
        invalid_argument
       </code>
       .
       <a class="calibre5" href="#c14-fig-0003" id="R_c14-fig-0003">
        Figure 14.3
       </a>
       shows the full hierarchy. For completeness, all standard exceptions are shown, including those thrown by parts of the Standard Library that are discussed in later chapters.
      </p>
      <span aria-label="548" class="calibre20" epub:type="pagebreak" id="Page_548" role="doc-pagebreak">
      </span>
      <figure class="calibre36">
       <img alt="A flowchart represents a hierarchy. At the top, there is a general exception class. Angle brackets of exception branch into three categories stdexcept, stdexcept, and typeinfo." class="center" src="images/c14f003.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c14-fig-0003" id="c14-fig-0003" role="doc-backlink">
           <b class="calibre14">
            FIGURE 14.3
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c14-para-0091">
       All of the exceptions thrown by the C++ Standard Library are objects of classes in this hierarchy. Each class in the hierarchy supports a
       <code class="calibre21">
        what()
       </code>
       member function that returns a
       <code class="calibre21">
        const char*
       </code>
       string describing the exception. You can use this string in an error message.
      </p>
      <p class="calibre13">
       Some of the exception classes require you to set in the constructor the string that is returned by
       <code class="calibre21">
        what()
       </code>
       . That's why you have to specify a string in the constructors for
       <code class="calibre21">
        runtime_error
       </code>
       and
       <code class="calibre21">
        invalid_argument
       </code>
       . This has already been done in examples throughout this chapter. Here is another version of
       <code class="calibre21">
        readIntegerFile()
       </code>
       that includes the filename in the error message:
      </p>
      <pre class="calibre26" id="c14-code-0029"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    if (inputStream.fail()) {</code>
<code class="calibre21">        <span class="color">// We failed to open the file: throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">const string error { format("Unable to open file {}.", filename) };</b></code>
<code class="calibre21">        <b class="calibre14">throw invalid_argument { error };</b></code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Read the integers one-by-one and add them to a vector.</span></code>
<code class="calibre21">    vector&lt;int&gt; integers;</code>
<code class="calibre21">    int temp;</code>
<code class="calibre21">    while (inputStream &gt;&gt; temp) {</code>
<code class="calibre21">        integers.push_back(temp);</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    if (!inputStream.eof()) {</code>
<code class="calibre21">        <span class="color">// We did not reach the end-of-file.</span></code>
<span aria-label="549" class="calibre20" epub:type="pagebreak" id="Page_549" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// This means that some error occurred while reading the file.</span></code>
<code class="calibre21">        <span class="color">// Throw an exception.</span></code>
<code class="calibre21">        <b class="calibre14">const string error { format("Unable to read file {}.", filename) };</b></code>
<code class="calibre21">        <b class="calibre14">throw runtime_error { error };</b></code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    return integers;</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0031">
      </span>
      <h3 class="calibre27" id="head-3-314">
       Catching Exceptions in a Class Hierarchy
      </h3>
      <p class="calibre13">
       A feature of exception hierarchies is that you can catch exceptions polymorphically. For example, if you look at the following two
       <code class="calibre21">
        catch
       </code>
       statements, you can see that they are identical except for the exception class that they handle:
      </p>
      <pre class="calibre26" id="c14-code-0030"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21">} catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">    println(cerr, "{}", e.what());</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">} catch (const runtime_error&amp; e) {</code>
<code class="calibre21">    println(cerr, "{}", e.what());</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Conveniently,
       <code class="calibre21">
        invalid_argument
       </code>
       and
       <code class="calibre21">
        runtime_error
       </code>
       are both derived classes of
       <code class="calibre21">
        exception
       </code>
       , so you can replace the two
       <code class="calibre21">
        catch
       </code>
       statements with a single
       <code class="calibre21">
        catch
       </code>
       statement for
       <code class="calibre21">
        exception
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0031"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21"><b class="calibre14">} catch (const exception&amp; e) {</b></code>
<code class="calibre21">    <b class="calibre14">println(cerr, "{}", e.what());</b></code>
<code class="calibre21">    <b class="calibre14">return 1;</b></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        catch
       </code>
       statement for an
       <code class="calibre21">
        exception
       </code>
       reference matches any derived classes of
       <code class="calibre21">
        exception
       </code>
       , including both
       <code class="calibre21">
        invalid_argument
       </code>
       and
       <code class="calibre21">
        runtime_error
       </code>
       . Note that the higher in the exception hierarchy you catch exceptions, the less specific your error handling can be. You should generally catch exceptions at as specific a level as possible.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0096">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           When you catch exceptions polymorphically, make sure to catch them by reference! If you catch exceptions by value, you can encounter slicing, in which case you lose information from the object. See
           <a class="calibre5" href="c10_split_000.xhtml">
            Chapter 10
           </a>
           for details on slicing
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       When more than one
       <code class="calibre21">
        catch
       </code>
       clause is used, the
       <code class="calibre21">
        catch
       </code>
       clauses are matched in syntactic order as they appear in your code; the first one that matches wins. If one
       <code class="calibre21">
        catch
       </code>
       is more inclusive than a later one, it will match first, and the more restrictive one, which comes later, will never be executed. Therefore, you should place your
       <code class="calibre21">
        catch
       </code>
       clauses from most restrictive to least restrictive in order. For example, suppose that you want to catch
       <code class="calibre21">
        invalid_argument
       </code>
       from
       <code class="calibre21">
        readIntegerFile()
       </code>
       explicitly, but you
       <span aria-label="550" class="calibre20" epub:type="pagebreak" id="Page_550" role="doc-pagebreak">
       </span>
       also want to leave the generic
       <code class="calibre21">
        exception
       </code>
       handler for any other exceptions. The correct way to do so is like this:
      </p>
      <pre class="calibre26" id="c14-code-0032"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21">} catch (const invalid_argument&amp; e) { <span class="color">// List the derived class first.</span></code>
<code class="calibre21">    <span class="color">// Take some special action for invalid filenames.</span></code>
<code class="calibre21">} catch (const exception&amp; e) { <span class="color">// Now list exception.</span></code>
<code class="calibre21">    println(cerr, "{}", e.what());</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The first
       <code class="calibre21">
        catch
       </code>
       statement catches
       <code class="calibre21">
        invalid_argument
       </code>
       exceptions, and the second catches any other exceptions of type
       <code class="calibre21">
        exception
       </code>
       . However, if you reverse the order of the
       <code class="calibre21">
        catch
       </code>
       statements, you don't get the same result:
      </p>
      <pre class="calibre26" id="c14-code-0033"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21">} catch (const exception&amp; e) { <span class="color">// BUG: catching base class first!</span></code>
<code class="calibre21">    println(cerr, "{}", e.what());</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">} catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">    <span class="color">// Take some special action for invalid filenames.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0099">
       With this order, any exception of a class that derives from
       <code class="calibre21">
        exception
       </code>
       is caught by the first
       <code class="calibre21">
        catch
       </code>
       statement; the second
       <code class="calibre21">
        catch
       </code>
       will never be reached. Some compilers issue a warning in this case, but you shouldn't count on it.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0033">
      </span>
      <h3 class="calibre27" id="head-3-315">
       Writing Your Own Exception Classes
      </h3>
      <p class="calibre13">
       There are two advantages to writing your own exception classes:
      </p>
      <ul class="check" id="c14-list-0005">
       <li class="calibre9" id="c14-li-0018">
        The number of exceptions in the C++ Standard Library is limited. Instead of using an exception class with a generic name, such as
        <code class="calibre21">
         runtime_error
        </code>
        , you can create classes with names that are more meaningful for the particular errors in your program.
       </li>
       <li class="calibre9" id="c14-li-0019">
        You can add your own information to these exceptions. Most exceptions in the standard hierarchy allow you to set only an error string. You might want to pass different information in the exception.
       </li>
      </ul>
      <p class="calibre13" id="c14-para-0101">
       It's recommended that all the exception classes that you write inherit directly or indirectly from the standard
       <code class="calibre21">
        exception
       </code>
       class. If everyone on your project follows that rule, you know that every exception in the program will be derived from
       <code class="calibre21">
        exception
       </code>
       (assuming that you aren't using third-party libraries that break this rule). This guideline makes exception handling via polymorphism significantly easier.
      </p>
      <p class="calibre13">
       Let's look at an example.
       <code class="calibre21">
        invalid_argument
       </code>
       and
       <code class="calibre21">
        runtime_error
       </code>
       don't do a good job at capturing the file opening and reading errors in
       <code class="calibre21">
        readIntegerFile()
       </code>
       . You can define your own error hierarchy for file errors, starting with a generic
       <code class="calibre21">
        FileError
       </code>
       class:
      </p>
      <pre class="calibre26" id="c14-code-0034"><code class="calibre21">class FileError : public exception</code>
<code class="calibre21">{</code>
<span aria-label="551" class="calibre20" epub:type="pagebreak" id="Page_551" role="doc-pagebreak"></span><code class="calibre21">    public:</code>
<code class="calibre21">        explicit FileError(string filename) : m_filename { move(filename) } {}</code>
<code class="calibre21">        const char* what() const noexcept override { return m_message.c_str(); }</code>
<code class="calibre21">        virtual const string&amp; getFilename() const noexcept { return m_filename; }</code>
<code class="calibre21">    protected:</code>
<code class="calibre21">        virtual void setMessage(string message) { m_message = move(message); }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_filename;</code>
<code class="calibre21">        string m_message;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c14-para-0103">
       As a good programming citizen, you make
       <code class="calibre21">
        FileError
       </code>
       a part of the standard exception hierarchy. It seems appropriate to integrate it as a child of
       <code class="calibre21">
        exception
       </code>
       . When you derive from
       <code class="calibre21">
        exception
       </code>
       , you can override the
       <code class="calibre21">
        what()
       </code>
       member function, which has the prototype shown and which must return a
       <code class="calibre21">
        const char*
       </code>
       string that is valid until the object is destroyed. In the case of
       <code class="calibre21">
        FileError
       </code>
       , this string comes from the
       <code class="calibre21">
        m_message
       </code>
       data member. Derived classes of
       <code class="calibre21">
        FileError
       </code>
       can set the message using the
       <code class="calibre21">
        protected setMessage()
       </code>
       member function. The generic
       <code class="calibre21">
        FileError
       </code>
       class also contains a filename and a public accessor for that filename.
      </p>
      <p class="calibre13">
       The first exceptional situation in
       <code class="calibre21">
        readIntegerFile()
       </code>
       occurs when the file cannot be opened. Thus, you might want to write a
       <code class="calibre21">
        FileOpenError
       </code>
       exception derived from
       <code class="calibre21">
        FileError
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0035"><code class="calibre21">class FileOpenError : public FileError</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit FileOpenError(string filename) : FileError { move(filename) }</code>
<code class="calibre21">        {</code>
<code class="calibre21">            setMessage(format("Unable to open {}.", getFilename()));</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c14-para-0105">
       The
       <code class="calibre21">
        FileOpenError
       </code>
       exception calls
       <code class="calibre21">
        setMessage()
       </code>
       to change the
       <code class="calibre21">
        m_message
       </code>
       string to represent the file-opening error. Note that in the body of the constructor,
       <code class="calibre21">
        getFilename()
       </code>
       is used to get the filename. The
       <code class="calibre21">
        filename
       </code>
       parameter cannot be used for this as the ctor-initializer has moved
       <code class="calibre21">
        filename
       </code>
       in the call to the
       <code class="calibre21">
        FileError
       </code>
       constructor. As you know, after a move operation, you shouldn't use an object any longer.
      </p>
      <p class="calibre13">
       The second exceptional situation in
       <code class="calibre21">
        readIntegerFile()
       </code>
       occurs if the file cannot be read properly. It might be useful for this exception to include the line number where the error occurred, as well as the filename in the error message string returned from
       <code class="calibre21">
        what()
       </code>
       . Here is a
       <code class="calibre21">
        FileReadError
       </code>
       exception derived from
       <code class="calibre21">
        FileError
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0036"><code class="calibre21">class FileReadError : public FileError</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit FileReadError(string filename, size_t lineNumber)</code>
<code class="calibre21">            : FileError { move(filename) }, m_lineNumber { lineNumber }</code>
<code class="calibre21">        {</code>
<code class="calibre21">            setMessage(format("Error reading {}, line {}.",</code>
<code class="calibre21">                getFilename(), lineNumber));</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        virtual size_t getLineNumber() const noexcept { return m_lineNumber; }</code>
<span aria-label="552" class="calibre20" epub:type="pagebreak" id="Page_552" role="doc-pagebreak"></span><code class="calibre21">    private:</code>
<code class="calibre21">        size_t m_lineNumber { 0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Of course, to set the line number properly,
       <code class="calibre21">
        readIntegerFile()
       </code>
       needs to be modified to track the number of lines read instead of just reading integers directly. Here is a new
       <code class="calibre21">
        readIntegerFile()
       </code>
       function that uses the new exceptions:
      </p>
      <pre class="calibre26" id="c14-code-0037"><code class="calibre21">vector&lt;int&gt; readIntegerFile(const string&amp; filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream inputStream { filename };</code>
<code class="calibre21">    if (inputStream.fail()) {</code>
<code class="calibre21">        <span class="color">// We failed to open the file: throw an exception.</span></code>
<code class="calibre21">        throw FileOpenError { filename };</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    vector&lt;int&gt; integers;</code>
<code class="calibre21">    size_t lineNumber { 0 };</code>
<code class="calibre21">    while (!inputStream.eof()) {</code>
<code class="calibre21">        <span class="color">// Read one line from the file.</span></code>
<code class="calibre21">        string line;</code>
<code class="calibre21">        getline(inputStream, line);</code>
<code class="calibre21">        ++lineNumber;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Create a string stream out of the line.</span></code>
<code class="calibre21">        istringstream lineStream { line };</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Read the integers one-by-one and add them to the vector.</span></code>
<code class="calibre21">        int temp;</code>
<code class="calibre21">        while (lineStream &gt;&gt; temp) {</code>
<code class="calibre21">            integers.push_back(temp);</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        if (!lineStream.eof()) {</code>
<code class="calibre21">            <span class="color">// We did not reach the end of the string stream.</span></code>
<code class="calibre21">            <span class="color">// This means that some error occurred while reading this line.</span></code>
<code class="calibre21">            <span class="color">// Throw an exception.</span></code>
<code class="calibre21">            throw FileReadError { filename, lineNumber };</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    return integers;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Now, code that calls
       <code class="calibre21">
        readIntegerFile()
       </code>
       can use polymorphism to catch exceptions of type
       <code class="calibre21">
        FileError
       </code>
       like this:
      </p>
      <pre class="calibre26" id="c14-code-0038"><code class="calibre21">try {</code>
<code class="calibre21">    myInts = readIntegerFile(filename);</code>
<code class="calibre21">} catch (const FileError&amp; e) {</code>
<code class="calibre21">    println(cerr, "{}", e.what());</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       There is one caveat when writing classes whose objects will be used as exceptions. When a piece of code throws an exception, the object or value thrown is moved or copied, using either the move constructor or the copy constructor. Thus, if you write a class whose objects will be thrown as
       <span aria-label="553" class="calibre20" epub:type="pagebreak" id="Page_553" role="doc-pagebreak">
       </span>
       exceptions, you must make sure those objects are copyable and/or moveable. This means that if you have dynamically allocated memory in your exception class, your class must have a destructor, but also a copy constructor and copy assignment operator and/or a move constructor and move assignment operator, see
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects.”
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0110">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Objects thrown as exceptions are always moved or copied at least once
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       It is possible for exceptions to be copied more than once, but only if you catch the exception by value instead of by reference.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0112">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Catch exception objects by reference (preferably reference-to-
           <code class="calibre21">
            const
           </code>
           ) to avoid unnecessary copying
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0036">
      </span>
      <h3 class="calibre27" id="head-3-316">
       Nested Exceptions
      </h3>
      <p class="calibre13" id="c14-para-0113">
       It could happen that during handling of a first exception, a second exceptional situation is triggered that requires a second exception to be thrown. Unfortunately, when you throw the second exception, all information about the first exception that you are currently trying to handle will be lost. The solution provided by C++ for this problem is called
       <i class="calibre18">
        nested exceptions
       </i>
       , which allow you to nest a caught exception in the context of a new exception. This can also be useful if you call a function in a third-party library that throws an exception of a certain type,
       <code class="calibre21">
        A
       </code>
       , but you only want exceptions of another type,
       <code class="calibre21">
        B
       </code>
       , in your code. In such a case, you catch all exceptions from the library and nest them in an exception of type
       <code class="calibre21">
        B
       </code>
       .
      </p>
      <p class="calibre13">
       You use
       <code class="calibre21">
        std::throw_with_nested()
       </code>
       to throw an exception with another exception nested inside it. A catch handler for this new exception can use a
       <code class="calibre21">
        dynamic_cast()
       </code>
       to get access to the
       <code class="calibre21">
        std::nested_exception
       </code>
       representing the first exception. The upcoming example demonstrates this. It first defines a
       <code class="calibre21">
        MyException
       </code>
       class, which derives from
       <code class="calibre21">
        exception
       </code>
       and accepts a string in its constructor:
      </p>
      <pre class="calibre26" id="c14-code-0039"><code class="calibre21">class MyException : public exception</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit MyException(string message) : m_message { move(message) } {}</code>
<code class="calibre21">        const char* what() const noexcept override { return m_message.c_str(); }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_message;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The following
       <code class="calibre21">
        doSomething()
       </code>
       function throws a
       <code class="calibre21">
        runtime_error
       </code>
       that is immediately caught in a catch handler. The catch handler writes a message and then uses the
       <code class="calibre21">
        throw_with_nested()
       </code>
       function to throw a second exception that has the first one nested inside it. Note that nesting the exception happens automatically:
      </p>
      <pre class="calibre26" id="c14-code-0040"><code class="calibre21">void doSomething()</code>
<code class="calibre21">{</code>
<span aria-label="554" class="calibre20" epub:type="pagebreak" id="Page_554" role="doc-pagebreak"></span><code class="calibre21">    try {</code>
<code class="calibre21">        throw runtime_error { "A runtime_error exception" };</code>
<code class="calibre21">    } catch (const runtime_error&amp; e) {</code>
<code class="calibre21">        println("doSomething() caught a runtime_error"); </code>
<code class="calibre21">        println("doSomething() throwing MyException"); </code>
<code class="calibre21">        throw_with_nested(</code>
<code class="calibre21">            MyException { "MyException with nested runtime_error" });</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0116">
       <code class="calibre21">
        throw_with_nested()
       </code>
       works by throwing an unnamed new compiler-generated type that derives from both
       <code class="calibre21">
        nested_exception
       </code>
       and, in this example, from
       <code class="calibre21">
        MyException
       </code>
       . Hence, it's another example of useful multiple inheritance in C++. The default constructor of the
       <code class="calibre21">
        nested_exception
       </code>
       base class automatically captures the exception currently being handled by calling
       <code class="calibre21">
        std::current_exception()
       </code>
       and stores it in an
       <code class="calibre21">
        std::exception_ptr
       </code>
       . An
       <code class="calibre21">
        exception_ptr
       </code>
       is a pointer-like type capable of storing either a null pointer or a pointer to an exception object that was thrown and captured with
       <code class="calibre21">
        current_exception()
       </code>
       . Instances of
       <code class="calibre21">
        exception_ptr
       </code>
       can be passed to functions (usually by value) and across different threads.
      </p>
      <p class="calibre13">
       Finally, the following code snippet demonstrates how to handle an exception with a nested exception. The code calls
       <code class="calibre21">
        doSomething()
       </code>
       and has one catch handler for exceptions of type
       <code class="calibre21">
        MyException
       </code>
       . When it catches such an exception, it writes a message and then uses a
       <code class="calibre21">
        dynamic_cast()
       </code>
       to get access to the nested exception. If there is no nested exception inside, the result will be a null pointer. If there is a nested exception inside, the
       <code class="calibre21">
        rethrow_nested()
       </code>
       member function on the
       <code class="calibre21">
        nested_exception
       </code>
       is called. This causes the nested exception to be rethrown, which you can then catch in another
       <code class="calibre21">
        try/catch
       </code>
       block.
      </p>
      <pre class="calibre26" id="c14-code-0041"><code class="calibre21">try {</code>
<code class="calibre21">    doSomething();</code>
<code class="calibre21">} catch (const MyException&amp; e) {</code>
<code class="calibre21">    println("main() caught MyException: {}", e.what()); </code>
<code class="calibre21"> </code>
<code class="calibre21">    const auto* nested { dynamic_cast&lt;const nested_exception*&gt;(&amp;e) };</code>
<code class="calibre21">    if (nested) {</code>
<code class="calibre21">        try {</code>
<code class="calibre21">            nested-&gt;rethrow_nested();</code>
<code class="calibre21">        } catch (const runtime_error&amp; e) {</code>
<code class="calibre21">            <span class="color">// Handle nested exception.</span></code>
<code class="calibre21">            println("  Nested exception: {}", e.what());</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c14-code-0042"><code class="calibre21">doSomething() caught a runtime_error</code>
<code class="calibre21">doSomething() throwing MyException</code>
<code class="calibre21">main() caught MyException: MyException with nested runtime_error</code>
<code class="calibre21">  Nested exception: A runtime_error exception</code></pre>
      <p class="calibre13">
       This code uses a
       <code class="calibre21">
        dynamic_cast()
       </code>
       to check for a nested exception. Because you always have to perform such a
       <code class="calibre21">
        dynamic_cast()
       </code>
       if you want to check for a nested exception, the standard provides a helper function called
       <code class="calibre21">
        std::rethrow_if_nested()
       </code>
       that does it for you. This helper function can be used as follows:
      </p>
      <pre class="calibre26" id="c14-code-0043"><code class="calibre21">try {</code>
<code class="calibre21">    doSomething();</code>
<span aria-label="555" class="calibre20" epub:type="pagebreak" id="Page_555" role="doc-pagebreak"></span><code class="calibre21">} catch (const MyException&amp; e) {</code>
<code class="calibre21">    println("main() caught MyException: {}", e.what()); </code>
<code class="calibre21">    <b class="calibre14">try {</b></code>
<code class="calibre21">        <b class="calibre14">rethrow_if_nested(e);</b></code>
<code class="calibre21">    <b class="calibre14">} catch (const runtime_error&amp; e) {</b></code>
<code class="calibre21">        <span class="color">// Handle nested exception.</span></code>
<code class="calibre21">        <b class="calibre14">println("  Nested exception: {}", e.what());</b></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0120">
       <code class="calibre21">
        throw_with_nested()
       </code>
       ,
       <code class="calibre21">
        nested_exception
       </code>
       ,
       <code class="calibre21">
        rethrow_if_nested()
       </code>
       ,
       <code class="calibre21">
        current_exception()
       </code>
       , and
       <code class="calibre21">
        exception_ptr
       </code>
       are all defined in
       <code class="calibre21">
        &lt;exception&gt;
       </code>
       .
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-162" class="calibre2">
     <span class="calibre" id="c14-sec-0037">
     </span>
     <h2 class="calibre6" id="head-2-162">
      RETHROWING EXCEPTIONS
     </h2>
     <p class="calibre13">
      The
      <code class="calibre21">
       throw
      </code>
      keyword can also be used to rethrow the current exception without copying it, as in the following example:
     </p>
     <pre class="calibre26" id="c14-code-0044"><code class="calibre21">void g() { throw invalid_argument { "Some exception" }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">void f()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        g();</code>
<code class="calibre21">    } catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">        println("caught in f(): {}", e.what());</code>
<code class="calibre21">        <b class="calibre14">throw;</b>  <span class="color">// rethrow</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        f();</code>
<code class="calibre21">    } catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">        println("caught in main(): {}", e.what());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      This example produces the following output:
     </p>
     <pre class="calibre26" id="c14-code-0045"><code class="calibre21">caught in f(): Some exception</code>
<code class="calibre21">caught in main(): Some exception</code></pre>
     <p class="calibre13">
      You might think you could rethrow a caught exception
      <code class="calibre21">
       e
      </code>
      with
      <code class="calibre21">
       throw e;
      </code>
      . However, that's wrong, because it can cause slicing of your exception object. For example, suppose
      <code class="calibre21">
       f()
      </code>
      is modified to catch
      <code class="calibre21">
       std::exception
      </code>
      s, and
      <code class="calibre21">
       main()
      </code>
      is modified to catch both
      <code class="calibre21">
       exception
      </code>
      and
      <code class="calibre21">
       invalid_argument
      </code>
      exceptions:
     </p>
     <pre class="calibre26" id="c14-code-0046"><code class="calibre21">void g() { throw invalid_argument { "Some exception" }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">void f()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<span aria-label="556" class="calibre20" epub:type="pagebreak" id="Page_556" role="doc-pagebreak"></span><code class="calibre21">        g();</code>
<code class="calibre21">    <b class="calibre14">} catch (const exception&amp; e) {</b></code>
<code class="calibre21">        println("caught in f(): {}", e.what());</code>
<code class="calibre21">        throw;  <span class="color">// rethrow</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        f();</code>
<code class="calibre21">    } catch (const invalid_argument&amp; e) {</code>
<code class="calibre21">        <b class="calibre14">println("invalid_argument caught in main(): {}", e.what());</b></code>
<code class="calibre21">    <b class="calibre14">} catch (const exception&amp; e) {</b></code>
<code class="calibre21">        <b class="calibre14">println("exception caught in main(): {}", e.what());</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      Remember that
      <code class="calibre21">
       invalid_argument
      </code>
      derives from
      <code class="calibre21">
       exception
      </code>
      , hence it must be caught first. The output of this code is as you would expect, shown here:
     </p>
     <pre class="calibre26" id="c14-code-0047"><code class="calibre21">caught in f(): Some exception</code>
<code class="calibre21">invalid_argument caught in main(): Some exception</code></pre>
     <p class="calibre13">
      Now, try replacing the
      <code class="calibre21">
       throw;
      </code>
      statement in
      <code class="calibre21">
       f()
      </code>
      with
      <code class="calibre21">
       throw e;
      </code>
      . The output then becomes as follows:
     </p>
     <pre class="calibre26" id="c14-code-0048"><code class="calibre21">caught in f(): Some exception</code>
<code class="calibre21"><b class="calibre14">exception caught in main(): Some exception</b></code></pre>
     <p class="calibre13">
      <code class="calibre21">
       main()
      </code>
      seems to be catching an
      <code class="calibre21">
       exception
      </code>
      object, instead of an
      <code class="calibre21">
       invalid_argument
      </code>
      object. That's because the
      <code class="calibre21">
       throw e;
      </code>
      statement causes slicing, reducing the
      <code class="calibre21">
       invalid_argument
      </code>
      to an
      <code class="calibre21">
       exception
      </code>
      .
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c14-para-0127">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          Always use
         </i>
         <code class="calibre21">
          throw
          <i class="calibre18">
           ;
          </i>
         </code>
         <i class="calibre18">
          to rethrow an exception. Never do something like
         </i>
         <code class="calibre21">
          throw e;
         </code>
         <i class="calibre18">
          to rethrow a caught exception
         </i>
         <code class="calibre21">
          e
         </code>
         <i class="calibre18">
          !
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-163" class="calibre2">
     <span class="calibre" id="c14-sec-0039">
     </span>
     <h2 class="calibre6" id="head-2-163">
      STACK UNWINDING AND CLEANUP
     </h2>
     <p class="calibre13" id="c14-para-0128">
      When a piece of code throws an exception, it searches for a catch handler on the stack. This catch handler could be zero or more function calls up the stack of execution. When one is found, the stack is stripped back to the stack level that defines the catch handler by unwinding all intermediate stack frames.
      <i class="calibre18">
       Stack unwinding
      </i>
      means that the destructors for all locally scoped variables are called, and all code remaining in each function past the current point of execution is skipped.
     </p>
     <p class="calibre13">
      During stack unwinding, pointer variables are obviously not freed, and other cleanup is not performed either. This behavior can present problems. For example, the following code causes a memory leak:
     </p>
     <pre class="calibre26" id="c14-code-0049"><code class="calibre21">void funcOne();</code>
<code class="calibre21">void funcTwo();</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<span aria-label="557" class="calibre20" epub:type="pagebreak" id="Page_557" role="doc-pagebreak"></span><code class="calibre21">        funcOne();</code>
<code class="calibre21">    } catch (const exception&amp; e) {</code>
<code class="calibre21">        println(cerr, "Exception caught!");</code>
<code class="calibre21">        return 1;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void funcOne()</code>
<code class="calibre21">{</code>
<code class="calibre21">    string str1;</code>
<code class="calibre21">    string* str2 { new string {} };</code>
<code class="calibre21">    funcTwo();</code>
<code class="calibre21">    delete str2;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void funcTwo()</code>
<code class="calibre21">{</code>
<code class="calibre21">    ifstream fileStream;</code>
<code class="calibre21">    fileStream.open("filename");</code>
<code class="calibre21">    throw exception {};</code>
<code class="calibre21">    fileStream.close();</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      When
      <code class="calibre21">
       funcTwo()
      </code>
      throws an exception, the closest exception handler is in
      <code class="calibre21">
       main()
      </code>
      . Control then jumps immediately from this line in
      <code class="calibre21">
       funcTwo()
      </code>
      ,
     </p>
     <pre class="calibre26" id="c14-code-0050"><code class="calibre21">throw exception {};</code></pre>
     <p class="calibre13">
      to this line in
      <code class="calibre21">
       main()
      </code>
      :
     </p>
     <pre class="calibre26" id="c14-code-0051"><code class="calibre21">println(cerr, "Exception caught!");</code></pre>
     <p class="calibre13">
      In
      <code class="calibre21">
       funcTwo()
      </code>
      , control remains at the line that threw the exception, so this subsequent line never gets a chance to run:
     </p>
     <pre class="calibre26" id="c14-code-0052"><code class="calibre21">fileStream.close();</code></pre>
     <p class="calibre13" id="c14-para-0133">
      However, luckily for you, the
      <code class="calibre21">
       ifstream
      </code>
      destructor is called because
      <code class="calibre21">
       fileStream
      </code>
      is a local variable on the stack. The
      <code class="calibre21">
       ifstream
      </code>
      destructor closes the file for you, so there is no resource leak here. If you had dynamically allocated
      <code class="calibre21">
       fileStream
      </code>
      , it would not be destroyed, and the file would not be closed.
     </p>
     <p class="calibre13">
      In
      <code class="calibre21">
       funcOne()
      </code>
      , control is at the call to
      <code class="calibre21">
       funcTwo()
      </code>
      , so this subsequent line never gets a chance to run:
     </p>
     <pre class="calibre26" id="c14-code-0053"><code class="calibre21">delete str2;</code></pre>
     <p class="calibre13">
      In this case, there really is a memory leak. Stack unwinding does not automatically call
      <code class="calibre21">
       delete
      </code>
      on
      <code class="calibre21">
       str2
      </code>
      for you. On the other hand,
      <code class="calibre21">
       str1
      </code>
      is destroyed properly because it is a local variable on the stack. Stack unwinding destroys all local variables correctly.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c14-para-0136">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          Careless exception handling can lead to memory and resource leaks
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c14-para-0137">
      This is one reason why you should never mix older C models of allocation (even if you are calling
      <code class="calibre21">
       new
      </code>
      so it looks like C++) with modern programming methodologies like exceptions. In C++, this
      <span aria-label="558" class="calibre20" epub:type="pagebreak" id="Page_558" role="doc-pagebreak">
      </span>
      situation should be handled by using stack-based allocations or, if that is not possible, by one of the techniques discussed in the upcoming two sections.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-317">
       Use Smart Pointers
      </h3>
      <p class="calibre13">
       If stack-based allocation is not possible, then use smart pointers. They allow you to write code that automatically prevents memory or resource leaks during exception handling. Whenever a smart pointer object is destroyed, it frees the underlying resource. Here is a modified
       <code class="calibre21">
        funcOne()
       </code>
       implementation using a
       <code class="calibre21">
        unique_ptr
       </code>
       smart pointer, defined in
       <code class="calibre21">
        &lt;memory&gt;
       </code>
       , and introduced in
       <a class="calibre5" href="c07.xhtml">
        Chapter 7
       </a>
       , “Memory Management”:
      </p>
      <pre class="calibre26" id="c14-code-0054"><code class="calibre21">void funcOne()</code>
<code class="calibre21">{</code>
<code class="calibre21">    string str1;</code>
<code class="calibre21">    <b class="calibre14">auto str2 { make_unique&lt;string&gt;("hello") };</b></code>
<code class="calibre21">    funcTwo();</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0139">
       The
       <code class="calibre21">
        str2
       </code>
       pointer will automatically be deleted when you return from
       <code class="calibre21">
        funcOne()
       </code>
       or when an exception is thrown.
      </p>
      <p class="calibre13">
       Of course, you should only allocate something dynamically if you have a good reason to do so. For example, in
       <code class="calibre21">
        funcOne()
       </code>
       , there is no good reason to make
       <code class="calibre21">
        str2
       </code>
       a dynamically allocated string. It should just be a stack-based
       <code class="calibre21">
        string
       </code>
       variable. It's merely shown here as an artificial example of the consequences of throwing exceptions.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0141">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           With smart pointers, or other resource acquisition is initialization (RAII) objects, you never have to remember to free the underlying resource: the destructor of the RAII object does it for you, whether you leave the function normally or via an exception. It's a design technique discussed in
          </i>
          <a class="calibre5" href="c32.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           32
          </a>
          <i class="calibre18">
           , “Incorporating Design Techniques and Frameworks.”
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-318">
       Catch, Cleanup, and Rethrow
      </h3>
      <p class="calibre13">
       Another technique for avoiding memory and resource leaks is for each function to catch any possible exceptions, perform necessary cleanup work, and rethrow the exception for the function higher up the stack to handle. Here is a revised
       <code class="calibre21">
        funcOne()
       </code>
       with this technique:
      </p>
      <pre class="calibre26" id="c14-code-0055"><code class="calibre21">void funcOne()</code>
<code class="calibre21">{</code>
<code class="calibre21">    string str1;</code>
<code class="calibre21">    string* str2 { new string {} };</code>
<code class="calibre21">    <b class="calibre14">try {</b></code>
<code class="calibre21">        <b class="calibre14">funcTwo();</b></code>
<code class="calibre21">    <b class="calibre14">} catch (…) {</b></code>
<code class="calibre21">        <b class="calibre14">delete str2;</b></code>
<code class="calibre21">        <b class="calibre14">throw;</b> <span class="color">// Rethrow the exception.</span></code>
<code class="calibre21">    <b class="calibre14">}</b></code>
<code class="calibre21">    delete str2;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c14-para-0143">
       <span aria-label="559" class="calibre20" epub:type="pagebreak" id="Page_559" role="doc-pagebreak">
       </span>
       This function wraps the call to
       <code class="calibre21">
        funcTwo()
       </code>
       with an exception handler that performs the cleanup (calls
       <code class="calibre21">
        delete
       </code>
       on
       <code class="calibre21">
        str2
       </code>
       ) and then rethrows the exception. The keyword
       <code class="calibre21">
        throw
       </code>
       by itself rethrows whatever exception was caught most recently. Note that the catch statement uses the
       <code class="calibre21">
        …
       </code>
       syntax to catch all exceptions.
      </p>
      <p class="calibre13">
       This method works fine but is messy and error prone. In particular, note that there are now two identical lines that call
       <code class="calibre21">
        delete
       </code>
       on
       <code class="calibre21">
        str2
       </code>
       : one while handling the exception and one when the function exits normally.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0145">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           The preferred solution is to use stack-based allocation, or, if not possible, to use smart pointers or other RAII classes instead of the catch, cleanup, and rethrow technique
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-164" class="calibre2">
     <span class="calibre" id="c14-sec-0045">
     </span>
     <h2 class="calibre6" id="head-2-164">
      SOURCE LOCATION
     </h2>
     <p class="calibre13" id="c14-para-0146">
      Before C++20, you could use the following preprocessor macros to get information about a location in your source code:
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         MACRO
        </th>
        <th class="left" scope="col">
         DESCRIPTION
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          __FILE__
         </span>
        </td>
        <td class="bgcolor">
         Replaced with the current source code filename
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          __LINE__
         </span>
        </td>
        <td class="bgcolor">
         Replaced with the current line number in the source code
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13" id="c14-para-0148">
      Additionally, every function has a locally defined
      <code class="calibre21">
       static
      </code>
      character array called
      <code class="calibre21">
       __func__
      </code>
      containing the name of the function.
     </p>
     <p class="calibre13" id="c14-para-0149">
      Since C++20, a proper object-oriented replacement for
      <code class="calibre21">
       __func__
      </code>
      and these C-style preprocessor macros is available in the form of an
      <code class="calibre21">
       std::source:location
      </code>
      class, defined in
      <code class="calibre21">
       &lt;source:location&gt;
      </code>
      . An instance of
      <code class="calibre21">
       source:location
      </code>
      has the following public accessors:
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         ACCESSOR
        </th>
        <th class="left" scope="col">
         DESCRIPTION
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          file_name()
         </span>
        </td>
        <td class="bgcolor">
         Contains the current source code filename
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          function_name()
         </span>
        </td>
        <td class="bgcolor">
         Contains the current function name, if the current position is inside a function
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          line()
         </span>
        </td>
        <td class="bgcolor">
         Contains the current line number in the source code
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          column()
         </span>
        </td>
        <td class="bgcolor">
         Contains the current column number in the source code
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13" id="c14-para-0151">
      A
      <code class="calibre21">
       static
      </code>
      member function
      <code class="calibre21">
       current()
      </code>
      is provided that creates a
      <code class="calibre21">
       source:location
      </code>
      instance based on the location in the source code where the member function is called.
     </p>
     <span aria-label="560" class="calibre20" epub:type="pagebreak" id="Page_560" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-319">
       Source Location for Logging
      </h3>
      <p class="calibre13">
       The
       <code class="calibre21">
        source:location
       </code>
       class is useful for logging purposes. Previously, logging often involved writing C-style macros to automatically gather the current file name, function name, and line number, so they could be included in the log output. Now, with
       <code class="calibre21">
        source:location
       </code>
       , you can write a pure C++ function to perform your logging and to automatically collect the location data you require. A nice trick to do this is defining a
       <code class="calibre21">
        logMessage()
       </code>
       function as follows. This time, the code is prefixed with line numbers to better explain what is happening.
      </p>
      <pre class="calibre26" id="c14-code-0056"><code class="calibre21"> 5. void logMessage(string_view message,</code>
<code class="calibre21"> <b class="calibre14">6.     const source:location&amp; location = source:location::current())</b></code>
<code class="calibre21"> 7. {</code>
<code class="calibre21"> 8.     println("{}({}): {}: {}", location.file_name(),</code>
<code class="calibre21"> 9.         location.line(), location.function_name(), message);</code>
<code class="calibre21">10. }</code>
<code class="calibre21">11.</code>
<code class="calibre21">12. void foo()</code>
<code class="calibre21">13. {</code>
<code class="calibre21">14.     logMessage("Starting execution of foo().");</code>
<code class="calibre21">15. }</code>
<code class="calibre21">16.</code>
<code class="calibre21">17. int main()</code>
<code class="calibre21">18. {</code>
<code class="calibre21">19.     foo();</code>
<code class="calibre21">20. }</code></pre>
      <p class="calibre13" id="c14-para-0153">
       The second parameter of
       <code class="calibre21">
        logMessage()
       </code>
       is a
       <code class="calibre21">
        source:location
       </code>
       with the result of the
       <code class="calibre21">
        static
       </code>
       member function
       <code class="calibre21">
        current()
       </code>
       as default value. The trick here is that the call to
       <code class="calibre21">
        current()
       </code>
       does not happen on line 6, but actually at the location where
       <code class="calibre21">
        logMessage()
       </code>
       is called, which is line 14, and that's exactly the location you are interested in.
      </p>
      <p class="calibre13">
       When executing this program with Microsoft Visual C++, the output is as follows:
      </p>
      <pre class="calibre26" id="c14-code-0057"><code class="calibre21">./01_Logging.cpp(14): void __cdecl foo(void): Starting execution of foo().</code></pre>
      <p class="calibre13" id="c14-para-0155">
       Line 14 indeed corresponds to the line calling
       <code class="calibre21">
        logMessage()
       </code>
       . The exact name of the function,
       <code class="calibre21">
        void __cdecl foo(void)
       </code>
       in this case, is compiler dependent.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-320">
       Automatically Embed a Source Location in Custom Exceptions
      </h3>
      <p class="calibre13">
       Another interesting use case for
       <code class="calibre21">
        source:location
       </code>
       is in your own exception classes to automatically store the location where an exception was thrown. Here's an example:
      </p>
      <pre class="calibre26" id="c14-code-0058"><code class="calibre21">class MyException : public exception</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit MyException(string message,</code>
<code class="calibre21">            source:location location = source:location::current())</code>
<code class="calibre21">            : m_message { move(message) }</code>
<code class="calibre21">            , m_location { move(location) }</code>
<code class="calibre21">        { }</code>
<code class="calibre21"> </code>
<code class="calibre21">        const char* what() const noexcept override { return m_message.c_str(); }</code>
<code class="calibre21">        virtual const source:location&amp; where() const noexcept{ return m_location; }</code>
<span aria-label="561" class="calibre20" epub:type="pagebreak" id="Page_561" role="doc-pagebreak"></span><code class="calibre21">    private:</code>
<code class="calibre21">        string m_message;</code>
<code class="calibre21">        source:location m_location;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">void doSomething()</code>
<code class="calibre21">{</code>
<code class="calibre21">    throw MyException { "Throwing MyException." };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        doSomething();</code>
<code class="calibre21">    } catch (const MyException&amp; e) {</code>
<code class="calibre21">        const auto&amp; location { e.where() };</code>
<code class="calibre21">        println(cerr, "Caught: '{}' at line {} in {}.",</code>
<code class="calibre21">            e.what(), location.line(), location.function_name());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output with Microsoft Visual C++ is similar to the following:
      </p>
      <pre class="calibre26" id="c14-code-0059"><code class="calibre21">Caught: 'Throwing MyException.' at line 26 in void __cdecl doSomething(void).</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-165" class="calibre2">
     <span class="calibre" id="c14-sec-0048">
     </span>
     <h2 class="calibre6" id="head-2-165">
      <img alt="C++23" class="calibre15" src="images/icon1.png"/>
      STACK TRACE
     </h2>
     <p class="calibre13" id="c14-para-0159">
      Whenever a function
      <code class="calibre21">
       A()
      </code>
      calls another function
      <code class="calibre21">
       B()
      </code>
      , the arguments to be passed to
      <code class="calibre21">
       B()
      </code>
      are recorded and information about where to return to when the function is finished is recorded as well. The execution of
      <code class="calibre21">
       B()
      </code>
      can again call another function
      <code class="calibre21">
       C()
      </code>
      and so on. All this information is recorded in
      <i class="calibre18">
       frames
      </i>
      on a
      <i class="calibre18">
       stack trace
      </i>
      , also known as a
      <i class="calibre18">
       call stack
      </i>
      . For each function call, a new frame is added to the stack trace. When the execution of the function is finished, its frame is removed from the stack trace. At any given moment in the execution of your program, the stack trace tells you exactly through which function calls you arrived in the currently executing function. Information like this is vital for finding and fixing bugs in your program.
      <a class="calibre5" href="c31.xhtml">
       Chapter 31
      </a>
      , “Conquering Debugging,” discusses debugging in detail. This section discusses the functionality provided by the Standard Library to work with stack traces, as well as how this can be very useful in combination with custom exceptions. Everything discussed in this section is new since C++23.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0049">
      </span>
      <h3 class="calibre27" id="head-3-321">
       The Stack Trace Library
      </h3>
      <p class="calibre13">
       The stack trace library is defined in
       <code class="calibre21">
        &lt;stacktrace&gt;
       </code>
       . You can retrieve a stack trace at any moment in time using the
       <code class="calibre21">
        static
       </code>
       member function
       <code class="calibre21">
        std::stacktrace::current()
       </code>
       . You can pass an integer to
       <code class="calibre21">
        current()
       </code>
       if you want to skip a certain number of top frames. An example of this is given in the next section. Once you have a stack trace, you can easily print it to the console using
       <code class="calibre21">
        print()
       </code>
       or
       <code class="calibre21">
        println()
       </code>
       . You can also convert a stack trace to a string using
       <code class="calibre21">
        std::to_string()
       </code>
       . Here is an example, with the stack trace–related statements highlighted:
      </p>
      <pre class="calibre26" id="c14-code-0060"><code class="calibre21">void handleStackTrace(const stacktrace&amp; trace)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("  Stack trace information:");</code>
<code class="calibre21">    println("    There are {} frames in the stack trace.", <b class="calibre14">trace.size()</b>);</code>
<span aria-label="562" class="calibre20" epub:type="pagebreak" id="Page_562" role="doc-pagebreak"></span><code class="calibre21">    println("    Here are all the frames:");</code>
<code class="calibre21">    println("---------------------------------------------------------");</code>
<code class="calibre21">    println("{}", <b class="calibre14">trace</b>);</code>
<code class="calibre21">    <span class="color">// If the above statement doesn't work yet, you can use the following:</span></code>
<code class="calibre21">    <span class="color">//println("{}", to_string(trace));</span></code>
<code class="calibre21">    println("---------------------------------------------------------");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void C()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("Entered C().");</code>
<code class="calibre21">    handleStackTrace(<b class="calibre14">stacktrace::current()</b>);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void B() { println("Entered B().");   C(); }</code>
<code class="calibre21">void A() { println("Entered A().");   B(); }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    A();</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Compiled with Microsoft Visual C++ and running on Windows, the output resembles the following. Long pathnames have been trimmed to prevent wrapping of lines. The
       <code class="calibre21">
        01_stacktrace.cpp
       </code>
       file is our code. The
       <code class="calibre21">
        exe_common.inl
       </code>
       and
       <code class="calibre21">
        exe_main.cpp
       </code>
       files belong to the Visual C++ runtime. The final two frames,
       <code class="calibre21">
        kernel32
       </code>
       and
       <code class="calibre21">
        ntdll
       </code>
       , are part of the Windows kernel. Function names are highlighted for readability.
      </p>
      <pre class="calibre26" id="c14-code-0061"><code class="calibre21">Entered A().</code>
<code class="calibre21">Entered B().</code>
<code class="calibre21">Entered C().</code>
<code class="calibre21">  Stack trace information:</code>
<code class="calibre21">    There are 10 frames in the stack trace.</code>
<code class="calibre21">    Here are all the frames:</code>
<code class="calibre21">---------------------------------------------------------</code>
<code class="calibre21">0&gt; D:\…\01_stacktrace.cpp(20): TestApp!<b class="calibre14">C</b>+0x77</code>
<code class="calibre21">1&gt; D:\…\01_stacktrace.cpp(27): TestApp!<b class="calibre14">B</b>+0x61</code>
<code class="calibre21">2&gt; D:\…\01_stacktrace.cpp(33): TestApp!<b class="calibre14">A</b>+0x61</code>
<code class="calibre21">3&gt; D:\…\01_stacktrace.cpp(38): TestApp!<b class="calibre14">main</b>+0x20</code>
<code class="calibre21">4&gt; D:\…\exe_common.inl(79): TestApp!<b class="calibre14">invoke_main</b>+0x39</code>
<code class="calibre21">5&gt; D:\…\exe_common.inl(288): TestApp!<b class="calibre14">__scrt_common_main_seh</b>+0x12E</code>
<code class="calibre21">6&gt; D:\…\exe_common.inl(331): TestApp!<b class="calibre14">__scrt_common_main</b>+0xE</code>
<code class="calibre21">7&gt; D:\…\exe_main.cpp(17): TestApp!<b class="calibre14">mainCRTStartup</b>+0xE</code>
<code class="calibre21">8&gt; KERNEL32!<b class="calibre14">BaseThreadInitThunk</b>+0x1D</code>
<code class="calibre21">9&gt; ntdll!<b class="calibre14">RtlUserThreadStart</b>+0x28</code>
<code class="calibre21">---------------------------------------------------------</code></pre>
      <p class="calibre13">
       You can iterate over the individual frames of a stack trace and query for information of each frame. A frame is represented by the
       <code class="calibre21">
        std::stacktrace:entry
       </code>
       class, which supports the following member functions:
      </p>
      <ul class="check" id="c14-list-0006">
       <li class="calibre9" id="c14-li-0020">
        <b class="calibre14">
         <code class="calibre21">
          description()
         </code>
        </b>
        : Returns the description of the frame
       </li>
       <li class="calibre9" id="c14-li-0021">
        <b class="calibre14">
         <code class="calibre21">
          source:file()
         </code>
         and
         <code class="calibre21">
          source:line()
         </code>
        </b>
        : The name of the source file and the line number within it that contains the statement represented by the frame
       </li>
      </ul>
      <p class="calibre13">
       <span aria-label="563" class="calibre20" epub:type="pagebreak" id="Page_563" role="doc-pagebreak">
       </span>
       For example, the following implementation of
       <code class="calibre21">
        handleStackTrace()
       </code>
       doesn't just print the entire stack trace all at once but iterates over the individual frames and prints out only the description of each.
      </p>
      <pre class="calibre26" id="c14-code-0062"><code class="calibre21">void handleStackTrace(const stacktrace&amp; trace)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("  Stack trace information:");</code>
<code class="calibre21">    println("    There are {} frames in the stack trace.", trace.size());</code>
<code class="calibre21">    println("    Here are the descriptions of all the frames:");</code>
<code class="calibre21">    <b class="calibre14">for (unsigned index { 0 }; auto&amp;&amp; frame : trace) {</b></code>
<code class="calibre21">        println("      {} -&gt; {}", index++, <b class="calibre14">frame.description()</b>);</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output now is as follows:
      </p>
      <pre class="calibre26" id="c14-code-0063"><code class="calibre21">Entered A().</code>
<code class="calibre21">Entered B().</code>
<code class="calibre21">Entered C().</code>
<code class="calibre21">  Stack trace information:</code>
<code class="calibre21">    There are 10 frames in the stack trace.</code>
<code class="calibre21">    Here are the descriptions of all the frames:</code>
<code class="calibre21">      0 -&gt; TestApp!<b class="calibre14">C</b>+0x77</code>
<code class="calibre21">      1 -&gt; TestApp!<b class="calibre14">B</b>+0x61</code>
<code class="calibre21">      2 -&gt; TestApp!<b class="calibre14">A</b>+0x61</code>
<code class="calibre21">      3 -&gt; TestApp!<b class="calibre14">main</b>+0x20</code>
<code class="calibre21">      4 -&gt; TestApp!<b class="calibre14">invoke_main</b>+0x39</code>
<code class="calibre21">      <i class="calibre18">… &lt;snip&gt; </i>…</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0050">
      </span>
      <h3 class="calibre27" id="head-3-322">
       Automatically Embed a Stack Trace in Custom Exceptions
      </h3>
      <p class="calibre13">
       We can extend the
       <code class="calibre21">
        MyException
       </code>
       class from an earlier section on
       <code class="calibre21">
        source:location
       </code>
       to include a stack trace in addition to the source location.
      </p>
      <pre class="calibre26" id="c14-code-0064"><code class="calibre21">class MyException : public exception</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit MyException(string message,</code>
<code class="calibre21">            source:location location = source:location::current())</code>
<code class="calibre21">            : m_message { move(message) }</code>
<code class="calibre21">            , m_location { move(location) }</code>
<code class="calibre21">            <b class="calibre14">, m_stackTrace { stacktrace::current(1) }</b> <span class="color">// 1 means skip top frame.</span></code>
<code class="calibre21">        { }</code>
<code class="calibre21"> </code>
<code class="calibre21">        const char* what() const noexcept override { return m_message.c_str(); }</code>
<code class="calibre21">        virtual const source:location&amp; where() const noexcept{ return m_location; }</code>
<code class="calibre21">        <b class="calibre14">virtual const stacktrace&amp; how() const noexcept { return m_stackTrace; }</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_message;</code>
<code class="calibre21">        source:location m_location;</code>
<code class="calibre21">        <b class="calibre14">stacktrace m_stackTrace;</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Note that the constructor passes
       <code class="calibre21">
        1
       </code>
       to
       <code class="calibre21">
        stacktrace::current()
       </code>
       to skip the top frame of the stack trace. This top frame would be the constructor of
       <code class="calibre21">
        MyException
       </code>
       , which we are not interested in. We're
       <span aria-label="564" class="calibre20" epub:type="pagebreak" id="Page_564" role="doc-pagebreak">
       </span>
       interested only in the stack trace leading up to the construction of this
       <code class="calibre21">
        MyException
       </code>
       instance. This new exception class can be tested as follows:
      </p>
      <pre class="calibre26" id="c14-code-0065"><code class="calibre21">void doSomething()</code>
<code class="calibre21">{</code>
<code class="calibre21">    throw MyException { "Throwing MyException." };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        doSomething();</code>
<code class="calibre21">    } catch (const MyException&amp; e) {</code>
<code class="calibre21">        <span class="color">// Print exception description + location where exception was raised.</span></code>
<code class="calibre21">        const auto&amp; location { e.where() };</code>
<code class="calibre21">        println(cerr, "Caught: '{}' at line {} in {}.",</code>
<code class="calibre21">            e.what(), location.line(), location.function_name());</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Print the stack trace at the point where the exception was raised.</span></code>
<code class="calibre21">        println(cerr, "  Stack trace:");</code>
<code class="calibre21">        for (unsigned index { 0 }; auto&amp;&amp; frame : e.how()) {</code>
<code class="calibre21">            const string&amp; fileName { frame.source:file() };</code>
<code class="calibre21">            println(cerr, "    {}&gt; {}, {}({})", index++, frame.description(),</code>
<code class="calibre21">                (fileName.empty() ? "n/a" : fileName), frame.source:line());</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       When compiling with Microsoft Visual C++ and running on Windows, the output resembles the following. Only the top two relevant entries of the stack trace are shown. The stack entries that are inside the Visual C++ runtime or inside Windows itself are omitted for brevity.
      </p>
      <pre class="calibre26" id="c14-code-0066"><code class="calibre21">Caught: 'Throwing MyException.' at line 30 in void __cdecl doSomething(void).</code>
<code class="calibre21">  Stack trace:</code>
<code class="calibre21">    0 &gt; TestApp!<b class="calibre14">doSomething</b>+0xD2, D:\…\03_CustomExceptionWithStackTrace.cpp(30)</code>
<code class="calibre21">    1 &gt; TestApp!<b class="calibre14">main</b>+0x4D, D:\…\03_CustomExceptionWithStackTrace.cpp(36)</code>
<code class="calibre21">    <i class="calibre18">… &lt;snip&gt; ..</i>.</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0169">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           If you are using custom exceptions, embed a stack trace in them for easier debugging of errors
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-166" class="calibre2">
     <span class="calibre" id="c14-sec-0052">
     </span>
     <h2 class="calibre6" id="head-2-166">
      COMMON ERROR-HANDLING ISSUES
     </h2>
     <p class="calibre13" id="c14-para-0170">
      Whether or not you use exceptions in your programs is up to you and your colleagues. However, you are strongly encouraged to formalize an error-handling plan for your programs, regardless of your use of exceptions. If you use exceptions, it is generally easier to come up with a unified error-handling scheme, but it is not impossible without exceptions. The most important aspect of a good plan is uniformity of error handling throughout all the modules of the program. Make sure that every programmer on the project understands and follows the error-handling rules.
     </p>
     <p class="calibre13" id="c14-para-0171">
      This section discusses the most common error-handling issues in the context of exceptions, but the issues are also relevant to programs that do not use exceptions.
     </p>
     <span aria-label="565" class="calibre20" epub:type="pagebreak" id="Page_565" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0053">
      </span>
      <h3 class="calibre27" id="head-3-323">
       Memory Allocation Errors
      </h3>
      <p class="calibre13" id="c14-para-0172">
       Despite that all the examples so far in this book have ignored the possibility, memory allocation can fail. On current 64-bit platforms, this will almost never happen, but on mobile or legacy systems, memory allocation can fail. On such systems, you must account for memory allocation failures. C++ provides several different ways to handle memory errors.
      </p>
      <p class="calibre13" id="c14-para-0173">
       The default behaviors of
       <code class="calibre21">
        new
       </code>
       and
       <code class="calibre21">
        new[]
       </code>
       are to throw an exception of type
       <code class="calibre21">
        bad_alloc
       </code>
       , defined in
       <code class="calibre21">
        &lt;new&gt;
       </code>
       , if they cannot allocate memory. Your code could catch these exceptions and handle them appropriately.
      </p>
      <p class="calibre13">
       It's not realistic to wrap all your calls to
       <code class="calibre21">
        new
       </code>
       and
       <code class="calibre21">
        new[]
       </code>
       with a
       <code class="calibre21">
        try/catch
       </code>
       , but at least you should do so when you are trying to allocate a big block of memory. The following example demonstrates how to catch memory allocation exceptions:
      </p>
      <pre class="calibre26" id="c14-code-0067"><code class="calibre21">int* ptr { nullptr };</code>
<code class="calibre21">size_t integerCount { numeric_limits&lt;size_t&gt;::max() };</code>
<code class="calibre21">println("Trying to allocate memory for {} integers.", integerCount);</code>
<code class="calibre21">try {</code>
<code class="calibre21">    ptr = new int[integerCount];</code>
<code class="calibre21">} catch (const bad_alloc&amp; e) {</code>
<code class="calibre21">    auto location { source:location::current() };</code>
<code class="calibre21">    println(cerr, "{}({}): Unable to allocate memory: {}",</code>
<code class="calibre21">        location.file_name(), location.line(), e.what());</code>
<code class="calibre21">    <span class="color">// Handle memory allocation failure.</span></code>
<code class="calibre21">    return;</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Proceed with function that assumes memory has been allocated.</span></code></pre>
      <p class="calibre13" id="c14-para-0175">
       Note that this code uses
       <code class="calibre21">
        source:location
       </code>
       to include the name of the file and the current line number in the error message. This makes debugging easier.
      </p>
      <p class="calibre13" id="c14-para-0176">
       You could, of course, bulk handle many possible new failures with a single
       <code class="calibre21">
        try
       </code>
       /
       <code class="calibre21">
        catch
       </code>
       block at a higher point in the program, if that works for your program.
      </p>
      <p class="calibre13" id="c14-para-0177">
       Another point to consider is that logging an error might try to allocate memory. If
       <code class="calibre21">
        new
       </code>
       fails, there might not be enough memory left even to log the error message.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c14-sec-0054">
       </span>
       <h4 class="calibre29" id="head-4-243">
        Non-throwing new
       </h4>
       <p class="calibre13">
        If you don't like exceptions, you can revert to the old C model in which memory allocation routines return a null pointer if they cannot allocate memory. C++ provides
        <i class="calibre18">
         nothrow
        </i>
        overloads of
        <code class="calibre21">
         new
        </code>
        and
        <code class="calibre21">
         new[]
        </code>
        , which return
        <code class="calibre21">
         nullptr
        </code>
        instead of throwing an exception if they fail to allocate memory. This is done by using the syntax
        <code class="calibre21">
         new(nothrow)
        </code>
        instead of
        <code class="calibre21">
         new
        </code>
        , as shown in the following example:
       </p>
       <pre class="calibre26" id="c14-code-0068"><code class="calibre21">int* ptr { new(nothrow) int[integerCount] };</code>
<code class="calibre21">if (ptr == nullptr) {</code>
<code class="calibre21">    auto location { source:location::current() };</code>
<code class="calibre21">    println(cerr, "{}({}): Unable to allocate memory!",</code>
<code class="calibre21">        location.file_name(), location.line());</code>
<code class="calibre21">    <span class="color">// Handle memory allocation failure.</span></code>
<code class="calibre21">    return;</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Proceed with function that assumes memory has been allocated.</span></code></pre>
       <p class="calibre13">
        <span aria-label="566" class="calibre20" epub:type="pagebreak" id="Page_566" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c14-para-0180">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            I do not recommend using non-throwing
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            , but the default behavior, which uses exceptions. An exception thrown when allocation fails cannot be ignored, while it's easy to forget checking for
           </i>
           <code class="calibre21">
            nullptr
           </code>
           <i class="calibre18">
            when using non-throwing
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c14-sec-0056">
       </span>
       <h4 class="calibre29" id="head-4-244">
        Customizing Memory Allocation Failure Behavior
       </h4>
       <p class="calibre13">
        C++ allows you to specify a
        <i class="calibre18">
         new handler
        </i>
        callback function. By default, there is no new handler, so
        <code class="calibre21">
         new
        </code>
        and
        <code class="calibre21">
         new[]
        </code>
        just throw
        <code class="calibre21">
         bad_alloc
        </code>
        exceptions. However, if there is a new handler, the memory allocation routine calls the new handler upon memory allocation failure instead of throwing an exception. If the new handler returns, the memory allocation routine attempts to allocate memory again, calling the new handler again if it fails. This cycle could become an infinite loop unless your new handler changes the situation with one of three alternatives. Practically speaking, some of the options are better than others.
       </p>
       <ul class="check" id="c14-list-0007">
        <li class="calibre9" id="c14-li-0022">
         <b class="calibre14">
          Make more memory available.
         </b>
         One trick to expose space is to allocate a large chunk of memory at program start-up and then to free it in the new handler. A practical example is when you hit an allocation error and you need to save the user state so no work gets lost. The key is to allocate a block of memory at program start-up large enough to allow a complete document save operation. When the new handler is triggered, you free this block, save the document, restart the application, and let it reload the saved document.
        </li>
        <li class="calibre9" id="c14-li-0023">
         <b class="calibre14">
          Throw an exception.
         </b>
         The C++ standard mandates that if you throw an exception from your new handler, it must be a
         <code class="calibre21">
          bad_alloc
         </code>
         exception or an exception derived from
         <code class="calibre21">
          bad_alloc
         </code>
         . Here are some examples:
         <ul class="check3" id="c14-list-0008">
          <li class="calibre9" id="c14-li-0024">
           <b class="calibre14">
            Write and throw a
           </b>
           <code class="calibre21">
            document_recovery_alloc
           </code>
           <b class="calibre14">
            exception, deriving from
           </b>
           <code class="calibre21">
            bad_alloc
           </code>
           <b class="calibre14">
            .
           </b>
           This exception can be caught somewhere in your application to trigger the document save operation and restart of the application.
          </li>
          <li class="calibre9" id="c14-li-0025">
           <b class="calibre14">
            Write and throw a
           </b>
           <code class="calibre21">
            please_terminate_me
           </code>
           <b class="calibre14">
            exception, deriving from
           </b>
           <code class="calibre21">
            bad_alloc
           </code>
           . In your top-level function—for example,
           <code class="calibre21">
            main()
           </code>
           —you catch this exception and handle it by returning from the top-level function. It's recommended to terminate a program by returning from the top-level function, instead of by calling a function such as
           <code class="calibre21">
            exit()
           </code>
           .
          </li>
         </ul>
        </li>
        <li class="calibre9" id="c14-li-0026">
         <b class="calibre14">
          Set a different new handler.
         </b>
         Theoretically, you could have a series of new handlers, each of which tries to create memory and sets a different new handler if it fails. However, such a scenario is usually more complicated than useful.
        </li>
       </ul>
       <p class="calibre13" id="c14-para-0183">
        If you don't do one of these things in your new handler, any memory allocation failure will cause an infinite loop.
       </p>
       <p class="calibre13" id="c14-para-0184">
        If there are some memory allocations that can fail but you don't want your new handler to be called, you can simply set the new handler back to its default of
        <code class="calibre21">
         nullptr
        </code>
        temporarily before calling
        <code class="calibre21">
         new
        </code>
        in such cases.
       </p>
       <p class="calibre13">
        <span aria-label="567" class="calibre20" epub:type="pagebreak" id="Page_567" role="doc-pagebreak">
        </span>
        You set the new handler with a call to
        <code class="calibre21">
         set_new_handler()
        </code>
        , declared in
        <code class="calibre21">
         &lt;new&gt;
        </code>
        . Here is an example of a new handler that logs an error message and throws an exception:
       </p>
       <pre class="calibre26" id="c14-code-0069"><code class="calibre21">class please_terminate_me : public bad_alloc { };</code>
<code class="calibre21"> </code>
<code class="calibre21">void myNewHandler()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println(cerr, "Unable to allocate memory.");</code>
<code class="calibre21">    throw please_terminate_me {};</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The new handler must take no arguments and return no value. This new handler throws a
        <code class="calibre21">
         please_terminate_me
        </code>
        exception, as suggested in the preceding list. You can activate this new handler like this:
       </p>
       <pre class="calibre26" id="c14-code-0070"><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        <span class="color">// Set the new new_handler and save the old one.</span></code>
<code class="calibre21">        new_handler oldHandler { set_new_handler(myNewHandler) };</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Generate allocation error.</span></code>
<code class="calibre21">        size_t numInts { numeric_limits&lt;size_t&gt;::max() };</code>
<code class="calibre21">        int* ptr { new int[numInts] };</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Reset the old new_handler.</span></code>
<code class="calibre21">        set_new_handler(oldHandler);</code>
<code class="calibre21">    } catch (const please_terminate_me&amp;) {</code>
<code class="calibre21">        auto location { source:location::current() };</code>
<code class="calibre21">        println(cerr, "{}({}): Terminating program.",</code>
<code class="calibre21">            location.file_name(), location.line());</code>
<code class="calibre21">        return 1;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c14-para-0187">
        <code class="calibre21">
         new_handler
        </code>
        is a type alias for the type of function pointer that
        <code class="calibre21">
         set_new_handler()
        </code>
        takes.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0057">
      </span>
      <h3 class="calibre27" id="head-3-324">
       Errors in Constructors
      </h3>
      <p class="calibre13" id="c14-para-0188">
       Before C++ programmers discover exceptions, they are often stymied by error handling and constructors. What if a constructor fails to construct the object properly? Constructors don't have a return value, so the standard pre-exception error-handling mechanism doesn't work. Without exceptions, the best you can do is to set a flag in the object specifying that it is not constructed properly. You can provide a member function, with a name like
       <code class="calibre21">
        checkConstructionStatus()
       </code>
       , which returns the value of that flag, and hope that clients remember to call this member function on the object after constructing it.
      </p>
      <p class="calibre13" id="c14-para-0189">
       Exceptions provide a much better solution. You can throw an exception from a constructor, even though you can't return a value
       <a aria-describedby="c14-note-0001" class="calibre5" epub:type="noteref" href="#c14-note-0001" id="R_c14-note-0001" role="doc-noteref">
        <sup class="calibre22">
         1
        </sup>
       </a>
       . With exceptions, you can easily tell clients whether construction of an object succeeded. However, there is one major problem: if an exception leaves a constructor, the
       <span aria-label="568" class="calibre20" epub:type="pagebreak" id="Page_568" role="doc-pagebreak">
       </span>
       destructor for that object will never be called! Thus, you must be careful to clean up any resources and free any allocated memory in constructors before allowing exceptions to leave the constructor.
      </p>
      <p class="calibre13">
       This section describes a
       <code class="calibre21">
        Matrix
       </code>
       class template as an example in which the constructor correctly handles exceptions. Note that this example is using a raw pointer called
       <code class="calibre21">
        m_matrix
       </code>
       to demonstrate the problems. In production-quality code, you should avoid using raw pointers, for example, by using a Standard Library container! The definition of the
       <code class="calibre21">
        Matrix
       </code>
       class template looks like this:
      </p>
      <pre class="calibre26" id="c14-code-0071"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class Matrix final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Matrix(std::size_t width, std::size_t height);</code>
<code class="calibre21">        ˜Matrix();</code>
<code class="calibre21">        <span class="color">// Copy/move ctors and copy/move assignment operators deleted (omitted).</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        void cleanup();</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::size_t m_width { 0 };</code>
<code class="calibre21">        std::size_t m_height { 0 };</code>
<code class="calibre21">        T** m_matrix { nullptr };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The implementation of the
       <code class="calibre21">
        Matrix
       </code>
       class is as follows. The first call to
       <code class="calibre21">
        new
       </code>
       is not protected with a
       <code class="calibre21">
        try/catch
       </code>
       block. It doesn't matter if the first
       <code class="calibre21">
        new
       </code>
       throws an exception because the constructor hasn't allocated anything else yet that needs freeing. If any of the subsequent
       <code class="calibre21">
        new
       </code>
       calls throw an exception, though, the constructor must clean up all of the memory already allocated. The constructor doesn't know what exceptions the
       <code class="calibre21">
        T
       </code>
       constructors themselves might throw, so it catches all exceptions via
       <code class="calibre21">
        …
       </code>
       and then nests the caught exception inside a
       <code class="calibre21">
        bad_alloc
       </code>
       exception. The array allocated with the first call to
       <code class="calibre21">
        new
       </code>
       is zero-initialized using the
       <code class="calibre21">
        {}
       </code>
       syntax; that is, each element will be
       <code class="calibre21">
        nullptr
       </code>
       . This makes the
       <code class="calibre21">
        cleanup()
       </code>
       member function easier, because it is allowed to call
       <code class="calibre21">
        delete
       </code>
       on a
       <code class="calibre21">
        nullptr
       </code>
       .
      </p>
      <pre class="calibre26" id="c14-code-0072"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">Matrix&lt;T&gt;::Matrix(std::size_t width, std::size_t height)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_matrix = new T*[width] {};    <span class="color">// Array is zero-initialized!</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Don't initialize the m_width and m_height members in the ctor-</span></code>
<code class="calibre21">    <span class="color">// initializer. These should only be initialized when the above</span></code>
<code class="calibre21">    <span class="color">// m_matrix allocation succeeds!</span></code>
<code class="calibre21">    m_width = width;</code>
<code class="calibre21">    m_height = height;</code>
<code class="calibre21"> </code>
<code class="calibre21">    try {</code>
<code class="calibre21">        for (std::size_t i { 0 }; i &lt; width; ++i) {</code>
<code class="calibre21">            m_matrix[i] = new T[height];</code>
<code class="calibre21">        }</code>
<code class="calibre21">    } catch (…) {</code>
<code class="calibre21">        std::println(std::cerr, "Exception caught in constructor, cleaning up…");</code>
<code class="calibre21">        cleanup();</code>
<code class="calibre21">        <span class="color">// Nest any caught exception inside a bad_alloc exception.</span></code>
<code class="calibre21">        std::throw_with_nested(std::bad_alloc {});</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="569" class="calibre20" epub:type="pagebreak" id="Page_569" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">Matrix&lt;T&gt;::˜Matrix()</code>
<code class="calibre21">{</code>
<code class="calibre21">    cleanup();</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void Matrix&lt;T&gt;::cleanup()</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (std::size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        delete[] m_matrix[i];</code>
<code class="calibre21">    }</code>
<code class="calibre21">    delete[] m_matrix;</code>
<code class="calibre21">    m_matrix = nullptr;</code>
<code class="calibre21">    m_width = m_height = 0;</code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0193">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Remember, if an exception leaves a constructor, the destructor for that object will never be called!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       The
       <code class="calibre21">
        Matrix
       </code>
       class template can be tested as follows. Catching the bad_alloc exception in main() is omitted for brevity.
      </p>
      <pre class="calibre26" id="c14-code-0073"><code class="calibre21">class Element</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Kept to a bare minimum, but in practice, this Element class</span></code>
<code class="calibre21">    <span class="color">// could throw exceptions in its constructor.</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_value;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Matrix&lt;Element&gt; m { 10, 10 };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You might be wondering what happens when you add inheritance into the mix. Base class constructors run before derived class constructors. If a derived class constructor throws an exception, C++ will execute the destructor of the fully constructed base classes.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0196">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           C++ guarantees that it will run the destructor for all fully constructed “subobjects.” Therefore, any constructor that completes without an exception will cause the corresponding destructor to be run
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0060">
      </span>
      <h3 class="calibre27" id="head-3-325">
       Function-Try-Blocks for Constructors
      </h3>
      <p class="calibre13" id="c14-para-0197">
       The exception mechanism, as discussed up to now in this chapter, is perfect for handling exceptions within functions. But how should you handle exceptions thrown from inside a ctor-initializer of a constructor? This section explains a feature called
       <i class="calibre18">
        function-try-blocks
       </i>
       , which are capable of catching
       <span aria-label="570" class="calibre20" epub:type="pagebreak" id="Page_570" role="doc-pagebreak">
       </span>
       those exceptions. Function-try-blocks work for normal functions as well as for constructors. This section focuses on the use with constructors. Most C++ programmers, even experienced C++ programmers, don't know of the existence of this feature, even though it was introduced a long time ago.
      </p>
      <p class="calibre13">
       The following piece of pseudo-code shows the basic syntax for a function-try-block for a constructor:
      </p>
      <pre class="calibre26" id="c14-code-0074"><code class="calibre21">MyClass::MyClass()</code>
<code class="calibre21">try</code>
<code class="calibre21">    : &lt;ctor-initializer&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">/* … constructor body … */</span></code>
<code class="calibre21">}</code>
<code class="calibre21">catch (const exception&amp; e)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">/* … */</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       As you can see, the
       <code class="calibre21">
        try
       </code>
       keyword should be right before the start of the ctor-initializer. The
       <code class="calibre21">
        catch
       </code>
       statements should be after the closing brace for the constructor, actually putting them outside the constructor body. There are a number of restrictions and guidelines that you should keep in mind when using function-try-blocks with constructors:
      </p>
      <ul class="check" id="c14-list-0009">
       <li class="calibre9" id="c14-li-0027">
        The
        <code class="calibre21">
         catch
        </code>
        statements catch any exception thrown either directly or indirectly by the ctor-initializer or by the constructor body.
       </li>
       <li class="calibre9" id="c14-li-0028">
        The
        <code class="calibre21">
         catch
        </code>
        statements have to rethrow the current exception or throw a new exception. If a
        <code class="calibre21">
         catch
        </code>
        statement doesn't do this, the runtime automatically rethrows the current exception.
       </li>
       <li class="calibre9" id="c14-li-0029">
        The
        <code class="calibre21">
         catch
        </code>
        statements can access arguments passed to the constructor.
       </li>
       <li class="calibre9" id="c14-li-0030">
        When a
        <code class="calibre21">
         catch
        </code>
        statement catches an exception in a function-try-block, all fully constructed base classes and members of the object are destroyed before execution of the
        <code class="calibre21">
         catch
        </code>
        statement starts.
       </li>
       <li class="calibre9" id="c14-li-0031">
        Inside
        <code class="calibre21">
         catch
        </code>
        statements you should not access data members that are objects because these are destroyed prior to executing the
        <code class="calibre21">
         catch
        </code>
        statements (see the previous bullet). However, if your object contains non-class data members—for example, raw pointers—you can access them if they have been initialized before the exception was thrown. If you have such raw, also called
        <i class="calibre18">
         naked
        </i>
        , resources, you have to take care of them by freeing them in the
        <code class="calibre21">
         catch
        </code>
        statements, as the upcoming example demonstrates.
       </li>
       <li class="calibre9" id="c14-li-0032">
        The catch statements in a function-try-block for a constructor cannot use the return keyword.
       </li>
      </ul>
      <p class="calibre13">
       Based on this list of limitations, function-try-blocks for constructors are useful only in a limited number of situations:
      </p>
      <ul class="check" id="c14-list-0010">
       <li class="calibre9" id="c14-li-0033">
        To convert an exception thrown by the ctor-initializer to another exception
       </li>
       <li class="calibre9" id="c14-li-0034">
        To log a message to a log file
       </li>
       <li class="calibre9" id="c14-li-0035">
        To free raw resources that have been allocated in the ctor-initializer prior to the exception being thrown
       </li>
      </ul>
      <p class="calibre13">
       <span aria-label="571" class="calibre20" epub:type="pagebreak" id="Page_571" role="doc-pagebreak">
       </span>
       The following example demonstrates how to use function-try-blocks. The code defines a class called
       <code class="calibre21">
        SubObject
       </code>
       . It has only one constructor, which throws an exception of type
       <code class="calibre21">
        runtime_error
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0075"><code class="calibre21">class SubObject</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit SubObject(int i) {</code>
<code class="calibre21">            throw runtime_error { "Exception by SubObject ctor" }; }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Next, the
       <code class="calibre21">
        MyClass
       </code>
       class has a data member of type
       <code class="calibre21">
        int*
       </code>
       and another one of type
       <code class="calibre21">
        SubObject
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0076"><code class="calibre21">class MyClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        MyClass();</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int* m_data { nullptr };</code>
<code class="calibre21">        SubObject m_subObject;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        SubObject
       </code>
       class does not have a default constructor. This means you need to initialize
       <code class="calibre21">
        m_subObject
       </code>
       in the
       <code class="calibre21">
        MyClass
       </code>
       ctor-initializer. The constructor of
       <code class="calibre21">
        MyClass
       </code>
       uses a function-try-block to catch exceptions thrown in its ctor-initializer as follows:
      </p>
      <pre class="calibre26" id="c14-code-0077"><code class="calibre21">MyClass::MyClass()</code>
<code class="calibre21">try</code>
<code class="calibre21">    : m_data { new int[42]{ 1, 2, 3 } }, m_subObject { 42 }</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">/* … constructor body … */</span></code>
<code class="calibre21">}</code>
<code class="calibre21">catch (const exception&amp; e)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Cleanup memory.</span></code>
<code class="calibre21">    delete[] m_data;</code>
<code class="calibre21">    m_data = nullptr;</code>
<code class="calibre21">    println(cerr, "function-try-block caught: '{}'", e.what());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Remember that
       <code class="calibre21">
        catch
       </code>
       statements in a function-try-block for a constructor have to either rethrow the current exception or throw a new exception. The preceding
       <code class="calibre21">
        catch
       </code>
       statement does not throw anything, so the C++ runtime automatically rethrows the current exception. The following is a simple function that uses
       <code class="calibre21">
        MyClass
       </code>
       :
      </p>
      <pre class="calibre26" id="c14-code-0078"><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        MyClass m;</code>
<code class="calibre21">    } catch (const exception&amp; e) {</code>
<code class="calibre21">        println(cerr, "main() caught: '{}'", e.what());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c14-code-0079"><code class="calibre21">function-try-block caught: 'Exception by SubObject ctor'</code>
<code class="calibre21">main() caught: 'Exception by SubObject ctor'</code></pre>
      <p class="calibre13" id="c14-para-0206">
       <span aria-label="572" class="calibre20" epub:type="pagebreak" id="Page_572" role="doc-pagebreak">
       </span>
       Note that the code in this example is error prone and not recommended. A proper solution for this example's case is to make the
       <code class="calibre21">
        m_data
       </code>
       member a container, such as
       <code class="calibre21">
        std::vector
       </code>
       , or a smart pointer, such as
       <code class="calibre21">
        unique_ptr
       </code>
       , and to remove the function-try-block.
      </p>
      <p class="calibre13">
       Function-try-blocks are not limited to constructors. They can be used with ordinary functions as well. However, for normal functions, there is no useful reason to use function-try-blocks because they can just as easily be converted to a simple
       <code class="calibre21">
        try/catch
       </code>
       block inside the function body. One notable difference when using a function-try-block on a normal function compared to a constructor is that rethrowing the current exception or throwing a new exception in the
       <code class="calibre21">
        catch
       </code>
       statements is not required, and the C++ runtime will not automatically rethrow the exception. Using the return keyword in such catch statements is allowed.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0208">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Avoid using function-try-blocks
          </i>
          !
         </p>
         <p class="calibre25" id="c14-para-0209">
          <i class="calibre18">
           Function-try-blocks are usually necessary only when you have raw resources as data members. Raw resources should be avoided by using RAII classes such as
          </i>
          <code class="calibre21">
           std::vector
          </code>
          <i class="calibre18">
          </i>
          or
          <i class="calibre18">
          </i>
          <code class="calibre21">
           unique_ptr
          </code>
          <i class="calibre18">
           . The RAII design pattern is discussed in
           <a class="calibre5" href="c32.xhtml">
            Chapter 32
           </a>
           .
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c14-sec-0062">
      </span>
      <h3 class="calibre27" id="head-3-326">
       Errors in Destructors
      </h3>
      <p class="calibre13">
       You should handle all error conditions that arise in destructors in the destructors themselves. You should not let any exceptions be thrown from destructors, for a couple of reasons:
      </p>
      <ol class="calibre7" id="c14-list-0011">
       <li class="calibre9" id="c14-li-0036">
        What action would clients take? Clients don't call destructors explicitly; destructors are called automatically for them. If you throw an exception from a destructor, what is a client supposed to do? There is no reasonable action the client can take, so there is no reason to burden that code with exception handling.
       </li>
       <li class="calibre9" id="c14-li-0037">
        The destructor is your one chance to free memory and resources used in the object. If you waste your chance by exiting the function early due to an exception, you will never be able to go back and free the memory or resources.
       </li>
       <li class="calibre9" id="c14-li-0038">
        Destructors are implicitly marked as
        <code class="calibre21">
         noexcept
        </code>
        , unless they are explicitly marked with
        <code class="calibre21">
         noexcept(false)
        </code>
        or the class has any subobjects with a
        <code class="calibre21">
         noexcept(false)
        </code>
        destructor. If you throw an exception from a
        <code class="calibre21">
         noexcept
        </code>
        destructor, the C++ runtime calls
        <code class="calibre21">
         std::terminate()
        </code>
        to terminate the application.
       </li>
       <li class="calibre9" id="c14-li-0039">
        Destructors can run during the process of stack unwinding while there is another exception being handled. If you throw an exception from the destructor in the middle of stack unwinding, the C++ runtime calls
        <code class="calibre21">
         std::terminate()
        </code>
        to terminate the application. For the brave and curious, C++ does provide the ability to determine, in a destructor, whether you are executing as a result of a normal function exit or delete call or because of stack unwinding. The function
        <code class="calibre21">
         uncaught_exceptions()
        </code>
        , declared in
        <code class="calibre21">
         &lt;exception&gt;
        </code>
        , returns the number of uncaught exceptions, that is, exceptions that have been thrown but that have not reached a matching
        <code class="calibre21">
         catch
        </code>
        yet. If the result of
        <code class="calibre21">
         uncaught_exceptions()
        </code>
        is greater than zero, then you are in the middle of stack unwinding. However, correct use of this function is complicated, messy, and should be avoided. Note that before C++17, the function was called
        <span aria-label="573" class="calibre20" epub:type="pagebreak" id="Page_573" role="doc-pagebreak">
        </span>
        <span aria-label="574" class="calibre20" epub:type="pagebreak" id="Page_574" role="doc-pagebreak">
        </span>
        <code class="calibre21">
         uncaught_exception()
        </code>
        (singular) and returned a
        <code class="calibre21">
         bool
        </code>
        that was
        <code class="calibre21">
         true
        </code>
        if you were in the middle of stack unwinding. This singular version is deprecated since C++17 and removed since C++20.
       </li>
      </ol>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c14-para-0211">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Be careful not to let any exceptions escape from a destructor
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-167" class="calibre2">
     <span class="calibre" id="c14-sec-0064">
     </span>
     <h2 class="calibre6" id="head-2-167">
      EXCEPTION SAFETY GUARANTEES
     </h2>
     <p class="calibre13">
      Now that you are fluent in working with exceptions, it's time to discuss
      <i class="calibre18">
       exception safety guarantees
      </i>
      . There are several levels of guarantees you can provide for code you write so that users of your code know what can be expected when an exception is thrown. The following exception safety guarantees can be specified for a function:
     </p>
     <ul class="check" id="c14-list-0012">
      <li class="calibre9" id="c14-li-0040">
       <b class="calibre14">
        Nothrow (or nofail) exception guarantee:
       </b>
       The function never throws any exceptions.
      </li>
      <li class="calibre9" id="c14-li-0041">
       <b class="calibre14">
        Strong exception guarantee:
       </b>
       If an exception is thrown, all involved objects are rolled back to the state they were in before the function was called. An example of code providing this guarantee is the copy-and-swap idiom introduced in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       .
      </li>
      <li class="calibre9" id="c14-li-0042">
       <b class="calibre14">
        Basic exception guarantee:
       </b>
       If an exception is thrown, all involved objects remain in a valid state, and no resources are leaked. However, the objects could be in another state than they were before the function was called.
      </li>
      <li class="calibre9" id="c14-li-0043">
       <b class="calibre14">
        No guarantee:
       </b>
       When an exception is thrown, the application can be in any invalid state, resources might be leaked, memory might be corrupted, and so on.
      </li>
     </ul>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c14-para-0213">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          If a function can throw exceptions, then it should provide, at the very least, a basic exception guarantee
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-168" class="calibre2">
     <span class="calibre" id="c14-sec-0066">
     </span>
     <h2 class="calibre6" id="head-2-168">
      SUMMARY
     </h2>
     <p class="calibre13" id="c14-para-0214">
      This chapter described the issues related to error handling in C++ programs and emphasized that you must design and code your programs with an error-handling plan. By reading this chapter, you learned the details of C++ exceptions syntax and behavior. You learned how to write custom exception classes that automatically embed the location where an exception was raised and the full stack trace at that moment. The chapter also covered some of the areas in which error handling plays a large role, including I/O streaming, memory allocation, constructors, and destructors. The chapter finished with the different kinds of exception safety guarantees a function can provide.
     </p>
    </section>
    <section aria-labelledby="head-2-169" class="calibre2">
     <span class="calibre" id="c14-sec-0067">
     </span>
     <h2 class="calibre6" id="head-2-169">
      EXERCISES
     </h2>
     <p class="calibre13" id="c14-para-0215">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c14-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c14-ex-0001">
        <b class="calibre14">
         Exercise 14-1:
        </b>
        Without compiling and executing, find and correct the errors in the following code:
        <pre class="calibre26" id="c14-code-0080"><code class="calibre21"><span class="color">// Throws a logic_error exception if the number of elements</span></code>
<code class="calibre21"><span class="color">// in the given dataset is not even.</span></code>
<code class="calibre21">void verifyDataSize(const vector&lt;int&gt;&amp; data)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (data.size() % 2 != 0)</code>
<code class="calibre21">        throw logic_error { "Number of data points must be even." };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Throws a logic_error exception if the number of elements</span></code>
<code class="calibre21"><span class="color">// in the given dataset is not even.</span></code>
<code class="calibre21"><span class="color">// Throws a domain_error exception if one of the datapoints is negative.</span></code>
<code class="calibre21">void processData(const vector&lt;int&gt;&amp; data)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Verify the size of the given dataset.</span></code>
<code class="calibre21">    try {</code>
<code class="calibre21">        verifyDataSize(data);</code>
<code class="calibre21">    } catch (const logic_error&amp; caughtException) {</code>
<code class="calibre21">        <span class="color">// Write message on standard output.</span></code>
<code class="calibre21">        println(cerr, "Invalid number of data points in dataset. Aborting.");</code>
<code class="calibre21">        <span class="color">// And rethrow the exception.</span></code>
<code class="calibre21">        throw caughtException;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Verify for negative datapoints.</span></code>
<code class="calibre21">    for (auto&amp; value : data) {</code>
<code class="calibre21">        if (value &lt; 0)</code>
<code class="calibre21">            throw domain_error { "Negative datapoints not allowed." };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Process data …</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        vector data { 1, 2, 3, -5, 6, 9 };</code>
<code class="calibre21">        processData(data);</code>
<code class="calibre21">    } catch (const logic_error&amp; caughtException) {</code>
<code class="calibre21">        println(cerr, "logic_error: {}", caughtException.what());</code>
<code class="calibre21">    } catch (const domain_error&amp; caughtException) {</code>
<code class="calibre21">        println(cerr, "domain_error: {}", caughtException.what());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       </li>
       <li class="calibre9" id="c14-ex-0002">
        <b class="calibre14">
         Exercise 14-2:
        </b>
        Take the code from the bidirectional I/O example from
        <a class="calibre5" href="c13.xhtml">
         Chapter 13
        </a>
        . You can find this in the
        <code class="calibre21">
         Ch13\22_Bidirectional
        </code>
        folder in the downloadable source code archive. The example implements a
        <code class="calibre21">
         changeNumberForID()
        </code>
        function. Retrofit the code to use exceptions on all places you deem appropriate. Once your code is using exceptions, do you see a possible change you can make to the
        <code class="calibre21">
         changeNumberForID()
        </code>
        function header?
       </li>
       <li class="calibre9" id="c14-ex-0003">
        <span aria-label="575" class="calibre20" epub:type="pagebreak" id="Page_575" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Exercise 14-3:
        </b>
        Add proper error handling using exceptions to your person database solution of Exercise 13-3.
       </li>
       <li class="calibre9" id="c14-ex-0004">
        <b class="calibre14">
         Exercise 14-4:
        </b>
        Take a look at the code in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        for the
        <code class="calibre21">
         Spreadsheet
        </code>
        example that includes support for move semantics using
        <code class="calibre21">
         swap()
        </code>
        . You can find the entire code in the downloadable source code archive in the folder
        <code class="calibre21">
         Ch09\07_SpreadsheetMoveSemantics–WithSwap
        </code>
        . Add proper error handling to the code, including handling of memory allocation failures. Add a maximum width and height to the class and include the proper verification checks. Write your own exception class,
        <code class="calibre21">
         InvalidCoordinate
        </code>
        , which stores both an invalid coordinate and the range of allowed coordinates. Use it in the
        <code class="calibre21">
         verifyCoordinate()
        </code>
        member function. Write a couple of tests in
        <code class="calibre21">
         main()
        </code>
        to test various error conditions.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c14_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c14_2">
     NOTE
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c14-note-0001" id="c14-note-0001" role="doc-backlink">
       1
      </a>
      There is one caveat, do not throw exceptions from constructors of global objects. Such exceptions cannot be caught because these objects are constructed before
      <code class="calibre21">
       main()
      </code>
      even starts executing.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
