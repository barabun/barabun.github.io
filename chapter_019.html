<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   10: Versioning
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_018.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_020.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="383" epub:type="pagebreak" id="pagebreak_383" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0010" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000027">
      10: Versioning
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         This chapter deals with the important topic of change management and control. It begins by discussing the relevance of version numbers and introducing an example version application programming interface (API) to let clients query the current version and feature set for an API. The life cycle of a typical API is described, including prerelease, release, maintenance, completion, and deprecation. The various terms for backward and forward compatibility are then defined, including functional compatibility, source compatibility, and binary compatibility. Then it's shown how you can make changes to an API while maintaining backward compatibility, including API changes such as adding, changing, deprecating, and removing functionality. Finally, the important topic of API reviews is covered as a mechanism to assert a change control process.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Application binary interface (ABI); Backward compatibility; Binary compatibility; Branching; Life cycle; Review process; Source compatibility; Version number
      </div>
     </section>
     <section>
      <p class="textfl" id="p0010">
       Up to this point, I have largely considered the design of an application programming interface (API) as a discrete task that is finished once the API is fully specified and released to users. Of course, this is simply the beginning of a continuous and complex process. After an API has been released, that's when the real work begins and when your API development process is put to the test.
      </p>
      <p class="text" id="p0015">
       Very few if any APIs stop development after the 1.0 product is released. There will always be bugs to fix, new features to integrate, workflows to refine, architecture to improve, other platforms to support, and so on.
      </p>
      <p class="text" id="p0020">
       The primary objective for all releases after the initial release of an API must be to cause zero impact on existing clients, or as close to zero as practically possible. Breaking the interface, or the behavior of the interface, between releases will force your clients to update their code to take advantage of your new API. The more you can minimize the need for this manual intervention on their part, the more likely your users are to upgrade to your new API, or even to keep using your API at all. If your API has a reputation for introducing major incompatible changes with each new release, you are giving your clients incentive to look for an alternative solution. On the other hand, an API with a reputation for stability and robustness can be the largest factor in the success of your product.
      </p>
      <p class="text" id="p0025">
       To this end, this chapter will cover the details of API versioning, explaining the different types of backward compatibility and describing how you can achieve backward compatibility for your API.
      </p>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        Version numbers
       </h2>
       <p class="textfl" id="p0030">
        Each release of your API should be accompanied with a unique identifier so that the latest incarnation of the API can be differentiated from previous offerings. The standard way to do this is to use a version number.
       </p>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         Version number significance
        </h3>
        <p class="textfl" id="p0035">
         There are many different schemes in use to provide versioning information for a software product. Most of these schemes attempt to impart some degree of the scale of change in a release by using a series of numbers, normally separated by a period (.) symbol. Most commonly, either two or three separate integers are used, for example “
         <a id="p384">
         </a>
         <span aria-label="384" epub:type="pagebreak" id="pagebreak_384" role="doc-pagebreak">
         </span>
         1.2” or “1.2.3”. The subsequent list, along with
         <a href="#f0010" id="Bf0010">
          Fig. 10.1
         </a>
         , explains the significance of each of these integers:
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0010">
          <img alt="image" height="1000" src="../../IMAGES/B9780443222191000027/main.assets/f10-01-9780443222191.jpg" width="2751"/>
          <figcaption class="figleg">
           <a id="cap0010">
           </a>
           <a id="fspara0010">
           </a>
           <span class="fignum">
            <a href="#Bf0010">
             Figure 10.1
            </a>
           </span>
           Illustrating the progression of version numbers using a standard MAJOR.MINOR.PATCH numbering scheme.
          </figcaption>
         </figure>
        </div>
        <div>
         <ul class="ce_list" id="olist0010">
          <li class="numlist" id="p0040">
           <a id="o0010">
           </a>
           1.
           <b>
            Major version.
           </b>
           This is the first integer in a version number, such as
           <b>
            1.
           </b>
           0.0. It's normally set to 1 for the initial release and is increased whenever significant changes are made. In terms of API change, a major version change can signal the backward-compatible addition of substantial new features, or it can signify that backward compatibility has been broken. In general, a bump of the major version of an API should signal to your users to expect significant API changes.
          </li>
          <li class="numlist" id="p0045">
           <a id="o0015">
           </a>
           2.
           <b>
            Minor version.
           </b>
           This is the second integer in a compound version number (e.g., 1.
           <b>
            0.
           </b>
           0). This is normally set to 0 after each major release and increased whenever smaller features or significant bug fixes have been added. Changes in minor version number should not normally involve incompatible API changes. Users should expect to be able to upgrade to a new minor release without making any changes to their own software. However, some new features may be added to the API, which, if used, would mean that users could not revert to an earlier minor version without changing their code.
          </li>
          <li class="numlist" id="p0050">
           <a id="o0020">
           </a>
           3.
           <b>
            Patch version.
           </b>
           The (optional) third integer is the patch number, sometimes also called the revision number (e.g., 1.0.
           <b>
            0
           </b>
           ). This is normally set to 0 after each minor release and increased whenever important bug or security fixes are released. Changes in patch number should imply no change to the actual API interface (i.e., only changes to the behavior of the API). In other words, patch version changes should be backward and forward compatible. That is, users should be able to revert to an earlier patch version and then switch back to a more recent patch version without changing their code (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib84" id="bib_84">
            Rooney, 2005
           </a>
           ).
          </li>
         </ul>
        </div>
        <p class="text" id="p0055">
         Some software products employ additional numbers or symbols to further describe a release. For example, an automated build number might be used so that every single build of the software can be differentiated from previous builds. This build number
         <a id="p385">
         </a>
         <span aria-label="385" epub:type="pagebreak" id="pagebreak_385" role="doc-pagebreak">
         </span>
         could be derived from the revision number of the last change checked into the revision control system, it may be derived from the current date, or it could just be a monotonically increasing number.
        </p>
        <p class="text" id="p0060">
         Software is often provided to users before the final release to get feedback and valuable field testing. In these cases, it's common to add a symbol to the version string to indicate the phase of the development process to which the software relates. For example, “1.0.0a” might refer to an alpha release, “1.0.0b” might refer to a beta release, and “1.0.0rc” might refer to a release candidate. However, once you start deviating from a purely numeric identification system, doing comparisons of version numbers starts to become more complicated (see Python PEP 0386
         <span title='hsp="0.25"'>
         </span>
         at
         <a href="http://www.python.org/dev/peps/pep-0386/">
          http://www.python.org/dev/peps/pep-0386/
         </a>
         for an example of this complexity).
        </p>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <div class="b1textfl" id="bpar0010">
            <i>
             TIP: It is good practice to include your API's major version number in your library names, particularly if you've made non–backward compatible changes, such as
            </i>
            <span class="inlinecode">
             <i>
              libFoo.so
             </i>
            </span>
            <i>
             ,
            </i>
            <span class="inlinecode">
             <i>
              libFoo2.so
             </i>
            </span>
            <i>
             , or
            </i>
            <span class="inlinecode">
             <i>
              libFoo3.so
             </i>
            </span>
            <i>
             .
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Esoteric numbering schemes
        </h3>
        <p class="textfl" id="p0065">
         I've also decided to list some nonstandard or imaginative versioning schemes that have been used by software projects in the past. This section is more for fun than actual practical advice, although each scheme obviously offers advantages for certain situations. For API development, however, I recommend sticking with the widely understood major, minor, patch scheme.
        </p>
        <p class="text" id="p0070">
         The TeX document processing system, originally designed by Donald Knuth, produces new version numbers by including additional digits of precision to the value pi, π. The first TeX version number was 3, then came 3.1, then 3.14, and so on. The current version as of 2021 was 3.141592653. Similarly, the version numbers for Knuth's related METAFONT program asymptotically approach the value e, 2.71828182.
        </p>
        <p class="text" id="p0075">
         Although this may seem at first to be simply the wry sense of humor of a mathematician, this numbering scheme does convey an important quality about the software. Even though Knuth himself recognizes that some areas of TeX could be improved, he has stated that no new fundamental changes should be made to the system and any new versions should contain only bug fixes. As such, the use of a versioning scheme that introduces increasingly smaller floating-point digits is insightful. In fact, Knuth's recognition of the importance of feature stability and backward compatibility, to the extent that he encoded this importance in the versioning scheme for his software, is food for thought for any API designer.
        </p>
        <p class="text" id="p0080">
         Another interesting versioning scheme is the use of dates as version numbers. This is commonly used for large end-user software releases such as Microsoft's Visual Studio 2022 and games such as EA's FIFA 23. However, a more subtle system is used by the Ubuntu flavor of the Linux operating system. This uses the year and month of a release
         <a id="p386">
         </a>
         <span aria-label="386" epub:type="pagebreak" id="pagebreak_386" role="doc-pagebreak">
         </span>
         as the major and minor version number, respectively. The first Ubuntu release, 4.10, appeared in Oct. 2004 whereas 9.04 was released during Apr. 2009. Ubuntu releases are also assigned a code name, consisting of an adjective and an animal name with the first same letter, such as Breezy Badger and Lucid Lynx. With the exception of the first two releases, the first letter of these code names increases alphabetically for each release. These schemes have the benefit of imparting how recent an Ubuntu release is, but they do not convey any notion of the degree of change in a release. This may be fine for a continually evolving operating system, although you should prefer a more traditional number scheme for your API to give your users an indication of the degree of API change to expect in a release.
        </p>
        <p class="text" id="p0085">
         The Linux kernel currently uses an even/odd numbering scheme to differentiate between stable releases (even) and development releases (odd). For example, Linux 2.4 and 2.6 are stable releases, whereas 2.3 and 2.5 are development releases. This numbering scheme is also used by the Second Life Server releases.
        </p>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Creating a version API
        </h3>
        <p class="textfl" id="p0090">
         The version information for your API should be accessible from code, to allow your clients to write programs that are conditional on your API's version number: for example, to call a new method that exists only in recent versions of your API, or to work around a bug in the implementation of a known release of your API.
        </p>
        <p class="text" id="p0095">
         To offer maximum flexibility, users should be able to query your API's version at compile time as well as runtime. The compile-time requirement is necessary so that the user can use
         <span class="inlinecode">
          #if
         </span>
         preprocessor directives to conditionally compile against newer classes and methods that would cause undefined reference errors if linking against older versions of your API. The runtime requirement allows clients to choose between different API calls dynamically or to provide logging output with your API version number included. These requirements suggest the creation of a version API. I present a simple generic API for this purpose:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="1181" src="../../IMAGES/B9780443222191000027/main.assets/u10-01-9780443222191.jpg" width="2045"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p387">
         </a>
        </p>
        <div>
         <span aria-label="387" epub:type="pagebreak" id="pagebreak_387" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0100">
         There are a few features of note in this
         <span class="inlinecode">
          Version
         </span>
         class. First, I provide accessors to return the individual major, minor, and patch numbers that comprise the current version. These simply return the values of the respective
         <span class="inlinecode">
          #define
         </span>
         statements,
         <span class="inlinecode">
          API_MAJOR
         </span>
         ,
         <span class="inlinecode">
          API_MINOR
         </span>
         , and
         <span class="inlinecode">
          API_PATCH
         </span>
         . Although I stated in the C++ Usage chapter that you should avoid
         <span class="inlinecode">
          #define
         </span>
         for constants, this is an exception to that rule because you need users to be able to access this information from the preprocessor.
        </p>
        <p class="text" id="p0105">
         The
         <span class="inlinecode">
          GetVersion()
         </span>
         method returns the version information as a user-friendly string, such as 1.2.0. This is useful for the client to display in an About dialog or to write to a debug log in the application.
        </p>
        <p class="text" id="p0110">
         Next, I provide a method to let users perform version comparisons. This lets them do checks in their code, such as checking that they are compiling against an API that is greater than or equal to the specified (major, minor, patch) triple. Obviously you could add other version math routines here, but
         <span class="inlinecode">
          IsAtLeast()
         </span>
         provides the most common use case.
        </p>
        <div>
         <aside aria-labelledby="b0015" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0015">
           <div class="b1textfl" id="bpar0015">
            <i>
             TIP: Provide version information for your API.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0115">
         Finally, I provide a
         <span class="inlinecode">
          HasFeature()
         </span>
         method. Normally when users want to compare version numbers, they don't really care about the version number itself, but instead they're using this designator as a way to determine whether a feature they want to use is present in the API. Instead of making your users be aware of which features were introduced in which versions of your API, the
         <span class="inlinecode">
          HasFeature()
         </span>
         method lets them test for the availability of the feature directly. For example, in version 2.0.0 of your API, perhaps you made the API thread-safe. You could therefore add a feature tag called THREADSAFE, so that users could do a check such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0035">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000027/main.assets/u10-02-9780443222191.jpg" width="1388"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0120">
         Although you probably don't need to define any feature tags for your 1.0 release, you should include this method in your version API so that it’s possible for a client to call it in any release of your API. The method can simply return false for 1.0, but for future releases, you can add tags for new features or major bug fixes. These strings can be stored in an
         <span class="inlinecode">
          std::set
         </span>
         and lazily initialized on the first call so that it's efficient to determine whether a feature tag is defined. The source code that accompanies this book provides an implementation of this concept.
        </p>
        <p class="text" id="p0125">
         Feature tags are particularly useful if you have an open source project in which clients may fork your source code, or an open specification project in which vendors
         <a id="p388">
         </a>
         <span aria-label="388" epub:type="pagebreak" id="pagebreak_388" role="doc-pagebreak">
         </span>
         can produce different implementations of your specification. In these cases, there could be multiple versions of your API that offer different feature sets in releases with the same version number. This concept is employed by the OpenGL API, in which the same version of the OpenGL API may be implemented by different vendors but with different extensions available. For example, the OpenGL API provides the
         <span class="inlinecode">
          glGetStringi(GL_EXTENSION, n)
         </span>
         call to return the name of the n'th
         <span class="inlinecode">
          extension.
         </span>
         Also, C++11 introduced a number of feature testing macros to detect the presence of new language features, such as
         <span class="inlinecode">
          __cpp_consteval
         </span>
         .
        </p>
       </section>
      </section>
      <section>
       <a id="s0030">
       </a>
       <h2 class="h1hd" id="cesectitle0040">
        Software branching strategies
       </h2>
       <p class="textfl" id="p0130">
        Before I talk in more depth about API versioning, let's cover some basics about the related topic of software branching strategies. Although small projects with one or two engineers can normally get by with a single code line, larger software projects normally involve some form of branching strategy to enable simultaneous development, stabilization, and maintenance of different releases of the software. In the next couple of sections I'll cover some of things to consider when choosing a branching strategy and policy for your project.
       </p>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         Branching strategies
        </h3>
        <p class="textfl" id="p0135">
         Every software project needs a trunk or main code line, which is the enduring repository of the project's source code. Branches are made from this trunk code line for individual releases or for development work that must be isolated from the next release. This model supports parallel development in which new features can be added to the project while imminent releases can lock down changes and stabilize the existing feature set.
        </p>
        <p class="text" id="p0140">
         There are many different branching schemes that can be devised. Each engineering team will normally adapt a strategy for its own individual needs, process, and workflow. However,
         <a href="#f0015" id="Bf0015">
          Fig. 10.2
         </a>
         provides one example branching strategy that's frequently seen. In this case, major releases are branched off the trunk and minor releases occur along that code line. If an emergency patch is required while work is happening for the next minor release, then a new branch may be created for that specific hotfix. Longer-term development work that needs to skip the next release because it won't be ready in time is often done in its own branch and then landed at the appropriate time. Note the resemblance between Figs.
         <a href="#f0010">
          10.1
         </a>
         and
         <a href="#f0015">
          10.2
         </a>
         . This similarity is, of course, not accidental.
        </p>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         Branching policies
        </h3>
        <p class="textfl" id="p0145">
         This basic structure is used by many projects to support parallel development and release management. However, there are many policy decisions that can be used to customize the actual workflow, such as in which branches developers work, how many development branches are in flight at once, at what point in the process are release branches created, how often changes are merged between branches, and whether automatic merges between branches are attempted.
         <a id="p389">
         </a>
        </p>
        <div>
         <span aria-label="389" epub:type="pagebreak" id="pagebreak_389" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0015">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="1240" src="../../IMAGES/B9780443222191000027/main.assets/f10-02-9780443222191.jpg" width="2698"/>
           <figcaption class="figleg">
            <a id="cap0015">
            </a>
            <a id="fspara0015">
            </a>
            <span class="fignum">
             <a href="#Bf0015">
              Figure 10.2
             </a>
            </span>
            An example branching diagram for multiple releases of a software product.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0150">
         Although different branching policies make sense for different situations, I'll comment that in my experience, ongoing development work should happen in the trunk code line, with development branches used where necessary for longer-term work. Quality assurance (QA) should also be focused on trunk, particularly during periods of development between releases. The trunk is where your project's crown jewels live: this is the code that will live on past individual releases. If no developers or QA engineers are working in trunk, and merges are allowed to take place into trunk unattended, the trunk will soon become unstable and buggy. Another arrangement is to have only release branches, although even in that case the advice is the same, that most of your active work should be happening on the most recent release branch.
        </p>
        <p class="text" id="p0155">
         Your choice of revision control system also has an impact on your branching policy, because different source control management (SCM) products make certain branching strategies easier than others. For example, supporting and merging between branches in Subversion can be a painful endeavor, whereas in distributed SCM systems such as Git or Mercurial, branching is designed into the core of the system. For example, using an SCM such as Git it's possible to consider merging between branches daily because this is an easy and low-impact operation. The more often you merge between branches, the less code divergence occurs and the easier it will be eventually to land the branch into trunk, if that's the end goal. Release branches will normally just be end of lifed when the release is done, as represented by the X symbol after the 1.1 release in
         <a href="#f0015">
          Fig. 10.2
         </a>
         . Another decision factor that relates to your SCM system is whether all of your engineers are on-site, in which case a server-based solution such as Perforce is acceptable, or whether you have open source engineers working out of their homes, in which case a distributed solution such as Git will be more appropriate.
         <a id="p390">
         </a>
         <span aria-label="390" epub:type="pagebreak" id="pagebreak_390" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <div class="b1textfl" id="bpar0020">
            <i>
             TIP: Branch only when necessary, and branch late. Prefer branching to freezing a code line. Merge between branches early and often. (From the Perforce High-Level Best Practices white paper).
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         APIs and parallel branches
        </h3>
        <p class="textfl" id="p0160">
         Once an API has been released, changes to that API should appear (at least externally) to follow a serialized process. That is, you do not release incompatible nonlinear versions of your API: the functionality in version
         <i>
          N
         </i>
         should be a strict superset of the functionality in version
         <i>
          N
         </i>
         -1. Although this may seem obvious, large software projects tend to involve developers working in several parallel branches of the code, and there can be several concurrently supported releases of an API. It's therefore important that the teams working in different parallel branches do not introduce incompatible features. There are several policy approaches to deal with this potential problem, such as:
        </p>
        <div>
         <ol id="ulist0010">
          <li class="bulllist" id="p0165">
           <a id="u0010">
           </a>
           ▪
           <b>
            Target development branches.
           </b>
           Your project will generally have development branches and release branches. By enforcing that no API changes occur directly in release branches, you minimize the chance that an API change is made in one release but is lost in the next release because it was never merged down to trunk. If an API change is needed in a release branch, it should be committed to trunk and then merged up from there. This is generally true of any change in a release branch, but interface changes have a higher cost if they're lost between releases.
          </li>
          <li class="bulllist" id="p0170">
           <a id="u0015">
           </a>
           ▪
           <b>
            Merge to trunk often.
           </b>
           Any changes to a public API should be developed in the common trunk code line or merged into trunk as early as possible. This also assumes that teams are regularly syncing their development branches to the trunk code, which is good practice anyway. This avoids surprises further down the line when two teams try to merge development branches with conflicting APIs.
          </li>
          <li class="bulllist" id="p0175">
           <a id="u0020">
           </a>
           ▪
           <b>
            Review process.
           </b>
           A single API review committee should oversee and vet all changes to public APIs before they're released. It's the job of this committee to ensure that no conflicting or non–backward compatible changes have been made to APIs. They are the gatekeepers and the last line of defense. This group should be sufficiently empowered to slip release deadlines if necessary to address API problems. I'll discuss how to run an API review process later in this chapter.
          </li>
         </ol>
        </div>
        <p class="text" id="p0180">
         These solutions attempt to keep a one true definition of the API in the trunk code line rather than fracture changes across multiple branches. This may not always be possible, but if you strive for this goal, you will make your life easier later.
        </p>
        <p class="text" id="p0185">
         The problems become more difficult if you have an open source product in which users may create many forks of your source code and make changes to your APIs that are beyond your control. You obviously cannot do too much about this situation. However, if
         <a id="p391">
         </a>
         <span aria-label="391" epub:type="pagebreak" id="pagebreak_391" role="doc-pagebreak">
         </span>
         these changes are to be merged back into your source repository, then you can and should apply the same thoughtful review process to community patches as you would to internally developed changes. It can be difficult or awkward to deny changes from open source developers, but you can minimize any hurt feelings by clearly documenting the review process and expectations, offering advice on technical direction early on, and providing constructive feedback on how a patch can be changed to make it more acceptable.
        </p>
       </section>
       <section>
        <a id="s0050">
        </a>
        <h3 class="h2hd" id="cesectitle0060">
         File formats and parallel products
        </h3>
        <p class="textfl" id="p0190">
         A colleague once described to me a project that he worked on in which a decision was made to support two different variants of the product: a Basic version and an Advanced version. Until that point, there was a single variant of the product and a single file format. The team had a policy of increasing the file format major version number when an incompatible change was introduced into the format, with the last single-variant version being 3.0. The file format was XML based and included a version tag, so it was known which version of the product generated the file. The file format reader would ignore tags that it didn't understand in versions that differed only by minor version number, so that it could still read files that were generated from newer but compatible versions of the product. Both the Basic and Advanced variants could read all files from 3.0 and earlier.
        </p>
        <p class="text" id="p0195">
         This all seems reasonable so far.
        </p>
        <p class="text" id="p0200">
         It wasn't long before the Advanced variant introduced new features that required non–backward compatible additions to the file format. So the team decided to increment the major version number to 4.x. However, then there was a need to evolve the entire file format in an incompatible way (i.e., to require a major version bump for Basic and Advanced files). To deal with this, the Basic variant format was updated to 5.x and the Advanced variant was bumped to 6.x. This meant that:
        </p>
        <div>
         <ol id="ulist0015">
          <li class="bulllist" id="p0205">
           <a id="u0025">
           </a>
           ▪ 3.x builds couldn't read any of 4.x through 6.x formats, which is fine.
          </li>
          <li class="bulllist" id="p0210">
           <a id="u0030">
           </a>
           ▪ 4.x builds (old Advanced) couldn't read 5.x files (new Basic) or 6.x files (new Advanced).
          </li>
          <li class="bulllist" id="p0215">
           <a id="u0035">
           </a>
           ▪ 5.x builds (new Basic) couldn't read 4.x files (old Advanced).
          </li>
          <li class="bulllist" id="p0220">
           <a id="u0040">
           </a>
           ▪ 6.x builds (new Advanced) could read any existing format, which is also fine.
          </li>
         </ol>
        </div>
        <p class="text" id="p0225">
         Then, of course, eventually another major version bump was required, introducing a 7.x (newer Basic) and 8.x (newer Advanced). Things then started to get really messy.
        </p>
        <p class="text" id="p0230">
         With the benefit of hindsight, we talked about how this situation could've been avoided. The key observation is that in this case, the information about which variant had created the file was being conflated with the file format version. One solution would have been to tease apart those two concepts and to write both into the file (i.e., a version number, such as 3.2 and a variant name such as Basic). In this way, the Basic variant could easily know whether it could read a format: it could read any file with an empty or Basic variant name. This essentially creates two version number spaces, in which the
         <a id="p392">
         </a>
         <span aria-label="392" epub:type="pagebreak" id="pagebreak_392" role="doc-pagebreak">
         </span>
         version numbers for the two variants can advance independently of each other. A product first checks the variant name for compatibility, then version number compatibility works in the usual linear fashion.
        </p>
        <p class="text" id="p0235">
         Learning from this experience, I offer this advice: when supporting different variants of a product, store the variant's name in any files that should be shared between the variants in addition to the version number of the variant that wrote the file.
        </p>
        <div>
         <aside aria-labelledby="b0025" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0025">
           <div class="b1textfl" id="bpar0025">
            <i>
             TIP: When creating Basic versus Advanced versions of the same APIs, accompany the version number with a Basic or Advanced string in any generated files. Don't try to use the version number solely to glean whether the file was generated by the Basic or Advanced API.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
      </section>
      <section>
       <a id="s0055">
       </a>
       <h2 class="h1hd" id="cesectitle0065">
        Life cycle of an API
       </h2>
       <p class="textfl" id="p0240">
        In this section I'll examine the life of an API and the various phases it goes through, from conception to end of life.
       </p>
       <p class="text" id="p0245">
        Maintaining an API is not necessarily the same as maintaining a normal software product. That's because of the extra constraints that are placed on API development to not break existing clients. In a normal end user software product, if you change the name of a method or class in your code, this doesn't affect the user-visible features of the application. However, if you change the name of a class or method in an API, you may break the code of all of your existing clients. An API is a contract, and you must make sure that you uphold your end of the contract.
       </p>
       <p class="text" id="p0250">
        <a href="#f0020" id="Bf0020">
         Fig. 10.3
        </a>
        provides an overview of the life span of a typical API. The most important event in this life span is the initial release, marked by the thick vertical bar in the figure. Before this pivotal point, it's fine to make major changes to the design and interface. However, after the initial release, once your users can write code using your API, you have committed to providing backward compatibility, and the extent of the changes you can make is greatly limited. Looking at the life span as a whole, there are four general stages of API development (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib99" id="bib_99">
         Tulach, 2008
        </a>
        ):
        <a id="p393">
        </a>
        <span aria-label="393" epub:type="pagebreak" id="pagebreak_393" role="doc-pagebreak">
        </span>
       </p>
       <div class="pageavoid">
        <figure class="fig" id="f0020">
         <img alt="image" height="598" src="../../IMAGES/B9780443222191000027/main.assets/f10-03-9780443222191.jpg" width="2752"/>
         <figcaption class="figleg">
          <a id="cap0020">
          </a>
          <a id="fspara0020">
          </a>
          <span class="fignum">
           <a href="#Bf0020">
            Figure 10.3
           </a>
          </span>
          The life cycle of an application programming interface (API). Before the initial release, extensive redesign of the API can be performed. After the initial release, only incremental changes can be tolerated.
         </figcaption>
        </figure>
       </div>
       <div>
        <ul class="ce_list" id="olist0015">
         <li class="numlist" id="p0255">
          <a id="o0025">
          </a>
          1.
          <b>
           Prerelease
          </b>
          : Before the initial release, an API can progress through a standard software cycle, including requirements gathering, planning, design, implementation, and testing. Most notably, as I've stated, the interface can go through major changes and redesigns during this period. You may release these early versions of your API to your users to get their feedback and suggestions. You should use a version number of 0.x for these prerelease versions to make it clear to users that the API is still under active development and may change radically before 1.0 is delivered.
         </li>
         <li class="numlist" id="p0260">
          <a id="o0030">
          </a>
          2.
          <b>
           Maintenance
          </b>
          : An API can still be modified after it has been released, but to maintain backward compatibility any changes must be restricted to adding new methods and classes, as well as fixing bugs in the implementation of existing methods. In other words, during the maintenance phase you should seek to evolve an API, not change it incompatibly. To ensure that changes do not break backward compatibility, it is good practice to conduct API reviews before a new version is released.
         </li>
         <li class="numlist" id="p0265">
          <a id="o0035">
          </a>
          3.
          <b>
           Completion
          </b>
          : At some point, the project leads will decide that the API has reached maturity and that no further changes should be made to the interface. This may be because the API solves the problems it was designed to solve, or it may be because team members have moved on to other projects and can no longer support the API. Stability is the most important quality at this point in the life span. As such, only bug fixes will generally be considered. API reviews could still be run at this stage, but if changes are indeed restricted to implementation code and not public headers, then they may not be necessary. Ultimately, the API will reach the point where it's considered to be complete and no further changes will be made.
         </li>
         <li class="numlist" id="p0270">
          <a id="o0040">
          </a>
          4.
          <b>
           Deprecation
          </b>
          : Some APIs eventually reach an end of life state where they're deprecated and then removed from circulation. Deprecation means that an API should not be used for any new development and that existing clients should migrate away from the API. This can happen if the API no longer serves a useful purpose or if a newer, incompatible API has been developed to take its place.
         </li>
        </ul>
       </div>
       <div>
        <aside aria-labelledby="b0030" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0030">
          <div class="b1textfl" id="bpar0030">
           <i>
            TIP: After release, you can evolve an API but not change it.
           </i>
          </div>
         </div>
        </aside>
       </div>
      </section>
      <section>
       <a id="s0060">
       </a>
       <h2 class="h1hd" id="cesectitle0070">
        Levels of compatibility
       </h2>
       <p class="textfl" id="p0275">
        Up to this point I've talked only vaguely about what backward compatibility means. It's now time to get concrete and define our terms more precisely. Accordingly, the next few sections will detail what is meant by the specific terms backward compatibility, forward
        <a id="p394">
        </a>
        <span aria-label="394" epub:type="pagebreak" id="pagebreak_394" role="doc-pagebreak">
        </span>
        compatibility, functional compatibility, source (or API) compatibility, and application binary interface (ABI) compatibility.
       </p>
       <p class="text" id="p0280">
        Often you'll provide different levels of compatibility promises for major, minor, and patch releases of your API. For example, you may promise that patch releases will be both backward and forward compatible (Subversion promises this), or you may promise only to break binary compatibility for major releases (KDE promises this for core libraries).
       </p>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         Backward compatibility
        </h3>
        <p class="textfl" id="p0285">
         Backward compatibility can be defined simply as an API that provides the same functionality as a previous version of the API. In other words, an API is backward compatible if it can fully take the place of a previous version of the API without requiring the user to make changes.
        </p>
        <p class="text" id="p0290">
         This implies that the newer API is a superset of the older API. It can add new functionality, but it cannot incompatibly change functionality that is already defined by the older API. The cardinal rule of API maintenance is never to remove anything from your interface.
        </p>
        <p class="text" id="p0295">
         There are different types of API backward compatibility, including:
        </p>
        <div>
         <ul class="ce_list" id="olist0020">
          <li class="numlist" id="p0300">
           <a id="o0045">
           </a>
           1. Functional compatibility,
          </li>
          <li class="numlist" id="p0305">
           <a id="o0050">
           </a>
           2. Source compatibility, and
          </li>
          <li class="numlist" id="p0310">
           <a id="o0055">
           </a>
           3. Binary compatibility.
          </li>
         </ul>
        </div>
        <p class="text" id="p0315">
         I will define each of these in more detail in the following sections. In addition, there are also data-oriented backward compatibility issues, such as:
        </p>
        <div>
         <ul class="ce_list" id="olist0025">
          <li class="numlist" id="p0320">
           <a id="o0060">
           </a>
           1. Client/server compatibility, and
          </li>
          <li class="numlist" id="p0325">
           <a id="o0065">
           </a>
           2. File format compatibility.
          </li>
         </ul>
        </div>
        <p class="text" id="p0330">
         For example, if your API involves communication over a network, then you also need to consider the compatibility of the client/server protocol you use. This means that a client using an older release of the API will still be able to communicate with a newer version of the server. Also a client using a newer release of the API will still be able to communicate with an older version of the server (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib84">
          Rooney, 2005
         </a>
         ).
        </p>
        <p class="text" id="p0335">
         Additionally, if your API stores data in a file or database, then you will need to consider the compatibility of that file format or database schema. For example, more recent versions of the API need to be able to read files generated by older versions of the API.
        </p>
        <p class="text" id="p0340">
         These data-oriented features should also have version numbers, and these don't have to be the same as your API version number (e.g., you may make a change to your API but not make a change to the underlying file format in that release, so the API version number changes while the file format version number stays the same).
         <a id="p395">
         </a>
         <span aria-label="395" epub:type="pagebreak" id="pagebreak_395" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0035" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0035">
           <div class="b1textfl" id="bpar0035">
            <i>
             TIP: Backward compatibility means that client code that uses version N of your API can be upgraded without change to version N+1.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         Functional compatibility
        </h3>
        <p class="textfl" id="p0345">
         Functional compatibility is concerned with the runtime behavior of an implementation. An API is functionally compatible if it behaves exactly the same as a previous version of the API. However, as Jaroslav Tulach notes, an API will hardly ever be 100% backward compatible in this respect. Even a release that fixes only bugs in implementation code will have changed the behavior of the API, behavior that some clients may be depending on.
        </p>
        <p class="text" id="p0350">
         For example, if your API provides the function:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000027/main.assets/u10-03-9780443222191.jpg" width="901"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0355">
         this function may have a bug in version 1.0 of your API, causing it to crash if you pass it a
         <span class="inlinecode">
          nullptr
         </span>
         . In version 1.1, you fix this bug so that your code no longer crashes in this case. This has changed the behavior of the API, so it's not strictly functionally compatible. However, it has changed the behavior in a good way: it's fixed a crashing bug. So, although this metric is useful as a basic measure of change in the runtime behavior of an API, that functional change may not necessarily be a bad thing. Most API updates will intentionally break functional compatibility.
        </p>
        <p class="text" id="p0360">
         As an example of a case in which functional compatibility is useful, consider a new version of an API that focused solely on performance. In this case, the behavior of the API is not changed at all. However, the algorithms behind the interface are improved to deliver the same results in less time. In this respect, the new API could be considered 100% functionally compatible.
        </p>
        <div>
         <aside aria-labelledby="b0040" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0040">
           <div class="b1textfl" id="bpar0040">
            <i>
             TIP: Functional compatibility means that version N+1 of your API behaves the same as version N.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0075">
        </a>
        <h3 class="h2hd" id="cesectitle0085">
         Source compatibility
        </h3>
        <p class="textfl" id="p0365">
         Source compatibility is a looser definition of backward compatibility. It basically states that users can recompile their programs using a newer version of the API without making any change to their code. This says nothing about the behavior of the resulting program,
         <a id="p396">
         </a>
         <span aria-label="396" epub:type="pagebreak" id="pagebreak_396" role="doc-pagebreak">
         </span>
         only that it can be successfully compiled and linked. Source compatibility is also sometimes referred to as API compatibility.
        </p>
        <p class="text" id="p0370">
         For example, these two functions are source compatible, even though their function signatures are different:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-04-9780443222191.jpg" width="1769"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0375">
         This is because any user code that was written to call the 1.0 version of the function will also compile against version 1.1 (the new argument is optional). In contrast, the next two functions are not source compatible because users will be forced to go through their code to find all instances of the
         <span class="inlinecode">
          SetImage()
         </span>
         method and add the required second parameter:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-05-9780443222191.jpg" width="1526"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0380">
         Any changes that are completely restricted to implementation code, and therefore do not involve changes to public headers, will obviously be 100% source compatible, because the interfaces are the same in both cases.
        </p>
        <div>
         <aside aria-labelledby="b0045" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0045">
           <div class="b1textfl" id="bpar0045">
            <i>
             TIP: Source compatibility means that a user who wrote code against version N of your API can also compile that code against version N+1 without changing their source.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0080">
        </a>
        <h3 class="h2hd" id="cesectitle0090">
         Binary/application binary interface compatibility
        </h3>
        <p class="textfl" id="p0385">
         Binary compatibility implies that clients only need to relink their programs with a newer version of a static library or simply drop a new shared library into the install directory of their end user application. This contrasts with source compatibility, in which users must recompile their programs whenever any new version of your API is released.
        </p>
        <p class="text" id="p0390">
         This implies that any changes to the API must not affect the representation of any classes, methods, or functions in the library file. The binary representation of all API elements must remain the same, including the type, size, and alignment of structures and the signatures of all functions. This is also often called ABI compatibility.
         <a id="p397">
         </a>
        </p>
        <div>
         <span aria-label="397" epub:type="pagebreak" id="pagebreak_397" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0395">
         Binary compatibility can be difficult to attain using C++. Most changes that you make to an interface in C++ will cause changes to its binary representation. For example, here are the mangled names of two different functions (i.e., the symbol names that are used to identify a function in an object or library file):
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000027/main.assets/u10-06-9780443222191.jpg" width="1769"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0400">
         These two methods are source compatible but they are not binary compatible, as evidenced by the different mangled names that each produce. This means that code compiled against version 1.0 cannot simply use the version 1.1 libraries because the
         <span class="inlinecode">
          _Z8SetImageP5Image
         </span>
         symbol is no longer defined.
        </p>
        <p class="text" id="p0405">
         The binary representation of an API can also change if you use different compile flags. It tends to be compiler specific, too. One reason for this is that the C++ standards committee decided not to dictate the specifics of name mangling. As a result, the mangling scheme used by one compiler may differ from that of another compiler, even on the same platform. (The mangled names presented earlier were produced by GNU C++ 4.3.)
        </p>
        <div>
         <aside aria-labelledby="b0050" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0050">
           <div class="b1textfl" id="bpar0050">
            <i>
             TIP: Binary compatibility means that an application written against version N of your API can be upgraded to version N+1 simply by replacing or relinking against the new dynamic library for your API.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0410">
         Next I provide two lists of specific API changes, detailing those that will require users to recompile their code and those that should be safe to perform without breaking binary compatibility.
        </p>
        <section>
         <a id="s0085">
         </a>
         <h4 class="h3hd" id="cesectitle0095">
          Binary incompatible API changes
         </h4>
         <div id="p0415">
         </div>
         <div>
          <ol id="ulist0020">
           <li class="bulllist" id="p0420">
            <a id="u0045">
            </a>
            ▪ Removing a class, method, or function.
           </li>
           <li class="bulllist" id="p0425">
            <a id="u0050">
            </a>
            ▪ Adding, removing, or reordering member variables for a class.
           </li>
           <li class="bulllist" id="p0430">
            <a id="u0055">
            </a>
            ▪ Adding or removing base classes from a class.
           </li>
           <li class="bulllist" id="p0435">
            <a id="u0060">
            </a>
            ▪ Changing the type of any member variable.
           </li>
           <li class="bulllist" id="p0440">
            <a id="u0065">
            </a>
            ▪ Changing the signature of an existing method in any way.
           </li>
           <li class="bulllist" id="p0445">
            <a id="u0070">
            </a>
            ▪ Adding, removing, or reordering template arguments.
           </li>
           <li class="bulllist" id="p0450">
            <a id="u0075">
            </a>
            ▪ Changing a noninlined method to be inlined.
            <a id="p398">
            </a>
           </li>
           <li>
            <span aria-label="398" epub:type="pagebreak" id="pagebreak_398" role="doc-pagebreak">
            </span>
           </li>
           <li class="bulllist" id="p0455">
            <a id="u0080">
            </a>
            ▪ Changing a nonvirtual method to be virtual, and vice versa.
           </li>
           <li class="bulllist" id="p0460">
            <a id="u0085">
            </a>
            ▪ Changing the order of virtual methods
           </li>
           <li class="bulllist" id="p0465">
            <a id="u0090">
            </a>
            ▪ Adding a virtual method to a class with no existing virtual methods.
           </li>
           <li class="bulllist" id="p0470">
            <a id="u0095">
            </a>
            ▪ Adding new virtual methods (some compilers may preserve binary compatibility if you add only new virtual methods after existing ones).
           </li>
           <li class="bulllist" id="p0475">
            <a id="u0100">
            </a>
            ▪ Overriding an existing virtual method (this may be possible in some cases, but is best avoided).
           </li>
          </ol>
         </div>
        </section>
        <section>
         <a id="s0090">
         </a>
         <h4 class="h3hd" id="cesectitle0100">
          Binary compatible API changes
         </h4>
         <div id="p0480">
         </div>
         <div>
          <ol id="ulist0025">
           <li class="bulllist" id="p0485">
            <a id="u0105">
            </a>
            ▪ Adding new classes, nonvirtual methods, or free functions.
           </li>
           <li class="bulllist" id="p0490">
            <a id="u0110">
            </a>
            ▪ Adding new static variables to a class.
           </li>
           <li class="bulllist" id="p0495">
            <a id="u0115">
            </a>
            ▪ Removing private static variables (if they are never referenced from an inline method).
           </li>
           <li class="bulllist" id="p0500">
            <a id="u0120">
            </a>
            ▪ Removing nonvirtual private methods (if they are never called from an inline method).
           </li>
           <li class="bulllist" id="p0505">
            <a id="u0125">
            </a>
            ▪ Changing the implementation of an inline method.
           </li>
           <li class="bulllist" id="p0510">
            <a id="u0130">
            </a>
            ▪ Changing an inline method to be noninline.
           </li>
           <li class="bulllist" id="p0515">
            <a id="u0135">
            </a>
            ▪ Changing the default arguments of a method (however, this requires recompilation to use the new default argument).
           </li>
           <li class="bulllist" id="p0520">
            <a id="u0140">
            </a>
            ▪ Adding or removing friend declarations from a class.
           </li>
           <li class="bulllist" id="p0525">
            <a id="u0145">
            </a>
            ▪ Adding a new enum to a class.
           </li>
           <li class="bulllist" id="p0530">
            <a id="u0150">
            </a>
            ▪ Appending new enumerations to an existing enum
           </li>
           <li class="bulllist" id="p0535">
            <a id="u0155">
            </a>
            ▪ Using unclaimed remaining bits of a bit field.
           </li>
          </ol>
         </div>
         <p class="text" id="p0540">
          Restricting any API changes to only those listed in this second list should allow you to maintain binary compatibility between your API releases. Some further tips to help you achieve binary compatibility include:
         </p>
         <div>
          <ol id="ulist0030">
           <li class="bulllist" id="p0545">
            <a id="u0160">
            </a>
            ▪ Rather than adding parameters to an existing method, you can define a new overloaded version of the method. This ensures that the original symbol continues to exist but provides the newer calling convention, too. Inside your
            <span class="inlinecode">
             .cpp
            </span>
            file, the older method may be implemented simply by calling the new overloaded method:
           </li>
          </ol>
         </div>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0060">
            <img alt="image" height="371" src="../../IMAGES/B9780443222191000027/main.assets/u10-07-9780443222191.jpg" width="1492"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="textfl">
          <a id="p399">
          </a>
         </p>
         <div>
          <span aria-label="399" epub:type="pagebreak" id="pagebreak_399" role="doc-pagebreak">
          </span>
         </div>
         <p class="text" id="p0550">
          (This technique may affect source compatibility if the method is not already overloaded, because client code can no longer reference the function pointer
          <span class="inlinecode">
           &amp;SetImage
          </span>
          without an explicit cast).
         </p>
         <div id="p9000">
         </div>
         <div>
          <ol id="ulist0035">
           <li class="bulllist" id="p0555">
            <a id="u0165">
            </a>
            ▪ The pimpl idom can be used to help preserve binary compatibility of your interfaces, because it moves all implementation details—those elements that are most likely to change in the future—into the
            <span class="inlinecode">
             .cpp
            </span>
            file where they don't affect the public
            <span class="inlinecode">
             .h
            </span>
            files.
           </li>
           <li class="bulllist" id="p0560">
            <a id="u0170">
            </a>
            ▪ Adopting a flat C style API can make it much easier to attain binary compatibility (and also cross-compiler compatibility), simply because C does not offer you features such as inheritance, optional parameters, overloading, exceptions, and templates. To get the best of both worlds, you may decide to develop your API using an object-oriented C++ style and then provide a flat C style wrapping of the C++ API.
           </li>
           <li class="bulllist" id="p0565">
            <a id="u0175">
            </a>
            ▪ If you do need to make a binary incompatible change, then you might consider naming the new library differently so that you don't break existing applications. This approach was taken by the libz library. Builds before version 1.1.4 were called ZLIB.DLL on Windows. However, a binary incompatible compiler setting was used to build later versions of the library, and so the library was renamed to ZLIB1.DLL, in which the 1 indicates the API major version number.
           </li>
          </ol>
         </div>
         <p class="text" id="p0570">
          Binary compatibility is transitive, so the ABI compatibility of your library dependencies can affect the compatibility of your library. For example, the clang compiler lets you choose between different C++ runtimes: libc++ (the LLVM runtime) or libstdc++ (the GNU runtime). However, these are not binary compatible: a library compiled against one will not link against the other. In particular, libc++ uses an inlined namespace of
          <span class="inlinecode">
           std::__1
          </span>
          for all of its symbols but libstdc++ does not. So, even if you used a plain C API for your library, if you have a C++ library dependency that was linked against libc++, then your clients will not be able to link against libstdc++ because it’s not binary compatible with your dependencies.
         </p>
        </section>
       </section>
       <section>
        <a id="s0095">
        </a>
        <h3 class="h2hd" id="cesectitle0105">
         Forward compatibility
        </h3>
        <p class="textfl" id="p0575">
         An API is forward compatible if client code written using a future version of the API can be compiled without modification using an older version of the API. Forward compatibility therefore means that users can downgrade to a previous release and still have their code work without modification.
        </p>
        <p class="text" id="p0580">
         Adding new functionality to an API breaks forward compatibility because client code written to take advantage of these new features will not compile against the older release where those changes are not present.
         <a id="p400">
         </a>
        </p>
        <div>
         <span aria-label="400" epub:type="pagebreak" id="pagebreak_400" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0585">
         For example, these two versions of a function are forward compatible:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0065">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-08-9780443222191.jpg" width="1631"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0590">
         This is because code written using the 1.1 version of the function, in which the second argument is required, can compile successfully in the 1.0 version. However, these two versions are not forward compatible:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0070">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-09-9780443222191.jpg" width="1804"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0595">
         This is because code written using the 1.1 version can provide an optional second argument, which if specified will not compile against the 1.0 version of the function.
        </p>
        <p class="text" id="p0600">
         Forward compatibility is obviously a difficult quality to provide any guarantees about because you can't predict what will happen to the API in the future. You can, however, give this your best effort before the 1.0 version of your API is released. In fact, this is an excellent activity to engage in before your first public release, to try to make your API as future-proof as possible.
        </p>
        <p class="text" id="p0605">
         This means that you must give thought to the question of how the API could evolve in the future. What new functionality might your users request? How would performance optimizations affect the API? How might the API be misused? Is there a more general concept that you may want to expose in the future? Are you aware of functionality that you plan to implement in the future that will affect the API?
        </p>
        <p class="text" id="p0610">
         Here are some ways in which you can make an API forward compatible:
        </p>
        <div>
         <ol id="ulist0040">
          <li class="bulllist" id="p0615">
           <a id="u0180">
           </a>
           ▪ If you know that you'll need to add a parameter to a method in the future, then you can use the technique shown in the first example mentioned earlier: that is, you can add the parameter even before the functionality is implemented and simply document (and name) this parameter as unused.
          </li>
          <li class="bulllist" id="p0620">
           <a id="u0185">
           </a>
           ▪ You can use an opaque pointer or typedef instead of using a built-in type directly if you anticipate switching to a different built-in type in the future. For example, create a typedef for the
           <span class="inlinecode">
            float
           </span>
           type called
           <span class="inlinecode">
            Real
           </span>
           , so that you can change the typedef to double in a future version of the API without causing the API to change.
          </li>
          <li class="bulllist" id="p0625">
           <a id="u0190">
           </a>
           ▪ The data-driven style of API design, described in the Styles chapter, is inherently forward compatible. A method that simply accepts an
           <span class="inlinecode">
            ArgList
           </span>
           variant container essentially allows any collection of arguments to be passed to it at runtime. The implementation can therefore add support for new named arguments without requiring changes to the function signature.
          </li>
         </ol>
        </div>
        <p class="textfl">
         <a id="p401">
         </a>
         <span aria-label="401" epub:type="pagebreak" id="pagebreak_401" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0055" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0055">
           <div class="b1textfl" id="bpar0055">
            <i>
             TIP: Forward compatibility means that client code that uses version N of your API can be downgraded without change to version N-1.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
      </section>
      <section>
       <a id="s0100">
       </a>
       <h2 class="h1hd" id="cesectitle0110">
        How to maintain backward compatibility
       </h2>
       <p class="textfl" id="p0630">
        Now that I've defined the various types of compatibility, I'll describe some strategies for maintaining backward compatibility when releasing newer versions of your APIs.
       </p>
       <section>
        <a id="s0105">
        </a>
        <h3 class="h2hd" id="cesectitle0115">
         Adding functionality
        </h3>
        <p class="textfl" id="p0635">
         In terms of source compatibility, adding new functionality to an API is generally a safe thing to do. Adding new classes, new methods, or new free functions does not change the interface for preexisting API elements and so will not break existing code.
        </p>
        <p class="text" id="p0640">
         As an exception to this rule, adding new pure virtual member functions to an abstract base class is not backward compatible: that is,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0075">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000027/main.assets/u10-10-9780443222191.jpg" width="2185"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0645">
         This is because all existing clients must now define an implementation for this new method; otherwise their derived classes will not be concrete and their code will not compile. The workaround for this is simply to provide a default implementation for any new methods that you add to an abstract base class (i.e., to make them virtual but not pure virtual). For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0080">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000027/main.assets/u10-11-9780443222191.jpg" width="2045"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0060" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0060">
           <div class="b1textfl" id="bpar0060">
            <i>
             TIP: Do not add new pure virtual member functions to an abstract base class after the initial release of your API.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p402">
         </a>
        </p>
        <div>
         <span aria-label="402" epub:type="pagebreak" id="pagebreak_402" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0650">
         In terms of binary (ABI) compatibility, the set of elements that you can add to the API without breaking compatibility is more restricted. For example, adding the first virtual method to a class will cause the size of the class to increase, normally by the size of one pointer, to include a pointer to the vtable for that class. Similarly, adding new base classes, adding template parameters, or adding new member variables will break binary compatibility. Some compilers will let you add virtual methods to a class that already has virtual methods without breaking binary compatibility, as long as you add the new virtual method after all other virtual methods in the class.
        </p>
        <p class="text" id="p0655">
         Refer to the list in the Binary Compatible section for a more detailed breakdown of API changes that will break binary compatibility.
        </p>
       </section>
       <section>
        <a id="s0110">
        </a>
        <h3 class="h2hd" id="cesectitle0120">
         Changing functionality
        </h3>
        <p class="textfl" id="p0660">
         Changing functionality without breaking existing clients is a trickier proposition. If you only care about source compatibility, then it's possible to add new parameters to a method as long as you order them after all previous parameters and declare them as optional. This means that users are not forced to update all existing calls to add the extra parameter. I gave an example of this earlier, which I will replicate here for convenience:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-12-9780443222191.jpg" width="1769"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0665">
         Also, changing the return type of an existing method, in which the method previously had a void return type, is a source compatible change because no existing code should be checking that return value:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-13-9780443222191.jpg" width="900"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0670">
         If you wish to add a parameter that doesn't appear after all of the existing parameters, or if you are writing a flat C API in which optional parameters are not available, then you can introduce a differently named function and perhaps refactor the implementation of the old method to call the new method. As an example, the Win32 API uses this technique extensively by creating functions that have an Ex suffix to represent extended functionality. For example:
        </p>
        <div>
         <div class="box_top_space">
         </div>
         <div class="pageavoid">
          <p class="tnum">
          </p>
          <table class="tbody" id="t0010">
           <tbody>
            <tr>
             <td class="tbs">
              <span class="icon1">
               <img alt="image" height="834" src="../../IMAGES/B9780443222191000027/main.assets/u10-14-9780443222191.jpg" width="2055"/>
              </span>
             </td>
            </tr>
           </tbody>
          </table>
         </div>
        </div>
        <p class="textfl">
         <a id="p403">
         </a>
        </p>
        <div>
         <span aria-label="403" epub:type="pagebreak" id="pagebreak_403" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="st0010">
         </a>
        </section>
        <p class="text" id="p0675">
         The Win32 API also provides examples of deprecating older functions and introducing an alternative name for the newer functions, instead of simply appending Ex to the end of the name. For example, the
         <span class="inlinecode">
          OpenFile()
         </span>
         method is deprecated, and instead the
         <span class="inlinecode">
          CreateFile()
         </span>
         function should be used for all modern applications.
        </p>
        <p class="text" id="p0680">
         In terms of template use, adding new explicit template instantiations to your API can potentially break backward compatibility because your clients may already have added an explicit instantiation for that type. If this is the case, those clients will receive a duplicate explicit instantiation error when trying to compile their code.
        </p>
        <p class="text" id="p0685">
         In terms of maintaining binary compatibility, any changes you make to an existing function signature will break binary compatibility, such as changing the order, type, number, or constness of parameters, or changing the return type. If you need to change the behavior of an existing method and maintain binary compatibility, then you must resort to creating a new method for that purpose, potentially overloading the name of the existing function. This technique was shown earlier in this chapter:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000027/main.assets/u10-15-9780443222191.jpg" width="1527"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0690">
         Finally, it will be common to change the behavior of an API without changing the signature of any of its methods. This could be done to fix a bug in the implementation or to change the valid values or error conditions that a method supports. These kinds of changes will be source and binary compatible, but they will break functional compatibility for your API. Often, these will be desired changes that your affected clients will find agreeable. However, in cases where the change in behavior may not be desirable to all clients, you can make the new behavior opt-in. For example, if you have added
         <a id="p404">
         </a>
         <span aria-label="404" epub:type="pagebreak" id="pagebreak_404" role="doc-pagebreak">
         </span>
         multithreaded locking to your API, you could allow clients to opt-in to this new behavior by calling a
         <span class="inlinecode">
          SetLocking()
         </span>
         method to turn on this functionality (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib99">
          Tulach, 2008
         </a>
         ). Alternatively, you could integrate the ability to turn on/off features with the
         <span class="inlinecode">
          HasFeature()
         </span>
         method I introduced earlier for the Version class. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000027/main.assets/u10-16-9780443222191.jpg" width="2116"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0695">
         With this capability, your clients could explicitly enable new functionality while the original behavior is maintained for existing clients, thus preserving functional compatibility. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000027/main.assets/u10-17-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0115">
        </a>
        <h3 class="h2hd" id="cesectitle0125">
         Deprecating functionality
        </h3>
        <p class="textfl" id="p0700">
         A deprecated feature is one that clients are actively discouraged from using, normally because it's been superseded by newer, preferred functionality. A deprecated feature remains in the API, so users can still call it, although doing so may generate some kind of warning. The expectation is that deprecated functionality may be completely removed from a future version of the API.
        </p>
        <p class="text" id="p0705">
         Deprecation is a way to start the process of removing a feature while giving your clients time to update their code to remove their dependency on the feature.
        </p>
        <p class="text" id="p0710">
         There are various reasons to deprecate functionality, including addressing security flaws, introducing a more powerful feature, simplifying the API, or supporting a refactoring of the API's functionality. For example, the standard C function
         <span class="inlinecode">
          tmpnam()
         </span>
         has been deprecated in preference to more secure implementations such as
         <span class="inlinecode">
          tmpnam_s()
         </span>
         or
         <span class="inlinecode">
          mkstemp()
         </span>
         .
        </p>
        <p class="text" id="p0715">
         When you deprecate an existing method you should mark this fact in the documentation for the method, along with a note on any newer functionality that should be used instead. In addition to this documentation task, there are ways to produce warning messages if the function is ever used. As of C++14, there's a standard way to do this with the
         <span class="inlinecode">
          [[deprecated]]
         </span>
         attribute. For example:
         <a id="p405">
         </a>
         <span aria-label="405" epub:type="pagebreak" id="pagebreak_405" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000027/main.assets/u10-18-9780443222191.jpg" width="2322"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0720">
         You can use
         <span class="inlinecode">
          [[deprecated]]
         </span>
         in front of a function signature, whether it is a free function, a function template, or a class method. You can also use it in front of a variable definition to deprecate any of your API constants. However, you cannot currently use it to deprecate an entire class, struct, or enum.
        </p>
        <p class="text" id="p0725">
         If you're unable to use C++14, most compilers provide their own way to decorate a class, method, or variable as being deprecated and will output a compile-time warning if a program tries to access a symbol decorated in this fashion. In Visual Studio C++, you prefix a method declaration with
         <span class="inlinecode">
          __declspec(deprecated)
         </span>
         , whereas in the GNU C++ compiler you use
         <span class="inlinecode">
          __attribute__ ((deprecated))
         </span>
         . This code defines a
         <span class="inlinecode">
          DEPRECATED
         </span>
         macro that will work for either compiler:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000027/main.assets/u10-19-9780443222191.jpg" width="2148"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0730">
         Using this definition, you can mark certain methods as being deprecated:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000027/main.assets/u10-20-9780443222191.jpg" width="1282"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0735">
         If users try to call the
         <span class="inlinecode">
          GetName()
         </span>
         method, their compiler will output a warning message indicating that the method is deprecated. For example, this warning is emitted by the GNU C++ 4.3 compiler:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0125">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000027/main.assets/u10-21-9780443222191.jpg" width="2044"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p406">
         </a>
        </p>
        <div>
         <span aria-label="406" epub:type="pagebreak" id="pagebreak_406" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0740">
         As an alternative to providing a compile-time warning, you could write code to issue a deprecation warning at runtime. One reason to do this is so you can provide more information in the warning message, such as an indication of an alternative method to use. For example, you could declare a function that you call as the first statement of each function you wish to deprecate, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0130">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000027/main.assets/u10-22-9780443222191.jpg" width="2045"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0745">
         The implementation of
         <span class="inlinecode">
          Deprecated()
         </span>
         could maintain an
         <span class="inlinecode">
          std::set
         </span>
         with the name of each function for which a warning has already been emitted. This would allow you to output a warning on only the first invocation of the deprecated method, to avoid spewage to the terminal if the method gets called a lot. Noel Llopis describes a similar technique in his Game Gem, except that his solution also keeps track of the number of unique call sites and batches up the warnings to output a single report at the end of the program's execution (DeLoura, 2001).
        </p>
       </section>
       <section>
        <a id="s0120">
        </a>
        <h3 class="h2hd" id="cesectitle0130">
         Removing functionality
        </h3>
        <p class="textfl" id="p0750">
         Some functionality may eventually be removed from an API after it’s gone through at least one release of being deprecated. Removing a feature will break all existing clients that depend upon that feature, which is why it's important to give users a warning about your intention to remove the functionality, by first marking it as deprecated.
        </p>
        <p class="text" id="p0755">
         Removing functionality from an API is a drastic step, but it's sometimes warranted when the methods should no longer be called for security reasons, if that functionality is simply no longer supported, or if it's restricting the ability of the API to evolve.
        </p>
        <p class="text" id="p0760">
         One way to remove functionality and yet still allow legacy users to access the old functionality is to bump the major version number and declare that the new version is not backward compatible. Then you can completely remove the functionality from the latest version of the API but still provide old versions of the API for download, with the understanding that they are deprecated and unsupported and should be used only by legacy applications. You may even consider storing the API headers in a different
         <a id="p407">
         </a>
         <span aria-label="407" epub:type="pagebreak" id="pagebreak_407" role="doc-pagebreak">
         </span>
         directory and renaming the libraries so that the two APIs do not conflict with each other. This is a big deal, so don't do it often. Once in the lifetime of the API is best. Never is even better.
        </p>
        <p class="text" id="p0765">
         This technique was used by the Qt library when it transitioned from version 3.x to 4.x. Qt 4 introduced several new features at the cost of source and binary compatibility with Qt 3. Many functions and enums were renamed to be more consistent, some functionality was simply removed from the API, whereas other features were isolated into a new Qt3Support library. A thorough porting guide was also provided to help clients transition to the new release. This allowed Qt to make a radical step forward and improve the consistency of the API while providing support for certain Qt 3 features to legacy applications.
        </p>
        <p class="text" id="p0770">
         Another option when deciding to remove some functionality is to leave it in the code so that legacy code continues to compile, but remove it from the associated API documentation so that its existence is no longer advertised to clients. The Qt library provides another good example of this, with the use of a preprocessor define that can compile out parts of a header during documentation generation, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0135">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000027/main.assets/u10-23-9780443222191.jpg" width="2185"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0775">
         You can also achieve this with the Doxygen tool by surrounding the function declaration with the
         <span class="inlinecode">
          \cond
         </span>
         and
         <span class="inlinecode">
          \endcond
         </span>
         commands, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0140">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000027/main.assets/u10-24-9780443222191.jpg" width="969"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0125">
        </a>
        <h3 class="h2hd" id="cesectitle0135">
         Inline namespaces for versioning
        </h3>
        <p class="textfl" id="p0780">
         C++11 introduced the concept of inline namespaces, in which all members of an inlined namespace are added to the enclosing namespace. This feature can be used to help with versioning of an API by enclosing all of its symbols within a version namespace, such as:
         <a id="p408">
         </a>
         <span aria-label="408" epub:type="pagebreak" id="pagebreak_408" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0145">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000027/main.assets/u10-25-9780443222191.jpg" width="866"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0785">
         The function in this example is available as
         <span class="inlinecode">
          MyLibrary::v1::MyFunction()
         </span>
         and also simply
         <span class="inlinecode">
          MyLibrary::MyFunction()
         </span>
         . Now, if we release a new version of the API, we can preserve the original implementation as well as introduce the newer version. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0150">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000027/main.assets/u10-26-9780443222191.jpg" width="866"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0790">
         Here I've introduced a new
         <span class="inlinecode">
          v2
         </span>
         namespace and made it be the inlined namespace instead of
         <span class="inlinecode">
          v1
         </span>
         . As a result, the
         <span class="inlinecode">
          MyLibrary::v2::MyFunction()
         </span>
         is now the version that is available as
         <span class="inlinecode">
          MyLibrary::MyFunction()
         </span>
         . However, your clients can still access the previous version by referring explicitly to
         <span class="inlinecode">
          MyLibrary::v1::MyFunction()
         </span>
         , or they could use
         <span class="inlinecode">
          using namespace MyLibrary::v1
         </span>
         to use only the
         <span class="inlinecode">
          v1
         </span>
         symbols consistently, even though
         <span class="inlinecode">
          v2
         </span>
         is the default inlined version.
        </p>
        <p class="text" id="p0795">
         When your clients refer to
         <span class="inlinecode">
          MyLibrary::MyFunction()
         </span>
         in their code, the compiler will use the full namespace with the version number in the object file. This means that if you were to break the binary compatibility of your API in a newer version, you wouldn't actually break your clients' projects because they would be explicitly linking against the previous version symbols. This approach therefore gives you the ability to insulate your clients from binary breaking changes, although at the cost of having to maintain an entire set of symbols for every version that you distribute. You could reduce this cost by employing this technique only for major version number changes of your API, or only for breaking version changes.
        </p>
        <p class="text" id="p0800">
         However, if you plan to use inline namespaces for versioning, you should use them from the very first version of your API. Otherwise, you could break ABI compatibility for your clients. For example, if they were originally linking against
         <span class="inlinecode">
          MyLibrary::MyFunction(),
         </span>
         but you moved to using inline namespaces, then that symbol would no longer exist and instead there would be
         <span class="inlinecode">
          MyLibrary::v1::MyFunction()
         </span>
         and
         <span class="inlinecode">
          MyLibrary::v2::MyFunction()
         </span>
         .
         <a id="p409">
         </a>
        </p>
        <div>
         <span aria-label="409" epub:type="pagebreak" id="pagebreak_409" role="doc-pagebreak">
         </span>
        </div>
       </section>
      </section>
      <section>
       <a id="s0130">
       </a>
       <h2 class="h1hd" id="cesectitle0140">
        API reviews
       </h2>
       <p class="textfl" id="p0805">
        Backward compatibility doesn't just happen. It requires dedicated and diligent effort to ensure that no new changes to an API have silently broken existing code. This is best achieved by adding API reviews to your development process. In this section, I'll present the argument for performing API reviews, discuss how to implement these successfully, and describe a number of tools that can be used to make the job of reviewing API changes more manageable.
       </p>
       <p class="text" id="p0810">
        There are two models for performing API reviews. One is to hold a single prerelease meeting to review all changes since the previous release. The other model is to enforce a precommit change request process in which changes to the API must be requested and approved before being checked in. You can do both, of course.
       </p>
       <section>
        <a id="s0135">
        </a>
        <h3 class="h2hd" id="cesectitle0145">
         The purpose of API reviews
        </h3>
        <p class="textfl" id="p0815">
         You wouldn't release source code to your users without at least compiling it. In the same way, you shouldn't release API changes to your clients without checking that they don't break their applications. API reviews are a critical and essential step for anyone who is serious about API development. In case you need further encouragement, here are a few reasons to enforce explicit checks of your API before you release it to clients:
        </p>
        <div>
         <ol id="ulist0045">
          <li class="bulllist" id="p0820">
           <a id="u0195">
           </a>
           ▪
           <b>
            Maintain backward compatibility.
           </b>
           The primary reason to review your API before it’s released is to ensure that you've not unknowingly changed the API in a way that breaks backward compatibility. As I mentioned, if you have many engineers working on fixing bugs and adding new features, it's possible that some will not understand the vital importance of preserving the public interface.
          </li>
          <li class="bulllist" id="p0825">
           <a id="u0200">
           </a>
           ▪
           <b>
            Maintain design consistency.
           </b>
           It's crucial that the architecture and design plans that you obsessed about for the version 1.0 release are maintained throughout subsequent releases. There are two issues here. The first is that changes that don't fit into the API design should be caught and recast; otherwise the original design will become diluted and deformed until you eventually end up with a system that has no cohesion or consistency. The second issue is that change is inevitable, and if the structure of the API must change, then this requires revisiting the architecture to update it for the new functional requirements and use cases. As a caution, John Lakos points out that if you implement one new feature for 10 clients, then every
           <a id="p410">
           </a>
           <span aria-label="410" epub:type="pagebreak" id="pagebreak_410" role="doc-pagebreak">
           </span>
           client gets nine features they didn't ask for, and you must implement, test, and support 10 features that you did not originally design for (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52" id="bib_52">
            Lakos, 1996
           </a>
           ).
          </li>
          <li class="bulllist" id="p0830">
           <a id="u0205">
           </a>
           ▪
           <b>
            Change control.
           </b>
           Sometimes a change may simply be too risky. For example, an engineer may try to add a major new feature for a release that's focused on bug fixing and stability. Changes may also be too extensive or poorly tested, appear too late in the release process, violate API principles such as exposing implementation details, or not conform to the coding standards for the API. The maintainers of an API should be able to reject changes that they feel are inappropriate for the current API release and target them for a future release, perhaps with feedback on ways to improve the change.
          </li>
          <li class="bulllist" id="p0835">
           <a id="u0210">
           </a>
           ▪
           <b>
            Allow future evolution.
           </b>
           A single change to the source code can often be implemented in several different ways. Some of those ways may be better than others in that they consider future evolution and put in place a more general mechanism that will allow future improvements to be added without breaking the API. The API maintainers should be able to demand that a change be reimplemented in more future-proof fashion. Tulach calls this being evolution ready (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib99">
            Tulach, 2008
           </a>
           ).
          </li>
          <li class="bulllist" id="p0840">
           <a id="u0215">
           </a>
           ▪
           <b>
            Revisit solutions.
           </b>
           Once your API has been used in real situations and you've received feedback from your clients on its usability, you may come up with better solutions. API reviews can also be a place where you revisit previous decisions to see if they're still valid and appropriate.
          </li>
         </ol>
        </div>
        <p class="text" id="p0845">
         If your API is so successful that it becomes a standard, then other vendors may write alternative implementations. This makes the need for API change control even more critical. For example, the creators of OpenGL recognized this need, and so they formed the OpenGL Architecture Review Board (ARB) to govern the standard. The ARB was responsible for changes to the OpenGL API, advancing the standard, and defining conformance tests. This ran from 1992 until 2006, at which point control of the API specification was passed to the Khronos Group.
        </p>
        <div>
         <aside aria-labelledby="b0065" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0065">
           <div class="b1textfl" id="bpar0065">
            <i>
             TIP: Introduce an API review process to check all changes before releasing new version of the API.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0140">
        </a>
        <h3 class="h2hd" id="cesectitle0150">
         Prerelease API reviews
        </h3>
        <p class="textfl" id="p0850">
         A prerelease API review is a meeting that you hold just before the API is finally released. It's often a good activity to perform right before or during the alpha release stage. The best process for these reviews for your organization will obviously differ from what works best elsewhere. However, here are some general suggestions to help guide you. First, you should identify who the critical attendees are for such a review meeting. For example:
         <a id="p411">
         </a>
         <span aria-label="411" epub:type="pagebreak" id="pagebreak_411" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <ul class="ce_list" id="olist0030">
          <li class="numlist" id="p0855">
           <a id="o0070">
           </a>
           1.
           <b>
            Product owner.
           </b>
           This is the person who has overall responsibility for product planning and representing the needs of clients. Obviously, this person must be technical, because your users are technical. In Scrum terminology, the product owner represents the stakeholders and the business.
          </li>
          <li class="numlist" id="p0860">
           <a id="o0075">
           </a>
           2.
           <b>
            Technical lead.
           </b>
           The review will generate questions about why a particular change was added and whether it was done in the best way. This requires deep technical knowledge of the code base and strong software design skills. This person should be intimately familiar with the architectural and design rationale for the API, if they didn't develop this themselves.
          </li>
          <li class="numlist" id="p0865">
           <a id="o0080">
           </a>
           3.
           <b>
            Documentation lead.
           </b>
           An API is more than code. It's also documentation. Not all issues that are raised in the review meeting need to be fixed by changing the code. Many will require documentation fixes. Strong documentation is a critical component of any API, and so the presence of a person with technical writing skills at the review is very important.
          </li>
          <li class="numlist" id="p0870">
           <a id="o0085">
           </a>
           4.
           <b>
            Testing lead.
           </b>
           One way to feel confident that you're not breaking backward compatibility is to ensure that all existing tests have been run and continue to pass. It is also important to be sure that new tests have been written that cover any new functionality. The developer will normally be responsible for maintaining unit tests, but a separate QA engineer may also be involved to deal with higher-level automated testing such as integration or performance tests.
          </li>
         </ul>
        </div>
        <p class="text" id="p0875">
         You may decide to add further optional attendees to the review meeting, to try and cast a wider net in your effort to ensure that the new API release is the best it can be. At Pixar, we performed API reviews for all of the animation system public APIs we delivered to our film production users. In addition to those attendees, we would include a couple of senior engineers who work daily in the source code. You'll obviously also want someone from project management present to capture all of the notes for the meeting so that nothing is forgotten.
        </p>
        <p class="text" id="p0880">
         Depending upon the size of your API and the extent of the changes, these meetings can be long and grueling. We would regularly have several 2-hour meetings to cover all API changes for a release. You shouldn't rush these meetings or continue them when everyone is getting tired. Assume that they'll take several days to complete, and ensure that developers and technical writers have time to implement any required changes coming out of the meeting before the API is released.
        </p>
        <p class="text" id="p0885">
         For larger organizations, it's particularly important to have a good process for engineers to submit proposals for new public APIs or changes to existing public APIs. It’s also vital to have a dedicated team focused on reviewing and enforcing the organization's best practices for API design. One large company where I worked has a particularly good API review process. They have an internal website where proposals for new or changed APIs can be submitted. The submissions are managed through GitHub, allowing reviewers and stakeholders to collaborate through comments, to enforce rules such as requiring two reviewer approvals, and to have an entire revision history for all API
         <a id="p412">
         </a>
         <span aria-label="412" epub:type="pagebreak" id="pagebreak_412" role="doc-pagebreak">
         </span>
         decisions. The format of these submissions is also well-defined and is composed of sections such as:
        </p>
        <div>
         <ol id="ulist0050">
          <li class="bulllist" id="p0890">
           <a id="u0220">
           </a>
           •
           <b>
            Metadata
           </b>
           : Each submission has a unique ID, a list of authors and sponsors, the target software release, any related bug tracking system IDs, and so on.
          </li>
          <li class="bulllist" id="p0895">
           <a id="u0225">
           </a>
           •
           <b>
            Introduction
           </b>
           : Provides a short elevator pitch for the API change.
          </li>
          <li class="bulllist" id="p0900">
           <a id="u0230">
           </a>
           •
           <b>
            Motivation
           </b>
           : Goes into detail about the problem being solved.
          </li>
          <li class="bulllist" id="p0905">
           <a id="u0235">
           </a>
           •
           <b>
            Proposed Solution
           </b>
           : Provides an overview of the solution, ideally with examples.
          </li>
          <li class="bulllist" id="p0910">
           <a id="u0240">
           </a>
           •
           <b>
            Detailed Design
           </b>
           : Declarations of new or changed public symbols, lifted verbatim from the code.
          </li>
          <li class="bulllist" id="p0915">
           <a id="u0245">
           </a>
           •
           <b>
            Impacts on Quality
           </b>
           : Any concerns on the usability or testing of the API.
          </li>
          <li class="bulllist" id="p0920">
           <a id="u0250">
           </a>
           •
           <b>
            Alternatives Considered
           </b>
           : Summarizes decisions that were made to get to the current proposal.
          </li>
         </ol>
        </div>
        <p class="text" id="p0925">
         In terms of activities that should be performed during an API review, the most important thing is to focus on the interface being delivered, not on the specifics of the implementation. In other words, the primary focus should be on the public symbols and the documentation, such as the automatically generated API documentation (see
         <a href="../B9780443222191000155/CH0011_415-442_B9780443222191000155.xhtml">
          Chapter 11
         </a>
         on Documentation for specifics on using Doxygen for this purpose). More specifically, you are most interested in changes to the API since the last release. This may involve the creation of a tool to report the differences between the current API and the previous version. For each change, the review committee should ask various questions, such as:
        </p>
        <div>
         <ol id="ulist0055">
          <li class="bulllist" id="p0930">
           <a id="u0255">
           </a>
           ▪ Does this change break backward compatibility?
          </li>
          <li class="bulllist" id="p0935">
           <a id="u0260">
           </a>
           ▪ Does this change break binary compatibility (if this is a goal)?
          </li>
          <li class="bulllist" id="p0940">
           <a id="u0265">
           </a>
           ▪ Does this change have sufficient documentation?
          </li>
          <li class="bulllist" id="p0945">
           <a id="u0270">
           </a>
           ▪ Could this change have been implemented in a more future-proof manner?
          </li>
          <li class="bulllist" id="p0950">
           <a id="u0275">
           </a>
           ▪ Does this change have negative performance implications?
          </li>
          <li class="bulllist" id="p0955">
           <a id="u0280">
           </a>
           ▪ Does this change break the architecture model?
          </li>
          <li class="bulllist" id="p0960">
           <a id="u0285">
           </a>
           ▪ Does this change conform to the API coding standards?
          </li>
          <li class="bulllist" id="p0965">
           <a id="u0290">
           </a>
           ▪ Does this change introduce cyclic dependencies into the code?
          </li>
          <li class="bulllist" id="p0970">
           <a id="u0295">
           </a>
           ▪ Should the API change include upgrade scripts to help clients update their code or data files?
          </li>
          <li class="bulllist" id="p0975">
           <a id="u0300">
           </a>
           ▪ Are there existing automated tests for the changed code to verify that functional compatibility has not been affected?
          </li>
          <li class="bulllist" id="p0980">
           <a id="u0305">
           </a>
           ▪ Does the change need automated tests, and have they been written?
          </li>
          <li class="bulllist" id="p0985">
           <a id="u0310">
           </a>
           ▪ Is this a change we want to release to clients?
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0145">
        </a>
        <h3 class="h2hd" id="cesectitle0155">
         Precommit API reviews
        </h3>
        <p class="textfl" id="p0990">
         Of course, you don't have to wait until right before release to catch these problems. The prerelease API review meeting is the last line of defense to ensure that undesirable changes aren't released to users. However, the work of the API review can be greatly decreased if the API owners are constantly vigilant during the development process,
         <a id="p413">
         </a>
         <span aria-label="413" epub:type="pagebreak" id="pagebreak_413" role="doc-pagebreak">
         </span>
         watching checkins to the source code and flagging problems early on so that they can be addressed before they reach the API review meeting.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0025">
          <img alt="image" height="1456" src="../../IMAGES/B9780443222191000027/main.assets/f10-04-9780443222191.jpg" width="2740"/>
          <figcaption class="figleg">
           <a id="cap0025">
           </a>
           <a id="fspara0025">
           </a>
           <span class="fignum">
            <a href="#Bf0025">
             Figure 10.4
            </a>
           </span>
           The public interface change request (CR) process for the Symbian platform. Copyright (c) 2009 Symbian Foundation limited. Licensed under the Creative commons license 2.0 by Stichbury.
          </figcaption>
         </figure>
        </div>
        <p class="text" id="p0995">
         Many organizations or projects will therefore institute precommit API reviews. That is, they will put in place a change request process, in which engineers wishing to make a change to the public API must formally request permission for the change from the API review committee. Implementation-only changes that do not affect the public API do not normally need to go through this additional process. This is particularly useful for open source software projects, in which patches can be submitted from many engineers with differing backgrounds and skills.
        </p>
        <p class="text" id="p1000">
         For example, the open-source Symbian mobile device OS imposes a change control process for all Symbian platform public API changes. The stated goal of this process is to ensure that the public API evolves in a controlled manner. The process is started by submitting a change request with the following information:
        </p>
        <div>
         <ol id="ulist0060">
          <li class="bulllist" id="p1005">
           <a id="u0315">
           </a>
           ▪ A description of the change and why it's necessary.
          </li>
          <li class="bulllist" id="p1010">
           <a id="u0320">
           </a>
           ▪ An impact analysis for any clients of the API.
          </li>
          <li class="bulllist" id="p1015">
           <a id="u0325">
           </a>
           ▪ A porting guide to the new version of the API.
          </li>
          <li class="bulllist" id="p1020">
           <a id="u0330">
           </a>
           ▪ Updates to the backward compatibility test cases.
          </li>
         </ol>
        </div>
        <p class="text" id="p1025">
         This is then reviewed by the architecture council, who will either approve or reject the request and provide the rationale for the decision. Once approved, the developer can submit the code, documentation, and test updates.
         <a href="#f0025" id="Bf0025">
          Fig. 10.4
         </a>
         provides an overview of this process.
         <a id="p414">
         </a>
        </p>
        <div>
         <span aria-label="414" epub:type="pagebreak" id="pagebreak_414" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1030">
         As another example, the Java-based NetBeans project defines an API review process for accepting patches from developers. This is done to supervise the architecture of the NetBeans IDE and related products. Changes to existing APIs, or requests for new APIs, are required to be reviewed before they are accepted into the trunk code line. This process is managed through the NetBeans bug tracking system, in which requests for review are marked with the keyword API_REVIEW or API_REVIEW_FAST. The review process will result in a change being either accepted or rejected. In the case of rejection, the developer is normally given direction on improvements to the design, implementation, or documentation that would make the change more acceptable. Of course, similar feedback may still be provided for accepted changes. For details on this process, see
         <a href="https://netbeans.apache.org/wiki/main/wiki/APIReviews/">
          https://netbeans.apache.org/wiki/main/wiki/APIReviews/
         </a>
         .
        </p>
        <p class="text" id="p1035">
         You can also rely on automation to make precommit checks easier. For example, using an SCM such as GitHub you can set up various commit hooks to enforce coding conventions, run automated tests, perform static analysis checks, and require approval from specific reviewers. Pull requests can then be merged only if all automated checks pass and sufficient approvals have been gained. You can also define a
         <span class="inlinecode">
          CODEOWNERS
         </span>
         file to have various reviewers for different parts of the code base, such as including a group of API reviewers for any
         <span class="inlinecode">
          .h
         </span>
         file changes.
        </p>
        <p class="text" id="p1040">
         Precommit reviews are a good way to stay on top of the incoming stream of API changes during the development process. However, it's still useful to schedule a single prerelease API review meeting as well. This can be used to catch any changes that slipped through the cracks because an engineer was unaware of the process or didn't realize that it applied to his or her change.
        </p>
       </section>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
