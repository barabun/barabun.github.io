<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   8Gaining Proficiency with Classes and Objects
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_018.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_020.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c08_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c08_1">
      <span aria-label="259" epub:type="pagebreak" id="Page_259" role="doc-pagebreak">
      </span>
      <span id="c08">
      </span>
      <span class="chapterNumber">
       8
      </span>
      <br/>
      <span class="chapterTitle">
       Gaining Proficiency with Classes and Objects
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c08-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c08-list-0001">
         <li id="c08-li-0001">
          How to write your own classes with member functions and data members
         </li>
         <li id="c08-li-0002">
          How to control access to your member functions and data members
         </li>
         <li id="c08-li-0003">
          How to use objects on the stack and on the free store
         </li>
         <li id="c08-li-0004">
          What the life cycle of an object is
         </li>
         <li id="c08-li-0005">
          How to write code that is executed when an object is created or destroyed
         </li>
         <li id="c08-li-0006">
          How to write code to copy or assign objects
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c08-fea-0001">
        </span>
        <h3 id="head-2-102">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p id="c08-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <a href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c08-para-0005">
      As an object-oriented language, C++ provides facilities for using objects and for writing object blueprints, called
      <i>
       classes
      </i>
      . You can certainly write programs in C++ without classes and objects, but by doing so, you do not take advantage of the most fundamental and useful aspect of the language; writing a C++ program without classes is like traveling to Paris and eating at McDonald's. To use classes and objects effectively, you must understand their syntax and capabilities.
     </p>
     <p id="c08-para-0006">
      <span aria-label="260" epub:type="pagebreak" id="Page_260" role="doc-pagebreak">
      </span>
      <a href="c01.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library,” reviewed the basic syntax of class definitions.
      <a href="c05.xhtml">
       Chapter 5
      </a>
      , “Designing with Classes,” introduced the object-oriented approach to programming in C++ and presented specific design strategies for classes and objects. This chapter describes the fundamental concepts involved in using classes and objects, including writing class definitions, defining member functions, using objects on the stack and the free store, writing constructors, default constructors, compiler-generated constructors, constructor initializers (also known as
      <i>
       ctor-initializers
      </i>
      ), copy constructors, initializer-list constructors, destructors, and assignment operators. Even if you are already comfortable with classes and objects, you should skim this chapter because it contains various tidbits of information with which you might not yet be familiar.
     </p>
    </section>
    <section aria-labelledby="head-2-103">
     <span id="c08-sec-0004">
     </span>
     <h2 id="head-2-103">
      INTRODUCING THE SPREADSHEET EXAMPLE
     </h2>
     <p id="c08-para-0007">
      Both this chapter and the next present a runnable example of a simple spreadsheet application. A spreadsheet is a two-dimensional grid of “cells,” and each cell contains a number or a string. Professional spreadsheets such as Microsoft Excel provide the ability to perform mathematical operations, such as calculating the sum of the values of a set of cells. The spreadsheet example in these chapters does not attempt to challenge Microsoft in the marketplace, but it is useful for illustrating the issues of classes and objects.
     </p>
     <p>
      The spreadsheet application uses two basic classes:
      <code>
       Spreadsheet
      </code>
      and
      <code>
       SpreadsheetCell
      </code>
      . Each
      <code>
       Spreadsheet
      </code>
      object contains
      <code>
       SpreadsheetCell
      </code>
      objects. In addition, a
      <code>
       SpreadsheetApplication
      </code>
      class manages a collection of
      <code>
       Spreadsheet
      </code>
      s. This chapter focuses on the
      <code>
       SpreadsheetCell
      </code>
      class.
      <a href="c09.xhtml">
       Chapter 9
      </a>
      , “Mastering Classes and Objects,” develops the
      <code>
       Spreadsheet
      </code>
      and
      <code>
       SpreadsheetApplication
      </code>
      classes.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c08-para-0009">
         <b>
          NOTE
         </b>
         <i>
          This chapter shows several different versions of the
         </i>
         <code>
          SpreadsheetCell
         </code>
         <i>
          class in order to introduce concepts gradually. Thus, the various attempts at the class throughout the chapter do not always illustrate the “best” way to do every aspect of class writing. In particular, the early examples omit important features that would normally be included but have not yet been introduced. You can download the final version of the class as described in the beginning of this chapter.
         </i>
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-104">
     <span id="c08-sec-0006">
     </span>
     <h2 id="head-2-104">
      WRITING CLASSES
     </h2>
     <p id="c08-para-0010">
      When you write a class, you specify the behaviors, or
      <i>
       member functions
      </i>
      , that will apply to objects of that class, and you specify the properties, or
      <i>
       data members
      </i>
      , that each object will contain.
     </p>
     <p id="c08-para-0011">
      There are two components in the process of writing classes: defining the classes themselves and defining their member functions.
     </p>
     <section>
      <span id="c08-sec-0007">
      </span>
      <h3 id="head-3-176">
       Class Definitions
      </h3>
      <p>
       Here is a first attempt at a simple
       <code>
        SpreadsheetCell
       </code>
       class in a
       <code>
        spreadsheet_cell
       </code>
       module, in which each cell can store only a single number:
      </p>
      <pre id="c08-code-0001"><span aria-label="261" epub:type="pagebreak" id="Page_261" role="doc-pagebreak"></span><code>export module spreadsheet_cell;</code>
<code> </code>
<code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        void setValue(double value);</code>
<code>        double getValue() const;</code>
<code>    private:</code>
<code>        double m_value;</code>
<code>};</code></pre>
      <p id="c08-para-0013">
       As described in
       <a href="c01.xhtml">
        Chapter 1
       </a>
       , the first line specifies that this is the definition of a module named
       <code>
        spreadsheet_cell
       </code>
       . Every class definition begins with the keyword
       <code>
        class
       </code>
       followed by the name of the class. If the class is defined in a module and the class must become visible to clients importing the module, then the
       <code>
        class
       </code>
       keyword is prefixed with
       <code>
        export
       </code>
       . A class definition is a
       <i>
        declaration
       </i>
       and ends with a semicolon.
      </p>
      <p id="c08-para-0014">
       Class definitions usually go in a file named after the class. For example, the
       <code>
        SpreadsheetCell
       </code>
       class definition is put in a file called
       <code>
        SpreadsheetCell.cppm
       </code>
       . Some compilers require the use of a specific extension; others allow you to choose any extension.
      </p>
      <section>
       <span id="c08-sec-0008">
       </span>
       <h4 id="head-4-144">
        Class Members
       </h4>
       <p id="c08-para-0015">
        A class can have several
        <i>
         members
        </i>
        . A member can be a
        <i>
         member function
        </i>
        (which in turn is a
        <i>
         function, constructor
        </i>
        , or
        <i>
         destructor
        </i>
        ), a
        <i>
         member variable
        </i>
        (also called a
        <i>
         data member
        </i>
        ), member enumerations, type aliases, nested classes, and so on.
       </p>
       <p>
        The two lines that look like function prototypes declare the member functions that this class supports:
       </p>
       <pre id="c08-code-0002"><code>void setValue(double value);</code>
<code>double getValue() const;</code></pre>
       <p id="c08-para-0017">
        <a href="c01.xhtml">
         Chapter 1
        </a>
        points out that it is always a good idea to declare member functions that do not change the object as
        <code>
         const
        </code>
        , like the
        <code>
         getValue()
        </code>
        member function.
       </p>
       <p>
        The line that looks like a variable declaration declares the data member for this class:
       </p>
       <pre id="c08-code-0003"><code>double m_value;</code></pre>
       <p id="c08-para-0019">
        A class defines the member functions and data members that apply. They apply only to a specific
        <i>
         instance
        </i>
        of the class, which is an
        <i>
         object
        </i>
        . The only exceptions to this rule are static members, which are explained in
        <a href="c09.xhtml">
         Chapter 9
        </a>
        . Classes define concepts; objects contain real bits. So, each object contains its own value for the
        <code>
         m_value
        </code>
        data member. The implementation of the member functions is shared across all objects. Classes can contain any number of member functions and data members. You cannot give a data member the same name as a member function.
       </p>
      </section>
      <section>
       <span id="c08-sec-0009">
       </span>
       <h4 id="head-4-145">
        Access Control
       </h4>
       <p id="c08-para-0020">
        Every member in a class is subject to one of three
        <i>
         access specifiers
        </i>
        :
        <code>
         public
        </code>
        ,
        <code>
         private
        </code>
        , or
        <code>
         protected
        </code>
        . The
        <code>
         protected
        </code>
        access specifier is explained in the context of inheritance in
        <a href="c10.xhtml">
         Chapter 10
        </a>
        , “Discovering Inheritance Techniques.” An access specifier applies to all member declarations that follow it, until the next access specifier. In the
        <code>
         SpreadsheetCell
        </code>
        class, the
        <code>
         setValue()
        </code>
        and
        <code>
         getValue()
        </code>
        member functions have
        <code>
         public
        </code>
        access, while the
        <code>
         m_value
        </code>
        data member has
        <code>
         private
        </code>
        access.
       </p>
       <p>
        <span aria-label="262" epub:type="pagebreak" id="Page_262" role="doc-pagebreak">
        </span>
        The default access specifier for classes is
        <code>
         private
        </code>
        : all member declarations before the first access specifier have the
        <code>
         private
        </code>
        access specification. For example, moving the
        <code>
         public
        </code>
        access specifier to after the
        <code>
         setValue()
        </code>
        member function declaration gives the
        <code>
         setValue()
        </code>
        member function
        <code>
         private
        </code>
        access instead of
        <code>
         public
        </code>
        :
       </p>
       <pre id="c08-code-0004"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>        <b>void setValue(double value);</b> <span class="color3">// now has private access</span></code>
<code>    <b>public:</b></code>
<code>        double getValue() const;</code>
<code>    private:</code>
<code>        double m_value;</code>
<code>};</code></pre>
       <p id="c08-para-0022">
        In C++, a
        <code>
         struct
        </code>
        can have member functions just like a
        <code>
         class
        </code>
        . In fact, there is only one difference: for a
        <code>
         struct
        </code>
        , the default access specifier is
        <code>
         public
        </code>
        , while it's
        <code>
         private
        </code>
        for a
        <code>
         class
        </code>
        .
       </p>
       <p>
        For example, the
        <code>
         SpreadsheetCell
        </code>
        class could be rewritten using a
        <code>
         struct
        </code>
        as follows:
       </p>
       <pre id="c08-code-0005"><code>export struct SpreadsheetCell</code>
<code>{</code>
<code>        void setValue(double value);</code>
<code>        double getValue() const;</code>
<code>    private:</code>
<code>        double m_value;</code>
<code>};</code></pre>
       <p>
        However, it's unconventional to do so. A
        <code>
         struct
        </code>
        is usually used only if you just need a collection of publicly accessible data members and no member functions. The following is an example of such a simple
        <code>
         struct
        </code>
        to store 2-D point coordinates:
       </p>
       <pre id="c08-code-0006"><code>export struct Point</code>
<code>{</code>
<code>    double x;</code>
<code>    double y;</code>
<code>};</code></pre>
      </section>
      <section>
       <span id="c08-sec-0010">
       </span>
       <h4 id="head-4-146">
        Order of Declarations
       </h4>
       <p>
        You can declare your members and access control specifiers in any order: C++ does not impose any restrictions, such as member functions before data members or
        <code>
         public
        </code>
        before
        <code>
         private
        </code>
        . Additionally, you can repeat access specifiers. For example, the
        <code>
         SpreadsheetCell
        </code>
        definition could look like this:
       </p>
       <pre id="c08-code-0007"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    <b>public:</b></code>
<code>        <b>void setValue(double value);</b></code>
<code>    <b>private:</b></code>
<code>        <b>double m_value;</b></code>
<code>    <b>public:</b></code>
<code>        <b>double getValue() const;</b></code>
<code>};</code></pre>
       <p id="c08-para-0026">
        However, for clarity it is a good idea to group declarations based on their access specifier and to group member functions and data members within those declarations.
       </p>
      </section>
      <span aria-label="263" epub:type="pagebreak" id="Page_263" role="doc-pagebreak">
      </span>
      <section>
       <span id="c08-sec-0011">
       </span>
       <h4 id="head-4-147">
        In-Class Member Initializers
       </h4>
       <p>
        Data members can be initialized directly in the class definition. For example, the
        <code>
         SpreadsheetCell
        </code>
        class can, by default, initialize
        <code>
         m_value
        </code>
        to 0 directly in the class definition as follows:
       </p>
       <pre id="c08-code-0008"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>    private:</code>
<code>        <b>double m_value { 0 };</b></code>
<code>};</code></pre>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0029">
           <b>
            NOTE
           </b>
           <i>
            It is recommended to always initialize data members of a class
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section>
      <span id="c08-sec-0013">
      </span>
      <h3 id="head-3-177">
       Defining Member Functions
      </h3>
      <p id="c08-para-0030">
       The preceding definition for the
       <code>
        SpreadsheetCell
       </code>
       class is enough for you to create objects of the class. However, if you try to call the
       <code>
        setValue()
       </code>
       or
       <code>
        getValue()
       </code>
       member function, your linker will complain that those member functions are not defined. That's because these member functions only have prototypes so far, but no implementations yet. Usually, a class definition goes in a module interface file. For the member function definitions, you have a choice: they can go in the module interface file or in a
       <i>
        module implementation file
       </i>
       .
      </p>
      <p>
       Here is the
       <code>
        SpreadsheetCell
       </code>
       class with in-class member function implementations:
      </p>
      <pre id="c08-code-0009"><code>export module spreadsheet_cell;</code>
<code> </code>
<code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>void setValue(double value) { m_value = value; }</b></code>
<code>        <b>double getValue() const { return m_value; }</b></code>
<code>    private:</code>
<code>        double m_value { 0 };</code>
<code>};</code></pre>
      <p id="c08-para-0032">
       Unlike with header files, with C++ modules there is no harm in putting member function definitions in module interface files. This is discussed in more detail in
       <a href="c11.xhtml">
        Chapter 11
       </a>
       , “Modules, Header Files, and Miscellaneous Topics.” However, this book often puts member function definitions in module implementation files, in the interest of keeping module interface files clean and without any implementation details.
      </p>
      <p>
       The first line of a module implementation file specifies which module the implementations are for. Here are the definitions for the two member functions of the
       <code>
        SpreadsheetCell
       </code>
       class in the
       <code>
        spreadsheet_cell
       </code>
       module:
      </p>
      <pre id="c08-code-0010"><code>module spreadsheet_cell;</code>
<code> </code>
<code>void SpreadsheetCell::setValue(double value)</code>
<code>{</code>
<span aria-label="264" epub:type="pagebreak" id="Page_264" role="doc-pagebreak"></span><code>    m_value = value;</code>
<code>}</code>
<code> </code>
<code>double SpreadsheetCell::getValue() const</code>
<code>{</code>
<code>    return m_value;</code>
<code>}</code></pre>
      <p>
       Note that the name of the class followed by two colons precedes each member function name:
      </p>
      <pre id="c08-code-0011"><code>void SpreadsheetCell::setValue(double value)</code></pre>
      <p id="c08-para-0035">
       The
       <code>
        ::
       </code>
       is called the
       <i>
        scope resolution operator
       </i>
       . In this context, the syntax tells the compiler that the coming definition of the
       <code>
        setValue()
       </code>
       member function is part of the
       <code>
        SpreadsheetCell
       </code>
       class. Note also that you do not repeat the access specification when you define the member function.
      </p>
      <section>
       <span id="c08-sec-0014">
       </span>
       <h4 id="head-4-148">
        Accessing Data Members
       </h4>
       <p>
        Non-static member functions of a class, such as
        <code>
         setValue()
        </code>
        and
        <code>
         getValue()
        </code>
        , are always executed on behalf of a specific object of that class. Inside a member function's body, you have access to all data members of the class for that object. In the previous definition for
        <code>
         setValue()
        </code>
        , the following line changes the
        <code>
         m_value
        </code>
        variable inside whatever object calls the member function:
       </p>
       <pre id="c08-code-0012"><code>m_value = value;</code></pre>
       <p id="c08-para-0037">
        If
        <code>
         setValue()
        </code>
        is called for two different objects, the same line of code (executed once for each object) changes the variable in two different objects.
       </p>
      </section>
      <section>
       <span id="c08-sec-0015">
       </span>
       <h4 id="head-4-149">
        Calling Other Member Functions
       </h4>
       <p>
        You can call member functions of a class from inside another member function. For example, consider an extension to the
        <code>
         SpreadsheetCell
        </code>
        class to allow setting and retrieving the value of a cell as a string or as a number. When you try to set the value of a cell with a string, the cell tries to convert the string to a number. If the string does not represent a valid number, the cell value is ignored. In this program, strings that are not numbers will generate a cell value of 0. Here is a first stab at such a class definition for a
        <code>
         SpreadsheetCell
        </code>
        :
       </p>
       <pre id="c08-code-0013"><code>export module spreadsheet_cell;</code>
<code><b>import std;</b></code>
<code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        void setValue(double value);</code>
<code>        double getValue() const;</code>
<code> </code>
<code>        <b>void setString(std::string_view value);</b></code>
<code>        <b>std::string getString() const;</b></code>
<code>    private:</code>
<code>        <b>std::string doubleToString(double value) const;</b></code>
<code>        <b>double stringToDouble(std::string_view value) const;</b></code>
<code>        double m_value { 0 };</code>
<code>};</code></pre>
       <p>
        <span aria-label="265" epub:type="pagebreak" id="Page_265" role="doc-pagebreak">
        </span>
        This version of the class stores the data only as a
        <code>
         double
        </code>
        . If the client sets the data as a
        <code>
         string
        </code>
        , it is converted to a
        <code>
         double
        </code>
        . If the text is not a valid number, the
        <code>
         double
        </code>
        value is set to 0. The class definition shows two new member functions to set and retrieve the text representation of the cell, and two new private
        <i>
         helper member functions
        </i>
        to convert a
        <code>
         double
        </code>
        to a
        <code>
         string
        </code>
        and vice versa. Here are the implementations of all the member functions:
       </p>
       <pre id="c08-code-0014"><code>module spreadsheet_cell;</code>
<code><b>import std;</b></code>
<code><b>using namespace std;</b></code>
<code> </code>
<code>void SpreadsheetCell::setValue(double value)</code>
<code>{</code>
<code>    m_value = value;</code>
<code>}</code>
<code> </code>
<code>double SpreadsheetCell::getValue() const</code>
<code>{</code>
<code>    return m_value;</code>
<code>}</code>
<code> </code>
<code><b>void SpreadsheetCell::setString(string_view value)</b></code>
<code><b>{</b></code>
<code>    <b>m_value = stringToDouble(value);</b></code>
<code><b>}</b></code>
<code> </code>
<code><b>string SpreadsheetCell::getString() const</b></code>
<code><b>{</b></code>
<code>    <b>return doubleToString(m_value);</b></code>
<code><b>}</b></code>
<code> </code>
<code><b>string SpreadsheetCell::doubleToString(double value) const</b></code>
<code><b>{</b></code>
<code>    <b>return to_string(value);</b></code>
<code><b>}</b></code>
<code> </code>
<code><b>double SpreadsheetCell::stringToDouble(string_view value) const</b></code>
<code><b>{</b></code>
<code>    <b>double number { 0 };</b></code>
<code>    <b>from_chars(value.data(), value.data() + value.size(), number);</b></code>
<code>    <b>return number;</b></code>
<code><b>}</b></code></pre>
       <p id="c08-para-0040">
        The
        <code>
         std::to_string()
        </code>
        and
        <code>
         from_chars()
        </code>
        functions are explained in
        <a href="c02.xhtml">
         Chapter 2
        </a>
        , “Working with Strings and String Views.”
       </p>
       <p id="c08-para-0041">
        Note that with this implementation of the
        <code>
         doubleToString()
        </code>
        member function, a value of, for example, 6.1 is converted to 6.100000. However, because it is a private helper member function, you are free to modify the implementation without having to modify any client code.
       </p>
      </section>
     </section>
     <section>
      <span id="c08-sec-0016">
      </span>
      <h3 id="head-3-178">
       Using Objects
      </h3>
      <p id="c08-para-0042">
       The previous class definition says that a
       <code>
        SpreadsheetCell
       </code>
       consists of one data member, four
       <code>
        public
       </code>
       member functions, and two
       <code>
        private
       </code>
       member functions. However, the class definition does
       <span aria-label="266" epub:type="pagebreak" id="Page_266" role="doc-pagebreak">
       </span>
       not actually create any
       <code>
        SpreadsheetCell
       </code>
       s; it just specifies their shape and behavior. In that sense, a class is like architectural blueprints. The blueprints specify what a house should look like, but drawing the blueprints doesn't build any houses. Houses must be constructed later based on the blueprints.
      </p>
      <p id="c08-para-0043">
       Similarly, in C++ you can construct a
       <code>
        SpreadsheetCell
       </code>
       “object” from the
       <code>
        SpreadsheetCell
       </code>
       class definition by declaring a variable of type
       <code>
        SpreadsheetCell
       </code>
       . Just as a builder can build more than one house based on a given set of blueprints, a programmer can create more than one
       <code>
        SpreadsheetCell
       </code>
       object from a
       <code>
        SpreadsheetCell
       </code>
       class. There are two ways to create and use objects: on the stack and on the free store.
      </p>
      <section>
       <span id="c08-sec-0017">
       </span>
       <h4 id="head-4-150">
        Objects on the Stack
       </h4>
       <p>
        Here is some code that creates and uses
        <code>
         SpreadsheetCell
        </code>
        objects on the stack:
       </p>
       <pre id="c08-code-0015"><code>SpreadsheetCell myCell, anotherCell;</code>
<code>myCell.setValue(6);</code>
<code>anotherCell.setString("3.2");</code>
<code>println("cell 1: {}", myCell.getValue());</code>
<code>println("cell 2: {}", anotherCell.getValue());</code></pre>
       <p id="c08-para-0045">
        You create objects just as you declare simple variables, except that the variable type is the class name. The
        <code>
         .
        </code>
        in lines like
        <code>
         myCell.setValue(6);
        </code>
        is called the
        <i>
         “dot” operator
        </i>
        , also called the
        <i>
         member access operator
        </i>
        ; it allows you to call
        <code>
         public
        </code>
        member functions on the object. If there were any
        <code>
         public
        </code>
        data members in the object, you could access them with the dot operator as well. Remember that
        <code>
         public
        </code>
        data members are not recommended.
       </p>
       <p>
        The output of the program is as follows:
       </p>
       <pre id="c08-code-0016"><code>cell 1: 6</code>
<code>cell 2: 3.2</code></pre>
      </section>
      <section>
       <span id="c08-sec-0018">
       </span>
       <h4 id="head-4-151">
        Objects on the Free Store
       </h4>
       <p>
        You can also dynamically allocate objects by using
        <code>
         new:
        </code>
       </p>
       <pre id="c08-code-0017"><code>SpreadsheetCell* myCellp { new SpreadsheetCell { } };</code>
<code>myCellp-&gt;setValue(3.7);</code>
<code>println("cell 1: {} {}", myCellp-&gt;getValue(), myCellp-&gt;getString());</code>
<code>delete myCellp;</code>
<code>myCellp = nullptr;</code></pre>
       <p>
        When you create an object on the free store, you access its members through the “arrow” operator:
        <code>
         -&gt;
        </code>
        . The arrow combines dereferencing (
        <code>
         *
        </code>
        ) and member access (
        <code>
         .
        </code>
        ). You could use those two operators instead, but doing so would be stylistically awkward:
       </p>
       <pre id="c08-code-0018"><code>SpreadsheetCell* myCellp { new SpreadsheetCell { } };</code>
<code><b>(*myCellp).setValue(3.7);</b></code>
<code><b>println("cell 1: {} {}", (*myCellp).getValue(), (*myCellp).getString());</b></code>
<code>delete myCellp;</code>
<code>myCellp = nullptr;</code></pre>
       <p>
        Just as you must free other memory that you allocate on the free store, you must free the memory for objects that you allocate on the free store by calling
        <code>
         delete
        </code>
        on them, as is done in the previous code
        <span aria-label="267" epub:type="pagebreak" id="Page_267" role="doc-pagebreak">
        </span>
        snippets! To guarantee safety and to avoid memory problems, you really should use smart pointers, as in the following example:
       </p>
       <pre id="c08-code-0019"><code><b>auto myCellp { make_unique&lt;SpreadsheetCell&gt;() };</b></code>
<code><span class="color3">// Equivalent to:</span></code>
<code><span class="color3">// unique_ptr&lt;SpreadsheetCell&gt; myCellp { new SpreadsheetCell { } };</span></code>
<code>myCellp-&gt;setValue(3.7);</code>
<code>println("cell 1: {} {}", myCellp-&gt;getValue(), myCellp-&gt;getString());</code></pre>
       <p>
        With smart pointers you don't need to manually free the memory; it happens automatically.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0051">
           <b>
            WARNING
           </b>
           <i>
            When you allocate an object with
           </i>
           <code>
            new
           </code>
           <i>
            , free it with
           </i>
           <code>
            delete
           </code>
           <i>
            after you are finished with it, or, better yet, use smart pointers to manage the memory automatically!
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0052">
           <b>
            NOTE
           </b>
           <i>
            If you don't use smart pointers, it is always a good idea to reset a pointer to
            <code>
             nullptr
            </code>
            after deleting the object to which it pointed. You are not required to do so, but it will make debugging easier in case the pointer is accidentally used after deleting the object
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section>
      <span id="c08-sec-0021">
      </span>
      <h3 id="head-3-179">
       The this Pointer
      </h3>
      <p>
       Every normal member function call implicitly passes a pointer to the object for which it is called as a “hidden” parameter with the name
       <code>
        this
       </code>
       . You can use this pointer to access data members or call member functions, and you can pass it to other member functions or functions. It is sometimes also useful for disambiguating names. For example, you could have defined the
       <code>
        SpreadsheetCell
       </code>
       class with a
       <code>
        value
       </code>
       data member instead of
       <code>
        m_value
       </code>
       . In that case,
       <code>
        setValue()
       </code>
       would look like the following:
      </p>
      <pre id="c08-code-0020"><code>void SpreadsheetCell::setValue(double value)</code>
<code>{</code>
<code>    <b>value = value;</b> <span class="color3">// Confusing!</span></code>
<code>}</code></pre>
      <p>
       That line is confusing. Which
       <code>
        value
       </code>
       do you mean: the
       <code>
        value
       </code>
       that was passed as a parameter or the
       <code>
        value
       </code>
       that is a member of the object?
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c08-para-0055">
          <b>
           NOTE
          </b>
          <i>
           With some compilers or compiler settings, the preceding confusing line compiles without any warnings or errors, but it will not produce the results that you are expecting
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       <span aria-label="268" epub:type="pagebreak" id="Page_268" role="doc-pagebreak">
       </span>
       To disambiguate the names, you can use the
       <code>
        this
       </code>
       pointer:
      </p>
      <pre id="c08-code-0021"><code>void SpreadsheetCell::setValue(double value)</code>
<code>{</code>
<code>    <b>this-&gt;value = value;</b></code>
<code>}</code></pre>
      <p id="c08-para-0057">
       However, if you use the naming conventions described in
       <a href="c03.xhtml">
        Chapter 3
       </a>
       , “Coding with Style,” you will never encounter this type of name collision.
      </p>
      <p>
       You can also use the
       <code>
        this
       </code>
       pointer to call a function that takes, as a parameter, a pointer to an object from within a member function of that object. For example, suppose you write a
       <code>
        printCell()
       </code>
       stand-alone function (not a member function) like this:
      </p>
      <pre id="c08-code-0022"><code>void printCell(const SpreadsheetCell&amp; cell)</code>
<code>{</code>
<code>    println("{}", cell.getString());</code>
<code>}</code></pre>
      <p>
       If you want to call
       <code>
        printCell()
       </code>
       from the
       <code>
        setValue()
       </code>
       member function, you must pass
       <code>
        *this
       </code>
       as the argument to give
       <code>
        printCell()
       </code>
       a reference to the
       <code>
        SpreadsheetCell
       </code>
       on which
       <code>
        setValue()
       </code>
       operates:
      </p>
      <pre id="c08-code-0023"><code>void SpreadsheetCell::setValue(double value)</code>
<code>{</code>
<code>    this-&gt;value = value;</code>
<code>    <b>printCell(*this);</b></code>
<code>}</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c08-para-0061">
          <b>
           NOTE
          </b>
          <i>
           Instead of writing a
          </i>
          <code>
           printCell()
          </code>
          <i>
           function, it would be more convenient to write a custom formatter, as explained in
           <a href="c02.xhtml">
            Chapter 2
           </a>
           . You can then use the following line to print a
          </i>
          <code>
           SpreadsheetCell
          </code>
          <i>
           called
          </i>
          <code>
           myCell
          </code>
          <i>
           :
          </i>
         </p>
         <pre id="c08-code-0024"><code>std::println("{}", myCell);</code></pre>
         <p id="c08-para-0063">
          <i>
           Alternatively, you can overload the
          </i>
          <code>
           &lt;&lt;
          </code>
          <i>
           operator, as explained in
           <a href="c15.xhtml">
            Chapter 15
           </a>
           , “Overloading C++ Operators.” You can then write the following:
          </i>
         </p>
         <pre id="c08-code-0025"><code>    cout &lt;&lt; myCell &lt;&lt; endl;</code></pre>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c08-sec-0025">
      </span>
      <h3 id="head-3-180">
       <img alt="C++23" src="../images\images/icon1.png"/>
       Explicit Object Parameter
      </h3>
      <p>
       Starting with C++23, instead of relying on the compiler to provide an implicit
       <code>
        this
       </code>
       parameter, you can use an
       <i>
        explicit object parameter
       </i>
       , usually of a reference type. The following code snippet implements the
       <code>
        setValue()
       </code>
       member function of
       <code>
        SpreadsheetCell
       </code>
       from the previous section using an explicit object parameter:
      </p>
      <pre id="c08-code-0026"><code>void SpreadsheetCell::setValue(<b>this SpreadsheetCell&amp; self,</b> double value)</code>
<code>{</code>
<code>    <b>self.</b>m_value = value;</code>
<code>    printCell(<b>self</b>);</code>
<code>}</code></pre>
      <p id="c08-para-0067">
       <span aria-label="269" epub:type="pagebreak" id="Page_269" role="doc-pagebreak">
       </span>
       The first parameter of
       <code>
        setValue()
       </code>
       is now the explicit object parameter, usually called
       <code>
        self
       </code>
       , but you can use any name you want. The type of
       <code>
        self
       </code>
       is prefixed with the
       <code>
        this
       </code>
       keyword. This explicit object parameter must be the first parameter of the member function. Once you use an explicit object parameter, the function no longer has an implicitly defined
       <code>
        this
       </code>
       ; hence, in the body of
       <code>
        setValue()
       </code>
       , you now must explicitly use
       <code>
        self
       </code>
       to access anything from the
       <code>
        SpreadsheetCell
       </code>
       .
      </p>
      <p>
       Calling a member function that uses an explicit object parameter is no different than calling one with an implicit
       <code>
        this
       </code>
       parameter. Even though
       <code>
        setValue()
       </code>
       now specifies two parameters,
       <code>
        self
       </code>
       and
       <code>
        value
       </code>
       , you still call it by passing just a single argument, the
       <code>
        value
       </code>
       that you want to set:
      </p>
      <pre id="c08-code-0027"><code>SpreadsheetCell myCell;</code>
<code>myCell.setValue(6);</code></pre>
      <p>
       Using explicit object parameters as demonstrated in this section has no benefits at all, it even makes the code more verbose. However, they are useful in the following situations:
      </p>
      <ul class="check1" id="c08-list-0002">
       <li id="c08-li-0007">
        To provide a more explicit syntax for writing ref-qualified member functions, discussed in
        <a href="c09.xhtml">
         Chapter 9
        </a>
        .
       </li>
       <li id="c08-li-0008">
        For member function templates where the type of the explicit object parameter is a template type parameter. This can be useful to avoid code duplication when implementing
        <code>
         const
        </code>
        and non-
        <code>
         const
        </code>
        overloads of member functions and is discussed in
        <a href="c12.xhtml">
         Chapter 12
        </a>
        , “Writing Generic Code with Templates.”
       </li>
       <li id="c08-li-0009">
        To write recursive lambda expressions, explained in
        <a href="c19.xhtml">
         Chapter 19
        </a>
        , “Function Pointers, Function Objects, and Lambda Expressions.”
       </li>
      </ul>
     </section>
    </section>
    <section aria-labelledby="head-2-105">
     <span id="c08-sec-0026">
     </span>
     <h2 id="head-2-105">
      UNDERSTANDING OBJECT LIFE CYCLES
     </h2>
     <p id="c08-para-0070">
      The object life cycle involves three activities:
      <i>
       creation
      </i>
      ,
      <i>
       destruction
      </i>
      , and
      <i>
       assignment
      </i>
      . It is important to understand how and when objects are created, destroyed, and assigned, and how you can customize these behaviors.
     </p>
     <section>
      <span id="c08-sec-0027">
      </span>
      <h3 id="head-3-181">
       Object Creation
      </h3>
      <p>
       Objects are created at the point you declare them (if they're on the stack) or when you explicitly allocate space for them with a smart pointer,
       <code>
        new
       </code>
       , or
       <code>
        new[]
       </code>
       . When an object is created, all its embedded objects are also created. Here is an example:
      </p>
      <pre id="c08-code-0028"><code>import std;</code>
<code> </code>
<code>class MyClass</code>
<code>{</code>
<code>    private:</code>
<code>        std::string m_name;</code>
<code>};</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    MyClass obj;</code>
<code>}</code></pre>
      <p id="c08-para-0072">
       <span aria-label="270" epub:type="pagebreak" id="Page_270" role="doc-pagebreak">
       </span>
       The embedded
       <code>
        string
       </code>
       object is created at the point where the
       <code>
        MyClass
       </code>
       object is created in the
       <code>
        main()
       </code>
       function and is destroyed when its containing object is destroyed.
      </p>
      <p>
       It is often helpful to give variables initial values as you declare them, as so:
      </p>
      <pre id="c08-code-0029"><code>int x { 0 };</code></pre>
      <p>
       Similarly, you could give initial values to objects. You can provide this functionality by declaring and writing a special member function called a
       <i>
        constructor
       </i>
       , in which you can perform initialization work for the object. Whenever an object is created, one of its constructors is executed.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c08-para-0075">
          <b>
           NOTE
          </b>
          <i>
           C++ programmers sometimes call a constructor a ctor (pronounced “see-tor”)
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <section>
       <span id="c08-sec-0029">
       </span>
       <h4 id="head-4-152">
        Writing Constructors
       </h4>
       <p id="c08-para-0076">
        Syntactically, a constructor is specified by a member function name that is the same as the class name. A constructor never has a return type and may or may not have parameters. A constructor that can be called without any arguments is called a
        <i>
         default constructor
        </i>
        . This can be a constructor that does not have any parameters, or a constructor for which all parameters have default values. There are certain contexts in which you may have to provide a default constructor, and you will get compilation errors if you have not provided one. Default constructors are discussed later in this chapter.
       </p>
       <p>
        Here is a first attempt at adding a constructor to the
        <code>
         SpreadsheetCell
        </code>
        class:
       </p>
       <pre id="c08-code-0030"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>SpreadsheetCell(double initialValue);</b></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
       <p>
        Just as you must provide implementations for normal member functions, you must provide an implementation for the constructor:
       </p>
       <pre id="c08-code-0031"><code>SpreadsheetCell::SpreadsheetCell(double initialValue)</code>
<code>{</code>
<code>    setValue(initialValue);</code>
<code>}</code></pre>
       <p id="c08-para-0079">
        The
        <code>
         SpreadsheetCell
        </code>
        constructor is a member of the
        <code>
         SpreadsheetCell
        </code>
        class, so C++ requires the normal
        <code>
         SpreadsheetCell::
        </code>
        scope resolution before the constructor name. The constructor name itself is also
        <code>
         SpreadsheetCell
        </code>
        , so the code ends up with the funny-looking
        <code>
         SpreadsheetCell::SpreadsheetCell
        </code>
        . The implementation simply makes a call to
        <code>
         setValue()
        </code>
        .
       </p>
      </section>
      <section>
       <span id="c08-sec-0030">
       </span>
       <h4 id="head-4-153">
        Using Constructors
       </h4>
       <p id="c08-para-0080">
        Using the constructor creates an object and initializes its values. You can use constructors with both stack-based and free store-based allocation.
       </p>
       <span aria-label="271" epub:type="pagebreak" id="Page_271" role="doc-pagebreak">
       </span>
       <section>
        <span id="c08-sec-0031">
        </span>
        <h5 id="head-5-56">
         Constructors for Objects on the Stack
        </h5>
        <p>
         When you allocate a
         <code>
          SpreadsheetCell
         </code>
         object on the stack, you use the constructor like this:
        </p>
        <pre id="c08-code-0032"><code><b>SpreadsheetCell myCell(5), anotherCell(4);</b></code>
<code>println("cell 1: {}", myCell.getValue());</code>
<code>println("cell 2: {}", anotherCell.getValue());</code></pre>
        <p>
         Alternatively, you can use the uniform initialization syntax:
        </p>
        <pre id="c08-code-0033"><code><b>SpreadsheetCell myCell { 5 }, anotherCell { 4 };</b></code></pre>
        <p>
         Note that you do
         <i>
          not
         </i>
         call the
         <code>
          SpreadsheetCell
         </code>
         constructor explicitly. For example, do not do something as follows:
        </p>
        <pre id="c08-code-0034"><code>SpreadsheetCell myCell.SpreadsheetCell(5); <span class="color3">// WILL NOT COMPILE!</span></code></pre>
        <p>
         Similarly, you cannot call the constructor later. The following is also incorrect:
        </p>
        <pre id="c08-code-0035"><code>SpreadsheetCell myCell;</code>
<code>myCell.SpreadsheetCell(5); <span class="color3">// WILL NOT COMPILE!</span></code></pre>
       </section>
       <section>
        <span id="c08-sec-0032">
        </span>
        <h5 id="head-5-57">
         Constructors for Objects on the Free Store
        </h5>
        <p>
         When you dynamically allocate a
         <code>
          SpreadsheetCell
         </code>
         object, you use the constructor like this:
        </p>
        <pre id="c08-code-0036"><code>auto smartCellp { make_unique&lt;SpreadsheetCell&gt;(4) };</code>
<code><span class="color3">// … do something with the cell, no need to delete the smart pointer</span></code>
<code> </code>
<code><span class="color3">// Or with raw pointers, without smart pointers (not recommended)</span></code>
<code>SpreadsheetCell* myCellp { new SpreadsheetCell { 5 } };</code>
<code><span class="color3">// Or</span></code>
<code><span class="color3">// SpreadsheetCell* myCellp{ new SpreadsheetCell(5) };</span></code>
<code>SpreadsheetCell* anotherCellp { nullptr };</code>
<code>anotherCellp = new SpreadsheetCell { 4 };</code>
<code><span class="color3">// … do something with the cells</span></code>
<code>delete myCellp;            myCellp = nullptr;</code>
<code>delete anotherCellp;       anotherCellp = nullptr;</code></pre>
        <p id="c08-para-0086">
         Note that you can declare a pointer to a
         <code>
          SpreadsheetCell
         </code>
         object without calling the constructor immediately, which is different from objects on the stack, where the constructor is called at the point of declaration.
        </p>
        <p id="c08-para-0087">
         Remember to always initialize pointers, either with a proper pointer or with
         <code>
          nullptr
         </code>
         .
        </p>
       </section>
      </section>
      <section>
       <span id="c08-sec-0033">
       </span>
       <h4 id="head-4-154">
        Providing Multiple Constructors
       </h4>
       <p id="c08-para-0088">
        You can provide more than one constructor in a class. All constructors have the same name (the name of the class), but different constructors must take a different number of arguments or different argument types. In C++, if you have more than one function with the same name, the compiler selects the one whose parameter types match the types at the call site. This is called
        <i>
         overloading
        </i>
        and is discussed in detail in
        <a href="c09.xhtml">
         Chapter 9
        </a>
        .
       </p>
       <p>
        In the
        <code>
         SpreadsheetCell
        </code>
        class, it is helpful to have two constructors: one to take an initial
        <code>
         double
        </code>
        value and one to take an initial string value. Here is the new class definition:
       </p>
       <pre id="c08-code-0037"><code>export class SpreadsheetCell</code>
<code>{</code>
<span aria-label="272" epub:type="pagebreak" id="Page_272" role="doc-pagebreak"></span><code>    public:</code>
<code>        SpreadsheetCell(double initialValue);</code>
<code>        <b>SpreadsheetCell(std::string_view initialValue);</b></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
       <p>
        Here is the implementation of the second constructor:
       </p>
       <pre id="c08-code-0038"><code>SpreadsheetCell::SpreadsheetCell(string_view initialValue)</code>
<code>{</code>
<code>    setString(initialValue);</code>
<code>}</code></pre>
       <p>
        Here is some code that uses the two different constructors:
       </p>
       <pre id="c08-code-0039"><code>SpreadsheetCell aThirdCell { "test" };  <span class="color3">// Uses string-arg ctor</span></code>
<code>SpreadsheetCell aFourthCell { 4.4 };    <span class="color3">// Uses double-arg ctor</span></code>
<code>auto aFifthCellp { make_unique&lt;SpreadsheetCell&gt;("5.5") }; <span class="color3">// string-arg ctor</span></code>
<code>println("aThirdCell: {}", aThirdCell.getValue());</code>
<code>println("aFourthCell: {}", aFourthCell.getValue());</code>
<code>println("aFifthCellp: {}", aFifthCellp-&gt;getValue());</code></pre>
       <p>
        When you have multiple constructors, it is tempting to try to implement one constructor in terms of another. For example, you might want to call the double constructor from the string constructor as follows:
       </p>
       <pre id="c08-code-0040"><code>SpreadsheetCell::SpreadsheetCell(string_view initialValue)</code>
<code>{</code>
<code>    SpreadsheetCell(stringToDouble(initialValue));</code>
<code>}</code></pre>
       <p id="c08-para-0093">
        That seems to make sense. After all, you can call normal class member functions from within other member functions. The code will compile, link, and run, but will not do what you expect! The explicit call to the
        <code>
         SpreadsheetCell
        </code>
        constructor actually creates a new temporary unnamed object of type
        <code>
         SpreadsheetCell
        </code>
        . It does not call the constructor for the object that you are supposed to be initializing.
       </p>
       <p id="c08-para-0094">
        However, all is not lost. C++ does support
        <i>
         delegating constructors
        </i>
        . These allow you to call other constructors of the same class from inside the ctor-initializer, but for this, you'll have to wait until later in this chapter after the introduction of ctor-initializers.
       </p>
      </section>
      <section>
       <span id="c08-sec-0034">
       </span>
       <h4 id="head-4-155">
        Default Constructors
       </h4>
       <p id="c08-para-0095">
        A
        <i>
         default constructor
        </i>
        is a constructor that requires no arguments. It is also called a
        <i>
         zero-argument constructor
        </i>
        .
       </p>
       <section>
        <span id="c08-sec-0035">
        </span>
        <h5 id="head-5-58">
         When You Need a Default Constructor
        </h5>
        <p>
         Consider arrays of objects. The act of creating an array of objects accomplishes two tasks: it allocates contiguous memory space for all the objects, and it calls the default constructor on each object. C++ fails to provide any syntax to tell the array creation code directly to call a different constructor. For example, if you do not define a default constructor for the
         <code>
          SpreadsheetCell
         </code>
         class, the following code does not compile:
        </p>
        <pre id="c08-code-0041"><code>SpreadsheetCell cells[3]; <span class="color3">// FAILS compilation without default constructor</span></code>
<code>SpreadsheetCell* myCellp { new SpreadsheetCell[10] }; <span class="color3">// Also FAILS</span></code></pre>
        <p>
         <span aria-label="273" epub:type="pagebreak" id="Page_273" role="doc-pagebreak">
         </span>
         You can circumvent this restriction by using
         <i>
          initializers
         </i>
         like these:
        </p>
        <pre id="c08-code-0042"><code>SpreadsheetCell cells[3] { SpreadsheetCell { 0 }, SpreadsheetCell { 23 },</code>
<code>    SpreadsheetCell { 41 } };</code></pre>
        <p id="c08-para-0098">
         However, it is usually easier to ensure that your class has a default constructor if you intend to create arrays of objects of that class. If you haven't defined your own constructors, the compiler automatically creates a default constructor for you. This compiler-generated constructor is discussed in a later section.
        </p>
       </section>
       <section>
        <span id="c08-sec-0036">
        </span>
        <h5 id="head-5-59">
         How to Write a Default Constructor
        </h5>
        <p>
         Here is part of the
         <code>
          SpreadsheetCell
         </code>
         class definition with a default constructor:
        </p>
        <pre id="c08-code-0043"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>SpreadsheetCell();</b></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
        <p>
         Here is a first crack at an implementation of the default constructor:
        </p>
        <pre id="c08-code-0044"><code>SpreadsheetCell::SpreadsheetCell()</code>
<code>{</code>
<code>    m_value = 0;</code>
<code>}</code></pre>
        <p>
         If you use an in-class member initializer for
         <code>
          m_value
         </code>
         , then the single statement in this default constructor can be left out.
        </p>
        <pre id="c08-code-0045"><code>SpreadsheetCell::SpreadsheetCell()</code>
<code>{</code>
<code>}</code></pre>
        <p>
         You use the default constructor on the stack like this:
        </p>
        <pre id="c08-code-0046"><code><b>SpreadsheetCell myCell;</b></code>
<code>myCell.setValue(6);</code>
<code>println("cell 1: {}", myCell.getValue());</code></pre>
        <p>
         The preceding code creates a new
         <code>
          SpreadsheetCell
         </code>
         called
         <code>
          myCell
         </code>
         , sets its value, and prints out its value. Unlike other constructors for stack-based objects, you do not call the default constructor with function-call syntax. Based on the syntax for other constructors, you might be tempted to call the default constructor like this:
        </p>
        <pre id="c08-code-0047"><code><b>SpreadsheetCell myCell();</b> <span class="color3">// WRONG, but will compile.</span></code>
<code>myCell.setValue(6);       <span class="color3">// However, this line will not compile.</span></code>
<code>println("cell 1: {}", myCell.getValue());</code></pre>
        <p id="c08-para-0104">
         Unfortunately, the line attempting to call the default constructor compiles. The line following it does not compile. This problem is commonly known as the
         <i>
          most vexing parse
         </i>
         , and it means that your compiler thinks the first line is actually a function declaration for a function with the name
         <code>
          myCell
         </code>
         that takes zero arguments and returns a
         <code>
          SpreadsheetCell
         </code>
         object. When it gets to the second line, it thinks that you're trying to use a function name as an object!
        </p>
        <p>
         <span aria-label="274" epub:type="pagebreak" id="Page_274" role="doc-pagebreak">
         </span>
         Of course, instead of using function-call-style parentheses, you can use the uniform initialization syntax as follows:
        </p>
        <pre id="c08-code-0048"><code>SpreadsheetCell myCell { }; <span class="color3">// Calls the default constructor.</span></code></pre>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c08-para-0107">
            <b>
             WARNING
            </b>
            <i>
             When creating an object on the stack with a default constructor, either use curly brackets for the uniform initialization syntax or omit any parentheses
            </i>
            .
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         For free store-based object allocation, the default constructor can be used as follows:
        </p>
        <pre id="c08-code-0049"><code>auto smartCellp { make_unique&lt;SpreadsheetCell&gt;() };</code>
<code><span class="color3">// Or with a raw pointer (not recommended)</span></code>
<code>SpreadsheetCell* myCellp { new SpreadsheetCell { } };</code>
<code><span class="color3">// Or</span></code>
<code><span class="color3">// SpreadsheetCell* myCellp { new SpreadsheetCell };</span></code>
<code><span class="color3">// Or</span></code>
<code><span class="color3">// SpreadsheetCell* myCellp { new SpreadsheetCell() };</span></code>
<code><span class="color3">// … use myCellp</span></code>
<code>delete myCellp;    myCellp = nullptr;</code></pre>
       </section>
       <section>
        <span id="c08-sec-0038">
        </span>
        <h5 id="head-5-60">
         Compiler-Generated Default Constructor
        </h5>
        <p>
         The first
         <code>
          SpreadsheetCell
         </code>
         class definition in this chapter looked like this:
        </p>
        <pre id="c08-code-0050"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        void setValue(double value);</code>
<code>        double getValue() const;</code>
<code>    private:</code>
<code>        double m_value;</code>
<code>};</code></pre>
        <p>
         This definition does not declare a default constructor, but still, the code that follows works fine:
        </p>
        <pre id="c08-code-0051"><code>SpreadsheetCell myCell;</code>
<code>myCell.setValue(6);</code></pre>
        <p>
         The following definition is the same as the preceding definition except that it adds an explicit constructor, accepting a
         <code>
          double
         </code>
         . It still does not explicitly declare a default constructor.
        </p>
        <pre id="c08-code-0052"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>SpreadsheetCell(double initialValue);</b> <span class="color3">// No default constructor</span></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
        <p>
         With this definition, the following code does not compile anymore:
        </p>
        <pre id="c08-code-0053"><code>SpreadsheetCell myCell;</code>
<code>myCell.setValue(6);</code></pre>
        <p>
         <span aria-label="275" epub:type="pagebreak" id="Page_275" role="doc-pagebreak">
         </span>
         What's going on here? The reason it is not compiling is that if you don't specify
         <i>
          any
         </i>
         constructors, the compiler writes one for you that doesn't take any arguments. This
         <i>
          compiler-generated default constructor
         </i>
         calls the default constructor on all object members of the class but does not initialize the language primitives such as
         <code>
          int
         </code>
         and
         <code>
          double
         </code>
         . Nonetheless, it allows you to create objects of that class. However, if you declare any constructor yourself, the compiler no longer generates a default constructor for you.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c08-para-0114">
            <b>
             NOTE
            </b>
            <i>
             A default constructor is the same as a zero-argument constructor. The term default constructor does not refer only to the constructor that is automatically generated if you fail to declare any constructors yourself. It also refers to the constructor that is defaulted to if no arguments are required
            </i>
            .
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section>
        <span id="c08-sec-0040">
        </span>
        <h5 id="head-5-61">
         Explicitly Defaulted Default Constructors
        </h5>
        <p id="c08-para-0115">
         Before C++11, if your class required a number of explicit constructors accepting arguments but also a default constructor that did nothing, you still had to explicitly write your own empty default constructor as shown earlier.
        </p>
        <p>
         To avoid having to write empty default constructors manually, C++ supports the concept of
         <i>
          explicitly defaulted default constructors
         </i>
         . This allows you to write the class definition as follows without having to provide an empty implementation for the default constructor:
        </p>
        <pre id="c08-code-0054"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>SpreadsheetCell() = default;</b></code>
<code>        SpreadsheetCell(double initialValue);</code>
<code>        SpreadsheetCell(std::string_view initialValue);</code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
        <p id="c08-para-0117">
         <code>
          SpreadsheetCell
         </code>
         defines two custom constructors. However, the compiler still generates a standard compiler-generated default constructor because one is explicitly defaulted using the
         <code>
          default
         </code>
         keyword. You are free to put the
         <code>
          = default
         </code>
         either directly in the class definition or in an implementation file.
        </p>
       </section>
       <section>
        <span id="c08-sec-0041">
        </span>
        <h5 id="head-5-62">
         Explicitly Deleted Default Constructors
        </h5>
        <p>
         The opposite of explicitly defaulted default constructors is also possible and is called
         <i>
          explicitly deleted default constructors
         </i>
         . For example, you can define a class with only static member functions (see
         <a href="c09.xhtml">
          Chapter 9
         </a>
         ) for which you do not want to write any constructors, and you also do not want the compiler to generate the default constructor. In that case, you need to explicitly delete the default constructor.
        </p>
        <pre id="c08-code-0055"><code>export class MyClass</code>
<code>{</code>
<code>    public:</code>
<code>        MyClass() = delete;</code>
<code>};</code></pre>
        <p>
         <span aria-label="276" epub:type="pagebreak" id="Page_276" role="doc-pagebreak">
         </span>
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c08-para-0120">
            <b>
             NOTE
            </b>
            <i>
             If a class has data members that have a deleted default constructor, then the default constructor for the class is automatically deleted as well
            </i>
            .
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section>
       <span id="c08-sec-0043">
       </span>
       <h4 id="head-4-156">
        Constructor Initializers aka Ctor-Initializers
       </h4>
       <p>
        Up to now, this chapter initialized data members in the body of a constructor, as in this example:
       </p>
       <pre id="c08-code-0056"><code>SpreadsheetCell::SpreadsheetCell(double initialValue)</code>
<code>{</code>
<code>    setValue(initialValue);</code>
<code>}</code></pre>
       <p>
        C++ provides an alternative method for initializing data members in the constructor, called the
        <i>
         constructor initializer
        </i>
        , also known as the
        <i>
         ctor-initializer
        </i>
        or
        <i>
         member initializer list
        </i>
        . Here is the same
        <code>
         SpreadsheetCell
        </code>
        constructor, rewritten to use the ctor-initializer syntax:
       </p>
       <pre id="c08-code-0057"><code>SpreadsheetCell::SpreadsheetCell(double initialValue)</code>
<code>    <b>: m_value { initialValue }</b></code>
<code>{</code>
<code>}</code></pre>
       <p id="c08-para-0123">
        As you can see, the ctor-initializer appears syntactically between the constructor parameter list and the opening brace for the body of the constructor. The list starts with a colon and is separated by commas. Each element in the list is an initialization of a data member using function notation or the uniform initialization syntax, a call to a base class constructor (see
        <a href="c10.xhtml">
         Chapter 10
        </a>
        ), or a call to a delegated constructor, discussed later in this chapter.
       </p>
       <p id="c08-para-0124">
        Initializing data members with a ctor-initializer provides different behavior than does initializing data members inside the constructor body itself. When C++ creates an object, it must create all the data members of the object before calling the constructor. As part of creating these data members, it must call a constructor on any of them that are themselves objects. By the time you assign a value to an object inside your constructor body, you are not actually constructing that object. You are only modifying its value. A ctor-initializer allows you to provide initial values for data members as they are created, which is more efficient than assigning values to them later.
       </p>
       <p id="c08-para-0125">
        If your class has as data member an object of a class that has a default constructor, then you do not have to explicitly initialize that object in the ctor-initializer. For example, if you have an
        <code>
         std::string
        </code>
        as data member, its default constructor initializes the string to the empty string, so initializing it to
        <code>
         ""
        </code>
        in the ctor-initializer is superfluous.
       </p>
       <p>
        On the other hand, if your class has as a data member an object of a class without a default constructor, you must use the ctor-initializer to properly construct that object. For example, take the following
        <code>
         SpreadsheetCell
        </code>
        class:
       </p>
       <pre id="c08-code-0058"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        SpreadsheetCell(double d);</code>
<code>};</code></pre>
       <p>
        <span aria-label="277" epub:type="pagebreak" id="Page_277" role="doc-pagebreak">
        </span>
        This class has only one constructor accepting a
        <code>
         double
        </code>
        and does not include a default constructor. You can use this class as a data member of another class as follows:
       </p>
       <pre id="c08-code-0059"><code>class SomeClass</code>
<code>{</code>
<code>    public:</code>
<code>        SomeClass();</code>
<code>    private:</code>
<code>        SpreadsheetCell m_cell;</code>
<code>};</code></pre>
       <p>
        You can implement the
        <code>
         SomeClass
        </code>
        constructor as follows:
       </p>
       <pre id="c08-code-0060"><code>SomeClass::SomeClass() { }</code></pre>
       <p id="c08-para-0129">
        However, with this implementation, the code does not compile. The compiler does not know how to initialize the
        <code>
         m_cell
        </code>
        data member of
        <code>
         SomeClass
        </code>
        because it does not have a default constructor.
       </p>
       <p>
        You must initialize the
        <code>
         m_cell
        </code>
        data member in the ctor-initializer as follows:
       </p>
       <pre id="c08-code-0061"><code>SomeClass::SomeClass() : m_cell { 1.0 } { }</code></pre>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0132">
           <b>
            NOTE
           </b>
           <i>
            Ctor-initializers allow initialization of data members at the time of their creation
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c08-para-0134">
        Some programmers prefer to assign initial values in the body of the constructor, even though this might be less efficient. However, several data types must be initialized in a ctor-initializer or with an in-class initializer. The following table summarizes them:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           DATA TYPE
          </th>
          <th class="left bgcolor2" scope="col">
           EXPLANATION
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            const
           </code>
           data members
          </td>
          <td class="left bor1 bgcolor3">
           You cannot legally assign a value to a
           <code>
            const
           </code>
           variable after it is created. Any value must be supplied at the time of creation.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           Reference data members
          </td>
          <td class="left bor1 bgcolor3">
           References cannot exist without referring to something, and once created, a reference cannot be changed to refer to something else.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           Object data members for which there is no default constructor
          </td>
          <td class="left bor1 bgcolor3">
           C++ attempts to initialize member objects using a default constructor. If no default constructor exists, it cannot initialize the object, and you must tell it explicitly which constructor to call.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           Base classes without default constructors
          </td>
          <td class="left bor1 bgcolor3">
           These are covered in
           <a href="c10.xhtml">
            Chapter 10
           </a>
           .
          </td>
         </tr>
        </tbody>
       </table>
       <p>
        There is one important caveat with ctor-initializers: they initialize data members in the order that they appear in the class definition, not their order in the ctor-initializer! Take the following definition for a class called
        <code>
         Foo
        </code>
        . Its constructor simply stores a
        <code>
         double
        </code>
        value and prints out the value to the console.
       </p>
       <pre id="c08-code-0062"><span aria-label="278" epub:type="pagebreak" id="Page_278" role="doc-pagebreak"></span><code>class Foo</code>
<code>{</code>
<code>    public:</code>
<code>        Foo(double value);</code>
<code>    private:</code>
<code>        double m_value { 0 };</code>
<code>};</code>
<code> </code>
<code>Foo::Foo(double value) : m_value { value }</code>
<code>{</code>
<code>    println("Foo::m_value = {}", m_value);</code>
<code>}</code></pre>
       <p>
        Suppose you have another class,
        <code>
         MyClass
        </code>
        , that contains a
        <code>
         Foo
        </code>
        object as one of its data members.
       </p>
       <pre id="c08-code-0063"><code>class MyClass</code>
<code>{</code>
<code>    public:</code>
<code>        MyClass(double value);</code>
<code>    private:</code>
<code>        double m_value { 0 };</code>
<code>        Foo m_foo;</code>
<code>};</code></pre>
       <p>
        Its constructor could be implemented as follows:
       </p>
       <pre id="c08-code-0064"><code>MyClass::MyClass(double value) : m_value { value }, m_foo { m_value }</code>
<code>{</code>
<code>    println("MyClass::m_value = {}", m_value);</code>
<code>}</code></pre>
       <p>
        The ctor-initializer first stores the given
        <code>
         value
        </code>
        in
        <code>
         m_value
        </code>
        and then calls the
        <code>
         Foo
        </code>
        constructor with
        <code>
         m_value
        </code>
        as argument. You can create an instance of
        <code>
         MyClass
        </code>
        as follows:
       </p>
       <pre id="c08-code-0065"><code>MyClass instance { 1.2 };</code></pre>
       <p>
        Here is the output of the program:
       </p>
       <pre id="c08-code-0066"><code>Foo::m_value = 1.2</code>
<code>MyClass::m_value = 1.2</code></pre>
       <p>
        So, everything looks fine. Now make one tiny change to the
        <code>
         MyClass
        </code>
        definition; just reverse the order of the
        <code>
         m_value
        </code>
        and
        <code>
         m_foo
        </code>
        data members. Nothing else is changed.
       </p>
       <pre id="c08-code-0067"><code>class MyClass</code>
<code>{</code>
<code>    public:</code>
<code>        MyClass(double value);</code>
<code>    private:</code>
<code>        <b>Foo m_foo;</b></code>
<code>        <b>double m_value { 0 };</b></code>
<code>};</code></pre>
       <p>
        The output of the program now depends on your system. It could, for example, be as follows:
       </p>
       <pre id="c08-code-0068"><code>Foo::m_value = -9.255963134931783e+61</code>
<code>MyClass::m_value = 1.2</code></pre>
       <p id="c08-para-0143">
        <span aria-label="279" epub:type="pagebreak" id="Page_279" role="doc-pagebreak">
        </span>
        This is far from what you expected. You might assume, based on your ctor-initializer, that
        <code>
         m_value
        </code>
        is initialized before using
        <code>
         m_value
        </code>
        in the call to the
        <code>
         Foo
        </code>
        constructor. But C++ doesn't work that way. The data members are initialized in the order they appear in the definition of the class, not the order in the ctor-initializer! So, in this case, the
        <code>
         Foo
        </code>
        constructor is called first with an uninitialized
        <code>
         m_value
        </code>
        .
       </p>
       <p id="c08-para-0144">
        Note that some compilers issue a warning when the order in the ctor-initializer does not match the order in the class definition.
       </p>
       <p>
        For this example, there is an easy fix. Don't pass
        <code>
         m_value
        </code>
        to the
        <code>
         Foo
        </code>
        constructor, but simply pass the
        <code>
         value
        </code>
        parameter:
       </p>
       <pre id="c08-code-0069"><code>MyClass::MyClass(double value) : m_value { value }, m_foo { <b>value</b> }</code>
<code>{</code>
<code>    println("MyClass::m_value = {}", m_value);</code>
<code>}</code></pre>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0147">
           <b>
            WARNING
           </b>
           <i>
            Ctor-initializers initialize data members in their declared order in the class definition, not their order in the ctor-initializer list
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c08-sec-0046">
       </span>
       <h4 id="head-4-157">
        Copy Constructors
       </h4>
       <p>
        There is a special constructor in C++ called a
        <i>
         copy constructor
        </i>
        that allows you to create an object that is an exact copy of another object. Here is the declaration for a copy constructor in the
        <code>
         SpreadsheetCell
        </code>
        class:
       </p>
       <pre id="c08-code-0070"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>SpreadsheetCell(const SpreadsheetCell&amp; src);</b></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
       <p>
        The copy constructor takes a reference-to-
        <code>
         const
        </code>
        to the source object. Like other constructors, it does not return a value. The copy constructor should copy all the data members from the source object. Technically, of course, you can do whatever you want in a copy constructor, but it's generally a good idea to follow expected behavior and initialize the new object to be a copy of the old one. Here is an example implementation of the
        <code>
         SpreadsheetCell
        </code>
        copy constructor. Note the use of the ctor-initializer.
       </p>
       <pre id="c08-code-0071"><code>SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell&amp; src)</code>
<code>    : m_value { src.m_value }</code>
<code>{</code>
<code>}</code></pre>
       <p>
        If you don't write a copy constructor yourself, C++ generates one for you that initializes each data member in the new object from its equivalent data member in the source object. For object data members, this initialization means that their copy constructors are called. Given a set of data members, called
        <code>
         m1
        </code>
        ,
        <code>
         m2
        </code>
        , …
        <code>
         mn
        </code>
        , this compiler-generated copy constructor can be expressed as follows:
       </p>
       <pre id="c08-code-0072"><code>classname::classname(const classname&amp; src)</code>
<code>    : m1 { src.m1 }, m2 { src.m2 }, … mn { src.mn } { }</code></pre>
       <p>
        <span aria-label="280" epub:type="pagebreak" id="Page_280" role="doc-pagebreak">
        </span>
        Therefore, in most circumstances, there is no need for you to specify a copy constructor!
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0152">
           <b>
            NOTE
           </b>
           <i>
            The
           </i>
           <code>
            SpreadsheetCell
           </code>
           <i>
            copy constructor is shown only for demonstration purposes. In fact, in this case, the copy constructor can be omitted because the default compiler-generated one is good enough. However, under certain conditions, this compiler-generated copy constructor is not sufficient. These conditions are covered in
            <a href="c09.xhtml">
             Chapter 9
            </a>
            .
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <section>
        <span id="c08-sec-0048">
        </span>
        <h5 id="head-5-63">
         When the Copy Constructor Is Called
        </h5>
        <p>
         The default semantics for passing arguments to functions in C++ is pass-by-value. That means that the function receives a copy of the value or object. Thus, whenever you pass an object to a function, the compiler calls the copy constructor of the new object to initialize it. For example, suppose you have the following
         <code>
          printString()
         </code>
         function accepting an
         <code>
          std::string
         </code>
         parameter by value:
        </p>
        <pre id="c08-code-0073"><code>void printString(string value)</code>
<code>{</code>
<code>    println("{}", value);</code>
<code>}</code></pre>
        <p>
         Recall that
         <code>
          std::string
         </code>
         is actually a class, not a built-in type. When your code makes a call to
         <code>
          printString()
         </code>
         passing a
         <code>
          string
         </code>
         argument, the
         <code>
          string
         </code>
         parameter
         <code>
          value
         </code>
         is initialized with a call to its copy constructor. The argument to the copy constructor is the
         <code>
          string
         </code>
         you passed to
         <code>
          printString()
         </code>
         . In the following example, the
         <code>
          string
         </code>
         copy constructor is executed for the
         <code>
          value
         </code>
         object in
         <code>
          printString()
         </code>
         with
         <code>
          name
         </code>
         as its argument:
        </p>
        <pre id="c08-code-0074"><code>string name { "heading one" };</code>
<code>printString(name); <span class="color3">// Copies name</span></code></pre>
        <p id="c08-para-0155">
         When the
         <code>
          printString()
         </code>
         member function finishes,
         <code>
          value
         </code>
         is destroyed. Because it was only a copy of
         <code>
          name
         </code>
         ,
         <code>
          name
         </code>
         remains intact. Of course, you can avoid the overhead of copy constructors by passing parameters as references-to-
         <code>
          const
         </code>
         , discussed in an upcoming section.
        </p>
        <p id="c08-para-0156">
         When returning objects by value from a function, the copy constructor might also get called. This is discussed in the section “
         <a href="#c08-sec-0073">
          Objects as Return Values
         </a>
         ” later in this chapter.
        </p>
       </section>
       <section>
        <span id="c08-sec-0049">
        </span>
        <h5 id="head-5-64">
         Calling the Copy Constructor Explicitly
        </h5>
        <p>
         You can use the copy constructor explicitly as well. It is often useful to be able to construct one object as an exact copy of another. For example, you might want to create a copy of a
         <code>
          SpreadsheetCell
         </code>
         object like this:
        </p>
        <pre id="c08-code-0075"><code>SpreadsheetCell myCell1 { 4 };</code>
<code><b>SpreadsheetCell myCell2 { myCell1 };</b> <span class="color3">// myCell2 has the same values as myCell1</span></code></pre>
       </section>
       <section>
        <span id="c08-sec-0050">
        </span>
        <h5 id="head-5-65">
         Passing Objects by Reference
        </h5>
        <p id="c08-para-0158">
         To avoid copying objects when you pass them to functions, you should declare that the function takes a
         <i>
          reference
         </i>
         to the object. Passing objects by reference is usually more efficient than passing them by value, because only the address of the object is copied, not the entire contents of the object.
         <span aria-label="281" epub:type="pagebreak" id="Page_281" role="doc-pagebreak">
         </span>
         Additionally, pass-by-reference avoids problems with dynamic memory allocation in objects, which is discussed in
         <a href="c09.xhtml">
          Chapter 9
         </a>
         .
        </p>
        <p>
         When you pass an object by reference, the function using the object reference could change the original object. When you are only using pass-by-reference for efficiency, you should preclude this possibility by declaring the object
         <code>
          const
         </code>
         as well. This is known as passing objects by reference-to-
         <code>
          const
         </code>
         and has been done in examples throughout this book.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c08-para-0160">
            <b>
             NOTE
            </b>
            <i>
             For performance reasons, it is best to pass objects by reference-to-
            </i>
            <code>
             const
            </code>
            <i>
             instead of by value.
             <a href="c09.xhtml">
              Chapter 9
             </a>
             slightly modifies this rule after the introduction of move semantics, allowing pass-by-value of objects in certain cases.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c08-para-0161">
         Note that the
         <code>
          SpreadsheetCell
         </code>
         class has a number of member functions accepting an
         <code>
          std::string_view
         </code>
         as parameter. As discussed in
         <a href="c02.xhtml">
          Chapter 2
         </a>
         , a
         <code>
          string_view
         </code>
         is basically just a pointer and a length. So, it is cheap to copy and is usually passed by value.
        </p>
        <p id="c08-para-0162">
         Also primitive types, such as
         <code>
          int
         </code>
         ,
         <code>
          double
         </code>
         , and so on, should just be passed by value. You don't gain anything by passing such types as reference-to-
         <code>
          const
         </code>
         .
        </p>
        <p id="c08-para-0163">
         The
         <code>
          doubleToString()
         </code>
         member function of the
         <code>
          SpreadsheetCell
         </code>
         class always returns a
         <code>
          string
         </code>
         by value because the implementation of the member function creates a local
         <code>
          string
         </code>
         object that at the end of the member function is returned to the caller. Returning a reference to this
         <code>
          string
         </code>
         wouldn't work because the
         <code>
          string
         </code>
         to which it refers to will be destroyed when the function exits.
        </p>
       </section>
       <section>
        <span id="c08-sec-0052">
        </span>
        <h5 id="head-5-66">
         Explicitly Defaulted and Deleted Copy Constructors
        </h5>
        <p>
         Just as you can explicitly default or delete a compiler-generated default constructor for a class, you can also explicitly default or delete a compiler-generated copy constructor as follows:
        </p>
        <pre id="c08-code-0076"><code>SpreadsheetCell(const SpreadsheetCell&amp; src) = default;</code></pre>
        <p>
         or
        </p>
        <pre id="c08-code-0077"><code>SpreadsheetCell(const SpreadsheetCell&amp; src) = delete;</code></pre>
        <p>
         By deleting the copy constructor, the object cannot be copied anymore. This can be used to disallow passing the object by value, as discussed in
         <a href="c09.xhtml">
          Chapter 9
         </a>
         .
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c08-para-0167">
            <b>
             NOTE
            </b>
            <i>
             If a class has data members that have a deleted or
            </i>
            <code>
             private
            </code>
            <i>
             copy constructor, then the copy constructor for the class is automatically deleted as well, even if you explicitly
            </i>
            <code>
             default
            </code>
            <i>
             one.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section>
       <span id="c08-sec-0054">
       </span>
       <h4 id="head-4-158">
        Initializer-List Constructors
       </h4>
       <p>
        An
        <i>
         initializer-list constructor
        </i>
        is a constructor with an
        <code>
         std::initializer_list&lt;T&gt;
        </code>
        (see
        <a href="c01.xhtml">
         Chapter 1
        </a>
        ) as the first parameter and without any additional parameters or with additional parameters having
        <span aria-label="282" epub:type="pagebreak" id="Page_282" role="doc-pagebreak">
        </span>
        default values. The
        <code>
         initializer_list&lt;T&gt;
        </code>
        class template is defined in
        <code>
         &lt;initializer_list&gt;
        </code>
        . The following class demonstrates its use. The class accepts only an
        <code>
         initializer_list&lt;double&gt;
        </code>
        with an even number of elements; otherwise, it throws an exception.
        <a href="c01.xhtml">
         Chapter 1
        </a>
        introduces exceptions.
       </p>
       <pre id="c08-code-0078"><code>class EvenSequence</code>
<code>{</code>
<code>    public:</code>
<code>        EvenSequence(initializer_list&lt;double&gt; values)</code>
<code>        {</code>
<code>            if (values.size() % 2 != 0) {</code>
<code>                throw invalid_argument { "initializer_list should "</code>
<code>                    "contain even number of elements." };</code>
<code>            }</code>
<code>            m_sequence.reserve(values.size());</code>
<code>            for (const auto&amp; value : values) {</code>
<code>                m_sequence.push_back(value);</code>
<code>            }</code>
<code>        }</code>
<code> </code>
<code>        void print() const</code>
<code>        {</code>
<code>            for (const auto&amp; value : m_sequence) {</code>
<code>                std::print("{}, ", value);</code>
<code>            }</code>
<code>            println("");</code>
<code>        }</code>
<code>    private:</code>
<code>        vector&lt;double&gt; m_sequence;</code>
<code>};</code></pre>
       <p id="c08-para-0169">
        Inside the initializer-list constructor you can access the elements of the initializer-list with a range-based
        <code>
         for
        </code>
        loop. You can get the number of elements in an initializer-list with the
        <code>
         size()
        </code>
        member function.
       </p>
       <p>
        The
        <code>
         EvenSequence
        </code>
        initializer-list constructor uses a range-based
        <code>
         for
        </code>
        loop to copy elements from the given
        <code>
         initializer_list&lt;T&gt;
        </code>
        . You can also use the
        <code>
         assign()
        </code>
        member function of
        <code>
         vector
        </code>
        . The different member functions of
        <code>
         vector
        </code>
        , including
        <code>
         assign()
        </code>
        , are discussed in detail in
        <a href="c18.xhtml">
         Chapter 18
        </a>
        , “Standard Library Containers.” As a sneak preview, to give you an idea of the power of a
        <code>
         vector
        </code>
        , here is the initializer-list constructor using
        <code>
         assign()
        </code>
        :
       </p>
       <pre id="c08-code-0079"><code>EvenSequence(initializer_list&lt;double&gt; values)</code>
<code>{</code>
<code>    if (values.size() % 2 != 0) {</code>
<code>        throw invalid_argument { "initializer_list should "</code>
<code>            "contain even number of elements." };</code>
<code>    }</code>
<code>    <b>m_sequence.assign(values);</b></code>
<code>}</code></pre>
       <p>
        <code>
         EvenSequence
        </code>
        objects can be constructed as follows:
       </p>
       <pre id="c08-code-0080"><code>try {</code>
<code>    EvenSequence p1 { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 };</code>
<code>    p1.print();</code>
<code> </code>
<span aria-label="283" epub:type="pagebreak" id="Page_283" role="doc-pagebreak"></span><code>    EvenSequence p2 { 1.0, 2.0, 3.0 };</code>
<code>} catch (const invalid_argument&amp; e) {</code>
<code>    println("{}", e.what());</code>
<code>}</code></pre>
       <p id="c08-para-0172">
        The construction of
        <code>
         p2
        </code>
        throws an exception because it has an odd number of elements in the initializer-list.
       </p>
       <p>
        The Standard Library has full support for initializer-list constructors. For example, the
        <code>
         std::vector
        </code>
        container can be initialized with an initializer-list:
       </p>
       <pre id="c08-code-0081"><code>vector&lt;string&gt; myVec { "String 1", "String 2", "String 3" };</code></pre>
       <p>
        Without initializer-list constructors, one way to initialize this
        <code>
         vector
        </code>
        is by using several
        <code>
         push_back()
        </code>
        calls:
       </p>
       <pre id="c08-code-0082"><code>vector&lt;string&gt; myVec;</code>
<code>myVec.push_back("String 1");</code>
<code>myVec.push_back("String 2");</code>
<code>myVec.push_back("String 3");</code></pre>
       <p>
        Initializer lists are not limited to constructors and can also be used with normal functions as explained in
        <a href="c01.xhtml">
         Chapter 1
        </a>
        .
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p>
           <b>
            NOTE
           </b>
           <i>
            When a class has both an initializer-list constructor and another single-argument constructor, then you should be careful to call the correct one. For example,
           </i>
           <code>
            std::vector
           </code>
           <i>
            has an initializer-list constructor to initialize a
           </i>
           <code>
            vector
           </code>
           <i>
            with a given set of elements. It also has a constructor accepting a single argument, the desired size of the new
           </i>
           <code>
            vector
           </code>
           <i>
            . You call the initializer-list constructor using a braced initializer,
           </i>
           <code>
            {}
           </code>
           <i>
            , and call the other single-argument constructor using parentheses,
           </i>
           <code>
            ()
           </code>
           <i>
            . For example:
           </i>
          </p>
          <pre id="c08-code-0083"><code>vector&lt;int&gt; v1 { 6 }; <span class="color3">// Constructs a vector with a single element, 6.</span></code>
<code>vector&lt;int&gt; v2 ( 6 ); <span class="color3">// Constructs a vector with 6 default-</span></code>
<code>                      <span class="color3">// initialized elements.</span></code></pre>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c08-sec-0056">
       </span>
       <h4 id="head-4-159">
        Delegating Constructors
       </h4>
       <p>
        <i>
         Delegating constructors
        </i>
        allow constructors to call another constructor from the same class. However, this call cannot be placed in the constructor body; it must be in the ctor-initializer, and it must be the only member-initializer in the list. The following is an example:
       </p>
       <pre id="c08-code-0084"><code>SpreadsheetCell::SpreadsheetCell(string_view initialValue)</code>
<code>    <b>: SpreadsheetCell { stringToDouble(initialValue) }</b></code>
<code>{</code>
<code>}</code></pre>
       <p id="c08-para-0179">
        When this
        <code>
         string_view
        </code>
        constructor (the delegating constructor) is called, it first delegates the call to the target constructor, which is the
        <code>
         double
        </code>
        constructor in this example. When the target constructor returns, the body of the delegating constructor is executed.
       </p>
       <p>
        <span aria-label="284" epub:type="pagebreak" id="Page_284" role="doc-pagebreak">
        </span>
        Make sure you avoid constructor recursion while using delegating constructors. Here is an example:
       </p>
       <pre id="c08-code-0085"><code>class MyClass</code>
<code>{</code>
<code>    MyClass(char c) : MyClass { 1.2 } { }</code>
<code>    MyClass(double d) : MyClass { 'm' } { }</code>
<code>};</code></pre>
       <p id="c08-para-0181">
        The first constructor delegates to the second constructor, which delegating back to the first one. The behavior of such code is undefined by the standard and depends on your compiler.
       </p>
      </section>
      <section>
       <span id="c08-sec-0057">
       </span>
       <h4 id="head-4-160">
        Converting Constructors and Explicit Constructors
       </h4>
       <p>
        The current set of constructors for
        <code>
         SpreadsheetCell
        </code>
        is as follows:
       </p>
       <pre id="c08-code-0086"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        SpreadsheetCell() = default;</code>
<code>        SpreadsheetCell(double initialValue);</code>
<code>        SpreadsheetCell(std::string_view initialValue);</code>
<code>        SpreadsheetCell(const SpreadsheetCell&amp; src);</code>
<code>    <span class="color3">// Remainder omitted for brevity</span></code>
<code>};</code></pre>
       <p>
        The single-parameter
        <code>
         double
        </code>
        and
        <code>
         string_view
        </code>
        constructors can be used to convert a
        <code>
         double
        </code>
        or a
        <code>
         string_view
        </code>
        into a
        <code>
         SpreadsheetCell
        </code>
        . Such constructors are called
        <i>
         converting constructors
        </i>
        . The compiler can use such constructors to perform implicit conversions for you. Here's an example:
       </p>
       <pre id="c08-code-0087"><code>SpreadsheetCell myCell { 4 };</code>
<code>myCell = 5;</code>
<code>myCell = "6"sv; <span class="color3">// A string_view literal (see <a href="c02.xhtml">Chapter 2</a>).</span></code></pre>
       <p>
        This might not always be the behavior you want. You can prevent the compiler from doing such implicit conversions by marking constructors as
        <code>
         explicit
        </code>
        . The
        <code>
         explicit
        </code>
        keyword goes only in the class definition. Here's an example:
       </p>
       <pre id="c08-code-0088"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        SpreadsheetCell() = default;</code>
<code>        SpreadsheetCell(double initialValue);</code>
<code>        <b>explicit SpreadsheetCell(std::string_view initialValue);</b></code>
<code>        SpreadsheetCell(const SpreadsheetCell&amp; src);</code>
<code>    <span class="color3">// Remainder omitted for brevity</span></code>
<code>};</code></pre>
       <p>
        With this change, a line as follows no longer compiles:
       </p>
       <pre id="c08-code-0089"><code>myCell = "6"sv; <span class="color3">// A string_view literal (see <a href="c02.xhtml">Chapter 2</a>).</span></code></pre>
       <p>
        Prior to C++11, converting constructors could have only a single parameter, as in the
        <code>
         SpreadsheetCell
        </code>
        example. Since C++11, converting constructors can have multiple parameters because of support for list initialization. Let's look at an example. Suppose you have the following class:
       </p>
       <pre id="c08-code-0090"><code>class MyClass</code>
<code>{</code>
<span aria-label="285" epub:type="pagebreak" id="Page_285" role="doc-pagebreak"></span><code>    public:</code>
<code>        MyClass(int) { }</code>
<code>        MyClass(int, int) { }</code>
<code>};</code></pre>
       <p>
        This class has two constructors, and since C++11, both are converting constructors. The following example shows that the compiler automatically converts arguments such as
        <code>
         1
        </code>
        ,
        <code>
         {1}
        </code>
        , and
        <code>
         {1,2}
        </code>
        , to instances of
        <code>
         MyClass
        </code>
        using these converting constructors:
       </p>
       <pre id="c08-code-0091"><code>void process(const MyClass&amp; c) { }</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    process(1);</code>
<code>    process({ 1 });</code>
<code>    process({ 1, 2 });</code>
<code>}</code></pre>
       <p>
        To prevent these implicit conversions, both converting constructors can be marked as
        <code>
         explicit
        </code>
        :
       </p>
       <pre id="c08-code-0092"><code>class MyClass</code>
<code>{</code>
<code>    public:</code>
<code>        <b>explicit</b> MyClass(int) { }</code>
<code>        <b>explicit</b> MyClass(int, int) { }</code>
<code>};</code></pre>
       <p>
        With this change, you have to perform these conversions explicitly; here's an example:
       </p>
       <pre id="c08-code-0093"><code>process(<b>MyClass</b>{ 1 });</code>
<code>process(<b>MyClass</b>{ 1, 2 });</code></pre>
       <p>
        It is possible to pass a Boolean argument to
        <code>
         explicit
        </code>
        to turn it into a conditional
        <code>
         explicit
        </code>
        . The syntax is as follows:
       </p>
       <pre id="c08-code-0094"><code><b>explicit(true)</b> MyClass(int);</code></pre>
       <p>
        Of course, just writing
        <code>
         explicit(true)
        </code>
        is equivalent to
        <code>
         explicit
        </code>
        , but it becomes more useful in the context of generic template code using type traits. With type traits you can query certain properties of given types, such as whether a certain type is convertible to another type. The result of such a type trait can be used as argument to
        <code>
         explicit()
        </code>
        . Type traits allow for writing advanced generic code and are discussed in
        <a href="c26.xhtml">
         Chapter 26
        </a>
        , “Advanced Templates.”
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0192">
           <b>
            NOTE
           </b>
           <i>
            It is recommended to mark at least any constructor that can be called with a single argument as
           </i>
           <code>
            explicit
           </code>
           <i>
            to avoid accidental implicit conversions. If there is a real use case for implicit conversions, you can mark the constructor with
           </i>
           <code>
            explicit(false)
           </code>
           <i>
            . Doing so explains to users of your class that the implicit conversion is consciously allowed
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c08-sec-0059">
       </span>
       <h4 id="head-4-161">
        Summary of Compiler-Generated Constructors
       </h4>
       <p id="c08-para-0193">
        The compiler can automatically generate a default constructor and a copy constructor for every class. However, the constructors that the compiler automatically generates depend on the constructors that you define yourself according to the rules in the following table:
       </p>
       <p>
        <span aria-label="286" epub:type="pagebreak" id="Page_286" role="doc-pagebreak">
        </span>
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           IF YOU DEFINE…
          </th>
          <th class="left bgcolor2" scope="col">
           THEN THE COMPILER GENERATES…
          </th>
          <th class="left bgcolor2" scope="col">
           AND YOU CAN CREATE AN OBJECT…
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           [no constructors]
          </td>
          <td class="left bor1 bgcolor3">
           A default constructor
           <br/>
           A copy constructor
          </td>
          <td class="left bor1 bgcolor3">
           With no arguments:
           <code>
            SpreadsheetCell a;
           </code>
           As a copy:
           <code>
            SpreadsheetCell b{a};
           </code>
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           A default constructor only
          </td>
          <td class="left bor1 bgcolor3">
           A copy constructor
          </td>
          <td class="left bor1 bgcolor3">
           With no arguments:
           <code>
            SpreadsheetCell a;
           </code>
           As a copy:
           <code>
            SpreadsheetCell b{a};
           </code>
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           A copy constructor only
          </td>
          <td class="left bor1 bgcolor3">
           No constructors
          </td>
          <td class="left bor1 bgcolor3">
           Theoretically, as a copy of another object (practically, you can't create any objects, because there are no non-copy constructors)
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           A single- or multi-argument non-copy constructor only
          </td>
          <td class="left bor1 bgcolor3">
           A copy constructor
          </td>
          <td class="left bor1 bgcolor3">
           With arguments:
           <code>
            SpreadsheetCell a{6};
           </code>
           As a copy:
           <code>
            SpreadsheetCell b{a};
           </code>
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           A default constructor as well as a single- or multi-argument non-copy constructor
          </td>
          <td class="left bor1 bgcolor3">
           A copy constructor
          </td>
          <td class="left bor1 bgcolor3">
           With no arguments:
           <code>
            SpreadsheetCell a;
           </code>
           With arguments:
           <code>
            SpreadsheetCell b{5};
           </code>
           As a copy:
           <code>
            SpreadsheetCell c{a};
           </code>
          </td>
         </tr>
        </tbody>
       </table>
       <p id="c08-para-0198">
        Note the lack of symmetry between the default constructor and the copy constructor. As long as you don't define a copy constructor explicitly, the compiler creates one for you. On the other hand, as soon as you define
        <i>
         any
        </i>
        constructor, the compiler stops generating a default constructor.
       </p>
       <p>
        As mentioned before in this chapter, the automatic generation of a default constructor and a default copy constructor can be influenced by defining them as explicitly defaulted or explicitly deleted.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0200">
           <b>
            NOTE
           </b>
           <i>
            A final type of constructor is a move constructor, required to implement move semantics. Move semantics is used to increase performance in certain situations and is discussed in detail in
           </i>
           <a href="c09.xhtml">
            <i>
             Chapter
            </i>
            9
           </a>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section>
      <span id="c08-sec-0061">
      </span>
      <h3 id="head-3-182">
       Object Destruction
      </h3>
      <p>
       When an object is destroyed, two events occur: the object's
       <i>
        destructor
       </i>
       member function is called, and the memory it was taking up is freed. The destructor is your chance to perform any cleanup work for the object, such as freeing dynamically allocated memory or closing file handles. If you don't declare a destructor, the compiler writes one for you that does recursive member-wise destruction and allows the object to be deleted. A destructor of a class is a member function with as name the name of the class prefixed with a tilde (
       <code>
        ˜
       </code>
       ). A destructor does not return anything and does not have any parameters. Here is an example of a destructor that simply writes something to standard output:
      </p>
      <pre id="c08-code-0095"><span aria-label="287" epub:type="pagebreak" id="Page_287" role="doc-pagebreak"></span><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        ˜SpreadsheetCell();  <span class="color3">// Destructor.</span></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code>
<code> </code>
<code>SpreadsheetCell::˜SpreadsheetCell()</code>
<code>{</code>
<code>    println("Destructor called.");</code>
<code>}</code></pre>
      <p>
       Objects on the stack are destroyed when they go
       <i>
        out of scope
       </i>
       , which means whenever the current function or other execution
       <i>
        block
       </i>
       ends. In other words, whenever the code encounters an ending curly brace, any objects created on the stack within those curly braces are destroyed. The following program shows this behavior:
      </p>
      <pre id="c08-code-0096"><code>int main()</code>
<code>{</code>
<code>    SpreadsheetCell myCell { 5 };</code>
<code>    if (myCell.getValue() == 5) {</code>
<code>        SpreadsheetCell anotherCell { 6 };</code>
<code>    } <span class="color3">// anotherCell is destroyed as this block ends.</span></code>
<code> </code>
<code>    println("myCell: {}", myCell.getValue());</code>
<code>} <span class="color3">// myCell is destroyed as this block ends.</span></code></pre>
      <p>
       Objects on the stack are destroyed in the reverse order of their declaration (and construction). For example, in the following code fragment,
       <code>
        myCell2
       </code>
       is created before
       <code>
        anotherCell2
       </code>
       , so
       <code>
        anotherCell2
       </code>
       is destroyed before
       <code>
        myCell2
       </code>
       (note that you can start a new code block at any point in your program with an opening curly brace):
      </p>
      <pre id="c08-code-0097"><code>{</code>
<code>    SpreadsheetCell myCell2 { 4 };</code>
<code>    SpreadsheetCell anotherCell2 { 5 }; <span class="color3">// myCell2 constructed before anotherCell2</span></code>
<code>} <span class="color3">// anotherCell2 destroyed before myCell2</span></code></pre>
      <p id="c08-para-0204">
       This ordering also applies to objects that are data members of other objects. Recall that data members are initialized in the order of their declaration in the class. Thus, following the rule that objects are destroyed in the reverse order of their construction, data member objects are destroyed in the reverse order of their declaration order in the class.
      </p>
      <p>
       Objects allocated on the free store without the help of smart pointers are not destroyed automatically. You must call
       <code>
        delete
       </code>
       on the object pointer to call its destructor and free its memory. The following program shows this behavior.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c08-para-0206">
          <b>
           WARNING
          </b>
          <i>
           Do not write programs like the next example where
          </i>
          <code>
           cellPtr2
          </code>
          <i>
           is not deleted. Make sure you always free dynamically allocated memory by calling
          </i>
          <code>
           delete
          </code>
          <i>
           or
          </i>
          <code>
           delete[]
          </code>
          <i>
           depending on whether the memory was allocated using
          </i>
          <code>
           new
          </code>
          <i>
           or
          </i>
          <code>
           new[]
          </code>
          <i>
           . Or better yet, use smart pointers as discussed earlier!
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <pre id="c08-code-0098"><span aria-label="288" epub:type="pagebreak" id="Page_288" role="doc-pagebreak"></span><code>int main()</code>
<code>{</code>
<code>    SpreadsheetCell* cellPtr1 { new SpreadsheetCell { 5 } };</code>
<code>    SpreadsheetCell* cellPtr2 { new SpreadsheetCell { 6 } };</code>
<code>    println("cellPtr1: {}", cellPtr1-&gt;getValue());</code>
<code>    delete cellPtr1; <span class="color3">// Destroys cellPtr1</span></code>
<code>    cellPtr1 = nullptr;</code>
<code>} <span class="color3">// cellPtr2 is NOT destroyed because delete was not called on it.</span></code></pre>
     </section>
     <section>
      <span id="c08-sec-0063">
      </span>
      <h3 id="head-3-183">
       Assigning to Objects
      </h3>
      <p>
       Just as you can assign the value of one
       <code>
        int
       </code>
       to another in C++, you can assign the value of one object to another. For example, the following code assigns the value of
       <code>
        myCell
       </code>
       to
       <code>
        anotherCell
       </code>
       :
      </p>
      <pre id="c08-code-0099"><code>SpreadsheetCell myCell { 5 }, anotherCell;</code>
<code><b>anotherCell = myCell;</b></code></pre>
      <p id="c08-para-0208">
       You might be tempted to say that
       <code>
        myCell
       </code>
       is “copied” to
       <code>
        anotherCell
       </code>
       . However, in the world of C++, “copying” occurs only when an object is being initialized. If an object already has a value that is being overwritten, the more accurate term is “assigned to.” Note that the facility that C++ provides for copying is the copy constructor. Because it is a constructor, it can only be used for object creation, not for later assignments to the object.
      </p>
      <p>
       Therefore, C++ provides another member function in every class to perform assignment. This member function is called the
       <i>
        assignment operator
       </i>
       . Its name is
       <code>
        operator=
       </code>
       because it is actually an overload of the
       <code>
        =
       </code>
       operator for that class. In the preceding example, the assignment operator for
       <code>
        anotherCell
       </code>
       is called, with
       <code>
        myCell
       </code>
       as the argument.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c08-para-0210">
          <b>
           NOTE
          </b>
          <i>
           The assignment operator as explained in this section is sometimes called the copy assignment operator because data is copied from the right-hand side object to the left-hand side object
          </i>
          .
          <a href="c09.xhtml">
           <i>
            Chapter
           </i>
           9
          </a>
          <i>
           discusses another kind of assignment operator, the move assignment operator, in which data is moved instead of copied, which improves performance for certain use cases
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c08-para-0211">
       As usual, if you don't write your own assignment operator, C++ writes one for you to allow objects to be assigned to one another. The default C++ assignment behavior is almost identical to its default copying behavior: it recursively assigns each data member from the source to the destination object.
      </p>
      <section>
       <span id="c08-sec-0065">
       </span>
       <h4 id="head-4-162">
        Declaring an Assignment Operator
       </h4>
       <p>
        Here is the assignment operator for the
        <code>
         SpreadsheetCell
        </code>
        class:
       </p>
       <pre id="c08-code-0100"><code>export class SpreadsheetCell</code>
<code>{</code>
<code>    public:</code>
<code>        <b>SpreadsheetCell&amp; operator=(const SpreadsheetCell&amp; rhs);</b></code>
<code>        <span class="color3">// Remainder of the class definition omitted for brevity</span></code>
<code>};</code></pre>
       <p id="c08-para-0213">
        <span aria-label="289" epub:type="pagebreak" id="Page_289" role="doc-pagebreak">
        </span>
        The assignment operator usually takes a reference-to-
        <code>
         const
        </code>
        to the source object, like the copy constructor. In this case, the source object is called
        <code>
         rhs
        </code>
        , which stands for right-hand side of the equal sign, but you are of course free to call it whatever you want. The object on which the assignment operator is called is the left-hand side of the equal sign.
       </p>
       <p>
        Unlike a copy constructor, the assignment operator returns a reference to a
        <code>
         SpreadsheetCell
        </code>
        object. The reason is that assignments can be
        <i>
         chained
        </i>
        , as in the following example:
       </p>
       <pre id="c08-code-0101"><code>myCell = anotherCell = aThirdCell;</code></pre>
       <p>
        When that line is executed, the first thing that happens is the assignment operator for
        <code>
         anotherCell
        </code>
        is called with
        <code>
         aThirdCell
        </code>
        as its “right-hand side” argument. Next, the assignment operator for
        <code>
         myCell
        </code>
        is called. However, its argument is not
        <code>
         anotherCell
        </code>
        ; its right-hand side is the
        <i>
         result
        </i>
        of the assignment of
        <code>
         aThirdCell
        </code>
        to
        <code>
         anotherCell
        </code>
        . The equal sign is simply just shorthand for what is really a member function call. When you look at the line in its full functional syntax shown here, you can see the problem:
       </p>
       <pre id="c08-code-0102"><code>myCell.operator=(anotherCell.operator=(aThirdCell));</code></pre>
       <p>
        Now, you can see that the
        <code>
         operator=
        </code>
        call from
        <code>
         anotherCell
        </code>
        must return a value, which is passed to the
        <code>
         operator=
        </code>
        call for
        <code>
         myCell
        </code>
        . The correct value to return is a reference to
        <code>
         anotherCell
        </code>
        itself, so it can serve as the source for the assignment to
        <code>
         myCell
        </code>
        .
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0217">
           <b>
            WARNING
           </b>
           <i>
            You could actually declare the assignment operator to return whatever type you wanted, including
           </i>
           <code>
            void
           </code>
           <i>
            . However, you should always return a reference to the object on which it is called because that's what clients expect.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c08-sec-0067">
       </span>
       <h4 id="head-4-163">
        Defining an Assignment Operator
       </h4>
       <p id="c08-para-0218">
        The implementation of the assignment operator is similar to that of a copy constructor but with several important differences. First, a copy constructor is called only for initialization, so the destination object does not yet have valid values. An assignment operator can overwrite the current values in an object. This consideration doesn't really come into play until you have dynamically allocated resources, such as memory, in your objects. See
        <a href="c09.xhtml">
         Chapter 9
        </a>
        for details.
       </p>
       <p>
        Second, it's legal in C++ to assign an object to itself. For example, the following code compiles and runs:
       </p>
       <pre id="c08-code-0103"><code>SpreadsheetCell cell { 4 };</code>
<code>cell = cell; <span class="color3">// Self-assignment</span></code></pre>
       <p id="c08-para-0220">
        Your assignment operator needs to take the possibility of self-assignment into account. In the
        <code>
         SpreadsheetCell
        </code>
        class, this is not important, as its only data member is a primitive type,
        <code>
         double
        </code>
        . However, when your class has dynamically allocated memory or other resources, it's paramount to take self-assignment into account, as is discussed in detail in
        <a href="c09.xhtml">
         Chapter 9
        </a>
        . To prevent problems in such cases, the first thing assignment operators usually do is check for self-assignment and return immediately if that's the case.
       </p>
       <p>
        <span aria-label="290" epub:type="pagebreak" id="Page_290" role="doc-pagebreak">
        </span>
        Here is the start of the definition of the assignment operator for the
        <code>
         SpreadsheetCell
        </code>
        class:
       </p>
       <pre id="c08-code-0104"><code>SpreadsheetCell&amp; SpreadsheetCell::operator=(const SpreadsheetCell&amp; rhs)</code>
<code>{</code>
<code>    if (this == &amp;rhs) {</code></pre>
       <p>
        This first line checks for self-assignment, but it might be a bit cryptic. Self-assignment occurs when the left-hand side and the right-hand side of the equal sign are the same. One way to tell whether two objects are the same is if they occupy the same memory location—more explicitly, if pointers to them are equal. Recall that
        <code>
         this
        </code>
        is a pointer to an object accessible from any member function called on the object. Thus,
        <code>
         this
        </code>
        is a pointer to the left-hand side object. Similarly,
        <code>
         &amp;rhs
        </code>
        is a pointer to the right-hand side object. If these pointers are equal, the assignment must be self-assignment, but because the return type is
        <code>
         SpreadsheetCell&amp;
        </code>
        , a correct value must still be returned. All assignment operators return
        <code>
         *this
        </code>
        as follows, and the self-assignment case is no exception:
       </p>
       <pre id="c08-code-0105"><code>        return *this;</code>
<code>    }</code></pre>
       <p>
        <code>
         this
        </code>
        is a pointer to the object on which the member function executes, so
        <code>
         *this
        </code>
        is the object itself. The compiler returns a reference to the object to match the declared return type. Now, if it is not self-assignment, you have to do an assignment to every member:
       </p>
       <pre id="c08-code-0106"><code>    m_value = rhs.m_value;</code>
<code>    return *this;</code>
<code>}</code></pre>
       <p id="c08-para-0224">
        Here the member function copies the values, and finally, it returns
        <code>
         *this
        </code>
        , as explained earlier.
       </p>
       <p>
        Astute readers will notice there's some code duplication between the copy assignment operator and the copy constructor; they both need to copy all data members.
        <a href="c09.xhtml">
         Chapter 9
        </a>
        introduces the copy-and-swap idiom to prevent such code duplication.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0226">
           <b>
            NOTE
           </b>
           <i>
            The
           </i>
           <code>
            SpreadsheetCell
           </code>
           <i>
            assignment operator is shown only for demonstration purposes. In fact, in this case, the assignment operator can be omitted because the default compiler-generated one is good enough; it does simple member-wise assignments of all data members. However, under certain conditions, this compiler-generated assignment operator is not sufficient. These conditions are covered in
            <a href="c09.xhtml">
             Chapter 9
            </a>
            .
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c08-para-0227">
           <b>
            WARNING
           </b>
           <i>
            If your class requires special handling for copy operations, always implement both the copy constructor and the copy assignment operator
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c08-sec-0070">
       </span>
       <h4 id="head-4-164">
        Explicitly Defaulted and Deleted Assignment Operator
       </h4>
       <p>
        You can explicitly default or delete a compiler-generated assignment operator as follows:
       </p>
       <pre id="c08-code-0107"><code>SpreadsheetCell&amp; operator=(const SpreadsheetCell&amp; rhs) = default;</code></pre>
       <p>
        <span aria-label="291" epub:type="pagebreak" id="Page_291" role="doc-pagebreak">
        </span>
        or
       </p>
       <pre id="c08-code-0108"><code>SpreadsheetCell&amp; operator=(const SpreadsheetCell&amp; rhs) = delete;</code></pre>
      </section>
     </section>
     <section>
      <span id="c08-sec-0071">
      </span>
      <h3 id="head-3-184">
       Compiler-Generated Copy Constructor and Copy Assignment Operator
      </h3>
      <p>
       C++11 deprecated the generation of a copy constructor if the class has a user-declared copy assignment operator or destructor. If you still need a compiler-generated copy constructor in such a case, you can explicitly default one:
      </p>
      <pre id="c08-code-0109"><code>MyClass(const MyClass&amp; src) = default;</code></pre>
      <p>
       C++11 also deprecated the generation of a copy assignment operator if the class has a user-declared copy constructor or destructor. If you still need a compiler-generated copy assignment operator in such a case, you can explicitly default one:
      </p>
      <pre id="c08-code-0110"><code>MyClass&amp; operator=(const MyClass&amp; rhs) = default;</code></pre>
     </section>
     <section>
      <span id="c08-sec-0072">
      </span>
      <h3 id="head-3-185">
       Distinguishing Copying from Assignment
      </h3>
      <p>
       It is sometimes difficult to tell when objects are initialized with a copy constructor rather than assigned to with the assignment operator. Essentially, things that look like a declaration are going to be using copy constructors, and things that look like assignment statements are handled by the assignment operator. Consider the following code:
      </p>
      <pre id="c08-code-0111"><code>SpreadsheetCell myCell { 5 };</code>
<code>SpreadsheetCell anotherCell { myCell };</code></pre>
      <p>
       <code>
        AnotherCell
       </code>
       is constructed with the copy constructor. Now consider the following:
      </p>
      <pre id="c08-code-0112"><code>SpreadsheetCell aThirdCell = myCell;</code></pre>
      <p>
       <code>
        aThirdCell
       </code>
       is also constructed with the copy constructor, because this is a declaration. The
       <code>
        operator=
       </code>
       is not called for this line! This syntax is just another way to write
       <code>
        SpreadsheetCell aThirdCell{myCell};
       </code>
       . However, consider the following code:
      </p>
      <pre id="c08-code-0113"><code>anotherCell = myCell; <span class="color3">// Calls operator= for anotherCell</span></code></pre>
      <p id="c08-para-0235">
       Here,
       <code>
        anotherCell
       </code>
       has already been constructed, so the compiler calls
       <code>
        operator=
       </code>
       .
      </p>
      <section>
       <span id="c08-sec-0073">
       </span>
       <h4 id="head-4-165">
        Objects as Return Values
       </h4>
       <p>
        When you return objects from functions, it is sometimes difficult to see exactly what copying and assigning is happening. For example, the implementation of
        <code>
         SpreadsheetCell::getString()
        </code>
        looks like this:
       </p>
       <pre id="c08-code-0114"><code>string SpreadsheetCell::getString() const</code>
<code>{</code>
<code>    return doubleToString(m_value);</code>
<code>}</code></pre>
       <p>
        Now consider the following code:
       </p>
       <pre id="c08-code-0115"><code>SpreadsheetCell myCell2 { 5 };</code>
<code>string s1;</code>
<code>s1 = myCell2.getString();</code></pre>
       <p id="c08-para-0238">
        <span aria-label="292" epub:type="pagebreak" id="Page_292" role="doc-pagebreak">
        </span>
        When
        <code>
         getString()
        </code>
        returns the string, the compiler actually creates an unnamed temporary
        <code>
         string
        </code>
        object by calling a
        <code>
         string
        </code>
        copy constructor. When you assign this result to
        <code>
         s1
        </code>
        , the assignment operator is called for
        <code>
         s1
        </code>
        with the temporary
        <code>
         string
        </code>
        as a parameter. Then, the temporary
        <code>
         string
        </code>
        object is destroyed. Thus, the single line of code could invoke the copy constructor and the assignment operator (for two different objects).
       </p>
       <p>
        In case you're not confused enough, consider this code:
       </p>
       <pre id="c08-code-0116"><code>SpreadsheetCell myCell3 { 5 };</code>
<code><b>string s2 = myCell3.getString();</b></code></pre>
       <p id="c08-para-0240">
        In this case,
        <code>
         getString()
        </code>
        still creates a temporary unnamed
        <code>
         string
        </code>
        object when it returns. But now,
        <code>
         s2
        </code>
        gets its copy constructor called, not its assignment operator.
       </p>
       <p id="c08-para-0241">
        With
        <i>
         move semantics
        </i>
        , the compiler can use a
        <i>
         move constructor
        </i>
        or
        <i>
         move assignment operator
        </i>
        instead of a copy constructor or copy assignment operator to return the string from
        <code>
         getString()
        </code>
        . This can be more efficient in certain cases and is discussed in
        <a href="c09.xhtml">
         Chapter 9
        </a>
        . However, even better, compilers are free to (and often even required to) implement
        <i>
         copy elision
        </i>
        to optimize away costly copy operations or move operations when returning values; see
        <a href="c01.xhtml">
         Chapter 1
        </a>
        .
       </p>
       <p id="c08-para-0242">
        If you ever forget the order in which these things happen or which constructor or operator is called, you can easily figure it out by temporarily including helpful output in your code or by stepping through your code with a debugger.
       </p>
      </section>
      <section>
       <span id="c08-sec-0074">
       </span>
       <h4 id="head-4-166">
        Copy Constructors and Object Members
       </h4>
       <p id="c08-para-0243">
        You should also note the difference between assignment operator and copy constructor calls in constructors. If an object contains other objects, the compiler-generated copy constructor calls the copy constructors of each of the contained objects recursively. When you write your own copy constructor, you can provide the same semantics by using a ctor-initializer, as shown previously. If you omit a data member from the ctor-initializer, the compiler performs default initialization on it (a call to the default constructor for objects) before executing your code in the body of the constructor. Thus, by the time the body of the constructor executes, all object data members have already been initialized.
       </p>
       <p>
        For example, you could write the
        <code>
         SpreadsheetCell
        </code>
        copy constructor like this:
       </p>
       <pre id="c08-code-0117"><code>SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell&amp; src)</code>
<code>{</code>
<code>    m_value = src.m_value;</code>
<code>}</code></pre>
       <p id="c08-para-0245">
        However, when you assign values to data members in the body of the copy constructor, you are using the assignment operator on them, not the copy constructor, because they have already been initialized.
       </p>
       <p>
        If you write the copy constructor as follows, then
        <code>
         m_value
        </code>
        is initialized using the copy constructor:
       </p>
       <pre id="c08-code-0118"><code>SpreadsheetCell::SpreadsheetCell(const SpreadsheetCell&amp; src)</code>
<code>    : m_value { src.m_value }</code>
<code>{</code>
<code>}</code></pre>
      </section>
     </section>
    </section>
    <span aria-label="293" epub:type="pagebreak" id="Page_293" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-106">
     <span id="c08-sec-0075">
     </span>
     <h2 id="head-2-106">
      SUMMARY
     </h2>
     <p id="c08-para-0247">
      This chapter covered the fundamental aspects of C++'s facilities for object-oriented programming: classes and objects. It first reviewed the basic syntax for writing classes and using objects, including access control. Then, it covered object life cycles: when objects are constructed, destructed, and assigned to, and what member functions those actions invoke. The chapter included details of the constructor syntax, including ctor-initializers and initializer-list constructors, and introduced the notion of copy assignment operators. It also specified exactly which constructors the compiler writes for you and under what circumstances, and it explained that default constructors require no arguments.
     </p>
     <p id="c08-para-0248">
      You may have found this chapter to be mostly review. Or, it may have opened your eyes to the world of object-oriented programming in C++. In any case, now that you are proficient with objects and classes, read
      <a href="c09.xhtml">
       Chapter 9
      </a>
      to learn more about their tricks and subtleties.
     </p>
    </section>
    <section aria-labelledby="head-2-107">
     <span id="c08-sec-0076">
     </span>
     <h2 id="head-2-107">
      EXERCISES
     </h2>
     <p id="c08-para-0249">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c08-exsec-0001">
      </span>
      <ol class="none">
       <li id="c08-ex-0001">
        <b>
         Exercise 8-1:
        </b>
        Implement a
        <code>
         Person
        </code>
        class storing a first and last name as data members. Add a single constructor accepting two parameters, the first and last name. Provide appropriate getters and setters. Write a small
        <code>
         main()
        </code>
        function to test your implementation by creating a
        <code>
         Person
        </code>
        object on the stack and on the free store.
       </li>
       <li id="c08-ex-0002">
        <b>
         Exercise 8-2:
        </b>
        With the set of member functions implemented in Exercise 8-1, the following line of code does not compile:
        <pre id="c08-code-0119"><code>Person persons[3];</code></pre>
        <p class="listPara1" id="c08-para-0253">
         Can you explain why this does not compile? Modify the implementation of your
         <code>
          Person
         </code>
         class to make this work.
        </p>
       </li>
       <li id="c08-ex-0003">
        <b>
         Exercise 8-3:
        </b>
        Add the following member functions to your
        <code>
         Person
        </code>
        class implementation: a copy constructor, a copy assignment operator, and a destructor. In all of these member functions, implement what you think is necessary, and additionally, output a line of text to the console so you can trace when they are executed. Modify your
        <code>
         main()
        </code>
        function to test these new member functions. Note: technically, these new member functions are not strictly required for this
        <code>
         Person
        </code>
        class, because the compiler-generated versions are good enough, but this exercise is to practice writing them.
       </li>
       <li id="c08-ex-0004">
        <b>
         Exercise 8-4:
        </b>
        Remove the copy constructor, copy assignment operator, and destructor from your
        <code>
         Person
        </code>
        class, because the default compiler-generated versions are exactly what you need for this simple class. Next, add a new data member to store the initials of a person, and provide a getter and setter. Add a new constructor that accepts three parameters, a first and last name, and a person's initials. Modify the original two-parameter constructor to automatically generate initials for a given first and last name, and delegate the actual construction work to the new three-parameter constructor. Test this new functionality in your
        <code>
         main()
        </code>
        function.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
