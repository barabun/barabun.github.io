<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   CONTAINER ADAPTERS
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_013.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_015.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c18_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <section aria-labelledby="head-2-201" class="calibre2">
     <h2 class="calibre6" id="head-2-201">
      CONTAINER ADAPTERS
     </h2>
     <p class="calibre13" id="c18-para-0223">
      In addition to the standard sequential containers, the Standard Library provides three
      <i class="calibre18">
       container adapters
      </i>
      :
      <code class="calibre21">
       queue
      </code>
      ,
      <code class="calibre21">
       priority_queue
      </code>
      , and
      <code class="calibre21">
       stack
      </code>
      . Each of these adapters is a wrapper around one of the sequential containers. They allow you to swap the underlying container without having to change the rest of the code. The intent of the adapters is to simplify the interface and to provide only those features that are appropriate for the
      <code class="calibre21">
       stack
      </code>
      ,
      <code class="calibre21">
       queue
      </code>
      , or
      <code class="calibre21">
       priority_queue
      </code>
      abstraction. These adapters do not provide access to the underlying container and hence are a perfect example of the data-hiding principle explained in
      <a class="calibre5" href="c04.xhtml">
       Chapter 4
      </a>
      , “Designing Professional C++ Programs.” For instance, the adapters don't provide the capability to erase multiple elements simultaneously, nor do they provide iterators. The latter means you cannot use them with range-based
      <code class="calibre21">
       for
      </code>
      loops or with any of the standard iterator-based algorithms discussed in
      <a class="calibre5" href="c20.xhtml">
       Chapter 20
      </a>
      . However, starting with C++23, the
      <code class="calibre21">
       std::format()
      </code>
      and
      <code class="calibre21">
       print()
      </code>
      functions do support formatting and printing the contents of these container adapters.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0076">
      </span>
      <h3 class="calibre27" id="head-3-408">
       queue
      </h3>
      <p class="calibre13">
       The
       <code class="calibre21">
        queue
       </code>
       container adapter, defined in
       <code class="calibre21">
        &lt;queue&gt;
       </code>
       , provides standard first-in, first-out semantics. As usual, it's written as a class template, which looks like this:
      </p>
      <pre class="calibre26" id="c18-code-0083"><code class="calibre21">template &lt;typename T, typename Container = deque&lt;T&gt;&gt; class queue;</code></pre>
      <p class="calibre13" id="c18-para-0225">
       The
       <code class="calibre21">
        T
       </code>
       template parameter specifies the type that you intend to store in the
       <code class="calibre21">
        queue
       </code>
       . The second template parameter allows you to stipulate the underlying container that the
       <code class="calibre21">
        queue
       </code>
       adapts. However, the
       <code class="calibre21">
        queue
       </code>
       requires the sequential container to support both
       <code class="calibre21">
        push_back()
       </code>
       and
       <code class="calibre21">
        pop_front()
       </code>
       , so you have only two built-in choices:
       <code class="calibre21">
        deque
       </code>
       and
       <code class="calibre21">
        list
       </code>
       . For most purposes, you can just stick with the default
       <code class="calibre21">
        deque
       </code>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0077">
       </span>
       <h4 class="calibre29" id="head-4-289">
        queue Operations
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         queue
        </code>
        interface is extremely simple: there are only nine member functions, a set of constructors, and comparison operators. New in C++23 is a constructor accepting an iterator pair, [begin, end), which constructs a
        <code class="calibre21">
         queue
        </code>
        containing the elements from the given iterator range. The
        <code class="calibre21">
         push()
        </code>
        and
        <code class="calibre21">
         emplace()
        </code>
        member functions add a new element to the tail of the queue, while
        <code class="calibre21">
         pop()
        </code>
        removes the element at the head of the queue. C++23 adds
        <code class="calibre21">
         push_range()
        </code>
        to add a range of elements to the
        <code class="calibre21">
         queue
        </code>
        . You can retrieve references to, without removing, the first and last elements with
        <code class="calibre21">
         front()
        </code>
        and
        <code class="calibre21">
         back()
        </code>
        , respectively. As usual, when called on
        <code class="calibre21">
         const
        </code>
        objects,
        <code class="calibre21">
         front()
        </code>
        and
        <code class="calibre21">
         back()
        </code>
        return
        <span aria-label="723" class="calibre20" epub:type="pagebreak" id="Page_723" role="doc-pagebreak">
        </span>
        references-to-
        <code class="calibre21">
         const
        </code>
        ; and when called on non-
        <code class="calibre21">
         const
        </code>
        objects, they return references-to-non-
        <code class="calibre21">
         const
        </code>
        (read/write).
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0227">
           <b class="calibre14">
            WARNING
           </b>
           <code class="calibre21">
            pop()
           </code>
           <i class="calibre18">
            does not return the element popped. If you want to retain a copy, you must first retrieve it with
           </i>
           <code class="calibre21">
            front()
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c18-para-0228">
        The queue also supports
        <code class="calibre21">
         size()
        </code>
        ,
        <code class="calibre21">
         empty()
        </code>
        , and
        <code class="calibre21">
         swap()
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0079">
       </span>
       <h4 class="calibre29" id="head-4-290">
        queue Example: A Network Packet Buffer
       </h4>
       <p class="calibre13">
        When two computers communicate over a network, they send information to each other divided into discrete chunks called
        <i class="calibre18">
         packets
        </i>
        . The networking layer of the computer's operating system must pick up the packets and store them as they arrive. However, the computer might not have enough bandwidth to process all of them at once. Thus, the networking layer usually
        <i class="calibre18">
         buffers
        </i>
        , or stores, the packets until the higher layers have a chance to attend to them. The packets should be processed in the order they arrive, so this problem is perfect for a
        <code class="calibre21">
         queue
        </code>
        structure. The following is a small
        <code class="calibre21">
         PacketBuffer
        </code>
        class, with comments explaining the code, which stores incoming packets in a
        <code class="calibre21">
         queue
        </code>
        until they are processed. It's a class template so that different layers of the networking stack can use it for different kinds of packets, such as IP packets or TCP packets. It allows the client to specify a maximum size because operating systems usually limit the number of packets that can be stored, so as not to use too much memory. When the buffer is full, subsequently arriving packets are ignored.
       </p>
       <pre class="calibre26" id="c18-code-0084"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class PacketBuffer final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// If maxSize is 0, the size is unlimited, because creating</span></code>
<code class="calibre21">        <span class="color">// a buffer of size 0 makes little sense. Otherwise only</span></code>
<code class="calibre21">        <span class="color">// maxSize packets are allowed in the buffer at any one time.</span></code>
<code class="calibre21">        explicit PacketBuffer(std::size_t maxSize = 0);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Stores a packet in the buffer.</span></code>
<code class="calibre21">        <span class="color">// Returns false if the packet has been discarded because</span></code>
<code class="calibre21">        <span class="color">// there is no more space in the buffer, true otherwise.</span></code>
<code class="calibre21">        bool bufferPacket(const T&amp; packet);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns the next packet. Throws out_of_range</span></code>
<code class="calibre21">        <span class="color">// if the buffer is empty.</span></code>
<code class="calibre21">        [[nodiscard]] T getNextPacket();</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::queue&lt;T&gt; m_packets;</code>
<code class="calibre21">        std::size_t m_maxSize;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; PacketBuffer&lt;T&gt;::PacketBuffer(std::size_t maxSize<span class="color">/*= 0*/</span>)</code>
<code class="calibre21">    : m_maxSize { maxSize }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="724" class="calibre20" epub:type="pagebreak" id="Page_724" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename T&gt; bool PacketBuffer&lt;T&gt;::bufferPacket(const T&amp; packet)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (m_maxSize &gt; 0 &amp;&amp; m_packets.size() == m_maxSize) {</code>
<code class="calibre21">        <span class="color">// No more space. Drop the packet.</span></code>
<code class="calibre21">        return false;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    m_packets.push(packet);</code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt; T PacketBuffer&lt;T&gt;::getNextPacket()</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (m_packets.empty()) {</code>
<code class="calibre21">        throw std::out_of_range { "Buffer is empty" };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Retrieve the head element</span></code>
<code class="calibre21">    T temp { m_packets.front() };</code>
<code class="calibre21">    <span class="color">// Pop the head element</span></code>
<code class="calibre21">    m_packets.pop();</code>
<code class="calibre21">    <span class="color">// Return the head element</span></code>
<code class="calibre21">    return temp;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        A practical application of this class would require multiple threads. However, without explicit synchronization, no Standard Library object can be used safely from multiple threads when at least one of the threads modifies the object. C++ provides synchronization classes to allow thread-safe access to shared objects. This is discussed in
        <a class="calibre5" href="c27.xhtml">
         Chapter 27
        </a>
        , “Multithreaded Programming with C++.” The focus in this example is on the
        <code class="calibre21">
         queue
        </code>
        class, so here is a single-threaded example of using the
        <code class="calibre21">
         PacketBuffer
        </code>
        :
       </p>
       <pre class="calibre26" id="c18-code-0085"><code class="calibre21">class IPPacket final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit IPPacket(int id) : m_id { id } {}</code>
<code class="calibre21">        int getID() const { return m_id; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_id;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    PacketBuffer&lt;IPPacket&gt; ipPackets { 3 };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Add 4 packets</span></code>
<code class="calibre21">    for (int i { 1 }; i &lt;= 4; ++i) {</code>
<code class="calibre21">        if (!ipPackets.bufferPacket(IPPacket { i })) {</code>
<code class="calibre21">            println("Packet {} dropped (queue is full).", i);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    while (true) {</code>
<code class="calibre21">        try {</code>
<code class="calibre21">            IPPacket packet { ipPackets.getNextPacket() };</code>
<code class="calibre21">            println("Processing packet {}", packet.getID());</code>
<code class="calibre21">        } catch (const out_of_range&amp;) {</code>
<span aria-label="725" class="calibre20" epub:type="pagebreak" id="Page_725" role="doc-pagebreak"></span><code class="calibre21">            println("Queue is empty.");</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output of this program is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0086"><code class="calibre21">Packet 4 dropped (queue is full).</code>
<code class="calibre21">Processing packet 1</code>
<code class="calibre21">Processing packet 2</code>
<code class="calibre21">Processing packet 3</code>
<code class="calibre21">Queue is empty.</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0080">
      </span>
      <h3 class="calibre27" id="head-3-409">
       priority_queue
      </h3>
      <p class="calibre13" id="c18-para-0232">
       A
       <i class="calibre18">
        priority queue
       </i>
       is a queue that keeps its elements in sorted order. Instead of a strict FIFO ordering, the element at the head of the queue at any given time is the one with the highest priority. This element could be the oldest on the queue or the most recent. If two elements have equal priority, their relative order in the queue is undefined.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        priority_queue
       </code>
       container adapter is also defined in
       <code class="calibre21">
        &lt;queue&gt;
       </code>
       . Its template definition looks something like this (slightly simplified):
      </p>
      <pre class="calibre26" id="c18-code-0087"><code class="calibre21">template &lt;typename T, typename Container = vector&lt;T&gt;,</code>
<code class="calibre21">          typename Compare = less&lt;T&gt;&gt;;</code></pre>
      <p class="calibre13">
       It's not as complicated as it looks. You've seen the first two parameters before:
       <code class="calibre21">
        T
       </code>
       is the element type stored in the
       <code class="calibre21">
        priority_queue
       </code>
       , and
       <code class="calibre21">
        Container
       </code>
       is the underlying container on which the
       <code class="calibre21">
        priority_queue
       </code>
       is adapted. The
       <code class="calibre21">
        priority_queue
       </code>
       uses
       <code class="calibre21">
        vector
       </code>
       as the default, but
       <code class="calibre21">
        deque
       </code>
       works as well.
       <code class="calibre21">
        list
       </code>
       does not work because the
       <code class="calibre21">
        priority_queue
       </code>
       requires random access to its elements. The third parameter,
       <code class="calibre21">
        Compare
       </code>
       , is trickier. As you'll learn more about in
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       ,
       <code class="calibre21">
        less
       </code>
       is a class template that supports comparison of two objects of type
       <code class="calibre21">
        T
       </code>
       with
       <code class="calibre21">
        operator&lt;
       </code>
       . This means the priority of elements in a
       <code class="calibre21">
        priority_queue
       </code>
       is determined according to
       <code class="calibre21">
        operator&lt;
       </code>
       . You can customize the comparison used, but that's a topic for
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       . For now, just make sure the types stored in a
       <code class="calibre21">
        priority_queue
       </code>
       support
       <code class="calibre21">
        operator&lt;
       </code>
       . Of course, since C++20 it's enough to provide
       <code class="calibre21">
        operator&lt;=&gt;
       </code>
       which then automatically provides
       <code class="calibre21">
        operator&lt;
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0235">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The head element of a
          </i>
          <code class="calibre21">
           priority_queue
          </code>
          <i class="calibre18">
           is the one with the “highest” priority; by default, this is determined according to
          </i>
          <code class="calibre21">
           operator&lt;
          </code>
          <i class="calibre18">
           such that elements that are “less” than other elements have lower priority.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0082">
       </span>
       <h4 class="calibre29" id="head-4-291">
        priority_queue Operations
       </h4>
       <p class="calibre13">
        A
        <code class="calibre21">
         priority_queue
        </code>
        provides even fewer operations than does a
        <code class="calibre21">
         queue
        </code>
        . The
        <code class="calibre21">
         push()
        </code>
        ,
        <code class="calibre21">
         emplace()
        </code>
        , and
        <code class="calibre21">
         push_range()
        </code>
        (C++23) member functions allow you to insert elements,
        <code class="calibre21">
         pop()
        </code>
        allows you to remove elements, and
        <code class="calibre21">
         top()
        </code>
        returns a reference-to-
        <code class="calibre21">
         const
        </code>
        to the head element.
        <span aria-label="726" class="calibre20" epub:type="pagebreak" id="Page_726" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0237">
           <b class="calibre14">
            WARNING
           </b>
           <code class="calibre21">
            top()
           </code>
           <i class="calibre18">
            returns a reference-to-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            even when called on a non-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            object, because modifying the element might change its order, which is not allowed. A
           </i>
           <code class="calibre21">
            priority_queue
           </code>
           <i class="calibre18">
            provides no mechanism to obtain the tail element.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0238">
           <b class="calibre14">
            WARNING
           </b>
           <code class="calibre21">
            pop()
           </code>
           <i class="calibre18">
            does not return the element popped. If you want to retain a copy, you must first retrieve it with
           </i>
           <code class="calibre21">
            top()
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c18-para-0239">
        Like a
        <code class="calibre21">
         queue
        </code>
        , a
        <code class="calibre21">
         priority_queue
        </code>
        supports
        <code class="calibre21">
         size()
        </code>
        ,
        <code class="calibre21">
         empty()
        </code>
        , and
        <code class="calibre21">
         swap()
        </code>
        . However, it does not provide any comparison operators.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0085">
       </span>
       <h4 class="calibre29" id="head-4-292">
        priority_queue Example: An Error Correlator
       </h4>
       <p class="calibre13">
        Single failures on a system can often cause multiple errors to be generated from different components. A good error-handling system uses
        <i class="calibre18">
         error correlation
        </i>
        to process the most important errors first. You can use a
        <code class="calibre21">
         priority_queue
        </code>
        to write a simple error correlator. Assume all error events encode their own priority. The error correlator simply sorts error events according to their priority so that the highest-priority errors are always processed first. Here are the class definitions:
       </p>
       <pre class="calibre26" id="c18-code-0088"><code class="calibre21"><span class="color">// Sample Error class with just a priority and a string error description.</span></code>
<code class="calibre21">export class Error final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Error(int priority, std::string errorString)</code>
<code class="calibre21">            : m_priority { priority }, m_errorString { std::move(errorString) } { }</code>
<code class="calibre21">        int getPriority() const { return m_priority; }</code>
<code class="calibre21">        const std::string&amp; getErrorString() const { return m_errorString; }</code>
<code class="calibre21">        <span class="color">// Compare Errors according to their priority.</span></code>
<code class="calibre21">        auto operator&lt;=&gt;(const Error&amp; rhs) const {</code>
<code class="calibre21">            return getPriority() &lt;=&gt; rhs.getPriority(); }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_priority;</code>
<code class="calibre21">        std::string m_errorString;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Stream insertion overload for Errors.</span></code>
<code class="calibre21">export std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Error&amp; err)</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::print(os, "{} (priority {})", err.getErrorString(), err.getPriority());</code>
<code class="calibre21">    return os;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Simple ErrorCorrelator class that returns highest priority errors first.</span></code>
<code class="calibre21">export class ErrorCorrelator final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<span aria-label="727" class="calibre20" epub:type="pagebreak" id="Page_727" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// Add an error to be correlated.</span></code>
<code class="calibre21">        void addError(const Error&amp; error) { m_errors.push(error); }</code>
<code class="calibre21">        <span class="color">// Retrieve the next error to be processed.</span></code>
<code class="calibre21">        [[nodiscard]] Error getError()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            <span class="color">// If there are no more errors, throw an exception.</span></code>
<code class="calibre21">            if (m_errors.empty()) {</code>
<code class="calibre21">                throw std::out_of_range { "No more errors." };</code>
<code class="calibre21">            }</code>
<code class="calibre21">            <span class="color">// Save the top element.</span></code>
<code class="calibre21">            Error top { m_errors.top() };</code>
<code class="calibre21">            <span class="color">// Remove the top element.</span></code>
<code class="calibre21">            m_errors.pop();</code>
<code class="calibre21">            <span class="color">// Return the saved element.</span></code>
<code class="calibre21">            return top;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::priority_queue&lt;Error&gt; m_errors;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Here is a simple test showing how to use the
        <code class="calibre21">
         ErrorCorrelator
        </code>
        . Realistic use would require multiple threads so that one thread adds errors, while another processes them. As mentioned earlier with the
        <code class="calibre21">
         queue
        </code>
        example, this requires explicit synchronization, which is discussed in
        <a class="calibre5" href="c27.xhtml">
         Chapter 27
        </a>
        .
       </p>
       <pre class="calibre26" id="c18-code-0089"><code class="calibre21">ErrorCorrelator ec;</code>
<code class="calibre21">ec.addError(Error { 3, "Unable to read file" });</code>
<code class="calibre21">ec.addError(Error { 1, "Incorrect entry from user" });</code>
<code class="calibre21">ec.addError(Error { 10, "Unable to allocate memory!" });</code>
<code class="calibre21"> </code>
<code class="calibre21">while (true) {</code>
<code class="calibre21">    try {</code>
<code class="calibre21">        Error e { ec.getError() };</code>
<code class="calibre21">        cout &lt;&lt; e &lt;&lt; endl;</code>
<code class="calibre21">    } catch (const out_of_range&amp;) {</code>
<code class="calibre21">        println("Finished processing errors");</code>
<code class="calibre21">        break;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output of this program is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0090"><code class="calibre21">Unable to allocate memory! (priority 10)</code>
<code class="calibre21">Unable to read file (priority 3)</code>
<code class="calibre21">Incorrect entry from user (priority 1)</code>
<code class="calibre21">Finished processing errors</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0086">
      </span>
      <h3 class="calibre27" id="head-3-410">
       stack
      </h3>
      <p class="calibre13">
       A
       <code class="calibre21">
        stack
       </code>
       is almost identical to a
       <code class="calibre21">
        queue
       </code>
       , except that it provides
       <i class="calibre18">
        first-in, last-out
       </i>
       (FILO) semantics, also known as
       <i class="calibre18">
        last-in, first-out
       </i>
       (LIFO), instead of FIFO. It is defined in
       <code class="calibre21">
        &lt;stack&gt;
       </code>
       . The template definition looks like this:
      </p>
      <pre class="calibre26" id="c18-code-0091"><code class="calibre21">template &lt;typename T, typename Container = deque&lt;T&gt;&gt; class stack;</code></pre>
      <p class="calibre13" id="c18-para-0244">
       You can use
       <code class="calibre21">
        vector
       </code>
       ,
       <code class="calibre21">
        list
       </code>
       , or
       <code class="calibre21">
        deque
       </code>
       as the underlying container for the
       <code class="calibre21">
        stack
       </code>
       .
      </p>
      <span aria-label="728" class="calibre20" epub:type="pagebreak" id="Page_728" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0087">
       </span>
       <h4 class="calibre29" id="head-4-293">
        stack Operations
       </h4>
       <p class="calibre13">
        Just as for
        <code class="calibre21">
         queue
        </code>
        , C++23 adds a constructor accepting an iterator pair, [begin, end), which constructs a
        <code class="calibre21">
         stack
        </code>
        containing the elements from the given iterator range. Also like
        <code class="calibre21">
         queue
        </code>
        ,
        <code class="calibre21">
         stack
        </code>
        provides
        <code class="calibre21">
         push()
        </code>
        ,
        <code class="calibre21">
         emplace()
        </code>
        ,
        <code class="calibre21">
         pop()
        </code>
        , and
        <code class="calibre21">
         push_range()
        </code>
        (C++23). The difference is that
        <code class="calibre21">
         push()
        </code>
        and
        <code class="calibre21">
         push_range()
        </code>
        add new elements to the top of the
        <code class="calibre21">
         stack
        </code>
        , “pushing down” all elements inserted earlier, and
        <code class="calibre21">
         pop()
        </code>
        removes the element from the top of the
        <code class="calibre21">
         stack
        </code>
        , which is the most recently inserted element. The
        <code class="calibre21">
         top()
        </code>
        member function returns a reference-to-
        <code class="calibre21">
         const
        </code>
        to the top element if called on a
        <code class="calibre21">
         const
        </code>
        object, and a reference-to-non-
        <code class="calibre21">
         const
        </code>
        if called on a non-
        <code class="calibre21">
         const
        </code>
        object.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0246">
           <b class="calibre14">
            WARNING
           </b>
           <code class="calibre21">
            pop()
           </code>
           <i class="calibre18">
            does not return the element popped. If you want to retain a copy, you must first retrieve it with
           </i>
           <code class="calibre21">
            top()
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c18-para-0247">
        The
        <code class="calibre21">
         stack
        </code>
        supports
        <code class="calibre21">
         empty()
        </code>
        ,
        <code class="calibre21">
         size()
        </code>
        ,
        <code class="calibre21">
         swap()
        </code>
        , and the standard comparison operators.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0089">
       </span>
       <h4 class="calibre29" id="head-4-294">
        stack Example: Revised Error Correlator
       </h4>
       <p class="calibre13" id="c18-para-0248">
        You can rewrite the previous
        <code class="calibre21">
         ErrorCorrelator
        </code>
        class so that it gives out the most recent error instead of the one with the highest priority. The only change required is to change
        <code class="calibre21">
         m_errors
        </code>
        from a
        <code class="calibre21">
         priority_queue
        </code>
        to a
        <code class="calibre21">
         stack
        </code>
        . With this change, the errors are distributed in LIFO order instead of priority order. Nothing in the member function definitions needs to change because the
        <code class="calibre21">
         push()
        </code>
        ,
        <code class="calibre21">
         pop()
        </code>
        ,
        <code class="calibre21">
         top()
        </code>
        , and
        <code class="calibre21">
         empty()
        </code>
        member functions exist on both a
        <code class="calibre21">
         priority_queue
        </code>
        and a
        <code class="calibre21">
         stack
        </code>
        .
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-202" class="calibre2">
     <span class="calibre" id="c18-sec-0090">
     </span>
     <h2 class="calibre6" id="head-2-202">
      ASSOCIATIVE CONTAINERS
     </h2>
     <p class="calibre13">
      The C++ Standard Library provides several different types of associative containers:
     </p>
     <ul class="check" id="c18-list-0013">
      <li class="calibre9" id="c18-li-0064">
       <b class="calibre14">
        Ordered associative containers:
       </b>
       <code class="calibre21">
        map
       </code>
       ,
       <code class="calibre21">
        multimap
       </code>
       ,
       <code class="calibre21">
        set
       </code>
       , and
       <code class="calibre21">
        multiset
       </code>
       .
      </li>
      <li class="calibre9" id="c18-li-0065">
       <b class="calibre14">
        Unordered associative containers:
       </b>
       <code class="calibre21">
        unordered_map
       </code>
       ,
       <code class="calibre21">
        unordered_multimap
       </code>
       ,
       <code class="calibre21">
        unordered_set
       </code>
       , and
       <code class="calibre21">
        unordered_multiset
       </code>
       . These are also known as hash tables.
      </li>
     </ul>
     <ul class="check" id="c18-list-0014">
      <li class="calibre9" id="c18-li-0066">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       <b class="calibre14">
        Flat associative container adapters:
       </b>
       <code class="calibre21">
        flat_map
       </code>
       ,
       <code class="calibre21">
        flat_multimap
       </code>
       ,
       <code class="calibre21">
        flat_set
       </code>
       , and
       <code class="calibre21">
        flat_multiset
       </code>
       . These adapt sequential containers to behave as ordered associative containers.
      </li>
     </ul>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0091">
      </span>
      <h3 class="calibre27" id="head-3-411">
       Ordered Associative Containers
      </h3>
      <p class="calibre13" id="c18-para-0251">
       Unlike the sequential containers, the
       <i class="calibre18">
        ordered associative containers
       </i>
       do not store elements in a linear configuration. Instead, they provide a mapping of keys to values. They generally offer insertion, deletion, and lookup times that are equivalent to each other.
      </p>
      <p class="calibre13" id="c18-para-0252">
       There are four ordered associative containers provided by the Standard Library:
       <code class="calibre21">
        map
       </code>
       ,
       <code class="calibre21">
        multimap
       </code>
       ,
       <code class="calibre21">
        set
       </code>
       , and
       <code class="calibre21">
        multiset
       </code>
       . Each of these containers stores its elements in a
       <i class="calibre18">
        sorted
       </i>
       , tree-like data structure.
      </p>
      <span aria-label="729" class="calibre20" epub:type="pagebreak" id="Page_729" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0092">
       </span>
       <h4 class="calibre29" id="head-4-295">
        The pair Utility Class
       </h4>
       <p class="calibre13">
        Before delving deeper into the ordered associative containers, let's revisit the
        <code class="calibre21">
         pair
        </code>
        class template briefly introduced in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        . It is defined in
        <code class="calibre21">
         &lt;utility&gt;
        </code>
        and groups together two values of possibly different types. The values are accessible through the
        <code class="calibre21">
         first
        </code>
        and
        <code class="calibre21">
         second
        </code>
        public data members. All comparison operators are supported and compare both the
        <code class="calibre21">
         first
        </code>
        and
        <code class="calibre21">
         second
        </code>
        values. Here are some examples:
       </p>
       <pre class="calibre26" id="c18-code-0092"><code class="calibre21"><span class="color">// Two-argument constructor and default constructor</span></code>
<code class="calibre21">pair&lt;string, int&gt; myPair { "hello", 5 };</code>
<code class="calibre21">pair&lt;string, int&gt; myOtherPair;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Can assign directly to first and second</span></code>
<code class="calibre21">myOtherPair.first = "hello";</code>
<code class="calibre21">myOtherPair.second = 6;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Copy constructor</span></code>
<code class="calibre21">pair&lt;string, int&gt; myThirdPair { myOtherPair };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// operator&lt;</span></code>
<code class="calibre21">if (myPair &lt; myOtherPair) {</code>
<code class="calibre21">    println("myPair is less than myOtherPair");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("myPair is greater than or equal to myOtherPair");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// operator==</span></code>
<code class="calibre21">if (myOtherPair == myThirdPair) {</code>
<code class="calibre21">    println("myOtherPair is equal to myThirdPair");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("myOtherPair is not equal to myThirdPair");</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0093"><code class="calibre21">myPair is less than myOtherPair</code>
<code class="calibre21">myOtherPair is equal to myThirdPair</code></pre>
       <p class="calibre13">
        With class template argument deduction, you can omit the template type arguments. Here is an example. Note the use of the standard string literal
        <code class="calibre21">
         s
        </code>
        .
       </p>
       <pre class="calibre26" id="c18-code-0094"><code class="calibre21">pair myPair { "hello"s, 5 };  <span class="color">// Type is pair&lt;string, int&gt;.</span></code></pre>
       <p class="calibre13">
        Before C++17 introduced support for CTAD, an
        <code class="calibre21">
         std::make_pair()
        </code>
        utility function template could be used to construct a
        <code class="calibre21">
         pair
        </code>
        from two values. The following are three ways to construct a
        <code class="calibre21">
         pair
        </code>
        of an
        <code class="calibre21">
         int
        </code>
        and a
        <code class="calibre21">
         double
        </code>
        :
       </p>
       <pre class="calibre26" id="c18-code-0095"><code class="calibre21">pair&lt;int, double&gt; pair1 { make_pair(5, 10.10) };</code>
<code class="calibre21">auto pair2 { make_pair(5, 10.10) };</code>
<code class="calibre21">pair pair3 { 5, 10.10 };  <span class="color">// CTAD</span></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0093">
       </span>
       <h4 class="calibre29" id="head-4-296">
        map
       </h4>
       <p class="calibre13" id="c18-para-0257">
        A
        <code class="calibre21">
         map
        </code>
        , defined in
        <code class="calibre21">
         &lt;map&gt;
        </code>
        , stores key/value pairs instead of just single values. Insertion, lookup, and deletion are all based on the key; the value is just “along for the ride.” The term
        <i class="calibre18">
         map
        </i>
        comes from the conceptual understanding that the container “maps” keys to values.
       </p>
       <p class="calibre13" id="c18-para-0258">
        <span aria-label="730" class="calibre20" epub:type="pagebreak" id="Page_730" role="doc-pagebreak">
        </span>
        A
        <code class="calibre21">
         map
        </code>
        keeps elements in sorted order, based on the keys, so that insertion, deletion, and lookup all take logarithmic time. Because of the order, when you enumerate the elements, they come out in the ordering imposed by the type's
        <code class="calibre21">
         operator&lt;
        </code>
        or a user-defined comparator. It is usually implemented as some form of balanced tree, such as a red-black tree. However, the tree structure is not exposed to the client.
       </p>
       <p class="calibre13" id="c18-para-0259">
        You should use a
        <code class="calibre21">
         map
        </code>
        whenever you need to store and retrieve elements based on a “key” and you would like to have them in a certain order.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0094">
        </span>
        <h5 class="calibre35" id="head-5-120">
         Constructing maps
        </h5>
        <p class="calibre13" id="c18-para-0260">
         The
         <code class="calibre21">
          map
         </code>
         class template takes four types: the key type, the value type, the comparator type, and the allocator type. As always, the allocator is ignored in this chapter. The comparator is similar to the comparator for a
         <code class="calibre21">
          priority_queue
         </code>
         described earlier. It allows you to change the default comparator. In this chapter, only the default
         <code class="calibre21">
          less
         </code>
         comparator is used. When using the default, make sure that your keys all respond to
         <code class="calibre21">
          operator&lt;
         </code>
         appropriately. If you're interested in further detail,
         <a class="calibre5" href="c19.xhtml">
          Chapter 19
         </a>
         explains how to write your own comparators.
        </p>
        <p class="calibre13">
         If you ignore the comparator and allocator parameters, constructing a
         <code class="calibre21">
          map
         </code>
         is just like constructing a
         <code class="calibre21">
          vector
         </code>
         or a
         <code class="calibre21">
          list
         </code>
         , except that you specify the key and value types separately in the template instantiation. For example, the following code constructs a
         <code class="calibre21">
          map
         </code>
         that uses
         <code class="calibre21">
          int
         </code>
         s as the key and objects of the
         <code class="calibre21">
          Data
         </code>
         class as values:
        </p>
        <pre class="calibre26" id="c18-code-0096"><code class="calibre21">class Data final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Data(int value = 0) : m_value { value } { }</code>
<code class="calibre21">        int getValue() const { return m_value; }</code>
<code class="calibre21">        void setValue(int value) { m_value = value; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_value;</code>
<code class="calibre21">};</code>
<code class="calibre21">…</code>
<code class="calibre21">map&lt;int, Data&gt; dataMap;</code></pre>
        <p class="calibre13" id="c18-para-0262">
         Internally,
         <code class="calibre21">
          dataMap
         </code>
         stores a
         <code class="calibre21">
          pair&lt;int, Data&gt;
         </code>
         for each element in the
         <code class="calibre21">
          map
         </code>
         .
        </p>
        <p class="calibre13">
         A
         <code class="calibre21">
          map
         </code>
         also supports uniform initialization. The following
         <code class="calibre21">
          map
         </code>
         internally stores instances of
         <code class="calibre21">
          pair&lt;string, int&gt;
         </code>
         :
        </p>
        <pre class="calibre26" id="c18-code-0097"><code class="calibre21">map&lt;string, int&gt; m {</code>
<code class="calibre21">    { "Marc G.", 12 }, { "Warren B.", 34 }, { "Peter V.W.", 56 }</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Class template argument deduction does not work as usual. For example, the following does not compile:
        </p>
        <pre class="calibre26" id="c18-code-0098"><code class="calibre21">map m {</code>
<code class="calibre21">    { "Marc G."s, 12 }, { "Warren B."s, 34 }, { "Peter V.W."s, 56 }</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         This does not work because the compiler cannot deduce
         <code class="calibre21">
          pair&lt;string, int&gt;
         </code>
         from, for example,
         <code class="calibre21">
          {"Marc G."s, 12}
         </code>
         . If you really want, you can write the following (note the
         <code class="calibre21">
          s
         </code>
         suffix for the string literals!):
        </p>
        <pre class="calibre26" id="c18-code-0099"><span aria-label="731" class="calibre20" epub:type="pagebreak" id="Page_731" role="doc-pagebreak"></span><code class="calibre21">map m {</code>
<code class="calibre21">    pair { "Marc G."s, 12 }, pair { "Warren B."s, 34 }, pair { "Peter V.W."s, 56 }</code>
<code class="calibre21">};</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0095">
        </span>
        <h5 class="calibre35" id="head-5-121">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         Formatting and Printing Maps
        </h5>
        <p class="calibre13">
         Just as for
         <code class="calibre21">
          vector
         </code>
         s,
         <code class="calibre21">
          std::format()
         </code>
         and the
         <code class="calibre21">
          print()
         </code>
         functions can be used to format and print entire
         <code class="calibre21">
          map
         </code>
         s with a single statement. For
         <code class="calibre21">
          vector
         </code>
         s, the output is surrounded by square brackets, and each element is separated with a comma. For
         <code class="calibre21">
          map
         </code>
         s, the output is slightly different: the output is surrounded by curly brackets, each key/value pair is separated by a comma, and a colon separates the key and the value. For example, printing the
         <code class="calibre21">
          map
         </code>
         from the previous section,
         <code class="calibre21">
          m
         </code>
         , gives the following output:
        </p>
        <pre class="calibre26" id="c18-code-0100"><code class="calibre21">{"Marc G.": 12, "Peter V.W.": 56, "Warren B.": 34}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0096">
        </span>
        <h5 class="calibre35" id="head-5-122">
         Inserting Elements
        </h5>
        <p class="calibre13">
         Inserting an element into sequential containers such as
         <code class="calibre21">
          vector
         </code>
         and
         <code class="calibre21">
          list
         </code>
         always requires you to specify the position at which the element is to be added. A
         <code class="calibre21">
          map
         </code>
         , along with the other ordered associative containers, is different. The
         <code class="calibre21">
          map
         </code>
         's internal implementation determines the position in which to store the new element; you need only to supply the key and the value.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0269">
            <b class="calibre14">
             NOTE
            </b>
            <code class="calibre21">
             map
            </code>
            <i class="calibre18">
             and the other ordered associative containers do provide a version of
            </i>
            <code class="calibre21">
             insert()
            </code>
            <i class="calibre18">
             that takes an iterator position. However, that position is only a “hint” to the container as to the correct position. The container is not required to insert the element at that position.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13" id="c18-para-0270">
         When inserting elements, it is important to keep in mind that
         <code class="calibre21">
          map
         </code>
         s require unique keys: every element in the
         <code class="calibre21">
          map
         </code>
         must have a different key. If you want to support multiple elements with the same key, you have two options: either you can use a
         <code class="calibre21">
          map
         </code>
         and store another container such as a
         <code class="calibre21">
          vector
         </code>
         as the value for a key or you can use
         <code class="calibre21">
          multimap
         </code>
         s, described later.
        </p>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0098">
         </span>
         <h6 class="calibre35" id="head-6-13">
          The insert() Member Function
         </h6>
         <p class="calibre13">
          The
          <code class="calibre21">
           insert()
          </code>
          member function can be used to add elements to a
          <code class="calibre21">
           map
          </code>
          and has the advantage of allowing you to detect whether a key already exists. You must specify the key/value pair as a
          <code class="calibre21">
           pair
          </code>
          object or as an
          <code class="calibre21">
           initializer_list
          </code>
          . The return type of the basic form of
          <code class="calibre21">
           insert()
          </code>
          is a
          <code class="calibre21">
           pair
          </code>
          of an
          <code class="calibre21">
           iterator
          </code>
          and a
          <code class="calibre21">
           bool
          </code>
          . The reason for the complicated return type is that
          <code class="calibre21">
           insert()
          </code>
          does not overwrite a value if one already exists with the specified key. The
          <code class="calibre21">
           bool
          </code>
          element of the returned
          <code class="calibre21">
           pair
          </code>
          specifies whether the
          <code class="calibre21">
           insert()
          </code>
          actually inserted the new key/value pair. The
          <code class="calibre21">
           iterator
          </code>
          refers to the element in the
          <code class="calibre21">
           map
          </code>
          with the specified key (with a new or old value, depending on whether the insert succeeded or failed).
          <code class="calibre21">
           map
          </code>
          iterators are discussed in more detail in the next section. Continuing the
          <code class="calibre21">
           map
          </code>
          example from the previous section, you can use
          <code class="calibre21">
           insert()
          </code>
          as follows:
         </p>
         <pre class="calibre26" id="c18-code-0101"><code class="calibre21">map&lt;int, Data&gt; dataMap;</code>
<code class="calibre21"> </code>
<code class="calibre21">auto ret { dataMap.insert({ 1, Data { 4 } }) };   <span class="color">// Using an initializer_list</span></code>
<code class="calibre21">if (ret.second) { println("Insert succeeded!"); }</code>
<code class="calibre21">else { println("Insert failed!"); }</code>
<code class="calibre21"> </code>
<span aria-label="732" class="calibre20" epub:type="pagebreak" id="Page_732" role="doc-pagebreak"></span><code class="calibre21">ret = dataMap.insert(make_pair(1, Data { 6 })); <span class="color">// Using a pair object</span></code>
<code class="calibre21">if (ret.second) { println("Insert succeeded!"); }</code>
<code class="calibre21">else { println("Insert failed!"); }</code></pre>
         <p class="calibre13">
          The type of the
          <code class="calibre21">
           ret
          </code>
          variable is a
          <code class="calibre21">
           pair
          </code>
          as follows:
         </p>
         <pre class="calibre26" id="c18-code-0102"><code class="calibre21">pair&lt;map&lt;int, Data&gt;::iterator, bool&gt; ret;</code></pre>
         <p class="calibre13" id="c18-para-0273">
          The first element of the
          <code class="calibre21">
           pair
          </code>
          is a
          <code class="calibre21">
           map
          </code>
          iterator for a
          <code class="calibre21">
           map
          </code>
          with keys of type
          <code class="calibre21">
           int
          </code>
          and values of type
          <code class="calibre21">
           Data
          </code>
          . The second element of the
          <code class="calibre21">
           pair
          </code>
          is a Boolean value.
         </p>
         <p class="calibre13">
          The output of the program is as follows:
         </p>
         <pre class="calibre26" id="c18-code-0103"><code class="calibre21">Insert succeeded!</code>
<code class="calibre21">Insert failed!</code></pre>
         <p class="calibre13">
          With
          <code class="calibre21">
           if
          </code>
          statement initializers, inserting the data into the
          <code class="calibre21">
           map
          </code>
          and checking the result can be done with a single statement as follows:
         </p>
         <pre class="calibre26" id="c18-code-0104"><code class="calibre21"><b class="calibre14">if (auto result { dataMap.insert({ 1, Data { 4 } }) }; result.second) {</b></code>
<code class="calibre21">    println("Insert succeeded!");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Insert failed!");</code>
<code class="calibre21">}</code></pre>
         <p class="calibre13">
          This can further be combined with structured bindings:
         </p>
         <pre class="calibre26" id="c18-code-0105"><code class="calibre21"><b class="calibre14">if (auto [iter, success] { dataMap.insert({ 1, Data { 4 } }) }; success) {</b></code>
<code class="calibre21">    println("Insert succeeded!");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Insert failed!");</code>
<code class="calibre21">}</code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0099">
         </span>
         <h6 class="calibre35" id="head-6-14">
          The insert_or_assign() Member Function
         </h6>
         <p class="calibre13">
          <code class="calibre21">
           insert_or_assign()
          </code>
          has a similar return type as
          <code class="calibre21">
           insert()
          </code>
          . However, if an element with the given key already exists,
          <code class="calibre21">
           insert_or_assign()
          </code>
          overwrites the old value with the new value, while
          <code class="calibre21">
           insert()
          </code>
          does not overwrite the old value in that case. Another difference with
          <code class="calibre21">
           insert()
          </code>
          is that
          <code class="calibre21">
           insert_or_assign()
          </code>
          has two separate parameters: the key and the value. Here is an example:
         </p>
         <pre class="calibre26" id="c18-code-0106"><code class="calibre21"><b class="calibre14">auto ret { dataMap.insert_or_assign(1, Data { 7 }) };</b></code>
<code class="calibre21">if (ret.second) { println("Inserted."); }</code>
<code class="calibre21">else { println("Overwritten."); }</code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0100">
         </span>
         <h6 class="calibre35" id="head-6-15">
          <img alt="C++23" class="calibre15" src="images/icon1.png"/>
          The insert_range() Member Function
         </h6>
         <p class="calibre13">
          C++23 adds
          <code class="calibre21">
           insert_range()
          </code>
          for
          <code class="calibre21">
           map
          </code>
          , which can be used to insert all elements of a given range to the
          <code class="calibre21">
           map
          </code>
          , and returns an iterator to the first element that was added. Here is an example:
         </p>
         <pre class="calibre26" id="c18-code-0107"><code class="calibre21">vector&lt;pair&lt;int, Data&gt;&gt; moreData { {2, Data{22}}, {3, Data{33}}, {4, Data{44}} };</code>
<code class="calibre21"><b class="calibre14">dataMap.insert_range(moreData);</b></code></pre>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0101">
         </span>
         <h6 class="calibre35" id="head-6-16">
          operator[]
         </h6>
         <p class="calibre13">
          Another member function to insert elements into a
          <code class="calibre21">
           map
          </code>
          is through the overloaded
          <code class="calibre21">
           operator[]
          </code>
          . The difference is mainly in the syntax: you specify the key and value separately. Additionally,
          <code class="calibre21">
           operator[]
          </code>
          <span aria-label="733" class="calibre20" epub:type="pagebreak" id="Page_733" role="doc-pagebreak">
          </span>
          always succeeds. If no value with the given key exists, it creates a new element with that key and value. If an element with the key already exists,
          <code class="calibre21">
           operator[]
          </code>
          replaces the value with the newly specified value. Here is part of the previous example using
          <code class="calibre21">
           operator[]
          </code>
          instead of
          <code class="calibre21">
           insert()
          </code>
          :
         </p>
         <pre class="calibre26" id="c18-code-0108"><code class="calibre21">map&lt;int, Data&gt; dataMap;</code>
<code class="calibre21">dataMap[1] = Data { 4 };</code>
<code class="calibre21">dataMap[1] = Data { 6 }; <span class="color">// Replaces the element with key 1</span></code></pre>
         <p class="calibre13" id="c18-para-0281">
          There is, however, one major caveat to
          <code class="calibre21">
           operator[]
          </code>
          : it always constructs a new value object, even if it doesn't need to use it. Thus, it requires a default constructor for the element values and can be less efficient than
          <code class="calibre21">
           insert()
          </code>
          .
         </p>
         <p class="calibre13">
          The fact that
          <code class="calibre21">
           operator[]
          </code>
          creates a new element in a
          <code class="calibre21">
           map
          </code>
          if the requested element does not already exist means that this operator is not marked as
          <code class="calibre21">
           const
          </code>
          . This sounds obvious, but might sometimes look counterintuitive. For example, suppose you have the following function:
         </p>
         <pre class="calibre26" id="c18-code-0109"><code class="calibre21">void func(const map&lt;int, int&gt;&amp; m)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("{}", m[1]);  <span class="color">// Error</span></code>
<code class="calibre21">}</code></pre>
         <p class="calibre13" id="c18-para-0283">
          This fails to compile, even though you appear to be just reading the value
          <code class="calibre21">
           m[1]
          </code>
          . It fails because the parameter
          <code class="calibre21">
           m
          </code>
          is a reference-to-
          <code class="calibre21">
           const
          </code>
          to a
          <code class="calibre21">
           map
          </code>
          , and
          <code class="calibre21">
           operator[]
          </code>
          is not marked as
          <code class="calibre21">
           const
          </code>
          . In such cases, you should instead use the
          <code class="calibre21">
           find()
          </code>
          or
          <code class="calibre21">
           at()
          </code>
          member function described in the section “
          <a class="calibre5" href="c18_split_001.xhtml#c18-sec-0105">
           Looking Up Elements
          </a>
          .”
         </p>
        </section>
        <section class="calibre2">
         <span class="calibre" id="c18-sec-0102">
         </span>
         <h6 class="calibre35" id="head-6-17">
          Emplace Member Functions
         </h6>
         <p class="calibre13" id="c18-para-0284">
          A
          <code class="calibre21">
           map
          </code>
          supports
          <code class="calibre21">
           emplace()
          </code>
          and
          <code class="calibre21">
           emplace:hint()
          </code>
          to construct elements in-place, similar to the emplace member functions of a
          <code class="calibre21">
           vector
          </code>
          . There is also a
          <code class="calibre21">
           try_emplace()
          </code>
          member function that inserts an element in-place if the given key does not exist yet, or does nothing if the key already exists in the
          <code class="calibre21">
           map
          </code>
          .
         </p>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0103">
        </span>
        <h5 class="calibre35" id="head-5-123">
         map Iterators
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          map
         </code>
         iterators work similarly to the iterators on the sequential containers. The major difference is that the iterators refer to key/value
         <code class="calibre21">
          pair
         </code>
         s instead of just the values. To access the value, you must retrieve the
         <code class="calibre21">
          second
         </code>
         field of the
         <code class="calibre21">
          pair
         </code>
         object.
         <code class="calibre21">
          map
         </code>
         iterators are bidirectional, meaning you can traverse them in both directions. Here is how you can iterate through the
         <code class="calibre21">
          map
         </code>
         from the previous example:
        </p>
        <pre class="calibre26" id="c18-code-0110"><code class="calibre21">for (auto iter { cbegin(dataMap) }; iter != cend(dataMap); ++iter) {</code>
<code class="calibre21">    println("{}", iter-&gt;second.getValue());</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         Take another look at the expression used to access the value:
        </p>
        <pre class="calibre26" id="c18-code-0111"><code class="calibre21">iter-&gt;second.getValue()</code></pre>
        <p class="calibre13" id="c18-para-0287">
         <code class="calibre21">
          iter
         </code>
         refers to a key/value
         <code class="calibre21">
          pair
         </code>
         , so you can use the
         <code class="calibre21">
          -&gt;
         </code>
         operator to access the
         <code class="calibre21">
          second
         </code>
         field of that
         <code class="calibre21">
          pair
         </code>
         , which is a
         <code class="calibre21">
          Data
         </code>
         object. You can then call the
         <code class="calibre21">
          getValue()
         </code>
         member function on that
         <code class="calibre21">
          Data
         </code>
         object.
        </p>
        <p class="calibre13">
         Note that the following code is functionally equivalent:
        </p>
        <pre class="calibre26" id="c18-code-0112"><code class="calibre21">(*iter).second.getValue()</code></pre>
        <p class="calibre13">
         <span aria-label="734" class="calibre20" epub:type="pagebreak" id="Page_734" role="doc-pagebreak">
         </span>
         Using a range-based
         <code class="calibre21">
          for
         </code>
         loop, the loop can be written more readable and less error prone as follows:
        </p>
        <pre class="calibre26" id="c18-code-0113"><code class="calibre21">for (const auto&amp; p : dataMap) {</code>
<code class="calibre21">    println("{}", p.second.getValue());</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         It can be implemented even more elegantly using a combination of a range-based
         <code class="calibre21">
          for
         </code>
         loop and structured bindings:
        </p>
        <pre class="calibre26" id="c18-code-0114"><code class="calibre21">for (const auto&amp; [key, data] : dataMap) {</code>
<code class="calibre21">    println("{}", data.getValue());</code>
<code class="calibre21">}</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c18-para-0292">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             You can modify element values through non-
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             iterators, but the compiler will generate an error if you try to modify the key of an element, even through a non-
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             iterator, because it would destroy the sorted order of the elements in the
            </i>
            <code class="calibre21">
             map
            </code>
            <i class="calibre18">
             .
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0105">
        </span>
        <h5 class="calibre35" id="head-5-124">
         Looking Up Elements
        </h5>
        <p class="calibre13">
         A
         <code class="calibre21">
          map
         </code>
         provides logarithmic lookup of elements based on a supplied key. If you already know that an element with a given key is in a map, the simplest way to look it up is through
         <code class="calibre21">
          operator[]
         </code>
         as long as you call it on a non-
         <code class="calibre21">
          const map
         </code>
         or a reference-to-non-
         <code class="calibre21">
          const map
         </code>
         . The nice thing about
         <code class="calibre21">
          operator[]
         </code>
         is that it returns a reference to the value that you can use and modify directly, without worrying about pulling the value out of a
         <code class="calibre21">
          pair
         </code>
         object. Here is an extension of the previous example to call the
         <code class="calibre21">
          setValue()
         </code>
         member function on the
         <code class="calibre21">
          Data
         </code>
         object value with key
         <code class="calibre21">
          1
         </code>
         :
        </p>
        <pre class="calibre26" id="c18-code-0115"><code class="calibre21">map&lt;int, Data&gt; dataMap;</code>
<code class="calibre21">dataMap[1] = Data { 4 };</code>
<code class="calibre21">dataMap[1] = Data { 6 };</code>
<code class="calibre21"><b class="calibre14">dataMap[1].setValue(100);</b></code></pre>
        <p class="calibre13">
         As an alternative,
         <code class="calibre21">
          map
         </code>
         provides a
         <code class="calibre21">
          find()
         </code>
         member function that returns an
         <code class="calibre21">
          iterator
         </code>
         referring to the key/value pair with the requested key, if it exists, or the
         <code class="calibre21">
          end()
         </code>
         iterator if the key is not found in the
         <code class="calibre21">
          map
         </code>
         . This can be useful in the following cases:
        </p>
        <ul class="check" id="c18-list-0015">
         <li class="calibre9" id="c18-li-0067">
          If you don't know whether the element exists, you may not want to use
          <code class="calibre21">
           operator[]
          </code>
          , because it will insert a new element with that key if it doesn't find one already.
         </li>
         <li class="calibre9" id="c18-li-0068">
          If you have a
          <code class="calibre21">
           const
          </code>
          or a reference-to-
          <code class="calibre21">
           const map
          </code>
          , in which case you cannot use
          <code class="calibre21">
           operator[]
          </code>
          .
         </li>
        </ul>
        <p class="calibre13">
         Here is an example using
         <code class="calibre21">
          find()
         </code>
         to perform the same modification to the
         <code class="calibre21">
          Data
         </code>
         object with key
         <code class="calibre21">
          1
         </code>
         :
        </p>
        <pre class="calibre26" id="c18-code-0116"><code class="calibre21">auto it { dataMap.find(1) };</code>
<code class="calibre21">if (it != end(dataMap)) {</code>
<code class="calibre21">    it-&gt;second.setValue(100);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c18-para-0296">
         As you can see, using
         <code class="calibre21">
          find()
         </code>
         is a bit clumsier, but it's sometimes necessary.
        </p>
        <p class="calibre13">
         <span aria-label="735" class="calibre20" epub:type="pagebreak" id="Page_735" role="doc-pagebreak">
         </span>
         Alternatively, you can use the
         <code class="calibre21">
          at()
         </code>
         member function, which, just as
         <code class="calibre21">
          operator[]
         </code>
         , returns a reference to the value in the
         <code class="calibre21">
          map
         </code>
         with the requested key, if it exists. It throws an
         <code class="calibre21">
          out_of_range
         </code>
         exception if the requested key isn't found in the
         <code class="calibre21">
          map
         </code>
         . The
         <code class="calibre21">
          at()
         </code>
         member function works fine on a
         <code class="calibre21">
          const
         </code>
         or a reference-to-
         <code class="calibre21">
          const map
         </code>
         . For example:
        </p>
        <pre class="calibre26" id="c18-code-0117"><code class="calibre21">dataMap.at(1).setValue(200);</code></pre>
        <p class="calibre13" id="c18-para-0298">
         If you only want to know whether an element with a certain key is in a
         <code class="calibre21">
          map
         </code>
         , you can use the
         <code class="calibre21">
          count()
         </code>
         member function. It returns the number of elements in a
         <code class="calibre21">
          map
         </code>
         with a given key. For
         <code class="calibre21">
          map
         </code>
         s, the result will always be
         <code class="calibre21">
          0
         </code>
         or
         <code class="calibre21">
          1
         </code>
         because there can be no elements with duplicate keys.
        </p>
        <p class="calibre13">
         Additionally, all associative containers (ordered, unordered, and flat) have a member function called
         <code class="calibre21">
          contains()
         </code>
         . It returns
         <code class="calibre21">
          true
         </code>
         if a given key exists in a container,
         <code class="calibre21">
          false
         </code>
         otherwise. With this, it's no longer necessary to use
         <code class="calibre21">
          count()
         </code>
         to figure out whether a certain key is in an associative container. Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0118"><code class="calibre21">auto isKeyInMap { dataMap.contains(1) };</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0106">
        </span>
        <h5 class="calibre35" id="head-5-125">
         Removing Elements
        </h5>
        <p class="calibre13">
         A
         <code class="calibre21">
          map
         </code>
         allows you to remove an element at a specific iterator position or to remove all elements in a given iterator range, in amortized constant and logarithmic time, respectively. From the client perspective, these two
         <code class="calibre21">
          erase()
         </code>
         member functions are equivalent to those in the sequential containers. A great feature of a
         <code class="calibre21">
          map
         </code>
         , however, is that it also provides a version of
         <code class="calibre21">
          erase()
         </code>
         to remove an element matching a key. Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0119"><code class="calibre21">map&lt;int, Data&gt; dataMap;</code>
<code class="calibre21">dataMap[1] = Data { 4 };</code>
<code class="calibre21">println("There are {} elements with key 1.", dataMap.count(1));</code>
<code class="calibre21">dataMap.erase(1);</code>
<code class="calibre21">println("There are {} elements with key 1.", dataMap.count(1));</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0120"><code class="calibre21">There are 1 elements with key 1.</code>
<code class="calibre21">There are 0 elements with key 1.</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0107">
        </span>
        <h5 class="calibre35" id="head-5-126">
         Nodes
        </h5>
        <p class="calibre13" id="c18-para-0302">
         All the ordered and unordered associative containers are
         <i class="calibre18">
          node-based
         </i>
         data structures. The Standard Library provides direct access to
         <i class="calibre18">
          nodes
         </i>
         in the form of
         <i class="calibre18">
          node handles
         </i>
         . The exact type is unspecified, but each container has a type alias called
         <code class="calibre21">
          node_type
         </code>
         that specifies the type of a node handle for that container. A node handle can only be moved and is the owner of the element stored in a node. It provides read/write access to both the key and the value.
        </p>
        <p class="calibre13" id="c18-para-0303">
         Nodes can be extracted from an associative container as a node handle using the
         <code class="calibre21">
          extract()
         </code>
         member function, based either on a given iterator position or on a given key. Extracting a node from a container removes it from the container, because the returned node handle is the sole owner of the extracted element.
        </p>
        <p class="calibre13" id="c18-para-0304">
         New
         <code class="calibre21">
          insert()
         </code>
         overloads are provided that allow you to insert a node handle into a container.
        </p>
        <p class="calibre13">
         <span aria-label="736" class="calibre20" epub:type="pagebreak" id="Page_736" role="doc-pagebreak">
         </span>
         By using
         <code class="calibre21">
          extract()
         </code>
         to extract node handles and using
         <code class="calibre21">
          insert()
         </code>
         to insert node handles, you can effectively transfer data from one associative container to another one without any copying or moving involved. You can even transfer nodes from a
         <code class="calibre21">
          map
         </code>
         to a
         <code class="calibre21">
          multimap
         </code>
         and from a
         <code class="calibre21">
          set
         </code>
         to a
         <code class="calibre21">
          multiset
         </code>
         . Continuing with the example from the previous section, the following code snippet transfers the node with key 1 from
         <code class="calibre21">
          dataMap
         </code>
         to a second
         <code class="calibre21">
          map
         </code>
         called
         <code class="calibre21">
          dataMap2
         </code>
         :
        </p>
        <pre class="calibre26" id="c18-code-0121"><code class="calibre21">map&lt;int, Data&gt; dataMap2;</code>
<code class="calibre21">auto extractedNode { dataMap.extract(1) };</code>
<code class="calibre21">dataMap2.insert(move(extractedNode));</code></pre>
        <p class="calibre13">
         The last two lines can be combined into one:
        </p>
        <pre class="calibre26" id="c18-code-0122"><code class="calibre21">dataMap2.insert(dataMap.extract(1));</code></pre>
        <p class="calibre13">
         One additional operation is available to move all nodes from one associative container to another one:
         <code class="calibre21">
          merge()
         </code>
         . Nodes that cannot be moved because they would cause, for example, duplicates in a target container that does not allow duplicates, are left in the source container. Here is an example:
        </p>
        <pre class="calibre26" id="c18-code-0123"><code class="calibre21">map&lt;int, int&gt; src { {1, 11}, {2, 22} };</code>
<code class="calibre21">map&lt;int, int&gt; dst { {2, 22}, {3, 33}, {4, 44}, {5, 55} };</code>
<code class="calibre21">dst.merge(src);</code>
<code class="calibre21">println("src = {}", src); <span class="color">// src = {2: 22}</span></code>
<code class="calibre21">println("dst = {}", dst); <span class="color">// dst = {1: 11, 2: 22, 3: 33, 4: 44, 5: 55}</span></code></pre>
        <p class="calibre13" id="c18-para-0308">
         After the merge operation,
         <code class="calibre21">
          src
         </code>
         still contains one element, {2: 22}, because the destination already contains such an element, so it cannot be moved.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0108">
        </span>
        <h5 class="calibre35" id="head-5-127">
         map Example: Bank Account
        </h5>
        <p class="calibre13">
         You can implement a simple bank account database using a
         <code class="calibre21">
          map
         </code>
         . A common pattern is for the key to be one field of a
         <code class="calibre21">
          class
         </code>
         or
         <code class="calibre21">
          struct
         </code>
         that is stored in a
         <code class="calibre21">
          map
         </code>
         . In this case, the key is the account number. Here are simple
         <code class="calibre21">
          BankAccount
         </code>
         and
         <code class="calibre21">
          BankDB
         </code>
         classes:
        </p>
        <pre class="calibre26" id="c18-code-0124"><code class="calibre21">export class BankAccount final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit BankAccount(int accountNumber, std::string name)</code>
<code class="calibre21">            : m_accountNumber { accountNumber }, m_clientName { std::move(name) }{}</code>
<code class="calibre21"> </code>
<code class="calibre21">        void setAccountNumber(int accountNumber) {</code>
<code class="calibre21">            m_accountNumber = accountNumber; }</code>
<code class="calibre21">        int getAccountNumber() const { return m_accountNumber; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        void setClientName(std::string name) { m_clientName = std::move(name); }</code>
<code class="calibre21">        const std::string&amp; getClientName() const { return m_clientName; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_accountNumber;</code>
<code class="calibre21">        std::string m_clientName;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">export class BankDB final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Adds account to the bank database. If an account exists already</span></code>
<code class="calibre21">        <span class="color">// with that account number, the new account is not added. Returns true</span></code>
<span aria-label="737" class="calibre20" epub:type="pagebreak" id="Page_737" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// if the account is added, false if it's not.</span></code>
<code class="calibre21">        bool addAccount(const BankAccount&amp; account);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Removes the account with accountNumber from the database.</span></code>
<code class="calibre21">        void deleteAccount(int accountNumber);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns a reference to the account represented</span></code>
<code class="calibre21">        <span class="color">// by its account number or the client name.</span></code>
<code class="calibre21">        <span class="color">// Throws out_of_range if the account is not found.</span></code>
<code class="calibre21">        BankAccount&amp; findAccount(int accountNumber);</code>
<code class="calibre21">        BankAccount&amp; findAccount(std::string_view name);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Adds all the accounts from db to this database.</span></code>
<code class="calibre21">        <span class="color">// Deletes all the accounts from db.</span></code>
<code class="calibre21">        void mergeDatabase(BankDB&amp; db);</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::map&lt;int, BankAccount&gt; m_accounts;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Here are the implementations of the
         <code class="calibre21">
          BankDB
         </code>
         member functions, with comments explaining the code:
        </p>
        <pre class="calibre26" id="c18-code-0125"><code class="calibre21">bool BankDB::addAccount(const BankAccount&amp; account)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Do the actual insert, using the account number as the key.</span></code>
<code class="calibre21">    auto res { m_accounts.emplace(account.getAccountNumber(), account) };</code>
<code class="calibre21">    <span class="color">// or: auto res { m_accounts.insert(</span></code>
<code class="calibre21">    <span class="color">//         pair { account.getAccountNumber(), account }) };</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Return the bool field of the pair specifying success or failure.</span></code>
<code class="calibre21">    return res.second;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void BankDB::deleteAccount(int accountNumber)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_accounts.erase(accountNumber);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">BankAccount&amp; BankDB::findAccount(int accountNumber)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Finding an element via its key can be done with find().</span></code>
<code class="calibre21">    auto it { m_accounts.find(accountNumber) };</code>
<code class="calibre21">    if (it == end(m_accounts)) {</code>
<code class="calibre21">        throw out_of_range { format("No account with number {}.", accountNumber) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// Remember that iterators into maps refer to pairs of key/value.</span></code>
<code class="calibre21">    return it-&gt;second;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">BankAccount&amp; BankDB::findAccount(string_view name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Finding an element by a non-key attribute requires a linear</span></code>
<code class="calibre21">    <span class="color">// search through the elements. The following uses structured bindings.</span></code>
<code class="calibre21">    for (auto&amp; [accountNumber, account] : m_accounts) {</code>
<code class="calibre21">        if (account.getClientName() == name) {</code>
<code class="calibre21">            return account;  <span class="color">// found it!</span></code>
<span aria-label="738" class="calibre20" epub:type="pagebreak" id="Page_738" role="doc-pagebreak"></span><code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    throw out_of_range { format("No account with name '{}'.", name) };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void BankDB::mergeDatabase(BankDB&amp; db)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Use merge().</span></code>
<code class="calibre21">    m_accounts.merge(db.m_accounts);</code>
<code class="calibre21">    <span class="color">// Or: m_accounts.insert(begin(db.m_accounts), end(db.m_accounts));</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Now clear the source database.</span></code>
<code class="calibre21">    db.m_accounts.clear();</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         You can test the
         <code class="calibre21">
          BankDB
         </code>
         class with the following code:
        </p>
        <pre class="calibre26" id="c18-code-0126"><code class="calibre21">BankDB db;</code>
<code class="calibre21">db.addAccount(BankAccount { 100, "Nicholas Solter" });</code>
<code class="calibre21">db.addAccount(BankAccount { 200, "Scott Kleper" });</code>
<code class="calibre21"> </code>
<code class="calibre21">try {</code>
<code class="calibre21">    auto&amp; account { db.findAccount(100) };</code>
<code class="calibre21">    println("Found account 100");</code>
<code class="calibre21">    account.setClientName("Nicholas A Solter");</code>
<code class="calibre21"> </code>
<code class="calibre21">    auto&amp; account2 { db.findAccount("Scott Kleper") };</code>
<code class="calibre21">    println("Found account of Scott Kleper");</code>
<code class="calibre21"> </code>
<code class="calibre21">    auto&amp; account3 { db.findAccount(1000) };</code>
<code class="calibre21">} catch (const out_of_range&amp; caughtException) {</code>
<code class="calibre21">    println("Unable to find account: {}", caughtException.what());</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0127"><code class="calibre21">Found account 100</code>
<code class="calibre21">Found account of Scott Kleper</code>
<code class="calibre21">Unable to find account: No account with number 1000.</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0109">
       </span>
       <h4 class="calibre29" id="head-4-297">
        multimap
       </h4>
       <p class="calibre13">
        A
        <code class="calibre21">
         multimap
        </code>
        is a
        <code class="calibre21">
         map
        </code>
        that allows multiple elements with the same key. Like
        <code class="calibre21">
         map
        </code>
        s,
        <code class="calibre21">
         multimap
        </code>
        s support uniform initialization. The interface is almost identical to the
        <code class="calibre21">
         map
        </code>
        interface, with the following differences:
       </p>
       <ul class="check" id="c18-list-0016">
        <li class="calibre9" id="c18-li-0069">
         <code class="calibre21">
          multimap
         </code>
         s do not provide
         <code class="calibre21">
          operator[]
         </code>
         and
         <code class="calibre21">
          at()
         </code>
         . The semantics of these do not make sense if there can be multiple elements with a single key.
        </li>
        <li class="calibre9" id="c18-li-0070">
         Inserts on
         <code class="calibre21">
          multimap
         </code>
         s always succeed. Thus, the
         <code class="calibre21">
          multimap::insert()
         </code>
         member function that adds a single element returns just an
         <code class="calibre21">
          iterator
         </code>
         instead of a
         <code class="calibre21">
          pair
         </code>
         .
        </li>
        <li class="calibre9" id="c18-li-0071">
         The
         <code class="calibre21">
          insert_or_assign()
         </code>
         and
         <code class="calibre21">
          try_emplace()
         </code>
         member functions supported by
         <code class="calibre21">
          map
         </code>
         are not supported by
         <code class="calibre21">
          multimap
         </code>
         .
        </li>
       </ul>
       <p class="calibre13">
        <span aria-label="739" class="calibre20" epub:type="pagebreak" id="Page_739" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0314">
           <b class="calibre14">
            NOTE
           </b>
           <code class="calibre21">
            multimap
           </code>
           <i class="calibre18">
            s allow you to insert identical key/value pairs. If you want to avoid this redundancy, you must check explicitly before inserting a new element.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c18-para-0315">
        The trickiest aspect of
        <code class="calibre21">
         multimap
        </code>
        s is looking up elements. You can't use
        <code class="calibre21">
         operator[]
        </code>
        , because it is not provided.
        <code class="calibre21">
         find()
        </code>
        isn't very useful because it returns an
        <code class="calibre21">
         iterator
        </code>
        referring to any one of the elements with a given key (not necessarily the first element with that key).
       </p>
       <p class="calibre13" id="c18-para-0316">
        However,
        <code class="calibre21">
         multimap
        </code>
        s store all elements with the same key together and provide member functions to obtain
        <code class="calibre21">
         iterator
        </code>
        s for this subrange of elements with the same key in the container. The
        <code class="calibre21">
         lower_bound()
        </code>
        and
        <code class="calibre21">
         upper_bound()
        </code>
        member functions each return a single
        <code class="calibre21">
         iterator
        </code>
        referring to the first and one-past-the-last elements matching a given key. If there are no elements matching that key, the
        <code class="calibre21">
         iterator
        </code>
        s returned by
        <code class="calibre21">
         lower_bound()
        </code>
        and
        <code class="calibre21">
         upper_bound()
        </code>
        will be equal to each other.
       </p>
       <p class="calibre13">
        If you need to obtain both
        <code class="calibre21">
         iterator
        </code>
        s bounding the elements with a given key, it's more efficient to use
        <code class="calibre21">
         equal_range()
        </code>
        instead of calling
        <code class="calibre21">
         lower_bound()
        </code>
        followed by calling
        <code class="calibre21">
         upper_bound()
        </code>
        . The
        <code class="calibre21">
         equal_range()
        </code>
        member function returns a
        <code class="calibre21">
         pair
        </code>
        of the two
        <code class="calibre21">
         iterator
        </code>
        s that would be returned by
        <code class="calibre21">
         lower_bound()
        </code>
        and
        <code class="calibre21">
         upper_bound()
        </code>
        .
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0318">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            The
           </i>
           <code class="calibre21">
            lower_bound()
           </code>
           <i class="calibre18">
            ,
           </i>
           <code class="calibre21">
            upper_bound()
           </code>
           <i class="calibre18">
            , and
           </i>
           <code class="calibre21">
            equal_range()
           </code>
           <i class="calibre18">
            member functions exist for
            <code class="calibre21">
             map
            </code>
            s as well, but their usefulness is limited because a
            <code class="calibre21">
             map
            </code>
            cannot have multiple elements with the same key
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0112">
        </span>
        <h5 class="calibre35" id="head-5-128">
         multimap Example: Buddy Lists
        </h5>
        <p class="calibre13" id="c18-para-0319">
         Most of the numerous online chat programs allow users to have a “buddy list” or list of friends. The chat program confers special privileges on users in the buddy list, such as allowing them to send unsolicited messages to the user.
        </p>
        <p class="calibre13">
         One way to implement the buddy lists for an online chat program is to store the information in a
         <code class="calibre21">
          multimap
         </code>
         . One
         <code class="calibre21">
          multimap
         </code>
         could store the buddy lists for every user. Each entry in the container stores one buddy for a user. The key is the user, and the value is the buddy. For example, if Harry Potter and Ron Weasley had each other on their individual buddy lists, there would be two entries of the form “Harry Potter” maps to “Ron Weasley” and “Ron Weasley” maps to “Harry Potter.” A
         <code class="calibre21">
          multimap
         </code>
         allows multiple values for the same key, so the same user is allowed multiple buddies. Here is the
         <code class="calibre21">
          BuddyList
         </code>
         class definition:
        </p>
        <pre class="calibre26" id="c18-code-0128"><code class="calibre21">export class BuddyList final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Adds buddy as a friend of name.</span></code>
<code class="calibre21">        void addBuddy(const std::string&amp; name, const std::string&amp; buddy);</code>
<code class="calibre21">        <span class="color">// Removes buddy as a friend of name.</span></code>
<code class="calibre21">        void removeBuddy(const std::string&amp; name, const std::string&amp; buddy);</code>
<code class="calibre21">        <span class="color">// Returns true if buddy is a friend of name, false otherwise.</span></code>
<code class="calibre21">        bool isBuddy(const std::string&amp; name, const std::string&amp; buddy) const;</code>
<span aria-label="740" class="calibre20" epub:type="pagebreak" id="Page_740" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// Retrieves a list of all the friends of name.</span></code>
<code class="calibre21">        std::vector&lt;std::string&gt; getBuddies(const std::string&amp; name) const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::multimap&lt;std::string, std::string&gt; m_buddies;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Here are the implementations, with comments explaining the code. It demonstrates the use of
         <code class="calibre21">
          lower_bound()
         </code>
         ,
         <code class="calibre21">
          upper_bound()
         </code>
         , and
         <code class="calibre21">
          equal_range()
         </code>
         .
        </p>
        <pre class="calibre26" id="c18-code-0129"><code class="calibre21">void BuddyList::addBuddy(const string&amp; name, const string&amp; buddy)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Make sure this buddy isn't already there. We don't want</span></code>
<code class="calibre21">    <span class="color">// to insert an identical copy of the key/value pair.</span></code>
<code class="calibre21">    if (!isBuddy(name, buddy)) {</code>
<code class="calibre21">        m_buddies.insert({ name, buddy }); <span class="color">// Using initializer_list</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void BuddyList::removeBuddy(const string&amp; name, const string&amp; buddy)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Obtain the beginning and end of the range of elements with</span></code>
<code class="calibre21">    <span class="color">// key 'name'. Use both lower_bound() and upper_bound() to demonstrate</span></code>
<code class="calibre21">    <span class="color">// their use. Otherwise, it's more efficient to call equal_range().</span></code>
<code class="calibre21">    auto begin { m_buddies.lower_bound(name) };  <span class="color">// Start of the range</span></code>
<code class="calibre21">    auto end { m_buddies.upper_bound(name) };    <span class="color">// End of the range</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Iterate through the elements with key 'name' looking</span></code>
<code class="calibre21">    <span class="color">// for a value 'buddy'. If there are no elements with key 'name',</span></code>
<code class="calibre21">    <span class="color">// begin equals end, so the loop body doesn't execute.</span></code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter) {</code>
<code class="calibre21">        if (iter-&gt;second == buddy) {</code>
<code class="calibre21">            <span class="color">// We found a match! Remove it from the map.</span></code>
<code class="calibre21">            m_buddies.erase(iter);</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">bool BuddyList::isBuddy(const string&amp; name, const string&amp; buddy) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Obtain the beginning and end of the range of elements with</span></code>
<code class="calibre21">    <span class="color">// key 'name' using equal_range(), and structured bindings.</span></code>
<code class="calibre21">    auto [begin, end] { m_buddies.equal_range(name) };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Iterate through the elements with key 'name' looking</span></code>
<code class="calibre21">    <span class="color">// for a value 'buddy'.</span></code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter) {</code>
<code class="calibre21">        if (iter-&gt;second == buddy) {</code>
<code class="calibre21">            <span class="color">// We found a match!</span></code>
<code class="calibre21">            return true;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// No matches</span></code>
<code class="calibre21">    return false;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="741" class="calibre20" epub:type="pagebreak" id="Page_741" role="doc-pagebreak"></span><code class="calibre21">vector&lt;string&gt; BuddyList::getBuddies(const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Obtain the beginning and end of the range of elements with</span></code>
<code class="calibre21">    <span class="color">// key 'name' using equal_range(), and structured bindings.</span></code>
<code class="calibre21">    auto [begin, end] { m_buddies.equal_range(name) };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Create a vector with all names in the range (all buddies of name).</span></code>
<code class="calibre21">    vector&lt;string&gt; buddies;</code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter) {</code>
<code class="calibre21">        buddies.push_back(iter-&gt;second);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return buddies;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c18-para-0322">
         Note that
         <code class="calibre21">
          removeBuddy()
         </code>
         can't simply use the version of
         <code class="calibre21">
          erase()
         </code>
         that erases all elements with a given key, because it should erase only one element with the key, not all of them. Note also that
         <code class="calibre21">
          getBuddies()
         </code>
         can't use
         <code class="calibre21">
          insert()
         </code>
         on the
         <code class="calibre21">
          vector
         </code>
         to insert the elements in the range returned by
         <code class="calibre21">
          equal_range()
         </code>
         , because the elements referred to by the
         <code class="calibre21">
          multimap iterator
         </code>
         s are key/value
         <code class="calibre21">
          pair
         </code>
         s, not
         <code class="calibre21">
          string
         </code>
         s. The
         <code class="calibre21">
          getBuddies()
         </code>
         member function must iterate explicitly through the range extracting the
         <code class="calibre21">
          string
         </code>
         from each key/value
         <code class="calibre21">
          pair
         </code>
         and pushing that onto the new
         <code class="calibre21">
          vector
         </code>
         to be returned.
        </p>
        <p class="calibre13">
         Alternatively, with the C++23 ranges functionality discussed in
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         ,
         <code class="calibre21">
          getBuddies()
         </code>
         can be implemented as follows without any explicit loops:
        </p>
        <pre class="calibre26" id="c18-code-0130"><code class="calibre21">vector&lt;string&gt; BuddyList::getBuddies(const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto [begin, end] { m_buddies.equal_range(name) };</code>
<code class="calibre21">    return ranges::subrange { begin, end } | views::values | ranges::to&lt;vector&gt;();</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         Here is a test of the
         <code class="calibre21">
          BuddyList
         </code>
         :
        </p>
        <pre class="calibre26" id="c18-code-0131"><code class="calibre21">BuddyList buddies;</code>
<code class="calibre21">buddies.addBuddy("Harry Potter", "Ron Weasley");</code>
<code class="calibre21">buddies.addBuddy("Harry Potter", "Hermione Granger");</code>
<code class="calibre21">buddies.addBuddy("Harry Potter", "Hagrid");</code>
<code class="calibre21">buddies.addBuddy("Harry Potter", "Draco Malfoy");</code>
<code class="calibre21"><span class="color">// That's not right! Remove Draco.</span></code>
<code class="calibre21">buddies.removeBuddy("Harry Potter", "Draco Malfoy");</code>
<code class="calibre21">buddies.addBuddy("Hagrid", "Harry Potter");</code>
<code class="calibre21">buddies.addBuddy("Hagrid", "Ron Weasley");</code>
<code class="calibre21">buddies.addBuddy("Hagrid", "Hermione Granger");</code>
<code class="calibre21"> </code>
<code class="calibre21">auto harrysFriends { buddies.getBuddies("Harry Potter") };</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Harry's friends: ");</code>
<code class="calibre21">for (const auto&amp; name : harrysFriends) {</code>
<code class="calibre21">    println("\t{}", name);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         <span aria-label="742" class="calibre20" epub:type="pagebreak" id="Page_742" role="doc-pagebreak">
         </span>
         The output is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0132"><code class="calibre21">Harry's friends:</code>
<code class="calibre21">        Ron Weasley</code>
<code class="calibre21">        Hermione Granger</code>
<code class="calibre21">        Hagrid</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0113">
       </span>
       <h4 class="calibre29" id="head-4-298">
        set
       </h4>
       <p class="calibre13" id="c18-para-0326">
        A
        <code class="calibre21">
         set
        </code>
        , defined in
        <code class="calibre21">
         &lt;set&gt;
        </code>
        , is similar to a
        <code class="calibre21">
         map
        </code>
        . The difference is that instead of storing key/value pairs, in
        <code class="calibre21">
         set
        </code>
        s the value is the key.
        <code class="calibre21">
         set
        </code>
        s are useful for storing information in which there is no explicit key, but which you want to have in sorted order without any duplicates, with quick insertion, lookup, and deletion.
       </p>
       <p class="calibre13" id="c18-para-0327">
        The interface supplied by
        <code class="calibre21">
         set
        </code>
        is almost identical to that of
        <code class="calibre21">
         map
        </code>
        . The main difference is that
        <code class="calibre21">
         set
        </code>
        doesn't provide
        <code class="calibre21">
         operator[]
        </code>
        ,
        <code class="calibre21">
         insert_or_assign()
        </code>
        , and
        <code class="calibre21">
         try_emplace()
        </code>
        .
       </p>
       <p class="calibre13" id="c18-para-0328">
        You cannot change the value of elements in a
        <code class="calibre21">
         set
        </code>
        because modifying elements of a
        <code class="calibre21">
         set
        </code>
        while they are in the container would destroy the order.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0114">
        </span>
        <h5 class="calibre35" id="head-5-129">
         set Example: Access Control List
        </h5>
        <p class="calibre13">
         One way to implement basic security on a computer system is through access control lists. Each entity on the system, such as a file or a device, has a list of users with permissions to access that entity. Users can generally be added to and removed from the permissions list for an entity only by users with special privileges. Internally, a
         <code class="calibre21">
          set
         </code>
         provides a nice way to represent the access control list. You could use one
         <code class="calibre21">
          set
         </code>
         for each entity, containing all the usernames that are allowed to access the entity. Here is a class definition for a simple access control list:
        </p>
        <pre class="calibre26" id="c18-code-0133"><code class="calibre21">export class AccessList final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Default constructor</span></code>
<code class="calibre21">        AccessList() = default;</code>
<code class="calibre21">        <span class="color">// Constructor to support uniform initialization.</span></code>
<code class="calibre21">        AccessList(std::initializer_list&lt;std::string_view&gt; users)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_allowed.insert(begin(users), end(users));</code>
<code class="calibre21">        }</code>
<code class="calibre21">        <span class="color">// Adds the user to the permissions list.</span></code>
<code class="calibre21">        void addUser(std::string user)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_allowed.emplace(std::move(user));</code>
<code class="calibre21">        }</code>
<code class="calibre21">        <span class="color">// Removes the user from the permissions list.</span></code>
<code class="calibre21">        void removeUser(const std::string&amp; user)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_allowed.erase(user);</code>
<code class="calibre21">        }</code>
<code class="calibre21">        <span class="color">// Returns true if the user is in the permissions list.</span></code>
<code class="calibre21">        bool isAllowed(const std::string&amp; user) const</code>
<code class="calibre21">        {</code>
<code class="calibre21">            return m_allowed.contains(user);</code>
<code class="calibre21">        }</code>
<span aria-label="743" class="calibre20" epub:type="pagebreak" id="Page_743" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// Returns all the users who have permissions.</span></code>
<code class="calibre21">        const std::set&lt;std::string&gt;&amp; getAllUsers() const</code>
<code class="calibre21">        {</code>
<code class="calibre21">            return m_allowed;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        <span class="color">// Returns a vector of all the users who have permissions.</span></code>
<code class="calibre21">        std::vector&lt;std::string&gt; getAllUsersAsVector() const</code>
<code class="calibre21">        {</code>
<code class="calibre21">            return { begin(m_allowed), end(m_allowed) };</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::set&lt;std::string&gt; m_allowed;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Take a look at the interesting one-line implementation of
         <code class="calibre21">
          getAllUsersAsVector()
         </code>
         . That one line constructs a
         <code class="calibre21">
          vector&lt;string&gt;
         </code>
         to return, by passing a begin and end iterator of
         <code class="calibre21">
          m_allowed
         </code>
         to the
         <code class="calibre21">
          vector
         </code>
         constructor. If you want, you can split this over two lines:
        </p>
        <pre class="calibre26" id="c18-code-0134"><code class="calibre21">std::vector&lt;std::string&gt; users { begin(m_allowed), end(m_allowed) };</code>
<code class="calibre21">return users;</code></pre>
        <p class="calibre13">
         Finally, here is a simple test program:
        </p>
        <pre class="calibre26" id="c18-code-0135"><code class="calibre21">AccessList fileX { "mgregoire", "baduser" };</code>
<code class="calibre21">fileX.addUser("pvw");</code>
<code class="calibre21">fileX.removeUser("baduser");</code>
<code class="calibre21"> </code>
<code class="calibre21">if (fileX.isAllowed("mgregoire")) { println("mgregoire has permissions"); }</code>
<code class="calibre21">if (fileX.isAllowed("baduser")) { println("baduser has permissions"); }</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// C++23 supports formatting/printing of ranges, see <a class="calibre5" href="c02.xhtml">Chapter 2</a>.</span></code>
<code class="calibre21">println("Users with access: {:n:}", fileX.getAllUsers());</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Iterating over the elements of a set.</span></code>
<code class="calibre21">print("Users with access: ");</code>
<code class="calibre21">for (const auto&amp; user : fileX.getAllUsers()) { print("{} ", user); }</code>
<code class="calibre21">println("");</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Iterating over the elements of a vector.</span></code>
<code class="calibre21">print("Users with access: ");</code>
<code class="calibre21">for (const auto&amp; user : fileX.getAllUsersAsVector()) { print("{} ", user); }</code>
<code class="calibre21">println("");</code></pre>
        <p class="calibre13" id="c18-para-0332">
         One of the constructors for
         <code class="calibre21">
          AccessList
         </code>
         uses an
         <code class="calibre21">
          initializer_list
         </code>
         as a parameter so that you can use the uniform initialization syntax, as demonstrated in the test program for initializing
         <code class="calibre21">
          fileX
         </code>
         .
        </p>
        <p class="calibre13">
         The output of this program is as follows:
        </p>
        <pre class="calibre26" id="c18-code-0136"><code class="calibre21">mgregoire has permissions</code>
<code class="calibre21">Users with access: mgregoire, pvw</code>
<code class="calibre21">Users with access: mgregoire pvw</code>
<code class="calibre21">Users with access: mgregoire pvw</code></pre>
        <p class="calibre13">
         <span aria-label="744" class="calibre20" epub:type="pagebreak" id="Page_744" role="doc-pagebreak">
         </span>
         Note that the
         <code class="calibre21">
          m_allowed
         </code>
         data member needs to be a
         <code class="calibre21">
          set
         </code>
         of
         <code class="calibre21">
          std::string
         </code>
         s, and not of
         <code class="calibre21">
          string_view
         </code>
         s. Changing it to a
         <code class="calibre21">
          set
         </code>
         of
         <code class="calibre21">
          string_view
         </code>
         s will introduce problems with dangling pointers. For example, suppose you have the following code:
        </p>
        <pre class="calibre26" id="c18-code-0137"><code class="calibre21">AccessList fileX;</code>
<code class="calibre21">{</code>
<code class="calibre21">    string user { "someuser" };</code>
<code class="calibre21">    fileX.addUser(user);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c18-para-0335">
         This code snippet creates a
         <code class="calibre21">
          string
         </code>
         called
         <code class="calibre21">
          user
         </code>
         and then adds that to the
         <code class="calibre21">
          fileX
         </code>
         access control list. However, the
         <code class="calibre21">
          string
         </code>
         and the call to
         <code class="calibre21">
          addUser()
         </code>
         are inside a set of curly brackets; that is, the
         <code class="calibre21">
          string
         </code>
         has a shorter lifetime than
         <code class="calibre21">
          fileX
         </code>
         . At the closing curly bracket, the
         <code class="calibre21">
          string
         </code>
         goes out of scope and is destroyed. This would leave the
         <code class="calibre21">
          fileX
         </code>
         access control list with a
         <code class="calibre21">
          string_view
         </code>
         pointing to a destroyed
         <code class="calibre21">
          string
         </code>
         , i.e., a dangling pointer! This problem is avoided by using a
         <code class="calibre21">
          set
         </code>
         of
         <code class="calibre21">
          string
         </code>
         s.
        </p>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0115">
       </span>
       <h4 class="calibre29" id="head-4-299">
        multiset
       </h4>
       <p class="calibre13" id="c18-para-0336">
        A
        <code class="calibre21">
         multiset
        </code>
        is to a
        <code class="calibre21">
         set
        </code>
        what a
        <code class="calibre21">
         multimap
        </code>
        is to a
        <code class="calibre21">
         map
        </code>
        . A
        <code class="calibre21">
         multiset
        </code>
        supports all the operations of a
        <code class="calibre21">
         set
        </code>
        , but it allows multiple elements that are equal to each other to be stored in the container simultaneously. An example of a
        <code class="calibre21">
         multiset
        </code>
        is not shown because it's so similar to
        <code class="calibre21">
         set
        </code>
        and
        <code class="calibre21">
         multimap
        </code>
        .
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0116">
      </span>
      <h3 class="calibre27" id="head-3-412">
       Unordered Associative Containers Or Hash Tables
      </h3>
      <p class="calibre13" id="c18-para-0337">
       The Standard Library has support for
       <i class="calibre18">
        unordered associative containers
       </i>
       or
       <i class="calibre18">
        hash tables
       </i>
       . There are four of them:
       <code class="calibre21">
        unordered_map
       </code>
       ,
       <code class="calibre21">
        unordered_multimap
       </code>
       ,
       <code class="calibre21">
        unordered_set
       </code>
       , and
       <code class="calibre21">
        unordered_multiset
       </code>
       . The
       <code class="calibre21">
        map
       </code>
       ,
       <code class="calibre21">
        multimap
       </code>
       ,
       <code class="calibre21">
        set
       </code>
       , and
       <code class="calibre21">
        multiset
       </code>
       containers discussed earlier sort their elements, while these unordered variants do not sort their elements.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0117">
       </span>
       <h4 class="calibre29" id="head-4-300">
        Hash Functions
       </h4>
       <p class="calibre13" id="c18-para-0338">
        The unordered associative containers are hash tables. That is because the implementation makes use of
        <i class="calibre18">
         hash functions
        </i>
        . The implementation usually consists of some kind of array where each element in the array is called a
        <i class="calibre18">
         bucket
        </i>
        . Each bucket has a specific numerical index like 0, 1, 2, up until the last bucket. A hash function transforms a key into a
        <i class="calibre18">
         hash value
        </i>
        , which is then transformed into a
        <i class="calibre18">
         bucket index
        </i>
        . The value associated with that key is then stored in that bucket.
       </p>
       <p class="calibre13" id="c18-para-0339">
        The result of a hash function is not always unique. The situation in which two or more keys hash to the same bucket index is called a
        <i class="calibre18">
         collision
        </i>
        . A collision can occur when different keys result in the same hash value or when different hash values transform to the same bucket index. There are many approaches to handling collisions, including quadratic re-hashing and linear chaining, among others. If you are interested, consult one of the references in the “Algorithms and Data Structures” section in
        <a class="calibre5" href="b02.xhtml">
         Appendix B
        </a>
        . The Standard Library does not specify which collision-handling algorithm is required, but most current implementations have chosen to resolve collisions by linear chaining. With linear chaining, buckets do not directly contain the data values associated with the keys but contain a pointer to a linked list. This linked list contains all the data values for that specific bucket.
        <a class="calibre5" href="c18_split_001.xhtml#c18-fig-0001" id="R_c18-fig-0001">
         Figure 18.1
        </a>
        shows how this works.
       </p>
       <span aria-label="745" class="calibre20" epub:type="pagebreak" id="Page_745" role="doc-pagebreak">
       </span>
       <figure class="calibre36">
        <img alt="A diagram illustrates a process. On the left, there is a column key that has five names Marc G, Nicholas S, Scott K, John D, and Johan G. Include hash function and hash values to the bucket index. On the far right, there is another column named buckets with indices ranging from 000 to 255." class="center" src="images/c18f001.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="c18_split_001.xhtml#R_c18-fig-0001" id="c18-fig-0001" role="doc-backlink">
            <b class="calibre14">
             FIGURE 18.1
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p class="calibre13" id="c18-para-0340">
        In
        <a class="calibre5" href="c18_split_001.xhtml#c18-fig-0001">
         Figure 18.1
        </a>
        , there are two collisions. The first collision is because applying the hash function to the keys “Marc G.” and “John D.” results in the same hash value that maps to bucket index 128. This bucket then points to a linked list containing the keys “Marc G.” and “John D.” together with their associated data values. The second collision is caused by the hash values for “Scott K.” and “Johan G.” mapping to the same bucket index 129.
       </p>
       <p class="calibre13" id="c18-para-0341">
        From
        <a class="calibre5" href="c18_split_001.xhtml#c18-fig-0001">
         Figure 18.1
        </a>
        , it is also clear how lookups based on keys work and what the complexity is. A lookup involves a single hash function call to calculate the hash value. This hash value is then transformed to a bucket index. Once the bucket index is known, one or more equality operations are required to find the right key in the linked list. This shows that lookups can be much faster compared to lookups with normal
        <code class="calibre21">
         map
        </code>
        s, but it all depends on how many collisions there are.
       </p>
       <p class="calibre13" id="c18-para-0342">
        The choice of the hash function is important. A hash function that creates no collisions is known as a
        <i class="calibre18">
         perfect hash
        </i>
        . A perfect hash has a lookup time that is constant; a regular hash has a lookup time that is, on average, close to 1, independent of the number of elements. As the number of collisions increases, the lookup time increases, reducing performance. Collisions can be reduced by increasing the basic hash table size, but you need to take cache sizes into account.
       </p>
       <p class="calibre13" id="c18-para-0343">
        The C++ standard provides hash functions for pointers and all primitive data types such as
        <code class="calibre21">
         bool
        </code>
        ,
        <code class="calibre21">
         char
        </code>
        ,
        <code class="calibre21">
         int
        </code>
        ,
        <code class="calibre21">
         float
        </code>
        ,
        <code class="calibre21">
         double
        </code>
        , and so on. Hash functions are also provided for several Standard Library classes, such as
        <code class="calibre21">
         optional
        </code>
        ,
        <code class="calibre21">
         bitset
        </code>
        ,
        <code class="calibre21">
         unique_ptr
        </code>
        ,
        <code class="calibre21">
         shared_ptr
        </code>
        ,
        <code class="calibre21">
         string
        </code>
        ,
        <code class="calibre21">
         string_view
        </code>
        ,
        <code class="calibre21">
         vector&lt;bool&gt;
        </code>
        , and more. If there is no standard hash function available for the type of keys you want to use, then you have to implement your own hash function. Creating a perfect hash is a nontrivial exercise, even when the set of keys is fixed and known. It requires deep mathematical analysis. Even creating a non-perfect one, but one that is good enough and has decent performance, is still challenging. It's outside the scope of this book to explain the mathematics behind hash functions in detail. Instead, only an example of a simple hash function is given.
       </p>
       <p class="calibre13">
        <span aria-label="746" class="calibre20" epub:type="pagebreak" id="Page_746" role="doc-pagebreak">
        </span>
        The following code demonstrates how to write a custom hash function. The code defines a class
        <code class="calibre21">
         IntWrapper
        </code>
        that just wraps a single integer. An
        <code class="calibre21">
         operator==
        </code>
        is provided because that's a requirement for keys used in unordered associative containers.
       </p>
       <pre class="calibre26" id="c18-code-0138"><code class="calibre21">class IntWrapper</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit IntWrapper(int i) : m_wrappedInt { i } {}</code>
<code class="calibre21">        int getValue() const { return m_wrappedInt; }</code>
<code class="calibre21">        bool operator==(const IntWrapper&amp;) const = default;<span class="color">// = default since C++20</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_wrappedInt;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        To write the actual hash function for
        <code class="calibre21">
         IntWrapper
        </code>
        , you write a specialization of the
        <code class="calibre21">
         std::hash
        </code>
        class template for
        <code class="calibre21">
         IntWrapper
        </code>
        . The
        <code class="calibre21">
         std::hash
        </code>
        class template is defined in
        <code class="calibre21">
         &lt;functional&gt;
        </code>
        . This specialization needs an implementation of the function call operator that calculates and returns the hash of a given
        <code class="calibre21">
         IntWrapper
        </code>
        instance. For this example, the request is simply forwarded to the standard hash function for integers:
       </p>
       <pre class="calibre26" id="c18-code-0139"><code class="calibre21">namespace std</code>
<code class="calibre21">{</code>
<code class="calibre21">    template&lt;&gt; struct hash&lt;IntWrapper&gt;</code>
<code class="calibre21">    {</code>
<code class="calibre21">        size_t operator()(const IntWrapper&amp; x) const {</code>
<code class="calibre21">            return std::hash&lt;int&gt;{}(x.getValue());</code>
<code class="calibre21">        }</code>
<code class="calibre21">    };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c18-para-0346">
        Note that you normally are not allowed to put anything in the
        <code class="calibre21">
         std
        </code>
        namespace; however,
        <code class="calibre21">
         std
        </code>
        class template specializations are an exception to this rule. The implementation of the function call operator is just one line. It creates an instance of the standard hash function for integers—
        <code class="calibre21">
         std::hash&lt;int&gt;{}
        </code>
        —and then calls the function call operator on it with
        <code class="calibre21">
         x.getValue()
        </code>
        as argument. Note that this forwarding works in this example because
        <code class="calibre21">
         IntWrapper
        </code>
        contains just one data member, an integer. If the class contained multiple data members, then a hash value would need to be calculated taking all those data members into account; however, those details fall outside the scope of this book.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0118">
       </span>
       <h4 class="calibre29" id="head-4-301">
        unordered_map
       </h4>
       <p class="calibre13">
        <code class="calibre21">
         unordered_map
        </code>
        is defined in
        <code class="calibre21">
         &lt;unordered_map&gt;
        </code>
        as a class template:
       </p>
       <pre class="calibre26" id="c18-code-0140"><code class="calibre21">template &lt;typename Key,</code>
<code class="calibre21">          typename T,</code>
<code class="calibre21">          typename Hash = hash&lt;Key&gt;,</code>
<code class="calibre21">          typename Pred = std::equal_to&lt;Key&gt;,</code>
<code class="calibre21">          typename Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;</code>
<code class="calibre21">    class unordered_map;</code></pre>
       <p class="calibre13">
        There are five template type parameters: the key type, the value type, the hash type, the equality comparator type, and the allocator type. The last three parameters have default values. The most important parameters are the first two. As with
        <code class="calibre21">
         map
        </code>
        s, uniform initialization can be used to initialize
        <span aria-label="747" class="calibre20" epub:type="pagebreak" id="Page_747" role="doc-pagebreak">
        </span>
        <span aria-label="748" class="calibre20" epub:type="pagebreak" id="Page_748" role="doc-pagebreak">
        </span>
        an
        <code class="calibre21">
         unordered_map
        </code>
        . Iterating over the elements is also similar to
        <code class="calibre21">
         map
        </code>
        s, as shown in the following example.
       </p>
       <pre class="calibre26" id="c18-code-0141"><code class="calibre21">unordered_map&lt;int, string&gt; m {</code>
<code class="calibre21">    {1, "Item 1"}, {2, "Item 2"}, {3, "Item 3"}, {4, "Item 4"}</code>
<code class="calibre21">};</code>
<code class="calibre21"><span class="color">// Using C++23 support for formatting/printing ranges.</span></code>
<code class="calibre21">println("{}", m);</code>
<code class="calibre21"><span class="color">// Using structured bindings.</span></code>
<code class="calibre21">for (const auto&amp; [key, value] : m) { print("{} = {}, ", key, value); }</code>
<code class="calibre21">println("");</code>
<code class="calibre21"><span class="color">// Without structured bindings.</span></code>
<code class="calibre21">for (const auto&amp; p : m) { print("{} = {}, ", p.first, p.second); }</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0142"><code class="calibre21">{4: "Item 4", 3: "Item 3", 2: "Item 2", 1: "Item 1"}</code>
<code class="calibre21">4 = Item 4, 3 = Item 3, 2 = Item 2, 1 = Item 1,</code>
<code class="calibre21">4 = Item 4, 3 = Item 3, 2 = Item 2, 1 = Item 1,</code></pre>
       <p class="calibre13" id="c18-para-0350">
        The following table summarizes the differences between
        <code class="calibre21">
         map
        </code>
        and
        <code class="calibre21">
         unordered_map
        </code>
        . A filled box (
        <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
        ) means the container supports that operation, while an empty box (
        <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
        ) means the operation is not supported.
       </p>
       <table border="1" class="calibre31">
        <thead class="calibre32">
         <tr class="calibre33">
          <th class="left" scope="col">
           OPERATION
          </th>
          <th class="left" scope="col">
           map
          </th>
          <th class="left" scope="col">
           unordered_map
          </th>
         </tr>
        </thead>
        <tbody class="calibre34">
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            at()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            begin()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            begin(n)
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            bucket()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            bucket_count()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            bucket_size()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            cbegin()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            cbegin(n)
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            cend()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            cend(n)
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            clear()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            contains()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            count()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            crbegin()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            crend()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            emplace()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            emplace:hint()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            empty()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            end()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            end(n)
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            equal_range()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            erase()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            extract()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            find()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            insert()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            insert_or_assign()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            insert_range()
           </span>
           (C++23)
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            iterator / const_iterator
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            load_factor()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            local_iterator / const_local_iterator
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            lower_bound()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            max_bucket_count()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            max_load_factor()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            max_size()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            merge()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            operator[]
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            rbegin()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            rehash()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            rend()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            reserve()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            reverse_iterator / const_reverse_iterator
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            size()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            swap()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            try_emplace()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
         </tr>
         <tr class="calibre33">
          <td class="calibre40">
           <span class="calibre21">
            upper_bound()
           </span>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square1.png"/>
          </td>
          <td class="bgcolor">
           <img alt="" class="calibre15" role="presentation" src="images/square.png"/>
           <span aria-label="749" class="calibre20" epub:type="pagebreak" id="Page_749" role="doc-pagebreak">
           </span>
          </td>
         </tr>
        </tbody>
       </table>
       <p class="calibre13" id="c18-para-0352">
        As with
        <code class="calibre21">
         map
        </code>
        , all keys in an
        <code class="calibre21">
         unordered_map
        </code>
        must be unique. The preceding table includes a number of hash-specific member functions. For example,
        <code class="calibre21">
         load_factor()
        </code>
        returns the average number of elements per bucket to give you an indication of the number of collisions. The
        <code class="calibre21">
         bucket_count()
        </code>
        member function returns the number of buckets in the container. It also provides a
        <code class="calibre21">
         local_iterator
        </code>
        and
        <code class="calibre21">
         const_local_iterator
        </code>
        , allowing you to iterate over the elements in a single bucket; however, these may not be used to iterate across buckets. The
        <code class="calibre21">
         bucket(key)
        </code>
        member function returns the index of the bucket that contains the given key;
        <code class="calibre21">
         begin(n)
        </code>
        returns a
        <code class="calibre21">
         local_iterator
        </code>
        referring to the first element in the bucket with index
        <code class="calibre21">
         n
        </code>
        , and
        <code class="calibre21">
         end(n)
        </code>
        returns a
        <code class="calibre21">
         local_iterator
        </code>
        referring to one-past-the-last element in the bucket with index
        <code class="calibre21">
         n
        </code>
        . The example in the next section demonstrates how to use some of these member functions.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c18-sec-0119">
        </span>
        <h5 class="calibre35" id="head-5-130">
         unordered_map Example: Phone Book
        </h5>
        <p class="calibre13">
         The following example uses an
         <code class="calibre21">
          unordered_map
         </code>
         to represent a phone book. The name of a person is the key, while the phone number is the value associated with that key.
        </p>
        <pre class="calibre26" id="c18-code-0143"><code class="calibre21">void printMap(const auto&amp; m)  <span class="color">// Abbreviated function template</span></code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto&amp; [key, value] : m) {</code>
<code class="calibre21">        println("{} (Phone: {})", key, value);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    println("-------");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Create a hash table.</span></code>
<code class="calibre21">    unordered_map&lt;string, string&gt; phoneBook {</code>
<code class="calibre21">        { "Marc G.", "123-456789" },</code>
<code class="calibre21">        { "Scott K.", "654-987321" } };</code>
<code class="calibre21">    printMap(phoneBook);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Add/remove some phone numbers.</span></code>
<code class="calibre21">    phoneBook.insert(make_pair("John D.", "321-987654"));</code>
<code class="calibre21">    phoneBook["Johan G."] = "963-258147";</code>
<code class="calibre21">    phoneBook["Freddy K."] = "999-256256";</code>
<code class="calibre21">    phoneBook.erase("Freddy K.");</code>
<code class="calibre21">    printMap(phoneBook);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Find the bucket index for a specific key.</span></code>
<code class="calibre21">    const size_t bucket { phoneBook.bucket("Marc G.") };</code>
<code class="calibre21">    println("Marc G. is in bucket {} containing the following {} names:",</code>
<code class="calibre21">        bucket, phoneBook.bucket_size(bucket));</code>
<code class="calibre21">    <span class="color">// Get begin and end iterators for the elements in this bucket.</span></code>
<span aria-label="750" class="calibre20" epub:type="pagebreak" id="Page_750" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// 'auto' is used here. The compiler deduces the type of</span></code>
<code class="calibre21">    <span class="color">// both as unordered_map&lt;string, string&gt;::const_local_iterator</span></code>
<code class="calibre21">    auto localBegin { phoneBook.cbegin(bucket) };</code>
<code class="calibre21">    auto localEnd { phoneBook.cend(bucket) };</code>
<code class="calibre21">    for (auto iter { localBegin }; iter != localEnd; ++iter) {</code>
<code class="calibre21">        println("\t{} (Phone: {})", iter-&gt;first, iter-&gt;second);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    println("-------");</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Print some statistics about the hash table</span></code>
<code class="calibre21">    println("There are {} buckets.", phoneBook.bucket_count());</code>
<code class="calibre21">    println("Average number of elements in a bucket is {}.",</code>
<code class="calibre21">        phoneBook.load_factor());</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         A possible output is as follows. Note that the output can be different on different systems, because it depends on the implementation of both the hash function and the
         <code class="calibre21">
          unordered_map
         </code>
         itself being used.
        </p>
        <pre class="calibre26" id="c18-code-0144"><code class="calibre21">Scott K. (Phone: 654-987321)</code>
<code class="calibre21">Marc G. (Phone: 123-456789)</code>
<code class="calibre21">-------</code>
<code class="calibre21">Scott K. (Phone: 654-987321)</code>
<code class="calibre21">Marc G. (Phone: 123-456789)</code>
<code class="calibre21">Johan G. (Phone: 963-258147)</code>
<code class="calibre21">John D. (Phone: 321-987654)</code>
<code class="calibre21">-------</code>
<code class="calibre21">Marc G. is in bucket 1 containing the following 2 names:</code>
<code class="calibre21">        Scott K. (Phone: 654-987321)</code>
<code class="calibre21">        Marc G. (Phone: 123-456789)</code>
<code class="calibre21">-------</code>
<code class="calibre21">There are 8 buckets.</code>
<code class="calibre21">Average number of elements in a bucket is 0.5</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0120">
       </span>
       <h4 class="calibre29" id="head-4-302">
        unordered_multimap
       </h4>
       <p class="calibre13">
        An
        <code class="calibre21">
         unordered_multimap
        </code>
        is an
        <code class="calibre21">
         unordered_map
        </code>
        that allows multiple elements with the same key. Their interfaces are almost identical, with the following differences:
       </p>
       <ul class="check" id="c18-list-0017">
        <li class="calibre9" id="c18-li-0072">
         <code class="calibre21">
          unordered_multimap
         </code>
         s do not provide
         <code class="calibre21">
          operator[]
         </code>
         and
         <code class="calibre21">
          at()
         </code>
         . The semantics of these do not make sense if there can be multiple elements with a single key.
        </li>
        <li class="calibre9" id="c18-li-0073">
         Inserts on
         <code class="calibre21">
          unordered_multimap
         </code>
         s always succeed. Thus, the
         <code class="calibre21">
          unordered_multimap::insert()
         </code>
         member function that adds a single element returns just an
         <code class="calibre21">
          iterator
         </code>
         instead of a
         <code class="calibre21">
          pair
         </code>
         .
        </li>
        <li class="calibre9" id="c18-li-0074">
         The
         <code class="calibre21">
          insert_or_assign()
         </code>
         and
         <code class="calibre21">
          try_emplace()
         </code>
         member functions supported by
         <code class="calibre21">
          unordered_map
         </code>
         are not supported by an
         <code class="calibre21">
          unordered_multimap
         </code>
         .
        </li>
       </ul>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c18-para-0356">
           <b class="calibre14">
            NOTE
           </b>
           <code class="calibre21">
            unordered_multimap
           </code>
           <i class="calibre18">
            s allow you to insert identical key/value pairs. If you want to avoid this redundancy, you must check explicitly before inserting a new element
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c18-para-0357">
        <span aria-label="751" class="calibre20" epub:type="pagebreak" id="Page_751" role="doc-pagebreak">
        </span>
        As discussed earlier with
        <code class="calibre21">
         multimap
        </code>
        s, looking up elements in
        <code class="calibre21">
         unordered_multimap
        </code>
        s cannot be done using
        <code class="calibre21">
         operator[]
        </code>
        because it is not provided. You can use
        <code class="calibre21">
         find()
        </code>
        , but it returns an iterator referring to any one of the elements with a given key (not necessarily the first element with that key). Instead, it's best to use the
        <code class="calibre21">
         equal_range()
        </code>
        member function, which returns a pair of iterators: one referring to the first element matching a given key, and one referring to one-past-the-last element matching that key. The use of
        <code class="calibre21">
         equal_range()
        </code>
        is the same as discussed for
        <code class="calibre21">
         multimap
        </code>
        s, so you can look at the example given for
        <code class="calibre21">
         multimap
        </code>
        s to see how it works.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0122">
       </span>
       <h4 class="calibre29" id="head-4-303">
        unordered_set/unordered_multiset
       </h4>
       <p class="calibre13" id="c18-para-0358">
        <code class="calibre21">
         &lt;unordered_set&gt;
        </code>
        defines
        <code class="calibre21">
         unordered_set
        </code>
        and
        <code class="calibre21">
         unordered_multiset
        </code>
        , which are similar to
        <code class="calibre21">
         set
        </code>
        and
        <code class="calibre21">
         multiset
        </code>
        , respectively, except that they do not sort their keys but use a hash function. The differences between
        <code class="calibre21">
         unordered_set
        </code>
        and
        <code class="calibre21">
         unordered_map
        </code>
        are similar to the differences between
        <code class="calibre21">
         set
        </code>
        and
        <code class="calibre21">
         map
        </code>
        as discussed earlier in this chapter, so they are not discussed in detail here. Consult a Standard Library Reference for a thorough summary of
        <code class="calibre21">
         unordered_set
        </code>
        and
        <code class="calibre21">
         unordered_multiset
        </code>
        operations.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0123">
      </span>
      <h3 class="calibre27" id="head-3-413">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Flat Set and Flat Map Associative Container Adapters
      </h3>
      <p class="calibre13">
       C++23 introduces the following new container adapters:
      </p>
      <ul class="check" id="c18-list-0018">
       <li class="calibre9" id="c18-li-0075">
        <code class="calibre21">
         std::flat_set
        </code>
        and
        <code class="calibre21">
         flat_multiset
        </code>
        defined in
        <code class="calibre21">
         &lt;flat_set&gt;
        </code>
       </li>
       <li class="calibre9" id="c18-li-0076">
        <code class="calibre21">
         std::flat_map
        </code>
        and
        <code class="calibre21">
         flat_multimap
        </code>
        defined in
        <code class="calibre21">
         &lt;flat_map&gt;
        </code>
       </li>
      </ul>
      <p class="calibre13" id="c18-para-0361">
       These are adapters providing an associative container interface on top of sequential containers.
       <code class="calibre21">
        flat_set
       </code>
       and
       <code class="calibre21">
        flat_map
       </code>
       require unique keys, just as
       <code class="calibre21">
        set
       </code>
       and
       <code class="calibre21">
        map
       </code>
       , while
       <code class="calibre21">
        flat_multiset
       </code>
       and
       <code class="calibre21">
        flat_multimap
       </code>
       support duplicate keys, just as
       <code class="calibre21">
        multiset
       </code>
       and
       <code class="calibre21">
        multimap
       </code>
       . They all store their data sorted on the keys using
       <code class="calibre21">
        std::less
       </code>
       as the default comparator.
       <code class="calibre21">
        flat_set
       </code>
       and
       <code class="calibre21">
        flat_multiset
       </code>
       provide for fast retrieval of a key, while
       <code class="calibre21">
        flat_map
       </code>
       and
       <code class="calibre21">
        flat_multimap
       </code>
       provide for fast retrieval of a value based on a key. A
       <code class="calibre21">
        flat_set
       </code>
       and a
       <code class="calibre21">
        flat_multiset
       </code>
       require one underlying sequential container to store their keys. A
       <code class="calibre21">
        flat_map
       </code>
       and a
       <code class="calibre21">
        flat_multimap
       </code>
       require two underlying containers, one to store the keys and another one to store the values. The underlying container must support random-access iterators, such as
       <code class="calibre21">
        vector
       </code>
       and
       <code class="calibre21">
        deque
       </code>
       . By default,
       <code class="calibre21">
        vector
       </code>
       is used.
      </p>
      <p class="calibre13" id="c18-para-0362">
       All flat associative container adapters have an interface similar to their ordered counterparts, except that the flat container adapters are not
       <i class="calibre18">
        node-based
       </i>
       data structures and thus don't have any concept of node handles as discussed earlier in this chapter in the context of the ordered associative containers. Another difference is that the flat variants provide random-access iterators, while the ordered counterparts provide only bidirectional iterators.
      </p>
      <p class="calibre13" id="c18-para-0363">
       With the addition of these flat container adapters, the Standard Library now provides three variants of each associative container type; e.g., there are now three map containers:
       <code class="calibre21">
        map
       </code>
       ,
       <code class="calibre21">
        unordered_map
       </code>
       , and
       <code class="calibre21">
        flat_map
       </code>
       . All three basically work in a similar fashion, but they store their data in drastically different data structures and thus have different time- and space-efficiency. Because the flat associative container adapters store their data sorted in sequential containers, they all have linear time complexity for adding and removing elements, which can potentially be slower than adding and removing elements from ordered and unordered containers. Lookups have logarithmic complexity, just as the ordered associative containers. However, for the flat variants, lookups and especially iteration
       <span aria-label="752" class="calibre20" epub:type="pagebreak" id="Page_752" role="doc-pagebreak">
       </span>
       over the elements are more efficient than for the ordered ones because the former store their data in sequential containers and thus have a much more efficient and cache-friendly memory layout. They also need less memory per element compared to the ordered or unordered variants. Which one of the three flavors per type to choose for a specific use case depends on the exact requirements of your use case. If performance is important, then I recommend profiling all three of them to find out which one is best suited for a specific use. Profiling is explained in
       <a class="calibre5" href="c29.xhtml">
        Chapter 29
       </a>
       , “Writing Efficient C++.”
      </p>
      <p class="calibre13">
       The flat associative container adapters are often just drop-in replacements for their ordered counterparts. For example, the access control list example from earlier has a data member called
       <code class="calibre21">
        m_allowed
       </code>
       of type
       <code class="calibre21">
        set&lt;string&gt;
       </code>
       , an ordered associative container. The code can easily be changed to use a
       <code class="calibre21">
        flat_set
       </code>
       instead. Two changes are necessary. First, the type of
       <code class="calibre21">
        m_allowed
       </code>
       is changed to the following:
      </p>
      <pre class="calibre26" id="c18-code-0145"><code class="calibre21">std::<b class="calibre14">flat_set</b>&lt;std::string&gt; m_allowed;</code></pre>
      <p class="calibre13">
       Second, the return type of
       <code class="calibre21">
        getAllUsers()
       </code>
       is changed to a
       <code class="calibre21">
        flat_set
       </code>
       :
      </p>
      <pre class="calibre26" id="c18-code-0146"><code class="calibre21">const std::<b class="calibre14">flat_set</b>&lt;std::string&gt;&amp; getAllUsers() const { return m_allowed; }</code></pre>
      <p class="calibre13" id="c18-para-0366">
       Everything else remains the same.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0124">
      </span>
      <h3 class="calibre27" id="head-3-414">
       Performance of Associative Containers
      </h3>
      <p class="calibre13" id="c18-para-0367">
       As is clear from this section, the C++ Standard Library contains several different associative containers. How do you know which one to use for a certain task? If iterating over the contents of an associative container is important for your use case, then the flat associative container adapters have the best performance, because of the way they store their data in continuous memory. If other operations are more important for you, then the unordered associative containers are usually faster compared to the ordered ones. However, if performance is really important, then the only way to decide on the correct container is by benchmarking all of them for your specific use case. Usually, though, you can just pick the one that is easier to work with. To use the ordered versions with your own class types, you must implement comparison operations for your class, while for the unordered versions, you need to write a hash function. The latter is usually harder to implement.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-203" class="calibre2">
     <span class="calibre" id="c18-sec-0125">
     </span>
     <h2 class="calibre6" id="head-2-203">
      OTHER CONTAINERS
     </h2>
     <p class="calibre13" id="c18-para-0368">
      There are several other features of the C++ language and the Standard Library that are somewhat related to containers, including standard C-style arrays,
      <code class="calibre21">
       string
      </code>
      s, streams, and
      <code class="calibre21">
       bitset
      </code>
      .
     </p>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0126">
      </span>
      <h3 class="calibre27" id="head-3-415">
       Standard C-Style Arrays
      </h3>
      <p class="calibre13" id="c18-para-0369">
       Recall that raw pointers are bona fide iterators because they support the required operations. This point is more than just a piece of trivia. It means that you can treat standard C-style arrays as Standard Library containers by using pointers to their elements as iterators. Standard C-style arrays, of course, don't provide member functions like
       <code class="calibre21">
        size()
       </code>
       ,
       <code class="calibre21">
        empty()
       </code>
       ,
       <code class="calibre21">
        insert()
       </code>
       , and
       <code class="calibre21">
        erase()
       </code>
       , so they aren't true Standard Library containers. Nevertheless, because they do support iterators through pointers, you can use them in the algorithms described in
       <a class="calibre5" href="c20.xhtml">
        Chapter 20
       </a>
       and in some of the member functions described in this chapter.
      </p>
      <p class="calibre13">
       <span aria-label="753" class="calibre20" epub:type="pagebreak" id="Page_753" role="doc-pagebreak">
       </span>
       For example, you could copy all the elements of a standard C-style array into a
       <code class="calibre21">
        vector
       </code>
       using the
       <code class="calibre21">
        insert()
       </code>
       member function of a
       <code class="calibre21">
        vector
       </code>
       that takes an iterator range from any container. This
       <code class="calibre21">
        insert()
       </code>
       member function's prototype looks like this:
      </p>
      <pre class="calibre26" id="c18-code-0147"><code class="calibre21">template &lt;typename InputIterator&gt; iterator insert(const_iterator position,</code>
<code class="calibre21">    InputIterator first, InputIterator last);</code></pre>
      <p class="calibre13">
       If you want to use a standard C-style
       <code class="calibre21">
        int
       </code>
       array as the source, then the template type parameter
       <code class="calibre21">
        InputIterator
       </code>
       becomes
       <code class="calibre21">
        int*
       </code>
       . Here is a full example:
      </p>
      <pre class="calibre26" id="c18-code-0148"><code class="calibre21">const size_t count { 10 };</code>
<code class="calibre21">int values[count];     <span class="color">// standard C-style array</span></code>
<code class="calibre21"><span class="color">// Initialize each element of the array to the value of its index.</span></code>
<code class="calibre21">for (int i { 0 }; i &lt; count; ++i) { values[i] = i; }</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Insert the contents of the array at the end of a vector.</span></code>
<code class="calibre21">vector&lt;int&gt; vec;</code>
<code class="calibre21">vec.insert(end(vec), values, values + count);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Print the contents of the vector.</span></code>
<code class="calibre21">println("{:n} ", vec);</code></pre>
      <p class="calibre13" id="c18-para-0372">
       Note that the iterator referring to the first element of the array is the address of the first element, which is
       <code class="calibre21">
        values
       </code>
       in this case. The name of an array alone is interpreted as the address of the first element. The iterator referring to the end must be one-past-the-last element, so it's the address of the first element plus
       <code class="calibre21">
        count
       </code>
       , or
       <code class="calibre21">
        values+count
       </code>
       .
      </p>
      <p class="calibre13">
       It's easier to use
       <code class="calibre21">
        std::begin()
       </code>
       or
       <code class="calibre21">
        cbegin()
       </code>
       to get an iterator to the first element of a statically allocated C-style array not accessed through pointers, and
       <code class="calibre21">
        std::end()
       </code>
       or
       <code class="calibre21">
        cend()
       </code>
       to get an iterator to one-past-the-last element of such an array. For example, the call to
       <code class="calibre21">
        insert()
       </code>
       in the previous example can be written as follows:
      </p>
      <pre class="calibre26" id="c18-code-0149"><code class="calibre21">vec.insert(end(vec), cbegin(values), cend(values));</code></pre>
      <p class="calibre13">
       Starting with C++23, this can be written more elegantly using
       <code class="calibre21">
        append_range()
       </code>
       :
      </p>
      <pre class="calibre26" id="c18-code-0150"><code class="calibre21">vec.append_range(values);</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0376">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Functions such as
          </i>
          <code class="calibre21">
           std::begin()
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           end()
          </code>
          <i class="calibre18">
           work only on statically allocated C-style arrays not accessed through pointers. They do not work if pointers are involved or with dynamically allocated C-style arrays.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0128">
      </span>
      <h3 class="calibre27" id="head-3-416">
       Strings
      </h3>
      <p class="calibre13" id="c18-para-0377">
       You can think of a
       <code class="calibre21">
        string
       </code>
       as a sequential container of characters. Thus, it shouldn't be surprising to learn that a C++
       <code class="calibre21">
        string
       </code>
       is a full-fledged sequential container. It has
       <code class="calibre21">
        begin()
       </code>
       and
       <code class="calibre21">
        end()
       </code>
       member functions that return iterators into the
       <code class="calibre21">
        string
       </code>
       ; and it has
       <code class="calibre21">
        insert()
       </code>
       ,
       <code class="calibre21">
        push_back()
       </code>
       ,
       <code class="calibre21">
        erase()
       </code>
       ,
       <code class="calibre21">
        size()
       </code>
       , and
       <code class="calibre21">
        empty()
       </code>
       member functions, and all the rest of the sequential container basics. It resembles a
       <code class="calibre21">
        vector
       </code>
       quite closely, even providing the member functions
       <code class="calibre21">
        reserve()
       </code>
       and
       <code class="calibre21">
        capacity()
       </code>
       .
      </p>
      <p class="calibre13">
       <span aria-label="754" class="calibre20" epub:type="pagebreak" id="Page_754" role="doc-pagebreak">
       </span>
       You can use
       <code class="calibre21">
        string
       </code>
       as a Standard Library container just as you would use
       <code class="calibre21">
        vector
       </code>
       . Here is an example:
      </p>
      <pre class="calibre26" id="c18-code-0151"><code class="calibre21">string myString;</code>
<code class="calibre21">myString.insert(cend(myString), 'h');</code>
<code class="calibre21">myString.insert(cend(myString), 'e');</code>
<code class="calibre21">myString.push_back('l');</code>
<code class="calibre21">myString.push_back('l');</code>
<code class="calibre21">myString.push_back('o');</code>
<code class="calibre21"> </code>
<code class="calibre21">for (const auto&amp; letter : myString) {</code>
<code class="calibre21">    print("{}", letter);</code>
<code class="calibre21">}</code>
<code class="calibre21">println("");</code>
<code class="calibre21"> </code>
<code class="calibre21">for (auto it { cbegin(myString) }; it != cend(myString); ++it) {</code>
<code class="calibre21">    print("{}", *it);</code>
<code class="calibre21">}</code>
<code class="calibre21">println("");</code></pre>
      <p class="calibre13" id="c18-para-0379">
       In addition to the Standard Library sequential container member functions,
       <code class="calibre21">
        string
       </code>
       s provide a host of useful member functions and
       <code class="calibre21">
        friend
       </code>
       functions. The
       <code class="calibre21">
        string
       </code>
       interface is actually quite a good example of a cluttered interface, one of the design pitfalls discussed in
       <a class="calibre5" href="c06.xhtml">
        Chapter 6
       </a>
       , “Designing for Reuse.” The
       <code class="calibre21">
        string
       </code>
       class is discussed in detail in
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0129">
      </span>
      <h3 class="calibre27" id="head-3-417">
       Streams
      </h3>
      <p class="calibre13" id="c18-para-0380">
       Input and output streams are not containers in the traditional sense because they do not store elements. However, they can be considered sequences of elements and as such share some characteristics with Standard Library containers. C++ streams do not provide any Standard Library–related member functions directly, but the Standard Library supplies special iterators called
       <code class="calibre21">
        istream_iterator
       </code>
       and
       <code class="calibre21">
        ostream_iterator
       </code>
       that allow you to “iterate” through input and output streams respectively.
       <a class="calibre5" href="c17.xhtml">
        Chapter 17
       </a>
       explains how to use them.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c18-sec-0130">
      </span>
      <h3 class="calibre27" id="head-3-418">
       bitset
      </h3>
      <p class="calibre13" id="c18-para-0381">
       A
       <code class="calibre21">
        bitset
       </code>
       is a fixed-length abstraction of a sequence of bits. A bit can represent only two values, 1 and 0, which can be referred to as on/off, true/false, and so on. A
       <code class="calibre21">
        bitset
       </code>
       also uses the terminology
       <i class="calibre18">
        set
       </i>
       and
       <i class="calibre18">
        unset
       </i>
       . You can
       <i class="calibre18">
        toggle
       </i>
       or
       <i class="calibre18">
        flip
       </i>
       a bit from one value to the other.
      </p>
      <p class="calibre13" id="c18-para-0382">
       A
       <code class="calibre21">
        bitset
       </code>
       is not a true Standard Library container: it's of fixed size, it's not parametrized on an element type, and it doesn't support iteration. However, it's a useful utility class, which is often lumped with the containers, so a brief introduction is provided here. Consult a Standard Library Reference for a thorough summary of the
       <code class="calibre21">
        bitset
       </code>
       operations.
      </p>
      <p class="calibre13">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c18-para-0384">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Starting with C++23,
          </i>
          <code class="calibre21">
           bitset
          </code>
          <i class="calibre18">
           is a
          </i>
          <code class="calibre21">
           constexpr
          </code>
          <i class="calibre18">
           class, and so can be used at compile time.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <span aria-label="755" class="calibre20" epub:type="pagebreak" id="Page_755" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0132">
       </span>
       <h4 class="calibre29" id="head-4-304">
        bitset Basics
       </h4>
       <p class="calibre13" id="c18-para-0385">
        A
        <code class="calibre21">
         bitset
        </code>
        , defined in
        <code class="calibre21">
         &lt;bitset&gt;
        </code>
        , is parametrized on the number of bits it stores. The default constructor initializes all fields of a
        <code class="calibre21">
         bitset
        </code>
        to 0. An alternative constructor creates a
        <code class="calibre21">
         bitset
        </code>
        from a
        <code class="calibre21">
         string
        </code>
        of
        <code class="calibre21">
         0
        </code>
        and
        <code class="calibre21">
         1
        </code>
        characters.
       </p>
       <p class="calibre13" id="c18-para-0386">
        You can adjust the value of individual bits with the
        <code class="calibre21">
         set()
        </code>
        ,
        <code class="calibre21">
         reset()
        </code>
        , and
        <code class="calibre21">
         flip()
        </code>
        member functions, and you can access and set individual fields with an overloaded
        <code class="calibre21">
         operator[]
        </code>
        . Note that
        <code class="calibre21">
         operator[]
        </code>
        on a non-
        <code class="calibre21">
         const
        </code>
        object returns a proxy object to which you can assign a Boolean value, call
        <code class="calibre21">
         flip()
        </code>
        , or complement with
        <code class="calibre21">
         operator~
        </code>
        . You can also access individual fields with the
        <code class="calibre21">
         test()
        </code>
        member function. Bits are accessed using a zero-based index. Finally, you can convert a
        <code class="calibre21">
         bitset
        </code>
        to a
        <code class="calibre21">
         string
        </code>
        of
        <code class="calibre21">
         0
        </code>
        and
        <code class="calibre21">
         1
        </code>
        characters using
        <code class="calibre21">
         to_string()
        </code>
        .
       </p>
       <p class="calibre13">
        Here is a small example:
       </p>
       <pre class="calibre26" id="c18-code-0152"><code class="calibre21">bitset&lt;10&gt; myBitset;</code>
<code class="calibre21"> </code>
<code class="calibre21">myBitset.set(3);</code>
<code class="calibre21">myBitset.set(6);</code>
<code class="calibre21">myBitset[8] = true;</code>
<code class="calibre21">myBitset[9] = myBitset[3];</code>
<code class="calibre21"> </code>
<code class="calibre21">if (myBitset.test(3)) { println("Bit 3 is set!"); }</code>
<code class="calibre21">println("{}", myBitset.to_string());</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0153"><code class="calibre21">Bit 3 is set!</code>
<code class="calibre21">1101001000</code></pre>
       <p class="calibre13" id="c18-para-0389">
        Note that the leftmost character in the output
        <code class="calibre21">
         string
        </code>
        is the highest numbered bit. This corresponds to our intuitions about binary number representations, where the low-order bit representing 2
        <sup class="calibre22">
         0
        </sup>
        = 1 is the rightmost bit in the printed representation.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0133">
       </span>
       <h4 class="calibre29" id="head-4-305">
        Bitwise Operators
       </h4>
       <p class="calibre13">
        In addition to the basic bit manipulation routines, a
        <code class="calibre21">
         bitset
        </code>
        provides implementations of all the bitwise operators:
        <code class="calibre21">
         &amp;
        </code>
        ,
        <code class="calibre21">
         |
        </code>
        ,
        <code class="calibre21">
         ^
        </code>
        ,
        <code class="calibre21">
         ~
        </code>
        ,
        <code class="calibre21">
         &lt;&lt;
        </code>
        ,
        <code class="calibre21">
         &gt;&gt;
        </code>
        ,
        <code class="calibre21">
         &amp;=
        </code>
        ,
        <code class="calibre21">
         |=
        </code>
        ,
        <code class="calibre21">
         ^=
        </code>
        ,
        <code class="calibre21">
         &lt;&lt;=
        </code>
        , and
        <code class="calibre21">
         &gt;&gt;=
        </code>
        . They behave just as they would on a “real” sequence of bits. Here is an example:
       </p>
       <pre class="calibre26" id="c18-code-0154"><code class="calibre21">auto str1 { "0011001100" };</code>
<code class="calibre21">auto str2 { "0000111100" };</code>
<code class="calibre21">bitset&lt;10&gt; bitsOne { str1 };</code>
<code class="calibre21">bitset&lt;10&gt; bitsTwo { str2 };</code>
<code class="calibre21"> </code>
<code class="calibre21">auto bitsThree { bitsOne &amp; bitsTwo };</code>
<code class="calibre21">println("{}", bitsThree.to_string());</code>
<code class="calibre21">bitsThree &lt;&lt;= 4;</code>
<code class="calibre21">println("{}", bitsThree.to_string());</code></pre>
       <p class="calibre13">
        The output of the program is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0155"><code class="calibre21">0000001100</code>
<code class="calibre21">0011000000</code></pre>
      </section>
      <span aria-label="756" class="calibre20" epub:type="pagebreak" id="Page_756" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c18-sec-0134">
       </span>
       <h4 class="calibre29" id="head-4-306">
        bitset Example: Representing Cable Channels
       </h4>
       <p class="calibre13" id="c18-para-0392">
        One possible use of
        <code class="calibre21">
         bitset
        </code>
        s is tracking channels of cable subscribers. Each subscriber could have a
        <code class="calibre21">
         bitset
        </code>
        of channels associated with their subscription, with set bits representing the channels to which they actually subscribe. This system could also support “packages” of channels, also represented as
        <code class="calibre21">
         bitset
        </code>
        s, which represent commonly subscribed combinations of channels.
       </p>
       <p class="calibre13">
        The following
        <code class="calibre21">
         CableCompany
        </code>
        class is a simple example of this model. It uses two
        <code class="calibre21">
         map
        </code>
        s, both mapping
        <code class="calibre21">
         string
        </code>
        s to
        <code class="calibre21">
         bitset
        </code>
        s. One stores the cable packages, while the other stores subscriber information.
       </p>
       <pre class="calibre26" id="c18-code-0156"><code class="calibre21">export class CableCompany final</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Number of supported channels.</span></code>
<code class="calibre21">        static constexpr std::size_t NumChannels { 10 };</code>
<code class="calibre21">        <span class="color">// Adds package with the channels specified as a bitset to the database.</span></code>
<code class="calibre21">        void addPackage(const std::string&amp; packageName,</code>
<code class="calibre21">            const std::bitset&lt;NumChannels&gt;&amp; channels);</code>
<code class="calibre21">        <span class="color">// Adds package with the channels specified as a string to the database.</span></code>
<code class="calibre21">        void addPackage(const std::string&amp; packageName,            const std::string&amp; channels);</code>
<code class="calibre21">        <span class="color">// Removes the specified package from the database.</span></code>
<code class="calibre21">        void removePackage(const std::string&amp; packageName);</code>
<code class="calibre21">        <span class="color">// Retrieves the channels of a given package.</span></code>
<code class="calibre21">        <span class="color">// Throws out_of_range if the package name is invalid.</span></code>
<code class="calibre21">        const std::bitset&lt;NumChannels&gt;&amp; getPackage(</code>
<code class="calibre21">            const std::string&amp; packageName) const;</code>
<code class="calibre21">        <span class="color">// Adds customer to database with initial channels found in package.</span></code>
<code class="calibre21">        <span class="color">// Throws out_of_range if the package name is invalid.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is already known.</span></code>
<code class="calibre21">        void newCustomer(const std::string&amp; name, const std::string&amp; package);</code>
<code class="calibre21">        <span class="color">// Adds customer to database with given initial channels.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is already known.</span></code>
<code class="calibre21">        void newCustomer(const std::string&amp; name,</code>
<code class="calibre21">            const std::bitset&lt;NumChannels&gt;&amp; channels);</code>
<code class="calibre21">        <span class="color">// Adds the channel to the customer's profile.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is unknown.</span></code>
<code class="calibre21">        void addChannel(const std::string&amp; name, int channel);</code>
<code class="calibre21">        <span class="color">// Removes the channel from the customer's profile.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is unknown.</span></code>
<code class="calibre21">        void removeChannel(const std::string&amp; name, int channel);</code>
<code class="calibre21">        <span class="color">// Adds the specified package to the customer's profile.</span></code>
<code class="calibre21">        <span class="color">// Throws out_of_range if the package name is invalid.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is unknown.</span></code>
<code class="calibre21">        void addPackageToCustomer(const std::string&amp; name,</code>
<code class="calibre21">            const std::string&amp; package);</code>
<code class="calibre21">        <span class="color">// Removes the specified customer from the database.</span></code>
<code class="calibre21">        void deleteCustomer(const std::string&amp; name);</code>
<code class="calibre21">        <span class="color">// Retrieves the channels to which a customer subscribes.</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is unknown.</span></code>
<code class="calibre21">        const std::bitset&lt;NumChannels&gt;&amp; getCustomerChannels(</code>
<code class="calibre21">            const std::string&amp; name) const;</code>
<span aria-label="757" class="calibre20" epub:type="pagebreak" id="Page_757" role="doc-pagebreak"></span><code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Retrieves the channels for a customer. (non-const)</span></code>
<code class="calibre21">        <span class="color">// Throws invalid_argument if the customer is unknown.</span></code>
<code class="calibre21">        std::bitset&lt;NumChannels&gt;&amp; getCustomerChannelsHelper(</code>
<code class="calibre21">            const std::string&amp; name);</code>
<code class="calibre21"> </code>
<code class="calibre21">        using MapType = std::map&lt;std::string, std::bitset&lt;NumChannels&gt;&gt;;</code>
<code class="calibre21">        MapType m_packages, m_customers;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Here are the implementations of all member functions, with comments explaining the code:
       </p>
       <pre class="calibre26" id="c18-code-0157"><code class="calibre21">void CableCompany::addPackage(const string&amp; packageName,</code>
<code class="calibre21">    const bitset&lt;NumChannels&gt;&amp; channels)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_packages.emplace(packageName, channels);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::addPackage(const string&amp; packageName, const string&amp; channels)</code>
<code class="calibre21">{</code>
<code class="calibre21">    addPackage(packageName, bitset&lt;NumChannels&gt; { channels });</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::removePackage(const string&amp; packageName)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_packages.erase(packageName);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">const bitset&lt;CableCompany::NumChannels&gt;&amp; CableCompany::getPackage(</code>
<code class="calibre21">    const string&amp; packageName) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Get an iterator to the specified package.</span></code>
<code class="calibre21">    if (auto it { m_packages.find(packageName) }; it != end(m_packages)) {</code>
<code class="calibre21">        <span class="color">// Found package. Note that 'it' is an iterator to a name/bitset pair.</span></code>
<code class="calibre21">        <span class="color">// The bitset is the second field.</span></code>
<code class="calibre21">        return it-&gt;second;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    throw out_of_range { format("Invalid package '{}'.", packageName) };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::newCustomer(const string&amp; name, const string&amp; package)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Get the channels for the given package.</span></code>
<code class="calibre21">    auto&amp; packageChannels { getPackage(package) };</code>
<code class="calibre21">    <span class="color">// Create the account with the bitset representing that package.</span></code>
<code class="calibre21">    newCustomer(name, packageChannels);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::newCustomer(const string&amp; name,</code>
<code class="calibre21">    const bitset&lt;NumChannels&gt;&amp; channels)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Add customer to the customers map.</span></code>
<code class="calibre21">    if (auto [iter, success] { m_customers.emplace(name, channels) }; !success) {</code>
<code class="calibre21">        <span class="color">// Customer was already in the database. Nothing changed.</span></code>
<code class="calibre21">        throw invalid_argument { format("Duplicate customer '{}'.", name) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="758" class="calibre20" epub:type="pagebreak" id="Page_758" role="doc-pagebreak"></span><code class="calibre21">void CableCompany::addChannel(const string&amp; name, int channel)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Get the current channels for the customer.</span></code>
<code class="calibre21">    auto&amp; customerChannels { getCustomerChannelsHelper(name) };</code>
<code class="calibre21">    <span class="color">// We found the customer; set the channel.</span></code>
<code class="calibre21">    customerChannels.set(channel);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::removeChannel(const string&amp; name, int channel)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Get the current channels for the customer.</span></code>
<code class="calibre21">    auto&amp; customerChannels { getCustomerChannelsHelper(name) };</code>
<code class="calibre21">    <span class="color">// We found this customer; remove the channel.</span></code>
<code class="calibre21">    customerChannels.reset(channel);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::addPackageToCustomer(const string&amp; name, const string&amp; package)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Get the channels for the given package.</span></code>
<code class="calibre21">    auto&amp; packageChannels { getPackage(package) };</code>
<code class="calibre21">    <span class="color">// Get the current channels for the customer.</span></code>
<code class="calibre21">    auto&amp; customerChannels { getCustomerChannelsHelper(name) };</code>
<code class="calibre21">    <span class="color">// Or-in the package to the customer's existing channels.</span></code>
<code class="calibre21">    customerChannels |= packageChannels;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void CableCompany::deleteCustomer(const string&amp; name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_customers.erase(name);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">const bitset&lt;CableCompany::NumChannels&gt;&amp; CableCompany::getCustomerChannels(</code>
<code class="calibre21">    const string&amp; name) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Find an iterator to the customer.</span></code>
<code class="calibre21">    if (auto it { m_customers.find(name) }; it != end(m_customers)) {</code>
<code class="calibre21">        <span class="color">// Found customer. Note that 'it' is an iterator to a name/bitset pair.</span></code>
<code class="calibre21">        <span class="color">// The bitset is the second field.</span></code>
<code class="calibre21">        return it-&gt;second;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    throw invalid_argument { format("Unknown customer '{}'.", name) };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">bitset&lt;CableCompany::NumChannels&gt;&amp; CableCompany::getCustomerChannelsHelper(</code>
<code class="calibre21">    const string&amp; name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Forward to const getCustomerChannels() to avoid code duplication.</span></code>
<code class="calibre21">    return const_cast&lt;bitset&lt;NumChannels&gt;&amp;&gt;(getCustomerChannels(name));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Finally, here is a simple program demonstrating how to use the
        <code class="calibre21">
         CableCompany
        </code>
        class:
       </p>
       <pre class="calibre26" id="c18-code-0158"><code class="calibre21">CableCompany myCC;</code>
<code class="calibre21">myCC.addPackage("basic",   "1111000000");</code>
<span aria-label="759" class="calibre20" epub:type="pagebreak" id="Page_759" role="doc-pagebreak"></span><code class="calibre21">myCC.addPackage("premium", "1111111111");</code>
<code class="calibre21">myCC.addPackage("sports",  "0000100111");</code>
<code class="calibre21"> </code>
<code class="calibre21">myCC.newCustomer("Marc G.", "basic");</code>
<code class="calibre21">myCC.addPackageToCustomer("Marc G.", "sports");</code>
<code class="calibre21">println("{}", myCC.getCustomerChannels("Marc G.").to_string());</code>
<code class="calibre21"> </code>
<code class="calibre21">try { println("{}", myCC.getCustomerChannels("John").to_string()); }</code>
<code class="calibre21">catch (const exception&amp; e) { println("Error: {}", e.what()); }</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c18-code-0159"><code class="calibre21">1111100111</code>
<code class="calibre21">Error: Unknown customer 'John'.</code></pre>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-204" class="calibre2">
     <span class="calibre" id="c18-sec-0135">
     </span>
     <h2 class="calibre6" id="head-2-204">
      SUMMARY
     </h2>
     <p class="calibre13" id="c18-para-0397">
      This chapter introduced the Standard Library containers. It also presented sample code illustrating a variety of uses for these containers. Ideally, you appreciate the power of
      <code class="calibre21">
       vector
      </code>
      ,
      <code class="calibre21">
       deque
      </code>
      ,
      <code class="calibre21">
       list
      </code>
      ,
      <code class="calibre21">
       forward_list
      </code>
      ,
      <code class="calibre21">
       array
      </code>
      ,
      <code class="calibre21">
       span
      </code>
      ,
      <code class="calibre21">
       mdspan
      </code>
      ,
      <code class="calibre21">
       stack
      </code>
      ,
      <code class="calibre21">
       queue
      </code>
      ,
      <code class="calibre21">
       priority_queue
      </code>
      ,
      <code class="calibre21">
       map
      </code>
      ,
      <code class="calibre21">
       multimap
      </code>
      ,
      <code class="calibre21">
       set
      </code>
      ,
      <code class="calibre21">
       multiset
      </code>
      ,
      <code class="calibre21">
       unordered_map
      </code>
      ,
      <code class="calibre21">
       unordered_multimap
      </code>
      ,
      <code class="calibre21">
       unordered_set
      </code>
      ,
      <code class="calibre21">
       unordered_multiset
      </code>
      ,
      <code class="calibre21">
       flat_map
      </code>
      ,
      <code class="calibre21">
       flat_multimap
      </code>
      ,
      <code class="calibre21">
       flat_set
      </code>
      ,
      <code class="calibre21">
       flat_multiset
      </code>
      ,
      <code class="calibre21">
       string
      </code>
      , and
      <code class="calibre21">
       bitset
      </code>
      . I recommend using these containers as much as possible instead of writing your own.
     </p>
     <p class="calibre13" id="c18-para-0398">
      Before we can delve into the true power of the Standard Library with a discussion of its generic algorithms and how they work with the containers discussed in this chapter, we have to explain function pointers, function objects, and lambda expressions. Those are the topics of the next chapter.
     </p>
    </section>
    <section aria-labelledby="head-2-205" class="calibre2">
     <span class="calibre" id="c18-sec-0136">
     </span>
     <h2 class="calibre6" id="head-2-205">
      EXERCISES
     </h2>
     <p class="calibre13" id="c18-para-0399">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <code class="calibre21">
        <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
         www.wiley.com/go/proc++6e
        </a>
       </code>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c18-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c18-ex-0001">
        <b class="calibre14">
         Exercise 18-1:
        </b>
        This exercise is to practice working with
        <code class="calibre21">
         vector
        </code>
        s. Create a program containing a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         int
        </code>
        s, called
        <code class="calibre21">
         values
        </code>
        , initialized with the numbers 2 and 5. Next, implement the following operations:
        <ol class="calibre7" id="c18-list-0020">
         <li class="calibre9" id="c18-li-0078">
          Use
          <code class="calibre21">
           insert()
          </code>
          to insert the numbers 3 and 4 at the correct place in
          <code class="calibre21">
           values
          </code>
          .
         </li>
         <li class="calibre9" id="c18-li-0079">
          Create a second
          <code class="calibre21">
           vector
          </code>
          of
          <code class="calibre21">
           int
          </code>
          s initialized with 0 and 1, and then insert the contents of this new
          <code class="calibre21">
           vector
          </code>
          at the beginning of
          <code class="calibre21">
           values
          </code>
          .
         </li>
         <li class="calibre9" id="c18-li-0080">
          Create a third
          <code class="calibre21">
           vector
          </code>
          of
          <code class="calibre21">
           int
          </code>
          s. Loop over the elements of
          <code class="calibre21">
           values
          </code>
          in reverse, and insert them in this third
          <code class="calibre21">
           vector
          </code>
          .
         </li>
         <li class="calibre9" id="c18-li-0081">
          Print the contents of the third
          <code class="calibre21">
           vector
          </code>
          using
          <code class="calibre21">
           println()
          </code>
          .
         </li>
         <li class="calibre9" id="c18-li-0082">
          Print the contents of the third
          <code class="calibre21">
           vector
          </code>
          using a range-based
          <code class="calibre21">
           for
          </code>
          loop.
         </li>
        </ol>
       </li>
       <li class="calibre9" id="c18-ex-0002">
        <span aria-label="760" class="calibre20" epub:type="pagebreak" id="Page_760" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Exercise 18-2:
        </b>
        Take your implementation of the
        <code class="calibre21">
         Person
        </code>
        class from Exercise 15-4. Add a new module called
        <code class="calibre21">
         phone_book
        </code>
        , defining a
        <code class="calibre21">
         PhoneBook
        </code>
        class that stores one or more phone numbers as
        <code class="calibre21">
         string
        </code>
        s for a person. Provide member functions to add and remove person's phone numbers to/from a phonebook. Also provide a member function that returns a
        <code class="calibre21">
         vector
        </code>
        with all phone numbers for a given person. Test your implementation in your
        <code class="calibre21">
         main()
        </code>
        function. In your tests, use the user-defined person literal developed in Exercise 15-4.
       </li>
       <li class="calibre9" id="c18-ex-0003">
        <b class="calibre14">
         Exercise 18-3:
        </b>
        In Exercise 15-1 you developed your own
        <code class="calibre21">
         AssociativeArray
        </code>
        . Modify the test code in
        <code class="calibre21">
         main()
        </code>
        from that exercise to use one of the Standard Library containers instead.
       </li>
       <li class="calibre9" id="c18-ex-0004">
        <b class="calibre14">
         Exercise 18-4:
        </b>
        Write an
        <code class="calibre21">
         average()
        </code>
        function (not a function template) to calculate the average of a sequence of
        <code class="calibre21">
         double
        </code>
        values. Make sure it works with a sequence or subsequence from a
        <code class="calibre21">
         vector
        </code>
        or an
        <code class="calibre21">
         array
        </code>
        . Test your code with both a
        <code class="calibre21">
         vector
        </code>
        and an
        <code class="calibre21">
         array
        </code>
        in your
        <code class="calibre21">
         main()
        </code>
        function.
       </li>
       <li class="calibre9" id="c18-ex-0005">
        <b class="calibre14">
         Bonus exercise:
        </b>
        Can you convert your
        <code class="calibre21">
         average()
        </code>
        function into a function template? The function template should only be instantiatable with integral or floating-point types. What effect does it have on your test code in
        <code class="calibre21">
         main()
        </code>
        ?
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
