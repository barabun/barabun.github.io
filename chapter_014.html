<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   5: Styles
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_013.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_015.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="179" epub:type="pagebreak" id="pagebreak_179" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0005" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000209">
      5: Styles
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         There are several different application programming interface (API) styles that can be used to implement any given design. This chapter covers five different programming styles available to C++ developers, describing the pros and cons of each method. These include the use of a procedural flat C API, without any C++ features such as classes, namespaces, or references; object-oriented C++ APIs, which can make use of inheritance, encapsulation, and polymorphism; template-based APIs, which allow functions and data structures to be written in terms of generic types; functional APIs, which focus on declarative programming techniques using functions as a first-class concept; and data-driven APIs, which map well to Web service APIs and support data-driven testing.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Data driven; Functional programming; Generic programming; Idempotency; Macro; Object oriented; std:any; Template; Web service
      </div>
     </section>
     <section>
      <p class="textfl" id="p0010">
       The previous chapters dealt with the qualities and approaches toward good application programming interface (API) design. Although I've illustrated these concepts with specific C++ examples, the abstract process of designing an API is language independent. However, in the next few chapters, I'll start to turn to more C++ specific aspects of producing a high-quality API.
      </p>
      <p class="text" id="p0015">
       In this chapter, I'll cover the topic of API style. Style in this context means how you decide to represent the capabilities of your API. That is, your API may provide access to internal state and routines to perform required functionality, but what is the form of invoking these actions? The answer to this question may seem obvious: you create classes to represent each key object in your API and provide methods on those classes. However, there are other styles you could adopt, and the object-oriented style may not be the best fit all of the time. In this chapter I'll present five very different API styles:
      </p>
      <div>
       <ul class="ce_list" id="olist0010">
        <li class="numlist" id="p0020">
         <a id="o0010">
         </a>
         1.
         <b>
          Flat C APIs
         </b>
         : An API that can be compiled by a C compiler. This simply involves a set of free functions along with any supporting data structures and constants. Because this style of interface contains no objects or inheritance, it's often called flat or procedural.
        </li>
        <li class="numlist" id="p0025">
         <a id="o0015">
         </a>
         2.
         <b>
          Object-Oriented C++ APIs
         </b>
         : As a C++ programmer, this is likely the style with which you're most familiar. It involves the use of objects with associated data and methods, and the application of concepts such as inheritance, encapsulation, and polymorphism.
        </li>
        <li class="numlist" id="p0030">
         <a id="o0020">
         </a>
         3.
         <b>
          Template-Based APIs
         </b>
         : C++ also supports generic programming and metaprogramming via its template functionality. This allows functions and data structures to be written in terms of generic types that can be specialized later by instantiating them with concrete types.
        </li>
        <li class="numlist" id="p0035">
         <a id="o0025">
         </a>
         4.
         <b>
          Functional APIs
         </b>
         : Functional programming is a style that relies on composing functions rather than executing sequences of imperative statements. It's a declarative programming style, meaning that it focuses more on what you want to do rather than how you want to do it.
        </li>
        <li class="numlist" id="p0040">
         <a id="o0030">
         </a>
         5.
         <b>
          Data-Driven APIs
         </b>
         : This type of interface involves sending named commands to a handler, with arguments that are packaged within a flexible data structure, rather than invoking specific methods or free functions. This style maps well to supporting network protocols and file formats.
        </li>
       </ul>
      </div>
      <p class="text" id="p0045">
       I'll now describe each of these API styles in turn and discuss the situations in which one style may be favored over another. Throughout the chapter, I'll use examples from the FMOD API to illustrate three of those styles. FMOD is a commercial library for
       <a id="p180">
       </a>
       <span aria-label="180" epub:type="pagebreak" id="pagebreak_180" role="doc-pagebreak">
       </span>
       creating and playing back interactive audio that is used by many game companies such as Activision, Blizzard, Ubisoft, and Microsoft. It provides a flat C API, a C++ API, and a Data-Driven API to access its core audio functionality. As such it provides an instructive comparison for several of those API styles.
      </p>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        Flat C APIs
       </h2>
       <p class="textfl" id="p0050">
        The term flat API is meant to convey the fact that the C language doesn't support the notion of encapsulated objects and inheritance hierarchies. Hence, an API that uses pure C syntax must be represented with a more restricted set of language features, such as typedefs, structs, and function calls that exist in the global namespace. Owing to the lack of the
        <span class="inlinecode">
         namespace
        </span>
        keyword in C, APIs employing this style must use a common prefix for all public functions and data structures to avoid name collisions with other C libraries.
       </p>
       <p class="text" id="p0055">
        Of course, you can still use internal linkage (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52" id="bib_52">
         Lakos, 1996
        </a>
        ) to hide symbol names in your implementation, such as declaring them static at the file scope level of your
        <span class="inlinecode">
         .cpp
        </span>
        files. In this way you can be assured that any such functions will not be exported externally and hence will not collide with the same symbol name in another library. (This applies equally to C++ programs as well, of course, although in C++ the use of anonymous namespaces is a preferred way to achieve the same result).
       </p>
       <p class="text" id="p0060">
        There are many examples of popular C APIs that are in use today, including:
       </p>
       <div>
        <ol id="ulist0010">
         <li class="bulllist" id="p0065">
          <a id="u0010">
          </a>
          ▪
          <b>
           The C Standard Library.
          </b>
          If you're writing a C program, then you must be familiar with the C Standard Library. This is composed of a collection of include files (such as
          <span class="inlinecode">
           stdio.h
          </span>
          ,
          <span class="inlinecode">
           stdlib.h
          </span>
          , and
          <span class="inlinecode">
           string.h
          </span>
          ) and library routines for I/O, string handling, memory management, mathematical operations, etc. (such as
          <span class="inlinecode">
           printf()
          </span>
          ,
          <span class="inlinecode">
           malloc()
          </span>
          ,
          <span class="inlinecode">
           floor()
          </span>
          , and
          <span class="inlinecode">
           strcpy()
          </span>
          ). Most C and many C++ programs are built using this library.
         </li>
         <li class="bulllist" id="p0070">
          <a id="u0015">
          </a>
          ▪
          <b>
           The Windows API.
          </b>
          Often referred to as the Win32 API, this is the core set of interfaces used to develop applications for the Microsoft Windows range of operating systems. It includes a group of APIs across various categories such as base services, the graphics device interface, the common dialogue box library, and network services. Another library, called Microsoft Foundation Class, provides a C++ wrapper to the Windows API.
         </li>
         <li class="bulllist" id="p0075">
          <a id="u0020">
          </a>
          ▪
          <b>
           The Linux Kernel API.
          </b>
          The entire Linux kernel is written in plain C. This includes the Linux Kernel API, which provides a stable interface for low-level software such as device drivers to access operating system functionality. The API includes driver functions, data types, basic C library functions, memory management operations, thread and process functions, and network functions, among many others.
         </li>
         <li class="bulllist" id="p0080">
          <a id="u0025">
          </a>
          ▪
          <b>
           GNOME GLib.
          </b>
          This is a general-purpose open source utility library containing many useful low-level routines for writing applications. This includes string utilities, file access, data structures such as trees, hashes, and lists, and a main loop abstraction. This library provides the foundation for the GNOME desktop environment and was originally part of the GIMP Toolkit (GTK+).
          <a id="p181">
          </a>
         </li>
         <li>
          <span aria-label="181" epub:type="pagebreak" id="pagebreak_181" role="doc-pagebreak">
          </span>
         </li>
         <li class="bulllist" id="p0085">
          <a id="u0030">
          </a>
          ▪
          <b>
           The Netscape Portable Runtime.
          </b>
          The Netscape Portable Runtime library provides a cross-platform API for low-level functionality such as threads, file I/O, network access, interval timing, memory management, and shared library linking. It is used as the core of the various Mozilla applications, including the Firefox Web browser and Thunderbird email client.
         </li>
         <li class="bulllist" id="p0090">
          <a id="u0035">
          </a>
          ▪
          <b>
           Image Libraries
          </b>
          : Most of the open source image libraries that help you add support for various image file formats to your applications are written entirely in C. For example, the libtiff, libpng, libz, libungif, and jpeg libraries are all plain C APIs.
         </li>
        </ol>
       </div>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         ANSI C features
        </h3>
        <p class="textfl" id="p0095">
         If you're used to writing C++ APIs, there will be many language features that you'll have to do without when writing a plain C API. For example, C does not support classes, references, smart pointers, templates, the C++ Standard Library, default arguments, access levels (public, private, or protected), or a bool type. Instead, C APIs are generally composed only of:
        </p>
        <div>
         <ul class="ce_list" id="olist0015">
          <li class="numlist" id="p0100">
           <a id="o0035">
           </a>
           1. Built-in types such as
           <span class="inlinecode">
            int
           </span>
           ,
           <span class="inlinecode">
            float
           </span>
           ,
           <span class="inlinecode">
            double
           </span>
           ,
           <span class="inlinecode">
            char
           </span>
           , and arrays and pointers to these.
          </li>
          <li class="numlist" id="p0105">
           <a id="o0040">
           </a>
           2. Custom types created via the
           <span class="inlinecode">
            typedef
           </span>
           and
           <span class="inlinecode">
            enum
           </span>
           keywords.
          </li>
          <li class="numlist" id="p0110">
           <a id="o0045">
           </a>
           3. Custom structures declared with the
           <span class="inlinecode">
            struct
           </span>
           or
           <span class="inlinecode">
            union
           </span>
           keywords.
          </li>
          <li class="numlist" id="p0115">
           <a id="o0050">
           </a>
           4. Global free functions.
          </li>
          <li class="numlist" id="p0120">
           <a id="o0055">
           </a>
           5. Preprocessor directives such as
           <span class="inlinecode">
            #define
           </span>
           .
          </li>
         </ul>
        </div>
        <p class="text" id="p0125">
         In fact, the complete set of C language keywords is quite short. The entire list is presented here as a reference:
        </p>
        <div>
         <ol id="ulist0015">
          <li class="bulllist" id="p0130">
           <a id="u0040">
           </a>
           ▪
           <b>
            auto
           </b>
           : defines a local variable as having a local lifetime.
          </li>
          <li class="bulllist" id="p0135">
           <a id="u0045">
           </a>
           ▪
           <b>
            break
           </b>
           : passes control out of a while, do, for, or switch statement.
          </li>
          <li class="bulllist" id="p0140">
           <a id="u0050">
           </a>
           ▪
           <b>
            case
           </b>
           : defines a specific branch point within a switch statement.
          </li>
          <li class="bulllist" id="p0145">
           <a id="u0055">
           </a>
           ▪
           <b>
            char
           </b>
           : the character data type.
          </li>
          <li class="bulllist" id="p0150">
           <a id="u0060">
           </a>
           ▪
           <b>
            const
           </b>
           : declares a variable value or pointer parameter to be unmodifiable.
          </li>
          <li class="bulllist" id="p0155">
           <a id="u0065">
           </a>
           ▪
           <b>
            continue
           </b>
           : passes control to the beginning of a while, do, or for statement.
          </li>
          <li class="bulllist" id="p0160">
           <a id="u0070">
           </a>
           ▪
           <b>
            default
           </b>
           : defines the fallback branch point for a switch statement.
          </li>
          <li class="bulllist" id="p0165">
           <a id="u0075">
           </a>
           ▪
           <b>
            do
           </b>
           : begins a do-while loop.
          </li>
          <li class="bulllist" id="p0170">
           <a id="u0080">
           </a>
           ▪
           <b>
            double
           </b>
           : the double-precision floating point data type.
          </li>
          <li class="bulllist" id="p0175">
           <a id="u0085">
           </a>
           ▪
           <b>
            else
           </b>
           : the statements to perform when an if statement resolves to false.
          </li>
          <li class="bulllist" id="p0180">
           <a id="u0090">
           </a>
           ▪
           <b>
            enum
           </b>
           : defines a set of constants of type int.
          </li>
          <li class="bulllist" id="p0185">
           <a id="u0095">
           </a>
           ▪
           <b>
            extern
           </b>
           : introduces the name of an identifier that is defined elsewhere.
          </li>
          <li class="bulllist" id="p0190">
           <a id="u0100">
           </a>
           ▪
           <b>
            float
           </b>
           : the single-precision floating point data type.
          </li>
          <li class="bulllist" id="p0195">
           <a id="u0105">
           </a>
           ▪
           <b>
            for
           </b>
           : defines a for loop.
          </li>
          <li class="bulllist" id="p0200">
           <a id="u0110">
           </a>
           ▪
           <b>
            goto
           </b>
           : transfers control to a labeled line of code.
          </li>
          <li class="bulllist" id="p0205">
           <a id="u0115">
           </a>
           ▪
           <b>
            if
           </b>
           : provides conditional execution of a sequence of statements.
          </li>
          <li class="bulllist" id="p0210">
           <a id="u0120">
           </a>
           ▪
           <b>
            int
           </b>
           : the integer data type.
          </li>
          <li class="bulllist" id="p0215">
           <a id="u0125">
           </a>
           ▪
           <b>
            long
           </b>
           : extends the size of certain built-in data types.
          </li>
          <li class="bulllist" id="p0220">
           <a id="u0130">
           </a>
           ▪
           <b>
            register
           </b>
           : instructs the compiler to store a variable in a CPU register.
           <a id="p182">
           </a>
          </li>
          <li>
           <span aria-label="182" epub:type="pagebreak" id="pagebreak_182" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p0225">
           <a id="u0135">
           </a>
           ▪
           <b>
            return
           </b>
           : exits a function with an optional return value.
          </li>
          <li class="bulllist" id="p0230">
           <a id="u0140">
           </a>
           ▪
           <b>
            short
           </b>
           : reduces the size of certain built-in data types.
          </li>
          <li class="bulllist" id="p0235">
           <a id="u0145">
           </a>
           ▪
           <b>
            signed
           </b>
           : declares a data type to be able to handle negative values.
          </li>
          <li class="bulllist" id="p0240">
           <a id="u0150">
           </a>
           ▪
           <b>
            sizeof
           </b>
           : returns the size of a type or expression.
          </li>
          <li class="bulllist" id="p0245">
           <a id="u0155">
           </a>
           ▪
           <b>
            static
           </b>
           : preserves the value of a variable even after its scope ends.
          </li>
          <li class="bulllist" id="p0250">
           <a id="u0160">
           </a>
           ▪
           <b>
            struct
           </b>
           : allows multiple variables to be grouped into a single type.
          </li>
          <li class="bulllist" id="p0255">
           <a id="u0165">
           </a>
           ▪
           <b>
            switch
           </b>
           : causes control to branch to one of a list of possible statements.
          </li>
          <li class="bulllist" id="p0260">
           <a id="u0170">
           </a>
           ▪
           <b>
            typedef
           </b>
           : creates a new type in terms of existing types.
          </li>
          <li class="bulllist" id="p0265">
           <a id="u0175">
           </a>
           ▪
           <b>
            union
           </b>
           : groups multiple variables that share the same memory location.
          </li>
          <li class="bulllist" id="p0270">
           <a id="u0180">
           </a>
           ▪
           <b>
            unsigned
           </b>
           : declares a data type to handle only positive values.
          </li>
          <li class="bulllist" id="p0275">
           <a id="u0185">
           </a>
           ▪
           <b>
            void
           </b>
           : the empty data type.
          </li>
          <li class="bulllist" id="p0280">
           <a id="u0190">
           </a>
           ▪
           <b>
            volatile
           </b>
           : indicates that a variable can be changed by an external process.
          </li>
          <li class="bulllist" id="p0285">
           <a id="u0195">
           </a>
           ▪
           <b>
            while
           </b>
           : defines a loop that exists when the condition evaluates to false.
          </li>
         </ol>
        </div>
        <p class="text" id="p0290">
         Although C is not strictly a subset of C++, well-written ANSI (American National Standards Institute) C programs will tend to be legal C++ programs, too. In general, a C++ compiler will impose greater type checking than a C compiler. When you're writing a plain C API, it's often a worthwhile task to try and compile your code with a C++ compiler and then fix any additional warnings or errors that are raised.
        </p>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0015">
            <i>
             SIDEBAR: Stronger type checking saves brain cells
            </i>
           </div>
           <div class="b1textfl" id="bpar0010">
            <i>
             I recall one occasion early in my career when my manager at SRI International, Yvan Leclerc, had a crashing bug in a C program. He spent the best part of a day trying to track the problem down, and eventually the two of us stepped through his code together, line by line.
            </i>
           </div>
           <div class="b1text" id="bpar0015">
            <i>
             After much scratching of heads, we finally noticed that he was using the
            </i>
            <span class="inlinecode">
             <i>
              calloc()
             </i>
            </span>
            <i>
             function, but was passing only a single argument to it. As you may recall from
            </i>
            <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
             Chapter 2
            </a>
            ,
            <i>
             the
            </i>
            <span class="inlinecode">
             <i>
              malloc()
             </i>
            </span>
            <i>
             function takes one parameter, whereas the
            </i>
            <span class="inlinecode">
             <i>
              calloc()
             </i>
            </span>
            <i>
             function takes two parameters.
            </i>
           </div>
           <div class="b1text" id="bpar0020">
            <i>
             He had switched from using
            </i>
            <span class="inlinecode">
             <i>
              malloc()
             </i>
            </span>
            <i>
             to
            </i>
            <span class="inlinecode">
             <i>
              calloc()
             </i>
            </span>
            <i>
             to return an initialized block of memory but had forgotten to change the parameters to the function call. As a result, the returned block of memory was not the size he expected it to be. This is not an error in C (although these days most C compilers will at least give you a warning), but it is a compile error in C++. Using a C++ compiler to compile that C code would have turned up the problem immediately.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <div>
         <aside aria-labelledby="b0015" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0015">
           <div class="b1textfl" id="bpar0025">
            <i>
             TIP: Try compiling your C API with a C++ compiler for greater type checking, and to ensure that a C++ program can use your API.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Benefits of an ANSI C API
        </h3>
        <p class="textfl" id="p0295">
         One of the main reasons to write an API in C is if it must integrate with an existing project that is written entirely in C. Situations such as these are becoming rarer as more projects are being written from the ground up in C++, but occasions may arise when
         <a id="p183">
         </a>
         <span aria-label="183" epub:type="pagebreak" id="pagebreak_183" role="doc-pagebreak">
         </span>
         your clients place this restriction on your API. Examples include any of the existing large C APIs that I listed earlier. For instance, if you're working on a Linux Kernel API, then you will need to write this interface in C.
        </p>
        <p class="text" id="p0300">
         Another reason to prefer the creation of a plain C API is binary compatibility. If you are required to maintain binary compatibility between releases of your API library, this is much easier to achieve with a plain C API than a C++ one. I will discuss the details of this in the chapter on Versioning, but suffice to say for now that seemingly minor changes to a C++ API can affect the binary representation for the resulting object and library files, thus breaking the ability for clients to simply drop in a replacement shared library and have it work without recompiling their code.
        </p>
        <p class="text" id="p0305">
         Of course, there's nothing to stop you producing an API that works under both C and C++. In fact, you may even decide that you wish to create a C++ API, to take advantage of the additional object-oriented features of C++, but also create a plain C wrapping of this interface for use within C-only projects, or to expose a simple and low–surface area version of your API for which binary compatibility is easier to enforce. The FMOD API is one such example of this, because it provides both a C++ and a C API.
        </p>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Writing an API in ANSI C
        </h3>
        <p class="textfl" id="p0310">
         The C language does not provide support for classes, so you cannot encapsulate data in objects along with the methods that act upon those data. Instead, you declare structs (or unions) that contain data, and then pass those as parameters to functions that operate on those data. For example, consider the following C++ class definition:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0010">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000209/main.assets/u05-01-9780443222191.jpg" width="866"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0315">
         This might look as follows in terms of a flat C API:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000209/main.assets/u05-02-9780443222191.jpg" width="1318"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p184">
         </a>
        </p>
        <div>
         <span aria-label="184" epub:type="pagebreak" id="pagebreak_184" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0320">
         Each C function associated with the stack must accept the
         <span class="inlinecode">
          Stack
         </span>
         data structure as a parameter, often as the first parameter. Also note that the name of the function must normally include some indication of the data on which it operates, because the name is not scoped within a class declaration as in C++. In this case I chose to prefix each function with the word Stack to make it clear that the functions operate on the
         <span class="inlinecode">
          Stack
         </span>
         data structure. This example can be further improved by using an opaque pointer to hide the private data, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0020">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000209/main.assets/u05-03-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0325">
         Additionally, C does not support the notion of constructors and destructors. Therefore, any structs must be explicitly initialized and destroyed by the client. This is normally done by adding specific API calls to create and destroy a data structure:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0025">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000209/main.assets/u05-04-9780443222191.jpg" width="1179"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0330">
         Now that I've compared what a C and C++ API might look like for the same task, let's look at the code that the client must write to use each API style. First, here's an example of using the C++ API:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000209/main.assets/u05-05-9780443222191.jpg" width="936"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0335">
         whereas the same operations performed with the C API might look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0035">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000209/main.assets/u05-06-9780443222191.jpg" width="1074"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0340">
         I'm ignoring the error handling in the previous case for simplicity. But it should be noted that the C++
         <span class="inlinecode">
          new
         </span>
         operator does not return
         <span class="inlinecode">
          nullptr
         </span>
         in the case of an error and instead throws a
         <span class="inlinecode">
          bad_alloc
         </span>
         exception. So the C++ example would require a
         <span class="inlinecode">
          try
         </span>
         /
         <span class="inlinecode">
          catch
         </span>
         <a id="p185">
         </a>
         <span aria-label="185" epub:type="pagebreak" id="pagebreak_185" role="doc-pagebreak">
         </span>
         block to check for memory allocation errors, whereas the C code would check for a
         <span class="inlinecode">
          nullptr
         </span>
         returned from the
         <span class="inlinecode">
          CreateStack()
         </span>
         function.
        </p>
       </section>
       <section>
        <a id="s0030">
        </a>
        <h3 class="h2hd" id="cesectitle0040">
         Calling C functions from C++
        </h3>
        <p class="textfl" id="p0345">
         C++ compilers can also compile C code, and even though you're writing a C API you may want to allow C++ clients to use your API, too. This is a relatively easy task and one that I suggest you undertake as a matter of course when releasing a C API.
        </p>
        <p class="text" id="p0350">
         The first step is to make sure that your code compiles under a C++ compiler. As I've already noted, the C standard is more relaxed, and so a C compiler will let you get away with more sloppy code than a C++ compiler will.
        </p>
        <p class="text" id="p0355">
         As part of this process, you will, of course, want to make sure that you don't use any C++ reserved keywords in your code. For example, the following code is legal C, but will produce an error with a C++ compiler because
         <span class="inlinecode">
          class
         </span>
         is a reserved word in C++:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000209/main.assets/u05-07-9780443222191.jpg" width="484"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0360">
         Finally, C functions have different linkage than C++ functions. That is, the same function is represented differently in object files produced by a C and C++ compiler. One reason for this is that C++ supports function overloading: declaring methods with the same name but different parameters or return values. As a result, C++ function names are mangled to encode additional information in the symbol name such as the number and type of each parameter. Because of this linkage difference, you cannot compile C++ code that uses a function, say
         <span class="inlinecode">
          DoAction()
         </span>
         , and then link this against a library produced by a C compiler that defines the
         <span class="inlinecode">
          DoAction()
         </span>
         function.
        </p>
        <p class="text" id="p0365">
         To get around this problem, you must wrap your C API in an
         <span class="inlinecode">
          extern “C”
         </span>
         construct, which tells the C++ compiler that the contained functions should use C-style linkage. A C compiler will not be able to parse this statement, so it's best to compile it conditionally for C++ compilers only. This code snippet illustrates this best practice:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000209/main.assets/u05-08-9780443222191.jpg" width="900"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <div class="b1textfl" id="bpar0030">
            <i>
             TIP: Use an
            </i>
            <span class="inlinecode">
             <i>
              extern “C”
             </i>
            </span>
            <i>
             scope in your C API headers so that C++ programs can compile and link against your API correctly.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p186">
         </a>
        </p>
        <div>
         <span aria-label="186" epub:type="pagebreak" id="pagebreak_186" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         Case study: FMOD C API
        </h3>
        <p class="textfl" id="p0370">
         The following source code presents a small program using the FMOD C API to play a single sound sample. This is provided to give you a real-world example of using a flat C API. Note the use of function naming conventions to create multiple layers of namespace, in which all functions begin with
         <span class="inlinecode">
          FMOD_
         </span>
         , all system-level calls begin with
         <span class="inlinecode">
          FMOD_System_
         </span>
         , and so on. Notice, in the interest of readability, that this example does not perform any error checking. Obviously, any real program would check that each function call completed without error:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="1964" src="../../IMAGES/B9780443222191000209/main.assets/u05-09-9780443222191.jpg" width="2031"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
      </section>
      <section>
       <a id="s0040">
       </a>
       <h2 class="h1hd" id="cesectitle0050">
        Object-oriented C++ APIs
       </h2>
       <p class="textfl" id="p0375">
        When you consider writing an API in C++, you probably think in terms of object-oriented design. Object-oriented programming (OOP) is a style of programming in which data and the functions that operate on those data are packaged together as an object. The origins of OOP date back to the 1960s with the development of the Simula
        <a id="p187">
        </a>
        <span aria-label="187" epub:type="pagebreak" id="pagebreak_187" role="doc-pagebreak">
        </span>
        and Smalltalk languages. However, it didn't take off as a dominant programming model until the 1990s, with the introduction of languages such as C++ and Java.
       </p>
       <p class="text" id="p0380">
        Because I have already covered many of the key techniques of OOP in the previous chapters, I will not spend too much time on this API style. I refer you to the Class Design section of the previous section, where I defined various OOP terms such as class, object, inheritance, composition, encapsulation, and polymorphism.
       </p>
       <p class="text" id="p0385">
        It should be noted that features such as method and operator overloading, default parameters, templates, exceptions, and namespaces are strictly not object-oriented concepts. However, they are new features that were included in the C++ language and are not a part of the original C language. C++ supports several programming models other than OOP, such as procedural programming (as seen in the previous section), generic programming, and functional programming (both of which I'll cover next).
       </p>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         Advantages of object-oriented APIs
        </h3>
        <p class="textfl" id="p0390">
         The primary benefit of using an object-oriented API is the ability to use classes and inheritance: that is, the ability to model software in terms of interconnected data, rather than collections of procedures. This can provide both conceptual and technical advantages.
        </p>
        <p class="text" id="p0395">
         In terms of conceptual advantages, often the physical items and processes that you try to model in code can be described in terms of objects. For example, an address book is a physical item with which we are all familiar, and it contains descriptions for several people, which again is a conceptual unit to which anyone can relate. The core task of OOP is therefore to identify the key objects in a given problem space and determine how they relate to each other. Many engineers believe that this is a more logical way to approach software design than thinking in terms of the set of all actions that must be performed (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib12" id="bib_12">
          Booch et al., 2007
         </a>
         ).
        </p>
        <p class="text" id="p0400">
         As for the technical advantages, using objects provides a way to encapsulate all of the data and methods for a single conceptual unit in one place. It essentially creates a unique namespace for all related methods and variables. For example, the methods of our earlier C++ Stack example all exist within the
         <span class="inlinecode">
          Stack
         </span>
         namespace, such as
         <span class="inlinecode">
          Stack::Push()
         </span>
         or
         <span class="inlinecode">
          Stack::Pop()
         </span>
         . Objects also provide the notion of information hiding with public, protected, and private access levels, which is a critical concept for API design.
        </p>
        <div>
         <aside aria-labelledby="b0025" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0025">
           <div class="b1textfl" id="bpar0035">
            <i>
             TIP: Object-oriented APIs offer the advantages of inheritance, encapsulation, and information hiding.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0050">
        </a>
        <h3 class="h2hd" id="cesectitle0060">
         Disadvantages of object-oriented APIs
        </h3>
        <p class="textfl" id="p0405">
         However, there can be downsides to using object-oriented concepts. Many of these result from abuses of the power of object-oriented techniques. The first is that adding inheritance to your object model can introduce a degree of complexity and subtlety that not all engineers may fully understand, such as knowing that base class destructors must always be marked as virtual, or that an overridden method in a subclass will hide all overloaded methods with the same name in the base class.
         <a id="p188">
         </a>
        </p>
        <div>
         <span aria-label="188" epub:type="pagebreak" id="pagebreak_188" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0410">
         Furthermore, deep inheritance hierarchies can make it challenging to figure out the complete interface offered by an object just by looking at header files, because the interface may be distributed across multiple headers (of course, good documentation tools such as Doxygen can help to abate this particular concern). Also, some engineers may abuse, or incorrectly use, the concepts of OOP, such as using inheritance in cases where it doesn't make sense (where the objects don't form an is-a relationship). This can cause strained and unclear designs that are difficult to work with.
        </p>
        <p class="text" id="p0415">
         Finally, creating a binary compatible API using object-oriented C++ concepts is an extremely difficult task. If binary compatibility is your goal, you may wish to choose one of the other API styles that I describe in this chapter, such as a flat C API or a data-driven API.
        </p>
       </section>
       <section>
        <a id="s0055">
        </a>
        <h3 class="h2hd" id="cesectitle0065">
         Case study: FMOD C++ API
        </h3>
        <p class="textfl" id="p0420">
         The following source code presents the same program you saw in the earlier section, except that this example uses the FMOD C++ API instead of the C API. Namespacing is now achieved using the C++ namespace feature, so that all classes and functions exist within the FMOD namespace. Also the include file for the API has the same base name as the C API, except that it uses an
         <span class="inlinecode">
          .hpp
         </span>
         extension to indicate that it’s a C++ header. Once again, error checking has been omitted to make the code more legible:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="1914" src="../../IMAGES/B9780443222191000209/main.assets/u05-10-9780443222191.jpg" width="2085"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p189">
         </a>
        </p>
        <div>
         <span aria-label="189" epub:type="pagebreak" id="pagebreak_189" role="doc-pagebreak">
         </span>
        </div>
       </section>
      </section>
      <section>
       <a id="s0060">
       </a>
       <h2 class="h1hd" id="cesectitle0070">
        Template-based APIs
       </h2>
       <p class="textfl" id="p0425">
        Templates are a feature of C++ that allow you to write functions or classes in terms of a generic yet-to-be-specified type. You can then specialize the template by instantiating it with a specific type or types. As a result, programming with templates is often called generic programming.
       </p>
       <p class="text" id="p0430">
        Templates are an extremely powerful and flexible tool. They can be used to write programs that generate code or that execute code at compile time (a technique known as metaprogramming). This can be used to achieve impressive results such as unrolling loops, precomputing certain values in a mathematical series, generating lookup tables at compile time, and expanding recursive functions that recurse a predetermined number of times. As such, templates can be used to perform work at compile time and thus improve run time performance.
       </p>
       <p class="text" id="p0435">
        However, it's not the focus of this book to provide a treatment of these aspects of template programming. There are many great books out there that already do this (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib3" id="bib_3">
         Alexandrescu, 2001
        </a>
        ;
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib100" id="bib_100">
         Vandevoorde and Josuttis, 2002
        </a>
        ). Instead, our focus will be on the use of templates for API design. In this regard, there are several examples of well-designed template-based APIs that you can look to for reference and inspiration, such as:
       </p>
       <div>
        <ol id="ulist0020">
         <li class="bulllist" id="p0440">
          <a id="u0200">
          </a>
          ▪
          <b>
           The C++ Standard Library.
          </b>
          All of the Standard Library container classes with which you're familiar, such as
          <span class="inlinecode">
           std::set
          </span>
          ,
          <span class="inlinecode">
           std::map
          </span>
          , and
          <span class="inlinecode">
           std::vector
          </span>
          , are class templates. That's why they can be used to hold data of different types.
         </li>
         <li class="bulllist" id="p0445">
          <a id="u0205">
          </a>
          ▪
          <b>
           Boost.
          </b>
          The Boost libraries provide a suite of powerful and useful features, many of which have since been added to the C++ standard. Most of the Boost classes use templates such as
          <span class="inlinecode">
           boost::shared_ptr
          </span>
          ,
          <span class="inlinecode">
           boost::function
          </span>
          , and
          <span class="inlinecode">
           boost::static_pointer_cast
          </span>
          .
         </li>
         <li class="bulllist" id="p0450">
          <a id="u0210">
          </a>
          ▪
          <b>
           Loki.
          </b>
          This is a library of class templates written by Andrei Alexandrescu to support his book,
          <i>
           Modern C++ Design
          </i>
          . It provides implementations of various design patterns, such as Visitor, Singleton, and Abstract Factory. This elegant code provides an exemplar of good template-based API design.
         </li>
        </ol>
       </div>
       <p class="text" id="p0455">
        Even though templates in C++ are often used in combination with object-oriented techniques, it's worth noting that the two are completely orthogonal concepts. Templates can be used equally well with free functions and with structs and unions (although of course, as you already know, structs are functionally equivalent to classes in C++, except for their default access level).
       </p>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         An example template-based API
        </h3>
        <p class="textfl" id="p0460">
         Continuing our stack example, let's look at how you would create a generic stack declaration using templates, and then instantiate it for integers. You can define the template-based stack class in terms of a generic type
         <span class="inlinecode">
          T
         </span>
         as:
         <a id="p190">
         </a>
         <span aria-label="190" epub:type="pagebreak" id="pagebreak_190" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0060">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000209/main.assets/u05-11-9780443222191.jpg" width="900"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0465">
         I have omitted the method definitions to keep the example clear. I will present some best practices for providing template definitions in the later chapter on C++ Usage. It's also worth noting that there's nothing special about the name
         <span class="inlinecode">
          T
         </span>
         . It's common to use the name
         <span class="inlinecode">
          T
         </span>
         for your generic type, but you could equally well call it
         <span class="inlinecode">
          MyGenericType
         </span>
         if you prefer.
        </p>
        <p class="text" id="p0470">
         With this declaration for a generic stack, you can then instantiate the template for the type
         <span class="inlinecode">
          int
         </span>
         by creating an object of type
         <span class="inlinecode">
          Stack&lt;int&gt;
         </span>
         . This will cause the compiler to generate code for this specific type instance. You could also define a simple typedef to make it more convenient to access this instance of the template, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0065">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000209/main.assets/u05-12-9780443222191.jpg" width="971"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0475">
         Then this
         <span class="inlinecode">
          IntStack
         </span>
         type can be used just as if you had written the class explicitly. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0070">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000209/main.assets/u05-13-9780443222191.jpg" width="1073"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         Templates versus macros
        </h3>
        <p class="textfl" id="p0480">
         An alternative to the templates approach would be to use the C preprocessor to define a block of text that you can stamp into the header multiple times, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0075">
           <img alt="image" height="892" src="../../IMAGES/B9780443222191000209/main.assets/u05-14-9780443222191.jpg" width="1179"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p191">
         </a>
        </p>
        <div>
         <span aria-label="191" epub:type="pagebreak" id="pagebreak_191" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0075">
         </a>
        </section>
        <p class="text" id="p0485">
         Aside from the ugliness of this code (e.g., having to end each line with a backslash and use preprocessor concatenation), the preprocessor has no notion of type checking or scoping. It's simply a text copying mechanism. This means that the declaration of the macro is not actually compiled, and so any errors in your macro will be reported on the single line where it's expanded, not where it's declared. Similarly, you can't step into your methods with a debugger because the whole code block is expanded in a single line of your source file. By contrast, templates provide a type-safe way to generate code at compile time, and you'll be able to debug into the actual lines of your class template.
        </p>
        <p class="text" id="p0490">
         Unless you're writing a plain C API and therefore don't have access to templates, you should avoid using the preprocessor to simulate templates.
        </p>
       </section>
       <section>
        <a id="s0075">
        </a>
        <h3 class="h2hd" id="cesectitle0085">
         Advantages of template-based APIs
        </h3>
        <p class="textfl" id="p0495">
         The obvious power of templates is that they let you create (instantiate) many different classes from a single root declaration. In our previous stack example, you could add support for string-based and floating-point stack classes simply by adding these declarations:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0080">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000209/main.assets/u05-15-9780443222191.jpg" width="1353"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0500">
         As such, templates can help to remove duplication because you don't need to copy, paste, and tweak the implementation code. Without templates, you would have to create (and maintain) a lot of very similar-looking code to support
         <span class="inlinecode">
          IntStack
         </span>
         ,
         <span class="inlinecode">
          StringStack
         </span>
         , and
         <span class="inlinecode">
          DoubleStack
         </span>
         class.
        </p>
        <p class="text" id="p0505">
         Another important property of templates is that they can provide static (compile time) polymorphism, as opposed to the use of inheritance, which provides dynamic (run time) polymorphism. One element of this is that templates allow the creation of different classes that all exhibit the same interface. For example, every instance of our stack class,
         <a id="p192">
         </a>
         <span aria-label="192" epub:type="pagebreak" id="pagebreak_192" role="doc-pagebreak">
         </span>
         whether
         <span class="inlinecode">
          IntStack
         </span>
         ,
         <span class="inlinecode">
          DoubleStack
         </span>
         , or
         <span class="inlinecode">
          StringStack
         </span>
         , is guaranteed to provide the same set of methods. You can also use templates to create functions that accept any of these types, without the run time cost of using virtual methods. This is achieved by generating different type-specific versions of the function at compile time. The following template function demonstrates this ability: it can be used to pop the topmost element from any of our stack types. In this example, two different versions of the function will be generated at compile time:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="1065" src="../../IMAGES/B9780443222191000209/main.assets/u05-16-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0510">
         A further benefit of templates is that you can specialize certain methods of a class for a specific type instance. For instance, our generic stack template is defined as
         <span class="inlinecode">
          Stack&lt;T&gt;
         </span>
         , but you could provide customized function implementations for certain types, such as for
         <span class="inlinecode">
          Stack&lt;int&gt;
         </span>
         . This is very handy for optimizing the class for certain types or for adding customizations for certain types that behave uniquely. This can be done by providing a method definition with the syntax:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000209/main.assets/u05-17-9780443222191.jpg" width="1490"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0080">
        </a>
        <h3 class="h2hd" id="cesectitle0090">
         Disadvantages of template-based APIs
        </h3>
        <p class="textfl" id="p0515">
         In terms of disadvantages of using templates, the most critical one for API design is that the definition of your class templates will normally have to appear in your public headers. This is because the compiler must have access to the entire definition of your template code to specialize it. This obviously exposes your internal details, which you
         <a id="p193">
         </a>
         <span aria-label="193" epub:type="pagebreak" id="pagebreak_193" role="doc-pagebreak">
         </span>
         know is a major sin of API development. It also means that the compiler will recompile the code each time the file is included, causing the generated code to be added to the object file for every module that uses the API. The result can be slower compilation times and code bloat (although C++11 introduced the notion of extern templates to address this). However, there are situations where you can in fact hide the implementation of a template in the
         <span class="inlinecode">
          .cpp
         </span>
         file, using a technique called explicit instantiation. I will discuss this technique in more detail in the next chapter on C++ Usage.
        </p>
        <p class="text" id="p0520">
         The previous static polymorphism example demonstrates another potential source of code bloat. This is because the compiler must generate code for each different version of the
         <span class="inlinecode">
          PopAnyStack()
         </span>
         function that's used. This is opposed to the virtual method flavor of polymorphism, which requires the compiler only to generate one such method, but then incurs a run time cost to know which class's
         <span class="inlinecode">
          IsEmpty()
         </span>
         and
         <span class="inlinecode">
          Pop()
         </span>
         methods to call. Therefore, if code size is more important to you than run time cost, you may decide to go with an object-oriented solution rather than use templates. Alternatively, if run time performance is critical for you, then templates may be the way to go.
        </p>
        <p class="text" id="p0525">
         Another commonly viewed disadvantage of templates is that most compilers can create verbose, long, or confusing messages for errors that occur in template code. It's common for simple errors in heavily templated code to produce dozens of lines of error output that cause you to scratch your head for a long time. In fact, there are even products on the market to simplify template error messages and make them easier to decipher, such as the STLFilt utility from BD Software. This is a concern not only for you as the developer of an API, but also for your clients because they will also be exposed to these voluble error messages if they use your API incorrectly. C++20 introduced a new feature called constraints to help alleviate this issue and provide more contextual template error messages.
        </p>
       </section>
      </section>
      <section>
       <a id="s0085">
       </a>
       <h2 class="h1hd" id="cesectitle0095">
        Functional APIs
       </h2>
       <p class="textfl" id="p0530">
        Functional programming is a programming style that relies on composing functions rather than executing sequences of imperative statements. It relies heavily on functions as a first-class concept, rather than objects. This approach is based on the formal system of computation called the lambda calculus, developed by Alonzo Church in 1936.
       </p>
       <p class="text" id="p0535">
        There are several programming languages that support only functional programming, such as Haskell, and there are others that support functional programming along with imperative style programming, such as C++. With the introduction of C++11, the language now has stronger support for functional programming, owing to additions like lambda functions and several new C++ Standard Library functions.
       </p>
       <section>
        <a id="s0090">
        </a>
        <h3 class="h2hd" id="cesectitle0100">
         Functional programming concepts
        </h3>
        <p class="textfl" id="p0540">
         Functional programming is a declarative programming style, meaning that it focuses more on what you want to do rather than the imperative approach of how you want to do
         <a id="p194">
         </a>
         <span aria-label="194" epub:type="pagebreak" id="pagebreak_194" role="doc-pagebreak">
         </span>
         it. That is, it focuses on the evaluation of expressions instead of the execution of statements (Čukić, 2018). For example, this imperative code shows how to calculate the average of a collection of integers:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000209/main.assets/u05-18-9780443222191.jpg" width="1318"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0545">
         whereas the following shows the same thing expressed in a functional style, using the C++20
         <span class="inlinecode">
          std::accumulate()
         </span>
         function:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000209/main.assets/u05-19-9780443222191.jpg" width="2324"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0550">
         In the functional programming style, functions are a first-class concept, so they can be passed as arguments to other functions, returned as the result of a function, and assigned to variables. For example, the
         <span class="inlinecode">
          std::accumulate
         </span>
         function also has an overloaded version in which you can provide a function to define an accumulation operator other than addition, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000209/main.assets/u05-20-9780443222191.jpg" width="2255"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0555">
         Another core aspect of functional programming is the use of pure functions. These are functions that have the attributes of:
        </p>
        <div>
         <ol id="ulist0025">
          <li class="bulllist" id="p0560">
           <a id="u0215">
           </a>
           •
           <b>
            Immutable arguments:
           </b>
           pure functions don't modify their arguments.
          </li>
          <li class="bulllist" id="p0565">
           <a id="u0220">
           </a>
           •
           <b>
            Stateless:
           </b>
           pure functions don't rely on any inputs other than their arguments.
          </li>
          <li class="bulllist" id="p0570">
           <a id="u0225">
           </a>
           •
           <b>
            No side effects:
           </b>
           pure functions don't mutate nonlocal variables or local static variables.
          </li>
         </ol>
        </div>
        <p class="text" id="p0575">
         As a result, pure functions can be called multiple times with the same arguments and they'll always return the same result. For example, mathematical functions such as
         <span class="inlinecode">
          sqrt()
         </span>
         and
         <span class="inlinecode">
          max()
         </span>
         can be implemented as pure functions, whereas
         <span class="inlinecode">
          rand()
         </span>
         and
         <span class="inlinecode">
          time()
         </span>
         cannot. (Note that a pure function in this context of functional programming is very different from a pure virtual function that's used in object-oriented C++ programming.)
         <a id="p195">
         </a>
        </p>
        <div>
         <span aria-label="195" epub:type="pagebreak" id="pagebreak_195" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0580">
         (It's interesting that there's been a proposal to add support for a
         <span class="inlinecode">
          [[pure]]
         </span>
         attribute to the C++ standard so that developers could specify a function as being pure. Among other things, this would allow compilers to perform more aggressive optimizations. However, at the time of writing this book, this proposal has not been adopted by the C++ standards committee).
        </p>
       </section>
       <section>
        <a id="s0095">
        </a>
        <h3 class="h2hd" id="cesectitle0105">
         An example functional API
        </h3>
        <p class="textfl" id="p0585">
         Continuing our example of defining an API for manipulating a stack, this behavior could be expressed in terms of a functional style by introducing various functions that operate on a stack data structure as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000209/main.assets/u05-21-9780443222191.jpg" width="2010"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0590">
         This design shows several pure functions that are contained within a
         <span class="inlinecode">
          stack
         </span>
         namespace and that can be chained together to create composite expressions, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000209/main.assets/u05-22-9780443222191.jpg" width="2357"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0595">
         This API also shows the use of functions as a first-class concept by introducing a
         <span class="inlinecode">
          pop_if()
         </span>
         function that accepts a function argument, in which elements will continue to be popped from the stack as long as the function returns true, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000209/main.assets/u05-23-9780443222191.jpg" width="1802"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0600">
         I've used the C++17
         <span class="inlinecode">
          [[nodiscard]]
         </span>
         attribute on each of the functions. That's because pure functions have no effect if their return value is not used, because they are defined to be stateless and without side effects. The use of
         <span class="inlinecode">
          [[nodiscard]]
         </span>
         will therefore generate a compiler warning if the user ignores the return result. This can help if the user assumes,
         <a id="p196">
         </a>
         <span aria-label="196" epub:type="pagebreak" id="pagebreak_196" role="doc-pagebreak">
         </span>
         incorrectly, that the function will modify the data structure in place instead of returning its result as a new data structure.
        </p>
        <p class="text" id="p0605">
         There are several other ways that a functional style stack API could be implemented. Often, you'll find that you want to combine functional programming with template programming, so that your functions can work on different types. The example I provided earlier works only on a stack of integers, so that I could focus on functional concepts, but you could, of course, extend it to use function templates that work on any type,
         <span class="inlinecode">
          T
         </span>
         . Also, many of the functional algorithms added to the C++ Standard Library, such as
         <span class="inlinecode">
          std::accumulate
         </span>
         ,
         <span class="inlinecode">
          std::copy_if
         </span>
         , and
         <span class="inlinecode">
          std::transform
         </span>
         , operate on iterators instead of containers. This makes them more general, but it also makes returning the results more convoluted and difficult to chain together as I did earlier.
        </p>
       </section>
       <section>
        <a id="s0100">
        </a>
        <h3 class="h2hd" id="cesectitle0110">
         Advantages of functional APIs
        </h3>
        <p class="textfl" id="p0610">
         Functional programming has been a popular style of programming for many years, largely because of the many benefits it offers. These benefits include:
        </p>
        <div>
         <ol id="ulist0030">
          <li class="bulllist" id="p0615">
           <a id="u0230">
           </a>
           •
           <b>
            Declarative style:
           </b>
           Because functional programming focuses more on the how than the what, it can result in more self-explanatory code. For example, rather than writing
           <span class="inlinecode">
            for
           </span>
           loops with custom logic to manipulate individual elements of a container, you can rely on higher-level functions such as
           <span class="inlinecode">
            for_each
           </span>
           ,
           <span class="inlinecode">
            transform
           </span>
           , and
           <span class="inlinecode">
            copy_if
           </span>
           .
          </li>
          <li class="bulllist" id="p0620">
           <a id="u0235">
           </a>
           •
           <b>
            Code readability:
           </b>
           Functional code can often be shorter than the equivalent imperative code because it tends to be specified at a higher level. This can help with the readability and maintainability of your clients' code.
          </li>
          <li class="bulllist" id="p0625">
           <a id="u0240">
           </a>
           •
           <b>
            Concurrency:
           </b>
           As I'll cover in the Concurrency chapter, the use of shared mutable state is the most common problem when trying to produce thread-safe code. However, pure functions are defined to have no shared state or side effects. They can therefore be trivially parallelized without the need to add synchronization primitives such as mutex locking.
          </li>
          <li class="bulllist" id="p0630">
           <a id="u0245">
           </a>
           •
           <b>
            Loose coupling:
           </b>
           The use of pure functions can also produce more robust code, and often fewer bugs as a result, because the lack of shared state and side effects removes any complex interactions with other parts of the system.
          </li>
          <li class="bulllist" id="p0635">
           <a id="u0250">
           </a>
           •
           <b>
            Testability:
           </b>
           A further benefit of pure functions is that they're easier to test. That's because they don't depend on external state, meaning that their behavior is fully expressed by the set of inputs that accept. Also, they will return the same result for the same set of inputs, making any automated tests more reproducible and robust.
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0105">
        </a>
        <h3 class="h2hd" id="cesectitle0115">
         Disadvantages of functional APIs
        </h3>
        <p class="textfl" id="p0640">
         Every programming style has its disadvantages as well as its advantages. In terms of the functional style, some potential concerns to bear in mind include:
         <a id="p197">
         </a>
         <span aria-label="197" epub:type="pagebreak" id="pagebreak_197" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <ol id="ulist0035">
          <li class="bulllist" id="p0645">
           <a id="u0255">
           </a>
           •
           <b>
            Memory usage:
           </b>
           Functional programming relies on making copies of data to avoid mutating existing variables. This style may therefore consume more memory than an equivalent imperative solution. This is a direct trade-off for all of the benefits of pure functions listed earlier. However, there may be optimizations that compilers can implement to offset these memory concerns, such as copy on write and return value optimization.
          </li>
          <li class="bulllist" id="p0650">
           <a id="u0260">
           </a>
           •
           <b>
            Performance:
           </b>
           Copying large amounts of memory can affect performance. Dedicated functional programming languages can often implement optimizations to offset these concerns, such as lazy evaluation and tail call recursion, but compilers for multiparadigm languages such as C++ may not be able to implement all of these optimizations as effectively.
          </li>
          <li class="bulllist" id="p0655">
           <a id="u0265">
           </a>
           •
           <b>
            Hardware compatibility:
           </b>
           Another aspect of performance is that imperative programming generally maps well to today's CPU and GPU architectures. However, functional programming does not map as well to modern hardware. The heavy use of recursion in traditional functional programming is one example, although it's fair to note that most functional implementations in C++ are implemented iteratively, not recursively.
          </li>
          <li class="bulllist" id="p0660">
           <a id="u0270">
           </a>
           •
           <b>
            Less support:
           </b>
           Objects and templates are the most common API styles for C++. As a result, there may be fewer functional programming experts that you can rely upon for your functional API designs and fewer resources such as tools and documentation available to you. Writing good functional APIs does require you to think differently, and the demands of producing a design for a general audience may require you to adopt the more mainstream methodologies.
          </li>
         </ol>
        </div>
       </section>
      </section>
      <section>
       <a id="s0110">
       </a>
       <h2 class="h1hd" id="cesectitle0120">
        Data-driven APIs
       </h2>
       <p class="textfl" id="p0665">
        A data-driven API can be differentiated from a code-driven API:
       </p>
       <div>
        <ol id="ulist0040">
         <li class="bulllist" id="p0670">
          <a id="u0275">
          </a>
          •
          <b>
           Code-driven API:
          </b>
          an engineer writes code that's compiled into a binary and distributed to clients for them to run. If new behavior is needed, the engineer changes the code and distributes a new binary to the clients. All of the examples so far in this chapter are examples of code-driven APIs.
         </li>
         <li class="bulllist" id="p0675">
          <a id="u0280">
          </a>
          •
          <b>
           Data-driven API:
          </b>
          an engineer writes code for a general engine that can read and interpret data from a file, where that file defines much of the run time behavior of the system. If new behavior is needed, a nonengineer (potentially even the client) could change the data file without needing to recompile the software.
         </li>
        </ol>
       </div>
       <p class="text" id="p0680">
        A data-driven program is therefore one that can perform different operations each time it's run by supplying it with different input data. For example, a data-driven program may simply accept the name of a file on disk that contains a list of commands to execute. This has an impact on the design of an API because it means that instead of relying on a collection of objects that provide various method calls, you provide more generic routines that accept named commands and a dictionary of named arguments. This is sometimes also called a message passing API or event-based API. The following function call formats illustrate how this API type differs from standard C and C++ calls:
        <a id="p198">
        </a>
        <span aria-label="198" epub:type="pagebreak" id="pagebreak_198" role="doc-pagebreak">
        </span>
       </p>
       <div>
        <ol id="ulist0045">
         <li class="bulllist" id="p0685">
          <a id="u0285">
          </a>
          ▪
          <span class="inlinecode">
           func(obj, a, b, c)
          </span>
          <span title='hsp="0.25"'>
          </span>
          =
          <span title='hsp="0.25"'>
          </span>
          flat C-style function
         </li>
         <li class="bulllist" id="p0690">
          <a id="u0290">
          </a>
          ▪
          <span class="inlinecode">
           obj.func(a, b, c)
          </span>
          <span title='hsp="0.25"'>
          </span>
          =
          <span title='hsp="0.25"'>
          </span>
          object-oriented C++ function
         </li>
         <li class="bulllist" id="p0695">
          <a id="u0295">
          </a>
          ▪
          <span class="inlinecode">
           send("func", a, b, c)
          </span>
          <span title='hsp="0.25"'>
          </span>
          =
          <span title='hsp="0.25"'>
          </span>
          data-driven function with positional parameters
         </li>
         <li class="bulllist" id="p0700">
          <a id="u0300">
          </a>
          ▪
          <span class="inlinecode">
           send("func", dict(arg1=a, arg2=b, arg2=c))
          </span>
          <span title='hsp="0.25"'>
          </span>
          =
          <span title='hsp="0.25"'>
          </span>
          data-driven function with a dictionary of named arguments (pseudocode).
         </li>
        </ol>
       </div>
       <div>
        <aside aria-labelledby="b0030" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0030">
          <p>
          </p>
          <div class="b1title" epub:type="title" id="title0020">
           <i>
            SIDEBAR: A data-driven dialogue engine
           </i>
          </div>
          <div class="b1textfl" id="bpar0040">
           <i>
            While at Apple, I developed a data-driven dialogue system for the Siri virtual assistant
           </i>
           (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib82" id="bib_82">
            Rhoten and Reddy, 2020
           </a>
           )
           <i>
            . This was driven by a data file format called Conversation Authoring Template (CAT), which could contain localized dialogue with embedded parameter values and conditional logic.
           </i>
          </div>
          <div class="b1text" id="bpar0045">
           <i>
            We developed an API that could load a CAT file for the current locale (
           </i>
           e.g.,
           <i>
            en-US or fr-FR) and accept various parameters from the run time code. The parameters would be formatted, correctly inflected for the locale, and inserted into the dialogue template. Conditions defined in the file could be used to select among different templates based on the input parameter values. The resulting localized dialogue would be spoken by Siri and shown on the display device.
           </i>
          </div>
          <div class="b1text" id="bpar0050">
           <i>
            Some of the benefits of this data-driven approach were that we could build rich authoring and localization GUI tools for nonengineers to use, we could employ extensive validation of the data files to catch errors early on, and we could push updates for Siri's dialogue to devices after an OS had shipped because the changes were expressed as data, not code.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <p class="text" id="p0705">
        To provide a concrete example of what this looks like, let's see how you might redesign our Stack example using a more data-driven model:
       </p>
       <div>
        <div class="pageavoid">
         <figure class="fig" id="f0125">
          <img alt="image" height="487" src="../../IMAGES/B9780443222191000209/main.assets/u05-24-9780443222191.jpg" width="1594"/>
          <figcaption class="figleg">
          </figcaption>
         </figure>
        </div>
       </div>
       <p class="text" id="p0710">
        This simple class could then be used to perform multiple operations, such as:
       </p>
       <div>
        <div class="pageavoid">
         <figure class="fig" id="f0130">
          <img alt="image" height="544" src="../../IMAGES/B9780443222191000209/main.assets/u05-25-9780443222191.jpg" width="1631"/>
          <figcaption class="figleg">
          </figcaption>
         </figure>
        </div>
       </div>
       <p class="textfl">
        <a id="p199">
        </a>
       </p>
       <div>
        <span aria-label="199" epub:type="pagebreak" id="pagebreak_199" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p0715">
        This is a more data-driven API because the individual methods have been replaced by a single method,
        <span class="inlinecode">
         Command()
        </span>
        , which supports multiple possible inputs specified as string data. One could easily imagine writing a simple program that could parse the contents of an ASCII text file containing various commands and executing each command in order. The input file could look something like:
       </p>
       <div>
        <div class="pageavoid">
         <figure class="fig" id="f0135">
          <img alt="image" height="313" src="../../IMAGES/B9780443222191000209/main.assets/u05-26-9780443222191.jpg" width="1352"/>
          <figcaption class="figleg">
          </figcaption>
         </figure>
        </div>
       </div>
       <p class="text" id="p0720">
        A program to consume this data file using the previous data-driven API would simply take the first whitespace-delimited string on each line (ignoring blank lines and lines that begin with # as a convenience). The program could then create an
        <span class="inlinecode">
         ArgList
        </span>
        structure for any further whitespace-delimited strings that follow the initial command. It would then pass those to the
        <span class="inlinecode">
         Stack::Command()
        </span>
        and continue processing the remainder of the file. This program could then perform vastly different stack operations by supplying a different text file, and notably without requiring the program to be recompiled.
       </p>
       <section>
        <a id="s0115">
        </a>
        <h3 class="h2hd" id="cesectitle0125">
         Advantages of data-driven APIs
        </h3>
        <p class="textfl" id="p0725">
         I've already pointed out one of the major benefits of data-driven APIs: that the business logic of a program can be abstracted out into a human-editable data file. In this way, the behavior of a program can be modified without the need to recompile the executable.
        </p>
        <p class="text" id="p0730">
         You may even decide to support a separate design tool to let users easily author the data file. Several commercial packages work this way, such as FMOD, which includes the FMOD Designer program that allows complex authoring of sound effects. The resulting
         <span class="inlinecode">
          .fev
         </span>
         files can be loaded by the data-driven FMOD Event API. Also, the Qt UI toolkit includes the Qt Designer application that lets users create user interfaces in a visual and interactive fashion. The resulting
         <span class="inlinecode">
          .ui
         </span>
         files can be loaded at run time by Qt's QUiLoader class.
        </p>
        <p class="text" id="p0735">
         Another major benefit of a data-driven API is that it tends to be far more tolerant of future API changes. That's because adding, removing, or changing a command can in many cases have no effect on the signatures of the public API methods. Often it will simply change the supported set of strings that can be passed to the command handler. In other words, passing an unsupported or obsolete command to the handler will not produce a compile-time error. Similarly, different versions of a command can be supported based upon the number and type of arguments that are provided, essentially mimicking C++’s method overloading.
        </p>
        <p class="text" id="p0740">
         Taking the earlier example of our data-driven Stack API, which simply provides a
         <span class="inlinecode">
          Stack::Command()
         </span>
         method, a newer version of the API might add support for a
         <span class="inlinecode">
          Top
         </span>
         command (to return the topmost element without popping it) and could also extend the
         <span class="inlinecode">
          Push
         </span>
         command to accept multiple values, each of which are pushed onto the stack in turn. An example program using these new features might look like:
         <a id="p200">
         </a>
         <span aria-label="200" epub:type="pagebreak" id="pagebreak_200" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0140">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000209/main.assets/u05-27-9780443222191.jpg" width="2256"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0745">
         Adding this new functionality involved no change whatsoever to the function signatures in the header file. It merely changed the supported strings, and the list of arguments, which can be passed to the
         <span class="inlinecode">
          Command()
         </span>
         method. Because of this property, it's much easier to create backward compatible API changes when using a data-driven model, even when removing or changing existing commands. Similarly, it's much easier to create binary compatible changes because it's more likely that you'll not need to change the signature of any of your public methods.
        </p>
        <p class="text" id="p0750">
         One further benefit of data-driven APIs is that they more easily support data-driven testing techniques. This is an automated testing technique in which, instead of writing lots of individual test programs or routines to exercise an API, you can simply write a single data-driven program that reads a file containing a series of commands to perform and assertions to check. Then, writing multiple tests means simply creating multiple input data files. Test development iteration can therefore be faster because no compilation step is required to create a new test. Also, QA engineers who do not possess deep C++ development skills can still write tests for your API.
        </p>
        <p class="text" id="p0755">
         Remaining with our Stack example, you could create a test program that accepts input data files such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0145">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000209/main.assets/u05-28-9780443222191.jpg" width="1975"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0760">
         This test program is very similar to the program I described earlier to read Stack commands from a data file. The main difference is that I've added support for a =&gt; symbol, which lets you check the result returned by the
         <span class="inlinecode">
          Stack::Command()
         </span>
         method. With that small addition, you now have a flexible testing framework that allows you to create any number of data-driven tests for our API.
         <a id="p201">
         </a>
         <span aria-label="201" epub:type="pagebreak" id="pagebreak_201" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0035" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0035">
           <div class="b1textfl" id="bpar0055">
            <i>
             TIP: Data-driven APIs map well to Web services and other client/server APIs. They also support data-driven testing techniques.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0120">
        </a>
        <h3 class="h2hd" id="cesectitle0130">
         Disadvantages of data-driven APIs
        </h3>
        <p class="textfl" id="p0765">
         As I've stated, the data-driven model is not appropriate for all interfaces. It may be useful for data communication interfaces such as Web services or for client/server message passing. However, it would not be an appropriate choice for a real-time 3D graphics API.
        </p>
        <p class="text" id="p0770">
         For one reason, the simplicity and stability of the API comes with a run time cost. This is because of the additional overhead of finding the correct internal routine to call given a command name string. The use of an internal hash table or dictionary that maps supported command names to callable functions can speed this process, but it will never be as fast as calling a function directly.
        </p>
        <p class="text" id="p0775">
         It's also worth noting that data-driven systems may require additional functionality to be built that you would not normally need for a code-driven solution. For example, with a code-driven solution you can rely on the compiler to emit warnings and errors if you make mistakes representing the logic of your program. However, with a data-driven approach you may need to write your own validation routines for the data formats that you support, so that you can detect syntactic and semantic errors in the data file inputs. You may also need to build a robust versioning system for your data format, so that your code can handle older or newer formats appropriately.
        </p>
        <p class="text" id="p0780">
         Furthermore, another downside of data-driven APIs is that your physical header files do not reflect your logical interface. This means that a user cannot simply look at your public header files and know what functionality and semantics are provided by the interface. However, recall in the first section of this book that I defined an API as a collection of header files … and associated documentation. So, as long as you provide good API documentation to specify the list of supported commands and their expected arguments, you can reasonably compensate for this disadvantage.
        </p>
       </section>
       <section>
        <a id="s0125">
        </a>
        <h3 class="h2hd" id="cesectitle0135">
         Supporting variant argument lists
        </h3>
        <p class="textfl" id="p0785">
         Up to this point, I have glossed over the use of our
         <span class="inlinecode">
          Result
         </span>
         and
         <span class="inlinecode">
          ArgList
         </span>
         types in the various previous examples. These are meant to represent data values that can contain differently typed values that may not be known at compile time. For example,
         <span class="inlinecode">
          ArgList
         </span>
         <a id="p202">
         </a>
         <span aria-label="202" epub:type="pagebreak" id="pagebreak_202" role="doc-pagebreak">
         </span>
         could be used to pass no arguments, a single integer argument, or two arguments in which one is a string and the other is a float. Weakly typed languages such as Python explicitly support this concept, but traditionally C++ has not: arrays and containers must contain elements that are all the same type, and where that type must be known at compile time.
        </p>
        <p class="text" id="p0790">
         However, C++17 introduced the
         <span class="inlinecode">
          std::any
         </span>
         type, which provides a type-safe way to hold a value of different types. This can therefore be used to parse arbitrary data from a file. For example, the following types can be used to represent a dictionary of arbitrarily typed values, such as a JavaScript Object Notation (JSON) object, using the C++
         <span class="inlinecode">
          any
         </span>
         type:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0150">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000209/main.assets/u05-29-9780443222191.jpg" width="1492"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0795">
         This would allow us to create an interface with an optional number of named arguments that can be of type bool, int, double, or string. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0155">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000209/main.assets/u05-30-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0800">
         You can now support methods that accept a single parameter of type
         <span class="inlinecode">
          ArgList
         </span>
         , which can be used to pass any combination of
         <span class="inlinecode">
          bool
         </span>
         ,
         <span class="inlinecode">
          int
         </span>
         ,
         <span class="inlinecode">
          double
         </span>
         , or
         <span class="inlinecode">
          std::string
         </span>
         arguments. As such, future changes to the API behavior (e.g., adding a new argument to the list of arguments supported by the method) can be made without changing the actual signature of the method.
        </p>
       </section>
       <section>
        <a id="s0130">
        </a>
        <h3 class="h2hd" id="cesectitle0140">
         Case study: FMOD data-driven API
        </h3>
        <p class="textfl" id="p0805">
         Here, I present a simple program using the FMOD data-driven API, to give a real-world example of this API style. This is only one example of a data-driven interface, and it does not illustrate all of the concepts that I've discussed. However, it does illustrate the case in which much of the logic is stored in a data file that's loaded at run time. This is the
         <span class="inlinecode">
          sound.fev
         </span>
         file, which is created by the FMOD Designer tool. The program then shows accessing a named parameter of an event in that file and changing that parameter's value:
         <a id="p203">
         </a>
         <span aria-label="203" epub:type="pagebreak" id="pagebreak_203" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0160">
           <img alt="image" height="2376" src="../../IMAGES/B9780443222191000209/main.assets/u05-31-9780443222191.jpg" width="1679"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0135">
        </a>
        <h3 class="h2hd" id="cesectitle0145">
         Data-driven Web services
        </h3>
        <p class="textfl" id="p0810">
         Not all interfaces are appropriately represented with a data-driven style. However, this style is particularly suited to stateless communication channels such as client/server
         <a id="p204">
         </a>
         <span aria-label="204" epub:type="pagebreak" id="pagebreak_204" role="doc-pagebreak">
         </span>
         applications in which the API allows commands to be sent to a server and optionally to return results to the client. It's also useful for passing messages between loosely coupled components and for working with inherently data-driven entities such as file formats.
        </p>
        <p class="text" id="p0815">
         Web services in particular can be naturally represented using a data-driven API. A Web service is normally accessed by sending a URL with a set of query parameters to a given Web service, or by sending a message in some structured format such as JSON or XML. For instance, the Digg website supports an API to let users interact with the
         <a href="http://Digg.com">
          Digg.com
         </a>
         Web service. As a specific example, the Digg API provides the
         <span class="inlinecode">
          digg.getInfo
         </span>
         call to return extended information for a specific digg on a story. This is invoked by sending an HTTP GET request in the form:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0165">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000209/main.assets/u05-32-9780443222191.jpg" width="2358"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0820">
         This maps well to the sort of data-driven APIs I've presented earlier, in which an HTTP request such as this could be invoked as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0170">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000209/main.assets/u05-33-9780443222191.jpg" width="1975"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0825">
         This correlates very closely to the underlying protocol, although it still provides an abstraction from the details of that protocol. For example, the implementation can still decide whether it's more appropriate to send the request as a GET or POST, or even a JSON or XML description.
        </p>
       </section>
       <section>
        <a id="s0140">
        </a>
        <h3 class="h2hd" id="cesectitle0150">
         Idempotency
        </h3>
        <p class="textfl" id="p0830">
         Because I'm discussing client/server applications, it's worth covering the topic of idempotency here, as well. An API is considered idempotent if calling a function more than once with the same set of parameters has no additional effect. For example, removing an element from an
         <span class="inlinecode">
          std:set
         </span>
         or
         <span class="inlinecode">
          std:map
         </span>
         is idempotent because if you attempt to remove the same element multiple times, the contents of the data structure will be the same as if you tried to remove the element only once.
        </p>
        <p class="text" id="p0835">
         Here's a simple example of an idempotent API, in which you can get or set a vector of strings, check if a string exists in the vector, and remove a string from the vector:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0175">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000209/main.assets/u05-34-9780443222191.jpg" width="2045"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0840">
         This API is idempotent because repeating any method call with the same input parameters will not change the underlying state of the object; for example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0180">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000209/main.assets/u05-35-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0845">
         will have the same effect as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0185">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000209/main.assets/u05-36-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0850">
         However, we could extend this API with a new
         <span class="inlinecode">
          AddLabel()
         </span>
         function to append a label to the vector of strings, in which the string argument is always appended to the vector even if it already exists. This new API might look like:
         <a id="p205">
         </a>
         <span aria-label="205" epub:type="pagebreak" id="pagebreak_205" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0190">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000209/main.assets/u05-37-9780443222191.jpg" width="2045"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0855">
         This new API call is not idempotent because calling
         <span class="inlinecode">
          AddLabel()
         </span>
         multiple times will change the underlying data structure each time we call it:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0195">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000209/main.assets/u05-38-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0860">
         will produce a vector with one string in it, whereas:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0200">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000209/main.assets/u05-39-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0865">
         will produce a vector with two strings in it. So repeating the function call produced a different end state.
        </p>
        <p class="text" id="p0870">
         Enforcing an idempotent API is not something that you need to strive for in most cases: many well-designed APIs are not idempotent and that's fine. However, there are a few problem domains where having an idempotent interface is desirable because it offers additional fault tolerance guarantees. The most common example is when dealing with network protocols. As such, you often hear about idempotency with respect to RESTful Web APIs.
        </p>
        <p class="text" id="p0875">
         When sending information over a network, you can sometimes encounter time-outs or network outages. In the face of such errors, a common strategy is for the client to resend the original request to the server. With an idempotent interface, the client can safely retransmit the same request without being concerned that the data on the server will be corrupted by being applied multiple times. For example, imagine a banking application in which the client sends a money transfer request to the server. If the request times out and is resent by the client, then in a nonidempotent system there's a possibility that two transfers are executed instead of one.
         <a id="p206">
         </a>
        </p>
        <div>
         <span aria-label="207" epub:type="pagebreak" id="pagebreak_207" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="st0010">
         </a>
         <div class="pageavoid">
          <p class="tnum">
           <a href="#Bt0010">
            Table 5.1
           </a>
          </p>
          <table class="tbody" id="t0010">
           <caption class="ttitle">
            <a id="tspara0010">
            </a>
            HTTP methods and whether they are idempotent.
           </caption>
           <thead>
            <tr>
             <th class="tcolhd1" scope="col">
              HTTP method
             </th>
             <th class="tcolhd1" scope="col">
              Is idempotent?
             </th>
            </tr>
           </thead>
           <tbody>
            <tr>
             <th class="tb" scope="row">
              HEAD
             </th>
             <td class="tb">
              Yes
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              GET
             </th>
             <td class="tb">
              Yes
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              OPTIONS
             </th>
             <td class="tb">
              Yes
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              TRACE
             </th>
             <td class="tb">
              Yes
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              PUT
             </th>
             <td class="tb">
              Yes
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              DELETE
             </th>
             <td class="tb">
              Yes
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              POST
             </th>
             <td class="tb">
              No
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              PATCH
             </th>
             <td class="tb">
              No
             </td>
            </tr>
           </tbody>
          </table>
         </div>
        </section>
        <p class="text" id="p0880">
         Because idempotency is concerned primarily with the effect of an API call on the underlying state of the system, any read-only API calls can be considered idempotent. Similarly, any calls that replace the representation of an existing data entry, or any calls that delete a data entry, can also be considered idempotent because they can be repeated safely (as shown in the previous example). But calls that add new data to the system are generally not idempotent.
        </p>
        <p class="text" id="p0885">
         In terms of the HTTP protocol,
         <a href="#t0010" id="Bt0010">
          Table 5.1
         </a>
         indicates which HTTP methods are considered idempotent and which are not (according to RFC 9110).
        </p>
        <p class="text" id="p0890">
         It's possible to make an operation such as a POST HTTP call become idempotent. A common way to do this is to introduce a unique identifier that's generated for each data-modifying request. The server can keep a record of the recent transaction GUIDs, and if it encounters a GUID that it’s already seen, it can ignore the request and return an appropriate success response without modifying the underlying data a second time.
        </p>
        <p class="text" id="p0895">
         It's not necessary for the duplicate call to return the same server response as the first one: idempotency is about ensuring the consistency of the data, so it could be valid for the second request to return a result indicating that it was ignored, and the client can choose how it wants to handle that information. It's also worth noting that the server may log a list of all requests that have been received, including any duplicate requests, so in that way the total underlying state will be different after a duplicate request, but the core business logic state should be unaffected.
        </p>
        <p class="text" id="p0900">
         So, in terms of API design guidelines, when a data-modifying operation is required to be fault tolerant, you can consider introducing a transaction GUID for each action so that the host can use this to handle duplicate requests correctly. Or, more generally, you could introduce the concept of beginning and ending an atomic transaction, in which the transaction is either guaranteed to be entirely executed or not at all, such as with a
         <span class="inlinecode">
          BeginTransaction()
         </span>
         and
         <span class="inlinecode">
          EndTranscation()
         </span>
         pair of functions in your API.
        </p>
       </section>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
