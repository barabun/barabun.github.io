<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   18Standard Library Containers
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_028.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_030.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c18_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c18_1">
      <span aria-label="683" epub:type="pagebreak" id="Page_683" role="doc-pagebreak">
      </span>
      <span id="c18">
      </span>
      <span class="chapterNumber">
       18
      </span>
      <br/>
      <span class="chapterTitle">
       Standard Library Containers
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c18-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c18-list-0001">
         <li id="c18-li-0001">
          Containers overview: requirements on elements and general error handling
         </li>
         <li id="c18-li-0002">
          Sequential containers:
          <code>
           vector
          </code>
          ,
          <code>
           deque
          </code>
          ,
          <code>
           list
          </code>
          ,
          <code>
           forward_list
          </code>
          , and
          <code>
           array
          </code>
         </li>
         <li id="c18-li-0003">
          Sequential views: span and mdspan
         </li>
         <li id="c18-li-0004">
          Container adapters:
          <code>
           queue
          </code>
          ,
          <code>
           priority_queue
          </code>
          , and
          <code>
           stack
          </code>
         </li>
         <li id="c18-li-0005">
          The
          <code>
           pair
          </code>
          utility class template
         </li>
         <li id="c18-li-0006">
          Associative containers:
          <code>
           map
          </code>
          ,
          <code>
           multimap
          </code>
          ,
          <code>
           set
          </code>
          , and
          <code>
           multiset
          </code>
         </li>
         <li id="c18-li-0007">
          Unordered associative containers or hash tables:
          <code>
           unordered_map
          </code>
          ,
          <code>
           unordered_multimap
          </code>
          ,
          <code>
           unordered_set
          </code>
          , and
          <code>
           unordered_multiset
          </code>
         </li>
         <li id="c18-li-0008">
          Flat associative container adapters:
          <code>
           flat_map
          </code>
          ,
          <code>
           flat_multimap
          </code>
          ,
          <code>
           flat_set
          </code>
          , and
          <code>
           flat_multiset
          </code>
         </li>
         <li id="c18-li-0009">
          Other containers: standard C-style arrays,
          <code>
           string
          </code>
          s, streams, and
          <code>
           bitset
          </code>
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <span id="c18-fea-0001">
        </span>
        <h3 id="head-2-197">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c18-sec-0003">
        </span>
        <p id="c18-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code>
          <code>
           <a href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c18-para-0005">
      This chapter of the Standard Library deep-dive chapters covers the available containers. It explains the different containers, their categories, and what the trade-offs are between them.
      <span aria-label="684" epub:type="pagebreak" id="Page_684" role="doc-pagebreak">
      </span>
      Some containers are discussed in much more detail compared to others. Once you know how to work with a container of each category, you will have no problems using any of the other containers from the same category. Consult your favorite Standard Library Reference for a complete reference of all member functions of all containers.
     </p>
    </section>
    <section aria-labelledby="head-2-198">
     <span id="c18-sec-0004">
     </span>
     <h2 id="head-2-198">
      CONTAINERS OVERVIEW
     </h2>
     <p id="c18-para-0006">
      Containers in the Standard Library are generic data structures that are useful for storing collections of data. You should rarely need to use a standard C-style array, write a linked list, or design a stack when you use the Standard Library. The containers are implemented as class templates, so you can instantiate them for any type that meets certain basic conditions outlined in the next section. Most of the Standard Library containers, except for
      <code>
       array
      </code>
      and
      <code>
       bitset
      </code>
      , are flexible in size and automatically grow or shrink to accommodate more or fewer elements. This is a huge benefit compared to the old, C-style arrays, which had a fixed size. Because of the fixed-size nature of C-style arrays, they are more vulnerable to overruns, which in the simplest cases merely cause the program to crash because data has been corrupted, but in the worst cases allow certain kinds of security attacks. By using Standard Library containers, you ensure that your programs will be less vulnerable to these kinds of problems.
     </p>
     <p id="c18-para-0007">
      <a href="c16.xhtml">
       Chapter 16
      </a>
      , “Overview of the C++ Standard Library,” gives a high-level overview of the different containers, container adapters, and sequential views provided by the Standard Library. The following table summarizes them.
     </p>
     <table border="1">
      <tbody>
       <tr>
        <td class="left bor1 bgcolor3">
         <ul class="check5" id="c18-list-0002">
          <li id="c18-li-0010">
           <b>
            Sequential containers
           </b>
           <ul class="check5">
            <li id="c18-li-0011">
             <code>
              vector
             </code>
             (dynamic array)
            </li>
            <li id="c18-li-0012">
             <code>
              deque
             </code>
            </li>
            <li id="c18-li-0013">
             <code>
              list
             </code>
            </li>
            <li id="c18-li-0014">
             <code>
              forward_list
             </code>
            </li>
            <li id="c18-li-0015">
             <code>
              array
             </code>
            </li>
           </ul>
          </li>
          <li id="c18-li-0016">
           <b>
            Sequential views
           </b>
           <ul class="check5">
            <li id="c18-li-0017">
             <code>
              span
             </code>
            </li>
            <li id="c18-li-0018">
             <code>
              mdspan
             </code>
            </li>
           </ul>
          </li>
          <li id="c18-li-0019">
           <b>
            Container adapters
           </b>
           <ul class="check5">
            <li id="c18-li-0020">
             <code>
              queue
             </code>
            </li>
            <li id="c18-li-0021">
             <code>
              priority_queue
             </code>
            </li>
            <li id="c18-li-0022">
             <code>
              stack
             </code>
            </li>
           </ul>
          </li>
         </ul>
        </td>
        <td class="left bor1 bgcolor3">
         <ul class="check5" id="c18-list-0003">
          <li id="c18-li-0023">
           <b>
            Ordered associative containers
           </b>
           <ul class="check5">
            <li id="c18-li-0024">
             <code>
              map / multimap
             </code>
            </li>
            <li id="c18-li-0025">
             <code>
              set / multiset
             </code>
            </li>
           </ul>
          </li>
          <li id="c18-li-0026">
           <b>
            Unordered associative containers or hash tables
           </b>
           <ul class="check5">
            <li id="c18-li-0027">
             <code>
              unordered_map / unordered_multimap
             </code>
            </li>
            <li id="c18-li-0028">
             <code>
              unordered_set / unordered_multiset
             </code>
            </li>
           </ul>
          </li>
          <li id="c18-li-0029">
           <b>
            Flat set and flat map associative container adapters
           </b>
           <ul class="check5">
            <li id="c18-li-0030">
             <code>
              flat_map / flat_multimap
             </code>
            </li>
            <li id="c18-li-0031">
             <code>
              flat_set / flat_multiset
             </code>
            </li>
           </ul>
          </li>
         </ul>
        </td>
       </tr>
      </tbody>
     </table>
     <p id="c18-para-0010">
      Additionally, C++
      <code>
       string
      </code>
      s and streams can also be used as Standard Library containers to a certain degree, and
      <code>
       bitset
      </code>
      can be used to store a fixed number of bits.
     </p>
     <p id="c18-para-0011">
      <span aria-label="685" epub:type="pagebreak" id="Page_685" role="doc-pagebreak">
      </span>
      Everything in the Standard Library is in the
      <code>
       std
      </code>
      namespace. As always, the examples in this book usually use the blanket
      <code>
       using namespace std;
      </code>
      directive in source files (never use this in header files!), but you can be more selective in your own programs about which symbols from
      <code>
       std
      </code>
      to use.
     </p>
     <section>
      <span id="c18-sec-0005">
      </span>
      <h3 id="head-3-398">
       Requirements on Elements
      </h3>
      <p id="c18-para-0012">
       Standard Library containers use value semantics on elements. That is, they store a copy of elements that they are given, assign to elements with the assignment operator, and destroy elements with the destructor. Thus, when you write classes that you intend to use with the Standard Library, you need to make sure they are copyable. When requesting an element from the container, a reference to the stored copy is returned.
      </p>
      <p id="c18-para-0013">
       If you prefer reference semantics, you can store pointers to elements instead of the elements themselves. When the containers copy a pointer, the result still refers to the same element. An alternative is to store
       <code>
        std::reference:wrapper
       </code>
       s in the container. A
       <code>
        reference:wrapper
       </code>
       basically exists to make references copyable and can be created using the
       <code>
        std::ref()
       </code>
       and
       <code>
        cref()
       </code>
       helper functions. The
       <code>
        reference:wrapper
       </code>
       class template, and the
       <code>
        ref()
       </code>
       and
       <code>
        cref()
       </code>
       function templates are defined in
       <code>
        &lt;functional&gt;
       </code>
       . An example of this is given in the section “
       <a href="#c18-sec-0034">
        Storing References in a vector
       </a>
       ” later in this chapter.
      </p>
      <p>
       It is possible to store move-only types, i.e., non-copyable types, in a container, but when doing so, some operations on the container might not compile. An example of a move-only type is
       <code>
        std::unique_ptr
       </code>
       .
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0015">
          <b>
           WARNING
          </b>
          <i>
           If you need to store pointers in containers, if possible, use
          </i>
          <code>
           unique_ptr
          </code>
          <i>
           s if the container becomes the owner of the pointed-to objects, or use
          </i>
          <code>
           shared_ptr
          </code>
          <i>
           s if the container shares ownership with other owners. Do not use the old and removed
          </i>
          <code>
           auto_ptr
          </code>
          <i>
           class in containers because it does not implement copying correctly.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       One of the template type parameters for Standard Library containers is an allocator. The container uses this allocator to allocate and deallocate memory for elements. The allocator type parameter has a default value, so you can almost always just ignore it. For example, the
       <code>
        vector
       </code>
       class template looks as follows:
      </p>
      <pre id="c18-code-0001"><code>template &lt;typename T, <b>typename Allocator = std::allocator&lt;T&gt;</b>&gt; class vector;</code></pre>
      <p>
       Some containers, such as a
       <code>
        map
       </code>
       , additionally accept a comparator as one of the template type parameters. This comparator is used to order elements. It has a default value as well, so you don't always have to specify it. This default is to compare elements using
       <code>
        operator&lt;
       </code>
       . The
       <code>
        map
       </code>
       class template looks like this:
      </p>
      <pre id="c18-code-0002"><code>template &lt;typename Key, typename T, <b>typename Compare = std::less&lt;Key&gt;</b>,</code>
<code>    typename Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt; class map;</code></pre>
      <p id="c18-para-0018">
       Both the allocator and the comparator template type parameters are discussed in detail later in this chapter.
      </p>
      <p id="c18-para-0019">
       <span aria-label="686" epub:type="pagebreak" id="Page_686" role="doc-pagebreak">
       </span>
       The specific requirements on elements in containers using the default allocator and default comparator are shown in the following table:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          MEMBER FUNCTION
         </th>
         <th class="left bgcolor2" scope="col">
          DESCRIPTION
         </th>
         <th class="bgcolor2" colspan="4" scope="colgroup">
          NOTES
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          Copy Constructor
         </td>
         <td class="left bor1 bgcolor3">
          Creates a new element that is “equal” to the old one, but that can safely be destructed without affecting the old one.
         </td>
         <td class="bgcolor3" colspan="4">
          Used every time you insert an element, except when using an emplace member function (discussed later).
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          Move Constructor
         </td>
         <td class="left bor1 bgcolor3">
          Creates a new element by moving all content from the source element to the new element.
         </td>
         <td class="bgcolor3" colspan="4">
          Used when the source element is an rvalue, and will be destroyed after the construction of the new element; also used when a
          <code>
           vector
          </code>
          grows in size. The move constructor should be
          <code>
           noexcept
          </code>
          ; otherwise, it won't be used!
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          Assignment Operator
         </td>
         <td class="left bor1 bgcolor3">
          Replaces the contents of an element with a copy of the source element.
         </td>
         <td class="bgcolor3" colspan="4">
          Used every time you modify an element.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          Move Assignment Operator
         </td>
         <td class="left bor1 bgcolor3">
          Replaces the contents of an element by moving all content from the source element.
         </td>
         <td class="bgcolor3" colspan="4">
          Used when the source element is an rvalue and will be destroyed after the assignment operation. The move assignment operator should be
          <code>
           noexcept;
          </code>
          otherwise, it won't be used!
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          Destructor
         </td>
         <td class="left bor1 bgcolor3">
          Cleans up an element.
         </td>
         <td class="bgcolor3" colspan="4">
          Used every time you remove an element, or when a
          <code>
           vector
          </code>
          grows in size.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          Default Constructor
         </td>
         <td class="left bor1 bgcolor3">
          Constructs an element without any arguments.
         </td>
         <td class="bgcolor3" colspan="4">
          Required only for certain operations, such as the
          <code>
           vector::resize()
          </code>
          member function with one argument, and the
          <code>
           map::operator[]
          </code>
          access.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator==
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Compares two elements for equality.
         </td>
         <td class="bgcolor3" colspan="4">
          Required for keys in unordered associative containers, and for certain operations, such as
          <code>
           operator==
          </code>
          on two containers.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&lt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Determines whether one element is less than another.
         </td>
         <td class="bgcolor3" colspan="4">
          Required for keys in ordered associative containers and flat associative container adapters, and for certain operations, such as
          <code>
           operator&lt;
          </code>
          on two containers.
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&gt;,
          </code>
          <code>
           &lt;=
          </code>
          ,
          <code>
           &gt;=
          </code>
          ,
          <code>
           !=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Compares two elements.
         </td>
         <td class="left bor1 bgcolor3">
          Required when comparing two containers.
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       <a href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” explains how to write these member functions.
       <span aria-label="687" epub:type="pagebreak" id="Page_687" role="doc-pagebreak">
       </span>
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0023">
          <b>
           WARNING
          </b>
          <i>
           The Standard Library containers often move or copy elements. So, for best performance, make sure the type of objects stored in a container supports move semantics, see
           <a href="c09.xhtml">
            Chapter 9
           </a>
           . If move semantics is not possible, make sure the copy constructor and copy assignment operator are as efficient as possible
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c18-sec-0008">
      </span>
      <h3 id="head-3-399">
       Exceptions and Error Checking
      </h3>
      <p id="c18-para-0024">
       The Standard Library containers provide limited error checking. Clients are expected to ensure that their uses are valid. However, some container member functions throw exceptions in certain conditions, such as out-of-bounds indexing. Of course, it is impossible to list exhaustively the exceptions that can be thrown from these member functions because they perform operations on user-specified types with unknown exception characteristics. This chapter mentions exceptions where appropriate. Consult a Standard Library Reference (see
       <a href="b02.xhtml">
        Appendix B
       </a>
       , “Annotated Bibliography”) for a list of possible exceptions thrown from each member function.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-199">
     <span id="c18-sec-0009">
     </span>
     <h2 id="head-2-199">
      SEQUENTIAL CONTAINERS
     </h2>
     <p id="c18-para-0025">
      <code>
       vector
      </code>
      ,
      <code>
       deque
      </code>
      ,
      <code>
       list
      </code>
      ,
      <code>
       forward_list
      </code>
      , and
      <code>
       array
      </code>
      are called
      <i>
       sequential containers
      </i>
      because they store a sequence of elements. The best way to learn about sequential containers is to jump in with an example of the
      <code>
       vector
      </code>
      container, which should be your default container anyway. The next section describes the
      <code>
       vector
      </code>
      container in detail, followed by briefer discussions of
      <code>
       deque
      </code>
      ,
      <code>
       list
      </code>
      ,
      <code>
       forward_list
      </code>
      , and
      <code>
       array
      </code>
      . Once you become familiar with the sequential containers, it's trivial to switch between them.
     </p>
     <section>
      <span id="c18-sec-0010">
      </span>
      <h3 id="head-3-400">
       vector
      </h3>
      <p id="c18-para-0026">
       The Standard Library
       <code>
        vector
       </code>
       container is similar to a standard C-style array: the elements are stored in contiguous memory, each in its own “slot.” You can index into a
       <code>
        vector
       </code>
       , as well as add new elements to the back or insert them anywhere else. Inserting and deleting elements into and from a
       <code>
        vector
       </code>
       generally takes linear time, though these operations actually run in
       <i>
        amortized constant
       </i>
       time at the end of a
       <code>
        vector
       </code>
       , as explained in the section “
       <a href="#c18-sec-0042">
        The vector Memory Allocation Scheme
       </a>
       ,” later in this chapter. Random access of individual elements has a constant complexity; see
       <a href="c04.xhtml">
        Chapter 4
       </a>
       , “Designing Professional C++ Programs,” for a discussion on algorithm complexity.
      </p>
      <section>
       <span id="c18-sec-0011">
       </span>
       <h4 id="head-4-279">
        vector Overview
       </h4>
       <p>
        <code>
         vector
        </code>
        is defined in
        <code>
         &lt;vector&gt;
        </code>
        as a class template with two type parameters: the element type to store and an
        <i>
         allocator
        </i>
        type:
       </p>
       <pre id="c18-code-0003"><code>template &lt;typename T, typename Allocator = allocator&lt;T&gt;&gt; class vector;</code></pre>
       <p>
        The
        <code>
         Allocator
        </code>
        parameter specifies the type for a memory allocator object that the client can set in order to use custom memory allocation. This template parameter has a default value.
        <span aria-label="688" epub:type="pagebreak" id="Page_688" role="doc-pagebreak">
        </span>
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0029">
           <b>
            NOTE
           </b>
           <i>
            The default value for the
           </i>
           <code>
            Allocator
           </code>
           <i>
            template type parameter is sufficient for most applications. This chapter always uses the default allocator.
            <a href="c25.xhtml">
             Chapter 25
            </a>
            , “Customizing and Extending the Standard Library,” provides more details in case you are interested.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c18-para-0030">
        <code>
         std::vector
        </code>
        is
        <code>
         constexpr
        </code>
        (see
        <a href="c09.xhtml">
         Chapter 9
        </a>
        ), just as
        <code>
         std::string
        </code>
        . This means that
        <code>
         vector
        </code>
        can be used to perform operations at compile time and that it can be used in the implementation of
        <code>
         constexpr
        </code>
        functions and other
        <code>
         constexpr
        </code>
        classes.
       </p>
       <section>
        <span id="c18-sec-0013">
        </span>
        <h5 id="head-5-108">
         Fixed-Length vectors
        </h5>
        <p>
         One way to use a
         <code>
          vector
         </code>
         is as a fixed-length array.
         <code>
          vector
         </code>
         provides a constructor that allows you to specify the number of elements and provides an overloaded
         <code>
          operator[]
         </code>
         to access and modify those elements. The result of
         <code>
          operator[]
         </code>
         is undefined when used to access an element outside the
         <code>
          vector
         </code>
         bounds. This means that a compiler can decide how to behave in that case. For example, the default behavior of Microsoft Visual C++ is to give a run-time error message when your program is compiled in debug mode and to disable any bounds checking in release mode for performance reasons. You can change these default behaviors.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0032">
            <b>
             WARNING
            </b>
            <i>
             Like “real” array indexing,
            </i>
            <code>
             operator[]
            </code>
            <i>
             on a
            </i>
            <code>
             vector
            </code>
            <i>
             does not provide bounds checking.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         In addition to using
         <code>
          operator[]
         </code>
         , you can access
         <code>
          vector
         </code>
         elements via
         <code>
          at()
         </code>
         ,
         <code>
          front()
         </code>
         , and
         <code>
          back()
         </code>
         . The
         <code>
          at()
         </code>
         member function is identical to
         <code>
          operator[]
         </code>
         , except that it performs bounds checking and throws an
         <code>
          out_of_range
         </code>
         exception if the index is out of bounds.
         <code>
          front()
         </code>
         and
         <code>
          back()
         </code>
         return references to the first and last elements of a
         <code>
          vector
         </code>
         , respectively. Calling
         <code>
          front()
         </code>
         or
         <code>
          back()
         </code>
         on an empty container triggers undefined behavior.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0034">
            <b>
             NOTE
            </b>
            <i>
             All
            </i>
            <code>
             vector
            </code>
            <i>
             element accesses have constant complexity.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         Here is a small example program to “normalize” test scores so that the highest score is set to 100, and all other scores are adjusted accordingly. The program creates a
         <code>
          vector
         </code>
         of ten
         <code>
          double
         </code>
         s, reads in ten values from the user, divides each value by the max score (times 100), and prints out the new values. To create the vector, parentheses, (10), are used and not uniform initialization, {10}, as the latter would create a vector of just one element with the value 10. For the sake of brevity, the program forsakes error checking.
        </p>
        <pre id="c18-code-0004"><code>vector&lt;double&gt; doubleVector(10); <span class="color3">// Create a vector of 10 doubles.</span></code>
<code> </code>
<code><span class="color3">// Initialize max to smallest number.</span></code>
<code>double max { -numeric_limits&lt;double&gt;::infinity() };</code>
<code> </code>
<span aria-label="689" epub:type="pagebreak" id="Page_689" role="doc-pagebreak"></span><code>for (size_t i { 0 }; i &lt; doubleVector.size(); ++i) {</code>
<code>    print("Enter score {}: ", i + 1);</code>
<code>    cin &gt;&gt; doubleVector[i];</code>
<code>    if (doubleVector[i]&gt; max) {</code>
<code>        max = doubleVector[i];</code>
<code>    }</code>
<code>}</code>
<code> </code>
<code>max /= 100.0;</code>
<code>for (auto&amp; element : doubleVector) {</code>
<code>    element /= max;</code>
<code>    print("{} ", element);</code>
<code>}</code></pre>
        <p>
         As you can see from this example, you can use a
         <code>
          vector
         </code>
         just as you would use a standard C-style array. Note that the first
         <code>
          for
         </code>
         loop uses the
         <code>
          size()
         </code>
         member function to determine the number of elements in the container. This example also demonstrates the use of a range-based
         <code>
          for
         </code>
         loop with a
         <code>
          vector
         </code>
         . Here, the range-based
         <code>
          for
         </code>
         loop uses
         <code>
          auto&amp;
         </code>
         and not
         <code>
          auto
         </code>
         because a reference is required so that the actual elements can be modified in each iteration.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0037">
            <b>
             NOTE
            </b>
            <code>
             operator[]
            </code>
            <i>
             on a
            </i>
            <code>
             vector
            </code>
            <i>
             normally returns a reference to the element, which can be used on the left-hand side of assignment statements. If
            </i>
            <code>
             operator[]
            </code>
            <i>
             is called on a
            </i>
            <code>
             const vector
            </code>
            <i>
             object, it returns a reference to a
            </i>
            <code>
             const
            </code>
            <i>
             element, which cannot be used as the target of an assignment. See
             <a href="c15.xhtml">
              Chapter 15
             </a>
             , “Overloading C++ Operators,” for details on how this trick is implemented.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section>
        <span id="c18-sec-0017">
        </span>
        <h5 id="head-5-109">
         Dynamic-Length vectors
        </h5>
        <p>
         The real power of a
         <code>
          vector
         </code>
         lies in its ability to grow dynamically. For example, consider the test score normalization program from the previous section with the additional requirement that it should handle any number of test scores. Here is the new version:
        </p>
        <pre id="c18-code-0005"><code><b>vector&lt;double&gt; doubleVector;</b> <span class="color3">// Create a vector with zero elements.</span></code>
<code> </code>
<code><span class="color3">// Initialize max to smallest number.</span></code>
<code>double max { -numeric_limits&lt;double&gt;::infinity() };</code>
<code> </code>
<code><b>for (size_t i { 1 }; true; ++i) {</b></code>
<code>    <b>double value;</b></code>
<code>    <b>print("Enter score {} (-1 to stop): ", i);</b></code>
<code>    <b>cin &gt;&gt; value;</b></code>
<code>    <b>if (value == -1) {</b></code>
<code>        <b>break;</b></code>
<code>    <b>}</b></code>
<code>    <b>doubleVector.push_back(value);</b></code>
<code>    <b>if (value &gt; max) {</b></code>
<code>        <b>max = value;</b></code>
<code>    <b>}</b></code>
<code>}</code>
<code> </code>
<span aria-label="690" epub:type="pagebreak" id="Page_690" role="doc-pagebreak"></span><code>max /= 100.0;</code>
<code>for (auto&amp; element : doubleVector) {</code>
<code>    element /= max;</code>
<code>    print("{} ", element);</code>
<code>}</code></pre>
        <p id="c18-para-0039">
         This version of the program uses the default constructor to create a
         <code>
          vector
         </code>
         with zero elements. As each score is read, it's added to the end of the
         <code>
          vector
         </code>
         with the
         <code>
          push_back()
         </code>
         member function, which takes care of allocating space for the new element. The range-based
         <code>
          for
         </code>
         loop doesn't require any changes.
        </p>
       </section>
       <section>
        <span id="c18-sec-0018">
        </span>
        <h5 id="head-5-110">
         <img alt="C++23" src="../images\images/icon1.png"/>
         Formatting and Printing Vectors
        </h5>
        <p>
         Starting with C++23,
         <code>
          std::format()
         </code>
         and the
         <code>
          print()
         </code>
         functions can be used to format and print entire containers with a single statement. This works for all Standard Library sequential containers, container adapters, and associative containers, and is introduced in
         <a href="c02.xhtml">
          Chapter 2
         </a>
         , “Working with Strings and String Views.” Here is an example:
        </p>
        <pre id="c18-code-0006"><code>vector values { 1.1, 2.2, 3.3 };</code>
<code>println("{}", values);   <span class="color3">// Prints the following: [1.1, 2.2, 3.3]</span></code></pre>
        <p>
         You can specify the
         <code>
          n
         </code>
         format specifier to omit the surrounding square brackets:
        </p>
        <pre id="c18-code-0007"><code>println("{:n}", values); <span class="color3">// Prints the following: 1.1, 2.2, 3.3</span></code></pre>
        <p>
         If your compiler doesn't support this feature yet, you can use a range-based
         <code>
          for
         </code>
         loop to iterate over the elements of a
         <code>
          vector
         </code>
         and to print them, for example:
        </p>
        <pre id="c18-code-0008"><code>for (const auto&amp; value : values) { std::cout &lt;&lt; value &lt;&lt; ", "; }</code></pre>
       </section>
      </section>
      <section>
       <span id="c18-sec-0019">
       </span>
       <h4 id="head-4-280">
        vector Details
       </h4>
       <p id="c18-para-0044">
        Now that you've had a taste of
        <code>
         vector
        </code>
        s, it's time to delve into their details.
       </p>
       <section>
        <span id="c18-sec-0020">
        </span>
        <h5 id="head-5-111">
         Constructors and Destructors
        </h5>
        <p>
         The default constructor creates a
         <code>
          vector
         </code>
         with zero elements.
        </p>
        <pre id="c18-code-0009"><code>vector&lt;int&gt; intVector; <span class="color3">// Creates a vector of ints with zero elements</span></code></pre>
        <p>
         You can specify a number of elements and, optionally, a value for those elements, like this:
        </p>
        <pre id="c18-code-0010"><code>vector&lt;int&gt; intVector(10, 100); <span class="color3">// Creates vector of 10 ints with value 100</span></code></pre>
        <p id="c18-para-0047">
         If you omit the default value, the new objects are zero-initialized.
         <i>
          Zero-initialization
         </i>
         constructs objects with the default constructor and initializes primitive integer types (such as
         <code>
          char
         </code>
         ,
         <code>
          int
         </code>
         , and so on) to zero, primitive floating-point types to 0.0, and pointer types to
         <code>
          nullptr
         </code>
         .
        </p>
        <p>
         You can create
         <code>
          vector
         </code>
         s of built-in classes like this:
        </p>
        <pre id="c18-code-0011"><code>vector&lt;string&gt; stringVector(10, "hello");</code></pre>
        <p>
         User-defined classes can also be used as
         <code>
          vector
         </code>
         elements:
        </p>
        <pre id="c18-code-0012"><code>class Element { };</code>
<code>…</code>
<code>vector&lt;Element&gt; elementVector;</code></pre>
        <p>
         <span aria-label="691" epub:type="pagebreak" id="Page_691" role="doc-pagebreak">
         </span>
         A
         <code>
          vector
         </code>
         can be constructed with an
         <code>
          initializer_list
         </code>
         containing the initial elements:
        </p>
        <pre id="c18-code-0013"><code>vector&lt;int&gt; intVector({ 1, 2, 3, 4, 5, 6 });</code></pre>
        <p>
         Uniform initialization
         <i>
          ,
         </i>
         as discussed in
         <a href="c01.xhtml">
          Chapter 1
         </a>
         , “A Crash Course in C++ and the Standard Library,” works on most Standard Library containers, including
         <code>
          vector
         </code>
         . Here is an example:
        </p>
        <pre id="c18-code-0014"><code>vector&lt;int&gt; intVector = { 1, 2, 3, 4, 5, 6 };</code>
<code>vector&lt;int&gt; intVector { 1, 2, 3, 4, 5, 6 };</code></pre>
        <p>
         Thanks to class template argument deduction (CTAD), you can omit the template type parameter. Here is an example:
        </p>
        <pre id="c18-code-0015"><code>vector intVector { 1, 2, 3, 4, 5, 6 };</code></pre>
        <p>
         Be cautious with uniform initialization, though; usually, when calling a constructor of an object, the uniform initialization syntax can be used. Here's an example:
        </p>
        <pre id="c18-code-0016"><code>string text { "Hello World." };</code></pre>
        <p>
         With
         <code>
          vector
         </code>
         you need be careful. For example, the following line of code calls a
         <code>
          vector
         </code>
         constructor to create a
         <code>
          vector
         </code>
         of 10 integers with value 100:
        </p>
        <pre id="c18-code-0017"><code>vector&lt;int&gt; intVector(10, 100); <span class="color3">// Creates vector of 10 ints with value 100</span></code></pre>
        <p>
         Using uniform initialization here instead as follows does not create a
         <code>
          vector
         </code>
         of 10 integers, but a
         <code>
          vector
         </code>
         with just two elements, initialized to 10 and 100:
        </p>
        <pre id="c18-code-0018"><code>vector&lt;int&gt; intVector { 10, 100 }; <span class="color3">// Creates vector with two elements: 10 and 100</span></code></pre>
        <p>
         You can allocate
         <code>
          vector
         </code>
         s on the free store as well:
        </p>
        <pre id="c18-code-0019"><code>auto elementVector { make_unique&lt;vector&lt;Element&gt;&gt;(10) };</code></pre>
       </section>
       <section>
        <span id="c18-sec-0021">
        </span>
        <h5 id="head-5-112">
         Copying and Assigning vectors
        </h5>
        <p id="c18-para-0057">
         A
         <code>
          vector
         </code>
         stores copies of the objects, and its destructor calls the destructor for each of the objects. The copy constructor and assignment operator of the
         <code>
          vector
         </code>
         class perform deep copies of all the elements in the
         <code>
          vector
         </code>
         . Thus, for efficiency, you should pass
         <code>
          vector
         </code>
         s by reference-to-non-
         <code>
          const
         </code>
         or reference-to-
         <code>
          const
         </code>
         to functions, instead of by value.
        </p>
        <p>
         In addition to normal copying and assignment,
         <code>
          vector
         </code>
         provides an
         <code>
          assign()
         </code>
         member function that removes all the current elements and adds any number of new elements. This member function is useful if you want to reuse a
         <code>
          vector
         </code>
         . Here is a trivial example.
         <code>
          intVector
         </code>
         is created with 10 elements having the default value 0. Then
         <code>
          assign()
         </code>
         is used to remove all 10 elements and replace them with 5 elements with value 100:
        </p>
        <pre id="c18-code-0020"><code>vector&lt;int&gt; intVector(10);</code>
<code>println("intVector: {:n}", intVector);  <span class="color3">// 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span></code>
<code>…</code>
<code>intVector.assign(5, 100);</code>
<code>println("intVector: {:n}", intVector);  <span class="color3">// 100, 100, 100, 100, 100</span></code></pre>
        <p>
         <code>
          assign()
         </code>
         can also accept an
         <code>
          initializer_list
         </code>
         as follows. After this statement,
         <code>
          intVector
         </code>
         has four elements with the given values:
        </p>
        <pre id="c18-code-0021"><code>intVector.assign({ 1, 2, 3, 4 });</code>
<code>println("intVector: {:n}", intVector);  <span class="color3">// 1, 2, 3, 4</span></code></pre>
        <p>
         <span aria-label="692" epub:type="pagebreak" id="Page_692" role="doc-pagebreak">
         </span>
         <code>
          vector
         </code>
         provides a
         <code>
          swap()
         </code>
         member function that allows you to swap the contents of two
         <code>
          vector
         </code>
         s in constant time. Here is a simple example:
        </p>
        <pre id="c18-code-0022"><code>vector&lt;int&gt; vectorOne(10);</code>
<code>vector&lt;int&gt; vectorTwo(5, 100);</code>
<code>println("vectorOne: {:n}", vectorOne);  <span class="color3">// 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span></code>
<code>println("vectorTwo: {:n}", vectorTwo);  <span class="color3">// 100, 100, 100, 100, 100</span></code>
<code> </code>
<code>vectorOne.swap(vectorTwo);</code>
<code> </code>
<code>println("vectorOne: {:n}", vectorOne);  <span class="color3">// 100, 100, 100, 100, 100</span></code>
<code>println("vectorTwo: {:n}", vectorTwo);  <span class="color3">// 0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span></code></pre>
       </section>
       <section>
        <span id="c18-sec-0022">
        </span>
        <h5 id="head-5-113">
         Comparing vectors
        </h5>
        <p>
         The Standard Library provides the usual six overloaded comparison operators for
         <code>
          vector
         </code>
         s:
         <code>
          ==
         </code>
         ,
         <code>
          !=
         </code>
         ,
         <code>
          &lt;
         </code>
         ,
         <code>
          &gt;
         </code>
         ,
         <code>
          &lt;=
         </code>
         ,
         <code>
          &gt;=
         </code>
         . Two
         <code>
          vector
         </code>
         s are equal if they have the same number of elements and all the corresponding elements in the two
         <code>
          vector
         </code>
         s are equal to each other. Two
         <code>
          vector
         </code>
         s are compared lexicographically; that is, one
         <code>
          vector
         </code>
         is “less than” another if all elements
         <code>
          0
         </code>
         through
         <code>
          i–1
         </code>
         in the first
         <code>
          vector
         </code>
         are equal to elements
         <code>
          0
         </code>
         through
         <code>
          i-1
         </code>
         in the second
         <code>
          vector
         </code>
         , but element
         <code>
          i
         </code>
         in the first is less than element
         <code>
          i
         </code>
         in the second, where
         <code>
          i
         </code>
         must be in the range
         <code>
          0…n
         </code>
         and
         <code>
          n
         </code>
         must be less than the
         <code>
          size()
         </code>
         of the smallest of the two
         <code>
          vector
         </code>
         s.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0062">
            <b>
             NOTE
            </b>
            <i>
             Comparing two
            </i>
            <code>
             vector
            </code>
            <i>
             s with
            </i>
            <code>
             operator==
            </code>
            <i>
             or
            </i>
            <code>
             !=
            </code>
            <i>
             requires the individual elements to be comparable with
            </i>
            <code>
             operator==
            </code>
            <i>
             . Comparing two
            </i>
            <code>
             vector
            </code>
            <i>
             s with
            </i>
            <code>
             operator&lt;
            </code>
            <i>
             ,
            </i>
            <code>
             &gt;
            </code>
            <i>
             ,
            </i>
            <code>
             &lt;=
            </code>
            <i>
             ,
            </i>
            or
            <i>
            </i>
            <code>
             &gt;=
            </code>
            <i>
             requires the individual elements to be comparable with
            </i>
            <code>
             operator&lt;
            </code>
            <i>
             . If you intend to store objects of a custom class in a
            </i>
            <code>
             vector
            </code>
            <i>
             , make sure to write those operators.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         Here is an example of a program that compares
         <code>
          vector
         </code>
         s of
         <code>
          int
         </code>
         s:
        </p>
        <pre id="c18-code-0023"><code>vector&lt;int&gt; vectorOne(10);</code>
<code>vector&lt;int&gt; vectorTwo(10);</code>
<code> </code>
<code>if (vectorOne == vectorTwo) { println("equal!"); }</code>
<code>else { println("not equal!"); }</code>
<code> </code>
<code>vectorOne[3] = 50;</code>
<code> </code>
<code>if (vectorOne &lt; vectorTwo) { println("vectorOne is less than vectorTwo"); }</code>
<code>else { println("vectorOne is not less than vectorTwo"); }</code></pre>
        <p>
         The output of the program is as follows:
        </p>
        <pre id="c18-code-0024"><code>equal!</code>
<code>vectorOne is not less than vectorTwo</code></pre>
       </section>
       <span aria-label="693" epub:type="pagebreak" id="Page_693" role="doc-pagebreak">
       </span>
       <section>
        <span id="c18-sec-0024">
        </span>
        <h5 id="head-5-114">
         vector Iterators
        </h5>
        <p>
         <a href="c17.xhtml">
          Chapter 17
         </a>
         , “Understanding Iterators and the Ranges Library,” explains the concepts of container iterators. The discussion can get a bit abstract, so it's helpful to jump in and look at a code example. Here is the last
         <code>
          for
         </code>
         loop of the test score normalization program from earlier in this chapter:
        </p>
        <pre id="c18-code-0025"><code>for (auto&amp; element : doubleVector) {</code>
<code>    element /= max;</code>
<code>    print("{} ", element);</code>
<code>}</code></pre>
        <p>
         This loop can be written using iterators instead of a range-based
         <code>
          for
         </code>
         loop as follows:
        </p>
        <pre id="c18-code-0026"><code>for (vector&lt;double&gt;::iterator iter { begin(doubleVector) };</code>
<code>    iter != end(doubleVector); ++iter) {</code>
<code>    *iter /= max;</code>
<code>    print("{} ", *iter);</code>
<code>}</code></pre>
        <p>
         First, take a look at the
         <code>
          for
         </code>
         loop initialization statement:
        </p>
        <pre id="c18-code-0027"><code>vector&lt;double&gt;::iterator iter { begin(doubleVector) };</code></pre>
        <p>
         Recall that every container defines a type named
         <code>
          iterator
         </code>
         to represent iterators for that type of container.
         <code>
          begin()
         </code>
         returns an iterator of that type referring to the first element in the container. Thus, the initialization statement obtains in the variable
         <code>
          iter
         </code>
         an iterator referring to the first element of
         <code>
          doubleVector
         </code>
         . Next, look at the
         <code>
          for
         </code>
         loop comparison:
        </p>
        <pre id="c18-code-0028"><code>iter != end(doubleVector);</code></pre>
        <p id="c18-para-0069">
         This statement simply checks whether the iterator is past the end of the sequence of elements in the
         <code>
          vector
         </code>
         . When it reaches that point, the loop terminates. Always use
         <code>
          operator!=
         </code>
         in such statements and not
         <code>
          operator&lt;
         </code>
         as the latter is not supported by all types of iterators; see
         <a href="c17.xhtml">
          Chapter 17
         </a>
         for details.
        </p>
        <p>
         The increment statement,
         <code>
          ++iter
         </code>
         , increments the iterator to refer to the next element in the
         <code>
          vector
         </code>
         .
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0071">
            <b>
             NOTE
            </b>
            <i>
             Use pre-increment instead of post-increment when possible because pre-increment is at least as efficient and usually more efficient
            </i>
            .
            <code>
             iter++
            </code>
            <i>
             must return a new iterator object, while
            </i>
            <code>
             ++iter
            </code>
            <i>
             can simply return a reference to
            </i>
            <code>
             iter
            </code>
            <i>
             . See
             <a href="c15.xhtml">
              Chapter 15
             </a>
             , “Overloading C++ Operators,” for details on implementing both versions of
            </i>
            <code>
             operator++
            </code>
            <i>
             .
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         The
         <code>
          for
         </code>
         loop body contains these two lines:
        </p>
        <pre id="c18-code-0029"><code>*iter /= max;</code>
<code>print("{} ", *iter);</code></pre>
        <p id="c18-para-0073">
         As you can see, your code can both access and modify the elements over which it iterates. The first line uses
         <code>
          operator*
         </code>
         to dereference
         <code>
          iter
         </code>
         to obtain the element to which it refers and assigns to that element. The second line dereferences
         <code>
          iter
         </code>
         again, but this time only to print the element to the standard output console.
        </p>
        <p>
         <span aria-label="694" epub:type="pagebreak" id="Page_694" role="doc-pagebreak">
         </span>
         The preceding
         <code>
          for
         </code>
         loop using iterators can be simplified by using the
         <code>
          auto
         </code>
         keyword:
        </p>
        <pre id="c18-code-0030"><code><b>for (auto iter { begin(doubleVector) };</b></code>
<code>    iter != end(doubleVector); ++iter) {</code>
<code>    *iter /= max;</code>
<code>    print("{} ", *iter);</code>
<code>}</code></pre>
        <p id="c18-para-0075">
         With
         <code>
          auto
         </code>
         , the compiler automatically deduces the type of the variable
         <code>
          iter
         </code>
         based on the right-hand side of the initializer, which in this case is the result of the call to
         <code>
          begin()
         </code>
         .
        </p>
        <p>
         <code>
          vector
         </code>
         supports the following member functions to get iterators:
        </p>
        <ul class="check1" id="c18-list-0004">
         <li id="c18-li-0032">
          <code>
           begin()
          </code>
          and
          <code>
           end()
          </code>
          returning iterators referring to the first and one past the last element
         </li>
         <li id="c18-li-0033">
          <code>
           rbegin()
          </code>
          and
          <code>
           rend()
          </code>
          returning reverse iterators referring to the last and one before the first element
         </li>
         <li id="c18-li-0034">
          <code>
           cbegin()
          </code>
          ,
          <code>
           cend()
          </code>
          ,
          <code>
           crbegin()
          </code>
          , and
          <code>
           crend()
          </code>
          returning
          <code>
           const
          </code>
          iterators
         </li>
        </ul>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0077">
            <b>
             NOTE
            </b>
            <i>
             If you need to iterate over all elements in a container, it's recommended to use a range-based
            </i>
            <code>
             for
            </code>
            <i>
             loop instead of iterators as the former is easier to read and write, as well as being less error-prone. Use iterators only when you need to iterate over a subrange or when you need an iterator in the body of the loop.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <section>
         <span id="c18-sec-0027">
         </span>
         <h6 id="head-6-1">
          Accessing Fields of Object Elements
         </h6>
         <p>
          If the elements of your container are objects, you can use the
          <code>
           -&gt;
          </code>
          operator on iterators to call member functions or access data members of those objects. For example, the following program creates a
          <code>
           vector
          </code>
          of 10
          <code>
           string
          </code>
          s, then iterates over all of them appending a new
          <code>
           string
          </code>
          to each one:
         </p>
         <pre id="c18-code-0031"><code>vector&lt;string&gt; stringVector(10, "hello");</code>
<code>for (auto it { begin(stringVector) }; it != end(stringVector); ++it) {</code>
<code>    it-&gt;append(" there");</code>
<code>}</code></pre>
         <p>
          Often, using a range-based
          <code>
           for
          </code>
          loop results in more elegant code, as in this example:
         </p>
         <pre id="c18-code-0032"><code>for (auto&amp; str : stringVector) {</code>
<code>    str.append(" there");</code>
<code>}</code></pre>
        </section>
        <section>
         <span id="c18-sec-0028">
         </span>
         <h6 id="head-6-2">
          const_iterator
         </h6>
         <p>
          The normal
          <code>
           iterator
          </code>
          is read/write. However, if you call
          <code>
           begin()
          </code>
          or
          <code>
           end()
          </code>
          on a
          <code>
           const
          </code>
          object, or you call
          <code>
           cbegin()
          </code>
          or
          <code>
           cend()
          </code>
          , you receive a
          <code>
           const_iterator
          </code>
          . A
          <code>
           const_iterator
          </code>
          is read-only; you cannot modify the element it refers to. An
          <code>
           iterator
          </code>
          can always be converted to a
          <code>
           const_iterator
          </code>
          , so it's always safe to write something like this:
         </p>
         <pre id="c18-code-0033"><code>vector&lt;<i>type</i>&gt;::const_iterator it { begin(myVector) };</code></pre>
         <p>
          <span aria-label="695" epub:type="pagebreak" id="Page_695" role="doc-pagebreak">
          </span>
          However, a
          <code>
           const_iterator
          </code>
          cannot be converted to an
          <code>
           iterator
          </code>
          . If
          <code>
           myVector
          </code>
          is
          <code>
           const
          </code>
          , the following line doesn't compile:
         </p>
         <pre id="c18-code-0034"><code>vector&lt;<i>type</i>&gt;::iterator it { begin(myVector) };</code></pre>
         <section>
          <aside>
           <div class="top hr">
            <hr/>
           </div>
           <section class="feature1">
            <p id="c18-para-0083">
             <b>
              NOTE
             </b>
             <i>
              If you do not need to modify the elements of a
             </i>
             <code>
              vector
             </code>
             <i>
              , you should use a
             </i>
             <code>
              const_iterator
             </code>
             <i>
              . This rule makes it easier to guarantee correctness of your code and helps the compiler to perform better optimizations
             </i>
             .
            </p>
            <div class="bottom hr">
             <hr/>
            </div>
           </section>
          </aside>
         </section>
         <p>
          When using the
          <code>
           auto
          </code>
          keyword, using
          <code>
           const_iterator
          </code>
          s looks a bit different. Suppose you write the following code:
         </p>
         <pre id="c18-code-0035"><code>vector&lt;string&gt; stringVector(10, "hello");</code>
<code>for (auto iter { begin(stringVector) }; iter != end(stringVector); ++iter) {</code>
<code>    println("{}", *iter);</code>
<code>}</code></pre>
         <p>
          Because of the
          <code>
           auto
          </code>
          keyword, the compiler deduces the type of the
          <code>
           iter
          </code>
          variable automatically and makes it a normal
          <code>
           iterator
          </code>
          because
          <code>
           stringVector
          </code>
          is not
          <code>
           const
          </code>
          . If you want a read-only
          <code>
           const_iterator
          </code>
          in combination with using
          <code>
           auto
          </code>
          , then you need to use
          <code>
           cbegin()
          </code>
          and
          <code>
           cend()
          </code>
          instead of
          <code>
           begin()
          </code>
          and
          <code>
           end()
          </code>
          as follows:
         </p>
         <pre id="c18-code-0036"><code><b>for (auto iter { cbegin(stringVector) }; iter != cend(stringVector); ++iter) {</b></code>
<code>    println("{}", *iter);</code>
<code>}</code></pre>
         <p id="c18-para-0086">
          Now the compiler uses
          <code>
           const_iterator
          </code>
          as type for the variable
          <code>
           iter
          </code>
          because that's what
          <code>
           cbegin()
          </code>
          returns.
         </p>
         <p>
          A range-based
          <code>
           for
          </code>
          loop can also be forced to use
          <code>
           const
          </code>
          iterators as follows:
         </p>
         <pre id="c18-code-0037"><code>for (<b>const auto&amp;</b> element : stringVector) {</code>
<code>    println("{}", element);</code>
<code>}</code></pre>
        </section>
        <section>
         <span id="c18-sec-0030">
         </span>
         <h6 id="head-6-3">
          Iterator Safety
         </h6>
         <p>
          Generally, iterators are about as safe as pointers—that is, extremely unsafe. For example, you can write code like this:
         </p>
         <pre id="c18-code-0038"><code>vector&lt;int&gt; intVector;</code>
<code>auto iter { end(intVector) };</code>
<code>*iter = 10; <span class="color3">// Bug! Iter doesn't refer to a valid element.</span></code></pre>
         <p id="c18-para-0089">
          Recall that the iterator returned by
          <code>
           end()
          </code>
          is one element past the end of a
          <code>
           vector
          </code>
          , not an iterator referring to the last element! Trying to dereference it results in undefined behavior. Iterators are not required to perform any verification.
         </p>
         <p>
          Another problem can occur if you use mismatched iterators. For example, the following
          <code>
           for
          </code>
          loop initializes
          <code>
           iter
          </code>
          with an iterator from
          <code>
           vectorTwo
          </code>
          and tries to compare it to the end iterator of
          <code>
           vectorOne
          </code>
          . Needless to say, this loop will not do what you intended and may never terminate. Dereferencing the iterator in the loop will likely produce undefined results.
         </p>
         <pre id="c18-code-0039"><span aria-label="696" epub:type="pagebreak" id="Page_696" role="doc-pagebreak"></span><code>vector&lt;int&gt; vectorOne(10);</code>
<code>vector&lt;int&gt; vectorTwo(10);</code>
<code><span class="color3">// BUG! Possible infinite loop.</span></code>
<code>for (auto iter { begin(<b>vectorTwo</b>) }; iter != end(<b>vectorOne</b>); ++iter) { <span class="color3">/* … */</span> }</code></pre>
         <section>
          <aside>
           <div class="top hr">
            <hr/>
           </div>
           <section class="feature1">
            <p id="c18-para-0092">
             <b>
              NOTE
             </b>
             <i>
              Microsoft Visual C++, by default, gives an assertion error at run time for both of the preceding problems when running a debug build of your program. By default, no verification of iterators is performed for release builds. You can enable it for release builds as well, but it has a performance penalty
             </i>
             .
            </p>
            <div class="bottom hr">
             <hr/>
            </div>
           </section>
          </aside>
         </section>
        </section>
        <section>
         <span id="c18-sec-0032">
         </span>
         <h6 id="head-6-4">
          Other Iterator Operations
         </h6>
         <p>
          The
          <code>
           vector
          </code>
          iterator is random access, which means you can move it backward and forward, and jump around. For example, the following code eventually changes the fifth element (index
          <code>
           4
          </code>
          ) to the value
          <code>
           4
          </code>
          :
         </p>
         <pre id="c18-code-0040"><code>vector&lt;int&gt; intVector(10);</code>
<code>auto it { begin(intVector) };</code>
<code>it += 5;</code>
<code>--it;</code>
<code>*it = 4;</code></pre>
        </section>
        <section>
         <span id="c18-sec-0033">
         </span>
         <h6 id="head-6-5">
          Iterators vs. Indexing
         </h6>
         <p>
          Given that you can write a
          <code>
           for
          </code>
          loop that uses a simple index variable and the
          <code>
           size()
          </code>
          member function to iterate over the elements of a
          <code>
           vector
          </code>
          , why should you bother using iterators? That's a valid question, for which there are three main answers:
         </p>
         <ul class="check1" id="c18-list-0005">
          <li id="c18-li-0035">
           Iterators allow you to insert and delete elements and sequences of elements at any point in the container. See the section “
           <a href="#c18-sec-0035">
            Adding and Removing Elements
           </a>
           ” later in this chapter.
          </li>
          <li id="c18-li-0036">
           Iterators allow you to use the Standard Library algorithms, which are discussed in
           <a href="c20.xhtml">
            Chapter 20
           </a>
           , “Mastering Standard Library Algorithms.”
          </li>
          <li id="c18-li-0037">
           Using an iterator to access each element sequentially is often more efficient than indexing the container to retrieve each element individually. This generalization is not true for
           <code>
            vector
           </code>
           s, but applies to
           <code>
            list
           </code>
           s,
           <code>
            map
           </code>
           s, and
           <code>
            set
           </code>
           s.
          </li>
         </ul>
        </section>
       </section>
       <section>
        <span id="c18-sec-0034">
        </span>
        <h5 id="head-5-115">
         Storing References in a vector
        </h5>
        <p>
         As mentioned earlier in this chapter, it is possible to store references in a container, such as a
         <code>
          vector
         </code>
         . To do this, you store
         <code>
          std::reference:wrapper
         </code>
         s in the container. The
         <code>
          std::ref()
         </code>
         and
         <code>
          cref()
         </code>
         function templates are used to create non-
         <code>
          const
         </code>
         and
         <code>
          const reference:wrapper
         </code>
         instances. The
         <code>
          get()
         </code>
         member function is used to get access to the object wrapped by a
         <code>
          reference:wrapper
         </code>
         . All this is defined in
         <code>
          &lt;functional&gt;
         </code>
         . Here is an example:
        </p>
        <pre id="c18-code-0041"><code>string str1 { "Hello" };</code>
<code>string str2 { "World" };</code>
<code> </code>
<span aria-label="697" epub:type="pagebreak" id="Page_697" role="doc-pagebreak"></span><code><span class="color3">// Create a vector of references to strings.</span></code>
<code>vector&lt;reference:wrapper&lt;string&gt;&gt; vec { ref(str1) };</code>
<code>vec.push_back(ref(str2));  <span class="color3">// push_back() works as well.</span></code>
<code> </code>
<code><span class="color3">// Modify the string referred to by the second reference in the vector.</span></code>
<code>vec[1].get() += "!";</code>
<code> </code>
<code><span class="color3">// The end result is that str2 is modified.</span></code>
<code>println("{} {}", str1, str2);</code></pre>
       </section>
       <section>
        <span id="c18-sec-0035">
        </span>
        <h5 id="head-5-116">
         Adding and Removing Elements
        </h5>
        <p>
         As you already know, you can append an element to a
         <code>
          vector
         </code>
         with the
         <code>
          push_back()
         </code>
         member function. The
         <code>
          vector
         </code>
         provides a corresponding remove member function called
         <code>
          pop_back()
         </code>
         .
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0097">
            <b>
             WARNING
            </b>
            <code>
             pop_back()
            </code>
            <i>
             does not return the element that is removed. If you want that element, you must first retrieve it with
            </i>
            <code>
             back()
            </code>
            <i>
             .
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p>
         You can also insert elements at any point in the
         <code>
          vector
         </code>
         with the
         <code>
          insert()
         </code>
         member function, which adds one or more elements to a position specified by an iterator, shifting all subsequent elements down to make room for the new ones. There are five different overloads of
         <code>
          insert()
         </code>
         that do the following:
        </p>
        <ul class="check1" id="c18-list-0006">
         <li id="c18-li-0038">
          Insert a single element.
         </li>
         <li id="c18-li-0039">
          Insert
          <i>
           n
          </i>
          copies of a single element.
         </li>
         <li id="c18-li-0040">
          Insert elements from an iterator range. Recall that the iterator range is half-open, such that it includes the element referred to by the starting iterator but not the one referred to by the ending iterator.
         </li>
         <li id="c18-li-0041">
          Insert a single element by moving the given element to a
          <code>
           vector
          </code>
          using move semantics.
         </li>
         <li id="c18-li-0042">
          Insert a list of elements into a
          <code>
           vector
          </code>
          where the list of elements is given as an
          <code>
           initializer_list
          </code>
          .
          <section>
           <aside>
            <div class="top hr">
             <hr/>
            </div>
            <section class="feature1">
             <p id="c18-para-0100">
              <b>
               NOTE
              </b>
              <i>
               There are overloads of
              </i>
              <code>
               push_back()
              </code>
              <i>
               and
              </i>
              <code>
               insert()
              </code>
              <i>
               that take an lvalue or an rvalue as a parameter. Both overloads allocate memory as needed to store the new elements. The lvalue overloads store copies of the given elements, while the rvalue overloads use move semantics to move ownership of the given elements to the
              </i>
              <code>
               vector
              </code>
              <i>
               instead of copying them.
              </i>
             </p>
             <div class="bottom hr">
              <hr/>
             </div>
            </section>
           </aside>
          </section>
         </li>
        </ul>
        <p id="c18-para-0102">
         <img alt="C++23" src="../images\images/icon1.png"/>
         C++23 adds the following member functions:
         <code>
          assign_range()
         </code>
         to replace all elements in a
         <code>
          vector
         </code>
         with the elements of a given range,
         <code>
          insert_range()
         </code>
         to insert all elements of a given range into a
         <code>
          vector
         </code>
         at a given position, and
         <code>
          append_range()
         </code>
         to append all elements of a given range to the end of a
         <code>
          vector
         </code>
         .
         <a href="c17.xhtml">
          Chapter 17
         </a>
         discusses ranges in detail.
        </p>
        <p id="c18-para-0103">
         <span aria-label="698" epub:type="pagebreak" id="Page_698" role="doc-pagebreak">
         </span>
         You can remove elements from any point in a
         <code>
          vector
         </code>
         with
         <code>
          erase()
         </code>
         , and you can remove all elements with
         <code>
          clear()
         </code>
         . There are two overloads of
         <code>
          erase()
         </code>
         : one accepting a single iterator to remove a single element, and one accepting two iterators specifying a range of elements to remove.
        </p>
        <p>
         Let's look at an example program that demonstrates some of the member functions for adding and removing elements. The following code snippet demonstrates
         <code>
          clear()
         </code>
         ,
         <code>
          push_back()
         </code>
         ,
         <code>
          pop_back()
         </code>
         , the C++23
         <code>
          append_range()
         </code>
         , the two-argument version of
         <code>
          erase()
         </code>
         , and the following overloads of
         <code>
          insert()
         </code>
         :
        </p>
        <ul class="check1" id="c18-list-0007">
         <li id="c18-li-0043">
          <b>
           <code>
            insert(const_iterator pos, const T&amp; x)
           </code>
           :
          </b>
          The value
          <code>
           x
          </code>
          is inserted at position
          <code>
           pos
          </code>
          .
         </li>
         <li id="c18-li-0044">
          <b>
           <code>
            insert(const_iterator pos, size_type n, const T&amp; x)
           </code>
           :
          </b>
          The value
          <code>
           x
          </code>
          is inserted
          <code>
           n
          </code>
          times at position
          <code>
           pos
          </code>
          .
         </li>
         <li id="c18-li-0045">
          <b>
           <code>
            insert(const_iterator pos, InputIterator first, InputIterator last)
           </code>
           :
          </b>
          The elements in the range
          <code>
           [first, last)
          </code>
          are inserted at position
          <code>
           pos
          </code>
          .
         </li>
        </ul>
        <p>
         Here is the code snippet:
        </p>
        <pre id="c18-code-0042"><code>vector vectorOne { 1, 2, 3, 5 };</code>
<code>vector&lt;int&gt; vectorTwo;</code>
<code>println("{:n}", vectorOne);</code>
<code> </code>
<code><span class="color3">// Oops, we forgot to add 4. Insert it in the correct place.</span></code>
<code>vectorOne.insert(cbegin(vectorOne) + 3, 4);</code>
<code> </code>
<code><span class="color3">// Add elements 6 through 10 to vectorTwo.</span></code>
<code>for (int i { 6 }; i &lt;= 10; ++i) {</code>
<code>    vectorTwo.push_back(i);</code>
<code>}</code>
<code>println("{:n}", vectorOne);</code>
<code>println("{:n}", vectorTwo);</code>
<code> </code>
<code><span class="color3">// Add all elements from vectorTwo to the end of vectorOne.</span></code>
<code>vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));</code>
<code>println("{:n}", vectorOne);</code>
<code> </code>
<code><span class="color3">// Add all vectorTwo elements to the end of vectorOne using C++23 append_range().</span></code>
<code><span class="color3">// Note how much clearer this is compared to the previous call to insert().</span></code>
<code>vectorOne.append_range(vectorTwo);</code>
<code>println("{:n}", vectorOne);</code>
<code> </code>
<code><span class="color3">// Now erase the numbers 2 through 5 in vectorOne.</span></code>
<code>vectorOne.erase(cbegin(vectorOne) + 1, cbegin(vectorOne) + 5);</code>
<code>println("{:n}", vectorOne);</code>
<code> </code>
<code><span class="color3">// Clear vectorTwo entirely.</span></code>
<code>vectorTwo.clear();</code>
<code> </code>
<code><span class="color3">// And add 10 copies of the value 100.</span></code>
<code>vectorTwo.insert(cbegin(vectorTwo), 10, 100);</code>
<code>println("{:n}", vectorTwo);</code>
<code> </code>
<span aria-label="699" epub:type="pagebreak" id="Page_699" role="doc-pagebreak"></span><code><span class="color3">// Decide we only want 9 elements.</span></code>
<code>vectorTwo.pop_back();</code>
<code>println("{:n}", vectorTwo);</code></pre>
        <p>
         The output of the program is as follows:
        </p>
        <pre id="c18-code-0043"><code>1, 2, 3, 5</code>
<code>1, 2, 3, 4, 5</code>
<code>6, 7, 8, 9, 10</code>
<code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code>1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10</code>
<code>1, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10</code>
<code>100, 100, 100, 100, 100, 100, 100, 100, 100, 100</code>
<code>100, 100, 100, 100, 100, 100, 100, 100, 100</code></pre>
        <p>
         Recall that iterator pairs represent half-open ranges, and
         <code>
          insert()
         </code>
         adds elements before the element referred to by a given iterator position. Thus, you can insert the entire contents of
         <code>
          vectorTwo
         </code>
         at the end of
         <code>
          vectorOne
         </code>
         , like this:
        </p>
        <pre id="c18-code-0044"><code>vectorOne.insert(cend(vectorOne), cbegin(vectorTwo), cend(vectorTwo));</code></pre>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0109">
            <b>
             WARNING
            </b>
            <i>
             Member functions such as
            </i>
            <code>
             insert()
            </code>
            <i>
             and
            </i>
            <code>
             erase()
            </code>
            <i>
             that take a common iterator range as argument assume that the beginning and ending iterators refer to elements in the same container and that the end iterator refers to an element at or past the begin iterator. The member functions will not work correctly if these preconditions are not met!
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c18-para-0110">
         If you want to remove all elements satisfying a condition, one solution would be to write a loop iterating over all the elements and erasing every element that matches the condition. However, this solution has quadratic complexity, which is bad for performance. This quadratic complexity can be avoided by using the
         <i>
          remove-erase-idiom
         </i>
         , which has a linear complexity. The remove-erase-idiom is discussed in
         <a href="c20.xhtml">
          Chapter 20
         </a>
         .
        </p>
        <p>
         Starting with C++20, however, there is a more elegant solution in the form of the
         <code>
          std::erase()
         </code>
         and
         <code>
          std::erase_if()
         </code>
         non-member functions, defined for all Standard Library containers. The former is demonstrated in the following code snippet:
        </p>
        <pre id="c18-code-0045"><code>vector values { 1, 2, 3, 2, 1, 2, 4, 5 };</code>
<code>println("{:n}", values);</code>
<code> </code>
<code>erase(values, 2);  <span class="color3">// Removes all values equal to 2.</span></code>
<code>println("{:n}", values);</code></pre>
        <p>
         The output is as follows:
        </p>
        <pre id="c18-code-0046"><code>1, 2, 3, 2, 1, 2, 4, 5</code>
<code>1, 3, 1, 4, 5</code></pre>
        <p id="c18-para-0113">
         <code>
          erase_if()
         </code>
         works similarly, but instead of passing a value as second argument, a predicate is passed that returns
         <code>
          true
         </code>
         for elements that should be removed, and
         <code>
          false
         </code>
         for elements that should be kept.
         <span aria-label="700" epub:type="pagebreak" id="Page_700" role="doc-pagebreak">
         </span>
         The predicate can take the form of a function pointer, a function object, or a lambda expression, all of which are discussed in detail in
         <a href="c19.xhtml">
          Chapter 19
         </a>
         , “Function Pointers, Function Objects, and Lambda Expressions.”
        </p>
        <section>
         <span id="c18-sec-0039">
         </span>
         <h6 id="head-6-6">
          Move Semantics
         </h6>
         <p>
          Adding elements to a
          <code>
           vector
          </code>
          can make use of move semantics to improve performance in certain situations. For example, suppose you have the following
          <code>
           vector
          </code>
          of
          <code>
           string
          </code>
          s:
         </p>
         <pre id="c18-code-0047"><code>vector&lt;string&gt; vec;</code></pre>
         <p>
          You can add an element to this
          <code>
           vector
          </code>
          as follows:
         </p>
         <pre id="c18-code-0048"><code>string myElement(5, 'a');  <span class="color3">// Constructs the string "aaaaa"</span></code>
<code>vec.push_back(myElement);</code></pre>
         <p id="c18-para-0116">
          However, because
          <code>
           myElement
          </code>
          is not a temporary object,
          <code>
           push_back()
          </code>
          makes a copy of
          <code>
           myElement
          </code>
          and puts it into the
          <code>
           vector
          </code>
          .
         </p>
         <p>
          The
          <code>
           vector
          </code>
          class also defines a
          <code>
           push_back(T&amp;&amp;)
          </code>
          , which is the move equivalent of
          <code>
           push_back(const T&amp;)
          </code>
          . So, copying can be avoided if you call
          <code>
           push_back()
          </code>
          as follows:
         </p>
         <pre id="c18-code-0049"><code>vec.push_back(move(myElement));</code></pre>
         <p>
          This statement explicitly says that
          <code>
           myElement
          </code>
          should be moved into the
          <code>
           vector
          </code>
          . Note that after this call,
          <code>
           myElement
          </code>
          is in a valid but otherwise indeterminate state. You should not use
          <code>
           myElement
          </code>
          anymore, unless you first bring it back to a determinate state, for example by calling
          <code>
           clear()
          </code>
          on it! You can also call
          <code>
           push_back()
          </code>
          as follows:
         </p>
         <pre id="c18-code-0050"><code>vec.push_back(string(5, 'a'));</code></pre>
         <p id="c18-para-0119">
          This call to
          <code>
           push_back()
          </code>
          triggers a call to the move overload because the call to the
          <code>
           string
          </code>
          constructor results in a temporary object. The
          <code>
           push_back()
          </code>
          member function moves this temporary
          <code>
           string
          </code>
          object into the
          <code>
           vector
          </code>
          , avoiding any copying.
         </p>
        </section>
        <section>
         <span id="c18-sec-0040">
         </span>
         <h6 id="head-6-7">
          Emplace Operations
         </h6>
         <p>
          C++ supports
          <i>
           emplace operations
          </i>
          on most Standard Library containers, including
          <code>
           vector
          </code>
          . Emplace means “to put into place.” An example is the
          <code>
           emplace:back()
          </code>
          member function of
          <code>
           vector
          </code>
          , which does not copy or move anything. Instead, it makes space in the container and constructs the object
          <i>
           in place
          </i>
          , as in this example:
         </p>
         <pre id="c18-code-0051"><code>vec.emplace:back(5, 'a');</code></pre>
         <p>
          The emplace member functions take a variable number of arguments as a variadic template. Variadic templates are discussed in
          <a href="c26.xhtml">
           Chapter 26
          </a>
          , “Advanced Templates,” but those details are not required to understand how to use
          <code>
           emplace:back()
          </code>
          . Basically, the arguments passed to
          <code>
           emplace:back()
          </code>
          are forwarded to a constructor of the type stored in the
          <code>
           vector
          </code>
          . The difference in performance between
          <code>
           emplace:back()
          </code>
          and
          <code>
           push_back()
          </code>
          using move semantics depends on how your specific compiler implements these operations. In most situations, you can pick the one based on the syntax that you prefer:
         </p>
         <pre id="c18-code-0052"><code>vec.push_back(string(5, 'a'));</code>
<code><span class="color3">// Or</span></code>
<code>vec.emplace:back(5, 'a');</code></pre>
         <p id="c18-para-0122">
          <span aria-label="701" epub:type="pagebreak" id="Page_701" role="doc-pagebreak">
          </span>
          The
          <code>
           emplace:back()
          </code>
          member function returns a reference to the inserted element. There is also an
          <code>
           emplace()
          </code>
          member function that constructs an object in place at a specific position in the
          <code>
           vector
          </code>
          and returns an iterator to the inserted element.
         </p>
        </section>
        <section>
         <span id="c18-sec-0041">
         </span>
         <h6 id="head-6-8">
          Algorithmic Complexity and Iterator Invalidation
         </h6>
         <p id="c18-para-0123">
          Inserting or erasing elements in a
          <code>
           vector
          </code>
          causes all subsequent elements to shift up or down to make room for, or fill in the holes left by, the affected elements. Thus, these operations take linear complexity. Furthermore, all iterators referring to the insertion or removal point or subsequent positions are invalid following the action. The iterators are not “magically” moved to keep up with the elements that are shifted up or down in the
          <code>
           vector
          </code>
          —that's up to you.
         </p>
         <p id="c18-para-0124">
          Also keep in mind that an internal
          <code>
           vector
          </code>
          reallocation can cause invalidation of all iterators referring to elements in the
          <code>
           vector
          </code>
          , not just those referring to elements past the point of insertion or deletion. See the next section for details.
         </p>
        </section>
       </section>
       <section>
        <span id="c18-sec-0042">
        </span>
        <h5 id="head-5-117">
         The vector Memory Allocation Scheme
        </h5>
        <p id="c18-para-0125">
         A
         <code>
          vector
         </code>
         allocates memory automatically to store the elements that you insert. Recall that the
         <code>
          vector
         </code>
         requirements dictate that the elements must be in contiguous memory, like in standard C-style arrays. Because it's impossible to request to add memory to the end of a current chunk of memory, every time a
         <code>
          vector
         </code>
         allocates more memory, it must allocate a new, larger chunk in a separate memory location and copy/move all the elements to the new chunk. This process is time-consuming, so
         <code>
          vector
         </code>
         implementations attempt to avoid it by allocating more space than needed when they have to perform a reallocation. That way, they can avoid reallocating memory every time you insert an element.
        </p>
        <p>
         One obvious question at this point is why you, as a client of
         <code>
          vector
         </code>
         , care how it manages its memory internally. You might think that the principle of abstraction should allow you to disregard the internals of the
         <code>
          vector
         </code>
         memory allocation scheme. Unfortunately, there are two reasons why you need to understand how it works:
        </p>
        <ul class="check1" id="c18-list-0008">
         <li id="c18-li-0046">
          <b>
           Efficiency:
          </b>
          The
          <code>
           vector
          </code>
          allocation scheme can guarantee that an element insertion runs in
          <i>
           amortized constant time
          </i>
          : most of the time the operation is constant, but once in a while (if it requires a reallocation), it's linear. If you are worried about efficiency, you can control when a
          <code>
           vector
          </code>
          performs reallocations.
         </li>
         <li id="c18-li-0047">
          <b>
           Iterator invalidations:
          </b>
          A reallocation invalidates all iterators referring to elements in a
          <code>
           vector
          </code>
          .
         </li>
        </ul>
        <p>
         Thus, the
         <code>
          vector
         </code>
         interface allows you to query and control the
         <code>
          vector
         </code>
         reallocations, both explained in the upcoming subsections.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0128">
            <b>
             WARNING
            </b>
            <i>
             If you don't control the reallocations explicitly, you should assume that all insertions cause a reallocation and thus invalidate all iterators
            </i>
            .
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <span aria-label="702" epub:type="pagebreak" id="Page_702" role="doc-pagebreak">
        </span>
        <section>
         <span id="c18-sec-0044">
         </span>
         <h6 id="head-6-9">
          Size and Capacity
         </h6>
         <p>
          <code>
           vector
          </code>
          provides two member functions for obtaining information about its size:
          <code>
           size()
          </code>
          and
          <code>
           capacity()
          </code>
          . The
          <code>
           size()
          </code>
          member function returns the number of elements in a
          <code>
           vector
          </code>
          , while
          <code>
           capacity()
          </code>
          returns the number of elements that it can hold without a reallocation. Thus, the number of elements that you can insert without causing a reallocation is
          <code>
           capacity() – size()
          </code>
          .
         </p>
         <section>
          <aside>
           <div class="top hr">
            <hr/>
           </div>
           <section class="feature1">
            <p id="c18-para-0130">
             <b>
              NOTE
             </b>
             <i>
              You can query whether a
             </i>
             <code>
              vector
             </code>
             <i>
              is empty with the
             </i>
             <code>
              empty()
             </code>
             <i>
              member function. A
             </i>
             <code>
              vector
             </code>
             <i>
              can be empty but have nonzero capacity.
             </i>
            </p>
            <div class="bottom hr">
             <hr/>
            </div>
           </section>
          </aside>
         </section>
         <p>
          There are also non-member
          <code>
           std::size()
          </code>
          and
          <code>
           std::empty()
          </code>
          global functions, which can be used with all containers. They can also be used with statically allocated C-style arrays not accessed through pointers, and with
          <code>
           initializer_list
          </code>
          s. Here is an example of using them with a
          <code>
           vector
          </code>
          :
         </p>
         <pre id="c18-code-0053"><code>vector vec { 1, 2, 3 };</code>
<code>println("{}", size(vec));  <span class="color3">// 3</span></code>
<code>println("{}", empty(vec)); <span class="color3">// false</span></code></pre>
         <p>
          Additionally,
          <code>
           std::ssize()
          </code>
          , a global non-member helper function, returns the size as a signed integral type. Here's an example:
         </p>
         <pre id="c18-code-0054"><code>auto s1 { size(vec) };   <span class="color3">// Type is size_t (unsigned)</span></code>
<code>auto s2 { ssize(vec) };  <span class="color3">// Type is long long (signed)</span></code></pre>
        </section>
        <section>
         <span id="c18-sec-0046">
         </span>
         <h6 id="head-6-10">
          Reserving Capacity
         </h6>
         <p id="c18-para-0133">
          If you don't care about efficiency or iterator invalidations, there is never a need to control the
          <code>
           vector
          </code>
          memory allocation explicitly. However, if you want to make your program as efficient as possible or you want to guarantee that iterators will not be invalidated, you can force a
          <code>
           vector
          </code>
          to preallocate enough space to hold all of its elements. Of course, you need to know how many elements it will hold, which is sometimes impossible to predict.
         </p>
         <p>
          One way to preallocate space is to call
          <code>
           reserve()
          </code>
          , which allocates enough memory to hold the specified number of elements. The upcoming round-robin class example shows the
          <code>
           reserve()
          </code>
          member function in action.
         </p>
         <section>
          <aside>
           <div class="top hr">
            <hr/>
           </div>
           <section class="feature1">
            <p id="c18-para-0135">
             <b>
              WARNING
             </b>
             <i>
              Reserving space for elements changes the capacity, but not the size. That is, it doesn't actually create elements. Don't access elements past a
             </i>
             <code>
              vector
             </code>
             <i>
              '
             </i>
             s
             <i>
              size
             </i>
             .
            </p>
            <div class="bottom hr">
             <hr/>
            </div>
           </section>
          </aside>
         </section>
         <p id="c18-para-0136">
          Another way to preallocate space is to specify, in the constructor, or with the
          <code>
           resize()
          </code>
          or
          <code>
           assign()
          </code>
          member function, how many elements you want a
          <code>
           vector
          </code>
          to store. This member function actually creates a
          <code>
           vector
          </code>
          of that size (and probably of that capacity).
         </p>
        </section>
        <span aria-label="703" epub:type="pagebreak" id="Page_703" role="doc-pagebreak">
        </span>
        <section>
         <span id="c18-sec-0048">
         </span>
         <h6 id="head-6-11">
          Reclaiming All Memory
         </h6>
         <p id="c18-para-0137">
          A
          <code>
           vector
          </code>
          automatically allocates more memory if needed; however, it will never release any memory, unless the
          <code>
           vector
          </code>
          is destroyed. Removing elements from a
          <code>
           vector
          </code>
          decreases the size of the
          <code>
           vector
          </code>
          , but never its capacity. How then can you reclaim its memory?
         </p>
         <p id="c18-para-0138">
          One option is to use the
          <code>
           shrink_to_fit()
          </code>
          member function, which requests a
          <code>
           vector
          </code>
          to reduce its capacity to its size. However, it's just a request, and a Standard Library implementation is allowed to ignore this request.
         </p>
         <p>
          Reclaiming
          <b>
           all
          </b>
          memory of a
          <code>
           vector
          </code>
          can be done using the following trick: swap the
          <code>
           vector
          </code>
          with an empty one. The following code snippet shows how memory of a
          <code>
           vector
          </code>
          called
          <code>
           values
          </code>
          can be reclaimed with a single statement. The third line of code constructs a temporary empty default-constructed
          <code>
           vector
          </code>
          of the same type as
          <code>
           values
          </code>
          and swaps this with
          <code>
           values
          </code>
          . All memory that was allocated for
          <code>
           values
          </code>
          now belongs to this temporary
          <code>
           vector
          </code>
          , which is automatically destroyed at the end of that statement freeing all its memory. The end result is that all memory that was allocated for
          <code>
           values
          </code>
          is reclaimed, and
          <code>
           values
          </code>
          is left with a capacity of zero.
         </p>
         <pre id="c18-code-0055"><code>vector&lt;int&gt; values;</code>
<code><span class="color3">// Populate values …</span></code>
<code>vector&lt;int&gt;().swap(values);</code></pre>
        </section>
        <section>
         <span id="c18-sec-0049">
         </span>
         <h6 id="head-6-12">
          Directly Accessing the Data
         </h6>
         <p id="c18-para-0140">
          A
          <code>
           vector
          </code>
          stores its data contiguously in memory. You can get a pointer to this block of memory with the
          <code>
           data()
          </code>
          member function.
         </p>
         <p>
          There is also a non-member
          <code>
           std::data()
          </code>
          function that can be used to get a pointer to the data. It works for the
          <code>
           array
          </code>
          and
          <code>
           vector
          </code>
          containers,
          <code>
           string
          </code>
          s, statically allocated C-style arrays not accessed through pointers, and
          <code>
           initializer_list
          </code>
          s. Here is an example for a
          <code>
           vector
          </code>
          :
         </p>
         <pre id="c18-code-0056"><code>vector vec { 1, 2, 3 };</code>
<code>int* data1 { vec.data() };</code>
<code>int* data2 { data(vec) };</code></pre>
         <p id="c18-para-0142">
          Another way to get access to the memory block of a
          <code>
           vector
          </code>
          is by taking the address of the first element, as in:
          <code>
           &amp;vec[0]
          </code>
          . You might find this kind of code in legacy code bases, but it is not safe for empty
          <code>
           vector
          </code>
          s; as such, I recommend not to use it and instead use
          <code>
           data()
          </code>
          .
         </p>
        </section>
       </section>
      </section>
      <section>
       <span id="c18-sec-0050">
       </span>
       <h4 id="head-4-281">
        Move Semantics
       </h4>
       <p>
        All Standard Library containers support move semantics by including a move constructor and move assignment operator. See
        <a href="c09.xhtml">
         Chapter 9
        </a>
        for details on move semantics. Standard Library containers can be returned from functions
        <i>
         by value
        </i>
        without performance penalty. Take a look at the following function:
       </p>
       <pre id="c18-code-0057"><code>vector&lt;int&gt; createVectorOfSize(size_t size)</code>
<code>{</code>
<code>    vector&lt;int&gt; vec(size);</code>
<code>    for (int contents { 0 }; auto&amp; i : vec) { i = contents++; }</code>
<code>    return vec;</code>
<code>}</code>
<code>…</code>
<code>vector&lt;int&gt; myVector;</code>
<code>myVector = createVectorOfSize(123);</code></pre>
       <p id="c18-para-0144">
        <span aria-label="704" epub:type="pagebreak" id="Page_704" role="doc-pagebreak">
        </span>
        Without move semantics, assigning the result of
        <code>
         createVectorOfSize()
        </code>
        to
        <code>
         myVector
        </code>
        might call the copy assignment operator. With the move semantics support in the Standard Library containers, copying of the
        <code>
         vector
        </code>
        is avoided. Instead, the assignment to
        <code>
         myVector
        </code>
        triggers a call to the move assignment operator.
       </p>
       <p id="c18-para-0145">
        Keep in mind, though, that for move semantics to work properly with Standard Library containers, the move constructor and move assignment operator of the type stored in the container must be marked as
        <code>
         noexcept
        </code>
        ! Why are these move member functions not allowed to throw any exceptions? Imagine that they are allowed to throw exceptions. Now, when adding, for example, new elements to a
        <code>
         vector
        </code>
        , it might be that the capacity of the
        <code>
         vector
        </code>
        is not sufficient and that it needs to allocate a bigger block of memory. Subsequently, the
        <code>
         vector
        </code>
        must either copy or move all the data from the original memory block to the new one. If this would be done using a move member function that can potentially throw, then it might happen that an exception gets thrown when part of the data has already been moved to the new memory block. What can we do then? Not much. To avoid these kinds of problems, Standard Library containers will only use move member functions if they guarantee not to throw any exceptions. If they are not marked
        <code>
         noexcept
        </code>
        , the copy member functions will be used instead to guarantee strong exception safety.
       </p>
       <p id="c18-para-0146">
        When implementing your own Standard Library–like containers, there is a useful helper function available called
        <code>
         std::move_if_noexcept()
        </code>
        , defined in
        <code>
         &lt;utility&gt;
        </code>
        . This can be used to call either the move constructor or the copy constructor depending on whether the move constructor is
        <code>
         noexcept
        </code>
        . In itself,
        <code>
         move_if_noexcept()
        </code>
        doesn't do much. It accepts a reference as a parameter and converts it to either an rvalue reference if the move constructor is
        <code>
         noexcept
        </code>
        or to a reference-to-
        <code>
         const
        </code>
        otherwise, but this simple trick allows you to call the correct constructor with a single call.
       </p>
       <p id="c18-para-0147">
        The Standard Library does not provide a similar helper function to call the move assignment operator or copy assignment operator depending on whether the former is
        <code>
         noexcept
        </code>
        . Implementing one yourself is not too complicated, but requires some template metaprogramming techniques and type traits to inspect properties of types. Both topics are discussed in
        <a href="c26.xhtml">
         Chapter 26
        </a>
        , which also gives an example of implementing your own
        <code>
         move_assign_if_noexcept()
        </code>
        .
       </p>
      </section>
      <section>
       <span id="c18-sec-0051">
       </span>
       <h4 id="head-4-282">
        vector Example: A Round-Robin Class
       </h4>
       <p id="c18-para-0148">
        A common problem in computer science is distributing requests among a finite list of resources. For example, a simple operating system could keep a list of processes and assign a time slice (such as 100ms) to each process to let the process perform some of its work. After the time slice is finished, the OS suspends the process, and the next process in the list is given a time slice to perform some of its work. One of the simplest algorithmic solutions to this problem is
        <i>
         round-robin scheduling
        </i>
        . When the time slice of the last process is finished, the scheduler starts over again with the first process. For example, in the case of three processes, the first-time slice would go to the first process, the second slice to the second process, the third slice to the third process, and the fourth slice back to the first process. The cycle would continue in this way indefinitely.
       </p>
       <p>
        Suppose that you decide to write a generic round-robin scheduling class that can be used with any type of resource. The class should support adding and removing resources and should support cycling through the resources to obtain the next one. You could use a
        <code>
         vector
        </code>
        directly, but it's often helpful to write a wrapper class that provides more directly the functionality you need for your specific application. The following example shows a
        <code>
         RoundRobin
        </code>
        class template with comments explaining the code.
        <span aria-label="705" epub:type="pagebreak" id="Page_705" role="doc-pagebreak">
        </span>
        First, here is the class definition, exported from a module called
        <code>
         round_robin
        </code>
        :
       </p>
       <pre id="c18-code-0058"><code>export module round_robin;</code>
<code>import std;</code>
<code> </code>
<code><span class="color3">// Class template RoundRobin</span></code>
<code><span class="color3">// Provides simple round-robin semantics for a list of elements.</span></code>
<code>export template &lt;typename T&gt;</code>
<code>class RoundRobin final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Client can give a hint as to the number of expected elements for</span></code>
<code>        <span class="color3">// increased efficiency.</span></code>
<code>        explicit RoundRobin(std::size_t numExpected = 0);</code>
<code>        <span class="color3">// Prevent copy construction and copy assignment</span></code>
<code>        RoundRobin(const RoundRobin&amp; src) = delete;</code>
<code>        RoundRobin&amp; operator=(const RoundRobin&amp; rhs) = delete;</code>
<code>        <span class="color3">// Explicitly default a move constructor and move assignment operator</span></code>
<code>        RoundRobin(RoundRobin&amp;&amp; src) noexcept = default;</code>
<code>        RoundRobin&amp; operator=(RoundRobin&amp;&amp; rhs) noexcept = default;</code>
<code>        <span class="color3">// Appends element to the end of the list. May be called</span></code>
<code>        <span class="color3">// between calls to getNext().</span></code>
<code>        void add(const T&amp; element);</code>
<code>        <span class="color3">// Removes the first (and only the first) element</span></code>
<code>        <span class="color3">// in the list that is equal (with operator==) to element.</span></code>
<code>        <span class="color3">// May be called between calls to getNext().</span></code>
<code>        void remove(const T&amp; element);</code>
<code>        <span class="color3">// Returns the next element in the list, starting with the first,</span></code>
<code>        <span class="color3">// and cycling back to the first when the end of the list is</span></code>
<code>        <span class="color3">// reached, taking into account elements that are added or removed.</span></code>
<code>        T&amp; getNext();</code>
<code>    private:</code>
<code>        std::vector&lt;T&gt; m_elements;</code>
<code>        typename std::vector&lt;T&gt;::iterator m_nextElement;</code>
<code>};</code></pre>
       <p id="c18-para-0150">
        As you can see, the public interface is straightforward: only three member functions plus the constructor. The resources are stored in a
        <code>
         vector
        </code>
        called
        <code>
         m_elements
        </code>
        . The iterator
        <code>
         m_nextElement
        </code>
        always refers to the element that will be returned with the next call to
        <code>
         getNext()
        </code>
        . If
        <code>
         getNext()
        </code>
        hasn't been called yet,
        <code>
         m_nextElement
        </code>
        is equal to
        <code>
         begin(m_elements)
        </code>
        . Note the use of the
        <code>
         typename
        </code>
        keyword in front of the line declaring
        <code>
         m_nextElement
        </code>
        . So far, you've only seen that keyword used to specify template type parameters, but there is another use for it. You must specify
        <code>
         typename
        </code>
        explicitly whenever you access a type based on one or more template parameters. In this case, the template parameter
        <code>
         T
        </code>
        is used to access the
        <code>
         iterator
        </code>
        type. Thus, you must specify
        <code>
         typename
        </code>
        .
       </p>
       <p id="c18-para-0151">
        The class also prevents copy construction and copy assignment because of the
        <code>
         m_nextElement
        </code>
        data member. To make copy construction and copy assignment work, you would have to implement an assignment operator and copy constructor and make sure
        <code>
         m_nextElement
        </code>
        is valid in the destination object.
       </p>
       <p>
        The implementation of the
        <code>
         RoundRobin
        </code>
        class follows with comments explaining the code. Note the use of
        <code>
         reserve()
        </code>
        in the constructor, and the extensive use of iterators in
        <code>
         add()
        </code>
        ,
        <code>
         remove()
        </code>
        , and
        <span aria-label="706" epub:type="pagebreak" id="Page_706" role="doc-pagebreak">
        </span>
        <code>
         getNext()
        </code>
        . The trickiest aspect is handling
        <code>
         m_nextElement
        </code>
        in the
        <code>
         add()
        </code>
        and
        <code>
         remove()
        </code>
        member functions.
       </p>
       <pre id="c18-code-0059"><code>template &lt;typename T&gt; RoundRobin&lt;T&gt;::RoundRobin(std::size_t numExpected)</code>
<code>{</code>
<code>    <span class="color3">// If the client gave a guideline, reserve that much space.</span></code>
<code>    m_elements.reserve(numExpected);</code>
<code> </code>
<code>    <span class="color3">// Initialize m_nextElement even though it isn't used until</span></code>
<code>    <span class="color3">// there's at least one element.</span></code>
<code>    m_nextElement = begin(m_elements);</code>
<code>}</code>
<code> </code>
<code><span class="color3">// Always add the new element at the end.</span></code>
<code>template &lt;typename T&gt; void RoundRobin&lt;T&gt;::add(const T&amp; element)</code>
<code>{</code>
<code>    <span class="color3">// Even though we add the element at the end, the vector could</span></code>
<code>    <span class="color3">// reallocate and invalidate the m_nextElement iterator with</span></code>
<code>    <span class="color3">// the push_back() call. Take advantage of the random-access</span></code>
<code>    <span class="color3">// iterator features to save our spot.</span></code>
<code>    <span class="color3">// Note: ptrdiff_t is a type capable of storing the difference</span></code>
<code>    <span class="color3">//       between two random-access iterators.</span></code>
<code>    std::ptrdiff_t pos { m_nextElement - begin(m_elements) };</code>
<code> </code>
<code>    <span class="color3">// Add the element.</span></code>
<code>    m_elements.push_back(element);</code>
<code> </code>
<code>    <span class="color3">// Reset our iterator to make sure it is valid.</span></code>
<code>    m_nextElement = begin(m_elements) + pos;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; void RoundRobin&lt;T&gt;::remove(const T&amp; element)</code>
<code>{</code>
<code>    for (auto it { begin(m_elements) }; it != end(m_elements); ++it) {</code>
<code>        if (*it == element) {</code>
<code>            <span class="color3">// Removing an element invalidates the m_nextElement iterator</span></code>
<code>            <span class="color3">// if it refers to an element past the point of the removal.</span></code>
<code>            <span class="color3">// Take advantage of the random-access features of the iterator</span></code>
<code>            <span class="color3">// to track the position of the current element after removal.</span></code>
<code>            std::ptrdiff_t newPos;</code>
<code> </code>
<code>            if (m_nextElement == end(m_elements) - 1 &amp;&amp;</code>
<code>                m_nextElement == it) {</code>
<code>                <span class="color3">// m_nextElement refers to the last element in the list,</span></code>
<code>                <span class="color3">// and we are removing that last element, so wrap back to</span></code>
<code>                <span class="color3">// the beginning.</span></code>
<code>                newPos = 0;</code>
<code>            } else if (m_nextElement &lt;= it) {</code>
<code>                <span class="color3">// Otherwise, if m_nextElement is before or at the one</span></code>
<code>                <span class="color3">// we're removing, the new position is the same as before.</span></code>
<code>                newPos = m_nextElement - begin(m_elements);</code>
<code>            } else {</code>
<code>                <span class="color3">// Otherwise, it's one less than before.</span></code>
<code>                newPos = m_nextElement - begin(m_elements) - 1;</code>
<code>            }</code>
<code> </code>
<span aria-label="707" epub:type="pagebreak" id="Page_707" role="doc-pagebreak"></span><code>            <span class="color3">// Erase the element (and ignore the return value).</span></code>
<code>            m_elements.erase(it);</code>
<code> </code>
<code>            <span class="color3">// Now reset our iterator to make sure it is valid.</span></code>
<code>            m_nextElement = begin(m_elements) + newPos;</code>
<code> </code>
<code>            return;</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; T&amp; RoundRobin&lt;T&gt;::getNext()</code>
<code>{</code>
<code>    <span class="color3">// First, make sure there are elements.</span></code>
<code>    if (m_elements.empty()) {</code>
<code>        throw std::out_of_range { "No elements in the list" };</code>
<code>    }</code>
<code> </code>
<code>    <span class="color3">// Store the current element which we need to return.</span></code>
<code>    auto&amp; toReturn { *m_nextElement };</code>
<code> </code>
<code>    <span class="color3">// Increment the iterator modulo the number of elements.</span></code>
<code>    ++m_nextElement;</code>
<code>    if (m_nextElement == end(m_elements)) { m_nextElement = begin(m_elements); }</code>
<code> </code>
<code>    <span class="color3">// Return a reference to the element.</span></code>
<code>    return toReturn;</code>
<code>}</code></pre>
       <p>
        Here's a simple implementation of a scheduler that uses the
        <code>
         RoundRobin
        </code>
        class template, with comments explaining the code:
       </p>
       <pre id="c18-code-0060"><code><span class="color3">// Basic Process class.</span></code>
<code>class Process final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Constructor accepting the name of the process.</span></code>
<code>        explicit Process(string name) : m_name { move(name) } {}</code>
<code> </code>
<code>        <span class="color3">// Lets a process perform its work for the duration of a time slice.</span></code>
<code>        void doWorkDuringTimeSlice()</code>
<code>        {</code>
<code>            println("Process {} performing work during time slice.", m_name);</code>
<code>            <span class="color3">// Actual implementation omitted.</span></code>
<code>        }</code>
<code> </code>
<code>        <span class="color3">// Needed for the RoundRobin::remove() member function to work.</span></code>
<code>        bool operator==(const Process&amp;) const = default; <span class="color3">// = default since C++20.</span></code>
<code>    private:</code>
<code>        string m_name;</code>
<code>};</code>
<code> </code>
<span aria-label="708" epub:type="pagebreak" id="Page_708" role="doc-pagebreak"></span><code><span class="color3">// Basic round-robin based process scheduler.</span></code>
<code>class Scheduler final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Constructor takes a vector of processes.</span></code>
<code>        explicit Scheduler(const vector&lt;Process&gt;&amp; processes)</code>
<code>        {</code>
<code>            <span class="color3">// Add the processes.</span></code>
<code>            for (auto&amp; process : processes) { m_processes.add(process); }</code>
<code>        }</code>
<code> </code>
<code>        <span class="color3">// Selects the next process using a round-robin scheduling algorithm</span></code>
<code>        <span class="color3">// and allows it to perform some work during this time slice.</span></code>
<code>        void scheduleTimeSlice()</code>
<code>        {</code>
<code>            try {</code>
<code>                m_processes.getNext().doWorkDuringTimeSlice();</code>
<code>            } catch (const out_of_range&amp;) {</code>
<code>                println(cerr, "No more processes to schedule.");</code>
<code>            }</code>
<code>        }</code>
<code> </code>
<code>        <span class="color3">// Removes the given process from the list of processes.</span></code>
<code>        void removeProcess(const Process&amp; process)</code>
<code>        {</code>
<code>            m_processes.remove(process);</code>
<code>        }</code>
<code>    private:</code>
<code>        RoundRobin&lt;Process&gt; m_processes;</code>
<code>};</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    vector processes { Process { "1" }, Process { "2" }, Process { "3" } };</code>
<code> </code>
<code>    Scheduler scheduler { processes };</code>
<code>    for (size_t i { 0 }; i &lt; 4; ++i) { scheduler.scheduleTimeSlice(); }</code>
<code> </code>
<code>    scheduler.removeProcess(processes[1]);</code>
<code>    println("Removed second process");</code>
<code> </code>
<code>    for (size_t i { 0 }; i &lt; 4; ++i) { scheduler.scheduleTimeSlice(); }</code>
<code>}</code></pre>
       <p>
        The output should be as follows:
       </p>
       <pre id="c18-code-0061"><code>Process 1 performing work during time slice.</code>
<code>Process 2 performing work during time slice.</code>
<code>Process 3 performing work during time slice.</code>
<code>Process 1 performing work during time slice.</code>
<code>Removed second process</code>
<code>Process 3 performing work during time slice.</code>
<code>Process 1 performing work during time slice.</code>
<code>Process 3 performing work during time slice.</code>
<code>Process 1 performing work during time slice.</code></pre>
      </section>
     </section>
     <span aria-label="709" epub:type="pagebreak" id="Page_709" role="doc-pagebreak">
     </span>
     <section>
      <span id="c18-sec-0052">
      </span>
      <h3 id="head-3-401">
       The vector&lt;bool&gt; Specialization
      </h3>
      <p>
       The C++ standard requires a partial specialization of
       <code>
        vector
       </code>
       for
       <code>
        bool
       </code>
       s, with the intention that it optimizes space allocation by “packing” the Boolean values. Recall that a
       <code>
        bool
       </code>
       is either
       <code>
        true
       </code>
       or
       <code>
        false
       </code>
       and thus could be represented by a single bit, which can take on exactly two values. C++ does not have a native type that stores exactly one bit. Some compilers represent a Boolean value with a type the same size as a
       <code>
        char
       </code>
       ; other compilers use an
       <code>
        int
       </code>
       . The
       <code>
        vector
       </code>
       &lt;
       <code>
        bool
       </code>
       &gt; specialization is supposed to store the “array of
       <code>
        bool
       </code>
       s” in single bits, thus saving space.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0156">
          <b>
           NOTE
          </b>
          <i>
           You can think of the
          </i>
          <code>
           vector&lt;bool&gt;
          </code>
          <i>
           as a bit-field instead of a
          </i>
          <code>
           vector
          </code>
          <i>
           . The
          </i>
          <code>
           bitset
          </code>
          <i>
           container described later in this chapter provides a more full-featured bit-field implementation than does
          </i>
          <code>
           vector&lt;bool&gt;
          </code>
          <i>
           . However, the benefit of
          </i>
          <code>
           vector&lt;bool&gt;
          </code>
          <i>
           is that it can change size dynamically.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c18-para-0157">
       In a half-hearted attempt to provide some bit-field routines for
       <code>
        vector&lt;bool&gt;
       </code>
       , there is one additional member function called
       <code>
        flip()
       </code>
       that complements bits; that is,
       <code>
        true
       </code>
       becomes
       <code>
        false
       </code>
       , and
       <code>
        false
       </code>
       becomes
       <code>
        true
       </code>
       , similar to the logical NOT operator. This member function can be called either on the container—in which case it complements all the elements in the container—or on a single reference returned from
       <code>
        operator[]
       </code>
       or a similar member function, in which case it complements that single element.
      </p>
      <p>
       At this point, you should be wondering how you can call a member function on a reference to
       <code>
        bool
       </code>
       . The answer is that you can't. The
       <code>
        vector&lt;bool&gt;
       </code>
       specialization actually defines a class called
       <code>
        reference
       </code>
       that serves as a proxy for the underlying
       <code>
        bool
       </code>
       (or bit). When you call
       <code>
        operator[]
       </code>
       ,
       <code>
        at()
       </code>
       , or a similar member function, then
       <code>
        vector&lt;bool&gt;
       </code>
       returns a
       <code>
        reference
       </code>
       object, which is a proxy for the real
       <code>
        bool
       </code>
       .
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0159">
          <b>
           WARNING
          </b>
          <i>
           The fact that references returned from
          </i>
          <code>
           vector&lt;bool&gt;
          </code>
          <i>
           are really proxies means that you can't take their addresses to obtain pointers to the actual elements in the container.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p id="c18-para-0160">
       In practice, the little amount of space saved by packing
       <code>
        bool
       </code>
       s hardly seems worth the extra effort. Even worse, accessing and modifying elements in a
       <code>
        vector&lt;bool&gt;
       </code>
       is much slower than, for example, in a
       <code>
        vector&lt;int&gt;
       </code>
       . Many C++ experts recommend avoiding
       <code>
        vector&lt;bool&gt;
       </code>
       in favor of the
       <code>
        bitset
       </code>
       . If you do need a dynamically sized bit field, then just use something like
       <code>
        vector&lt;std::int_fast8_t&gt;
       </code>
       or
       <code>
        vector&lt;unsigned char&gt;
       </code>
       . The
       <code>
        std::int_fast8_t
       </code>
       type is defined in
       <code>
        &lt;cstdint&gt;
       </code>
       . It is a signed integer type for which the compiler has to use the fastest integer type it has that is at least 8 bits.
      </p>
     </section>
     <section>
      <span id="c18-sec-0055">
      </span>
      <h3 id="head-3-402">
       deque
      </h3>
      <p>
       <code>
        deque
       </code>
       (abbreviation for
       <i>
        double-ended queue
       </i>
       ) is almost identical to
       <code>
        vector
       </code>
       , but is used far less frequently. It is defined in
       <code>
        &lt;deque&gt;
       </code>
       . The principal differences are as follows:
       <span aria-label="710" epub:type="pagebreak" id="Page_710" role="doc-pagebreak">
       </span>
      </p>
      <ul class="check1" id="c18-list-0009">
       <li id="c18-li-0048">
        Elements are not stored contiguously in memory.
       </li>
       <li id="c18-li-0049">
        A
        <code>
         deque
        </code>
        supports true constant-time insertion and removal of elements at both the front and the back (a
        <code>
         vector
        </code>
        supports amortized constant time at just the back).
       </li>
       <li id="c18-li-0050">
        A
        <code>
         deque
        </code>
        provides the following member functions that
        <code>
         vector
        </code>
        omits:
        <ul class="check1" id="c18-list-0010">
         <li id="c18-li-0051">
          <code>
           push_front()
          </code>
          : Inserts an element at the beginning.
         </li>
         <li id="c18-li-0052">
          <code>
           pop_front()
          </code>
          : Removes the first element.
         </li>
         <li id="c18-li-0053">
          <code>
           emplace:front()
          </code>
          : Creates a new element in-place at the beginning and returns a reference to the inserted element.
         </li>
         <li id="c18-li-0054">
          <code>
           prepend_range()
          </code>
          : Adds all elements of a given range to the beginning of a
          <code>
           deque
          </code>
          . Available since C++23.
         </li>
        </ul>
       </li>
       <li id="c18-li-0055">
        A
        <code>
         deque
        </code>
        never moves its elements to a bigger array (as
        <code>
         vector
        </code>
        does) when inserting elements at the front or at the back. This also means that a
        <code>
         deque
        </code>
        does not invalidate any iterators in such cases.
       </li>
       <li id="c18-li-0056">
        A
        <code>
         deque
        </code>
        does not expose its memory management scheme via
        <code>
         reserve()
        </code>
        or
        <code>
         capacity()
        </code>
        .
       </li>
      </ul>
      <p id="c18-para-0163">
       <code>
        deque
       </code>
       s are rarely used, as opposed to
       <code>
        vector
       </code>
       s, so they are not further discussed. Consult a Standard Library Reference for a detailed list of all supported member functions.
      </p>
     </section>
     <section>
      <span id="c18-sec-0056">
      </span>
      <h3 id="head-3-403">
       list
      </h3>
      <p id="c18-para-0164">
       The Standard Library
       <code>
        list
       </code>
       class template, defined in
       <code>
        &lt;list&gt;
       </code>
       , is a standard doubly linked list. It supports constant-time insertion and deletion of elements at any point in the list but provides slow (linear) time access to individual elements. In fact, the list does not even provide random-access operations like
       <code>
        operator[]
       </code>
       . Only through iterators can you access individual elements.
      </p>
      <p id="c18-para-0165">
       Most of the
       <code>
        list
       </code>
       operations are identical to those of
       <code>
        vector
       </code>
       , including the constructors, destructor, copying operations, assignment operations, and comparison operations. This section focuses on those member functions that differ from those of
       <code>
        vector
       </code>
       .
      </p>
      <section>
       <span id="c18-sec-0057">
       </span>
       <h4 id="head-4-283">
        Accessing Elements
       </h4>
       <p id="c18-para-0166">
        The only member functions provided by a
        <code>
         list
        </code>
        to access elements are
        <code>
         front()
        </code>
        and
        <code>
         back()
        </code>
        , both of which run in constant time. These member functions return a reference to the first and last elements in a
        <code>
         list
        </code>
        . All other element access must be performed through iterators.
       </p>
       <p>
        Just as
        <code>
         vector
        </code>
        ,
        <code>
         list
        </code>
        supports
        <code>
         begin()
        </code>
        ,
        <code>
         end()
        </code>
        ,
        <code>
         rbegin()
        </code>
        ,
        <code>
         rend()
        </code>
        ,
        <code>
         cbegin()
        </code>
        ,
        <code>
         cend()
        </code>
        ,
        <code>
         crbegin()
        </code>
        , and
        <code>
         crend()
        </code>
        .
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0168">
           <b>
            WARNING
           </b>
           <i>
            Lists do not provide random access to elements
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <span aria-label="711" epub:type="pagebreak" id="Page_711" role="doc-pagebreak">
      </span>
      <section>
       <span id="c18-sec-0059">
       </span>
       <h4 id="head-4-284">
        Iterators
       </h4>
       <p id="c18-para-0169">
        A
        <code>
         list
        </code>
        iterator is bidirectional, not random access like a
        <code>
         vector
        </code>
        iterator. That means that you cannot add and subtract
        <code>
         list
        </code>
        iterators from each other or perform other pointer arithmetic on them. For example, if
        <code>
         p
        </code>
        is a
        <code>
         list
        </code>
        iterator, you can traverse through the elements of the
        <code>
         list
        </code>
        by doing
        <code>
         ++p
        </code>
        or
        <code>
         --p
        </code>
        , but you cannot use the addition or subtraction operator;
        <code>
         p+n
        </code>
        and
        <code>
         p-n
        </code>
        do not work.
       </p>
      </section>
      <section>
       <span id="c18-sec-0060">
       </span>
       <h4 id="head-4-285">
        Adding and Removing Elements
       </h4>
       <p id="c18-para-0170">
        A
        <code>
         list
        </code>
        supports the same add and remove element member functions as a
        <code>
         vector
        </code>
        , including
        <code>
         push_back()
        </code>
        ,
        <code>
         pop_back()
        </code>
        ,
        <code>
         emplace()
        </code>
        ,
        <code>
         emplace:back()
        </code>
        , the five forms of
        <code>
         insert()
        </code>
        ,
        <code>
         assign_range()
        </code>
        ,
        <code>
         insert_range()
        </code>
        ,
        <code>
         append_range()
        </code>
        , the two forms of
        <code>
         erase()
        </code>
        , and
        <code>
         clear()
        </code>
        . Like a
        <code>
         deque
        </code>
        , it also provides
        <code>
         push_front()
        </code>
        ,
        <code>
         emplace:front()
        </code>
        ,
        <code>
         pop_front()
        </code>
        , and
        <code>
         prepend_range()
        </code>
        . Member functions adding or removing a single element run in constant time, once you've found the correct position, while member functions adding or removing multiple elements run in linear time. Thus, a
        <code>
         list
        </code>
        could be appropriate for applications that perform many insertions and deletions from the data structure, but do not need quick index-based element access. But even then, a
        <code>
         vector
        </code>
        might still be faster. Use a performance profiler to make sure.
       </p>
      </section>
      <section>
       <span id="c18-sec-0061">
       </span>
       <h4 id="head-4-286">
        list Size
       </h4>
       <p id="c18-para-0171">
        Like
        <code>
         deque
        </code>
        s, and unlike
        <code>
         vector
        </code>
        s,
        <code>
         list
        </code>
        s do not expose their underlying memory model. Consequently, they support
        <code>
         size()
        </code>
        ,
        <code>
         empty()
        </code>
        , and
        <code>
         resize()
        </code>
        , but not
        <code>
         reserve()
        </code>
        or
        <code>
         capacity()
        </code>
        . Note that the
        <code>
         size()
        </code>
        member function on a
        <code>
         list
        </code>
        has constant complexity.
       </p>
      </section>
      <section>
       <span id="c18-sec-0062">
       </span>
       <h4 id="head-4-287">
        Special list Operations
       </h4>
       <p id="c18-para-0172">
        A
        <code>
         list
        </code>
        provides several special operations that exploit its quick element insertion and deletion. This section provides an overview of some of these operations with examples. Consult a Standard Library Reference for a thorough reference of all the member functions.
       </p>
       <section>
        <span id="c18-sec-0063">
        </span>
        <h5 id="head-5-118">
         Splicing
        </h5>
        <p>
         The linked-list characteristics of a
         <code>
          list
         </code>
         allow it to
         <i>
          splice
         </i>
         , or insert, an entire
         <code>
          list
         </code>
         at any position in another
         <code>
          list
         </code>
         in constant time. The simplest version of this member function works as follows:
        </p>
        <pre id="c18-code-0062"><code><span class="color3">// Store the a words in the main dictionary.</span></code>
<code>list&lt;string&gt; dictionary { "aardvark", "ambulance" };</code>
<code><span class="color3">// Store the b words.</span></code>
<code>list&lt;string&gt; bWords { "bathos", "balderdash" };</code>
<code><span class="color3">// Add the c words to the main dictionary.</span></code>
<code>dictionary.push_back("canticle");</code>
<code>dictionary.push_back("consumerism");</code>
<code><span class="color3">// Splice the b words into the main dictionary.</span></code>
<code>if (!bWords.empty()) {</code>
<code>    <span class="color3">// Get an iterator to the last b word.</span></code>
<code>    auto iterLastB { --(cend(bWords)) };</code>
<code>    <span class="color3">// Iterate up to the spot where we want to insert b words.</span></code>
<code>    auto it { cbegin(dictionary) };</code>
<code>    for (; it != cend(dictionary); ++it) {</code>
<code>        if (*it &gt; *iterLastB) { break; }</code>
<code>    }</code>
<span aria-label="712" epub:type="pagebreak" id="Page_712" role="doc-pagebreak"></span><code>    <span class="color3">// Add in the b words. This action removes the elements from bWords.</span></code>
<code>    dictionary.splice(it, bWords);</code>
<code>}</code>
<code><span class="color3">// Print out the dictionary.</span></code>
<code>println("{:n:}", dictionary);</code></pre>
        <p>
         The result from running this program looks like this:
        </p>
        <pre id="c18-code-0063"><code>aardvark, ambulance, bathos, balderdash, canticle, consumerism</code></pre>
        <p>
         There are also two other overloads of
         <code>
          splice()
         </code>
         : one that inserts a single element from another
         <code>
          list
         </code>
         and one that inserts a range from another
         <code>
          list
         </code>
         . Additionally, all overloads of
         <code>
          splice()
         </code>
         are available with either a normal reference or an rvalue reference to the source
         <code>
          list
         </code>
         .
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0176">
            <b>
             WARNING
            </b>
            <i>
             Splicing is destructive to the
            </i>
            <code>
             list
            </code>
            <i>
             passed as an argument, i.e., it removes the spliced elements from one
            </i>
            <code>
             list
            </code>
            <i>
             to insert them into the other.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section>
        <span id="c18-sec-0065">
        </span>
        <h5 id="head-5-119">
         More Efficient Versions of Algorithms
        </h5>
        <p>
         In addition to
         <code>
          splice()
         </code>
         , a
         <code>
          list
         </code>
         provides special implementations of several of the generic Standard Library algorithms. The generic forms are covered in
         <a href="c20.xhtml">
          Chapter 20
         </a>
         . Here, only the specific versions provided by
         <code>
          list
         </code>
         are discussed.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0178">
            <b>
             NOTE
            </b>
            <i>
             When you have a choice, use the
            </i>
            <code>
             list
            </code>
            <i>
             -specific member functions rather than the generic Standard Library algorithms because the former are more efficient. Sometimes you don't have a choice, and you must use the
            </i>
            <code>
             list
            </code>
            <i>
             -specific member functions; for example, the generic
            </i>
            <code>
             std::sort()
            </code>
            <i>
             algorithm requires random-access iterators, which a
            </i>
            <code>
             list
            </code>
            <i>
             does not provide.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c18-para-0179">
         The following table summarizes the algorithms for which
         <code>
          list
         </code>
         provides special implementations as member functions. See
         <a href="c20.xhtml">
          Chapter 20
         </a>
         for more details on the algorithms.
        </p>
        <table border="1">
         <thead>
          <tr>
           <th class="left bgcolor2" scope="col">
            MEMBER FUNCTION
           </th>
           <th class="left bgcolor2" scope="col">
            DESCRIPTION
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             remove()
            </code>
            <br/>
            <code>
             remove_if()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Removes all elements matching certain criteria from a
            <code>
             list
            </code>
            and returns the number of removed elements.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             unique()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Removes duplicate consecutive elements from a
            <code>
             list
            </code>
            , based on
            <code>
             operator==
            </code>
            or a user-supplied binary predicate, and returns the number of removed elements.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             merge()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Merges two
            <code>
             lists
            </code>
            . Both
            <code>
             list
            </code>
            s must be sorted according to
            <code>
             operator&lt;
            </code>
            or a user-defined comparator. Like
            <code>
             splice()
            </code>
            ,
            <code>
             merge()
            </code>
            is destructive to the
            <code>
             list
            </code>
            passed as an argument.
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             sort()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Performs a stable sort on elements in a
            <code>
             list
            </code>
            .
           </td>
          </tr>
          <tr>
           <td class="left bor1 bgcolor3">
            <code>
             reverse()
            </code>
           </td>
           <td class="left bor1 bgcolor3">
            Reverses the order of the elements in a
            <code>
             list
            </code>
            .
            <span aria-label="713" epub:type="pagebreak" id="Page_713" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
       </section>
      </section>
      <section>
       <span id="c18-sec-0067">
       </span>
       <h4 id="head-4-288">
        list Example: Determining Enrollment
       </h4>
       <p id="c18-para-0184">
        Suppose that you are writing a computer registration system for a university. One feature you might provide is the ability to generate a complete list of enrolled students in the university from lists of the students in each class. For the sake of this example, assume that you must write only a single function that takes a
        <code>
         vector
        </code>
        of
        <code>
         list
        </code>
        s of student names (as
        <code>
         string
        </code>
        s), plus a
        <code>
         list
        </code>
        of students that have been dropped from their courses because they failed to pay tuition. This function should generate a complete
        <code>
         list
        </code>
        of all the students in all the courses, without any duplicates, and without those students who have been dropped. Note that students might be in more than one course.
       </p>
       <p>
        Here is the code for this function, with comments explaining the code. With the power of Standard Library
        <code>
         list
        </code>
        s, the function is practically shorter than its written description! Note that the Standard Library allows you to “nest” containers: in this case, you can use a
        <code>
         vector
        </code>
        of
        <code>
         list
        </code>
        s.
       </p>
       <pre id="c18-code-0064"><code><span class="color3">// courseStudents is a vector of lists, one for each course. The lists</span></code>
<code><span class="color3">// contain the students enrolled in those courses. They are not sorted.</span></code>
<code><span class="color3">//</span></code>
<code><span class="color3">// droppedStudents is a list of students who failed to pay their</span></code>
<code><span class="color3">// tuition and so were dropped from their courses.</span></code>
<code><span class="color3">//</span></code>
<code><span class="color3">// The function returns a list of every enrolled (non-dropped) student in</span></code>
<code><span class="color3">// all the courses.</span></code>
<code>list&lt;string&gt; getTotalEnrollment(const vector 
&lt;list&lt;string&gt;&gt;&amp; courseStudents,</code>
<code>                                const list&lt;string&gt;&amp; droppedStudents)</code>
<code>{</code>
<code>    list&lt;string&gt; allStudents;</code>
<code> </code>
<code>    <span class="color3">// Concatenate all the course lists onto the master list</span></code>
<code>    for (auto&amp; lst : courseStudents) {</code>
<code>        allStudents.append_range(lst);</code>
<code>    }</code>
<code> </code>
<code>    <span class="color3">// Sort the master list</span></code>
<code>    allStudents.sort();</code>
<code> </code>
<code>    <span class="color3">// Remove duplicate student names (those who are in multiple courses).</span></code>
<code>    allStudents.unique();</code>
<code> </code>
<code>    <span class="color3">// Remove students who are on the dropped list.</span></code>
<code>    <span class="color3">// Iterate through the dropped list, calling remove on the</span></code>
<code>    <span class="color3">// master list for each student in the dropped list.</span></code>
<code>    for (auto&amp; str : droppedStudents) {</code>
<code>        allStudents.remove(str);</code>
<code>    }</code>
<code> </code>
<code>    <span class="color3">// done!</span></code>
<code>    return allStudents;</code>
<code>}</code></pre>
       <span aria-label="714" epub:type="pagebreak" id="Page_714" role="doc-pagebreak">
       </span>
       <span aria-label="715" epub:type="pagebreak" id="Page_715" role="doc-pagebreak">
       </span>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0187">
           <b>
            NOTE
           </b>
           <i>
            This example demonstrates the use of the
           </i>
           <code>
            list
           </code>
           <i>
            -specific algorithms. As stated several times before, often a
           </i>
           <code>
            vector
           </code>
           <i>
            is faster than a
           </i>
           <code>
            list
           </code>
           <i>
            . So, the recommended solution to the student enrollment problem would be to only use
           </i>
           <code>
            vector
           </code>
           <i>
            s and to combine these with generic Standard Library algorithms, but those are discussed in
            <a href="c20.xhtml">
             Chapter 20
            </a>
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section>
      <span id="c18-sec-0069">
      </span>
      <h3 id="head-3-404">
       forward_list
      </h3>
      <p id="c18-para-0188">
       A
       <code>
        forward_list
       </code>
       , defined in
       <code>
        &lt;forward_list&gt;
       </code>
       , is similar to a
       <code>
        list
       </code>
       except that it is a singly linked list, while
       <code>
        list
       </code>
       is a doubly linked list. This means that
       <code>
        forward_list
       </code>
       supports only forward iteration, and because of this, ranges need to be specified differently compared to a
       <code>
        list
       </code>
       . If you want to modify any list, you need access to the element before the first element of interest. Because a
       <code>
        forward_list
       </code>
       does not have an iterator that supports going backward, there is no easy way to get to the preceding element. For this reason, ranges that will be modified—for example, ranges supplied to
       <code>
        erase()
       </code>
       and
       <code>
        splice()
       </code>
       —must be open at the beginning. The
       <code>
        begin()
       </code>
       function that was discussed earlier returns an iterator to the first element and thus can only be used to construct a range that is closed at the beginning. The
       <code>
        forward_list
       </code>
       class therefore provides a
       <code>
        before_begin()
       </code>
       member function, which returns an iterator that points to an imaginary element before the beginning of the list. You cannot dereference this iterator as it points to invalid data. However, incrementing this iterator by 1 makes it the same as the iterator returned by
       <code>
        begin()
       </code>
       ; as a result, it can be used to make a range that is open at the beginning.
      </p>
      <p id="c18-para-0189">
       Constructors and assignment operators are similar between a
       <code>
        list
       </code>
       and a
       <code>
        forward_list
       </code>
       . The C++ standard requires that
       <code>
        forward_list
       </code>
       minimizes its memory use. That's the reason why there is no
       <code>
        size()
       </code>
       member function, because by not providing it, there is no need to store the size of the list. Additionally, a
       <code>
        list
       </code>
       has to store a pointer to the previous and the next element in the list, while a
       <code>
        forward_list
       </code>
       only needs to store a pointer to the next element, further reducing memory use. For example, each element in a
       <code>
        list&lt;int&gt;
       </code>
       on a 64-bit system requires 20 bytes (two 64-bit pointers, 16 bytes, and the
       <code>
        int
       </code>
       itself, 4 bytes). A
       <code>
        forward_list&lt;int&gt;
       </code>
       requires only 12 bytes (one 64-bit pointer, 8 bytes, and the
       <code>
        int
       </code>
       , 4 bytes) per element.
      </p>
      <p id="c18-para-0190">
       The following table sums up the differences between a
       <code>
        list
       </code>
       and a
       <code>
        forward_list
       </code>
       . A filled box (
       <img alt="" role="presentation" src="../images\images/square1.png"/>
       ) means the container supports that operation, while an empty box (
       <img alt="" role="presentation" src="../images\images/square.png"/>
       ) means the operation is not supported.
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          OPERATION
         </th>
         <th class="left bgcolor2" scope="col">
          list
         </th>
         <th class="left bgcolor2" scope="col">
          forward_list
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left">
          <span class="forecolor1">
           append_range()
          </span>
          (C++23)
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           assign()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           assign_range()
          </span>
          (C++23)
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           back()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           before_begin()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           begin()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           cbefore_begin()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           cbegin()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           cend()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           clear()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           crbegin()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           crend()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           emplace()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           emplace:after()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           emplace:back()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           emplace:front()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           empty()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           end()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           erase()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           erase_after()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           front()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           insert()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           insert_after()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           insert_range()
          </span>
          (C++23)
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           insert_range_after()
          </span>
          (C++23)
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           iterator / const_iterator
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           max_size()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           merge()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           pop_back()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           pop_front()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           prepend_range()
          </span>
          (C++23)
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           push_back()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           push_front()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           rbegin()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           remove()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           remove_if()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           rend()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           resize()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           reverse()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           reverse_iterator / const_reverse_iterator
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           size()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           sort()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           splice()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           splice:after()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           swap()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
        </tr>
        <tr>
         <td class="left">
          <span class="forecolor1">
           unique()
          </span>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
         </td>
         <td class="left bgcolor3">
          <img alt="" role="presentation" src="../images\images/square1.png"/>
          <span aria-label="716" epub:type="pagebreak" id="Page_716" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       The following example demonstrates the use of
       <code>
        forward_list
       </code>
       s:
      </p>
      <pre id="c18-code-0065"><code><span class="color3">// Create 3 forward lists using an initializer_list</span></code>
<code><span class="color3">// to initialize their elements (uniform initialization).</span></code>
<code>forward_list&lt;int&gt; list1 { 5, 6 };</code>
<code>forward_list list2 { 1, 2, 3, 4 };  <span class="color3">// CTAD is supported.</span></code>
<code>forward_list list3 { 7, 8, 9 };</code>
<code> </code>
<code><span class="color3">// Insert list2 at the front of list1 using splice.</span></code>
<code>list1.splice:after(list1.before_begin(), list2);</code>
<code> </code>
<code><span class="color3">// Add number 0 at the beginning of the list1.</span></code>
<code>list1.push_front(0);</code>
<code> </code>
<code><span class="color3">// Insert list3 at the end of list1.</span></code>
<code><span class="color3">// For this, we first need an iterator to the last element.</span></code>
<code>auto iter { list1.before_begin() };</code>
<code>auto iterTemp { iter };</code>
<code>while (++iterTemp != end(list1)) { ++iter; }</code>
<code>list1.insert_after(iter, cbegin(list3), cend(list3));</code>
<code> </code>
<code><span class="color3">// Output the contents of list1.</span></code>
<code>println("{:n}", list1);</code></pre>
      <p>
       <span aria-label="717" epub:type="pagebreak" id="Page_717" role="doc-pagebreak">
       </span>
       To insert
       <code>
        list3
       </code>
       at the end of
       <code>
        list1
       </code>
       , you need an iterator to the last element of
       <code>
        list1
       </code>
       . However, because this is a
       <code>
        forward_list
       </code>
       , you cannot use
       <code>
        --end(list1)
       </code>
       , so you need to iterate over the list from the beginning and stop at the last element. The output is as follows:
      </p>
      <pre id="c18-code-0066"><code>0, 1, 2, 3, 4, 5, 6, 7, 8, 9</code></pre>
     </section>
     <section>
      <span id="c18-sec-0070">
      </span>
      <h3 id="head-3-405">
       array
      </h3>
      <p id="c18-para-0194">
       An
       <code>
        array
       </code>
       , defined in
       <code>
        &lt;array&gt;
       </code>
       , is similar to a
       <code>
        vector
       </code>
       except that it is of a fixed size; it cannot grow or shrink in size. The purpose of a fixed size is to allow an
       <code>
        array
       </code>
       to be allocated on the stack, rather than always demanding access to the free store as
       <code>
        vector
       </code>
       does.
      </p>
      <p id="c18-para-0195">
       For
       <code>
        array
       </code>
       s containing primitive types (integers, floating-point numbers, characters, Booleans, and so on), initialization of elements is different compared to how they are initialized for containers such as
       <code>
        vector
       </code>
       ,
       <code>
        list
       </code>
       , and so on. If no initialization values are given to an
       <code>
        array
       </code>
       when it is created, then the
       <code>
        array
       </code>
       elements will be uninitialized, i.e., contain garbage. For other containers, such as
       <code>
        vector
       </code>
       and
       <code>
        list
       </code>
       , elements are always initialized, either with given values or using zero initialization. As such,
       <code>
        array
       </code>
       s behave virtually identical to C-style arrays.
      </p>
      <p>
       Just like
       <code>
        vector
       </code>
       s,
       <code>
        array
       </code>
       s support random-access iterators, and elements are stored in contiguous memory. An
       <code>
        array
       </code>
       has support for
       <code>
        front()
       </code>
       ,
       <code>
        back()
       </code>
       ,
       <code>
        at()
       </code>
       , and
       <code>
        operator[]
       </code>
       . It also supports a
       <code>
        fill()
       </code>
       member function to fill the
       <code>
        array
       </code>
       with a specific element. Because it is fixed in size, it does not support
       <code>
        push_back()
       </code>
       ,
       <code>
        pop_back()
       </code>
       ,
       <code>
        insert()
       </code>
       ,
       <code>
        erase()
       </code>
       ,
       <code>
        clear()
       </code>
       ,
       <code>
        resize()
       </code>
       ,
       <code>
        reserve()
       </code>
       ,
       <code>
        capacity()
       </code>
       , or any of the range-based member functions. A disadvantage compared to a
       <code>
        vector
       </code>
       is that the
       <code>
        swap()
       </code>
       member function of an
       <code>
        array
       </code>
       runs in linear time, while it has constant complexity for a
       <code>
        vector
       </code>
       . An
       <code>
        array
       </code>
       can also not be moved in constant time, while a
       <code>
        vector
       </code>
       can. An
       <code>
        array
       </code>
       has a
       <code>
        size()
       </code>
       member function, which is a clear advantage over C-style arrays. The following example demonstrates how to use the
       <code>
        array
       </code>
       class. Note that the
       <code>
        array
       </code>
       declaration requires two template parameters: the first specifies the type of the elements, and the second specifies the fixed number of elements in the
       <code>
        array
       </code>
       .
      </p>
      <pre id="c18-code-0067"><code><span class="color3">// Create an array of 3 integers and initialize them</span></code>
<code><span class="color3">// with the given initializer_list using uniform initialization.</span></code>
<code>array&lt;int, 3&gt; arr { 9, 8, 7 };</code>
<code><span class="color3">// Output the size of the array.</span></code>
<code>println("Array size = {}", arr.size()); <span class="color3">// or std::size(arr)</span></code>
<code><span class="color3">// Output the contents using C++23's support for formatting ranges.</span></code>
<code>println("{:n}", arr);</code>
<code><span class="color3">// Output the contents again using a range-based for loop.</span></code>
<code>for (const auto&amp; i : arr) { print("{} ", i); }</code>
<code>println("");</code>
<code> </code>
<code>println("Performing arr.fill(3)…");</code>
<code><span class="color3">// Use the fill member function to change the contents of the array.</span></code>
<code>arr.fill(3);</code>
<code><span class="color3">// Output the contents of the array using iterators.</span></code>
<code>for (auto iter { cbegin(arr) }; iter != cend(arr); ++iter) {</code>
<code>    print("{} ", *iter);</code>
<code>}</code></pre>
      <p>
       <span aria-label="718" epub:type="pagebreak" id="Page_718" role="doc-pagebreak">
       </span>
       The output is as follows:
      </p>
      <pre id="c18-code-0068"><code>Array size = 3</code>
<code>9, 8, 7</code>
<code>9 8 7</code>
<code>Performing arr.fill(3)…</code>
<code>3 3 3</code></pre>
      <p>
       You can use the
       <code>
        std::get&lt;n&gt;()
       </code>
       function template to retrieve an element from an
       <code>
        std::array
       </code>
       at the given index
       <i>
        n
       </i>
       . The index has to be a constant expression, so it cannot, for example, be a loop variable. The benefit of using
       <code>
        std::get&lt;n&gt;()
       </code>
       is that the compiler checks at compile time that the given index is valid; otherwise, it results in a compilation error, as in this example:
      </p>
      <pre id="c18-code-0069"><code>array myArray { 11, 22, 33 };  // std::array supports CTAD.</code>
<code>println("{}", std::get&lt;1&gt;(myArray));</code>
<code>println("{}", std::get&lt;10&gt;(myArray));  <span class="color3">// BUG! Compilation error!</span></code></pre>
      <p>
       <code>
        std::to_array()
       </code>
       , defined in
       <code>
        &lt;array&gt;
       </code>
       , converts a given C-style array to an
       <code>
        std::array
       </code>
       , using copy-initialization of the elements. The function works only for one-dimensional arrays. Here is a quick example:
      </p>
      <pre id="c18-code-0070"><code>auto arr1 { to_array({ 11, 22, 33 }) }; <span class="color3">// Type is array&lt;int, 3&gt;</span></code>
<code> </code>
<code>double carray[] { 9, 8, 7, 6 };</code>
<code>auto arr2 { to_array(carray) };         <span class="color3">// Type is array&lt;double, 4&gt;</span></code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-200">
     <span id="c18-sec-0071">
     </span>
     <h2 id="head-2-200">
      SEQUENTIAL VIEWS
     </h2>
     <p id="c18-para-0200">
      The C++ Standard Library provides two
      <i>
       sequential views
      </i>
      :
      <code>
       std::span
      </code>
      and
      <code>
       std::mdspan
      </code>
      . The latter is new in C++23. A
      <code>
       span
      </code>
      provides a one-dimensional, non-owning view over a contiguous sequence of data. An
      <code>
       mdspan
      </code>
      generalizes this concept and allows the creation of multidimensional, non-owning views over a contiguous sequence of data.
     </p>
     <section>
      <span id="c18-sec-0072">
      </span>
      <h3 id="head-3-406">
       span
      </h3>
      <p>
       Suppose you have this function to print the contents of a
       <code>
        vector
       </code>
       :
      </p>
      <pre id="c18-code-0071"><code>void print(const vector&lt;int&gt;&amp; values)</code>
<code>{</code>
<code>    for (const auto&amp; value : values) { print("{} ", value); }</code>
<code>    println("");</code>
<code>}</code></pre>
      <p>
       Suppose further that you also want to print the contents of C-style arrays. One option is to overload the
       <code>
        print()
       </code>
       function to accept a pointer to the first element of the array, and the number of elements to print:
      </p>
      <pre id="c18-code-0072"><code>void print(const int values[], size_t count)</code>
<code>{</code>
<code>    for (size_t i { 0 }; i &lt; count; ++i) { print("{} ", values[i]); }</code>
<code>    println("");</code>
<code>}</code></pre>
      <p id="c18-para-0203">
       <span aria-label="719" epub:type="pagebreak" id="Page_719" role="doc-pagebreak">
       </span>
       If you also want to print
       <code>
        std::array
       </code>
       s, you could provide a third overload, but what would the function parameter type be? For an
       <code>
        std::array
       </code>
       , you have to specify the type and the number of elements in the
       <code>
        array
       </code>
       as template parameters. You see, it's getting complicated.
      </p>
      <p>
       <code>
        std::span
       </code>
       , defined in
       <code>
        &lt;span&gt;
       </code>
       , comes to the rescue here, as it allows you to write a single function that works with
       <code>
        vector
       </code>
       s, C-style arrays, and
       <code>
        std::array
       </code>
       s of any size. Here is a single implementation of
       <code>
        print()
       </code>
       using
       <code>
        span
       </code>
       :
      </p>
      <pre id="c18-code-0073"><code>void print(span&lt;int&gt; values)</code>
<code>{</code>
<code>    for (const auto&amp; value : values) { print("{} ", value); }</code>
<code>    println("");</code>
<code>}</code></pre>
      <p id="c18-para-0205">
       Note that, just as with
       <code>
        string_view
       </code>
       from
       <a href="c02.xhtml">
        Chapter 2
       </a>
       , a
       <code>
        span
       </code>
       is cheap to copy; it basically just contains a pointer to the first element in a sequence and a number of elements. A
       <code>
        span
       </code>
       never copies data! As such, it is usually passed by value.
      </p>
      <p id="c18-para-0206">
       There are several constructors for creating a
       <code>
        span
       </code>
       . For example, one can be created to include all elements of a given
       <code>
        vector
       </code>
       ,
       <code>
        std::array
       </code>
       , or C-style array. A
       <code>
        span
       </code>
       can also be created to include only part of a container, by passing the address of the first element and the number of elements you want to include in the
       <code>
        span
       </code>
       .
      </p>
      <p id="c18-para-0207">
       A subview can be created from an existing
       <code>
        span
       </code>
       using the
       <code>
        subspan()
       </code>
       member function. Its first argument is the offset into the
       <code>
        span
       </code>
       , and the second argument is the number of elements to include in the subview. There are also two additional member functions called
       <code>
        first()
       </code>
       and
       <code>
        last()
       </code>
       returning subviews of a
       <code>
        span
       </code>
       containing the first
       <i>
        n
       </i>
       elements or the last
       <i>
        n
       </i>
       elements respectively.
      </p>
      <p id="c18-para-0208">
       A
       <code>
        span
       </code>
       has a couple of member functions that are similar to
       <code>
        vector
       </code>
       and
       <code>
        array
       </code>
       :
       <code>
        begin()
       </code>
       ,
       <code>
        end()
       </code>
       ,
       <code>
        rbegin()
       </code>
       ,
       <code>
        rend()
       </code>
       ,
       <code>
        front()
       </code>
       ,
       <code>
        back()
       </code>
       ,
       <code>
        operator[]
       </code>
       ,
       <code>
        data()
       </code>
       ,
       <code>
        size()
       </code>
       , and
       <code>
        empty()
       </code>
       .
      </p>
      <p>
       The following code snippet demonstrates a few ways to call the
       <code>
        print(span)
       </code>
       function:
      </p>
      <pre id="c18-code-0074"><code>vector v { 11, 22, 33, 44, 55, 66 };</code>
<code><span class="color3">// Pass the whole vector, implicitly converted to a span.</span></code>
<code>print(v);</code>
<code><span class="color3">// Pass an explicitly created span.</span></code>
<code>span mySpan { v };</code>
<code>print(mySpan);</code>
<code><span class="color3">// Create a subview and pass that.</span></code>
<code>span subspan { mySpan.subspan(2, 3) };</code>
<code>print(subspan);</code>
<code><span class="color3">// Pass a subview created in-line.</span></code>
<code>print({ v.data() + 2, 3 });</code>
<code> </code>
<code><span class="color3">// Pass an std::array.</span></code>
<code>array&lt;int, 5&gt; arr { 5, 4, 3, 2, 1 };</code>
<code>print(arr);</code>
<code>print({ arr.data() + 2, 3 });</code>
<code> </code>
<code><span class="color3">// Pass a C-style array.</span></code>
<code>int carr[] { 9, 8, 7, 6, 5 };</code>
<code>print(carr);            <span class="color3">// The entire C-style array.</span></code>
<code>print({ carr + 2, 3 }); <span class="color3">// A subview of the C-style array.</span></code></pre>
      <p>
       <span aria-label="720" epub:type="pagebreak" id="Page_720" role="doc-pagebreak">
       </span>
       The output is as follows:
      </p>
      <pre id="c18-code-0075"><code>11 22 33 44 55 66</code>
<code>11 22 33 44 55 66</code>
<code>33 44 55</code>
<code>33 44 55</code>
<code>5 4 3 2 1</code>
<code>3 2 1</code>
<code>9 8 7 6 5</code>
<code>7 6 5</code></pre>
      <p>
       Unlike
       <code>
        string_view
       </code>
       that provides a read-only view of a
       <code>
        string
       </code>
       , a
       <code>
        span
       </code>
       can provide read/write access to the underlying elements. Remember that a
       <code>
        span
       </code>
       just contains a pointer to the first element in a sequence and the number of elements; that is, a
       <code>
        span
       </code>
       never copies data! As such, modifying an element in a
       <code>
        span
       </code>
       actually modifies the element in the underlying sequence. If this is not desired, a
       <code>
        span
       </code>
       of
       <code>
        const
       </code>
       elements can be created. For example, the
       <code>
        print()
       </code>
       function has no reason to modify any of the elements in a given
       <code>
        span
       </code>
       . We can prevent such modifications as follows:
      </p>
      <pre id="c18-code-0076"><code>void print(span&lt;<b>const int</b>&gt; values)</code>
<code>{</code>
<code>    for (const auto&amp; value : values) { print("{} ", value); }</code>
<code>    println("");</code>
<code>}</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0213">
          <b>
           NOTE
          </b>
          <i>
           When writing a function accepting a
          </i>
          <code>
           const vector&lt;T&gt;&amp;
          </code>
          <i>
           , consider accepting a
          </i>
          <code>
           span&lt;const T&gt;
          </code>
          <i>
           instead, so the function can work with views and subviews of data sequences coming from
           <code>
            vector
           </code>
           s,
           <code>
            array
           </code>
           s, C-style arrays and more. If the function accepts a
          </i>
          <code>
           vector&lt;T&gt;&amp;
          </code>
          <i>
           , consider accepting a
          </i>
          <code>
           span&lt;T&gt;
          </code>
          <i>
           , unless the function needs to add or remove elements from the
          </i>
          <code>
           vector
          </code>
          <i>
           .
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c18-sec-0074">
      </span>
      <h3 id="head-3-407">
       <img alt="C++23" src="../images\images/icon1.png"/>
       mdspan
      </h3>
      <p>
       <code>
        std::mdspan
       </code>
       , defined in
       <code>
        &lt;mdspan&gt;
       </code>
       , is similar to
       <code>
        std::span
       </code>
       but allows you to create multidimensional views over a contiguous sequence of data. Just as
       <code>
        span
       </code>
       , an
       <code>
        mdspan
       </code>
       doesn't own the data, so it is cheap to copy. An
       <code>
        mdspan
       </code>
       has four template type parameters:
      </p>
      <ul class="check1" id="c18-list-0011">
       <li id="c18-li-0057">
        <b>
         <code>
          ElementType
         </code>
         :
        </b>
        The type of the underlying elements.
       </li>
       <li id="c18-li-0058">
        <b>
         <code>
          Extents
         </code>
         :
        </b>
        The number of dimensions and their size, a specialization of
        <code>
         std::extents
        </code>
        .
       </li>
       <li id="c18-li-0059">
        <b>
         <code>
          LayoutPolicy
         </code>
         :
        </b>
        A policy specifying how to convert a multidimensional index to a one-dimensional index into the underlying contiguous sequence of data. You can implement whichever layout policy you need, such as tiled layout, Hilbert curve, and so on. The following standard policies are available:
        <ul class="check1" id="c18-list-0012">
         <li id="c18-li-0060">
          <b>
           <code>
            layout_right
           </code>
           :
          </b>
          Row-major multidimensional array layout, where the rightmost extent has stride 1. This is the default policy.
         </li>
         <li id="c18-li-0061">
          <span aria-label="721" epub:type="pagebreak" id="Page_721" role="doc-pagebreak">
          </span>
          <b>
           <code>
            layout_left
           </code>
           :
          </b>
          Column-major multidimensional array layout, where the leftmost extent has stride 1.
         </li>
         <li id="c18-li-0062">
          <b>
           <code>
            layout_stride
           </code>
           :
          </b>
          A layout mapping with user-defined strides.
         </li>
        </ul>
       </li>
       <li id="c18-li-0063">
        <b>
         <code>
          AccessorPolicy
         </code>
         :
        </b>
        A policy specifying how to convert the one-dimensional index into the underlying contiguous sequence of data into a reference to the actual element at that location. The default is
        <code>
         std::default_accessor
        </code>
        .
       </li>
      </ul>
      <p>
       There are numerous constructors available. One of them is a constructor accepting a pointer to the contiguous sequence of data as the first parameter, followed by one or more dimension extents. Such extents passed as constructor arguments are called
       <i>
        dynamic extents
       </i>
       . Data can be accessed using a multidimensional
       <code>
        operator[]
       </code>
       . The
       <code>
        size()
       </code>
       member function returns the number of elements in an
       <code>
        mdspan
       </code>
       , and
       <code>
        empty()
       </code>
       returns
       <code>
        true
       </code>
       if an
       <code>
        mdspan
       </code>
       is empty. The
       <code>
        stride(n)
       </code>
       member function can be used to query the stride of dimension
       <code>
        n
       </code>
       . The size of the dimensions can be queried using the
       <code>
        extents()
       </code>
       member function. It returns an
       <code>
        std::extents
       </code>
       instance on which you can call
       <code>
        extent(n)
       </code>
       to query the size of dimension
       <code>
        n
       </code>
       . Here is an example:
      </p>
      <pre id="c18-code-0077"><code>template &lt;typename T&gt; void print2Dmdspan(const T&amp; mdSpan)</code>
<code>{</code>
<code>    for (size_t i { 0 }; i &lt; mdSpan.extents().extent(0); ++i) {</code>
<code>        for (size_t j { 0 }; j &lt; mdSpan.extents().extent(1); ++j) {</code>
<code>             print("{} ", mdSpan[i, j]);</code>
<code>        }</code>
<code>        println("");</code>
<code>    }</code>
<code>}</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    vector data { 1, 2, 3, 4, 5, 6, 7, 8 };</code>
<code>    <span class="color3">// View data as a 2D array of 2 rows with 4 integers each,</span></code>
<code>    <span class="color3">// using the default row-major layout policy.</span></code>
<code>    mdspan data2D { data.data(), 2, 4 };</code>
<code>    print2Dmdspan(data2D);</code>
<code>}</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c18-code-0078"><code>1 2 3 4</code>
<code>5 6 7 8</code></pre>
      <p>
       This code uses the default row-major layout policy. The following code snippet uses the column-major layout policy instead. Because the layout policy is the third template type parameter, you have to specify the first and second template type parameters as well. Instead of passing the size of each dimension as an argument to the constructor, the code now passes an
       <code>
        std::extents
       </code>
       as the second template type parameter:
      </p>
      <pre id="c18-code-0079"><code>mdspan&lt;int, extents&lt;int, 2, 4&gt;, layout_left&gt; data2D { data.data() };</code></pre>
      <p>
       The output now is as follows:
      </p>
      <pre id="c18-code-0080"><code>1 3 5 7</code>
<code>2 4 6 8</code></pre>
      <p>
       <span aria-label="722" epub:type="pagebreak" id="Page_722" role="doc-pagebreak">
       </span>
       This
       <code>
        mdspan
       </code>
       definition specifies the extent of all dimensions as compile-time constants, i.e.,
       <i>
        static extents
       </i>
       . It is also possible to combine static and dynamic extents. The following example specifies the first dimension as a compile-time constant, and the second as a dynamic extent. You then must pass the size of all dynamic extents as arguments to the constructor.
      </p>
      <pre id="c18-code-0081"><code>mdspan&lt;int, extents&lt;int, 2, dynamic_extent&gt;&gt; data2D { data.data(), 4 };</code></pre>
      <p>
       The output is again as follows:
      </p>
      <pre id="c18-code-0082"><code>1 2 3 4</code>
<code>5 6 7 8</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-201">
     <span id="c18-sec-0075">
     </span>
     <h2 id="head-2-201">
      CONTAINER ADAPTERS
     </h2>
     <p id="c18-para-0223">
      In addition to the standard sequential containers, the Standard Library provides three
      <i>
       container adapters
      </i>
      :
      <code>
       queue
      </code>
      ,
      <code>
       priority_queue
      </code>
      , and
      <code>
       stack
      </code>
      . Each of these adapters is a wrapper around one of the sequential containers. They allow you to swap the underlying container without having to change the rest of the code. The intent of the adapters is to simplify the interface and to provide only those features that are appropriate for the
      <code>
       stack
      </code>
      ,
      <code>
       queue
      </code>
      , or
      <code>
       priority_queue
      </code>
      abstraction. These adapters do not provide access to the underlying container and hence are a perfect example of the data-hiding principle explained in
      <a href="c04.xhtml">
       Chapter 4
      </a>
      , “Designing Professional C++ Programs.” For instance, the adapters don't provide the capability to erase multiple elements simultaneously, nor do they provide iterators. The latter means you cannot use them with range-based
      <code>
       for
      </code>
      loops or with any of the standard iterator-based algorithms discussed in
      <a href="c20.xhtml">
       Chapter 20
      </a>
      . However, starting with C++23, the
      <code>
       std::format()
      </code>
      and
      <code>
       print()
      </code>
      functions do support formatting and printing the contents of these container adapters.
     </p>
     <section>
      <span id="c18-sec-0076">
      </span>
      <h3 id="head-3-408">
       queue
      </h3>
      <p>
       The
       <code>
        queue
       </code>
       container adapter, defined in
       <code>
        &lt;queue&gt;
       </code>
       , provides standard first-in, first-out semantics. As usual, it's written as a class template, which looks like this:
      </p>
      <pre id="c18-code-0083"><code>template &lt;typename T, typename Container = deque&lt;T&gt;&gt; class queue;</code></pre>
      <p id="c18-para-0225">
       The
       <code>
        T
       </code>
       template parameter specifies the type that you intend to store in the
       <code>
        queue
       </code>
       . The second template parameter allows you to stipulate the underlying container that the
       <code>
        queue
       </code>
       adapts. However, the
       <code>
        queue
       </code>
       requires the sequential container to support both
       <code>
        push_back()
       </code>
       and
       <code>
        pop_front()
       </code>
       , so you have only two built-in choices:
       <code>
        deque
       </code>
       and
       <code>
        list
       </code>
       . For most purposes, you can just stick with the default
       <code>
        deque
       </code>
       .
      </p>
      <section>
       <span id="c18-sec-0077">
       </span>
       <h4 id="head-4-289">
        queue Operations
       </h4>
       <p>
        The
        <code>
         queue
        </code>
        interface is extremely simple: there are only nine member functions, a set of constructors, and comparison operators. New in C++23 is a constructor accepting an iterator pair, [begin, end), which constructs a
        <code>
         queue
        </code>
        containing the elements from the given iterator range. The
        <code>
         push()
        </code>
        and
        <code>
         emplace()
        </code>
        member functions add a new element to the tail of the queue, while
        <code>
         pop()
        </code>
        removes the element at the head of the queue. C++23 adds
        <code>
         push_range()
        </code>
        to add a range of elements to the
        <code>
         queue
        </code>
        . You can retrieve references to, without removing, the first and last elements with
        <code>
         front()
        </code>
        and
        <code>
         back()
        </code>
        , respectively. As usual, when called on
        <code>
         const
        </code>
        objects,
        <code>
         front()
        </code>
        and
        <code>
         back()
        </code>
        return
        <span aria-label="723" epub:type="pagebreak" id="Page_723" role="doc-pagebreak">
        </span>
        references-to-
        <code>
         const
        </code>
        ; and when called on non-
        <code>
         const
        </code>
        objects, they return references-to-non-
        <code>
         const
        </code>
        (read/write).
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0227">
           <b>
            WARNING
           </b>
           <code>
            pop()
           </code>
           <i>
            does not return the element popped. If you want to retain a copy, you must first retrieve it with
           </i>
           <code>
            front()
           </code>
           <i>
            .
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c18-para-0228">
        The queue also supports
        <code>
         size()
        </code>
        ,
        <code>
         empty()
        </code>
        , and
        <code>
         swap()
        </code>
        .
       </p>
      </section>
      <section>
       <span id="c18-sec-0079">
       </span>
       <h4 id="head-4-290">
        queue Example: A Network Packet Buffer
       </h4>
       <p>
        When two computers communicate over a network, they send information to each other divided into discrete chunks called
        <i>
         packets
        </i>
        . The networking layer of the computer's operating system must pick up the packets and store them as they arrive. However, the computer might not have enough bandwidth to process all of them at once. Thus, the networking layer usually
        <i>
         buffers
        </i>
        , or stores, the packets until the higher layers have a chance to attend to them. The packets should be processed in the order they arrive, so this problem is perfect for a
        <code>
         queue
        </code>
        structure. The following is a small
        <code>
         PacketBuffer
        </code>
        class, with comments explaining the code, which stores incoming packets in a
        <code>
         queue
        </code>
        until they are processed. It's a class template so that different layers of the networking stack can use it for different kinds of packets, such as IP packets or TCP packets. It allows the client to specify a maximum size because operating systems usually limit the number of packets that can be stored, so as not to use too much memory. When the buffer is full, subsequently arriving packets are ignored.
       </p>
       <pre id="c18-code-0084"><code>export template &lt;typename T&gt;</code>
<code>class PacketBuffer final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// If maxSize is 0, the size is unlimited, because creating</span></code>
<code>        <span class="color3">// a buffer of size 0 makes little sense. Otherwise only</span></code>
<code>        <span class="color3">// maxSize packets are allowed in the buffer at any one time.</span></code>
<code>        explicit PacketBuffer(std::size_t maxSize = 0);</code>
<code> </code>
<code>        <span class="color3">// Stores a packet in the buffer.</span></code>
<code>        <span class="color3">// Returns false if the packet has been discarded because</span></code>
<code>        <span class="color3">// there is no more space in the buffer, true otherwise.</span></code>
<code>        bool bufferPacket(const T&amp; packet);</code>
<code> </code>
<code>        <span class="color3">// Returns the next packet. Throws out_of_range</span></code>
<code>        <span class="color3">// if the buffer is empty.</span></code>
<code>        [[nodiscard]] T getNextPacket();</code>
<code>    private:</code>
<code>        std::queue&lt;T&gt; m_packets;</code>
<code>        std::size_t m_maxSize;</code>
<code>};</code>
<code> </code>
<code>template &lt;typename T&gt; PacketBuffer&lt;T&gt;::PacketBuffer(std::size_t maxSize<span class="color3">/*= 0*/</span>)</code>
<code>    : m_maxSize { maxSize }</code>
<code>{</code>
<code>}</code>
<code> </code>
<span aria-label="724" epub:type="pagebreak" id="Page_724" role="doc-pagebreak"></span><code>template &lt;typename T&gt; bool PacketBuffer&lt;T&gt;::bufferPacket(const T&amp; packet)</code>
<code>{</code>
<code>    if (m_maxSize &gt; 0 &amp;&amp; m_packets.size() == m_maxSize) {</code>
<code>        <span class="color3">// No more space. Drop the packet.</span></code>
<code>        return false;</code>
<code>    }</code>
<code>    m_packets.push(packet);</code>
<code>    return true;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; T PacketBuffer&lt;T&gt;::getNextPacket()</code>
<code>{</code>
<code>    if (m_packets.empty()) {</code>
<code>        throw std::out_of_range { "Buffer is empty" };</code>
<code>    }</code>
<code>    <span class="color3">// Retrieve the head element</span></code>
<code>    T temp { m_packets.front() };</code>
<code>    <span class="color3">// Pop the head element</span></code>
<code>    m_packets.pop();</code>
<code>    <span class="color3">// Return the head element</span></code>
<code>    return temp;</code>
<code>}</code></pre>
       <p>
        A practical application of this class would require multiple threads. However, without explicit synchronization, no Standard Library object can be used safely from multiple threads when at least one of the threads modifies the object. C++ provides synchronization classes to allow thread-safe access to shared objects. This is discussed in
        <a href="c27.xhtml">
         Chapter 27
        </a>
        , “Multithreaded Programming with C++.” The focus in this example is on the
        <code>
         queue
        </code>
        class, so here is a single-threaded example of using the
        <code>
         PacketBuffer
        </code>
        :
       </p>
       <pre id="c18-code-0085"><code>class IPPacket final</code>
<code>{</code>
<code>    public:</code>
<code>        explicit IPPacket(int id) : m_id { id } {}</code>
<code>        int getID() const { return m_id; }</code>
<code>    private:</code>
<code>        int m_id;</code>
<code>};</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    PacketBuffer&lt;IPPacket&gt; ipPackets { 3 };</code>
<code> </code>
<code>    <span class="color3">// Add 4 packets</span></code>
<code>    for (int i { 1 }; i &lt;= 4; ++i) {</code>
<code>        if (!ipPackets.bufferPacket(IPPacket { i })) {</code>
<code>            println("Packet {} dropped (queue is full).", i);</code>
<code>        }</code>
<code>    }</code>
<code> </code>
<code>    while (true) {</code>
<code>        try {</code>
<code>            IPPacket packet { ipPackets.getNextPacket() };</code>
<code>            println("Processing packet {}", packet.getID());</code>
<code>        } catch (const out_of_range&amp;) {</code>
<span aria-label="725" epub:type="pagebreak" id="Page_725" role="doc-pagebreak"></span><code>            println("Queue is empty.");</code>
<code>            break;</code>
<code>        }</code>
<code>    }</code>
<code>}</code></pre>
       <p>
        The output of this program is as follows:
       </p>
       <pre id="c18-code-0086"><code>Packet 4 dropped (queue is full).</code>
<code>Processing packet 1</code>
<code>Processing packet 2</code>
<code>Processing packet 3</code>
<code>Queue is empty.</code></pre>
      </section>
     </section>
     <section>
      <span id="c18-sec-0080">
      </span>
      <h3 id="head-3-409">
       priority_queue
      </h3>
      <p id="c18-para-0232">
       A
       <i>
        priority queue
       </i>
       is a queue that keeps its elements in sorted order. Instead of a strict FIFO ordering, the element at the head of the queue at any given time is the one with the highest priority. This element could be the oldest on the queue or the most recent. If two elements have equal priority, their relative order in the queue is undefined.
      </p>
      <p>
       The
       <code>
        priority_queue
       </code>
       container adapter is also defined in
       <code>
        &lt;queue&gt;
       </code>
       . Its template definition looks something like this (slightly simplified):
      </p>
      <pre id="c18-code-0087"><code>template &lt;typename T, typename Container = vector&lt;T&gt;,</code>
<code>          typename Compare = less&lt;T&gt;&gt;;</code></pre>
      <p>
       It's not as complicated as it looks. You've seen the first two parameters before:
       <code>
        T
       </code>
       is the element type stored in the
       <code>
        priority_queue
       </code>
       , and
       <code>
        Container
       </code>
       is the underlying container on which the
       <code>
        priority_queue
       </code>
       is adapted. The
       <code>
        priority_queue
       </code>
       uses
       <code>
        vector
       </code>
       as the default, but
       <code>
        deque
       </code>
       works as well.
       <code>
        list
       </code>
       does not work because the
       <code>
        priority_queue
       </code>
       requires random access to its elements. The third parameter,
       <code>
        Compare
       </code>
       , is trickier. As you'll learn more about in
       <a href="c19.xhtml">
        Chapter 19
       </a>
       ,
       <code>
        less
       </code>
       is a class template that supports comparison of two objects of type
       <code>
        T
       </code>
       with
       <code>
        operator&lt;
       </code>
       . This means the priority of elements in a
       <code>
        priority_queue
       </code>
       is determined according to
       <code>
        operator&lt;
       </code>
       . You can customize the comparison used, but that's a topic for
       <a href="c19.xhtml">
        Chapter 19
       </a>
       . For now, just make sure the types stored in a
       <code>
        priority_queue
       </code>
       support
       <code>
        operator&lt;
       </code>
       . Of course, since C++20 it's enough to provide
       <code>
        operator&lt;=&gt;
       </code>
       which then automatically provides
       <code>
        operator&lt;
       </code>
       .
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0235">
          <b>
           NOTE
          </b>
          <i>
           The head element of a
          </i>
          <code>
           priority_queue
          </code>
          <i>
           is the one with the “highest” priority; by default, this is determined according to
          </i>
          <code>
           operator&lt;
          </code>
          <i>
           such that elements that are “less” than other elements have lower priority.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <section>
       <span id="c18-sec-0082">
       </span>
       <h4 id="head-4-291">
        priority_queue Operations
       </h4>
       <p>
        A
        <code>
         priority_queue
        </code>
        provides even fewer operations than does a
        <code>
         queue
        </code>
        . The
        <code>
         push()
        </code>
        ,
        <code>
         emplace()
        </code>
        , and
        <code>
         push_range()
        </code>
        (C++23) member functions allow you to insert elements,
        <code>
         pop()
        </code>
        allows you to remove elements, and
        <code>
         top()
        </code>
        returns a reference-to-
        <code>
         const
        </code>
        to the head element.
        <span aria-label="726" epub:type="pagebreak" id="Page_726" role="doc-pagebreak">
        </span>
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0237">
           <b>
            WARNING
           </b>
           <code>
            top()
           </code>
           <i>
            returns a reference-to-
           </i>
           <code>
            const
           </code>
           <i>
            even when called on a non-
           </i>
           <code>
            const
           </code>
           <i>
            object, because modifying the element might change its order, which is not allowed. A
           </i>
           <code>
            priority_queue
           </code>
           <i>
            provides no mechanism to obtain the tail element.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0238">
           <b>
            WARNING
           </b>
           <code>
            pop()
           </code>
           <i>
            does not return the element popped. If you want to retain a copy, you must first retrieve it with
           </i>
           <code>
            top()
           </code>
           <i>
            .
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c18-para-0239">
        Like a
        <code>
         queue
        </code>
        , a
        <code>
         priority_queue
        </code>
        supports
        <code>
         size()
        </code>
        ,
        <code>
         empty()
        </code>
        , and
        <code>
         swap()
        </code>
        . However, it does not provide any comparison operators.
       </p>
      </section>
      <section>
       <span id="c18-sec-0085">
       </span>
       <h4 id="head-4-292">
        priority_queue Example: An Error Correlator
       </h4>
       <p>
        Single failures on a system can often cause multiple errors to be generated from different components. A good error-handling system uses
        <i>
         error correlation
        </i>
        to process the most important errors first. You can use a
        <code>
         priority_queue
        </code>
        to write a simple error correlator. Assume all error events encode their own priority. The error correlator simply sorts error events according to their priority so that the highest-priority errors are always processed first. Here are the class definitions:
       </p>
       <pre id="c18-code-0088"><code><span class="color3">// Sample Error class with just a priority and a string error description.</span></code>
<code>export class Error final</code>
<code>{</code>
<code>    public:</code>
<code>        explicit Error(int priority, std::string errorString)</code>
<code>            : m_priority { priority }, m_errorString { std::move(errorString) } { }</code>
<code>        int getPriority() const { return m_priority; }</code>
<code>        const std::string&amp; getErrorString() const { return m_errorString; }</code>
<code>        <span class="color3">// Compare Errors according to their priority.</span></code>
<code>        auto operator&lt;=&gt;(const Error&amp; rhs) const {</code>
<code>            return getPriority() &lt;=&gt; rhs.getPriority(); }</code>
<code>    private:</code>
<code>        int m_priority;</code>
<code>        std::string m_errorString;</code>
<code>};</code>
<code> </code>
<code><span class="color3">// Stream insertion overload for Errors.</span></code>
<code>export std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Error&amp; err)</code>
<code>{</code>
<code>    std::print(os, "{} (priority {})", err.getErrorString(), err.getPriority());</code>
<code>    return os;</code>
<code>}</code>
<code> </code>
<code><span class="color3">// Simple ErrorCorrelator class that returns highest priority errors first.</span></code>
<code>export class ErrorCorrelator final</code>
<code>{</code>
<code>    public:</code>
<span aria-label="727" epub:type="pagebreak" id="Page_727" role="doc-pagebreak"></span><code>        <span class="color3">// Add an error to be correlated.</span></code>
<code>        void addError(const Error&amp; error) { m_errors.push(error); }</code>
<code>        <span class="color3">// Retrieve the next error to be processed.</span></code>
<code>        [[nodiscard]] Error getError()</code>
<code>        {</code>
<code>            <span class="color3">// If there are no more errors, throw an exception.</span></code>
<code>            if (m_errors.empty()) {</code>
<code>                throw std::out_of_range { "No more errors." };</code>
<code>            }</code>
<code>            <span class="color3">// Save the top element.</span></code>
<code>            Error top { m_errors.top() };</code>
<code>            <span class="color3">// Remove the top element.</span></code>
<code>            m_errors.pop();</code>
<code>            <span class="color3">// Return the saved element.</span></code>
<code>            return top;</code>
<code>        }</code>
<code>    private:</code>
<code>        std::priority_queue&lt;Error&gt; m_errors;</code>
<code>};</code></pre>
       <p>
        Here is a simple test showing how to use the
        <code>
         ErrorCorrelator
        </code>
        . Realistic use would require multiple threads so that one thread adds errors, while another processes them. As mentioned earlier with the
        <code>
         queue
        </code>
        example, this requires explicit synchronization, which is discussed in
        <a href="c27.xhtml">
         Chapter 27
        </a>
        .
       </p>
       <pre id="c18-code-0089"><code>ErrorCorrelator ec;</code>
<code>ec.addError(Error { 3, "Unable to read file" });</code>
<code>ec.addError(Error { 1, "Incorrect entry from user" });</code>
<code>ec.addError(Error { 10, "Unable to allocate memory!" });</code>
<code> </code>
<code>while (true) {</code>
<code>    try {</code>
<code>        Error e { ec.getError() };</code>
<code>        cout &lt;&lt; e &lt;&lt; endl;</code>
<code>    } catch (const out_of_range&amp;) {</code>
<code>        println("Finished processing errors");</code>
<code>        break;</code>
<code>    }</code>
<code>}</code></pre>
       <p>
        The output of this program is as follows:
       </p>
       <pre id="c18-code-0090"><code>Unable to allocate memory! (priority 10)</code>
<code>Unable to read file (priority 3)</code>
<code>Incorrect entry from user (priority 1)</code>
<code>Finished processing errors</code></pre>
      </section>
     </section>
     <section>
      <span id="c18-sec-0086">
      </span>
      <h3 id="head-3-410">
       stack
      </h3>
      <p>
       A
       <code>
        stack
       </code>
       is almost identical to a
       <code>
        queue
       </code>
       , except that it provides
       <i>
        first-in, last-out
       </i>
       (FILO) semantics, also known as
       <i>
        last-in, first-out
       </i>
       (LIFO), instead of FIFO. It is defined in
       <code>
        &lt;stack&gt;
       </code>
       . The template definition looks like this:
      </p>
      <pre id="c18-code-0091"><code>template &lt;typename T, typename Container = deque&lt;T&gt;&gt; class stack;</code></pre>
      <p id="c18-para-0244">
       You can use
       <code>
        vector
       </code>
       ,
       <code>
        list
       </code>
       , or
       <code>
        deque
       </code>
       as the underlying container for the
       <code>
        stack
       </code>
       .
      </p>
      <span aria-label="728" epub:type="pagebreak" id="Page_728" role="doc-pagebreak">
      </span>
      <section>
       <span id="c18-sec-0087">
       </span>
       <h4 id="head-4-293">
        stack Operations
       </h4>
       <p>
        Just as for
        <code>
         queue
        </code>
        , C++23 adds a constructor accepting an iterator pair, [begin, end), which constructs a
        <code>
         stack
        </code>
        containing the elements from the given iterator range. Also like
        <code>
         queue
        </code>
        ,
        <code>
         stack
        </code>
        provides
        <code>
         push()
        </code>
        ,
        <code>
         emplace()
        </code>
        ,
        <code>
         pop()
        </code>
        , and
        <code>
         push_range()
        </code>
        (C++23). The difference is that
        <code>
         push()
        </code>
        and
        <code>
         push_range()
        </code>
        add new elements to the top of the
        <code>
         stack
        </code>
        , “pushing down” all elements inserted earlier, and
        <code>
         pop()
        </code>
        removes the element from the top of the
        <code>
         stack
        </code>
        , which is the most recently inserted element. The
        <code>
         top()
        </code>
        member function returns a reference-to-
        <code>
         const
        </code>
        to the top element if called on a
        <code>
         const
        </code>
        object, and a reference-to-non-
        <code>
         const
        </code>
        if called on a non-
        <code>
         const
        </code>
        object.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0246">
           <b>
            WARNING
           </b>
           <code>
            pop()
           </code>
           <i>
            does not return the element popped. If you want to retain a copy, you must first retrieve it with
           </i>
           <code>
            top()
           </code>
           <i>
            .
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c18-para-0247">
        The
        <code>
         stack
        </code>
        supports
        <code>
         empty()
        </code>
        ,
        <code>
         size()
        </code>
        ,
        <code>
         swap()
        </code>
        , and the standard comparison operators.
       </p>
      </section>
      <section>
       <span id="c18-sec-0089">
       </span>
       <h4 id="head-4-294">
        stack Example: Revised Error Correlator
       </h4>
       <p id="c18-para-0248">
        You can rewrite the previous
        <code>
         ErrorCorrelator
        </code>
        class so that it gives out the most recent error instead of the one with the highest priority. The only change required is to change
        <code>
         m_errors
        </code>
        from a
        <code>
         priority_queue
        </code>
        to a
        <code>
         stack
        </code>
        . With this change, the errors are distributed in LIFO order instead of priority order. Nothing in the member function definitions needs to change because the
        <code>
         push()
        </code>
        ,
        <code>
         pop()
        </code>
        ,
        <code>
         top()
        </code>
        , and
        <code>
         empty()
        </code>
        member functions exist on both a
        <code>
         priority_queue
        </code>
        and a
        <code>
         stack
        </code>
        .
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-202">
     <span id="c18-sec-0090">
     </span>
     <h2 id="head-2-202">
      ASSOCIATIVE CONTAINERS
     </h2>
     <p>
      The C++ Standard Library provides several different types of associative containers:
     </p>
     <ul class="check1" id="c18-list-0013">
      <li id="c18-li-0064">
       <b>
        Ordered associative containers:
       </b>
       <code>
        map
       </code>
       ,
       <code>
        multimap
       </code>
       ,
       <code>
        set
       </code>
       , and
       <code>
        multiset
       </code>
       .
      </li>
      <li id="c18-li-0065">
       <b>
        Unordered associative containers:
       </b>
       <code>
        unordered_map
       </code>
       ,
       <code>
        unordered_multimap
       </code>
       ,
       <code>
        unordered_set
       </code>
       , and
       <code>
        unordered_multiset
       </code>
       . These are also known as hash tables.
      </li>
     </ul>
     <ul class="check1" id="c18-list-0014">
      <li id="c18-li-0066">
       <img alt="C++23" src="../images\images/icon1.png"/>
       <b>
        Flat associative container adapters:
       </b>
       <code>
        flat_map
       </code>
       ,
       <code>
        flat_multimap
       </code>
       ,
       <code>
        flat_set
       </code>
       , and
       <code>
        flat_multiset
       </code>
       . These adapt sequential containers to behave as ordered associative containers.
      </li>
     </ul>
     <section>
      <span id="c18-sec-0091">
      </span>
      <h3 id="head-3-411">
       Ordered Associative Containers
      </h3>
      <p id="c18-para-0251">
       Unlike the sequential containers, the
       <i>
        ordered associative containers
       </i>
       do not store elements in a linear configuration. Instead, they provide a mapping of keys to values. They generally offer insertion, deletion, and lookup times that are equivalent to each other.
      </p>
      <p id="c18-para-0252">
       There are four ordered associative containers provided by the Standard Library:
       <code>
        map
       </code>
       ,
       <code>
        multimap
       </code>
       ,
       <code>
        set
       </code>
       , and
       <code>
        multiset
       </code>
       . Each of these containers stores its elements in a
       <i>
        sorted
       </i>
       , tree-like data structure.
      </p>
      <span aria-label="729" epub:type="pagebreak" id="Page_729" role="doc-pagebreak">
      </span>
      <section>
       <span id="c18-sec-0092">
       </span>
       <h4 id="head-4-295">
        The pair Utility Class
       </h4>
       <p>
        Before delving deeper into the ordered associative containers, let's revisit the
        <code>
         pair
        </code>
        class template briefly introduced in
        <a href="c01.xhtml">
         Chapter 1
        </a>
        . It is defined in
        <code>
         &lt;utility&gt;
        </code>
        and groups together two values of possibly different types. The values are accessible through the
        <code>
         first
        </code>
        and
        <code>
         second
        </code>
        public data members. All comparison operators are supported and compare both the
        <code>
         first
        </code>
        and
        <code>
         second
        </code>
        values. Here are some examples:
       </p>
       <pre id="c18-code-0092"><code><span class="color3">// Two-argument constructor and default constructor</span></code>
<code>pair&lt;string, int&gt; myPair { "hello", 5 };</code>
<code>pair&lt;string, int&gt; myOtherPair;</code>
<code> </code>
<code><span class="color3">// Can assign directly to first and second</span></code>
<code>myOtherPair.first = "hello";</code>
<code>myOtherPair.second = 6;</code>
<code> </code>
<code><span class="color3">// Copy constructor</span></code>
<code>pair&lt;string, int&gt; myThirdPair { myOtherPair };</code>
<code> </code>
<code><span class="color3">// operator&lt;</span></code>
<code>if (myPair &lt; myOtherPair) {</code>
<code>    println("myPair is less than myOtherPair");</code>
<code>} else {</code>
<code>    println("myPair is greater than or equal to myOtherPair");</code>
<code>}</code>
<code> </code>
<code><span class="color3">// operator==</span></code>
<code>if (myOtherPair == myThirdPair) {</code>
<code>    println("myOtherPair is equal to myThirdPair");</code>
<code>} else {</code>
<code>    println("myOtherPair is not equal to myThirdPair");</code>
<code>}</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c18-code-0093"><code>myPair is less than myOtherPair</code>
<code>myOtherPair is equal to myThirdPair</code></pre>
       <p>
        With class template argument deduction, you can omit the template type arguments. Here is an example. Note the use of the standard string literal
        <code>
         s
        </code>
        .
       </p>
       <pre id="c18-code-0094"><code>pair myPair { "hello"s, 5 };  <span class="color3">// Type is pair&lt;string, int&gt;.</span></code></pre>
       <p>
        Before C++17 introduced support for CTAD, an
        <code>
         std::make_pair()
        </code>
        utility function template could be used to construct a
        <code>
         pair
        </code>
        from two values. The following are three ways to construct a
        <code>
         pair
        </code>
        of an
        <code>
         int
        </code>
        and a
        <code>
         double
        </code>
        :
       </p>
       <pre id="c18-code-0095"><code>pair&lt;int, double&gt; pair1 { make_pair(5, 10.10) };</code>
<code>auto pair2 { make_pair(5, 10.10) };</code>
<code>pair pair3 { 5, 10.10 };  <span class="color3">// CTAD</span></code></pre>
      </section>
      <section>
       <span id="c18-sec-0093">
       </span>
       <h4 id="head-4-296">
        map
       </h4>
       <p id="c18-para-0257">
        A
        <code>
         map
        </code>
        , defined in
        <code>
         &lt;map&gt;
        </code>
        , stores key/value pairs instead of just single values. Insertion, lookup, and deletion are all based on the key; the value is just “along for the ride.” The term
        <i>
         map
        </i>
        comes from the conceptual understanding that the container “maps” keys to values.
       </p>
       <p id="c18-para-0258">
        <span aria-label="730" epub:type="pagebreak" id="Page_730" role="doc-pagebreak">
        </span>
        A
        <code>
         map
        </code>
        keeps elements in sorted order, based on the keys, so that insertion, deletion, and lookup all take logarithmic time. Because of the order, when you enumerate the elements, they come out in the ordering imposed by the type's
        <code>
         operator&lt;
        </code>
        or a user-defined comparator. It is usually implemented as some form of balanced tree, such as a red-black tree. However, the tree structure is not exposed to the client.
       </p>
       <p id="c18-para-0259">
        You should use a
        <code>
         map
        </code>
        whenever you need to store and retrieve elements based on a “key” and you would like to have them in a certain order.
       </p>
       <section>
        <span id="c18-sec-0094">
        </span>
        <h5 id="head-5-120">
         Constructing maps
        </h5>
        <p id="c18-para-0260">
         The
         <code>
          map
         </code>
         class template takes four types: the key type, the value type, the comparator type, and the allocator type. As always, the allocator is ignored in this chapter. The comparator is similar to the comparator for a
         <code>
          priority_queue
         </code>
         described earlier. It allows you to change the default comparator. In this chapter, only the default
         <code>
          less
         </code>
         comparator is used. When using the default, make sure that your keys all respond to
         <code>
          operator&lt;
         </code>
         appropriately. If you're interested in further detail,
         <a href="c19.xhtml">
          Chapter 19
         </a>
         explains how to write your own comparators.
        </p>
        <p>
         If you ignore the comparator and allocator parameters, constructing a
         <code>
          map
         </code>
         is just like constructing a
         <code>
          vector
         </code>
         or a
         <code>
          list
         </code>
         , except that you specify the key and value types separately in the template instantiation. For example, the following code constructs a
         <code>
          map
         </code>
         that uses
         <code>
          int
         </code>
         s as the key and objects of the
         <code>
          Data
         </code>
         class as values:
        </p>
        <pre id="c18-code-0096"><code>class Data final</code>
<code>{</code>
<code>    public:</code>
<code>        explicit Data(int value = 0) : m_value { value } { }</code>
<code>        int getValue() const { return m_value; }</code>
<code>        void setValue(int value) { m_value = value; }</code>
<code>    private:</code>
<code>        int m_value;</code>
<code>};</code>
<code>…</code>
<code>map&lt;int, Data&gt; dataMap;</code></pre>
        <p id="c18-para-0262">
         Internally,
         <code>
          dataMap
         </code>
         stores a
         <code>
          pair&lt;int, Data&gt;
         </code>
         for each element in the
         <code>
          map
         </code>
         .
        </p>
        <p>
         A
         <code>
          map
         </code>
         also supports uniform initialization. The following
         <code>
          map
         </code>
         internally stores instances of
         <code>
          pair&lt;string, int&gt;
         </code>
         :
        </p>
        <pre id="c18-code-0097"><code>map&lt;string, int&gt; m {</code>
<code>    { "Marc G.", 12 }, { "Warren B.", 34 }, { "Peter V.W.", 56 }</code>
<code>};</code></pre>
        <p>
         Class template argument deduction does not work as usual. For example, the following does not compile:
        </p>
        <pre id="c18-code-0098"><code>map m {</code>
<code>    { "Marc G."s, 12 }, { "Warren B."s, 34 }, { "Peter V.W."s, 56 }</code>
<code>};</code></pre>
        <p>
         This does not work because the compiler cannot deduce
         <code>
          pair&lt;string, int&gt;
         </code>
         from, for example,
         <code>
          {"Marc G."s, 12}
         </code>
         . If you really want, you can write the following (note the
         <code>
          s
         </code>
         suffix for the string literals!):
        </p>
        <pre id="c18-code-0099"><span aria-label="731" epub:type="pagebreak" id="Page_731" role="doc-pagebreak"></span><code>map m {</code>
<code>    pair { "Marc G."s, 12 }, pair { "Warren B."s, 34 }, pair { "Peter V.W."s, 56 }</code>
<code>};</code></pre>
       </section>
       <section>
        <span id="c18-sec-0095">
        </span>
        <h5 id="head-5-121">
         <img alt="C++23" src="../images\images/icon1.png"/>
         Formatting and Printing Maps
        </h5>
        <p>
         Just as for
         <code>
          vector
         </code>
         s,
         <code>
          std::format()
         </code>
         and the
         <code>
          print()
         </code>
         functions can be used to format and print entire
         <code>
          map
         </code>
         s with a single statement. For
         <code>
          vector
         </code>
         s, the output is surrounded by square brackets, and each element is separated with a comma. For
         <code>
          map
         </code>
         s, the output is slightly different: the output is surrounded by curly brackets, each key/value pair is separated by a comma, and a colon separates the key and the value. For example, printing the
         <code>
          map
         </code>
         from the previous section,
         <code>
          m
         </code>
         , gives the following output:
        </p>
        <pre id="c18-code-0100"><code>{"Marc G.": 12, "Peter V.W.": 56, "Warren B.": 34}</code></pre>
       </section>
       <section>
        <span id="c18-sec-0096">
        </span>
        <h5 id="head-5-122">
         Inserting Elements
        </h5>
        <p>
         Inserting an element into sequential containers such as
         <code>
          vector
         </code>
         and
         <code>
          list
         </code>
         always requires you to specify the position at which the element is to be added. A
         <code>
          map
         </code>
         , along with the other ordered associative containers, is different. The
         <code>
          map
         </code>
         's internal implementation determines the position in which to store the new element; you need only to supply the key and the value.
        </p>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0269">
            <b>
             NOTE
            </b>
            <code>
             map
            </code>
            <i>
             and the other ordered associative containers do provide a version of
            </i>
            <code>
             insert()
            </code>
            <i>
             that takes an iterator position. However, that position is only a “hint” to the container as to the correct position. The container is not required to insert the element at that position.
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
        <p id="c18-para-0270">
         When inserting elements, it is important to keep in mind that
         <code>
          map
         </code>
         s require unique keys: every element in the
         <code>
          map
         </code>
         must have a different key. If you want to support multiple elements with the same key, you have two options: either you can use a
         <code>
          map
         </code>
         and store another container such as a
         <code>
          vector
         </code>
         as the value for a key or you can use
         <code>
          multimap
         </code>
         s, described later.
        </p>
        <section>
         <span id="c18-sec-0098">
         </span>
         <h6 id="head-6-13">
          The insert() Member Function
         </h6>
         <p>
          The
          <code>
           insert()
          </code>
          member function can be used to add elements to a
          <code>
           map
          </code>
          and has the advantage of allowing you to detect whether a key already exists. You must specify the key/value pair as a
          <code>
           pair
          </code>
          object or as an
          <code>
           initializer_list
          </code>
          . The return type of the basic form of
          <code>
           insert()
          </code>
          is a
          <code>
           pair
          </code>
          of an
          <code>
           iterator
          </code>
          and a
          <code>
           bool
          </code>
          . The reason for the complicated return type is that
          <code>
           insert()
          </code>
          does not overwrite a value if one already exists with the specified key. The
          <code>
           bool
          </code>
          element of the returned
          <code>
           pair
          </code>
          specifies whether the
          <code>
           insert()
          </code>
          actually inserted the new key/value pair. The
          <code>
           iterator
          </code>
          refers to the element in the
          <code>
           map
          </code>
          with the specified key (with a new or old value, depending on whether the insert succeeded or failed).
          <code>
           map
          </code>
          iterators are discussed in more detail in the next section. Continuing the
          <code>
           map
          </code>
          example from the previous section, you can use
          <code>
           insert()
          </code>
          as follows:
         </p>
         <pre id="c18-code-0101"><code>map&lt;int, Data&gt; dataMap;</code>
<code> </code>
<code>auto ret { dataMap.insert({ 1, Data { 4 } }) };   <span class="color3">// Using an initializer_list</span></code>
<code>if (ret.second) { println("Insert succeeded!"); }</code>
<code>else { println("Insert failed!"); }</code>
<code> </code>
<span aria-label="732" epub:type="pagebreak" id="Page_732" role="doc-pagebreak"></span><code>ret = dataMap.insert(make_pair(1, Data { 6 })); <span class="color3">// Using a pair object</span></code>
<code>if (ret.second) { println("Insert succeeded!"); }</code>
<code>else { println("Insert failed!"); }</code></pre>
         <p>
          The type of the
          <code>
           ret
          </code>
          variable is a
          <code>
           pair
          </code>
          as follows:
         </p>
         <pre id="c18-code-0102"><code>pair&lt;map&lt;int, Data&gt;::iterator, bool&gt; ret;</code></pre>
         <p id="c18-para-0273">
          The first element of the
          <code>
           pair
          </code>
          is a
          <code>
           map
          </code>
          iterator for a
          <code>
           map
          </code>
          with keys of type
          <code>
           int
          </code>
          and values of type
          <code>
           Data
          </code>
          . The second element of the
          <code>
           pair
          </code>
          is a Boolean value.
         </p>
         <p>
          The output of the program is as follows:
         </p>
         <pre id="c18-code-0103"><code>Insert succeeded!</code>
<code>Insert failed!</code></pre>
         <p>
          With
          <code>
           if
          </code>
          statement initializers, inserting the data into the
          <code>
           map
          </code>
          and checking the result can be done with a single statement as follows:
         </p>
         <pre id="c18-code-0104"><code><b>if (auto result { dataMap.insert({ 1, Data { 4 } }) }; result.second) {</b></code>
<code>    println("Insert succeeded!");</code>
<code>} else {</code>
<code>    println("Insert failed!");</code>
<code>}</code></pre>
         <p>
          This can further be combined with structured bindings:
         </p>
         <pre id="c18-code-0105"><code><b>if (auto [iter, success] { dataMap.insert({ 1, Data { 4 } }) }; success) {</b></code>
<code>    println("Insert succeeded!");</code>
<code>} else {</code>
<code>    println("Insert failed!");</code>
<code>}</code></pre>
        </section>
        <section>
         <span id="c18-sec-0099">
         </span>
         <h6 id="head-6-14">
          The insert_or_assign() Member Function
         </h6>
         <p>
          <code>
           insert_or_assign()
          </code>
          has a similar return type as
          <code>
           insert()
          </code>
          . However, if an element with the given key already exists,
          <code>
           insert_or_assign()
          </code>
          overwrites the old value with the new value, while
          <code>
           insert()
          </code>
          does not overwrite the old value in that case. Another difference with
          <code>
           insert()
          </code>
          is that
          <code>
           insert_or_assign()
          </code>
          has two separate parameters: the key and the value. Here is an example:
         </p>
         <pre id="c18-code-0106"><code><b>auto ret { dataMap.insert_or_assign(1, Data { 7 }) };</b></code>
<code>if (ret.second) { println("Inserted."); }</code>
<code>else { println("Overwritten."); }</code></pre>
        </section>
        <section>
         <span id="c18-sec-0100">
         </span>
         <h6 id="head-6-15">
          <img alt="C++23" src="../images\images/icon1.png"/>
          The insert_range() Member Function
         </h6>
         <p>
          C++23 adds
          <code>
           insert_range()
          </code>
          for
          <code>
           map
          </code>
          , which can be used to insert all elements of a given range to the
          <code>
           map
          </code>
          , and returns an iterator to the first element that was added. Here is an example:
         </p>
         <pre id="c18-code-0107"><code>vector&lt;pair&lt;int, Data&gt;&gt; moreData { {2, Data{22}}, {3, Data{33}}, {4, Data{44}} };</code>
<code><b>dataMap.insert_range(moreData);</b></code></pre>
        </section>
        <section>
         <span id="c18-sec-0101">
         </span>
         <h6 id="head-6-16">
          operator[]
         </h6>
         <p>
          Another member function to insert elements into a
          <code>
           map
          </code>
          is through the overloaded
          <code>
           operator[]
          </code>
          . The difference is mainly in the syntax: you specify the key and value separately. Additionally,
          <code>
           operator[]
          </code>
          <span aria-label="733" epub:type="pagebreak" id="Page_733" role="doc-pagebreak">
          </span>
          always succeeds. If no value with the given key exists, it creates a new element with that key and value. If an element with the key already exists,
          <code>
           operator[]
          </code>
          replaces the value with the newly specified value. Here is part of the previous example using
          <code>
           operator[]
          </code>
          instead of
          <code>
           insert()
          </code>
          :
         </p>
         <pre id="c18-code-0108"><code>map&lt;int, Data&gt; dataMap;</code>
<code>dataMap[1] = Data { 4 };</code>
<code>dataMap[1] = Data { 6 }; <span class="color3">// Replaces the element with key 1</span></code></pre>
         <p id="c18-para-0281">
          There is, however, one major caveat to
          <code>
           operator[]
          </code>
          : it always constructs a new value object, even if it doesn't need to use it. Thus, it requires a default constructor for the element values and can be less efficient than
          <code>
           insert()
          </code>
          .
         </p>
         <p>
          The fact that
          <code>
           operator[]
          </code>
          creates a new element in a
          <code>
           map
          </code>
          if the requested element does not already exist means that this operator is not marked as
          <code>
           const
          </code>
          . This sounds obvious, but might sometimes look counterintuitive. For example, suppose you have the following function:
         </p>
         <pre id="c18-code-0109"><code>void func(const map&lt;int, int&gt;&amp; m)</code>
<code>{</code>
<code>    println("{}", m[1]);  <span class="color3">// Error</span></code>
<code>}</code></pre>
         <p id="c18-para-0283">
          This fails to compile, even though you appear to be just reading the value
          <code>
           m[1]
          </code>
          . It fails because the parameter
          <code>
           m
          </code>
          is a reference-to-
          <code>
           const
          </code>
          to a
          <code>
           map
          </code>
          , and
          <code>
           operator[]
          </code>
          is not marked as
          <code>
           const
          </code>
          . In such cases, you should instead use the
          <code>
           find()
          </code>
          or
          <code>
           at()
          </code>
          member function described in the section “
          <a href="#c18-sec-0105">
           Looking Up Elements
          </a>
          .”
         </p>
        </section>
        <section>
         <span id="c18-sec-0102">
         </span>
         <h6 id="head-6-17">
          Emplace Member Functions
         </h6>
         <p id="c18-para-0284">
          A
          <code>
           map
          </code>
          supports
          <code>
           emplace()
          </code>
          and
          <code>
           emplace:hint()
          </code>
          to construct elements in-place, similar to the emplace member functions of a
          <code>
           vector
          </code>
          . There is also a
          <code>
           try_emplace()
          </code>
          member function that inserts an element in-place if the given key does not exist yet, or does nothing if the key already exists in the
          <code>
           map
          </code>
          .
         </p>
        </section>
       </section>
       <section>
        <span id="c18-sec-0103">
        </span>
        <h5 id="head-5-123">
         map Iterators
        </h5>
        <p>
         <code>
          map
         </code>
         iterators work similarly to the iterators on the sequential containers. The major difference is that the iterators refer to key/value
         <code>
          pair
         </code>
         s instead of just the values. To access the value, you must retrieve the
         <code>
          second
         </code>
         field of the
         <code>
          pair
         </code>
         object.
         <code>
          map
         </code>
         iterators are bidirectional, meaning you can traverse them in both directions. Here is how you can iterate through the
         <code>
          map
         </code>
         from the previous example:
        </p>
        <pre id="c18-code-0110"><code>for (auto iter { cbegin(dataMap) }; iter != cend(dataMap); ++iter) {</code>
<code>    println("{}", iter-&gt;second.getValue());</code>
<code>}</code></pre>
        <p>
         Take another look at the expression used to access the value:
        </p>
        <pre id="c18-code-0111"><code>iter-&gt;second.getValue()</code></pre>
        <p id="c18-para-0287">
         <code>
          iter
         </code>
         refers to a key/value
         <code>
          pair
         </code>
         , so you can use the
         <code>
          -&gt;
         </code>
         operator to access the
         <code>
          second
         </code>
         field of that
         <code>
          pair
         </code>
         , which is a
         <code>
          Data
         </code>
         object. You can then call the
         <code>
          getValue()
         </code>
         member function on that
         <code>
          Data
         </code>
         object.
        </p>
        <p>
         Note that the following code is functionally equivalent:
        </p>
        <pre id="c18-code-0112"><code>(*iter).second.getValue()</code></pre>
        <p>
         <span aria-label="734" epub:type="pagebreak" id="Page_734" role="doc-pagebreak">
         </span>
         Using a range-based
         <code>
          for
         </code>
         loop, the loop can be written more readable and less error prone as follows:
        </p>
        <pre id="c18-code-0113"><code>for (const auto&amp; p : dataMap) {</code>
<code>    println("{}", p.second.getValue());</code>
<code>}</code></pre>
        <p>
         It can be implemented even more elegantly using a combination of a range-based
         <code>
          for
         </code>
         loop and structured bindings:
        </p>
        <pre id="c18-code-0114"><code>for (const auto&amp; [key, data] : dataMap) {</code>
<code>    println("{}", data.getValue());</code>
<code>}</code></pre>
        <section>
         <aside>
          <div class="top hr">
           <hr/>
          </div>
          <section class="feature1">
           <p id="c18-para-0292">
            <b>
             WARNING
            </b>
            <i>
             You can modify element values through non-
            </i>
            <code>
             const
            </code>
            <i>
             iterators, but the compiler will generate an error if you try to modify the key of an element, even through a non-
            </i>
            <code>
             const
            </code>
            <i>
             iterator, because it would destroy the sorted order of the elements in the
            </i>
            <code>
             map
            </code>
            <i>
             .
            </i>
           </p>
           <div class="bottom hr">
            <hr/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section>
        <span id="c18-sec-0105">
        </span>
        <h5 id="head-5-124">
         Looking Up Elements
        </h5>
        <p>
         A
         <code>
          map
         </code>
         provides logarithmic lookup of elements based on a supplied key. If you already know that an element with a given key is in a map, the simplest way to look it up is through
         <code>
          operator[]
         </code>
         as long as you call it on a non-
         <code>
          const map
         </code>
         or a reference-to-non-
         <code>
          const map
         </code>
         . The nice thing about
         <code>
          operator[]
         </code>
         is that it returns a reference to the value that you can use and modify directly, without worrying about pulling the value out of a
         <code>
          pair
         </code>
         object. Here is an extension of the previous example to call the
         <code>
          setValue()
         </code>
         member function on the
         <code>
          Data
         </code>
         object value with key
         <code>
          1
         </code>
         :
        </p>
        <pre id="c18-code-0115"><code>map&lt;int, Data&gt; dataMap;</code>
<code>dataMap[1] = Data { 4 };</code>
<code>dataMap[1] = Data { 6 };</code>
<code><b>dataMap[1].setValue(100);</b></code></pre>
        <p>
         As an alternative,
         <code>
          map
         </code>
         provides a
         <code>
          find()
         </code>
         member function that returns an
         <code>
          iterator
         </code>
         referring to the key/value pair with the requested key, if it exists, or the
         <code>
          end()
         </code>
         iterator if the key is not found in the
         <code>
          map
         </code>
         . This can be useful in the following cases:
        </p>
        <ul class="check1" id="c18-list-0015">
         <li id="c18-li-0067">
          If you don't know whether the element exists, you may not want to use
          <code>
           operator[]
          </code>
          , because it will insert a new element with that key if it doesn't find one already.
         </li>
         <li id="c18-li-0068">
          If you have a
          <code>
           const
          </code>
          or a reference-to-
          <code>
           const map
          </code>
          , in which case you cannot use
          <code>
           operator[]
          </code>
          .
         </li>
        </ul>
        <p>
         Here is an example using
         <code>
          find()
         </code>
         to perform the same modification to the
         <code>
          Data
         </code>
         object with key
         <code>
          1
         </code>
         :
        </p>
        <pre id="c18-code-0116"><code>auto it { dataMap.find(1) };</code>
<code>if (it != end(dataMap)) {</code>
<code>    it-&gt;second.setValue(100);</code>
<code>}</code></pre>
        <p id="c18-para-0296">
         As you can see, using
         <code>
          find()
         </code>
         is a bit clumsier, but it's sometimes necessary.
        </p>
        <p>
         <span aria-label="735" epub:type="pagebreak" id="Page_735" role="doc-pagebreak">
         </span>
         Alternatively, you can use the
         <code>
          at()
         </code>
         member function, which, just as
         <code>
          operator[]
         </code>
         , returns a reference to the value in the
         <code>
          map
         </code>
         with the requested key, if it exists. It throws an
         <code>
          out_of_range
         </code>
         exception if the requested key isn't found in the
         <code>
          map
         </code>
         . The
         <code>
          at()
         </code>
         member function works fine on a
         <code>
          const
         </code>
         or a reference-to-
         <code>
          const map
         </code>
         . For example:
        </p>
        <pre id="c18-code-0117"><code>dataMap.at(1).setValue(200);</code></pre>
        <p id="c18-para-0298">
         If you only want to know whether an element with a certain key is in a
         <code>
          map
         </code>
         , you can use the
         <code>
          count()
         </code>
         member function. It returns the number of elements in a
         <code>
          map
         </code>
         with a given key. For
         <code>
          map
         </code>
         s, the result will always be
         <code>
          0
         </code>
         or
         <code>
          1
         </code>
         because there can be no elements with duplicate keys.
        </p>
        <p>
         Additionally, all associative containers (ordered, unordered, and flat) have a member function called
         <code>
          contains()
         </code>
         . It returns
         <code>
          true
         </code>
         if a given key exists in a container,
         <code>
          false
         </code>
         otherwise. With this, it's no longer necessary to use
         <code>
          count()
         </code>
         to figure out whether a certain key is in an associative container. Here is an example:
        </p>
        <pre id="c18-code-0118"><code>auto isKeyInMap { dataMap.contains(1) };</code></pre>
       </section>
       <section>
        <span id="c18-sec-0106">
        </span>
        <h5 id="head-5-125">
         Removing Elements
        </h5>
        <p>
         A
         <code>
          map
         </code>
         allows you to remove an element at a specific iterator position or to remove all elements in a given iterator range, in amortized constant and logarithmic time, respectively. From the client perspective, these two
         <code>
          erase()
         </code>
         member functions are equivalent to those in the sequential containers. A great feature of a
         <code>
          map
         </code>
         , however, is that it also provides a version of
         <code>
          erase()
         </code>
         to remove an element matching a key. Here is an example:
        </p>
        <pre id="c18-code-0119"><code>map&lt;int, Data&gt; dataMap;</code>
<code>dataMap[1] = Data { 4 };</code>
<code>println("There are {} elements with key 1.", dataMap.count(1));</code>
<code>dataMap.erase(1);</code>
<code>println("There are {} elements with key 1.", dataMap.count(1));</code></pre>
        <p>
         The output is as follows:
        </p>
        <pre id="c18-code-0120"><code>There are 1 elements with key 1.</code>
<code>There are 0 elements with key 1.</code></pre>
       </section>
       <section>
        <span id="c18-sec-0107">
        </span>
        <h5 id="head-5-126">
         Nodes
        </h5>
        <p id="c18-para-0302">
         All the ordered and unordered associative containers are
         <i>
          node-based
         </i>
         data structures. The Standard Library provides direct access to
         <i>
          nodes
         </i>
         in the form of
         <i>
          node handles
         </i>
         . The exact type is unspecified, but each container has a type alias called
         <code>
          node_type
         </code>
         that specifies the type of a node handle for that container. A node handle can only be moved and is the owner of the element stored in a node. It provides read/write access to both the key and the value.
        </p>
        <p id="c18-para-0303">
         Nodes can be extracted from an associative container as a node handle using the
         <code>
          extract()
         </code>
         member function, based either on a given iterator position or on a given key. Extracting a node from a container removes it from the container, because the returned node handle is the sole owner of the extracted element.
        </p>
        <p id="c18-para-0304">
         New
         <code>
          insert()
         </code>
         overloads are provided that allow you to insert a node handle into a container.
        </p>
        <p>
         <span aria-label="736" epub:type="pagebreak" id="Page_736" role="doc-pagebreak">
         </span>
         By using
         <code>
          extract()
         </code>
         to extract node handles and using
         <code>
          insert()
         </code>
         to insert node handles, you can effectively transfer data from one associative container to another one without any copying or moving involved. You can even transfer nodes from a
         <code>
          map
         </code>
         to a
         <code>
          multimap
         </code>
         and from a
         <code>
          set
         </code>
         to a
         <code>
          multiset
         </code>
         . Continuing with the example from the previous section, the following code snippet transfers the node with key 1 from
         <code>
          dataMap
         </code>
         to a second
         <code>
          map
         </code>
         called
         <code>
          dataMap2
         </code>
         :
        </p>
        <pre id="c18-code-0121"><code>map&lt;int, Data&gt; dataMap2;</code>
<code>auto extractedNode { dataMap.extract(1) };</code>
<code>dataMap2.insert(move(extractedNode));</code></pre>
        <p>
         The last two lines can be combined into one:
        </p>
        <pre id="c18-code-0122"><code>dataMap2.insert(dataMap.extract(1));</code></pre>
        <p>
         One additional operation is available to move all nodes from one associative container to another one:
         <code>
          merge()
         </code>
         . Nodes that cannot be moved because they would cause, for example, duplicates in a target container that does not allow duplicates, are left in the source container. Here is an example:
        </p>
        <pre id="c18-code-0123"><code>map&lt;int, int&gt; src { {1, 11}, {2, 22} };</code>
<code>map&lt;int, int&gt; dst { {2, 22}, {3, 33}, {4, 44}, {5, 55} };</code>
<code>dst.merge(src);</code>
<code>println("src = {}", src); <span class="color3">// src = {2: 22}</span></code>
<code>println("dst = {}", dst); <span class="color3">// dst = {1: 11, 2: 22, 3: 33, 4: 44, 5: 55}</span></code></pre>
        <p id="c18-para-0308">
         After the merge operation,
         <code>
          src
         </code>
         still contains one element, {2: 22}, because the destination already contains such an element, so it cannot be moved.
        </p>
       </section>
       <section>
        <span id="c18-sec-0108">
        </span>
        <h5 id="head-5-127">
         map Example: Bank Account
        </h5>
        <p>
         You can implement a simple bank account database using a
         <code>
          map
         </code>
         . A common pattern is for the key to be one field of a
         <code>
          class
         </code>
         or
         <code>
          struct
         </code>
         that is stored in a
         <code>
          map
         </code>
         . In this case, the key is the account number. Here are simple
         <code>
          BankAccount
         </code>
         and
         <code>
          BankDB
         </code>
         classes:
        </p>
        <pre id="c18-code-0124"><code>export class BankAccount final</code>
<code>{</code>
<code>    public:</code>
<code>        explicit BankAccount(int accountNumber, std::string name)</code>
<code>            : m_accountNumber { accountNumber }, m_clientName { std::move(name) }{}</code>
<code> </code>
<code>        void setAccountNumber(int accountNumber) {</code>
<code>            m_accountNumber = accountNumber; }</code>
<code>        int getAccountNumber() const { return m_accountNumber; }</code>
<code> </code>
<code>        void setClientName(std::string name) { m_clientName = std::move(name); }</code>
<code>        const std::string&amp; getClientName() const { return m_clientName; }</code>
<code>    private:</code>
<code>        int m_accountNumber;</code>
<code>        std::string m_clientName;</code>
<code>};</code>
<code> </code>
<code>export class BankDB final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Adds account to the bank database. If an account exists already</span></code>
<code>        <span class="color3">// with that account number, the new account is not added. Returns true</span></code>
<span aria-label="737" epub:type="pagebreak" id="Page_737" role="doc-pagebreak"></span><code>        <span class="color3">// if the account is added, false if it's not.</span></code>
<code>        bool addAccount(const BankAccount&amp; account);</code>
<code> </code>
<code>        <span class="color3">// Removes the account with accountNumber from the database.</span></code>
<code>        void deleteAccount(int accountNumber);</code>
<code> </code>
<code>        <span class="color3">// Returns a reference to the account represented</span></code>
<code>        <span class="color3">// by its account number or the client name.</span></code>
<code>        <span class="color3">// Throws out_of_range if the account is not found.</span></code>
<code>        BankAccount&amp; findAccount(int accountNumber);</code>
<code>        BankAccount&amp; findAccount(std::string_view name);</code>
<code> </code>
<code>        <span class="color3">// Adds all the accounts from db to this database.</span></code>
<code>        <span class="color3">// Deletes all the accounts from db.</span></code>
<code>        void mergeDatabase(BankDB&amp; db);</code>
<code>    private:</code>
<code>        std::map&lt;int, BankAccount&gt; m_accounts;</code>
<code>};</code></pre>
        <p>
         Here are the implementations of the
         <code>
          BankDB
         </code>
         member functions, with comments explaining the code:
        </p>
        <pre id="c18-code-0125"><code>bool BankDB::addAccount(const BankAccount&amp; account)</code>
<code>{</code>
<code>    <span class="color3">// Do the actual insert, using the account number as the key.</span></code>
<code>    auto res { m_accounts.emplace(account.getAccountNumber(), account) };</code>
<code>    <span class="color3">// or: auto res { m_accounts.insert(</span></code>
<code>    <span class="color3">//         pair { account.getAccountNumber(), account }) };</span></code>
<code> </code>
<code>    <span class="color3">// Return the bool field of the pair specifying success or failure.</span></code>
<code>    return res.second;</code>
<code>}</code>
<code> </code>
<code>void BankDB::deleteAccount(int accountNumber)</code>
<code>{</code>
<code>    m_accounts.erase(accountNumber);</code>
<code>}</code>
<code> </code>
<code>BankAccount&amp; BankDB::findAccount(int accountNumber)</code>
<code>{</code>
<code>    <span class="color3">// Finding an element via its key can be done with find().</span></code>
<code>    auto it { m_accounts.find(accountNumber) };</code>
<code>    if (it == end(m_accounts)) {</code>
<code>        throw out_of_range { format("No account with number {}.", accountNumber) };</code>
<code>    }</code>
<code>    <span class="color3">// Remember that iterators into maps refer to pairs of key/value.</span></code>
<code>    return it-&gt;second;</code>
<code>}</code>
<code> </code>
<code>BankAccount&amp; BankDB::findAccount(string_view name)</code>
<code>{</code>
<code>    <span class="color3">// Finding an element by a non-key attribute requires a linear</span></code>
<code>    <span class="color3">// search through the elements. The following uses structured bindings.</span></code>
<code>    for (auto&amp; [accountNumber, account] : m_accounts) {</code>
<code>        if (account.getClientName() == name) {</code>
<code>            return account;  <span class="color3">// found it!</span></code>
<span aria-label="738" epub:type="pagebreak" id="Page_738" role="doc-pagebreak"></span><code>        }</code>
<code>    }</code>
<code>    throw out_of_range { format("No account with name '{}'.", name) };</code>
<code>}</code>
<code> </code>
<code>void BankDB::mergeDatabase(BankDB&amp; db)</code>
<code>{</code>
<code>    <span class="color3">// Use merge().</span></code>
<code>    m_accounts.merge(db.m_accounts);</code>
<code>    <span class="color3">// Or: m_accounts.insert(begin(db.m_accounts), end(db.m_accounts));</span></code>
<code> </code>
<code>    <span class="color3">// Now clear the source database.</span></code>
<code>    db.m_accounts.clear();</code>
<code>}</code></pre>
        <p>
         You can test the
         <code>
          BankDB
         </code>
         class with the following code:
        </p>
        <pre id="c18-code-0126"><code>BankDB db;</code>
<code>db.addAccount(BankAccount { 100, "Nicholas Solter" });</code>
<code>db.addAccount(BankAccount { 200, "Scott Kleper" });</code>
<code> </code>
<code>try {</code>
<code>    auto&amp; account { db.findAccount(100) };</code>
<code>    println("Found account 100");</code>
<code>    account.setClientName("Nicholas A Solter");</code>
<code> </code>
<code>    auto&amp; account2 { db.findAccount("Scott Kleper") };</code>
<code>    println("Found account of Scott Kleper");</code>
<code> </code>
<code>    auto&amp; account3 { db.findAccount(1000) };</code>
<code>} catch (const out_of_range&amp; caughtException) {</code>
<code>    println("Unable to find account: {}", caughtException.what());</code>
<code>}</code></pre>
        <p>
         The output is as follows:
        </p>
        <pre id="c18-code-0127"><code>Found account 100</code>
<code>Found account of Scott Kleper</code>
<code>Unable to find account: No account with number 1000.</code></pre>
       </section>
      </section>
      <section>
       <span id="c18-sec-0109">
       </span>
       <h4 id="head-4-297">
        multimap
       </h4>
       <p>
        A
        <code>
         multimap
        </code>
        is a
        <code>
         map
        </code>
        that allows multiple elements with the same key. Like
        <code>
         map
        </code>
        s,
        <code>
         multimap
        </code>
        s support uniform initialization. The interface is almost identical to the
        <code>
         map
        </code>
        interface, with the following differences:
       </p>
       <ul class="check1" id="c18-list-0016">
        <li id="c18-li-0069">
         <code>
          multimap
         </code>
         s do not provide
         <code>
          operator[]
         </code>
         and
         <code>
          at()
         </code>
         . The semantics of these do not make sense if there can be multiple elements with a single key.
        </li>
        <li id="c18-li-0070">
         Inserts on
         <code>
          multimap
         </code>
         s always succeed. Thus, the
         <code>
          multimap::insert()
         </code>
         member function that adds a single element returns just an
         <code>
          iterator
         </code>
         instead of a
         <code>
          pair
         </code>
         .
        </li>
        <li id="c18-li-0071">
         The
         <code>
          insert_or_assign()
         </code>
         and
         <code>
          try_emplace()
         </code>
         member functions supported by
         <code>
          map
         </code>
         are not supported by
         <code>
          multimap
         </code>
         .
        </li>
       </ul>
       <p>
        <span aria-label="739" epub:type="pagebreak" id="Page_739" role="doc-pagebreak">
        </span>
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0314">
           <b>
            NOTE
           </b>
           <code>
            multimap
           </code>
           <i>
            s allow you to insert identical key/value pairs. If you want to avoid this redundancy, you must check explicitly before inserting a new element.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c18-para-0315">
        The trickiest aspect of
        <code>
         multimap
        </code>
        s is looking up elements. You can't use
        <code>
         operator[]
        </code>
        , because it is not provided.
        <code>
         find()
        </code>
        isn't very useful because it returns an
        <code>
         iterator
        </code>
        referring to any one of the elements with a given key (not necessarily the first element with that key).
       </p>
       <p id="c18-para-0316">
        However,
        <code>
         multimap
        </code>
        s store all elements with the same key together and provide member functions to obtain
        <code>
         iterator
        </code>
        s for this subrange of elements with the same key in the container. The
        <code>
         lower_bound()
        </code>
        and
        <code>
         upper_bound()
        </code>
        member functions each return a single
        <code>
         iterator
        </code>
        referring to the first and one-past-the-last elements matching a given key. If there are no elements matching that key, the
        <code>
         iterator
        </code>
        s returned by
        <code>
         lower_bound()
        </code>
        and
        <code>
         upper_bound()
        </code>
        will be equal to each other.
       </p>
       <p>
        If you need to obtain both
        <code>
         iterator
        </code>
        s bounding the elements with a given key, it's more efficient to use
        <code>
         equal_range()
        </code>
        instead of calling
        <code>
         lower_bound()
        </code>
        followed by calling
        <code>
         upper_bound()
        </code>
        . The
        <code>
         equal_range()
        </code>
        member function returns a
        <code>
         pair
        </code>
        of the two
        <code>
         iterator
        </code>
        s that would be returned by
        <code>
         lower_bound()
        </code>
        and
        <code>
         upper_bound()
        </code>
        .
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0318">
           <b>
            NOTE
           </b>
           <i>
            The
           </i>
           <code>
            lower_bound()
           </code>
           <i>
            ,
           </i>
           <code>
            upper_bound()
           </code>
           <i>
            , and
           </i>
           <code>
            equal_range()
           </code>
           <i>
            member functions exist for
            <code>
             map
            </code>
            s as well, but their usefulness is limited because a
            <code>
             map
            </code>
            cannot have multiple elements with the same key
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <section>
        <span id="c18-sec-0112">
        </span>
        <h5 id="head-5-128">
         multimap Example: Buddy Lists
        </h5>
        <p id="c18-para-0319">
         Most of the numerous online chat programs allow users to have a “buddy list” or list of friends. The chat program confers special privileges on users in the buddy list, such as allowing them to send unsolicited messages to the user.
        </p>
        <p>
         One way to implement the buddy lists for an online chat program is to store the information in a
         <code>
          multimap
         </code>
         . One
         <code>
          multimap
         </code>
         could store the buddy lists for every user. Each entry in the container stores one buddy for a user. The key is the user, and the value is the buddy. For example, if Harry Potter and Ron Weasley had each other on their individual buddy lists, there would be two entries of the form “Harry Potter” maps to “Ron Weasley” and “Ron Weasley” maps to “Harry Potter.” A
         <code>
          multimap
         </code>
         allows multiple values for the same key, so the same user is allowed multiple buddies. Here is the
         <code>
          BuddyList
         </code>
         class definition:
        </p>
        <pre id="c18-code-0128"><code>export class BuddyList final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Adds buddy as a friend of name.</span></code>
<code>        void addBuddy(const std::string&amp; name, const std::string&amp; buddy);</code>
<code>        <span class="color3">// Removes buddy as a friend of name.</span></code>
<code>        void removeBuddy(const std::string&amp; name, const std::string&amp; buddy);</code>
<code>        <span class="color3">// Returns true if buddy is a friend of name, false otherwise.</span></code>
<code>        bool isBuddy(const std::string&amp; name, const std::string&amp; buddy) const;</code>
<span aria-label="740" epub:type="pagebreak" id="Page_740" role="doc-pagebreak"></span><code>        <span class="color3">// Retrieves a list of all the friends of name.</span></code>
<code>        std::vector&lt;std::string&gt; getBuddies(const std::string&amp; name) const;</code>
<code>    private:</code>
<code>        std::multimap&lt;std::string, std::string&gt; m_buddies;</code>
<code>};</code></pre>
        <p>
         Here are the implementations, with comments explaining the code. It demonstrates the use of
         <code>
          lower_bound()
         </code>
         ,
         <code>
          upper_bound()
         </code>
         , and
         <code>
          equal_range()
         </code>
         .
        </p>
        <pre id="c18-code-0129"><code>void BuddyList::addBuddy(const string&amp; name, const string&amp; buddy)</code>
<code>{</code>
<code>    <span class="color3">// Make sure this buddy isn't already there. We don't want</span></code>
<code>    <span class="color3">// to insert an identical copy of the key/value pair.</span></code>
<code>    if (!isBuddy(name, buddy)) {</code>
<code>        m_buddies.insert({ name, buddy }); <span class="color3">// Using initializer_list</span></code>
<code>    }</code>
<code>}</code>
<code> </code>
<code>void BuddyList::removeBuddy(const string&amp; name, const string&amp; buddy)</code>
<code>{</code>
<code>    <span class="color3">// Obtain the beginning and end of the range of elements with</span></code>
<code>    <span class="color3">// key 'name'. Use both lower_bound() and upper_bound() to demonstrate</span></code>
<code>    <span class="color3">// their use. Otherwise, it's more efficient to call equal_range().</span></code>
<code>    auto begin { m_buddies.lower_bound(name) };  <span class="color3">// Start of the range</span></code>
<code>    auto end { m_buddies.upper_bound(name) };    <span class="color3">// End of the range</span></code>
<code> </code>
<code>    <span class="color3">// Iterate through the elements with key 'name' looking</span></code>
<code>    <span class="color3">// for a value 'buddy'. If there are no elements with key 'name',</span></code>
<code>    <span class="color3">// begin equals end, so the loop body doesn't execute.</span></code>
<code>    for (auto iter { begin }; iter != end; ++iter) {</code>
<code>        if (iter-&gt;second == buddy) {</code>
<code>            <span class="color3">// We found a match! Remove it from the map.</span></code>
<code>            m_buddies.erase(iter);</code>
<code>            break;</code>
<code>        }</code>
<code>    }</code>
<code>}</code>
<code> </code>
<code>bool BuddyList::isBuddy(const string&amp; name, const string&amp; buddy) const</code>
<code>{</code>
<code>    <span class="color3">// Obtain the beginning and end of the range of elements with</span></code>
<code>    <span class="color3">// key 'name' using equal_range(), and structured bindings.</span></code>
<code>    auto [begin, end] { m_buddies.equal_range(name) };</code>
<code> </code>
<code>    <span class="color3">// Iterate through the elements with key 'name' looking</span></code>
<code>    <span class="color3">// for a value 'buddy'.</span></code>
<code>    for (auto iter { begin }; iter != end; ++iter) {</code>
<code>        if (iter-&gt;second == buddy) {</code>
<code>            <span class="color3">// We found a match!</span></code>
<code>            return true;</code>
<code>        }</code>
<code>    }</code>
<code>    <span class="color3">// No matches</span></code>
<code>    return false;</code>
<code>}</code>
<code> </code>
<span aria-label="741" epub:type="pagebreak" id="Page_741" role="doc-pagebreak"></span><code>vector&lt;string&gt; BuddyList::getBuddies(const string&amp; name) const</code>
<code>{</code>
<code>    <span class="color3">// Obtain the beginning and end of the range of elements with</span></code>
<code>    <span class="color3">// key 'name' using equal_range(), and structured bindings.</span></code>
<code>    auto [begin, end] { m_buddies.equal_range(name) };</code>
<code> </code>
<code>    <span class="color3">// Create a vector with all names in the range (all buddies of name).</span></code>
<code>    vector&lt;string&gt; buddies;</code>
<code>    for (auto iter { begin }; iter != end; ++iter) {</code>
<code>        buddies.push_back(iter-&gt;second);</code>
<code>    }</code>
<code>    return buddies;</code>
<code>}</code></pre>
        <p id="c18-para-0322">
         Note that
         <code>
          removeBuddy()
         </code>
         can't simply use the version of
         <code>
          erase()
         </code>
         that erases all elements with a given key, because it should erase only one element with the key, not all of them. Note also that
         <code>
          getBuddies()
         </code>
         can't use
         <code>
          insert()
         </code>
         on the
         <code>
          vector
         </code>
         to insert the elements in the range returned by
         <code>
          equal_range()
         </code>
         , because the elements referred to by the
         <code>
          multimap iterator
         </code>
         s are key/value
         <code>
          pair
         </code>
         s, not
         <code>
          string
         </code>
         s. The
         <code>
          getBuddies()
         </code>
         member function must iterate explicitly through the range extracting the
         <code>
          string
         </code>
         from each key/value
         <code>
          pair
         </code>
         and pushing that onto the new
         <code>
          vector
         </code>
         to be returned.
        </p>
        <p>
         Alternatively, with the C++23 ranges functionality discussed in
         <a href="c17.xhtml">
          Chapter 17
         </a>
         ,
         <code>
          getBuddies()
         </code>
         can be implemented as follows without any explicit loops:
        </p>
        <pre id="c18-code-0130"><code>vector&lt;string&gt; BuddyList::getBuddies(const string&amp; name) const</code>
<code>{</code>
<code>    auto [begin, end] { m_buddies.equal_range(name) };</code>
<code>    return ranges::subrange { begin, end } | views::values | ranges::to&lt;vector&gt;();</code>
<code>}</code></pre>
        <p>
         Here is a test of the
         <code>
          BuddyList
         </code>
         :
        </p>
        <pre id="c18-code-0131"><code>BuddyList buddies;</code>
<code>buddies.addBuddy("Harry Potter", "Ron Weasley");</code>
<code>buddies.addBuddy("Harry Potter", "Hermione Granger");</code>
<code>buddies.addBuddy("Harry Potter", "Hagrid");</code>
<code>buddies.addBuddy("Harry Potter", "Draco Malfoy");</code>
<code><span class="color3">// That's not right! Remove Draco.</span></code>
<code>buddies.removeBuddy("Harry Potter", "Draco Malfoy");</code>
<code>buddies.addBuddy("Hagrid", "Harry Potter");</code>
<code>buddies.addBuddy("Hagrid", "Ron Weasley");</code>
<code>buddies.addBuddy("Hagrid", "Hermione Granger");</code>
<code> </code>
<code>auto harrysFriends { buddies.getBuddies("Harry Potter") };</code>
<code> </code>
<code>println("Harry's friends: ");</code>
<code>for (const auto&amp; name : harrysFriends) {</code>
<code>    println("\t{}", name);</code>
<code>}</code></pre>
        <p>
         <span aria-label="742" epub:type="pagebreak" id="Page_742" role="doc-pagebreak">
         </span>
         The output is as follows:
        </p>
        <pre id="c18-code-0132"><code>Harry's friends:</code>
<code>        Ron Weasley</code>
<code>        Hermione Granger</code>
<code>        Hagrid</code></pre>
       </section>
      </section>
      <section>
       <span id="c18-sec-0113">
       </span>
       <h4 id="head-4-298">
        set
       </h4>
       <p id="c18-para-0326">
        A
        <code>
         set
        </code>
        , defined in
        <code>
         &lt;set&gt;
        </code>
        , is similar to a
        <code>
         map
        </code>
        . The difference is that instead of storing key/value pairs, in
        <code>
         set
        </code>
        s the value is the key.
        <code>
         set
        </code>
        s are useful for storing information in which there is no explicit key, but which you want to have in sorted order without any duplicates, with quick insertion, lookup, and deletion.
       </p>
       <p id="c18-para-0327">
        The interface supplied by
        <code>
         set
        </code>
        is almost identical to that of
        <code>
         map
        </code>
        . The main difference is that
        <code>
         set
        </code>
        doesn't provide
        <code>
         operator[]
        </code>
        ,
        <code>
         insert_or_assign()
        </code>
        , and
        <code>
         try_emplace()
        </code>
        .
       </p>
       <p id="c18-para-0328">
        You cannot change the value of elements in a
        <code>
         set
        </code>
        because modifying elements of a
        <code>
         set
        </code>
        while they are in the container would destroy the order.
       </p>
       <section>
        <span id="c18-sec-0114">
        </span>
        <h5 id="head-5-129">
         set Example: Access Control List
        </h5>
        <p>
         One way to implement basic security on a computer system is through access control lists. Each entity on the system, such as a file or a device, has a list of users with permissions to access that entity. Users can generally be added to and removed from the permissions list for an entity only by users with special privileges. Internally, a
         <code>
          set
         </code>
         provides a nice way to represent the access control list. You could use one
         <code>
          set
         </code>
         for each entity, containing all the usernames that are allowed to access the entity. Here is a class definition for a simple access control list:
        </p>
        <pre id="c18-code-0133"><code>export class AccessList final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Default constructor</span></code>
<code>        AccessList() = default;</code>
<code>        <span class="color3">// Constructor to support uniform initialization.</span></code>
<code>        AccessList(std::initializer_list&lt;std::string_view&gt; users)</code>
<code>        {</code>
<code>            m_allowed.insert(begin(users), end(users));</code>
<code>        }</code>
<code>        <span class="color3">// Adds the user to the permissions list.</span></code>
<code>        void addUser(std::string user)</code>
<code>        {</code>
<code>            m_allowed.emplace(std::move(user));</code>
<code>        }</code>
<code>        <span class="color3">// Removes the user from the permissions list.</span></code>
<code>        void removeUser(const std::string&amp; user)</code>
<code>        {</code>
<code>            m_allowed.erase(user);</code>
<code>        }</code>
<code>        <span class="color3">// Returns true if the user is in the permissions list.</span></code>
<code>        bool isAllowed(const std::string&amp; user) const</code>
<code>        {</code>
<code>            return m_allowed.contains(user);</code>
<code>        }</code>
<span aria-label="743" epub:type="pagebreak" id="Page_743" role="doc-pagebreak"></span><code>        <span class="color3">// Returns all the users who have permissions.</span></code>
<code>        const std::set&lt;std::string&gt;&amp; getAllUsers() const</code>
<code>        {</code>
<code>            return m_allowed;</code>
<code>        }</code>
<code>        <span class="color3">// Returns a vector of all the users who have permissions.</span></code>
<code>        std::vector&lt;std::string&gt; getAllUsersAsVector() const</code>
<code>        {</code>
<code>            return { begin(m_allowed), end(m_allowed) };</code>
<code>        }</code>
<code>    private:</code>
<code>        std::set&lt;std::string&gt; m_allowed;</code>
<code>};</code></pre>
        <p>
         Take a look at the interesting one-line implementation of
         <code>
          getAllUsersAsVector()
         </code>
         . That one line constructs a
         <code>
          vector&lt;string&gt;
         </code>
         to return, by passing a begin and end iterator of
         <code>
          m_allowed
         </code>
         to the
         <code>
          vector
         </code>
         constructor. If you want, you can split this over two lines:
        </p>
        <pre id="c18-code-0134"><code>std::vector&lt;std::string&gt; users { begin(m_allowed), end(m_allowed) };</code>
<code>return users;</code></pre>
        <p>
         Finally, here is a simple test program:
        </p>
        <pre id="c18-code-0135"><code>AccessList fileX { "mgregoire", "baduser" };</code>
<code>fileX.addUser("pvw");</code>
<code>fileX.removeUser("baduser");</code>
<code> </code>
<code>if (fileX.isAllowed("mgregoire")) { println("mgregoire has permissions"); }</code>
<code>if (fileX.isAllowed("baduser")) { println("baduser has permissions"); }</code>
<code> </code>
<code><span class="color3">// C++23 supports formatting/printing of ranges, see <a href="c02.xhtml">Chapter 2</a>.</span></code>
<code>println("Users with access: {:n:}", fileX.getAllUsers());</code>
<code> </code>
<code><span class="color3">// Iterating over the elements of a set.</span></code>
<code>print("Users with access: ");</code>
<code>for (const auto&amp; user : fileX.getAllUsers()) { print("{} ", user); }</code>
<code>println("");</code>
<code> </code>
<code><span class="color3">// Iterating over the elements of a vector.</span></code>
<code>print("Users with access: ");</code>
<code>for (const auto&amp; user : fileX.getAllUsersAsVector()) { print("{} ", user); }</code>
<code>println("");</code></pre>
        <p id="c18-para-0332">
         One of the constructors for
         <code>
          AccessList
         </code>
         uses an
         <code>
          initializer_list
         </code>
         as a parameter so that you can use the uniform initialization syntax, as demonstrated in the test program for initializing
         <code>
          fileX
         </code>
         .
        </p>
        <p>
         The output of this program is as follows:
        </p>
        <pre id="c18-code-0136"><code>mgregoire has permissions</code>
<code>Users with access: mgregoire, pvw</code>
<code>Users with access: mgregoire pvw</code>
<code>Users with access: mgregoire pvw</code></pre>
        <p>
         <span aria-label="744" epub:type="pagebreak" id="Page_744" role="doc-pagebreak">
         </span>
         Note that the
         <code>
          m_allowed
         </code>
         data member needs to be a
         <code>
          set
         </code>
         of
         <code>
          std::string
         </code>
         s, and not of
         <code>
          string_view
         </code>
         s. Changing it to a
         <code>
          set
         </code>
         of
         <code>
          string_view
         </code>
         s will introduce problems with dangling pointers. For example, suppose you have the following code:
        </p>
        <pre id="c18-code-0137"><code>AccessList fileX;</code>
<code>{</code>
<code>    string user { "someuser" };</code>
<code>    fileX.addUser(user);</code>
<code>}</code></pre>
        <p id="c18-para-0335">
         This code snippet creates a
         <code>
          string
         </code>
         called
         <code>
          user
         </code>
         and then adds that to the
         <code>
          fileX
         </code>
         access control list. However, the
         <code>
          string
         </code>
         and the call to
         <code>
          addUser()
         </code>
         are inside a set of curly brackets; that is, the
         <code>
          string
         </code>
         has a shorter lifetime than
         <code>
          fileX
         </code>
         . At the closing curly bracket, the
         <code>
          string
         </code>
         goes out of scope and is destroyed. This would leave the
         <code>
          fileX
         </code>
         access control list with a
         <code>
          string_view
         </code>
         pointing to a destroyed
         <code>
          string
         </code>
         , i.e., a dangling pointer! This problem is avoided by using a
         <code>
          set
         </code>
         of
         <code>
          string
         </code>
         s.
        </p>
       </section>
      </section>
      <section>
       <span id="c18-sec-0115">
       </span>
       <h4 id="head-4-299">
        multiset
       </h4>
       <p id="c18-para-0336">
        A
        <code>
         multiset
        </code>
        is to a
        <code>
         set
        </code>
        what a
        <code>
         multimap
        </code>
        is to a
        <code>
         map
        </code>
        . A
        <code>
         multiset
        </code>
        supports all the operations of a
        <code>
         set
        </code>
        , but it allows multiple elements that are equal to each other to be stored in the container simultaneously. An example of a
        <code>
         multiset
        </code>
        is not shown because it's so similar to
        <code>
         set
        </code>
        and
        <code>
         multimap
        </code>
        .
       </p>
      </section>
     </section>
     <section>
      <span id="c18-sec-0116">
      </span>
      <h3 id="head-3-412">
       Unordered Associative Containers Or Hash Tables
      </h3>
      <p id="c18-para-0337">
       The Standard Library has support for
       <i>
        unordered associative containers
       </i>
       or
       <i>
        hash tables
       </i>
       . There are four of them:
       <code>
        unordered_map
       </code>
       ,
       <code>
        unordered_multimap
       </code>
       ,
       <code>
        unordered_set
       </code>
       , and
       <code>
        unordered_multiset
       </code>
       . The
       <code>
        map
       </code>
       ,
       <code>
        multimap
       </code>
       ,
       <code>
        set
       </code>
       , and
       <code>
        multiset
       </code>
       containers discussed earlier sort their elements, while these unordered variants do not sort their elements.
      </p>
      <section>
       <span id="c18-sec-0117">
       </span>
       <h4 id="head-4-300">
        Hash Functions
       </h4>
       <p id="c18-para-0338">
        The unordered associative containers are hash tables. That is because the implementation makes use of
        <i>
         hash functions
        </i>
        . The implementation usually consists of some kind of array where each element in the array is called a
        <i>
         bucket
        </i>
        . Each bucket has a specific numerical index like 0, 1, 2, up until the last bucket. A hash function transforms a key into a
        <i>
         hash value
        </i>
        , which is then transformed into a
        <i>
         bucket index
        </i>
        . The value associated with that key is then stored in that bucket.
       </p>
       <p id="c18-para-0339">
        The result of a hash function is not always unique. The situation in which two or more keys hash to the same bucket index is called a
        <i>
         collision
        </i>
        . A collision can occur when different keys result in the same hash value or when different hash values transform to the same bucket index. There are many approaches to handling collisions, including quadratic re-hashing and linear chaining, among others. If you are interested, consult one of the references in the “Algorithms and Data Structures” section in
        <a href="b02.xhtml">
         Appendix B
        </a>
        . The Standard Library does not specify which collision-handling algorithm is required, but most current implementations have chosen to resolve collisions by linear chaining. With linear chaining, buckets do not directly contain the data values associated with the keys but contain a pointer to a linked list. This linked list contains all the data values for that specific bucket.
        <a href="#c18-fig-0001" id="R_c18-fig-0001">
         Figure 18.1
        </a>
        shows how this works.
       </p>
       <span aria-label="745" epub:type="pagebreak" id="Page_745" role="doc-pagebreak">
       </span>
       <figure>
        <img alt="A diagram illustrates a process. On the left, there is a column key that has five names Marc G, Nicholas S, Scott K, John D, and Johan G. Include hash function and hash values to the bucket index. On the far right, there is another column named buckets with indices ranging from 000 to 255." class="center" src="../images\images/c18f001.png"/>
        <figcaption>
         <p>
          <span class="figureLabel">
           <a href="#R_c18-fig-0001" id="c18-fig-0001" role="doc-backlink">
            <b>
             FIGURE 18.1
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p id="c18-para-0340">
        In
        <a href="#c18-fig-0001">
         Figure 18.1
        </a>
        , there are two collisions. The first collision is because applying the hash function to the keys “Marc G.” and “John D.” results in the same hash value that maps to bucket index 128. This bucket then points to a linked list containing the keys “Marc G.” and “John D.” together with their associated data values. The second collision is caused by the hash values for “Scott K.” and “Johan G.” mapping to the same bucket index 129.
       </p>
       <p id="c18-para-0341">
        From
        <a href="#c18-fig-0001">
         Figure 18.1
        </a>
        , it is also clear how lookups based on keys work and what the complexity is. A lookup involves a single hash function call to calculate the hash value. This hash value is then transformed to a bucket index. Once the bucket index is known, one or more equality operations are required to find the right key in the linked list. This shows that lookups can be much faster compared to lookups with normal
        <code>
         map
        </code>
        s, but it all depends on how many collisions there are.
       </p>
       <p id="c18-para-0342">
        The choice of the hash function is important. A hash function that creates no collisions is known as a
        <i>
         perfect hash
        </i>
        . A perfect hash has a lookup time that is constant; a regular hash has a lookup time that is, on average, close to 1, independent of the number of elements. As the number of collisions increases, the lookup time increases, reducing performance. Collisions can be reduced by increasing the basic hash table size, but you need to take cache sizes into account.
       </p>
       <p id="c18-para-0343">
        The C++ standard provides hash functions for pointers and all primitive data types such as
        <code>
         bool
        </code>
        ,
        <code>
         char
        </code>
        ,
        <code>
         int
        </code>
        ,
        <code>
         float
        </code>
        ,
        <code>
         double
        </code>
        , and so on. Hash functions are also provided for several Standard Library classes, such as
        <code>
         optional
        </code>
        ,
        <code>
         bitset
        </code>
        ,
        <code>
         unique_ptr
        </code>
        ,
        <code>
         shared_ptr
        </code>
        ,
        <code>
         string
        </code>
        ,
        <code>
         string_view
        </code>
        ,
        <code>
         vector&lt;bool&gt;
        </code>
        , and more. If there is no standard hash function available for the type of keys you want to use, then you have to implement your own hash function. Creating a perfect hash is a nontrivial exercise, even when the set of keys is fixed and known. It requires deep mathematical analysis. Even creating a non-perfect one, but one that is good enough and has decent performance, is still challenging. It's outside the scope of this book to explain the mathematics behind hash functions in detail. Instead, only an example of a simple hash function is given.
       </p>
       <p>
        <span aria-label="746" epub:type="pagebreak" id="Page_746" role="doc-pagebreak">
        </span>
        The following code demonstrates how to write a custom hash function. The code defines a class
        <code>
         IntWrapper
        </code>
        that just wraps a single integer. An
        <code>
         operator==
        </code>
        is provided because that's a requirement for keys used in unordered associative containers.
       </p>
       <pre id="c18-code-0138"><code>class IntWrapper</code>
<code>{</code>
<code>    public:</code>
<code>        explicit IntWrapper(int i) : m_wrappedInt { i } {}</code>
<code>        int getValue() const { return m_wrappedInt; }</code>
<code>        bool operator==(const IntWrapper&amp;) const = default;<span class="color3">// = default since C++20</span></code>
<code>    private:</code>
<code>        int m_wrappedInt;</code>
<code>};</code></pre>
       <p>
        To write the actual hash function for
        <code>
         IntWrapper
        </code>
        , you write a specialization of the
        <code>
         std::hash
        </code>
        class template for
        <code>
         IntWrapper
        </code>
        . The
        <code>
         std::hash
        </code>
        class template is defined in
        <code>
         &lt;functional&gt;
        </code>
        . This specialization needs an implementation of the function call operator that calculates and returns the hash of a given
        <code>
         IntWrapper
        </code>
        instance. For this example, the request is simply forwarded to the standard hash function for integers:
       </p>
       <pre id="c18-code-0139"><code>namespace std</code>
<code>{</code>
<code>    template&lt;&gt; struct hash&lt;IntWrapper&gt;</code>
<code>    {</code>
<code>        size_t operator()(const IntWrapper&amp; x) const {</code>
<code>            return std::hash&lt;int&gt;{}(x.getValue());</code>
<code>        }</code>
<code>    };</code>
<code>}</code></pre>
       <p id="c18-para-0346">
        Note that you normally are not allowed to put anything in the
        <code>
         std
        </code>
        namespace; however,
        <code>
         std
        </code>
        class template specializations are an exception to this rule. The implementation of the function call operator is just one line. It creates an instance of the standard hash function for integers—
        <code>
         std::hash&lt;int&gt;{}
        </code>
        —and then calls the function call operator on it with
        <code>
         x.getValue()
        </code>
        as argument. Note that this forwarding works in this example because
        <code>
         IntWrapper
        </code>
        contains just one data member, an integer. If the class contained multiple data members, then a hash value would need to be calculated taking all those data members into account; however, those details fall outside the scope of this book.
       </p>
      </section>
      <section>
       <span id="c18-sec-0118">
       </span>
       <h4 id="head-4-301">
        unordered_map
       </h4>
       <p>
        <code>
         unordered_map
        </code>
        is defined in
        <code>
         &lt;unordered_map&gt;
        </code>
        as a class template:
       </p>
       <pre id="c18-code-0140"><code>template &lt;typename Key,</code>
<code>          typename T,</code>
<code>          typename Hash = hash&lt;Key&gt;,</code>
<code>          typename Pred = std::equal_to&lt;Key&gt;,</code>
<code>          typename Alloc = std::allocator&lt;std::pair&lt;const Key, T&gt;&gt;&gt;</code>
<code>    class unordered_map;</code></pre>
       <p>
        There are five template type parameters: the key type, the value type, the hash type, the equality comparator type, and the allocator type. The last three parameters have default values. The most important parameters are the first two. As with
        <code>
         map
        </code>
        s, uniform initialization can be used to initialize
        <span aria-label="747" epub:type="pagebreak" id="Page_747" role="doc-pagebreak">
        </span>
        <span aria-label="748" epub:type="pagebreak" id="Page_748" role="doc-pagebreak">
        </span>
        an
        <code>
         unordered_map
        </code>
        . Iterating over the elements is also similar to
        <code>
         map
        </code>
        s, as shown in the following example.
       </p>
       <pre id="c18-code-0141"><code>unordered_map&lt;int, string&gt; m {</code>
<code>    {1, "Item 1"}, {2, "Item 2"}, {3, "Item 3"}, {4, "Item 4"}</code>
<code>};</code>
<code><span class="color3">// Using C++23 support for formatting/printing ranges.</span></code>
<code>println("{}", m);</code>
<code><span class="color3">// Using structured bindings.</span></code>
<code>for (const auto&amp; [key, value] : m) { print("{} = {}, ", key, value); }</code>
<code>println("");</code>
<code><span class="color3">// Without structured bindings.</span></code>
<code>for (const auto&amp; p : m) { print("{} = {}, ", p.first, p.second); }</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c18-code-0142"><code>{4: "Item 4", 3: "Item 3", 2: "Item 2", 1: "Item 1"}</code>
<code>4 = Item 4, 3 = Item 3, 2 = Item 2, 1 = Item 1,</code>
<code>4 = Item 4, 3 = Item 3, 2 = Item 2, 1 = Item 1,</code></pre>
       <p id="c18-para-0350">
        The following table summarizes the differences between
        <code>
         map
        </code>
        and
        <code>
         unordered_map
        </code>
        . A filled box (
        <img alt="" role="presentation" src="../images\images/square1.png"/>
        ) means the container supports that operation, while an empty box (
        <img alt="" role="presentation" src="../images\images/square.png"/>
        ) means the operation is not supported.
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           OPERATION
          </th>
          <th class="left bgcolor2" scope="col">
           map
          </th>
          <th class="left bgcolor2" scope="col">
           unordered_map
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left">
           <span class="forecolor1">
            at()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            begin()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            begin(n)
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            bucket()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            bucket_count()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            bucket_size()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            cbegin()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            cbegin(n)
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            cend()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            cend(n)
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            clear()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            contains()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            count()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            crbegin()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            crend()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            emplace()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            emplace:hint()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            empty()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            end()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            end(n)
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            equal_range()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            erase()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            extract()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            find()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            insert()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            insert_or_assign()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            insert_range()
           </span>
           (C++23)
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            iterator / const_iterator
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            load_factor()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            local_iterator / const_local_iterator
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            lower_bound()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            max_bucket_count()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            max_load_factor()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            max_size()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            merge()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            operator[]
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            rbegin()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            rehash()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            rend()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            reserve()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            reverse_iterator / const_reverse_iterator
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            size()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            swap()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            try_emplace()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
         </tr>
         <tr>
          <td class="left">
           <span class="forecolor1">
            upper_bound()
           </span>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square1.png"/>
          </td>
          <td class="left bgcolor3">
           <img alt="" role="presentation" src="../images\images/square.png"/>
           <span aria-label="749" epub:type="pagebreak" id="Page_749" role="doc-pagebreak">
           </span>
          </td>
         </tr>
        </tbody>
       </table>
       <p id="c18-para-0352">
        As with
        <code>
         map
        </code>
        , all keys in an
        <code>
         unordered_map
        </code>
        must be unique. The preceding table includes a number of hash-specific member functions. For example,
        <code>
         load_factor()
        </code>
        returns the average number of elements per bucket to give you an indication of the number of collisions. The
        <code>
         bucket_count()
        </code>
        member function returns the number of buckets in the container. It also provides a
        <code>
         local_iterator
        </code>
        and
        <code>
         const_local_iterator
        </code>
        , allowing you to iterate over the elements in a single bucket; however, these may not be used to iterate across buckets. The
        <code>
         bucket(key)
        </code>
        member function returns the index of the bucket that contains the given key;
        <code>
         begin(n)
        </code>
        returns a
        <code>
         local_iterator
        </code>
        referring to the first element in the bucket with index
        <code>
         n
        </code>
        , and
        <code>
         end(n)
        </code>
        returns a
        <code>
         local_iterator
        </code>
        referring to one-past-the-last element in the bucket with index
        <code>
         n
        </code>
        . The example in the next section demonstrates how to use some of these member functions.
       </p>
       <section>
        <span id="c18-sec-0119">
        </span>
        <h5 id="head-5-130">
         unordered_map Example: Phone Book
        </h5>
        <p>
         The following example uses an
         <code>
          unordered_map
         </code>
         to represent a phone book. The name of a person is the key, while the phone number is the value associated with that key.
        </p>
        <pre id="c18-code-0143"><code>void printMap(const auto&amp; m)  <span class="color3">// Abbreviated function template</span></code>
<code>{</code>
<code>    for (auto&amp; [key, value] : m) {</code>
<code>        println("{} (Phone: {})", key, value);</code>
<code>    }</code>
<code>    println("-------");</code>
<code>}</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    <span class="color3">// Create a hash table.</span></code>
<code>    unordered_map&lt;string, string&gt; phoneBook {</code>
<code>        { "Marc G.", "123-456789" },</code>
<code>        { "Scott K.", "654-987321" } };</code>
<code>    printMap(phoneBook);</code>
<code> </code>
<code>    <span class="color3">// Add/remove some phone numbers.</span></code>
<code>    phoneBook.insert(make_pair("John D.", "321-987654"));</code>
<code>    phoneBook["Johan G."] = "963-258147";</code>
<code>    phoneBook["Freddy K."] = "999-256256";</code>
<code>    phoneBook.erase("Freddy K.");</code>
<code>    printMap(phoneBook);</code>
<code> </code>
<code>    <span class="color3">// Find the bucket index for a specific key.</span></code>
<code>    const size_t bucket { phoneBook.bucket("Marc G.") };</code>
<code>    println("Marc G. is in bucket {} containing the following {} names:",</code>
<code>        bucket, phoneBook.bucket_size(bucket));</code>
<code>    <span class="color3">// Get begin and end iterators for the elements in this bucket.</span></code>
<span aria-label="750" epub:type="pagebreak" id="Page_750" role="doc-pagebreak"></span><code>    <span class="color3">// 'auto' is used here. The compiler deduces the type of</span></code>
<code>    <span class="color3">// both as unordered_map&lt;string, string&gt;::const_local_iterator</span></code>
<code>    auto localBegin { phoneBook.cbegin(bucket) };</code>
<code>    auto localEnd { phoneBook.cend(bucket) };</code>
<code>    for (auto iter { localBegin }; iter != localEnd; ++iter) {</code>
<code>        println("\t{} (Phone: {})", iter-&gt;first, iter-&gt;second);</code>
<code>    }</code>
<code>    println("-------");</code>
<code> </code>
<code>    <span class="color3">// Print some statistics about the hash table</span></code>
<code>    println("There are {} buckets.", phoneBook.bucket_count());</code>
<code>    println("Average number of elements in a bucket is {}.",</code>
<code>        phoneBook.load_factor());</code>
<code>}</code></pre>
        <p>
         A possible output is as follows. Note that the output can be different on different systems, because it depends on the implementation of both the hash function and the
         <code>
          unordered_map
         </code>
         itself being used.
        </p>
        <pre id="c18-code-0144"><code>Scott K. (Phone: 654-987321)</code>
<code>Marc G. (Phone: 123-456789)</code>
<code>-------</code>
<code>Scott K. (Phone: 654-987321)</code>
<code>Marc G. (Phone: 123-456789)</code>
<code>Johan G. (Phone: 963-258147)</code>
<code>John D. (Phone: 321-987654)</code>
<code>-------</code>
<code>Marc G. is in bucket 1 containing the following 2 names:</code>
<code>        Scott K. (Phone: 654-987321)</code>
<code>        Marc G. (Phone: 123-456789)</code>
<code>-------</code>
<code>There are 8 buckets.</code>
<code>Average number of elements in a bucket is 0.5</code></pre>
       </section>
      </section>
      <section>
       <span id="c18-sec-0120">
       </span>
       <h4 id="head-4-302">
        unordered_multimap
       </h4>
       <p>
        An
        <code>
         unordered_multimap
        </code>
        is an
        <code>
         unordered_map
        </code>
        that allows multiple elements with the same key. Their interfaces are almost identical, with the following differences:
       </p>
       <ul class="check1" id="c18-list-0017">
        <li id="c18-li-0072">
         <code>
          unordered_multimap
         </code>
         s do not provide
         <code>
          operator[]
         </code>
         and
         <code>
          at()
         </code>
         . The semantics of these do not make sense if there can be multiple elements with a single key.
        </li>
        <li id="c18-li-0073">
         Inserts on
         <code>
          unordered_multimap
         </code>
         s always succeed. Thus, the
         <code>
          unordered_multimap::insert()
         </code>
         member function that adds a single element returns just an
         <code>
          iterator
         </code>
         instead of a
         <code>
          pair
         </code>
         .
        </li>
        <li id="c18-li-0074">
         The
         <code>
          insert_or_assign()
         </code>
         and
         <code>
          try_emplace()
         </code>
         member functions supported by
         <code>
          unordered_map
         </code>
         are not supported by an
         <code>
          unordered_multimap
         </code>
         .
        </li>
       </ul>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c18-para-0356">
           <b>
            NOTE
           </b>
           <code>
            unordered_multimap
           </code>
           <i>
            s allow you to insert identical key/value pairs. If you want to avoid this redundancy, you must check explicitly before inserting a new element
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p id="c18-para-0357">
        <span aria-label="751" epub:type="pagebreak" id="Page_751" role="doc-pagebreak">
        </span>
        As discussed earlier with
        <code>
         multimap
        </code>
        s, looking up elements in
        <code>
         unordered_multimap
        </code>
        s cannot be done using
        <code>
         operator[]
        </code>
        because it is not provided. You can use
        <code>
         find()
        </code>
        , but it returns an iterator referring to any one of the elements with a given key (not necessarily the first element with that key). Instead, it's best to use the
        <code>
         equal_range()
        </code>
        member function, which returns a pair of iterators: one referring to the first element matching a given key, and one referring to one-past-the-last element matching that key. The use of
        <code>
         equal_range()
        </code>
        is the same as discussed for
        <code>
         multimap
        </code>
        s, so you can look at the example given for
        <code>
         multimap
        </code>
        s to see how it works.
       </p>
      </section>
      <section>
       <span id="c18-sec-0122">
       </span>
       <h4 id="head-4-303">
        unordered_set/unordered_multiset
       </h4>
       <p id="c18-para-0358">
        <code>
         &lt;unordered_set&gt;
        </code>
        defines
        <code>
         unordered_set
        </code>
        and
        <code>
         unordered_multiset
        </code>
        , which are similar to
        <code>
         set
        </code>
        and
        <code>
         multiset
        </code>
        , respectively, except that they do not sort their keys but use a hash function. The differences between
        <code>
         unordered_set
        </code>
        and
        <code>
         unordered_map
        </code>
        are similar to the differences between
        <code>
         set
        </code>
        and
        <code>
         map
        </code>
        as discussed earlier in this chapter, so they are not discussed in detail here. Consult a Standard Library Reference for a thorough summary of
        <code>
         unordered_set
        </code>
        and
        <code>
         unordered_multiset
        </code>
        operations.
       </p>
      </section>
     </section>
     <section>
      <span id="c18-sec-0123">
      </span>
      <h3 id="head-3-413">
       <img alt="C++23" src="../images\images/icon1.png"/>
       Flat Set and Flat Map Associative Container Adapters
      </h3>
      <p>
       C++23 introduces the following new container adapters:
      </p>
      <ul class="check1" id="c18-list-0018">
       <li id="c18-li-0075">
        <code>
         std::flat_set
        </code>
        and
        <code>
         flat_multiset
        </code>
        defined in
        <code>
         &lt;flat_set&gt;
        </code>
       </li>
       <li id="c18-li-0076">
        <code>
         std::flat_map
        </code>
        and
        <code>
         flat_multimap
        </code>
        defined in
        <code>
         &lt;flat_map&gt;
        </code>
       </li>
      </ul>
      <p id="c18-para-0361">
       These are adapters providing an associative container interface on top of sequential containers.
       <code>
        flat_set
       </code>
       and
       <code>
        flat_map
       </code>
       require unique keys, just as
       <code>
        set
       </code>
       and
       <code>
        map
       </code>
       , while
       <code>
        flat_multiset
       </code>
       and
       <code>
        flat_multimap
       </code>
       support duplicate keys, just as
       <code>
        multiset
       </code>
       and
       <code>
        multimap
       </code>
       . They all store their data sorted on the keys using
       <code>
        std::less
       </code>
       as the default comparator.
       <code>
        flat_set
       </code>
       and
       <code>
        flat_multiset
       </code>
       provide for fast retrieval of a key, while
       <code>
        flat_map
       </code>
       and
       <code>
        flat_multimap
       </code>
       provide for fast retrieval of a value based on a key. A
       <code>
        flat_set
       </code>
       and a
       <code>
        flat_multiset
       </code>
       require one underlying sequential container to store their keys. A
       <code>
        flat_map
       </code>
       and a
       <code>
        flat_multimap
       </code>
       require two underlying containers, one to store the keys and another one to store the values. The underlying container must support random-access iterators, such as
       <code>
        vector
       </code>
       and
       <code>
        deque
       </code>
       . By default,
       <code>
        vector
       </code>
       is used.
      </p>
      <p id="c18-para-0362">
       All flat associative container adapters have an interface similar to their ordered counterparts, except that the flat container adapters are not
       <i>
        node-based
       </i>
       data structures and thus don't have any concept of node handles as discussed earlier in this chapter in the context of the ordered associative containers. Another difference is that the flat variants provide random-access iterators, while the ordered counterparts provide only bidirectional iterators.
      </p>
      <p id="c18-para-0363">
       With the addition of these flat container adapters, the Standard Library now provides three variants of each associative container type; e.g., there are now three map containers:
       <code>
        map
       </code>
       ,
       <code>
        unordered_map
       </code>
       , and
       <code>
        flat_map
       </code>
       . All three basically work in a similar fashion, but they store their data in drastically different data structures and thus have different time- and space-efficiency. Because the flat associative container adapters store their data sorted in sequential containers, they all have linear time complexity for adding and removing elements, which can potentially be slower than adding and removing elements from ordered and unordered containers. Lookups have logarithmic complexity, just as the ordered associative containers. However, for the flat variants, lookups and especially iteration
       <span aria-label="752" epub:type="pagebreak" id="Page_752" role="doc-pagebreak">
       </span>
       over the elements are more efficient than for the ordered ones because the former store their data in sequential containers and thus have a much more efficient and cache-friendly memory layout. They also need less memory per element compared to the ordered or unordered variants. Which one of the three flavors per type to choose for a specific use case depends on the exact requirements of your use case. If performance is important, then I recommend profiling all three of them to find out which one is best suited for a specific use. Profiling is explained in
       <a href="c29.xhtml">
        Chapter 29
       </a>
       , “Writing Efficient C++.”
      </p>
      <p>
       The flat associative container adapters are often just drop-in replacements for their ordered counterparts. For example, the access control list example from earlier has a data member called
       <code>
        m_allowed
       </code>
       of type
       <code>
        set&lt;string&gt;
       </code>
       , an ordered associative container. The code can easily be changed to use a
       <code>
        flat_set
       </code>
       instead. Two changes are necessary. First, the type of
       <code>
        m_allowed
       </code>
       is changed to the following:
      </p>
      <pre id="c18-code-0145"><code>std::<b>flat_set</b>&lt;std::string&gt; m_allowed;</code></pre>
      <p>
       Second, the return type of
       <code>
        getAllUsers()
       </code>
       is changed to a
       <code>
        flat_set
       </code>
       :
      </p>
      <pre id="c18-code-0146"><code>const std::<b>flat_set</b>&lt;std::string&gt;&amp; getAllUsers() const { return m_allowed; }</code></pre>
      <p id="c18-para-0366">
       Everything else remains the same.
      </p>
     </section>
     <section>
      <span id="c18-sec-0124">
      </span>
      <h3 id="head-3-414">
       Performance of Associative Containers
      </h3>
      <p id="c18-para-0367">
       As is clear from this section, the C++ Standard Library contains several different associative containers. How do you know which one to use for a certain task? If iterating over the contents of an associative container is important for your use case, then the flat associative container adapters have the best performance, because of the way they store their data in continuous memory. If other operations are more important for you, then the unordered associative containers are usually faster compared to the ordered ones. However, if performance is really important, then the only way to decide on the correct container is by benchmarking all of them for your specific use case. Usually, though, you can just pick the one that is easier to work with. To use the ordered versions with your own class types, you must implement comparison operations for your class, while for the unordered versions, you need to write a hash function. The latter is usually harder to implement.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-203">
     <span id="c18-sec-0125">
     </span>
     <h2 id="head-2-203">
      OTHER CONTAINERS
     </h2>
     <p id="c18-para-0368">
      There are several other features of the C++ language and the Standard Library that are somewhat related to containers, including standard C-style arrays,
      <code>
       string
      </code>
      s, streams, and
      <code>
       bitset
      </code>
      .
     </p>
     <section>
      <span id="c18-sec-0126">
      </span>
      <h3 id="head-3-415">
       Standard C-Style Arrays
      </h3>
      <p id="c18-para-0369">
       Recall that raw pointers are bona fide iterators because they support the required operations. This point is more than just a piece of trivia. It means that you can treat standard C-style arrays as Standard Library containers by using pointers to their elements as iterators. Standard C-style arrays, of course, don't provide member functions like
       <code>
        size()
       </code>
       ,
       <code>
        empty()
       </code>
       ,
       <code>
        insert()
       </code>
       , and
       <code>
        erase()
       </code>
       , so they aren't true Standard Library containers. Nevertheless, because they do support iterators through pointers, you can use them in the algorithms described in
       <a href="c20.xhtml">
        Chapter 20
       </a>
       and in some of the member functions described in this chapter.
      </p>
      <p>
       <span aria-label="753" epub:type="pagebreak" id="Page_753" role="doc-pagebreak">
       </span>
       For example, you could copy all the elements of a standard C-style array into a
       <code>
        vector
       </code>
       using the
       <code>
        insert()
       </code>
       member function of a
       <code>
        vector
       </code>
       that takes an iterator range from any container. This
       <code>
        insert()
       </code>
       member function's prototype looks like this:
      </p>
      <pre id="c18-code-0147"><code>template &lt;typename InputIterator&gt; iterator insert(const_iterator position,</code>
<code>    InputIterator first, InputIterator last);</code></pre>
      <p>
       If you want to use a standard C-style
       <code>
        int
       </code>
       array as the source, then the template type parameter
       <code>
        InputIterator
       </code>
       becomes
       <code>
        int*
       </code>
       . Here is a full example:
      </p>
      <pre id="c18-code-0148"><code>const size_t count { 10 };</code>
<code>int values[count];     <span class="color3">// standard C-style array</span></code>
<code><span class="color3">// Initialize each element of the array to the value of its index.</span></code>
<code>for (int i { 0 }; i &lt; count; ++i) { values[i] = i; }</code>
<code> </code>
<code><span class="color3">// Insert the contents of the array at the end of a vector.</span></code>
<code>vector&lt;int&gt; vec;</code>
<code>vec.insert(end(vec), values, values + count);</code>
<code> </code>
<code><span class="color3">// Print the contents of the vector.</span></code>
<code>println("{:n} ", vec);</code></pre>
      <p id="c18-para-0372">
       Note that the iterator referring to the first element of the array is the address of the first element, which is
       <code>
        values
       </code>
       in this case. The name of an array alone is interpreted as the address of the first element. The iterator referring to the end must be one-past-the-last element, so it's the address of the first element plus
       <code>
        count
       </code>
       , or
       <code>
        values+count
       </code>
       .
      </p>
      <p>
       It's easier to use
       <code>
        std::begin()
       </code>
       or
       <code>
        cbegin()
       </code>
       to get an iterator to the first element of a statically allocated C-style array not accessed through pointers, and
       <code>
        std::end()
       </code>
       or
       <code>
        cend()
       </code>
       to get an iterator to one-past-the-last element of such an array. For example, the call to
       <code>
        insert()
       </code>
       in the previous example can be written as follows:
      </p>
      <pre id="c18-code-0149"><code>vec.insert(end(vec), cbegin(values), cend(values));</code></pre>
      <p>
       Starting with C++23, this can be written more elegantly using
       <code>
        append_range()
       </code>
       :
      </p>
      <pre id="c18-code-0150"><code>vec.append_range(values);</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0376">
          <b>
           WARNING
          </b>
          <i>
           Functions such as
          </i>
          <code>
           std::begin()
          </code>
          <i>
           and
          </i>
          <code>
           end()
          </code>
          <i>
           work only on statically allocated C-style arrays not accessed through pointers. They do not work if pointers are involved or with dynamically allocated C-style arrays.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c18-sec-0128">
      </span>
      <h3 id="head-3-416">
       Strings
      </h3>
      <p id="c18-para-0377">
       You can think of a
       <code>
        string
       </code>
       as a sequential container of characters. Thus, it shouldn't be surprising to learn that a C++
       <code>
        string
       </code>
       is a full-fledged sequential container. It has
       <code>
        begin()
       </code>
       and
       <code>
        end()
       </code>
       member functions that return iterators into the
       <code>
        string
       </code>
       ; and it has
       <code>
        insert()
       </code>
       ,
       <code>
        push_back()
       </code>
       ,
       <code>
        erase()
       </code>
       ,
       <code>
        size()
       </code>
       , and
       <code>
        empty()
       </code>
       member functions, and all the rest of the sequential container basics. It resembles a
       <code>
        vector
       </code>
       quite closely, even providing the member functions
       <code>
        reserve()
       </code>
       and
       <code>
        capacity()
       </code>
       .
      </p>
      <p>
       <span aria-label="754" epub:type="pagebreak" id="Page_754" role="doc-pagebreak">
       </span>
       You can use
       <code>
        string
       </code>
       as a Standard Library container just as you would use
       <code>
        vector
       </code>
       . Here is an example:
      </p>
      <pre id="c18-code-0151"><code>string myString;</code>
<code>myString.insert(cend(myString), 'h');</code>
<code>myString.insert(cend(myString), 'e');</code>
<code>myString.push_back('l');</code>
<code>myString.push_back('l');</code>
<code>myString.push_back('o');</code>
<code> </code>
<code>for (const auto&amp; letter : myString) {</code>
<code>    print("{}", letter);</code>
<code>}</code>
<code>println("");</code>
<code> </code>
<code>for (auto it { cbegin(myString) }; it != cend(myString); ++it) {</code>
<code>    print("{}", *it);</code>
<code>}</code>
<code>println("");</code></pre>
      <p id="c18-para-0379">
       In addition to the Standard Library sequential container member functions,
       <code>
        string
       </code>
       s provide a host of useful member functions and
       <code>
        friend
       </code>
       functions. The
       <code>
        string
       </code>
       interface is actually quite a good example of a cluttered interface, one of the design pitfalls discussed in
       <a href="c06.xhtml">
        Chapter 6
       </a>
       , “Designing for Reuse.” The
       <code>
        string
       </code>
       class is discussed in detail in
       <a href="c02.xhtml">
        Chapter 2
       </a>
       .
      </p>
     </section>
     <section>
      <span id="c18-sec-0129">
      </span>
      <h3 id="head-3-417">
       Streams
      </h3>
      <p id="c18-para-0380">
       Input and output streams are not containers in the traditional sense because they do not store elements. However, they can be considered sequences of elements and as such share some characteristics with Standard Library containers. C++ streams do not provide any Standard Library–related member functions directly, but the Standard Library supplies special iterators called
       <code>
        istream_iterator
       </code>
       and
       <code>
        ostream_iterator
       </code>
       that allow you to “iterate” through input and output streams respectively.
       <a href="c17.xhtml">
        Chapter 17
       </a>
       explains how to use them.
      </p>
     </section>
     <section>
      <span id="c18-sec-0130">
      </span>
      <h3 id="head-3-418">
       bitset
      </h3>
      <p id="c18-para-0381">
       A
       <code>
        bitset
       </code>
       is a fixed-length abstraction of a sequence of bits. A bit can represent only two values, 1 and 0, which can be referred to as on/off, true/false, and so on. A
       <code>
        bitset
       </code>
       also uses the terminology
       <i>
        set
       </i>
       and
       <i>
        unset
       </i>
       . You can
       <i>
        toggle
       </i>
       or
       <i>
        flip
       </i>
       a bit from one value to the other.
      </p>
      <p id="c18-para-0382">
       A
       <code>
        bitset
       </code>
       is not a true Standard Library container: it's of fixed size, it's not parametrized on an element type, and it doesn't support iteration. However, it's a useful utility class, which is often lumped with the containers, so a brief introduction is provided here. Consult a Standard Library Reference for a thorough summary of the
       <code>
        bitset
       </code>
       operations.
      </p>
      <p>
       <img alt="C++23" src="../images\images/icon1.png"/>
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c18-para-0384">
          <b>
           NOTE
          </b>
          <i>
           Starting with C++23,
          </i>
          <code>
           bitset
          </code>
          <i>
           is a
          </i>
          <code>
           constexpr
          </code>
          <i>
           class, and so can be used at compile time.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <span aria-label="755" epub:type="pagebreak" id="Page_755" role="doc-pagebreak">
      </span>
      <section>
       <span id="c18-sec-0132">
       </span>
       <h4 id="head-4-304">
        bitset Basics
       </h4>
       <p id="c18-para-0385">
        A
        <code>
         bitset
        </code>
        , defined in
        <code>
         &lt;bitset&gt;
        </code>
        , is parametrized on the number of bits it stores. The default constructor initializes all fields of a
        <code>
         bitset
        </code>
        to 0. An alternative constructor creates a
        <code>
         bitset
        </code>
        from a
        <code>
         string
        </code>
        of
        <code>
         0
        </code>
        and
        <code>
         1
        </code>
        characters.
       </p>
       <p id="c18-para-0386">
        You can adjust the value of individual bits with the
        <code>
         set()
        </code>
        ,
        <code>
         reset()
        </code>
        , and
        <code>
         flip()
        </code>
        member functions, and you can access and set individual fields with an overloaded
        <code>
         operator[]
        </code>
        . Note that
        <code>
         operator[]
        </code>
        on a non-
        <code>
         const
        </code>
        object returns a proxy object to which you can assign a Boolean value, call
        <code>
         flip()
        </code>
        , or complement with
        <code>
         operator~
        </code>
        . You can also access individual fields with the
        <code>
         test()
        </code>
        member function. Bits are accessed using a zero-based index. Finally, you can convert a
        <code>
         bitset
        </code>
        to a
        <code>
         string
        </code>
        of
        <code>
         0
        </code>
        and
        <code>
         1
        </code>
        characters using
        <code>
         to_string()
        </code>
        .
       </p>
       <p>
        Here is a small example:
       </p>
       <pre id="c18-code-0152"><code>bitset&lt;10&gt; myBitset;</code>
<code> </code>
<code>myBitset.set(3);</code>
<code>myBitset.set(6);</code>
<code>myBitset[8] = true;</code>
<code>myBitset[9] = myBitset[3];</code>
<code> </code>
<code>if (myBitset.test(3)) { println("Bit 3 is set!"); }</code>
<code>println("{}", myBitset.to_string());</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c18-code-0153"><code>Bit 3 is set!</code>
<code>1101001000</code></pre>
       <p id="c18-para-0389">
        Note that the leftmost character in the output
        <code>
         string
        </code>
        is the highest numbered bit. This corresponds to our intuitions about binary number representations, where the low-order bit representing 2
        <sup>
         0
        </sup>
        = 1 is the rightmost bit in the printed representation.
       </p>
      </section>
      <section>
       <span id="c18-sec-0133">
       </span>
       <h4 id="head-4-305">
        Bitwise Operators
       </h4>
       <p>
        In addition to the basic bit manipulation routines, a
        <code>
         bitset
        </code>
        provides implementations of all the bitwise operators:
        <code>
         &amp;
        </code>
        ,
        <code>
         |
        </code>
        ,
        <code>
         ^
        </code>
        ,
        <code>
         ~
        </code>
        ,
        <code>
         &lt;&lt;
        </code>
        ,
        <code>
         &gt;&gt;
        </code>
        ,
        <code>
         &amp;=
        </code>
        ,
        <code>
         |=
        </code>
        ,
        <code>
         ^=
        </code>
        ,
        <code>
         &lt;&lt;=
        </code>
        , and
        <code>
         &gt;&gt;=
        </code>
        . They behave just as they would on a “real” sequence of bits. Here is an example:
       </p>
       <pre id="c18-code-0154"><code>auto str1 { "0011001100" };</code>
<code>auto str2 { "0000111100" };</code>
<code>bitset&lt;10&gt; bitsOne { str1 };</code>
<code>bitset&lt;10&gt; bitsTwo { str2 };</code>
<code> </code>
<code>auto bitsThree { bitsOne &amp; bitsTwo };</code>
<code>println("{}", bitsThree.to_string());</code>
<code>bitsThree &lt;&lt;= 4;</code>
<code>println("{}", bitsThree.to_string());</code></pre>
       <p>
        The output of the program is as follows:
       </p>
       <pre id="c18-code-0155"><code>0000001100</code>
<code>0011000000</code></pre>
      </section>
      <span aria-label="756" epub:type="pagebreak" id="Page_756" role="doc-pagebreak">
      </span>
      <section>
       <span id="c18-sec-0134">
       </span>
       <h4 id="head-4-306">
        bitset Example: Representing Cable Channels
       </h4>
       <p id="c18-para-0392">
        One possible use of
        <code>
         bitset
        </code>
        s is tracking channels of cable subscribers. Each subscriber could have a
        <code>
         bitset
        </code>
        of channels associated with their subscription, with set bits representing the channels to which they actually subscribe. This system could also support “packages” of channels, also represented as
        <code>
         bitset
        </code>
        s, which represent commonly subscribed combinations of channels.
       </p>
       <p>
        The following
        <code>
         CableCompany
        </code>
        class is a simple example of this model. It uses two
        <code>
         map
        </code>
        s, both mapping
        <code>
         string
        </code>
        s to
        <code>
         bitset
        </code>
        s. One stores the cable packages, while the other stores subscriber information.
       </p>
       <pre id="c18-code-0156"><code>export class CableCompany final</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Number of supported channels.</span></code>
<code>        static constexpr std::size_t NumChannels { 10 };</code>
<code>        <span class="color3">// Adds package with the channels specified as a bitset to the database.</span></code>
<code>        void addPackage(const std::string&amp; packageName,</code>
<code>            const std::bitset&lt;NumChannels&gt;&amp; channels);</code>
<code>        <span class="color3">// Adds package with the channels specified as a string to the database.</span></code>
<code>        void addPackage(const std::string&amp; packageName,            const std::string&amp; channels);</code>
<code>        <span class="color3">// Removes the specified package from the database.</span></code>
<code>        void removePackage(const std::string&amp; packageName);</code>
<code>        <span class="color3">// Retrieves the channels of a given package.</span></code>
<code>        <span class="color3">// Throws out_of_range if the package name is invalid.</span></code>
<code>        const std::bitset&lt;NumChannels&gt;&amp; getPackage(</code>
<code>            const std::string&amp; packageName) const;</code>
<code>        <span class="color3">// Adds customer to database with initial channels found in package.</span></code>
<code>        <span class="color3">// Throws out_of_range if the package name is invalid.</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is already known.</span></code>
<code>        void newCustomer(const std::string&amp; name, const std::string&amp; package);</code>
<code>        <span class="color3">// Adds customer to database with given initial channels.</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is already known.</span></code>
<code>        void newCustomer(const std::string&amp; name,</code>
<code>            const std::bitset&lt;NumChannels&gt;&amp; channels);</code>
<code>        <span class="color3">// Adds the channel to the customer's profile.</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is unknown.</span></code>
<code>        void addChannel(const std::string&amp; name, int channel);</code>
<code>        <span class="color3">// Removes the channel from the customer's profile.</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is unknown.</span></code>
<code>        void removeChannel(const std::string&amp; name, int channel);</code>
<code>        <span class="color3">// Adds the specified package to the customer's profile.</span></code>
<code>        <span class="color3">// Throws out_of_range if the package name is invalid.</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is unknown.</span></code>
<code>        void addPackageToCustomer(const std::string&amp; name,</code>
<code>            const std::string&amp; package);</code>
<code>        <span class="color3">// Removes the specified customer from the database.</span></code>
<code>        void deleteCustomer(const std::string&amp; name);</code>
<code>        <span class="color3">// Retrieves the channels to which a customer subscribes.</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is unknown.</span></code>
<code>        const std::bitset&lt;NumChannels&gt;&amp; getCustomerChannels(</code>
<code>            const std::string&amp; name) const;</code>
<span aria-label="757" epub:type="pagebreak" id="Page_757" role="doc-pagebreak"></span><code>    private:</code>
<code>        <span class="color3">// Retrieves the channels for a customer. (non-const)</span></code>
<code>        <span class="color3">// Throws invalid_argument if the customer is unknown.</span></code>
<code>        std::bitset&lt;NumChannels&gt;&amp; getCustomerChannelsHelper(</code>
<code>            const std::string&amp; name);</code>
<code> </code>
<code>        using MapType = std::map&lt;std::string, std::bitset&lt;NumChannels&gt;&gt;;</code>
<code>        MapType m_packages, m_customers;</code>
<code>};</code></pre>
       <p>
        Here are the implementations of all member functions, with comments explaining the code:
       </p>
       <pre id="c18-code-0157"><code>void CableCompany::addPackage(const string&amp; packageName,</code>
<code>    const bitset&lt;NumChannels&gt;&amp; channels)</code>
<code>{</code>
<code>    m_packages.emplace(packageName, channels);</code>
<code>}</code>
<code> </code>
<code>void CableCompany::addPackage(const string&amp; packageName, const string&amp; channels)</code>
<code>{</code>
<code>    addPackage(packageName, bitset&lt;NumChannels&gt; { channels });</code>
<code>}</code>
<code> </code>
<code>void CableCompany::removePackage(const string&amp; packageName)</code>
<code>{</code>
<code>    m_packages.erase(packageName);</code>
<code>}</code>
<code> </code>
<code>const bitset&lt;CableCompany::NumChannels&gt;&amp; CableCompany::getPackage(</code>
<code>    const string&amp; packageName) const</code>
<code>{</code>
<code>    <span class="color3">// Get an iterator to the specified package.</span></code>
<code>    if (auto it { m_packages.find(packageName) }; it != end(m_packages)) {</code>
<code>        <span class="color3">// Found package. Note that 'it' is an iterator to a name/bitset pair.</span></code>
<code>        <span class="color3">// The bitset is the second field.</span></code>
<code>        return it-&gt;second;</code>
<code>    }</code>
<code>    throw out_of_range { format("Invalid package '{}'.", packageName) };</code>
<code>}</code>
<code> </code>
<code>void CableCompany::newCustomer(const string&amp; name, const string&amp; package)</code>
<code>{</code>
<code>    <span class="color3">// Get the channels for the given package.</span></code>
<code>    auto&amp; packageChannels { getPackage(package) };</code>
<code>    <span class="color3">// Create the account with the bitset representing that package.</span></code>
<code>    newCustomer(name, packageChannels);</code>
<code>}</code>
<code> </code>
<code>void CableCompany::newCustomer(const string&amp; name,</code>
<code>    const bitset&lt;NumChannels&gt;&amp; channels)</code>
<code>{</code>
<code>    <span class="color3">// Add customer to the customers map.</span></code>
<code>    if (auto [iter, success] { m_customers.emplace(name, channels) }; !success) {</code>
<code>        <span class="color3">// Customer was already in the database. Nothing changed.</span></code>
<code>        throw invalid_argument { format("Duplicate customer '{}'.", name) };</code>
<code>    }</code>
<code>}</code>
<code> </code>
<span aria-label="758" epub:type="pagebreak" id="Page_758" role="doc-pagebreak"></span><code>void CableCompany::addChannel(const string&amp; name, int channel)</code>
<code>{</code>
<code>    <span class="color3">// Get the current channels for the customer.</span></code>
<code>    auto&amp; customerChannels { getCustomerChannelsHelper(name) };</code>
<code>    <span class="color3">// We found the customer; set the channel.</span></code>
<code>    customerChannels.set(channel);</code>
<code>}</code>
<code> </code>
<code>void CableCompany::removeChannel(const string&amp; name, int channel)</code>
<code>{</code>
<code>    <span class="color3">// Get the current channels for the customer.</span></code>
<code>    auto&amp; customerChannels { getCustomerChannelsHelper(name) };</code>
<code>    <span class="color3">// We found this customer; remove the channel.</span></code>
<code>    customerChannels.reset(channel);</code>
<code>}</code>
<code> </code>
<code>void CableCompany::addPackageToCustomer(const string&amp; name, const string&amp; package)</code>
<code>{</code>
<code>    <span class="color3">// Get the channels for the given package.</span></code>
<code>    auto&amp; packageChannels { getPackage(package) };</code>
<code>    <span class="color3">// Get the current channels for the customer.</span></code>
<code>    auto&amp; customerChannels { getCustomerChannelsHelper(name) };</code>
<code>    <span class="color3">// Or-in the package to the customer's existing channels.</span></code>
<code>    customerChannels |= packageChannels;</code>
<code>}</code>
<code> </code>
<code>void CableCompany::deleteCustomer(const string&amp; name)</code>
<code>{</code>
<code>    m_customers.erase(name);</code>
<code>}</code>
<code> </code>
<code>const bitset&lt;CableCompany::NumChannels&gt;&amp; CableCompany::getCustomerChannels(</code>
<code>    const string&amp; name) const</code>
<code>{</code>
<code>    <span class="color3">// Find an iterator to the customer.</span></code>
<code>    if (auto it { m_customers.find(name) }; it != end(m_customers)) {</code>
<code>        <span class="color3">// Found customer. Note that 'it' is an iterator to a name/bitset pair.</span></code>
<code>        <span class="color3">// The bitset is the second field.</span></code>
<code>        return it-&gt;second;</code>
<code>    }</code>
<code>    throw invalid_argument { format("Unknown customer '{}'.", name) };</code>
<code>}</code>
<code> </code>
<code>bitset&lt;CableCompany::NumChannels&gt;&amp; CableCompany::getCustomerChannelsHelper(</code>
<code>    const string&amp; name)</code>
<code>{</code>
<code>    <span class="color3">// Forward to const getCustomerChannels() to avoid code duplication.</span></code>
<code>    return const_cast&lt;bitset&lt;NumChannels&gt;&amp;&gt;(getCustomerChannels(name));</code>
<code>}</code></pre>
       <p>
        Finally, here is a simple program demonstrating how to use the
        <code>
         CableCompany
        </code>
        class:
       </p>
       <pre id="c18-code-0158"><code>CableCompany myCC;</code>
<code>myCC.addPackage("basic",   "1111000000");</code>
<span aria-label="759" epub:type="pagebreak" id="Page_759" role="doc-pagebreak"></span><code>myCC.addPackage("premium", "1111111111");</code>
<code>myCC.addPackage("sports",  "0000100111");</code>
<code> </code>
<code>myCC.newCustomer("Marc G.", "basic");</code>
<code>myCC.addPackageToCustomer("Marc G.", "sports");</code>
<code>println("{}", myCC.getCustomerChannels("Marc G.").to_string());</code>
<code> </code>
<code>try { println("{}", myCC.getCustomerChannels("John").to_string()); }</code>
<code>catch (const exception&amp; e) { println("Error: {}", e.what()); }</code></pre>
       <p>
        The output is as follows:
       </p>
       <pre id="c18-code-0159"><code>1111100111</code>
<code>Error: Unknown customer 'John'.</code></pre>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-204">
     <span id="c18-sec-0135">
     </span>
     <h2 id="head-2-204">
      SUMMARY
     </h2>
     <p id="c18-para-0397">
      This chapter introduced the Standard Library containers. It also presented sample code illustrating a variety of uses for these containers. Ideally, you appreciate the power of
      <code>
       vector
      </code>
      ,
      <code>
       deque
      </code>
      ,
      <code>
       list
      </code>
      ,
      <code>
       forward_list
      </code>
      ,
      <code>
       array
      </code>
      ,
      <code>
       span
      </code>
      ,
      <code>
       mdspan
      </code>
      ,
      <code>
       stack
      </code>
      ,
      <code>
       queue
      </code>
      ,
      <code>
       priority_queue
      </code>
      ,
      <code>
       map
      </code>
      ,
      <code>
       multimap
      </code>
      ,
      <code>
       set
      </code>
      ,
      <code>
       multiset
      </code>
      ,
      <code>
       unordered_map
      </code>
      ,
      <code>
       unordered_multimap
      </code>
      ,
      <code>
       unordered_set
      </code>
      ,
      <code>
       unordered_multiset
      </code>
      ,
      <code>
       flat_map
      </code>
      ,
      <code>
       flat_multimap
      </code>
      ,
      <code>
       flat_set
      </code>
      ,
      <code>
       flat_multiset
      </code>
      ,
      <code>
       string
      </code>
      , and
      <code>
       bitset
      </code>
      . I recommend using these containers as much as possible instead of writing your own.
     </p>
     <p id="c18-para-0398">
      Before we can delve into the true power of the Standard Library with a discussion of its generic algorithms and how they work with the containers discussed in this chapter, we have to explain function pointers, function objects, and lambda expressions. Those are the topics of the next chapter.
     </p>
    </section>
    <section aria-labelledby="head-2-205">
     <span id="c18-sec-0136">
     </span>
     <h2 id="head-2-205">
      EXERCISES
     </h2>
     <p id="c18-para-0399">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <code>
        <a href="http://www.wiley.com/go/proc++6e">
         www.wiley.com/go/proc++6e
        </a>
       </code>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c18-exsec-0001">
      </span>
      <ol class="none">
       <li id="c18-ex-0001">
        <b>
         Exercise 18-1:
        </b>
        This exercise is to practice working with
        <code>
         vector
        </code>
        s. Create a program containing a
        <code>
         vector
        </code>
        of
        <code>
         int
        </code>
        s, called
        <code>
         values
        </code>
        , initialized with the numbers 2 and 5. Next, implement the following operations:
        <ol class="decimal" id="c18-list-0020">
         <li id="c18-li-0078">
          Use
          <code>
           insert()
          </code>
          to insert the numbers 3 and 4 at the correct place in
          <code>
           values
          </code>
          .
         </li>
         <li id="c18-li-0079">
          Create a second
          <code>
           vector
          </code>
          of
          <code>
           int
          </code>
          s initialized with 0 and 1, and then insert the contents of this new
          <code>
           vector
          </code>
          at the beginning of
          <code>
           values
          </code>
          .
         </li>
         <li id="c18-li-0080">
          Create a third
          <code>
           vector
          </code>
          of
          <code>
           int
          </code>
          s. Loop over the elements of
          <code>
           values
          </code>
          in reverse, and insert them in this third
          <code>
           vector
          </code>
          .
         </li>
         <li id="c18-li-0081">
          Print the contents of the third
          <code>
           vector
          </code>
          using
          <code>
           println()
          </code>
          .
         </li>
         <li id="c18-li-0082">
          Print the contents of the third
          <code>
           vector
          </code>
          using a range-based
          <code>
           for
          </code>
          loop.
         </li>
        </ol>
       </li>
       <li id="c18-ex-0002">
        <span aria-label="760" epub:type="pagebreak" id="Page_760" role="doc-pagebreak">
        </span>
        <b>
         Exercise 18-2:
        </b>
        Take your implementation of the
        <code>
         Person
        </code>
        class from Exercise 15-4. Add a new module called
        <code>
         phone_book
        </code>
        , defining a
        <code>
         PhoneBook
        </code>
        class that stores one or more phone numbers as
        <code>
         string
        </code>
        s for a person. Provide member functions to add and remove person's phone numbers to/from a phonebook. Also provide a member function that returns a
        <code>
         vector
        </code>
        with all phone numbers for a given person. Test your implementation in your
        <code>
         main()
        </code>
        function. In your tests, use the user-defined person literal developed in Exercise 15-4.
       </li>
       <li id="c18-ex-0003">
        <b>
         Exercise 18-3:
        </b>
        In Exercise 15-1 you developed your own
        <code>
         AssociativeArray
        </code>
        . Modify the test code in
        <code>
         main()
        </code>
        from that exercise to use one of the Standard Library containers instead.
       </li>
       <li id="c18-ex-0004">
        <b>
         Exercise 18-4:
        </b>
        Write an
        <code>
         average()
        </code>
        function (not a function template) to calculate the average of a sequence of
        <code>
         double
        </code>
        values. Make sure it works with a sequence or subsequence from a
        <code>
         vector
        </code>
        or an
        <code>
         array
        </code>
        . Test your code with both a
        <code>
         vector
        </code>
        and an
        <code>
         array
        </code>
        in your
        <code>
         main()
        </code>
        function.
       </li>
       <li id="c18-ex-0005">
        <b>
         Bonus exercise:
        </b>
        Can you convert your
        <code>
         average()
        </code>
        function into a function template? The function template should only be instantiatable with integral or floating-point types. What effect does it have on your test code in
        <code>
         main()
        </code>
        ?
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
