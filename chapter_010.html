<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   1: Introduction
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_009.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_011.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="1" epub:type="pagebreak" id="pagebreak_1" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0001" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000234">
      1: Introduction
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         The first chapter defines what an application programming interface (API) is with various examples and describes how an API is represented in C++. This chapter details the difference between API development and standard application development and enumerates the benefits of APIs in software development, such as producing more robust code, encouraging code reuse, and enabling parallel development. The various layers of APIs within a modern application are described, with specific reference to a large open source client/server program. The relationship of the terms API and software development kit is explained, as is the relationship among APIs, file formats, and network protocols.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Backward compatibility; Component; Contract; Documentation; File format; Header; Interface; Library; Network protocol; Testing
      </div>
     </section>
     <section>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        What are APIs?
       </h2>
       <p class="textfl" id="p0010">
        An application programming interface (API) provides an abstraction for a problem and specifies how clients should interact with software components that implement a solution to that problem. The components themselves are typically distributed as a software library, allowing them to be used in multiple applications. In essence, APIs define reusable building blocks that allow modular pieces of functionality to be incorporated into end-user applications.
       </p>
       <p class="text" id="p0015">
        An API can be written for yourself, for other engineers in your organization, or for the development community at large. It can be as small as a single function or involve hundreds of classes, methods, free functions, data types, enumerations, and constants. Its implementation can be proprietary or open source. The important underlying concept is that an API is a well-defined interface that provides a specific service to other pieces of software.
       </p>
       <p class="text" id="p0020">
        A modern application is typically built on top of many APIs, where some of these can also depend upon further APIs. This is illustrated in
        <a href="#f0010" id="Bf0010">
         Fig. 1.1
        </a>
        , which shows an example application that directly depends on the API for three libraries (Libraries 1–3), where two of those APIs depend on the API for a further two libraries (Libraries 4–5). For instance, an image viewing application may use an API for loading GIF images, and that API may itself be built upon a lower-level API for compressing and decompressing data.
       </p>
       <p class="text" id="p0025">
        API development is ubiquitous in modern software development. Its purpose is to provide a logical interface to the functionality of a component while also hiding any implementation details. For example, our API for loading GIF images may simply provide a
        <span class="inlinecode">
         LoadImage()
        </span>
        method that accepts a filename and returns a 2D array of pixels. All of the file format and data compression details are hidden behind this simple interface. This concept is also illustrated in
        <a href="#f0010">
         Fig. 1.1
        </a>
        , where client code only accesses an API via its public interface, shown as the dark section at the top of each box.
       </p>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         Contracts and contractors
        </h3>
        <p class="textfl" id="p0030">
         As an analogy, consider the task of building your own home. If you were to build a house entirely on your own, you would need to possess a thorough understanding of architecture, plumbing, electrical wiring, carpentry, masonry, and many other trades. You would also need to perform every task yourself and keep track of the minutest of details for every aspect of the project, such as whether you have enough wood for your
         <a id="p2">
         </a>
         <span aria-label="2" epub:type="pagebreak" id="pagebreak_2" role="doc-pagebreak">
         </span>
         floorboards or whether you have the right fasteners to fit your screws. Finally, because you are the only person working on the project, you can perform only a single task at any point in time and hence the total time to complete the project could be very large.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0010">
          <img alt="image" height="1168" src="../../IMAGES/B9780443222191000234/main.assets/f01-01-9780443222191.jpg" width="1417"/>
          <figcaption class="figleg">
           <a id="cap0010">
           </a>
           <a id="fspara0010">
           </a>
           <span class="fignum">
            <a href="#Bf0010">
             Figure 1.1
            </a>
           </span>
           An application that calls routines from a hierarchy of application programming interfaces (APIs). Each box represents a software library where the
           <i>
            dark section
           </i>
           represents the public interface, or API, for that library while the
           <i>
            white section
           </i>
           represents the hidden implementation behind that API.
          </figcaption>
         </figure>
        </div>
        <p class="text" id="p0035">
         An alternative strategy is to hire professional contractors to perform key tasks for you. You could hire an architect to design the plans for the house, a carpenter for all your woodwork needs, a plumber to install the water pipes and sewage system for your house, and an electrician to set up the power systems. Taking this approach, you negotiate a contract with each of your contractors—telling them what work you want done and agreeing upon a price. They then perform that work for you. If you're lucky, maybe you even have a good friend who is a contractor and they offer you their services for free. With this strategy, you are freed from the need to know everything about all aspects of building a house and instead you can take a higher-level supervisory role to select the best contractors for your purpose and ensure that the work of each individual contractor is combined to produce the vision of your ideal home.
        </p>
        <p class="text" id="p0040">
         The analogy to APIs is probably obvious: the house that you're building equates to a software program that you want to write, and the contractors provide APIs that abstract each of the tasks you need to perform and hide the implementation details of the work involved. Your task then resolves to selecting the appropriate APIs for your application and integrating them into your software. The analogy of having skilled friends who provide contracting services for free is meant to represent the use of freely available open source libraries in contrast to commercial libraries that require a licensing fee. The analogy could even be extended by having some of the contractors employing subcontractors, which corresponds to certain APIs depending upon other APIs to perform their task.
         <a id="p3">
         </a>
        </p>
        <div>
         <span aria-label="3" epub:type="pagebreak" id="pagebreak_3" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0015">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="1569" src="../../IMAGES/B9780443222191000234/main.assets/f01-02-9780443222191.jpg" width="1856"/>
           <figcaption class="figleg">
            <a id="cap0015">
            </a>
            <a id="fspara0015">
            </a>
            <span class="fignum">
             <a href="#Bf0015">
              Figure 1.2
             </a>
            </span>
            Using contractors to perform specialized tasks to build a house.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0045">
         The contractor analogy is a common one in object-oriented programming. Early practitioners in the field talked about an object defining a binding contract for the services or behavior that it provides. An object then implements those services when asked to by a client program, potentially by subcontracting some of the work out to other objects behind the scenes (Snyder, 1986;
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib65" id="bib_65">
          Meyer, 1987
         </a>
         ) (
         <a href="#f0015" id="Bf0015">
          Fig. 1.2
         </a>
         ).
        </p>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         APIs in C++
        </h3>
        <p class="textfl" id="p0050">
         Strictly speaking, an API is simply a description of how to interact with a component. That is, it provides an abstraction and a functional specification for a component. In fact, many software engineers prefer to expand the acronym API as abstract programming interface instead of application programming interface.
        </p>
        <p class="text" id="p0055">
         In C++, this is traditionally embodied as one or more header (
         <span class="inlinecode">
          .h
         </span>
         ) files plus supporting documentation files. However as of C++20, we also have the concept of modules as an alternative to using headers. An implementation for a given API is often represented as a library file that can be linked into end-user applications. This can either be a static library such as a
         <span class="inlinecode">
          .lib
         </span>
         file on Windows or
         <span class="inlinecode">
          .a
         </span>
         on macOS and Linux, or a dynamic library such as a
         <span class="inlinecode">
          .dll
         </span>
         file on Windows,
         <span class="inlinecode">
          .dylib
         </span>
         on macOS, or
         <span class="inlinecode">
          .so
         </span>
         on Linux.
        </p>
        <p class="text" id="p0060">
         A C++ API will therefore generally include the following elements:
        </p>
        <div>
         <ul class="ce_list" id="olist0010">
          <li class="numlist" id="p0065">
           <a id="o0010">
           </a>
           1.
           <b>
            Headers/Modules
           </b>
           : A collection of
           <span class="inlinecode">
            .h
           </span>
           header files or module interface units that define the interface and allow client code to be compiled against that interface.
           <a id="p4">
           </a>
           <span aria-label="4" epub:type="pagebreak" id="pagebreak_4" role="doc-pagebreak">
           </span>
           Open source APIs also include the source code (
           <span class="inlinecode">
            .cpp
           </span>
           files) for the API implementation.
          </li>
          <li class="numlist" id="p0070">
           <a id="o0015">
           </a>
           2.
           <b>
            Libraries
           </b>
           : One or more static or dynamic library files that provide an implementation for the API (e.g.,
           <span class="inlinecode">
            .a
           </span>
           ,
           <span class="inlinecode">
            .lib
           </span>
           ,
           <span class="inlinecode">
            .dll
           </span>
           ,
           <span class="inlinecode">
            .dylib
           </span>
           , etc. files). Clients can link their code against these library files to add the functionality to their applications. (I'll go into more detail about the related terms library, framework, and software development kit [SDK] later in this chapter.)
          </li>
          <li class="numlist" id="p0075">
           <a id="o0020">
           </a>
           3.
           <b>
            Documentation
           </b>
           : Overview information that describes how to use the API, often including automatically generated documentation for all the classes and functions in the API.
          </li>
         </ul>
        </div>
        <p class="text" id="p0080">
         As an example of a well-known API, Microsoft's Windows API (often referred to as the Win32 API) is a collection of C functions, data types, and constants that enable programmers to write applications that run on the Windows platform. This includes functions for file handling, process and thread management, creating graphical user interfaces, talking to networks, and so on.
        </p>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <div class="b1textfl" id="bpar0010">
            <i>
             TIP: An API is a logical interface to a software component that hides the internal details required to implement it.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0085">
         The Win32 API is an example of plain C API rather than a C++ API. While you can use a C API directly from a C++ program, a good example of a specific C++ API is the C++ Standard Library. This contains a set of container classes, iterators for navigating over the elements in those containers, and various algorithms that act on those containers (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib48" id="bib_48">
          Josuttis, 1999
         </a>
         ). For instance, the collection of algorithms includes high-level operations such as
         <span class="inlinecode">
          std::search()
         </span>
         ,
         <span class="inlinecode">
          std::reverse()
         </span>
         ,
         <span class="inlinecode">
          std::sort()
         </span>
         , and
         <span class="inlinecode">
          std::set_intersection()
         </span>
         . The C++ Standard Library therefore presents a logical interface to the task of manipulating collections of elements without exposing any of the internal details about how each algorithm is implemented.
        </p>
       </section>
      </section>
      <section>
       <a id="s0025">
       </a>
       <h2 class="h1hd" id="cesectitle0035">
        What's different about API design?
       </h2>
       <p class="textfl" id="p0090">
        Interfaces are the most important code that a developer writes. That's because problems in an interface are far more costly to fix than problems in the associated implementation code. As a result, the process of developing shared APIs demands more attention than standard application or graphical user interface (GUI) development. Of course, both should involve best design practices; however in the case of API development, these are
        <a id="p5">
        </a>
        <span aria-label="5" epub:type="pagebreak" id="pagebreak_5" role="doc-pagebreak">
        </span>
        critical to its success. Specifically, there are some key differentiating factors of API development:
       </p>
       <div>
        <ol id="ulist0010">
         <li class="bulllist" id="p0095">
          <a id="u0010">
          </a>
          • An API is an interface designed for developers, in much the same way that a GUI is an interface designed for end users. In fact, it's been said that an API is a user interface for programmers (
          <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib4" id="bib_4">
           Arnold, 2005
          </a>
          ). As such, your API could be used by thousands of developers around the world, and it will undoubtedly be used in ways that you never intended (
          <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib99" id="bib_99">
           Tulach, 2008
          </a>
          ). You must anticipate this in your design. A well-designed API can be your organization's biggest asset. Conversely a poor API can create a support nightmare and even turn your users toward your competitors, just as a buggy or difficult-to-use GUI might force an end user to switch to a different application.
         </li>
         <li class="bulllist" id="p0100">
          <a id="u0015">
          </a>
          • Multiple applications can share the same API. In
          <a href="#f0010">
           Fig. 1.1
          </a>
          , I showed that a single application can be composed of multiple APIs. However, any one of those APIs could also be reused in several other applications. This means that while problems in the code for any given application will affect only that one application, errors in an API can affect all applications that depend upon that functionality.
         </li>
         <li class="bulllist" id="p0105">
          <a id="u0020">
          </a>
          • You must strive for backward compatibility whenever you change an API. If you make an incompatible change to your interface, your clients' code may fail to compile, or worse, their code could compile but behave differently or crash intermittently. Imagine the confusion and chaos that would arise if the signature of the
          <span class="inlinecode">
           printf()
          </span>
          function in the standard C library was different for different compilers or platforms. The simple “Hello World” program might not look so simple any more:
         </li>
        </ol>
       </div>
       <div>
        <div class="pageavoid">
         <figure class="fig" id="f0025">
          <img alt="image" height="1528" src="../../IMAGES/B9780443222191000234/main.assets/u01-01-9780443222191.jpg" width="1700"/>
          <figcaption class="figleg">
          </figcaption>
         </figure>
        </div>
       </div>
       <p class="textfl">
        <a id="p6">
        </a>
       </p>
       <section>
        <a id="sf0025">
        </a>
       </section>
       <div>
        <span aria-label="6" epub:type="pagebreak" id="pagebreak_6" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p0110">
        This may seem like a contrived example, but it’s actually not that extreme. Take a look at the standard header files that come with your compiler and you will find declarations that are just as convoluted and inscrutable, or perhaps worse.
       </p>
       <div>
        <ol id="ulist0015">
         <li class="bulllist" id="p0115">
          <a id="u0025">
          </a>
          • Owing to the backward compatibility requirement, it is critical to have a change control process in place. During the normal development process, many developers may fix bugs or add new features to an API. Some of these may be junior engineers who do not fully understand all aspects of good API design. As a result, it's important to hold an API review before releasing a new version of the API. This involves one or more senior engineers checking that all changes to the interface are acceptable, have been made for a valid reason, and are implemented in the best way to maintain backward compatibility. Many open source APIs also enforce a change request process to gain approval for a change before it’s added to the source code.
         </li>
         <li class="bulllist" id="p0120">
          <a id="u0030">
          </a>
          • APIs tend to live for a long time. There can be a large up-front cost to produce a good API because of the extra overhead of planning, design, versioning, and review that are necessary. However, if done well, the long-term cost can be substantially cheaper because you have the ability to make radical changes and improvements to your software without disrupting your clients. That is, your development velocity can be greater because of the increased flexibility that the API affords you.
         </li>
         <li class="bulllist" id="p0125">
          <a id="u0035">
          </a>
          • The need for good documentation is paramount when writing an API, particularly if you don't provide the source code for your implementation. Users can look at your header files to glean how to use it, but this doesn't define the behavior of the API, such as acceptable input values or error conditions. Well-written, consistent, and extensive documentation is therefore imperative for any good API.
         </li>
         <li class="bulllist" id="p0130">
          <a id="u0040">
          </a>
          • The need for automated testing is similarly very high. Of course, you should always test your code, but when you're writing an API you may have hundreds of other developers, and thousands of their users, depending upon the correctness of your code. If you are making major changes to the implementation of your API, you can be more confident that you will not break your clients' programs if you have a thorough suite of regression tests to verify that the API behavior has not changed.
         </li>
        </ol>
       </div>
       <p class="text" id="p0135">
        Writing good APIs is difficult. While the necessary skills are founded upon general software design principles, they also require additional knowledge and development processes to address the points listed earlier. However, the principles and techniques of API design are rarely taught to engineers. Normally, these skills are gained only through experience—by making mistakes and learning empirically what does and does not work (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib38" id="bib_38">
         Henning, 2009
        </a>
        ). This book is an attempt to redress this situation, to distill the strategies of industrial-strength, future-proof API design that have evolved through years of software engineering experience into a comprehensive, practical, and accessible format.
        <a id="p7">
        </a>
        <span aria-label="7" epub:type="pagebreak" id="pagebreak_7" role="doc-pagebreak">
        </span>
       </p>
       <div>
        <aside aria-labelledby="b0015" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0015">
          <div class="b1textfl" id="bpar0015">
           <i>
            TIP: An API describes software used by other engineers to build their applications. As such, it must be well-designed, documented, regression tested, and stable between releases.
           </i>
          </div>
         </div>
        </aside>
       </div>
      </section>
      <section>
       <a id="s0030">
       </a>
       <h2 class="h1hd" id="cesectitle0040">
        Why should you use APIs?
       </h2>
       <p class="textfl" id="p0140">
        The question of why you should care about APIs in your own software projects can be interpreted in two ways:
       </p>
       <div>
        <ul class="ce_list" id="olist0015">
         <li class="numlist" id="p0145">
          <a id="o0025">
          </a>
          1. Why should you design and write your own APIs? Or,
         </li>
         <li class="numlist" id="p0150">
          <a id="o0030">
          </a>
          2. Why should you use APIs from other providers in your applications?
         </li>
        </ul>
       </div>
       <p class="text" id="p0155">
        I'll tackle both perspectives in the following sections as I present the various benefits of using APIs in your projects.
       </p>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         More robust code
        </h3>
        <p class="textfl" id="p0160">
         If you're writing a module to be used by other developers, either for fellow engineers within your organization or for external customers of your library, then it would be a wise investment to create an API for them to access your functionality. Doing so will offer you the following benefits:
        </p>
        <div>
         <ul class="ce_list" id="ulist0020">
          <li class="numlist" id="p0165">
           <a id="u0045">
           </a>
           ⁃
           <b>
            Hides implementation.
           </b>
           By hiding the implementation details of your module, you gain the flexibility to change the implementation at a future date without causing an upheaval for your users. Without doing so, you'll either restrict yourself in terms of the updates you can make to your code or you'll force your users to rewrite their code to adopt new versions of your library. If you make it too onerous for your clients to update to new versions of your software, then it's highly likely that they will either not upgrade at all or look elsewhere for an API that will not be as much work for them to maintain. Good API design can therefore significantly affect the success of your business or project.
          </li>
          <li class="numlist" id="p0170">
           <a id="u0050">
           </a>
           ⁃
           <b>
            Increases longevity.
           </b>
           Over time, systems that expose their implementation details tend to devolve into spaghetti code in which every part of the system depends upon the internal details of other parts of the system. As a result, the system becomes fragile, rigid, immobile, and viscous (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib59" id="bib_59">
            Martin, 2000
           </a>
           ). This often results in organizations having to spend significant effort to evolve the code toward a better design, or simply rewrite it from scratch. By investing in good API design up-front and paying the incremental cost to maintain a coherent design, your software can survive for longer and cost less to maintain in the long run. I'll delve much more deeply into this point at the start of
           <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
            Chapter 4
           </a>
           .
          </li>
          <li class="numlist" id="p0175">
           <a id="u0055">
           </a>
           ⁃
           <b>
            Promotes modularization.
           </b>
           An API is normally devised to address a specific task or use case. As such, APIs tend to define a modular grouping of functionality with a
           <a id="p8">
           </a>
           <span aria-label="8" epub:type="pagebreak" id="pagebreak_8" role="doc-pagebreak">
           </span>
           coherent focus. Developing an application on top of a collection of APIs promotes loosely coupled and modular architectures in which the behavior of one module is not dependent upon the internal details of another module. If you work at a large company, this can have direct benefits for you if you're working on one such modular API. That's because it can be clearer if a bug is due to code that you own or for which another team is responsible. So you can spend less time triaging bugs that are unrelated to your code.
          </li>
          <li class="numlist" id="p0180">
           <a id="u0060">
           </a>
           ⁃
           <b>
            Reduces code duplication.
           </b>
           Code duplication is one of the cardinal sins of software engineering and should be stamped out whenever possible. By keeping all your code's logic behind a strict interface that all clients must use, you centralize the behavior in a single place. Doing so means that you need to update only one place to change the behavior of your API for all of the clients. This can help to remove duplication of implementation code throughout your code base. In fact, many APIs are created after discovering duplicated code and deciding to consolidate it behind a single interface. This is a good thing.
          </li>
          <li class="numlist" id="p0185">
           <a id="u0065">
           </a>
           ⁃
           <b>
            Removes hardcoded assumptions.
           </b>
           Many programs may contain hardcoded values that are copied throughout the code, for example, using the filename
           <span class="inlinecode">
            myprogram.log
           </span>
           whenever data are written to a log file. Instead, APIs can be used to provide access to this information without replicating these constant values across the code base. For example, a
           <span class="inlinecode">
            GetLogFilename()
           </span>
           API call could be used to replace the hardcoded
           <span class="inlinecode">
            “myprogram.log”
           </span>
           string.
          </li>
          <li class="numlist" id="p0190">
           <a id="u0070">
           </a>
           ⁃
           <b>
            Easier to change the implementation.
           </b>
           If you have hidden all the implementation details of your module behind its public interface, then you can change those implementation details without affecting any code that depends upon the API. For example, you might decide to change a file parsing routine to use
           <span class="inlinecode">
            std::string
           </span>
           containers instead of allocating, freeing, and reallocating your own
           <span class="inlinecode">
            char ∗
           </span>
           buffers.
          </li>
          <li class="numlist" id="p0195">
           <a id="u0075">
           </a>
           ⁃
           <b>
            Easier to optimize.
           </b>
           Similarly, with your implementation details successfully hidden, you can optimize the performance of your API without requiring any changes to your clients' code. For example, you could add a caching solution to a method that performs some computationally intensive calculation. This is possible because all attempts to read and write your underlying data are performed via your API, so it becomes much easier to know when you must invalidate your cached result and recomputed the new value.
          </li>
         </ul>
        </div>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         Code reuse
        </h3>
        <p class="textfl" id="p0200">
         Code reuse is the use of existing software to build new software. It's one of the holy grails of modern software development. APIs provide a mechanism to enable code reuse.
        </p>
        <p class="text" id="p0205">
         In the early years of software development, it was common for a company to have to write all code for any application they produced. If the program needed to read GIF
         <a id="p9">
         </a>
         <span aria-label="9" epub:type="pagebreak" id="pagebreak_9" role="doc-pagebreak">
         </span>
         images or parse a text file, the company would have to write all that code in-house. Nowadays, with the proliferation of good commercial and open source libraries, it makes much more sense simply to reuse code that others have written. For example, there are various open source image reading APIs and file format parsing APIs that you can download and use in your applications today. These libraries have been refined and debugged by many developers around the world and have been battle-tested in many other programs.
        </p>
        <p class="text" id="p0210">
         In essence, software development has become a lot more modular with the use of distinct components that form the building blocks of an application and talk together via their published APIs. The benefit of this approach is that you don't need to understand every detail of every software component, in the same way that for the earlier house building analogy you can delegate many details to professional contractors. This can translate into faster development cycles, because you can either reuse existing code or decouple the schedule for various components. It also allows you to concentrate on your core business logic rather than having to spend time reinventing the wheel.
        </p>
        <p class="text" id="p0215">
         One of the difficulties in achieving code reuse, however, is that you must often come up with a more general interface than you originally intended. That's because other clients may have additional expectations or requirements. Effective code reuse therefore follows from a deep understanding of the clients of your software and designing a system that integrates their collective interests with your own.
        </p>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0015">
            <i>
             SIDEBAR: C++ APIs and the Web
            </i>
           </div>
           <div class="b1textfl" id="bpar0020">
            <i>
             The trend toward applications that depend upon third-party APIs is particularly popular in the field of cloud computing. Here, web applications rely more and more on web services (APIs) to provide core functionality. In the case of web mash-ups, the application itself is sometimes simply a repackaging of multiple existing services to provide a new service, such as combining the Google Maps API with a local crimes statistics database to provide a map-based interface to the crime data.
            </i>
           </div>
           <div class="b1text" id="bpar0025">
            <i>
             In fact, it's worth taking a few moments to highlight the importance of C++ API design in web development. A superficial analysis might conclude that server-side web development is confined to scripting languages such as PHP, Perl, or Python (the “P” in the popular LAMP acronym), or .NET languages based upon Microsoft's Active Server Pages technology. This may be true for small-scale web development. However, it is noteworthy that many large-scale web services use a C++ backend to deliver optimal performance.
            </i>
           </div>
           <div class="b1text" id="bpar0030">
            <i>
             In fact, Facebook developed a product called HipHop to convert their PHP code into C++ to improve the performance of their social networking site. The Figma web application also used C++ compiled to WebAssembly to optimize their website. C++ API design therefore has a role to play in scalable web service development. Additionally, if you develop your core APIs in C++, not only can they form a high-performance web service, your code can also be reused to deliver your product in other forms, such as desktop or mobile phone versions.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p10">
         </a>
        </p>
        <div>
         <span aria-label="10" epub:type="pagebreak" id="pagebreak_10" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0220">
         As an aside, one potential explanation for this shift in software development strategy is the result of the forces of globalization (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib32" id="bib_32">
          Friedman, 2007
         </a>
         ;
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib103" id="bib_103">
          Wolf, 2004
         </a>
         ). In effect, the convergence of the Internet, standard network protocols, and web technologies has created a leveling of the software playing field. This has enabled companies and individuals all over the world to create, contribute to, and compete with large complex software projects. This form of globalization promotes an environment where companies and developers anywhere in the world can forge a livelihood out of developing software subsystems. Other organizations in different parts of the world can then build end-user applications by assembling and augmenting these building blocks to solve specific problems. In terms of our focus here, APIs provide the mechanism to enable this globalization and componentization of modern software development.
        </p>
       </section>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         Parallel development
        </h3>
        <p class="textfl" id="p0225">
         Even if you're writing in-house software, your fellow engineers will very likely need to write code that uses your code. If you use good API design techniques, you can simplify their lives, and by extension your own (because you won't have to answer as many questions about how your code works or how to use to it). This becomes even more important if multiple developers are working in parallel on code that depends upon each other.
        </p>
        <p class="text" id="p0230">
         For example, let's say that you are working on a string encryption algorithm that another developer wants to use to write data out to a configuration file. One approach would be to have the other developer wait until you're finished your work. Then they can use it in their file writer module. However, a far more efficient use of time would be for the two of you to meet early on and agree upon an appropriate API. Then you can put that API in place with placeholder functionality that your colleague can start calling immediately, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="949" src="../../IMAGES/B9780443222191000234/main.assets/u01-02-9780443222191.jpg" width="2218"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p11">
         </a>
        </p>
        <section>
         <a id="sf0030">
         </a>
        </section>
        <div>
         <span aria-label="11" epub:type="pagebreak" id="pagebreak_11" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0235">
         You can then provide a simple implementation of these functions, so that at least the module will compile and link. For example, the associated
         <span class="inlinecode">
          .cpp
         </span>
         file might look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0035">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000234/main.assets/u01-03-9780443222191.jpg" width="2082"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0240">
         In this way, your colleague can use this API and proceed with the work without being held up by your progress. For the time being, your API will not actually encrypt any strings, but that's just a minor implementation detail! The important point is that you have a stable interface—a contract—on which you both agree, and that it behaves appropriately, such as
         <span class="inlinecode">
          Decrypt(Encypt("Hello")) == "Hello"
         </span>
         . When you finish your work and update the
         <span class="inlinecode">
          .cpp
         </span>
         file with the correct implementation, your colleague's code will simply work without any further changes required on his or her part.
        </p>
        <p class="text" id="p0245">
         In reality, it's likely that there will be interface issues that you didn't anticipate before you started writing the code and you will probably have to iterate on the API a few times to get it just right. However, for the most part, the two of you can work in parallel with minimal holdups.
        </p>
        <p class="text" id="p0250">
         This approach also encourages test-driven, or test-first, development. By stubbing out the API early on, you can write unit tests to validate the desired functionality and run these continuously to make sure that you haven't broken your contract with your colleague.
        </p>
        <p class="text" id="p0255">
         Scaling this process up to an organizational level, your project could have separate teams that may be remote from each other, even working to different schedules. But by defining each team's dependencies upfront, and creating APIs to model these, each team can work independently and with minimal knowledge of how the other teams are implementing their work behind the API. This efficient use of resources, and the corresponding reduction in redundant communication, can correlate to significant overall cost savings for an organization.
        </p>
       </section>
      </section>
      <section>
       <a id="s0050">
       </a>
       <h2 class="h1hd" id="cesectitle0060">
        When should you avoid APIs?
       </h2>
       <p class="textfl" id="p0260">
        Designing and implementing an API usually requires more work than writing normal application code. That's because the purpose of an API is to provide a robust and stable
        <a id="p12">
        </a>
        <span aria-label="12" epub:type="pagebreak" id="pagebreak_12" role="doc-pagebreak">
        </span>
        interface for other developers to use. As such, the level of quality, planning, documentation, testing, support, and maintenance is far higher for an API than for software that's meant to be used only within a single application.
       </p>
       <p class="text" id="p0265">
        As a result, if you're writing an internal module that doesn't require other clients to communicate with it, then the extra overhead of creating and supporting a stable public interface for your module may not be worth the effort. However, this is not a reason to write sloppy code. Spending the extra time to adhere to the principles of API design will not be wasted effort in the long run.
       </p>
       <p class="text" id="p0270">
        On the flip side of the coin, consider that you're a software developer who wants to use a third-party API in your application. The previous section discussed several reasons why you might want to reuse external APIs in your software. However, there may be cases in which you wish to avoid using a particular API and pay the cost to implement the code yourself, or look for an alternate solution. For example:
       </p>
       <div>
        <ul class="ce_list" id="ulist0025">
         <li class="numlist" id="p0275">
          <a id="u0080">
          </a>
          ⁃
          <b>
           License restrictions.
          </b>
          An API may provide everything you need for functionality, but the license restrictions may be prohibitive for your needs. For example, if you want to use an open source package that's distributed under the GNU General Public License (GPL), then you are required to release any derived works under the GPL as well. This means that using this package in your program would require you to release the entire source code for your application, a constraint that may not be acceptable for a commercial application. Other licenses, such as the GNU Lesser GPL are more permissive and tend to be more common for software libraries. Another licensing aspect is that the dollar cost for a commercial API may be too high for your project, or the licensing terms may be too restrictive, such as requiring a license fee per developer or even per user.
         </li>
         <li class="numlist" id="p0280">
          <a id="u0085">
          </a>
          ⁃
          <b>
           Functionality mismatch.
          </b>
          An API may appear to solve a problem that you have but may do it in a way that doesn't match the constraints or functional requirements of your application. For example, perhaps you're developing an image processing tool and you want to provide a Fourier transform capability. There are many implementations of the fast Fourier transform (FFT) available, but many of these are 1D algorithms, whereas you require a 2D FFT because you are dealing with 2D image data. Additionally, many 2D FFT algorithms work only on data sets with dimensions that are a power of 2 (e.g., 256
          <span title='hsp="0.25"'>
          </span>
          ×
          <span title='hsp="0.25"'>
          </span>
          256 or 512
          <span title='hsp="0.25"'>
          </span>
          ×
          <span title='hsp="0.25"'>
          </span>
          512 pixels). Furthermore, perhaps the API that you found doesn't work on the platforms that you must support, or perhaps it doesn't match the performance criteria that you've specified for your application.
         </li>
         <li class="numlist" id="p0285">
          <a id="u0090">
          </a>
          ⁃
          <b>
           Lack of source code.
          </b>
          Although there are many open source APIs, sometimes the best API for your case may be a closed source offering. That is, only the header files for the interface are made available to you, but the underlying C++ source files are not distributed with the library. This has several important implications. Among these is the fact that if you encounter a bug in the library, you're unable to inspect the source code to understand what might be going wrong. Reading the
          <a id="p13">
          </a>
          <span aria-label="13" epub:type="pagebreak" id="pagebreak_13" role="doc-pagebreak">
          </span>
          source can be a valuable technique for tracking down a bug and potentially discovering a work-around for the issue.
         </li>
        </ul>
       </div>
       <p class="text" id="p0290">
        Furthermore, without access to the source code for an API, you lose the ability to change the source to fix a bug. This means that the schedule for your software project could be adversely affected by unanticipated problems in a third-party API you're using and by the time spent waiting for the owners of that API to address your bug reports and distribute a fixed patch.
       </p>
       <div>
        <ul class="ce_list" id="ulist0030">
         <li class="numlist" id="p0295">
          <a id="u0095">
          </a>
          ⁃
          <b>
           Lack of documentation.
          </b>
          An API may appear to fulfill a need that you have in your application, but if the API has poor or nonexistent documentation, then you may decide to look elsewhere for a solution. Perhaps it's not obvious how to use the API, perhaps you cannot be sure how the API will behave under certain situations, or perhaps you simply don't trust the work of an engineer who hasn't taken the time to explain how their code should be used.
         </li>
        </ul>
       </div>
       <p class="text" id="p0300">
        While I've tried to play devil's advocate here and come up with cases where you don't need to worry about API design, over the course of my career as a software engineer, I've come to appreciate that everything is API design. For example, in a large organization with a lot of internal code, it's tempting to think of everything as just “the code,” because it's easy to change anything you want. But not all code changes should be treated equally. If you don't have strong API boundaries and processes in place, then treating all of your software as one giant ball of code will quickly devolve into chaos. As Alex Martelli phrased it, the worst API is no API at all (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib58" id="bib_58">
         Martelli, 2011
        </a>
        ). If you take one thing from this book, it should be to treat every software problem as an API design problem first and foremost.
       </p>
      </section>
      <section>
       <a id="s0055">
       </a>
       <h2 class="h1hd" id="cesectitle0065">
        API examples
       </h2>
       <p class="textfl" id="p0305">
        APIs are everywhere. Even if you've been programming for only a short amount of time, the chances are that you've written code to use an API or two, and maybe you've also written one yourself.
       </p>
       <section>
        <a id="s0060">
        </a>
        <h3 class="h2hd" id="cesectitle0070">
         Layers of APIs
        </h3>
        <p class="textfl" id="p0310">
         An API can be any size, from a single function to a large collection of classes. It can also provide access to functionality at any architectural level, from low-level operating system (OS) calls all the way up to GUI tool kits. The following list presents various common APIs, many of which you've probably heard of already, to give you an appreciation for how prevalent API development is:
        </p>
        <div>
         <ul class="ce_list" id="ulist0035">
          <li class="numlist" id="p0315">
           <a id="u0100">
           </a>
           ⁃
           <b>
            OS APIs.
           </b>
           Every OS must provide a set of standard APIs to allow programs to access OS-level services. For example, the POSIX API defines functions such as
           <span class="inlinecode">
            fork()
           </span>
           ,
           <span class="inlinecode">
            getpid()
           </span>
           , and
           <span class="inlinecode">
            kill()
           </span>
           for managing UNIX-style processes, whereas Microsoft's
           <a id="p14">
           </a>
           <span aria-label="14" epub:type="pagebreak" id="pagebreak_14" role="doc-pagebreak">
           </span>
           Win32 API includes functions such as
           <span class="inlinecode">
            CreateProcess()
           </span>
           ,
           <span class="inlinecode">
            GetCurrentProcess()
           </span>
           , and
           <span class="inlinecode">
            TerminateProcess()
           </span>
           for managing Windows processes. These are stable low-level APIs that should never change; otherwise many programs could break!
          </li>
          <li class="numlist" id="p0320">
           <a id="u0105">
           </a>
           ⁃
           <b>
            Language APIs.
           </b>
           The C language is supported by the C Standard Library, implemented as the libc library and associated man pages. It includes familiar functions such as
           <span class="inlinecode">
            printf()
           </span>
           ,
           <span class="inlinecode">
            scanf()
           </span>
           , and
           <span class="inlinecode">
            fopen()
           </span>
           . The C++ language also offers the C++ Standard Library, which provides an API for various container classes (e.g.,
           <span class="inlinecode">
            std::string
           </span>
           ,
           <span class="inlinecode">
            std::vector
           </span>
           ,
           <span class="inlinecode">
            std::set
           </span>
           , and
           <span class="inlinecode">
            std::map
           </span>
           ), iterators (e.g.,
           <span class="inlinecode">
            std::vector&lt;double&gt;::iterator
           </span>
           ), and generic algorithms (e.g.,
           <span class="inlinecode">
            std::sort
           </span>
           ,
           <span class="inlinecode">
            std::for_each
           </span>
           , and
           <span class="inlinecode">
            std::set_union
           </span>
           ). For example, the following code snippet uses the C++ Standard Library API to iterate through all elements in a vector and print them out (although in modern code, using
           <span class="inlinecode">
            auto
           </span>
           within a range-based
           <span class="inlinecode">
            for
           </span>
           loop would be simpler):
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000234/main.assets/u01-04-9780443222191.jpg" width="1770"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="ulist0040">
          <li class="numlist" id="p0325">
           <a id="u0110">
           </a>
           ⁃
           <b>
            Image APIs.
           </b>
           Gone are the days when developers needed to write their own image reading and writing routines. There is now a wide range of open source packages out there for you to download and use in your own programs. For example, there's the popular libjpeg library that provides an implementation of a JPEG/JFIF decoder and encoder. There's the extensive libtiff library for reading and writing various flavors of TIFF files. And there's the libpng library for handling PNG format images. All of these libraries define APIs that let you write code to read and write the image formats without having to know anything about the underlying file formats. For example, the follow code snippet uses the libtiff API to find the dimensions of a TIFF image:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000234/main.assets/u01-05-9780443222191.jpg" width="1734"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p15">
         </a>
         <span aria-label="15" epub:type="pagebreak" id="pagebreak_15" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <ul class="ce_list" id="ulist0045">
          <li class="numlist" id="p0330">
           <a id="u0115">
           </a>
           ⁃
           <b>
            3D graphics APIs.
           </b>
           The two classic real-time 3D graphics APIs are OpenGL and DirectX. These let you define 3D objects in terms of small primitives, such as triangles or polygons; specify the surface properties of those primitives, such as color, normal, and texture; and define the environment conditions, such as lights, fog, and clipping panes. Thanks to standard APIs such as these, game developers can write 3D games that will work on graphics cards old and new, from many different manufacturers. That's because each graphics card manufacturer provides drivers that provide the implementation details behind the OpenGL or DirectX API. Before the widespread use of these APIs, a developer had to write a 3D application for a specific piece of graphics hardware, and this program would probably not work on another machine with different graphics hardware. These APIs also enable a host of higher-level scene graph APIs, such as OpenSceneGraph, OpenSG, and OGRE. The following code segment shows the classic example of rendering a triangle, with a different color for each vertex, using the OpenGL API:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000234/main.assets/u01-06-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="ulist0050">
          <li class="numlist" id="p0335">
           <a id="u0120">
           </a>
           ⁃
           <b>
            GUI APIs.
           </b>
           Any application that wants to open its own window needs to use a GUI tool kit. This is an API that provides the ability to create windows, buttons, text fields, dialogues, icons, menus, and so on. The API will normally also provide an event model, to allow the capturing of mouse and keyboard events. Some popular C/C++ GUI APIs include the wxWidgets library, Qt Company's Qt API, GTK+, and X/Motif. It used to be the case that if a company wanted to release an application on more than one platform, such as Windows and Mac, it would have to rewrite the user interface code using a different GUI API for each platform, or it would have to develop its own in-house cross-platform GUI tool kit. However, these days most modern GUI tool kits are available for multiple platforms including Windows, Mac, and Linux, which makes it far easier to write cross-platform applications. As a sample of a modern cross-platform GUI API, the following complete program shows a bare minimum Qt program that pops up a window with a Hello World button:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000234/main.assets/u01-07-9780443222191.jpg" width="1316"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p16">
         </a>
         <span aria-label="16" epub:type="pagebreak" id="pagebreak_16" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0025" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0025">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0020">
            <i>
             SIDEBAR: C++ Standard Library versus Standard Template Library
            </i>
           </div>
           <div class="b1textfl" id="bpar0035">
            <i>
             The C++ Standard Library is the official name of the collection of classes and functions written in the core language and included in the C++ ISO standard.
            </i>
           </div>
           <div class="b1text" id="bpar0040">
            <i>
             There is also the older term Standard Template Library (STL), which refers to the library written by Alexander Stepanov before C++ was standardized.
            </i>
           </div>
           <div class="b1text" id="bpar0045">
            <i>
             Parts of the STL were standardized in the C++ Standard Library, but it's important to note that the two APIs are not the same. I will refer to the C++ Standard Library throughout this book because it’s part of the official ISO standard.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0340">
         Of course, this list is just a brief cross-section of all possible APIs that are out there. You'll also find APIs to let you access data over networks, to parse and generate XML or YAML files, to help you write multithreaded programs, or to solve complex mathematical problems. The point of the list was simply to demonstrate the breadth and depth of APIs that have been developed to help you build your applications, and to give you a flavor for what code based upon these APIs looks like.
        </p>
        <div>
         <aside aria-labelledby="b0030" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0030">
           <div class="b1textfl" id="bpar0050">
            <i>
             TIP: APIs are used everywhere in modern software development, from OS- and language-level APIs to image, audio, graphics, concurrency, network, XML, mathematics, web browsing, or GUI APIs.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         A real-life example
        </h3>
        <p class="textfl" id="p0345">
         The previous list of API examples was purposefully arranged by architectural level to show the range of APIs that you might use when building an application. You will often use APIs from several architectural levels when building a large software product. For example,
         <a href="#f0020" id="Bf0020">
          Fig. 1.3
         </a>
         presents an example architecture diagram for the Second Life Viewer developed by Linden Lab. This is a large open source program that lets users interact
         <a id="p17">
         </a>
         <span aria-label="17" epub:type="pagebreak" id="pagebreak_17" role="doc-pagebreak">
         </span>
         with each other in an online 3D virtual world, with the ability to perform voice chat and text messaging among users. The diagram demonstrates the use and layering of APIs in a large C++ software project.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0020">
          <img alt="image" height="1113" src="../../IMAGES/B9780443222191000234/main.assets/f01-03-9780443222191.jpg" width="2184"/>
          <figcaption class="figleg">
           <a id="cap0020">
           </a>
           <a id="fspara0020">
           </a>
           <span class="fignum">
            <a href="#Bf0020">
             Figure 1.3
            </a>
           </span>
           Architecture diagram for the second life viewer.
           <a id="fspara0025">
           </a>
           <i>
            API
           </i>
           , application programming interface;
           <i>
            APR
           </i>
           , Apache Portable runtime;
           <i>
            OS
           </i>
           , operating system.
          </figcaption>
         </figure>
        </div>
        <p class="text" id="p0350">
         Of note is the layer of internal APIs, by which I mean the set of modules that a company develops in-house for a particular product, or suite of products. Although
         <a href="#f0020">
          Fig. 1.3
         </a>
         simply shows these as a single layer for the purpose of simplicity, the set of internal APIs will form an additional stack of layers, from foundation-level routines that provide an in-house string, dictionary, file IO, threading routines, and so on to APIs that provide the core business logic of the application, all the way up to custom GUI APIs for managing the application's user interface.
        </p>
        <p class="text" id="p0355">
         Obviously,
         <a href="#f0020">
          Fig. 1.3
         </a>
         doesn't provide an exhaustive list of all APIs that are used in this application. It simply shows a few examples for each layer of the architecture. However,
         <a href="#t0010" id="Bt0010">
          Table 1.1
         </a>
         present the set of third-party dependencies for the application, to give you an idea of how many open source and commercial closed source dependencies a contemporary software project is built upon. When you factor in system and OS libraries as well, this list grows even further.
        </p>
       </section>
      </section>
      <section>
       <a id="s0070">
       </a>
       <h2 class="h1hd" id="cesectitle0080">
        Libraries, frameworks, and software development kits
       </h2>
       <p class="textfl" id="p0360">
        I briefly introduced the term library earlier in this chapter. Here I'll go into more details about libraries and discuss some related terms such as framework and SDK.
       </p>
       <p class="text" id="p0365">
        A software library is a collection of data and compiled code for one or more architectures. It's what stores the implementation code for your API and is the artifact that your clients link into their programs. Common types of library include static libraries (e.g.,
        <span class="inlinecode">
         .a
        </span>
        or
        <span class="inlinecode">
         .lib
        </span>
        ), where the library code is linked directly into client code at link time, and dynamic libraries (e.g.,
        <span class="inlinecode">
         .so
        </span>
        ,
        <span class="inlinecode">
         .dll
        </span>
        , or
        <span class="inlinecode">
         .dylib
        </span>
        ), where the library code is loaded and linked
        <a id="p18">
        </a>
        <span aria-label="18" epub:type="pagebreak" id="pagebreak_18" role="doc-pagebreak">
        </span>
        into client code at runtime. Most OSs have a dynamic library search path to influence how they find these files at runtime, and compilers can embed hints into the compiled code about where to find any dynamic library dependencies. I cover these details in Appendix A on Libraries.
       </p>
       <div class="pageavoid">
        <p class="tnum">
         <a href="#Bt0010">
          Table 1.1
         </a>
        </p>
        <table class="tbody" id="t0010">
         <caption class="ttitle">
          <a id="tspara0010">
          </a>
          List of open and closed source application programming interfaces used by second life viewer.
         </caption>
         <thead>
          <tr>
           <th class="tcolhd1" scope="col">
            API
           </th>
           <th class="tcolhd1" scope="col">
            Description
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <th class="tb" scope="row">
            APR
           </th>
           <td class="tb">
            Apache Portable runtime
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Boost
           </th>
           <td class="tb">
            Set of portable C++ source libraries
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            c-ares
           </th>
           <td class="tb">
            Asynchronous DNS resolution library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            cURL
           </th>
           <td class="tb">
            Client URL request library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Expat
           </th>
           <td class="tb">
            Stream-oriented XML Parser
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            FMOD
           </th>
           <td class="tb">
            Commercial audio engine and mp3 stream decoder
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            FreeGLUT
           </th>
           <td class="tb">
            Open source version of the OpenGL Utility tool kit (GLUT)
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            FreeType
           </th>
           <td class="tb">
            Font rasterization engine.
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            glh_linear
           </th>
           <td class="tb">
            C++ OpenGL helper library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Jpeglib
           </th>
           <td class="tb">
            JPEG decoder library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            KDU
           </th>
           <td class="tb">
            Commercial Kakadu (KDU) JPEG-2000 decoder library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Libpng
           </th>
           <td class="tb">
            PNG image library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Llqtwebkit
           </th>
           <td class="tb">
            Qt's WebKit embeddable web browser
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Ogg Vorbis
           </th>
           <td class="tb">
            Compressed audio format library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            OpenGL
           </th>
           <td class="tb">
            3D graphics rendering engine
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Openjpeg
           </th>
           <td class="tb">
            Open-source JPEG-2000 library, alternative to KDU
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            OpenSSL
           </th>
           <td class="tb">
            Secure sockets layer (SSL) library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Quicktime
           </th>
           <td class="tb">
            Library for playing video clips
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Vivox
           </th>
           <td class="tb">
            Commercial voice chat library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Xmlrpc-epi
           </th>
           <td class="tb">
            XML-RPC protocol library
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Zlib
           </th>
           <td class="tb">
            Lossless data compression library
           </td>
          </tr>
         </tbody>
        </table>
       </div>
       <p class="text" id="p0370">
        You may choose to distribute your software only as binary library files and public headers, or you may choose to adopt an open source model where clients can directly build the library files themselves from your source code.
       </p>
       <p class="text" id="p0375">
        A library file is normally accompanied by a set of header files (
        <span class="inlinecode">
         .h
        </span>
        ) that describe the elements of your API (i.e., the classes, functions, templates, enums, namespaces, etc. that make up your interface). These header files are needed for clients to compile their code against your interface. It's also worth noting that C++20 introduced an alternative to the use of headers with the concept of modules, which I will cover in more detail in the chapter on C++ Revisions. Altogether, a library and its associated header files or modules are often referred to as an SDK. An SDK may also include other resources to help you use an API, such as documentation, example source code, and supporting tools.
       </p>
       <p class="text" id="p0380">
        As an example, Apple publishes various iOS APIs for developing applications that run on the iPhone, iPod Touch, and iPad devices. Examples include the UIKit user interface
        <a id="p19">
        </a>
        <span aria-label="19" epub:type="pagebreak" id="pagebreak_19" role="doc-pagebreak">
        </span>
        API, the WebKit API to embed web browser functionality in your applications, and the Core Audio API for audio services. Apple also provides the iOS SDK, which is a downloadable installer that contains the headers and libraries that implement the various iOS APIs. These are the files that you compile and link against to give your programs access to the underlying functionality of the APIs. The iOS SDK includes API documentation, sample code, various templates for Apple's Integrated Development Environment called XCode, and the iPhone Simulator that lets you run iPhone apps on your desktop computer.
       </p>
       <p class="text" id="p0385">
        The term framework can have a few interpretations. On Apple platforms, there is a
        <span class="inlinecode">
         .framework
        </span>
        asset type that is essentially a bundle containing different versions of a library and its associated headers. However, the term can also imply a larger collection of APIs. For example, the Qt Framework is composed of many separate modules that offer different APIs for different tasks. Furthermore, many engineers subscribe to the definition that the key difference between a library and a framework is that a framework uses inversion of control. This means that the framework has some built-in behavior and that you can register code with the framework, but it decides when to call your code. A good example of this is a UI framework in which the framework owns the main event loop, but you can register functions and classes to handle specific events such as button presses. In other words, a library is a collection of functionality that you can call from your code, whereas a framework is a collection of functionality that calls your code.
       </p>
      </section>
      <section>
       <a id="s0075">
       </a>
       <h2 class="h1hd" id="cesectitle0085">
        File formats and network protocols
       </h2>
       <p class="textfl" id="p0390">
        There are several other forms of communication “contracts” that are commonly used in computer applications. One of the most familiar is the file format. This is a way to save in-memory data to a file on disk using a well-known layout of those data. For example, the JPEG File Interchange Format (JFIF) is an image file format for exchanging JPEG-encoded imagery, commonly given the
        <span class="inlinecode">
         .jpg
        </span>
        or
        <span class="inlinecode">
         .jpeg
        </span>
        file extension. The format of a JFIF file header is shown in
        <a href="#t0015" id="Bt0015">
         Table 1.2
        </a>
        .
       </p>
       <p class="text" id="p0395">
        Given the format for a data file, such as this JFIF/JPEG format, any program can read and write image files in the format. This allows the easy interchange of image data among different users and the proliferation of image viewers and tools that can operate on those images.
       </p>
       <p class="text" id="p0400">
        Similarly, client/server applications, peer-to-peer applications, and middleware services work by sending data back and forward using an established protocol, usually over a network socket. For example, the Subversion version control system uses a client/server architecture in which the master repository is stored on the server and individual clients synchronize their local clients with the server (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib84" id="bib_84">
         Rooney, 2005
        </a>
        ). To make this work, the client and the server must agree upon the format of data that are transmitted across the network. This is known as the client/server protocol or line protocol. If the client sends a data stream that does not conform to this protocol, then the server will not be
        <a id="p20">
        </a>
        <span aria-label="20" epub:type="pagebreak" id="pagebreak_20" role="doc-pagebreak">
        </span>
        able to understand the message. It is therefore critical that the specification of the client/server protocol is well-defined and that both the client and server conform to the specification.
       </p>
       <div class="pageavoid">
        <p class="tnum">
         <a href="#Bt0015">
          Table 1.2
         </a>
        </p>
        <table class="tbody" id="t0015">
         <caption class="ttitle">
          <a id="tspara0015">
          </a>
          JPEG File Interchange Format header specification.
         </caption>
         <thead>
          <tr>
           <th class="tcolhd1" scope="col">
            Field
           </th>
           <th class="tcolhd1" scope="col">
            Byte size
           </th>
           <th class="tcolhd1" scope="col">
            Description
           </th>
          </tr>
         </thead>
         <tbody>
          <tr>
           <th class="tb" scope="row">
            APP0 marker
           </th>
           <td class="tb">
            2
           </td>
           <td class="tb">
            Always 0xFFE0
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Length
           </th>
           <td class="tb">
            2
           </td>
           <td class="tb">
            Length of segment excluding APP0 marker
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Identifier
           </th>
           <td class="tb">
            5
           </td>
           <td class="tb">
            Always 0x4A46494600 (“JFIF\0”)
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Version
           </th>
           <td class="tb">
            2
           </td>
           <td class="tb">
            0x0102
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Density units
           </th>
           <td class="tb">
            1
           </td>
           <td class="tb">
            Units for pixel density fields, 0
            <span title='hsp="0.25"'>
            </span>
            =
            <span title='hsp="0.25"'>
            </span>
            no units
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            X density
           </th>
           <td class="tb">
            2
           </td>
           <td class="tb">
            Integer horizontal pixel density
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Y density
           </th>
           <td class="tb">
            2
           </td>
           <td class="tb">
            Integer vertical pixel density
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Thumbnail width (w)
           </th>
           <td class="tb">
            1
           </td>
           <td class="tb">
            Horizontal size of embedded thumbnail
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Thumbnail height (h)
           </th>
           <td class="tb">
            1
           </td>
           <td class="tb">
            Vertical size of embedded thumbnail
           </td>
          </tr>
          <tr>
           <th class="tb" scope="row">
            Thumbnail data
           </th>
           <td class="tb">
            3
            <span title='hsp="0.25"'>
            </span>
            ×
            <span title='hsp="0.25"'>
            </span>
            w
            <span title='hsp="0.25"'>
            </span>
            ×
            <span title='hsp="0.25"'>
            </span>
            h
           </td>
           <td class="tb">
            Uncompressed 24-bit RGB raster data
           </td>
          </tr>
         </tbody>
        </table>
       </div>
       <p class="text" id="p0405">
        Both of these cases are conceptually similar to an API in that they define a standard interface, or specification, for information to be exchanged. Also, any changes to the specification must consider the impact on existing clients. Despite this similarity, file formats and line protocols are not actually APIs because they are not programming interfaces for code that you link into your application. However, a good rule of thumb is that whenever you have a file format or a client/server protocol, you should also have an associated API to manage changes to that specification.
       </p>
       <div>
        <aside aria-labelledby="b0035" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0035">
          <div class="b1textfl" id="bpar0055">
           <i>
            TIP: Whenever you create a file format or client/server protocol, you should also create an API for it. This allows the details of the specification, and any future changes to it, to be centralized and hidden.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <p class="text" id="p0410">
        For example, if you specify a file format for your application's data, you should also write an API to allow reading and writing files in that format. For one thing, this is simply good practice, so that knowledge of the file format is not distributed throughout your application. More importantly, having an API allows you easily to change the file format in the future without having to rewrite any code outside the API implementation. Finally, if you do end up with multiple different versions of a file format, then your API can abstract that complexity away so that it can read and write data in any version of the format, or it can know if the format is written with a newer version of the API and take
        <a id="p21">
        </a>
        <span aria-label="21" epub:type="pagebreak" id="pagebreak_21" role="doc-pagebreak">
        </span>
        appropriate steps. In essence, the actual format of the data on disk becomes a hidden implementation detail with which your application does not need to be concerned. I'll discuss this more when talking about data-driven APIs in the Styles chapter.
       </p>
       <p class="text" id="p0415">
        This advice applies just as well to client/server applications, in which the definition of a common protocol, and a common API to manage that protocol, can allow the client and server teams to work relatively independently of each other. For instance, you may begin using user datagram protocol (UDP) as the transport layer for part of your system but later decide to switch to transmission control protocol (TCP) (as indeed happened with the Second Life code base). If all network access had already been abstracted behind an appropriate API, then such a major implementation change would have little to no impact on the rest of the system.
       </p>
      </section>
      <section>
       <a id="s0080">
       </a>
       <h2 class="h1hd" id="cesectitle0090">
        About this book
       </h2>
       <p class="textfl" id="p0420">
        Now that I've covered the basics of what an API is, and the pros and cons of API development, I'll dive into details such as how to design good APIs, how to implement them efficiently in C++, and how to version them without breaking backward compatibility. The progression of chapters in this book roughly follows the standard evolution of an API, from initial design through implementation, versioning, documentation, and testing.
       </p>
       <p class="text" id="p0425">
        <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
         Chapter 2
        </a>
        :
        <i>
         Qualities
        </i>
       </p>
       <div>
        <ul id="ulist0055">
         <li class="unnumlist" id="p0430">
          <a id="u0125">
          </a>
          I begin the main text with a chapter that answers the question, what is a good API? This will cover a wide gamut of qualities that you should be aware of when designing your APIs, such as information hiding, minimal completeness, and loose coupling. As I do throughout the book, I illustrate these concepts with many C++ source code examples to show how they relate to your own projects.
         </li>
        </ul>
       </div>
       <p class="text" id="p0435">
        <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
         Chapter 3
        </a>
        :
        <i>
         Patterns
        </i>
       </p>
       <div>
        <ul id="ulist0060">
         <li class="unnumlist" id="p0440">
          <a id="u0130">
          </a>
          The next couple of chapters tackle the question, how do you design a good API? Accordingly,
          <a href="../B9780443222191000192/CH0003_81-121_B9780443222191000192.xhtml">
           Chapter 3
          </a>
          looks at some specific design patterns and idioms that are particularly helpful in API design. These include the pimpl idiom, Singleton, Factory Method, Proxy, Adapter, Façade, and Observer.
         </li>
        </ul>
       </div>
       <p class="text" id="p0445">
        <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
         Chapter 4
        </a>
        :
        <i>
         Design
        </i>
       </p>
       <div>
        <ul id="ulist0065">
         <li class="unnumlist" id="p0450">
          <a id="u0135">
          </a>
          Continuing the topic of how to design a good API,
          <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
           Chapter 4
          </a>
          discusses functional requirement gathering and use case modeling to drive the design of a clean and usable interface, as well some techniques of object-oriented analysis and object-oriented design. This chapter includes a discussion on many of the problems that large software projects face. These observations are taken from real-world experiences and provide insight into the issues that arise when doing large-scale API development.
         </li>
        </ul>
       </div>
       <p class="textfl">
        <a id="p22">
        </a>
       </p>
       <div>
        <span aria-label="22" epub:type="pagebreak" id="pagebreak_22" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p0455">
        <a href="../B9780443222191000209/CH0005_179-207_B9780443222191000209.xhtml">
         Chapter 5
        </a>
        :
        <i>
         Styles
        </i>
       </p>
       <div>
        <ul id="ulist0070">
         <li class="unnumlist" id="p0460">
          <a id="u0140">
          </a>
          The next few chapters focus on creating high-quality APIs with C++. This is a deep and complex topic and is, of course, the specific focus of this book. I therefore begin by describing various styles of C and C++ APIs that you could adopt in your projects, such as flat C APIs, object-oriented APIs, template-based APIs, and data-driven APIs.
         </li>
        </ul>
       </div>
       <p class="text" id="p0465">
        <a href="../B9780443222191000106/CH0006_209-250_B9780443222191000106.xhtml">
         Chapter 6
        </a>
        :
        <i>
         C++ Usage
        </i>
       </p>
       <div>
        <ul id="ulist0075">
         <li class="unnumlist" id="p0470">
          <a id="u0145">
          </a>
          Next, I discuss various core C++ language features that can affect good API design. This includes numerous important issues such as good constructor and operator style, namespaces, pointer versus reference parameters, the use of friends, and how to export symbols in a dynamic library. These are best practices that you can use for any version of the C++ standard.
         </li>
        </ul>
       </div>
       <p class="text" id="p0475">
        <a href="../B9780443222191000064/CH0007_251-327_B9780443222191000064.xhtml">
         Chapter 7
        </a>
        :
        <i>
         C++ Revisions
        </i>
       </p>
       <div>
        <ul id="ulist0080">
         <li class="unnumlist" id="p0480">
          <a id="u0150">
          </a>
          Since the initial C++98 ISO standard was published, there have been several revisions to the standard, including C++03, C++11, C++14, C++17, C++20, and C++23. Most of these revisions introduced new features that can affect API design. This chapter focuses on each of these revisions in turn and identifies the API features that you can take advantage of in your own projects.
         </li>
        </ul>
       </div>
       <p class="text" id="p0485">
        <a href="../B9780443222191000052/CH0008_329-365_B9780443222191000052.xhtml">
         Chapter 8
        </a>
        :
        <i>
         Performance
        </i>
       </p>
       <div>
        <ul id="ulist0085">
         <li class="unnumlist" id="p0490">
          <a id="u0155">
          </a>
          In this chapter, I analyze performance issues in APIs and show you how to build high-performing APIs in C++. This involves the use of const references, forward declares, data member clustering, and inlining. I also present various tools that can help you to assess the performance of your code.
         </li>
        </ul>
       </div>
       <p class="text" id="p0495">
        <a href="../B9780443222191000076/CH0009_367-381_B9780443222191000076.xhtml">
         Chapter 9
        </a>
        :
        <i>
         Concurrency
        </i>
       </p>
       <div>
        <ul id="ulist0090">
         <li class="unnumlist" id="p0500">
          <a id="u0160">
          </a>
          The initial C++98 and C++03 standards did not consider how code should behave in a multithreaded environment. With the advent of C++11, the language now has broad support for writing concurrent and parallel code. This chapter covers topics such as data races, race conditions, thread safety, and reentrancy in C++ code.
         </li>
        </ul>
       </div>
       <p class="text" id="p0505">
        <a href="../B9780443222191000027/CH0010_383-414_B9780443222191000027.xhtml">
         Chapter 10
        </a>
        :
        <i>
         Versioning
        </i>
       </p>
       <div>
        <ul id="ulist0095">
         <li class="unnumlist" id="p0510">
          <a id="u0165">
          </a>
          With the foundations of API design in hand, I start to expand into more complex aspects, beginning with API versioning and how to maintain backward compatibility. This is one of the most important—and difficult—aspects of robust API design. Here I will define the various terms backward, forward, functional, source, and binary/application binary interface compatibility, and describe how to evolve an API with minimal impact to your clients.
         </li>
        </ul>
       </div>
       <p class="text" id="p0515">
        <a href="../B9780443222191000155/CH0011_415-442_B9780443222191000155.xhtml">
         Chapter 11
        </a>
        :
        <i>
         Documentation
        </i>
       </p>
       <div>
        <ul id="ulist0100">
         <li class="unnumlist" id="p0520">
          <a id="u0170">
          </a>
          Next, I dedicate a chapter to the topic of API documentation. An API is ill-defined without proper supporting documentation, so I present good techniques for
          <a id="p23">
          </a>
          <span aria-label="23" epub:type="pagebreak" id="pagebreak_23" role="doc-pagebreak">
          </span>
          commenting and documenting your API, with specific examples using the excellent Doxygen tool.
         </li>
        </ul>
       </div>
       <p class="text" id="p0525">
        <a href="../B9780443222191000210/CH0012_443-485_B9780443222191000210.xhtml">
         Chapter 12
        </a>
        :
        <i>
         Testing
        </i>
       </p>
       <div>
        <ul id="ulist0105">
         <li class="unnumlist" id="p0530">
          <a id="u0175">
          </a>
          The use of extensive testing lets you evolve an API with the confidence that you're not breaking your clients' programs. Here I present various types of automated testing, including unit, integration, and performance tests, and present examples of good testing methodologies for you to use in your own projects. This covers topics such as test-driven development, stub and mock objects, testing private code, and contract programming.
         </li>
        </ul>
       </div>
       <p class="text" id="p0535">
        <a href="../B9780443222191000131/CH0013_487-500_B9780443222191000131.xhtml">
         Chapter 13
        </a>
        :
        <i>
         Objective-C and Swift
        </i>
       </p>
       <div>
        <ul id="ulist0110">
         <li class="unnumlist" id="p0540">
          <a id="u0180">
          </a>
          The Objective-C and Swift programming languages have become the de facto mechanisms to develop apps for Apple's ecosystem of products. But you may also want to integrate your C++ code into these apps. I will therefore cover how Objective-C++ and C++ code can coexist and how a C++ API can be accessed from Swift code.
         </li>
        </ul>
       </div>
       <p class="text" id="p0545">
        <a href="../B978044322219100012X/CH0014_501-531_B978044322219100012X.xhtml">
         Chapter 14
        </a>
        :
        <i>
         Scripting
        </i>
       </p>
       <div>
        <ul id="ulist0115">
         <li class="unnumlist" id="p0550">
          <a id="u0185">
          </a>
          In addition to integrating your C++ code into other compiled languages, you may wish to integrate it into different scripting languages, perhaps so that power users of your application can write scripts to perform custom actions. I therefore talk about how to create script bindings for a C++ API so that it can be called from languages such as Python and Ruby.
         </li>
        </ul>
       </div>
       <p class="text" id="p0555">
        <a href="../B9780443222191000040/CH0015_533-564_B9780443222191000040.xhtml">
         Chapter 15
        </a>
        :
        <i>
         Extensibility
        </i>
       </p>
       <div>
        <ul id="ulist0120">
         <li class="unnumlist" id="p0560">
          <a id="u0190">
          </a>
          Another advanced topic is that of user extensibility: creating an API that allows programmers to write custom C++ plug-ins that extend the basic functionality you ship with the API. This can be a critical mechanism to promote adoption of your API and to help it survive in the long term. Additionally, I cover how to create extensible interfaces using inheritance and templates.
         </li>
        </ul>
       </div>
       <p class="text" id="p0565">
        Appendix A:
        <i>
         Libraries
        </i>
       </p>
       <div>
        <ul id="ulist0125">
         <li class="unnumlist" id="p0570">
          <a id="u0195">
          </a>
          The book concludes with an appendix on how to create static and dynamic libraries. You must be able to create libraries for your code to be used by others. Also, there are interface design issues to consider when creating dynamic libraries, such as the set of symbols that you export publicly. So I discuss the differences between static and shared libraries and demonstrate how you can make your compiler produce these libraries to allow the reuse of your code in other applications.
         </li>
        </ul>
       </div>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
