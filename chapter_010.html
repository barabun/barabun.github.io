<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   YOUR FIRST BIGGER C++ PROGRAM
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_009.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_011.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c01_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <section aria-labelledby="head-2-53" class="calibre2">
     <section class="calibre2">
      <section class="calibre2">
       <h4 class="calibre29" id="head-4-36">
        The Range-Based for Loop
       </h4>
       <p class="calibre13" id="c01-para-0348">
        The
        <i class="calibre18">
         range-based
        </i>
        <code class="calibre21">
         for
        </code>
        loop is the fourth looping mechanism. It allows for easy iteration over elements of a container. This type of loop works for C-style arrays, initializer lists (discussed later in this chapter), and any type that supports
        <code class="calibre21">
         begin()
        </code>
        and
        <code class="calibre21">
         end()
        </code>
        functions returning iterators (see
        <a class="calibre5" href="c17.xhtml">
         Chapter 17
        </a>
        ), such as
        <code class="calibre21">
         std::array
        </code>
        ,
        <code class="calibre21">
         vector
        </code>
        , and all other Standard Library containers discussed in
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        , “Standard Library Containers.”
       </p>
       <p class="calibre13">
        The following example first defines an
        <code class="calibre21">
         array
        </code>
        of four integers. The range-based
        <code class="calibre21">
         for
        </code>
        loop then iterates over a
        <i class="calibre18">
         copy
        </i>
        of every element in this
        <code class="calibre21">
         array
        </code>
        and prints out each value. To iterate over the elements themselves
        <i class="calibre18">
         without making copies
        </i>
        , use a reference variable, as discussed later in this chapter.
       </p>
       <pre class="calibre26" id="c01-code-0169"><code class="calibre21">array arr { 1, 2, 3, 4 };</code>
<code class="calibre21">for (int i : arr) { println("{}", i); }</code></pre>
       <span aria-label="43" class="calibre20" epub:type="pagebreak" id="Page_43" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0078">
        </span>
        <h5 class="calibre35" id="head-5-5">
         Initializers for Range-Based for Loops
        </h5>
        <p class="calibre13">
         You can use initializers with range-based
         <code class="calibre21">
          for
         </code>
         loops, similar to initializers for
         <code class="calibre21">
          if
         </code>
         and
         <code class="calibre21">
          switch
         </code>
         statements. The syntax is as follows:
        </p>
        <pre class="calibre26" id="c01-code-0170"><code class="calibre21">for (<b class="calibre14">&lt;initializer&gt;;</b> &lt;range-declaration&gt; : &lt;range-expression&gt;) { 
&lt;body&gt; }</code></pre>
        <p class="calibre13">
         Any variables introduced in the
         <code class="calibre21">
          &lt;initializer&gt;
         </code>
         are available only in the &lt;range-declaration&gt;, the
         <code class="calibre21">
          &lt;range-expression&gt;
         </code>
         and in the
         <code class="calibre21">
          &lt;body&gt;
         </code>
         . They are not available outside the range-based
         <code class="calibre21">
          for
         </code>
         loop. Here is an example:
        </p>
        <pre class="calibre26" id="c01-code-0171"><code class="calibre21">for (array arr { 1, 2, 3, 4 }; int i : arr) { println("{}", i); }</code></pre>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0079">
      </span>
      <h3 class="calibre27" id="head-3-81">
       Initializer Lists
      </h3>
      <p class="calibre13">
       Initializer lists are defined in
       <code class="calibre21">
        &lt;initializer_list&gt;
       </code>
       and make it easy to write functions that can accept a variable number of arguments. The
       <code class="calibre21">
        std::initializer_list
       </code>
       type is a class template, and so it requires you to specify the type of elements in the list between angle brackets, similar to how you specify the type of elements stored in a
       <code class="calibre21">
        vector
       </code>
       . The following example shows how to use an initializer list:
      </p>
      <pre class="calibre26" id="c01-code-0172"><code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">int sum(initializer_list&lt;int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int total { 0 };</code>
<code class="calibre21">    for (int value : values) {</code>
<code class="calibre21">        total += value;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return total;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       By accepting an initializer list of integers as a parameter, the function
       <code class="calibre21">
        sum()
       </code>
       can be called with a
       <i class="calibre18">
        braced initializer
       </i>
       of integers as argument. The body of the function uses a range-based
       <code class="calibre21">
        for
       </code>
       loop to accumulate the total sum. This function can be used as follows:
      </p>
      <pre class="calibre26" id="c01-code-0173"><code class="calibre21">int a { sum({ 1, 2, 3 }) };</code>
<code class="calibre21">int b { sum({ 10, 20, 30, 40, 50, 60 }) };</code></pre>
      <p class="calibre13">
       Initializer lists are type safe. All elements in such a list must be of the same type. For the
       <code class="calibre21">
        sum()
       </code>
       function shown here, all elements of the initializer list must be integers. Trying to call it with a
       <code class="calibre21">
        double
       </code>
       , as shown next, results in a compilation error or warning stating that converting from
       <code class="calibre21">
        double
       </code>
       to
       <code class="calibre21">
        int
       </code>
       requires narrowing.
      </p>
      <pre class="calibre26" id="c01-code-0174"><code class="calibre21">int c { sum({ 1, 2, &lt;b&gt;3.0&lt;/b&gt; }) };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0080">
      </span>
      <h3 class="calibre27" id="head-3-82">
       Strings in C++
      </h3>
      <p class="calibre13">
       There are two ways to work with strings in C++:
      </p>
      <ul class="check" id="c01-list-0012">
       <li class="calibre9" id="c01-li-0049">
        <b class="calibre14">
         The C style:
        </b>
        Representing strings as arrays of characters
       </li>
       <li class="calibre9" id="c01-li-0050">
        <b class="calibre14">
         The C++ style:
        </b>
        Wrapping a C-style representation in an easier-to-use and safer string type
       </li>
      </ul>
      <p class="calibre13">
       <span aria-label="44" class="calibre20" epub:type="pagebreak" id="Page_44" role="doc-pagebreak">
       </span>
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       provides a detailed discussion. For now, the only thing you need to know is that the C++
       <code class="calibre21">
        std::string
       </code>
       type is defined in &lt;
       <code class="calibre21">
        string
       </code>
       &gt; and that you can use a C++
       <code class="calibre21">
        string
       </code>
       almost like a basic type. The following example shows that
       <code class="calibre21">
        string
       </code>
       s can be used just like character arrays:
      </p>
      <pre class="calibre26" id="c01-code-0175"><code class="calibre21">string myString { "Hello, World" };</code>
<code class="calibre21">println("The value of myString is {}", myString);</code>
<code class="calibre21">println("The second letter is {}", myString[1]);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0081">
      </span>
      <h3 class="calibre27" id="head-3-83">
       C++ as an Object-Oriented Language
      </h3>
      <p class="calibre13" id="c01-para-0357">
       If you are a C programmer, you may have viewed the features covered so far in this chapter as convenient additions to the C language. As the name C++ implies, in many ways the language is just a “better C.” There is one major point that this view overlooks: unlike C, C++ is an object-oriented language.
      </p>
      <p class="calibre13" id="c01-para-0358">
       Object-oriented programming (OOP) is a different, arguably more natural, way to write code. If you are used to procedural languages such as C or Pascal, don't worry.
       <a class="calibre5" href="c05.xhtml">
        Chapter 5
       </a>
       , “Designing with Classes,” covers all the background information you need to know to shift your mindset to the object-oriented paradigm. If you already know the theory of OOP, the rest of this section will get you up to speed (or refresh your memory) on basic C++ object syntax.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0082">
       </span>
       <h4 class="calibre29" id="head-4-37">
        Defining Classes
       </h4>
       <p class="calibre13" id="c01-para-0359">
        A
        <i class="calibre18">
         class
        </i>
        defines the characteristics of an object. In C++, classes are usually defined and exported from a module interface file (
        <code class="calibre21">
         .cppm
        </code>
        ), while their definitions can either be directly in the same module interface file or in a corresponding module implementation file (
        <code class="calibre21">
         .cpp
        </code>
        ).
        <a class="calibre5" href="c11.xhtml">
         Chapter 11
        </a>
        discusses modules in depth.
       </p>
       <p class="calibre13" id="c01-para-0360">
        A basic class definition for an airline ticket class is shown in the following example. The class can calculate the price of the ticket based on the number of miles in the flight and whether the customer is a member of the Elite Super Rewards Program.
       </p>
       <p class="calibre13" id="c01-para-0361">
        The definition begins by declaring the class name. Inside a set of curly braces, the
        <i class="calibre18">
         data members
        </i>
        (properties) of the class and its
        <i class="calibre18">
         member functions
        </i>
        (behaviors) are declared. Each data member and member function is associated with a particular access level:
        <code class="calibre21">
         public
        </code>
        ,
        <code class="calibre21">
         protected
        </code>
        , or
        <code class="calibre21">
         private
        </code>
        . These labels can occur in any order and can be repeated. Members that are
        <code class="calibre21">
         public
        </code>
        can be accessed from outside the class, while members that are
        <code class="calibre21">
         private
        </code>
        cannot be accessed from anywhere outside the class. Members that are
        <code class="calibre21">
         protected
        </code>
        can be accessed by derived classes, explained in detail in
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        in the context of inheritance. It's recommended to make all your data members
        <code class="calibre21">
         private
        </code>
        , and if needed, to give access to them with
        <code class="calibre21">
         public
        </code>
        or
        <code class="calibre21">
         protected
        </code>
        getters to retrieve data from an object and
        <code class="calibre21">
         public
        </code>
        or
        <code class="calibre21">
         protected
        </code>
        setters to set data for an object. This way, you can easily change the representation of your data while keeping the
        <code class="calibre21">
         public
        </code>
        /
        <code class="calibre21">
         protected
        </code>
        interface the same.
       </p>
       <p class="calibre13">
        Remember, when writing a module interface file, don't forget to use an
        <code class="calibre21">
         export module
        </code>
        declaration to specify which module you are writing, and don't forget to explicitly export the types you want to make available to users of your module.
       </p>
       <pre class="calibre26" id="c01-code-0176"><code class="calibre21">export module airline_ticket;</code>
<code class="calibre21"> </code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<span aria-label="45" class="calibre20" epub:type="pagebreak" id="Page_45" role="doc-pagebreak"></span><code class="calibre21">export class AirlineTicket</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        AirlineTicket();</code>
<code class="calibre21">        ˜AirlineTicket();</code>
<code class="calibre21"> </code>
<code class="calibre21">        double calculatePriceInDollars();</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::string getPassengerName();</code>
<code class="calibre21">        void setPassengerName(std::string name);</code>
<code class="calibre21"> </code>
<code class="calibre21">        int getNumberOfMiles();</code>
<code class="calibre21">        void setNumberOfMiles(int miles);</code>
<code class="calibre21"> </code>
<code class="calibre21">        bool hasEliteSuperRewardsStatus();</code>
<code class="calibre21">        void setHasEliteSuperRewardsStatus(bool status);</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_passengerName;</code>
<code class="calibre21">        int m_numberOfMiles;</code>
<code class="calibre21">        bool m_hasEliteSuperRewardsStatus;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c01-para-0363">
        This book follows the convention to prefix each data member of a class with a lowercase
        <code class="calibre21">
         m
        </code>
        followed by an underscore, such as
        <code class="calibre21">
         m_passengerName
        </code>
        .
       </p>
       <p class="calibre13" id="c01-para-0364">
        The member function that has the same name as the class with no return type is a
        <i class="calibre18">
         constructor
        </i>
        . It is automatically called when an object of the class is created. The member function with a tilde (~) character followed by the class name is a
        <i class="calibre18">
         destructor
        </i>
        . It is automatically called when an object is destroyed.
       </p>
       <p class="calibre13">
        The
        <code class="calibre21">
         .cppm
        </code>
        module interface file defines the class, while the implementations of the member functions in this example are in a
        <code class="calibre21">
         .cpp
        </code>
        module implementation file. This source file starts with the following module declaration to tell the compiler that this is a source file for the
        <code class="calibre21">
         airline_ticket
        </code>
        module:
       </p>
       <pre class="calibre26" id="c01-code-0177"><code class="calibre21">module airline_ticket;</code></pre>
       <p class="calibre13">
        There are several ways to initialize data members of a class. One way is to use a
        <i class="calibre18">
         constructor initializer
        </i>
        , which follows a colon after the constructor header. Here is the
        <code class="calibre21">
         AirlineTicket
        </code>
        constructor with a constructor initializer:
       </p>
       <pre class="calibre26" id="c01-code-0178"><code class="calibre21">AirlineTicket::AirlineTicket()</code>
<code class="calibre21">    : m_passengerName { "Unknown Passenger" }</code>
<code class="calibre21">    , m_numberOfMiles { 0 }</code>
<code class="calibre21">    , m_hasEliteSuperRewardsStatus { false }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        A second option is to put the initializations in the body of the constructor, as shown here:
       </p>
       <pre class="calibre26" id="c01-code-0179"><code class="calibre21">AirlineTicket::AirlineTicket()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Initialize data members.</span></code>
<code class="calibre21">    m_passengerName = "Unknown Passenger";</code>
<code class="calibre21">    m_numberOfMiles = 0;</code>
<code class="calibre21">    m_hasEliteSuperRewardsStatus = false;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        However, if the constructor is only initializing data members without doing anything else, then there is actually no real need for a constructor because data members can be initialized directly inside a
        <span aria-label="46" class="calibre20" epub:type="pagebreak" id="Page_46" role="doc-pagebreak">
        </span>
        class definition, also known as
        <i class="calibre18">
         in-class initializers
        </i>
        . For example, instead of writing an
        <code class="calibre21">
         AirlineTicket
        </code>
        constructor, you can modify the data members in the class definition to initialize them as follows:
       </p>
       <pre class="calibre26" id="c01-code-0180"><code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_passengerName { "Unknown Passenger" };</code>
<code class="calibre21">        int m_numberOfMiles { 0 };</code>
<code class="calibre21">        bool m_hasEliteSuperRewardsStatus { false };</code></pre>
       <p class="calibre13" id="c01-para-0369">
        If your class additionally needs to perform some other types of initializations, such as opening a file, allocating memory, and so on, then you still need to write a constructor to handle those initializations.
       </p>
       <p class="calibre13">
        Here is the destructor for the
        <code class="calibre21">
         AirlineTicket
        </code>
        class:
       </p>
       <pre class="calibre26" id="c01-code-0181"><code class="calibre21">AirlineTicket::~AirlineTicket()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Nothing to do in terms of cleanup</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0371">
        This destructor doesn't do anything and can simply be removed from this class. It is just shown here so you know the syntax of destructors. Destructors are required if you need to perform some cleanup, such as closing files, freeing memory, and so on.
        <a class="calibre5" href="c08.xhtml">
         Chapters 8
        </a>
        , “Gaining Proficiency with Classes and Objects,” and
        <a class="calibre5" href="c09.xhtml">
         9
        </a>
        discuss destructors in more detail.
       </p>
       <p class="calibre13">
        The definitions of the other
        <code class="calibre21">
         AirlineTicket
        </code>
        class member functions are shown here:
       </p>
       <pre class="calibre26" id="c01-code-0182"><code class="calibre21">double AirlineTicket::calculatePriceInDollars()</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (hasEliteSuperRewardsStatus()) {</code>
<code class="calibre21">        <span class="color">// Elite Super Rewards customers fly for free!</span></code>
<code class="calibre21">        return 0;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">// The cost of the ticket is the number of miles times 0.1.</span></code>
<code class="calibre21">    <span class="color">// Real airlines probably have a more complicated formula!</span></code>
<code class="calibre21">    return getNumberOfMiles() * 0.1;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">string AirlineTicket::getPassengerName() { return m_passengerName; }</code>
<code class="calibre21">void AirlineTicket::setPassengerName(string name) { m_passengerName = name; }</code>
<code class="calibre21"> </code>
<code class="calibre21">int AirlineTicket::getNumberOfMiles() { return m_numberOfMiles; }</code>
<code class="calibre21">void AirlineTicket::setNumberOfMiles(int miles) { m_numberOfMiles = miles; }</code>
<code class="calibre21"> </code>
<code class="calibre21">bool AirlineTicket::hasEliteSuperRewardsStatus()</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_hasEliteSuperRewardsStatus;</code>
<code class="calibre21">}</code>
<code class="calibre21">void AirlineTicket::setHasEliteSuperRewardsStatus(bool status)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_hasEliteSuperRewardsStatus = status;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        As mentioned in the beginning of this section, it's also possible to put the member function implementations directly in the module interface file. The syntax is as follows:
       </p>
       <pre class="calibre26" id="c01-code-0183"><code class="calibre21">export class AirlineTicket</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<span aria-label="47" class="calibre20" epub:type="pagebreak" id="Page_47" role="doc-pagebreak"></span><code class="calibre21">        double calculatePriceInDollars()</code>
<code class="calibre21">        {</code>
<code class="calibre21">            if (hasEliteSuperRewardsStatus()) { return 0; }</code>
<code class="calibre21">            return getNumberOfMiles() * 0.1;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::string getPassengerName() { return m_passengerName; }</code>
<code class="calibre21">        void setPassengerName(std::string name) { m_passengerName = name; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        int getNumberOfMiles() { return m_numberOfMiles; }</code>
<code class="calibre21">        void setNumberOfMiles(int miles) { m_numberOfMiles = miles; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        bool hasEliteSuperRewardsStatus() { return m_hasEliteSuperRewardsStatus; }</code>
<code class="calibre21">        void setHasEliteSuperRewardsStatus(bool status)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_hasEliteSuperRewardsStatus = status;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_passengerName { "Unknown Passenger" };</code>
<code class="calibre21">        int m_numberOfMiles { 0 };</code>
<code class="calibre21">        bool m_hasEliteSuperRewardsStatus { false };</code>
<code class="calibre21">};</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0083">
       </span>
       <h4 class="calibre29" id="head-4-38">
        Using Classes
       </h4>
       <p class="calibre13">
        To use the
        <code class="calibre21">
         AirlineTicket
        </code>
        class, you first need to import its module:
       </p>
       <pre class="calibre26" id="c01-code-0184"><code class="calibre21">import airline_ticket;</code></pre>
       <p class="calibre13">
        The following sample program makes use of the class. This example shows the creation of a stack-based
        <code class="calibre21">
         AirlineTicket
        </code>
        object:
       </p>
       <pre class="calibre26" id="c01-code-0185"><code class="calibre21">AirlineTicket myTicket;</code>
<code class="calibre21">myTicket.setPassengerName("Sherman T. Socketwrench");</code>
<code class="calibre21">myTicket.setNumberOfMiles(700);</code>
<code class="calibre21">double cost { myTicket.calculatePriceInDollars() };</code>
<code class="calibre21">println("This ticket will cost ${}", cost);</code></pre>
       <p class="calibre13" id="c01-para-0376">
        The
        <code class="calibre21">
         AirlineTicket
        </code>
        example exposes you to the general syntax for creating and using classes. Of course, there is much more to learn, and that's the topic of
        <a class="calibre5" href="c08.xhtml">
         Chapters 8
        </a>
        ,
        <a class="calibre5" href="c09.xhtml">
         9
        </a>
        , and
        <a class="calibre5" href="c10_split_000.xhtml">
         10
        </a>
        .
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0084">
      </span>
      <h3 class="calibre27" id="head-3-84">
       Scope Resolution
      </h3>
      <p class="calibre13" id="c01-para-0377">
       As a C++ programmer, you need to familiarize yourself with the concept of a
       <i class="calibre18">
        scope
       </i>
       , which defines where an item is visible. Every name in your program, including variable, function, and class names, is in a certain scope. You create scopes with namespaces, function definitions, blocks delimited by curly braces, and class definitions. Variables that are initialized in the initialization statement of
       <code class="calibre21">
        for
       </code>
       loops and range-based
       <code class="calibre21">
        for
       </code>
       loops are scoped to that
       <code class="calibre21">
        for
       </code>
       loop and are not visible outside the
       <code class="calibre21">
        for
       </code>
       loop. Similarly, variables initialized in an initializer for
       <code class="calibre21">
        if
       </code>
       or
       <code class="calibre21">
        switch
       </code>
       statements are scoped to that
       <code class="calibre21">
        if
       </code>
       or
       <code class="calibre21">
        switch
       </code>
       statement and are not visible outside that statement. When you try to access a variable, function, or class, the name is first looked up in the nearest enclosing scope, then the parent scope, and so forth, up to the
       <i class="calibre18">
        global scope
       </i>
       . Any name not in a namespace, function, block delimited by curly braces, or class is assumed to be in the global scope. If it is not found in the global scope, at that point the compiler generates an undefined symbol error.
      </p>
      <p class="calibre13">
       <span aria-label="48" class="calibre20" epub:type="pagebreak" id="Page_48" role="doc-pagebreak">
       </span>
       Sometimes names in scopes hide identical names in other scopes. Other times, the scope you want is not part of the default scope resolution from that particular line in the program. If you don't want the default scope resolution for a name, you can qualify the name with a specific scope using the scope resolution operator
       <code class="calibre21">
        ::
       </code>
       . The following example demonstrates this. The example defines a class
       <code class="calibre21">
        Demo
       </code>
       with a
       <code class="calibre21">
        get()
       </code>
       member function, a
       <code class="calibre21">
        get()
       </code>
       function that is globally scoped, and a
       <code class="calibre21">
        get()
       </code>
       function that is in the
       <code class="calibre21">
        NS
       </code>
       namespace.
      </p>
      <pre class="calibre26" id="c01-code-0186"><code class="calibre21">class Demo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        int get() { return 5; }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int get() { return 10; }</code>
<code class="calibre21"> </code>
<code class="calibre21">namespace NS</code>
<code class="calibre21">{</code>
<code class="calibre21">    int get() { return 20; }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The global scope is unnamed, but you can access it specifically by using the scope resolution operator by itself (with no name prefix). The different
       <code class="calibre21">
        get()
       </code>
       functions can be called as follows. In this example, the code itself is in the
       <code class="calibre21">
        main()
       </code>
       function, which is always in the global scope:
      </p>
      <pre class="calibre26" id="c01-code-0187"><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Demo d;</code>
<code class="calibre21">    println("{}", d.get());      <span class="color">// prints 5</span></code>
<code class="calibre21">    println("{}", NS::get());    <span class="color">// prints 20</span></code>
<code class="calibre21">    println("{}", ::get());      <span class="color">// prints 10</span></code>
<code class="calibre21">    println("{}", get());        <span class="color">// prints 10</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       If the earlier namespace called
       <code class="calibre21">
        NS
       </code>
       is defined as an
       <i class="calibre18">
        unnamed / anonymous namespace
       </i>
       , that is, a namespace without a name as follows:
      </p>
      <pre class="calibre26" id="c01-code-0188"><code class="calibre21"><b class="calibre14">namespace</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    int get() { return 20; }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       then the following line will cause a compilation error about ambiguous name resolution because you would have a
       <code class="calibre21">
        get()
       </code>
       defined in the global scope, and another
       <code class="calibre21">
        get()
       </code>
       defined in the unnamed namespace.
      </p>
      <pre class="calibre26" id="c01-code-0189"><code class="calibre21">println("{}", get());</code></pre>
      <p class="calibre13">
       The same error occurs if you add the following
       <code class="calibre21">
        using
       </code>
       directive right before the
       <code class="calibre21">
        main()
       </code>
       function:
      </p>
      <pre class="calibre26" id="c01-code-0190"><code class="calibre21">using namespace NS;</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0085">
      </span>
      <h3 class="calibre27" id="head-3-85">
       Uniform Initialization
      </h3>
      <p class="calibre13">
       Before C++11, initialization of types was not always uniform. For example, take the following definitions of a circle, once as a structure, and once as a class:
      </p>
      <pre class="calibre26" id="c01-code-0191"><span aria-label="49" class="calibre20" epub:type="pagebreak" id="Page_49" role="doc-pagebreak"></span><code class="calibre21">struct CircleStruct</code>
<code class="calibre21">{</code>
<code class="calibre21">    int x, y;</code>
<code class="calibre21">    double radius;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">class CircleClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        CircleClass(int x, int y, double radius)</code>
<code class="calibre21">            : m_x { x }, m_y { y }, m_radius { radius } {}</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_x, m_y;</code>
<code class="calibre21">        double m_radius;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       In pre-C++11, initialization of a variable of type
       <code class="calibre21">
        CircleStruct
       </code>
       and a variable of type
       <code class="calibre21">
        CircleClass
       </code>
       looked different:
      </p>
      <pre class="calibre26" id="c01-code-0192"><code class="calibre21">CircleStruct myCircle1 = { 10, 10, 2.5 };</code>
<code class="calibre21">CircleClass myCircle2(10, 10, 2.5);</code></pre>
      <p class="calibre13" id="c01-para-0385">
       For the structure version, you can use the
       <code class="calibre21">
        {…}
       </code>
       syntax. However, for the class version, you needed to call the constructor using function notation:
       <code class="calibre21">
        (…)
       </code>
       .
      </p>
      <p class="calibre13">
       Since C++11, you can more uniformly use the
       <code class="calibre21">
        {…}
       </code>
       syntax to initialize types, as follows:
      </p>
      <pre class="calibre26" id="c01-code-0193"><code class="calibre21">CircleStruct myCircle3 = { 10, 10, 2.5 };</code>
<code class="calibre21">CircleClass myCircle4 = { 10, 10, 2.5 };</code></pre>
      <p class="calibre13">
       The definition of
       <code class="calibre21">
        myCircle4
       </code>
       automatically calls the constructor of
       <code class="calibre21">
        CircleClass
       </code>
       . Even the use of the equal sign is optional, so the following are identical:
      </p>
      <pre class="calibre26" id="c01-code-0194"><code class="calibre21">CircleStruct myCircle5 { 10, 10, 2.5 };</code>
<code class="calibre21">CircleClass myCircle6 { 10, 10, 2.5 };</code></pre>
      <p class="calibre13">
       As another example, in the section “
       <a class="calibre5" href="c01_split_000.xhtml#c01-sec-0039">
        Structs
       </a>
       ” earlier in this chapter, an
       <code class="calibre21">
        Employee
       </code>
       structure is initialized as follows:
      </p>
      <pre class="calibre26" id="c01-code-0195"><code class="calibre21">Employee anEmployee;</code>
<code class="calibre21">anEmployee.firstInitial = 'J';</code>
<code class="calibre21">anEmployee.lastInitial = 'D';</code>
<code class="calibre21">anEmployee.employeeNumber = 42;</code>
<code class="calibre21">anEmployee.salary = 80'000;</code></pre>
      <p class="calibre13">
       With uniform initialization, this can be rewritten as follows:
      </p>
      <pre class="calibre26" id="c01-code-0196"><code class="calibre21">Employee anEmployee { 'J', 'D', 42, 80'000 };</code></pre>
      <p class="calibre13">
       Uniform initialization is not limited to structures and classes. You can use it to initialize almost anything in C++. For example, the following code initializes all four variables with the value 3:
      </p>
      <pre class="calibre26" id="c01-code-0197"><code class="calibre21">int a = 3;</code>
<code class="calibre21">int b(3);</code>
<code class="calibre21">int c = { 3 };  <span class="color">// Uniform initialization</span></code>
<code class="calibre21">int d { 3 };    <span class="color">// Uniform initialization</span></code></pre>
      <p class="calibre13">
       <span aria-label="50" class="calibre20" epub:type="pagebreak" id="Page_50" role="doc-pagebreak">
       </span>
       Uniform initialization can be used to perform zero-initialization of variables; you just specify an empty set of curly braces, as shown here:
      </p>
      <pre class="calibre26" id="c01-code-0198"><code class="calibre21">int e { };      <span class="color">// Uniform initialization, e will be 0</span></code></pre>
      <p class="calibre13">
       This syntax can also be used with structures. If you create an instance of the
       <code class="calibre21">
        Employee struct
       </code>
       as follows, then its data members are default initialized, which, for primitive types such as
       <code class="calibre21">
        char
       </code>
       and
       <code class="calibre21">
        int
       </code>
       , means they'll contain whatever random data is left in memory:
      </p>
      <pre class="calibre26" id="c01-code-0199"><code class="calibre21">Employee anEmployee;</code></pre>
      <p class="calibre13">
       However, if you create the instance as follows, then all data members are zero initialized:
      </p>
      <pre class="calibre26" id="c01-code-0200"><code class="calibre21">Employee anEmployee { };</code></pre>
      <p class="calibre13">
       A benefit of using uniform initialization is that it prevents
       <i class="calibre18">
        narrowing
       </i>
       . When using the old-style assignment syntax to initialize variables, C++ implicitly performs narrowing, as shown here:
      </p>
      <pre class="calibre26" id="c01-code-0201"><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    int x = 3.14;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       For the statement in
       <code class="calibre21">
        main()
       </code>
       , C++ automatically truncates 3.14 to 3 before assigning it to
       <code class="calibre21">
        x
       </code>
       <code class="calibre21">
       </code>
       . Some compilers
       <i class="calibre18">
        might
       </i>
       issue a warning about this narrowing, while others won't. In any case, narrowing conversions should not go unnoticed, as they might cause subtle or not so subtle bugs. With uniform initialization, the assignment to
       <code class="calibre21">
        x
       </code>
       <code class="calibre21">
       </code>
       <i class="calibre18">
        must
       </i>
       generate a compilation error if your compiler fully conforms to the C++11 standard:
      </p>
      <pre class="calibre26" id="c01-code-0202"><code class="calibre21">int x { 3.14 };    <span class="color">// Error because narrowing</span></code></pre>
      <p class="calibre13" id="c01-para-0396">
       If a narrowing cast is what you need, I recommend using the
       <code class="calibre21">
        gsl::narrow_cast()
       </code>
       function available in the Guidelines Support Library (GSL).
      </p>
      <p class="calibre13">
       Uniform initialization can also be used in the constructor initializer to initialize arrays that are members of a class.
      </p>
      <pre class="calibre26" id="c01-code-0203"><code class="calibre21">class MyClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">         MyClass()            : m_array { 0, 1, 2, 3 }        {        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_array[4];</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Uniform initialization can be used with the Standard Library containers as well—such as
       <code class="calibre21">
        std::vector
       </code>
       , already demonstrated earlier in this chapter.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0399">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Considering all these benefits, it is recommended to use uniform initialization over using the assignment syntax to initialize variables. Hence, this book uses uniform initialization wherever possible
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <span aria-label="51" class="calibre20" epub:type="pagebreak" id="Page_51" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0087">
       </span>
       <h4 class="calibre29" id="head-4-39">
        Designated Initializers
       </h4>
       <p class="calibre13">
        <i class="calibre18">
         Designated initializers
        </i>
        initialize data members of aggregates using their name. An
        <i class="calibre18">
         aggregate type
        </i>
        is an object of an array type, or an object of a structure or class that satisfies the following restrictions: only
        <code class="calibre21">
         public
        </code>
        data members, no user-declared or inherited constructors, no
        <code class="calibre21">
         virtual
        </code>
        functions (see
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        ), and no
        <code class="calibre21">
         virtual
        </code>
        ,
        <code class="calibre21">
         private
        </code>
        , or
        <code class="calibre21">
         protected
        </code>
        base classes (see
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        ). A designated initializer starts with a dot followed by the name of a data member. Designated initializers must be in the same order as the declaration order of the data members. Mixing designated initializers and non-designated initializers is not allowed. Any data members that are not initialized using a designated initializer are initialized with their default values, which means the following:
       </p>
       <ul class="check" id="c01-list-0013">
        <li class="calibre9" id="c01-li-0051">
         Data members that have an in-class initializer will get that value.
        </li>
        <li class="calibre9" id="c01-li-0052">
         Data members that do not have an in-class initializer are zero initialized.
        </li>
       </ul>
       <p class="calibre13">
        Let's take a look at a slightly modified
        <code class="calibre21">
         Employee
        </code>
        structure. This time the
        <code class="calibre21">
         salary
        </code>
        data member has a default value of 75,000.
       </p>
       <pre class="calibre26" id="c01-code-0204"><code class="calibre21">struct Employee {</code>
<code class="calibre21">    char firstInitial;</code>
<code class="calibre21">    char lastInitial;</code>
<code class="calibre21">    int  employeeNumber;</code>
<code class="calibre21">    int  salary { 75'000 };</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Earlier in this chapter, such an
        <code class="calibre21">
         Employee
        </code>
        structure is initialized using a uniform initialization syntax as follows:
       </p>
       <pre class="calibre26" id="c01-code-0205"><code class="calibre21">Employee anEmployee { 'J', 'D', 42, 80'000 };</code></pre>
       <p class="calibre13">
        Using designated initializers, this can be written as follows:
       </p>
       <pre class="calibre26" id="c01-code-0206"><code class="calibre21">Employee anEmployee {</code>
<code class="calibre21">    .firstInitial = 'J',</code>
<code class="calibre21">    .lastInitial = 'D',</code>
<code class="calibre21">    .employeeNumber = 42,</code>
<code class="calibre21">    .salary = 80'000</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c01-para-0404">
        A benefit of using such designated initializers is that it's much easier to understand what a designated initializer is initializing compared to using the uniform initialization syntax.
       </p>
       <p class="calibre13">
        With designated initializers, you can skip initialization of certain members if you are satisfied with their default values. For example, when creating an employee, you could skip initializing
        <code class="calibre21">
         employeeNumber
        </code>
        , in which case
        <code class="calibre21">
         employeeNumber
        </code>
        is zero initialized as it doesn't have an in-class initializer:
       </p>
       <pre class="calibre26" id="c01-code-0207"><code class="calibre21">Employee anEmployee {</code>
<code class="calibre21">    .firstInitial = 'J',</code>
<code class="calibre21">    .lastInitial = 'D',</code>
<code class="calibre21">    .salary = 80'000</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        With the uniform initialization syntax, this is not possible, and you have to specify 0 for the employee number as follows:
       </p>
       <pre class="calibre26" id="c01-code-0208"><code class="calibre21">Employee anEmployee { 'J', 'D', 0, 80'000 };</code></pre>
       <p class="calibre13">
        <span aria-label="52" class="calibre20" epub:type="pagebreak" id="Page_52" role="doc-pagebreak">
        </span>
        If you skip initializing the
        <code class="calibre21">
         salary
        </code>
        data member as follows, then
        <code class="calibre21">
         salary
        </code>
        gets its default value, which is its in-class initialization value, 75,000:
       </p>
       <pre class="calibre26" id="c01-code-0209"><code class="calibre21">Employee anEmployee {</code>
<code class="calibre21">    .firstInitial = 'J',</code>
<code class="calibre21">    .lastInitial = 'D'</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c01-para-0408">
        A final benefit of using designated initializers is that when members are added to the data structure, existing code using designated initializers keeps working. The new data members will just be initialized with their default values.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0088">
      </span>
      <h3 class="calibre27" id="head-3-86">
       Pointers and Dynamic Memory
      </h3>
      <p class="calibre13" id="c01-para-0409">
       Dynamic memory allows you to build programs with data that is not of fixed size at compile time. Most nontrivial programs make use of dynamic memory in some form.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0089">
       </span>
       <h4 class="calibre29" id="head-4-40">
        The Stack and the Free Store
       </h4>
       <p class="calibre13" id="c01-para-0410">
        Memory in your C++ application is divided into two parts—the
        <i class="calibre18">
         stack
        </i>
        and the
        <i class="calibre18">
         free store
        </i>
        . One way to visualize the stack is as a deck of cards. The current top card represents the current scope of the program, usually the function that is currently being executed. All variables declared inside the current function will take up memory in the top stack frame, the top card of the deck. If the current function, which I'll call
        <code class="calibre21">
         foo()
        </code>
        , calls another function
        <code class="calibre21">
         bar()
        </code>
        , a new card is put on the deck so that
        <code class="calibre21">
         bar()
        </code>
        has its own
        <i class="calibre18">
         stack frame
        </i>
        to work with. Any parameters passed from
        <code class="calibre21">
         foo()
        </code>
        to
        <code class="calibre21">
         bar()
        </code>
        are copied from the
        <code class="calibre21">
         foo()
        </code>
        stack frame into the
        <code class="calibre21">
         bar()
        </code>
        stack frame.
        <a class="calibre5" href="c01_split_001.xhtml#c01-fig-0002" id="R_c01-fig-0002">
         Figure 1.2
        </a>
        shows what the stack might look like during the execution of a hypothetical function
        <code class="calibre21">
         foo()
        </code>
        that has declared two integer values.
       </p>
       <figure class="calibre36">
        <img alt="An illustration of the stack and the free store. A hypothetical function foo open closed brackets is in one box, and the main open-closed bracket is in another box. The int i is 7, and the int j is 11." class="center" src="images/c01f002.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="c01_split_001.xhtml#R_c01-fig-0002" id="c01-fig-0002" role="doc-backlink">
            <b class="calibre14">
             FIGURE 1.2
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p class="calibre13" id="c01-para-0411">
        Stack frames are nice because they provide an isolated memory workspace for each function. If a variable is declared inside the
        <code class="calibre21">
         foo()
        </code>
        stack frame, calling the
        <code class="calibre21">
         bar()
        </code>
        function won't change it unless you specifically tell it to. Also, when the
        <code class="calibre21">
         foo()
        </code>
        function is done running, the stack frame goes away, and all of the variables declared within the function no longer take up memory. Variables that are stack-allocated do not need to be deallocated (deleted) by the programmer; it happens automatically.
       </p>
       <p class="calibre13">
        The
        <i class="calibre18">
         free store
        </i>
        is an area of memory that is completely independent of the current function or stack frame. You can put variables on the free store if you want them to exist even when the function in which they were created has completed. The free store is less structured than the stack. You can think of it as just a pile of bits. Your program can add new bits to the pile at any time or modify bits that are already on the pile. You have to make sure that you deallocate (delete) any memory that you allocated on the free store. This does not happen automatically, unless you use smart pointers, which are discussed in detail in
        <a class="calibre5" href="c07.xhtml">
         Chapter 7
        </a>
        , “Memory Management.”
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0413">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Pointers are introduced here because you will encounter them, especially in legacy code bases. In new code, however, such raw/naked pointers are allowed only if there is no ownership involved. Otherwise, you should use one of the smart pointers explained in
            <a class="calibre5" href="c07.xhtml">
             Chapter 7
            </a>
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <span aria-label="53" class="calibre20" epub:type="pagebreak" id="Page_53" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0091">
       </span>
       <h4 class="calibre29" id="head-4-41">
        Working with Pointers
       </h4>
       <p class="calibre13">
        You can put anything on the free store by explicitly allocating memory for it. For example, to put an integer on the free store, you need to allocate memory for it, but first you need to declare a
        <i class="calibre18">
         pointer
        </i>
        :
       </p>
       <pre class="calibre26" id="c01-code-0210"><code class="calibre21">int* myIntegerPointer;</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         *
        </code>
        after the
        <code class="calibre21">
         int
        </code>
        type indicates that the variable you are declaring refers or points to some integer memory. Think of the pointer as an arrow that points at the dynamically allocated free store memory. It does not yet point to anything specific because you haven't assigned it to anything; it is an
        <i class="calibre18">
         uninitialized variable
        </i>
        . Uninitialized variables should be avoided at all times, and especially uninitialized pointers because they point to some random place in memory. Working with such pointers will most likely make your program crash. That's why you should always declare and initialize your pointers at the same time! You can initialize them to a null pointer (
        <code class="calibre21">
         nullptr
        </code>
        —for more information, see the “Null Pointer Constant” section) if you don't want to allocate memory right away:
       </p>
       <pre class="calibre26" id="c01-code-0211"><code class="calibre21">int* myIntegerPointer { nullptr };</code></pre>
       <p class="calibre13">
        A null pointer is a special default value that no valid pointer will ever have and converts to
        <code class="calibre21">
         false
        </code>
        when used in a Boolean expression. Here's an example:
       </p>
       <pre class="calibre26" id="c01-code-0212"><code class="calibre21">if (!myIntegerPointer) { <span class="color">/* myIntegerPointer is a null pointer. */</span> }</code></pre>
       <p class="calibre13">
        You use the
        <code class="calibre21">
         new
        </code>
        operator to allocate the memory:
       </p>
       <pre class="calibre26" id="c01-code-0213"><code class="calibre21">myIntegerPointer = new int;</code></pre>
       <p class="calibre13">
        In this case, the pointer points to the address of just a single integer value. To access this value, you need to
        <i class="calibre18">
         dereference
        </i>
        the pointer. Think of dereferencing as following the pointer's arrow to the actual value on the free store. To set the value of the newly allocated free store integer, you would use code like the following:
       </p>
       <pre class="calibre26" id="c01-code-0214"><code class="calibre21">*myIntegerPointer = 8;</code></pre>
       <p class="calibre13" id="c01-para-0419">
        Notice that this is not the same as setting
        <code class="calibre21">
         myIntegerPointer
        </code>
        to the value 8. You are not changing the pointer; you are changing the memory that it points to. If you were to reassign the pointer value, it would point to the memory address 8, which is probably random garbage that will eventually make your program crash.
       </p>
       <p class="calibre13">
        After you are finished with your dynamically allocated memory, you need to deallocate the memory using the
        <code class="calibre21">
         delete
        </code>
        operator. To prevent the pointer from being used after having deallocated the memory it points to, it's recommended to set it to
        <code class="calibre21">
         nullptr
        </code>
        :
       </p>
       <pre class="calibre26" id="c01-code-0215"><code class="calibre21">delete myIntegerPointer;</code>
<code class="calibre21">myIntegerPointer = nullptr;</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0422">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            A pointer must be valid before it is dereferenced. Dereferencing a null pointer or an uninitialized pointer causes undefined behavior. Your program might crash, but it might just as well keep running and start giving strange results
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        <span aria-label="54" class="calibre20" epub:type="pagebreak" id="Page_54" role="doc-pagebreak">
        </span>
        Pointers don't always point to free store memory. You can declare a pointer that points to a variable on the stack, even another pointer. To get a pointer to a variable, you use the
        <code class="calibre21">
         &amp;
        </code>
        (“address of”) operator:
       </p>
       <pre class="calibre26" id="c01-code-0216"><code class="calibre21">int i { 8 };</code>
<code class="calibre21">int* myIntegerPointer { &amp;i };  <span class="color">// Points to the variable with the value 8</span></code></pre>
       <p class="calibre13">
        C++ has a special syntax for dealing with pointers to structures or classes. Technically, if you have a pointer to a structure or a class, you can access its fields by first dereferencing it with
        <code class="calibre21">
         *
        </code>
        , and then using the normal
        <code class="calibre21">
         .
        </code>
        syntax, as in the code that follows. This code snippet also demonstrates how to dynamically allocate and deallocate an
        <code class="calibre21">
         Employee
        </code>
        instance.
       </p>
       <pre class="calibre26" id="c01-code-0217"><code class="calibre21">Employee* anEmployee { new Employee { 'J', 'D', 42, 80'000 } };</code>
<code class="calibre21">println("{}", (*anEmployee).salary);</code>
<code class="calibre21">delete anEmployee; anEmployee = nullptr;</code></pre>
       <p class="calibre13">
        This syntax is a little messy. The
        <code class="calibre21">
         -&gt;
        </code>
        (arrow) operator lets you perform both the dereference and the field access in one step. The following statement is equivalent to the previous
        <code class="calibre21">
         println()
        </code>
        call but is easier to read:
       </p>
       <pre class="calibre26" id="c01-code-0218"><code class="calibre21">println("{}", anEmployee-&gt;salary);</code></pre>
       <p class="calibre13">
        Remember the concept of short-circuiting logic, discussed earlier in this chapter? This can be useful in combination with pointers to avoid using an invalid pointer, as in the following example:
       </p>
       <pre class="calibre26" id="c01-code-0219"><code class="calibre21">bool isValidSalary { anEmployee &amp;&amp; anEmployee-&gt;salary&gt; 0 };</code></pre>
       <p class="calibre13">
        Or, here it is a little bit more verbose:
       </p>
       <pre class="calibre26" id="c01-code-0220"><code class="calibre21">bool isValidSalary { anEmployee != nullptr &amp;&amp; anEmployee-&gt;salary&gt; 0 };</code></pre>
       <p class="calibre13" id="c01-para-0428">
        <code class="calibre21">
         anEmployee
        </code>
        is dereferenced to get the salary only if it is a valid pointer. If it is a null pointer, the logical operation short-circuits, and the
        <code class="calibre21">
         anEmployee
        </code>
        pointer is not dereferenced.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0093">
       </span>
       <h4 class="calibre29" id="head-4-42">
        Dynamically Allocated Arrays
       </h4>
       <p class="calibre13">
        The free store can also be used to dynamically allocate arrays. You use the
        <code class="calibre21">
         new[]
        </code>
        operator to allocate memory for an array.
       </p>
       <pre class="calibre26" id="c01-code-0221"><code class="calibre21">int arraySize { 8 };</code>
<code class="calibre21">int* myVariableSizedArray { new int[arraySize] };</code></pre>
       <p class="calibre13" id="c01-para-0430">
        This allocates enough memory to hold
        <code class="calibre21">
         arraySize
        </code>
        integers.
        <a class="calibre5" href="c01_split_001.xhtml#c01-fig-0003" id="R_c01-fig-0003">
         Figure 1.3
        </a>
        shows what the stack and the free store both look like after this code is executed. As you can see, the pointer variable still resides on the stack, but the array that was dynamically created lives on the free store.
       </p>
       <p class="calibre13">
        Now that the memory has been allocated, you can work with
        <code class="calibre21">
         myVariableSizedArray
        </code>
        as though it were a regular stack-based array:
       </p>
       <pre class="calibre26" id="c01-code-0222"><code class="calibre21">myVariableSizedArray[3] = 2;</code></pre>
       <p class="calibre13">
        When your code is done with the array, it should remove the array from the free store so that other variables can use the memory. In C++, you use the
        <code class="calibre21">
         delete[]
        </code>
        operator to do this:
       </p>
       <pre class="calibre26" id="c01-code-0223"><code class="calibre21">delete[] myVariableSizedArray;</code>
<code class="calibre21">myVariableSizedArray = nullptr;</code></pre>
       <p class="calibre13">
        The brackets after
        <code class="calibre21">
         delete
        </code>
        indicate that you are deleting an array!
        <span aria-label="55" class="calibre20" epub:type="pagebreak" id="Page_55" role="doc-pagebreak">
        </span>
       </p>
       <figure class="calibre36">
        <img alt="A diagram of two figures. 1. Stack. 2. Free store. Stack includes myVarriableSizedArray. Free store ranges from myVarriableSizedArray 0 to 7." class="center" src="images/c01f003.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="c01_split_001.xhtml#R_c01-fig-0003" id="c01-fig-0003" role="doc-backlink">
            <b class="calibre14">
             FIGURE 1.3
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0434">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            If you do need dynamically allocated memory, avoid using
           </i>
           <code class="calibre21">
            malloc()
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            free()
           </code>
           <i class="calibre18">
            from C. Instead, use
            <code class="calibre21">
             new
            </code>
            and
            <code class="calibre21">
             delete
            </code>
            , or
           </i>
           <code class="calibre21">
            new[]
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            delete[]
           </code>
           <i class="calibre18">
            from C++. However, in modern C++, the goal is to avoid
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            ,
           </i>
           <code class="calibre21">
            delete
           </code>
           <i class="calibre18">
            ,
           </i>
           <code class="calibre21">
            new[]
           </code>
           <i class="calibre18">
            , and
           </i>
           <code class="calibre21">
            delete[]
           </code>
           <i class="calibre18">
            altogether, and use more modern constructs such as Standard Library containers, e.g.,
           </i>
           <code class="calibre21">
            std::vector
           </code>
           <i class="calibre18">
            , and smart pointers, discussed in
            <a class="calibre5" href="c07.xhtml">
             Chapter 7
            </a>
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0435">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            To prevent memory leaks, every call to
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            should be paired with a call to
           </i>
           <code class="calibre21">
            delete
           </code>
           <i class="calibre18">
            , and every call to
           </i>
           <code class="calibre21">
            new[]
           </code>
           <i class="calibre18">
            should be paired with a call to
           </i>
           <code class="calibre21">
            delete[]
           </code>
           <i class="calibre18">
            . Not calling
           </i>
           <code class="calibre21">
            delete
           </code>
           <i class="calibre18">
            or
           </i>
           <code class="calibre21">
            delete[]
           </code>
           <i class="calibre18">
            , or mismatching calls, results in memory leaks or worse. All these intricacies are discussed in
            <a class="calibre5" href="c07.xhtml">
             Chapter 7
            </a>
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0096">
       </span>
       <h4 class="calibre29" id="head-4-43">
        Null Pointer Constant
       </h4>
       <p class="calibre13">
        Before C++11, the constant
        <code class="calibre21">
         NULL
        </code>
        , defined in
        <code class="calibre21">
         &lt;cstddef&gt;
        </code>
        , was used for null pointers. You cannot get access to this constant using any
        <code class="calibre21">
         import
        </code>
        declaration; instead, you must use
        <code class="calibre21">
         #include &lt;cstddef&gt;
        </code>
        .
        <code class="calibre21">
         NULL
        </code>
        is simply defined as the constant 0, which can cause problems. Take the following example:
       </p>
       <pre class="calibre26" id="c01-code-0224"><code class="calibre21">#include &lt;cstddef&gt;</code>
<code class="calibre21"> </code>
<code class="calibre21">void func(int i) { <span class="color">/* … */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    func(NULL);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0437">
        The code defines a function
        <code class="calibre21">
         func()
        </code>
        with a single integer parameter. The
        <code class="calibre21">
         main()
        </code>
        function calls
        <code class="calibre21">
         func()
        </code>
        with argument
        <code class="calibre21">
         NULL
        </code>
        , which is supposed to be a null pointer constant. However, since
        <code class="calibre21">
         NULL
        </code>
        is
        <span aria-label="56" class="calibre20" epub:type="pagebreak" id="Page_56" role="doc-pagebreak">
        </span>
        not a real pointer, but identical to the integer 0, it triggers a call to
        <code class="calibre21">
         func(int)
        </code>
        . This might be unexpected behavior. Hence, some compilers even give a warning about this.
       </p>
       <p class="calibre13">
        This problem is avoided by using a real
        <i class="calibre18">
         null pointer constant
        </i>
        ,
        <code class="calibre21">
         nullptr
        </code>
        . The following code uses this real null pointer constant and causes a compilation error because there is no overload of
        <code class="calibre21">
         func()
        </code>
        accepting a pointer:
       </p>
       <pre class="calibre26" id="c01-code-0225"><code class="calibre21">func(nullptr);</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0097">
      </span>
      <h3 class="calibre27" id="head-3-87">
       The Use of const
      </h3>
      <p class="calibre13" id="c01-para-0439">
       The keyword
       <code class="calibre21">
        const
       </code>
       can be used in a few different ways in C++. Its uses are related, but there are subtle differences. The subtleties of
       <code class="calibre21">
        const
       </code>
       make for excellent interview questions!
      </p>
      <p class="calibre13" id="c01-para-0440">
       Basically, the keyword
       <code class="calibre21">
        const
       </code>
       is short for “constant” and specifies that something remains unchanged. The compiler enforces this requirement by marking any attempt to change it as an error. Furthermore, when optimizations are enabled, the compiler can take advantage of this knowledge to produce better code.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0098">
       </span>
       <h4 class="calibre29" id="head-4-44">
        const as a Qualifier for a Type
       </h4>
       <p class="calibre13">
        If you assumed that the keyword
        <code class="calibre21">
         const
        </code>
        has something to do with constants, you have correctly uncovered one of its uses. In C, programmers often use the preprocessor #
        <code class="calibre21">
         define
        </code>
        mechanism, see
        <a class="calibre5" href="c11.xhtml">
         Chapter 11
        </a>
        , to declare symbolic names for values that won't change during the execution of the program, such as the version number. In C++, programmers are encouraged to avoid #
        <code class="calibre21">
         define
        </code>
        in favor of using
        <code class="calibre21">
         const
        </code>
        to define constants. Defining a constant with
        <code class="calibre21">
         const
        </code>
        is just like defining a variable, except that the compiler guarantees that code cannot change the value. Here are some examples:
       </p>
       <pre class="calibre26" id="c01-code-0226"><code class="calibre21">const int versionNumberMajor { 2 };</code>
<code class="calibre21">const int versionNumberMinor { 1 };</code>
<code class="calibre21">const std::string productName { "Super Hyper Net Modulator" };</code>
<code class="calibre21">const double PI { 3.141592653589793238462 };</code></pre>
       <p class="calibre13" id="c01-para-0442">
        You can mark any variable
        <code class="calibre21">
         const
        </code>
        , including global variables and class data members.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0099">
        </span>
        <h5 class="calibre35" id="head-5-6">
         const with Pointers
        </h5>
        <p class="calibre13">
         When a variable contains one or more levels of indirection via a pointer, applying
         <code class="calibre21">
          const
         </code>
         becomes trickier. Consider the following lines of code:
        </p>
        <pre class="calibre26" id="c01-code-0227"><code class="calibre21">int* ip;</code>
<code class="calibre21">ip = new int[10];</code>
<code class="calibre21">ip[4] = 5;</code></pre>
        <p class="calibre13" id="c01-para-0444">
         Suppose that you decide to apply
         <code class="calibre21">
          const
         </code>
         to
         <code class="calibre21">
          ip
         </code>
         . Set aside your doubts about the usefulness of doing so for a moment, and consider what it means. Do you want to prevent the
         <code class="calibre21">
          ip
         </code>
         variable itself from being changed, or do you want to prevent the values to which it points from being changed? That is, do you want to prevent the second statement or the third statement?
        </p>
        <p class="calibre13">
         To prevent the pointed-to values from being modified (as in the third statement), you can add the keyword
         <code class="calibre21">
          const
         </code>
         to the declaration of
         <code class="calibre21">
          ip
         </code>
         like this:
        </p>
        <pre class="calibre26" id="c01-code-0228"><code class="calibre21"><b class="calibre14">const int* ip;</b></code>
<code class="calibre21">ip = new int[10];</code>
<code class="calibre21">ip[4] = 5; <span class="color">// DOES NOT COMPILE!</span></code></pre>
        <p class="calibre13">
         <span aria-label="57" class="calibre20" epub:type="pagebreak" id="Page_57" role="doc-pagebreak">
         </span>
         Now you cannot change the values to which
         <code class="calibre21">
          ip
         </code>
         points. An alternative but semantically equivalent way to write this is as follows:
        </p>
        <pre class="calibre26" id="c01-code-0229"><code class="calibre21"><b class="calibre14">int const* ip;</b></code>
<code class="calibre21">ip = new int[10];</code>
<code class="calibre21">ip[4] = 5; <span class="color">// DOES NOT COMPILE!</span></code></pre>
        <p class="calibre13" id="c01-para-0447">
         Putting the
         <code class="calibre21">
          const
         </code>
         before or after the
         <code class="calibre21">
          int
         </code>
         makes no difference in its functionality.
        </p>
        <p class="calibre13">
         If you instead want to mark
         <code class="calibre21">
          ip
         </code>
         itself
         <code class="calibre21">
          const
         </code>
         (not the values to which it points), you need to write this:
        </p>
        <pre class="calibre26" id="c01-code-0230"><code class="calibre21"><b class="calibre14">int* const ip { nullptr };</b></code>
<code class="calibre21">ip = new int[10]; <span class="color">// DOES NOT COMPILE!</span></code>
<code class="calibre21">ip[4] = 5;        <span class="color">// Error: dereferencing a null pointer</span></code></pre>
        <p class="calibre13">
         Now that
         <code class="calibre21">
          ip
         </code>
         itself cannot be changed, the compiler requires you to initialize it when you declare it, either with
         <code class="calibre21">
          nullptr
         </code>
         as in the preceding code or with newly allocated memory as follows:
        </p>
        <pre class="calibre26" id="c01-code-0231"><code class="calibre21"><b class="calibre14">int* const ip { new int[10] };</b></code>
<code class="calibre21">ip[4] = 5;</code></pre>
        <p class="calibre13">
         You can also mark both the pointer and the value to which it points
         <code class="calibre21">
          const
         </code>
         like this:
        </p>
        <pre class="calibre26" id="c01-code-0232"><code class="calibre21">int const* const ip { nullptr };</code></pre>
        <p class="calibre13">
         Here is an alternative but equivalent syntax:
        </p>
        <pre class="calibre26" id="c01-code-0233"><code class="calibre21">const int* const ip { nullptr };</code></pre>
        <p class="calibre13">
         Although this syntax might seem confusing, there is actually a simple rule: the
         <code class="calibre21">
          const
         </code>
         keyword applies to whatever is directly to its left. Consider this line again:
        </p>
        <pre class="calibre26" id="c01-code-0234"><code class="calibre21">int const* const ip { nullptr };</code></pre>
        <p class="calibre13" id="c01-para-0453">
         From left to right, the first
         <code class="calibre21">
          const
         </code>
         is directly to the right of the word
         <code class="calibre21">
          int
         </code>
         . Thus, it applies to the
         <code class="calibre21">
          int
         </code>
         to which
         <code class="calibre21">
          ip
         </code>
         points. Therefore, it specifies that you cannot change the values to which
         <code class="calibre21">
          ip
         </code>
         points. The second
         <code class="calibre21">
          const
         </code>
         is directly to the right of the
         <code class="calibre21">
          *
         </code>
         . Thus, it applies to the pointer to the
         <code class="calibre21">
          int
         </code>
         , which is the
         <code class="calibre21">
          ip
         </code>
         variable. Therefore, it specifies that you cannot change
         <code class="calibre21">
          ip
         </code>
         (the pointer) itself.
        </p>
        <p class="calibre13">
         The reason this rule becomes confusing is an exception. That is, the first
         <code class="calibre21">
          const
         </code>
         can go before the variable like this:
        </p>
        <pre class="calibre26" id="c01-code-0235"><code class="calibre21">const int* const ip { nullptr };</code></pre>
        <p class="calibre13" id="c01-para-0455">
         This “exceptional” syntax is used much more commonly than the other syntax.
        </p>
        <p class="calibre13">
         You can extend this rule to any number of levels of indirection, as in this example:
        </p>
        <pre class="calibre26" id="c01-code-0236"><code class="calibre21">const int * const * const * const ip { nullptr };</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c01-para-0458">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Here is another easy-to-remember rule to figure out complicated variable declarations: read from right to left. For example
            </i>
            ,
            <code class="calibre21">
             int* const ip
            </code>
            <i class="calibre18">
             reads from right to left as “
            </i>
            <code class="calibre21">
             ip
            </code>
            <i class="calibre18">
             is a
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             pointer to an
            </i>
            <code class="calibre21">
             int
            </code>
            <i class="calibre18">
             .” Further
            </i>
            ,
            <code class="calibre21">
             int const* ip
            </code>
            <i class="calibre18">
             reads as “
            </i>
            <code class="calibre21">
             ip
            </code>
            <i class="calibre18">
             is a pointer to a
            </i>
            <code class="calibre21">
             const int
            </code>
            <i class="calibre18">
             ,” and
            </i>
            <code class="calibre21">
             const int* ip
            </code>
            <i class="calibre18">
             reads as “
            </i>
            <code class="calibre21">
             ip
            </code>
            <i class="calibre18">
             is a pointer to an
            </i>
            <code class="calibre21">
             int
            </code>
            <i class="calibre18">
             constant.”
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <span aria-label="58" class="calibre20" epub:type="pagebreak" id="Page_58" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0101">
        </span>
        <h5 class="calibre35" id="head-5-7">
         const to Protect Parameters
        </h5>
        <p class="calibre13" id="c01-para-0459">
         In C++, you can cast a non-
         <code class="calibre21">
          const
         </code>
         variable to a
         <code class="calibre21">
          const
         </code>
         variable. Why would you want to do this? It offers some degree of protection from other code changing the variable. If you are calling a function that a co-worker of yours is writing and you want to ensure that the function doesn't change the value of an argument you pass in, you can tell your co-worker to have the function take a
         <code class="calibre21">
          const
         </code>
         parameter. If the function attempts to change the value of the parameter, it will not compile.
        </p>
        <p class="calibre13">
         In the following code, a
         <code class="calibre21">
          string*
         </code>
         is automatically cast to a
         <code class="calibre21">
          const string*
         </code>
         in the call to
         <code class="calibre21">
          mysteryFunction()
         </code>
         . If the author of
         <code class="calibre21">
          mysteryFunction()
         </code>
         attempts to change the value of the passed string, the code will not compile. There are ways around this restriction, but using them requires conscious effort. C++ only protects against accidentally changing
         <code class="calibre21">
          const
         </code>
         variables.
        </p>
        <pre class="calibre26" id="c01-code-0237"><code class="calibre21">void mysteryFunction(const string* someString)</code>
<code class="calibre21">{</code>
<code class="calibre21">    *someString = "Test";  <span class="color">// Will not compile</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    string myString { "The string" };</code>
<code class="calibre21">    mysteryFunction(&amp;myString);  // &amp;myString is a string*</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         You can also use
         <code class="calibre21">
          const
         </code>
         on primitive-type parameters to prevent accidentally changing them in the body of the function. For example, the following function has a
         <code class="calibre21">
          const
         </code>
         integer parameter. In the body of the function, you cannot modify the
         <code class="calibre21">
          param
         </code>
         integer. If you do try to modify it, the compiler will generate an error.
        </p>
        <pre class="calibre26" id="c01-code-0238"><code class="calibre21">void func(const int param) { <span class="color">/* Not allowed to change param… */</span> }</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0102">
       </span>
       <h4 class="calibre29" id="head-4-45">
        const Member Functions
       </h4>
       <p class="calibre13">
        A second use of the
        <code class="calibre21">
         const
        </code>
        keyword is to mark class member functions as
        <code class="calibre21">
         const
        </code>
        , preventing them from modifying data members of the class. The
        <code class="calibre21">
         AirlineTicket
        </code>
        class introduced earlier can be modified to mark all read-only member functions as
        <code class="calibre21">
         const
        </code>
        . The
        <code class="calibre21">
         const
        </code>
        must be added to both the member function declaration and its definition. If any
        <code class="calibre21">
         const
        </code>
        member function tries to modify one of the
        <code class="calibre21">
         AirlineTicket
        </code>
        data members, the compiler will emit an error.
       </p>
       <pre class="calibre26" id="c01-code-0239"><code class="calibre21">export class AirlineTicket</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">double calculatePriceInDollars() const;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">std::string getPassengerName() const;</b></code>
<code class="calibre21">        void setPassengerName(std::string name);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">int getNumberOfMiles() const;</b></code>
<code class="calibre21">        void setNumberOfMiles(int miles);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">bool hasEliteSuperRewardsStatus() const;</b></code>
<code class="calibre21">        void setHasEliteSuperRewardsStatus(bool status);</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_passengerName { "Unknown Passenger" };</code>
<code class="calibre21">        int m_numberOfMiles { 0 };</code>
<code class="calibre21">        bool m_hasEliteSuperRewardsStatus { false };</code>
<span aria-label="59" class="calibre20" epub:type="pagebreak" id="Page_59" role="doc-pagebreak"></span><code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">std::string AirlineTicket::getPassengerName() const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_passengerName;</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Other member functions omitted…</span></code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0464">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            To follow the
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            -correctness principle, it's recommended to declare member functions that do not change any data members of the object as being
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            . These member functions are also called
            <b class="calibre14">
             inspectors
            </b>
            , compared to
            <b class="calibre14">
             mutators
            </b>
            for non-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            member functions.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0104">
      </span>
      <h3 class="calibre27" id="head-3-88">
       References
      </h3>
      <p class="calibre13" id="c01-para-0465">
       Professional C++ code, including much of the code in this book, uses references extensively. A
       <i class="calibre18">
        reference
       </i>
       in C++ is an
       <i class="calibre18">
        alias
       </i>
       for another variable. All modifications to the reference change the value of the variable to which it refers. You can think of references as implicit pointers that save you the trouble of taking the address of variables and dereferencing the pointer. Alternatively, you can think of references as just another name for the original variable. You can create stand-alone reference variables, use reference data members in classes, accept references as parameters to functions, and return references from functions.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0105">
       </span>
       <h4 class="calibre29" id="head-4-46">
        Reference Variables
       </h4>
       <p class="calibre13">
        Reference variables must be initialized as soon as they are created, like this:
       </p>
       <pre class="calibre26" id="c01-code-0240"><code class="calibre21">int x { 3 };</code>
<code class="calibre21">int&amp; xRef { x };</code></pre>
       <p class="calibre13">
        Attaching
        <code class="calibre21">
         &amp;
        </code>
        to a type indicates that the variable is a reference. It is still used as though it was a normal variable, but behind the scenes, it is really a pointer to the original variable. Both the variable
        <code class="calibre21">
         x
        </code>
        and the reference variable
        <code class="calibre21">
         xRef
        </code>
        point to exactly the same value; i.e.,
        <code class="calibre21">
         xRef
        </code>
        is just another name for
        <code class="calibre21">
         x
        </code>
        . If you change the value through either one of them, the change is visible through the other one as well. For example, the following code sets
        <code class="calibre21">
         x
        </code>
        to 10 through
        <code class="calibre21">
         xRef
        </code>
        :
       </p>
       <pre class="calibre26" id="c01-code-0241"><code class="calibre21">xRef = 10;</code></pre>
       <p class="calibre13">
        You cannot declare a reference variable outside of a class definition without initializing it.
       </p>
       <pre class="calibre26" id="c01-code-0242"><code class="calibre21">int&amp; emptyRef; <span class="color">// DOES NOT COMPILE!</span></code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0470">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            A reference variable must always be initialized when it's created
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0107">
        </span>
        <h5 class="calibre35" id="head-5-8">
         Modifying References
        </h5>
        <p class="calibre13">
         A reference always refers to the same variable to which it is initialized; references cannot be changed once they are created. The syntax might be confusing for beginning C++ programmers. If you assign a variable to a reference when the reference is declared, the reference refers to that variable. However, if
         <span aria-label="60" class="calibre20" epub:type="pagebreak" id="Page_60" role="doc-pagebreak">
         </span>
         you assign a variable to a reference after that, the variable to which the reference refers is changed to the value of the variable being assigned. The reference is not updated to refer to that variable. Here is a code example:
        </p>
        <pre class="calibre26" id="c01-code-0243"><code class="calibre21">int x { 3 }, y { 4 };</code>
<code class="calibre21">int&amp; xRef { x };</code>
<code class="calibre21">xRef = y; <span class="color">// Changes value of x to 4. Doesn't make xRef refer to y.</span></code></pre>
        <p class="calibre13">
         You might try to circumvent this restriction by taking the address of
         <code class="calibre21">
          y
         </code>
         when you assign it:
        </p>
        <pre class="calibre26" id="c01-code-0244"><code class="calibre21">xRef = &amp;y; <span class="color">// DOES NOT COMPILE!</span></code></pre>
        <p class="calibre13" id="c01-para-0473">
         This code does not compile. The address of
         <code class="calibre21">
          y
         </code>
         is a pointer, but
         <code class="calibre21">
          xRef
         </code>
         is declared as a reference to an
         <code class="calibre21">
          int
         </code>
         , not a reference to a pointer.
        </p>
        <p class="calibre13">
         Some programmers go even further in their attempts to circumvent the intended semantics of references. What if you assign a reference to a reference? Won't that make the first reference refer to the variable to which the second reference refers? You might be tempted to try this code:
        </p>
        <pre class="calibre26" id="c01-code-0245"><code class="calibre21">int x { 3 }, z { 5 };</code>
<code class="calibre21">int&amp; xRef { x };</code>
<code class="calibre21">int&amp; zRef { z };</code>
<code class="calibre21">zRef = xRef; <span class="color">// Assigns values, not references</span></code></pre>
        <p class="calibre13">
         The final statement does not change to what
         <code class="calibre21">
          zRef
         </code>
         refers to. Instead, it sets the value of
         <code class="calibre21">
          z
         </code>
         to 3, because
         <code class="calibre21">
          xRef
         </code>
         refers to
         <code class="calibre21">
          x
         </code>
         , which is 3.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c01-para-0476">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Once a reference is initialized to refer to a specific variable, you cannot change the reference to refer to another variable; you can change only the value of the variable the reference refers to
            </i>
            .
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0109">
        </span>
        <h5 class="calibre35" id="head-5-9">
         References-to-const
        </h5>
        <p class="calibre13" id="c01-para-0477">
         <code class="calibre21">
          const
         </code>
         applied to references is usually easier than
         <code class="calibre21">
          const
         </code>
         applied to pointers for two reasons. First, references are
         <code class="calibre21">
          const
         </code>
         by default, in that you can't change to what they refer. So, there is no need to mark them
         <code class="calibre21">
          const
         </code>
         explicitly. Second, you can't create a reference to a reference, so there is usually only one level of indirection with references. The only way to get multiple levels of indirection is to create a reference to a pointer.
        </p>
        <p class="calibre13">
         Thus, when C++ programmers refer to a reference-to-
         <code class="calibre21">
          const
         </code>
         , they mean something like this:
        </p>
        <pre class="calibre26" id="c01-code-0246"><code class="calibre21">int z;</code>
<code class="calibre21">const int&amp; zRef { z };</code>
<code class="calibre21">zRef = 4; <span class="color">// DOES NOT COMPILE</span></code></pre>
        <p class="calibre13" id="c01-para-0479">
         By applying
         <code class="calibre21">
          const
         </code>
         to the
         <code class="calibre21">
          int&amp;
         </code>
         , you prevent assignment to
         <code class="calibre21">
          zRef
         </code>
         , as shown. Similar to pointers,
         <code class="calibre21">
          const int&amp; zRef
         </code>
         is equivalent to
         <code class="calibre21">
          int const&amp; zRef
         </code>
         . Note, however, that marking
         <code class="calibre21">
          zRef const
         </code>
         has no effect on
         <code class="calibre21">
          z
         </code>
         . You can still modify the value of
         <code class="calibre21">
          z
         </code>
         by changing it directly instead of through the reference.
        </p>
        <p class="calibre13">
         You cannot create a reference to an unnamed value, such as an integer literal, unless the reference is to a
         <code class="calibre21">
          const
         </code>
         value. In the following example,
         <code class="calibre21">
          unnamedRef1
         </code>
         does not compile because it is a reference-to-non-
         <code class="calibre21">
          const
         </code>
         referring to a constant. That would mean you could change the value of the constant,
         <span aria-label="61" class="calibre20" epub:type="pagebreak" id="Page_61" role="doc-pagebreak">
         </span>
         5, which doesn't make sense.
         <code class="calibre21">
          unnamedRef2
         </code>
         works because it's a reference-to-
         <code class="calibre21">
          const
         </code>
         , so you cannot for example write
         <code class="calibre21">
          unnamedRef2 = 7
         </code>
         .
        </p>
        <pre class="calibre26" id="c01-code-0247"><code class="calibre21">int&amp; unnamedRef1 { 5 };       <span class="color">// DOES NOT COMPILE</span></code>
<code class="calibre21">const int&amp; unnamedRef2 { 5 }; <span class="color">// Works as expected</span></code></pre>
        <p class="calibre13">
         The same holds for temporary objects. You cannot create a reference-to-non-
         <code class="calibre21">
          const
         </code>
         to a temporary object, but a reference-to-
         <code class="calibre21">
          const
         </code>
         is fine. For example, suppose you have the following function returning an
         <code class="calibre21">
          std::string
         </code>
         object:
        </p>
        <pre class="calibre26" id="c01-code-0248"><code class="calibre21">string getString() { return "Hello world!"; }</code></pre>
        <p class="calibre13">
         You can create a reference-to-
         <code class="calibre21">
          const
         </code>
         to the result of calling
         <code class="calibre21">
          getString()
         </code>
         , and that reference keeps the temporary
         <code class="calibre21">
          std::string
         </code>
         object alive until the reference goes out of scope:
        </p>
        <pre class="calibre26" id="c01-code-0249"><code class="calibre21">string&amp; string1 { getString() };       <span class="color">// DOES NOT COMPILE</span></code>
<code class="calibre21">const string&amp; string2 { getString() }; <span class="color">// Works as expected</span></code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0110">
        </span>
        <h5 class="calibre35" id="head-5-10">
         References to Pointers and Pointers to References
        </h5>
        <p class="calibre13">
         You can create references to any type, including pointer types. Here is an example of a reference to a pointer to
         <code class="calibre21">
          int
         </code>
         :
        </p>
        <pre class="calibre26" id="c01-code-0250"><code class="calibre21">int* intP { nullptr };</code>
<code class="calibre21">int*&amp; ptrRef { intP };</code>
<code class="calibre21">ptrRef = new int;</code>
<code class="calibre21">*ptrRef = 5;</code>
<code class="calibre21">delete ptrRef; ptrRef = nullptr;</code></pre>
        <p class="calibre13" id="c01-para-0484">
         The syntax is a little strange: you might not be accustomed to seeing
         <code class="calibre21">
          *
         </code>
         and
         <code class="calibre21">
          &amp;
         </code>
         right next to each other. However, the semantics are straightforward:
         <code class="calibre21">
          ptrRef
         </code>
         is a reference to
         <code class="calibre21">
          intP
         </code>
         , which is a pointer to
         <code class="calibre21">
          int
         </code>
         . Modifying
         <code class="calibre21">
          ptrRef
         </code>
         changes
         <code class="calibre21">
          intP
         </code>
         . References to pointers are rare but can occasionally be useful, as discussed in the “Reference Parameters” section later in this chapter.
        </p>
        <p class="calibre13">
         Taking the address of a reference gives the same result as taking the address of the variable to which the reference refers. Here is an example:
        </p>
        <pre class="calibre26" id="c01-code-0251"><code class="calibre21">int x { 3 };</code>
<code class="calibre21">int&amp; xRef { x };</code>
<code class="calibre21"><b class="calibre14">int* xPtr { &amp;xRef };</b> <span class="color">// Address of a reference is pointer to value.</span></code>
<code class="calibre21"><b class="calibre14">*xPtr = 100;</b></code></pre>
        <p class="calibre13" id="c01-para-0486">
         This code sets
         <code class="calibre21">
          xPtr
         </code>
         to point to
         <code class="calibre21">
          x
         </code>
         by taking the address of a reference to
         <code class="calibre21">
          x
         </code>
         . Assigning 100 to
         <code class="calibre21">
          *xPtr
         </code>
         changes the value of
         <code class="calibre21">
          x
         </code>
         to 100. Writing the comparison
         <code class="calibre21">
          xPtr == xRef
         </code>
         will not compile because of a type mismatch;
         <code class="calibre21">
          xPtr
         </code>
         is a pointer to an
         <code class="calibre21">
          int
         </code>
         , while
         <code class="calibre21">
          xRef
         </code>
         is a reference to an
         <code class="calibre21">
          int
         </code>
         . The comparisons
         <code class="calibre21">
          xPtr == &amp;xRef
         </code>
         and
         <code class="calibre21">
          xPtr == &amp;x
         </code>
         both compile without errors and are both
         <code class="calibre21">
          true
         </code>
         .
        </p>
        <p class="calibre13" id="c01-para-0487">
         Finally, note that you cannot declare a reference to a reference or a pointer to a reference. For example, neither
         <code class="calibre21">
          int&amp; &amp;
         </code>
         nor
         <code class="calibre21">
          int&amp;*
         </code>
         is allowed.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0111">
        </span>
        <h5 class="calibre35" id="head-5-11">
         Structured Bindings and References
        </h5>
        <p class="calibre13">
         Structured bindings are introduced earlier in this chapter. One of the examples given was the following:
        </p>
        <pre class="calibre26" id="c01-code-0252"><code class="calibre21">pair myPair { "hello", 5 };</code>
<code class="calibre21">auto [theString, theInt] { myPair };  <span class="color">// Decompose using structured bindings</span></code></pre>
        <p class="calibre13">
         <span aria-label="62" class="calibre20" epub:type="pagebreak" id="Page_62" role="doc-pagebreak">
         </span>
         Now that you know about references and
         <code class="calibre21">
          const
         </code>
         variables, it's time to learn that both can be combined with structured bindings as well. Here's an example:
        </p>
        <pre class="calibre26" id="c01-code-0253"><code class="calibre21">auto&amp; [theString, theInt] { myPair };    <span class="color">// Decompose into references-to-non-const</span></code>
<code class="calibre21">const auto&amp; [theString, theInt] { myPair };  <span class="color">// Decompose into references-to-const</span></code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0112">
       </span>
       <h4 class="calibre29" id="head-4-47">
        Reference Data Members
       </h4>
       <p class="calibre13">
        Data members of classes can be references. As discussed earlier, a reference cannot exist without referring to some other variable, and it is not possible to change where a reference refers to. Thus, reference data members cannot be initialized inside the body of a class constructor, but they must be initialized in the
        <i class="calibre18">
         constructor initializer
        </i>
        . Syntax-wise, a constructor initializer immediately follows the constructor header and starts with a colon. The following is a quick example with the constructor initializer highlighted.
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        goes in much more detail.
       </p>
       <pre class="calibre26" id="c01-code-0254"><code class="calibre21">class MyClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        MyClass(int&amp; ref) <b class="calibre14">: m_ref { ref }</b> { <span class="color">/* Body of constructor */</span> }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int&amp; m_ref;</code>
<code class="calibre21">};</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0492">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            A reference must always be initialized when it's created. Usually, references are created when they are declared, but reference data members need to be initialized in a constructor initializer for the containing class
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0114">
       </span>
       <h4 class="calibre29" id="head-4-48">
        Reference Parameters
       </h4>
       <p class="calibre13" id="c01-para-0493">
        C++ programmers do not often use stand-alone reference variables or reference data members. The most common use of references is for parameters to functions. The default parameter-passing semantics is pass-by-value: functions receive copies of their arguments. When those parameters are modified, the original arguments remain unchanged. Pointers to stack variables are often used in C to allow functions to modify variables in other stack frames. By dereferencing the pointer, the function can change the memory that represents the variable even though that variable isn't in the current stack frame. The problem with this approach is that it brings the messiness of pointer syntax into what is really a simple task.
       </p>
       <p class="calibre13">
        Instead of passing pointers to functions, C++ offers a better mechanism, called
        <i class="calibre18">
         pass-by-reference
        </i>
        , where parameters are references instead of pointers. The following are two implementations of an
        <code class="calibre21">
         addOne()
        </code>
        function. The first one has no effect on the variable that is passed in because it is passed by value, and thus the function receives a copy of the value passed to it. The second one uses a reference and thus changes the original variable.
       </p>
       <pre class="calibre26" id="c01-code-0255"><code class="calibre21">void addOne(int i)</code>
<code class="calibre21">{</code>
<code class="calibre21">    i++;  <span class="color">// Has no real effect because this is a copy of the original</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="63" class="calibre20" epub:type="pagebreak" id="Page_63" role="doc-pagebreak"></span><code class="calibre21">void addOne(int&amp; i)</code>
<code class="calibre21">{</code>
<code class="calibre21">    i++;  <span class="color">// Actually changes the original variable</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The syntax for the call to the
        <code class="calibre21">
         addOne()
        </code>
        function with an integer reference is no different than if the function just took an integer.
       </p>
       <pre class="calibre26" id="c01-code-0256"><code class="calibre21">int myInt { 7 };</code>
<code class="calibre21">addOne(myInt);</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0497">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            There is a subtle difference between the two
           </i>
           <code class="calibre21">
            addOne()
           </code>
           <i class="calibre18">
            implementations. The version using pass-by-value accepts literals without a problem; for example,
           </i>
           <code class="calibre21">
            addOne(3
            <i class="calibre18">
             );
            </i>
           </code>
           <i class="calibre18">
            is legal. However, doing the same with the pass-by-reference version of
           </i>
           <code class="calibre21">
            addOne()
           </code>
           <i class="calibre18">
            will result in a compilation error. This can be solved by using reference-to-
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            parameters, discussed in the next section.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Here is another example where pass-by-reference comes in handy; it's a simple swap function to swap the values of two
        <code class="calibre21">
         int
        </code>
        s:
       </p>
       <pre class="calibre26" id="c01-code-0257"><code class="calibre21">void swap(int&amp; first, int&amp; second)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int temp { first };</code>
<code class="calibre21">    first = second;</code>
<code class="calibre21">    second = temp;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        You can call it like this:
       </p>
       <pre class="calibre26" id="c01-code-0258"><code class="calibre21">int x { 5 }, y { 6 };</code>
<code class="calibre21">swap(x, y);</code></pre>
       <p class="calibre13" id="c01-para-0500">
        When
        <code class="calibre21">
         swap()
        </code>
        is called with the arguments
        <code class="calibre21">
         x
        </code>
        and
        <code class="calibre21">
         y
        </code>
        , the
        <code class="calibre21">
         first
        </code>
        parameter is initialized to refer to
        <code class="calibre21">
         x
        </code>
        , and the
        <code class="calibre21">
         second
        </code>
        parameter is initialized to refer to
        <code class="calibre21">
         y
        </code>
        . When
        <code class="calibre21">
         swap()
        </code>
        modifies
        <code class="calibre21">
         first
        </code>
        and
        <code class="calibre21">
         second
        </code>
        ,
        <code class="calibre21">
         x
        </code>
        and
        <code class="calibre21">
         y
        </code>
        are actually changed.
       </p>
       <p class="calibre13">
        A common quandary arises when you have a pointer to something that you need to pass to a function that takes a reference. You can “convert” a pointer to a reference in this case by dereferencing the pointer. This action gives you the value to which the pointer points, which the compiler then uses to initialize the reference parameter. For example, you can call
        <code class="calibre21">
         swap()
        </code>
        like this:
       </p>
       <pre class="calibre26" id="c01-code-0259"><code class="calibre21">int x { 5 }, y { 6 };</code>
<code class="calibre21"><b class="calibre14">int *xp { &amp;x }, *yp { &amp;y };</b></code>
<code class="calibre21"><b class="calibre14">swap(*xp, *yp);</b></code></pre>
       <p class="calibre13">
        Finally, if you have a function that needs to return an object of a class that is expensive to copy, you'll often see the function accepting an output parameter of type reference-to-non-
        <code class="calibre21">
         const
        </code>
        to such a class that the function then modifies, instead of directly returning such an object. Developers thought that this was the recommended way to prevent any performance penalties with creating copies when
        <span aria-label="64" class="calibre20" epub:type="pagebreak" id="Page_64" role="doc-pagebreak">
        </span>
        returning objects from functions. However, even back then, compilers were usually smart enough to avoid any redundant copies. So, we have the following rule:
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0503">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            The recommended way to return objects from a function is to return them by value, instead of using output parameters
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0117">
        </span>
        <h5 class="calibre35" id="head-5-12">
         Pass-by-Reference-to-const
        </h5>
        <p class="calibre13">
         The main value in reference-to-
         <code class="calibre21">
          const
         </code>
         parameters is efficiency. When you pass a value into a function, an entire copy is made. When you pass a reference, you are really just passing a pointer to the original so the computer doesn't need to make a copy. By passing a reference-to-
         <code class="calibre21">
          const
         </code>
         , you get the best of both worlds: no copy is made, and the original variable cannot be changed. References-to-
         <code class="calibre21">
          const
         </code>
         become more important when you are dealing with objects because they can be large and making copies of them can have unwanted side effects. The following example shows how to pass an
         <code class="calibre21">
          std::string
         </code>
         to a function as a reference-to-
         <code class="calibre21">
          const
         </code>
         :
        </p>
        <pre class="calibre26" id="c01-code-0260"><code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">void printString(const string&amp; myString) { println("{}", myString); }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    string someString { "Hello World" };</code>
<code class="calibre21">    printString(someString);</code>
<code class="calibre21">    printString("Hello World");  <span class="color">// Passing literals works.</span></code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0118">
        </span>
        <h5 class="calibre35" id="head-5-13">
         Pass-by-Reference vs. Pass-by-Value
        </h5>
        <p class="calibre13">
         Pass-by-reference is required when you want to modify the parameter and see those changes reflected in the variable passed to the function. However, you should not limit your use of pass-by-reference to only those cases. Pass-by-reference avoids copying the arguments to the function, providing two additional benefits:
        </p>
        <ul class="check" id="c01-list-0014">
         <li class="calibre9" id="c01-li-0053">
          <b class="calibre14">
           Efficiency:
          </b>
          Large objects could take a long time to copy. Pass-by-reference passes only a reference to the object into the function.
         </li>
         <li class="calibre9" id="c01-li-0054">
          <b class="calibre14">
           Support:
          </b>
          Not all classes allow pass-by-value.
         </li>
        </ul>
        <p class="calibre13">
         If you want to leverage these benefits but do not want to allow the original objects to be modified, you should mark the parameters
         <code class="calibre21">
          const
         </code>
         , giving you pass-by-reference-to-
         <code class="calibre21">
          const
         </code>
         .
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c01-para-0507">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             These benefits of pass-by-reference imply that you should use pass-by-value only for simple built-in types such as
            </i>
            <code class="calibre21">
             int
            </code>
            <i class="calibre18">
             and
            </i>
            <code class="calibre21">
             double
            </code>
            <i class="calibre18">
             for which you don't need to modify the arguments. If you need to pass an object to a function, prefer to pass it by reference-to-
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             instead of by value. This prevents unnecessary copying. Pass it by reference-to-non-
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             if the function needs to modify the object.
             <a class="calibre5" href="c09.xhtml">
              Chapter 9
             </a>
             slightly modifies this rule after the introduction of move semantics, allowing pass-by-value of objects in certain cases.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <span aria-label="65" class="calibre20" epub:type="pagebreak" id="Page_65" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0120">
       </span>
       <h4 class="calibre29" id="head-4-49">
        Reference Return Values
       </h4>
       <p class="calibre13">
        You can return a reference from a function. Of course, you can use this technique only if the variable to which the returned reference refers to continues to exist following the function termination.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0509">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            From a function, never return a reference to a variable that is locally scoped to that function, such as an automatically allocated variable on the stack that will be destroyed when the function ends
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c01-para-0510">
        One of the main reasons to return a reference is if you want to be able to assign to the return value directly as an
        <i class="calibre18">
         lvalue
        </i>
        (the left-hand side of an assignment statement). Several overloaded operators commonly return references, such as operators
        <code class="calibre21">
         =
        </code>
        ,
        <code class="calibre21">
         +=
        </code>
        , and so on.
        <a class="calibre5" href="c15.xhtml">
         Chapter 15
        </a>
        goes into more details on how to write such overloaded operators yourself.
       </p>
       <p class="calibre13" id="c01-para-0511">
        Another reason to return a reference from a function is if the return type is expensive to copy. By returning a reference or reference-to-
        <code class="calibre21">
         const
        </code>
        , the copying is avoided, but keep the earlier warning in mind. This is often used to return objects by reference-to-const from class member functions, as demonstrated later in this chapter.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0122">
       </span>
       <h4 class="calibre29" id="head-4-50">
        Deciding Between References and Pointers
       </h4>
       <p class="calibre13">
        References in C++ could be considered redundant: everything you can do with references, you can accomplish with pointers. For example, you could write the earlier shown
        <code class="calibre21">
         swap()
        </code>
        function like this:
       </p>
       <pre class="calibre26" id="c01-code-0261"><code class="calibre21">void swap(int* first, int* second)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int temp { *first };</code>
<code class="calibre21">    *first = *second;</code>
<code class="calibre21">    *second = temp;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        However, this code is more cluttered than the version with references. References make your programs cleaner and easier to understand. They are also safer than pointers: it's impossible to have a null reference, and you don't explicitly dereference references, so you can't encounter any of the dereferencing errors associated with pointers. Of course, these arguments about references being safer are valid only in the absence of any pointers. For example, take the following function that accepts a reference to an
        <code class="calibre21">
         int
        </code>
        :
       </p>
       <pre class="calibre26" id="c01-code-0262"><code class="calibre21">void refcall(int&amp; t) { ++t; }</code></pre>
       <p class="calibre13">
        You could declare a pointer and initialize it to point to some random place in memory. Then you could dereference this pointer and pass it as the reference argument to
        <code class="calibre21">
         refcall()
        </code>
        , as in the following code. This code compiles fine, but it is undefined what will happen when executed. It could for example cause a crash.
       </p>
       <pre class="calibre26" id="c01-code-0263"><code class="calibre21">int* ptr { (int*)8 };</code>
<code class="calibre21">refcall(*ptr);</code></pre>
       <p class="calibre13" id="c01-para-0515">
        Most of the time, you can use references instead of pointers. References to objects also support
        <i class="calibre18">
         polymorphism
        </i>
        , discussed in detail in
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        , in the same way as pointers to objects. However, there are some use cases in which you need to use a pointer. One example is when you need to change
        <span aria-label="66" class="calibre20" epub:type="pagebreak" id="Page_66" role="doc-pagebreak">
        </span>
        the location to which it points. Recall that you cannot change the variable to which a reference refers. For example, when you dynamically allocate memory, you need to store a pointer to the result in a pointer rather than a reference. A second use case in which you need to use a pointer is when the pointer is optional, that is, when it can be
        <code class="calibre21">
         nullptr
        </code>
        . Yet another use case is if you want to store polymorphic types (discussed in
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        ) in a container.
       </p>
       <p class="calibre13">
        A long time ago, and in legacy code, a way to distinguish between appropriate use of pointers and references in parameters and return types was to consider who
        <i class="calibre18">
         owns
        </i>
        the memory. If the code receiving the variable became the owner and thus became responsible for releasing the memory associated with an object, it had to receive a pointer to the object. If the code receiving the variable didn't have to free the memory, it received a reference. Nowadays, however, raw pointers should be avoided in favor of
        <i class="calibre18">
         smart pointers
        </i>
        (see
        <a class="calibre5" href="c07.xhtml">
         Chapter 7
        </a>
        ), which is the recommended way to transfer ownership.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0517">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Prefer references over pointers; that is, use a pointer only if a reference is not possible
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Consider a function that splits an array of
        <code class="calibre21">
         int
        </code>
        s into two arrays: one of even numbers and one of odd numbers. The function doesn't know how many numbers in the source array will be even or odd, so it should dynamically allocate the memory for the destination arrays after examining the source array. It should also return the sizes of the two new arrays. Altogether, there are four items to return: pointers to the two new arrays and the sizes of the two new arrays. Obviously, you must use pass-by-reference. The canonical C way to write the function looks like this:
       </p>
       <pre class="calibre26" id="c01-code-0264"><code class="calibre21">void separateOddsAndEvens(const int arr[], size_t size, int** odds,</code>
<code class="calibre21">    size_t* numOdds, int** evens, size_t* numEvens)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Count the number of odds and evens.</span></code>
<code class="calibre21">    *numOdds = *numEvens = 0;</code>
<code class="calibre21">    for (size_t i = 0; i &lt; size; ++i) {</code>
<code class="calibre21">        if (arr[i] % 2 == 1) {</code>
<code class="calibre21">            ++(*numOdds);</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            ++(*numEvens);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Allocate two new arrays of the appropriate size.</span></code>
<code class="calibre21">    *odds = new int[*numOdds];</code>
<code class="calibre21">    *evens = new int[*numEvens];</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Copy the odds and evens to the new arrays.</span></code>
<code class="calibre21">    size_t oddsPos = 0, evensPos = 0;</code>
<code class="calibre21">    for (size_t i = 0; i &lt; size; ++i) {</code>
<code class="calibre21">        if (arr[i] % 2 == 1) {</code>
<code class="calibre21">            (*odds)[oddsPos++] = arr[i];</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            (*evens)[evensPos++] = arr[i];</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="67" class="calibre20" epub:type="pagebreak" id="Page_67" role="doc-pagebreak">
        </span>
        The final four parameters to the function are the “reference” parameters. To change the values to which they refer,
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        must dereference them, leading to some ugly syntax in the function body. Additionally, when you want to call
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        , you must pass the address of two pointers so that the function can change the actual pointers, and pass the address of two
        <code class="calibre21">
         size_t
        </code>
        s so that the function can change the actual
        <code class="calibre21">
         size_t
        </code>
        s. Note also that the caller is responsible for deleting the two arrays created by
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        !
       </p>
       <pre class="calibre26" id="c01-code-0265"><code class="calibre21">int unSplit[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">int* oddNums { nullptr };</code>
<code class="calibre21">int* evenNums { nullptr };</code>
<code class="calibre21">size_t numOdds { 0 }, numEvens { 0 };</code>
<code class="calibre21"> </code>
<code class="calibre21">separateOddsAndEvens(unSplit, std::size(unSplit),</code>
<code class="calibre21">    &amp;oddNums, &amp;numOdds, &amp;evenNums, &amp;numEvens);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Use the arrays…</span></code>
<code class="calibre21"> </code>
<code class="calibre21">delete[] oddNums; oddNums = nullptr;</code>
<code class="calibre21">delete[] evenNums; evenNums = nullptr;</code></pre>
       <p class="calibre13">
        If this syntax annoys you (which it should), you can write the same function by using references to obtain true pass-by-reference semantics:
       </p>
       <pre class="calibre26" id="c01-code-0266"><code class="calibre21"><b class="calibre14">void separateOddsAndEvens(const int arr[], size_t size, int*&amp; odds,</b></code>
<code class="calibre21">    <b class="calibre14">size_t&amp; numOdds, int*&amp; evens, size_t&amp; numEvens)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">numOdds = numEvens = 0;</b></code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">        if (arr[i] % 2 == 1) {</code>
<code class="calibre21">            <b class="calibre14">++numOdds;</b></code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            <b class="calibre14">++numEvens;</b></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <b class="calibre14">odds = new int[numOdds];</b></code>
<code class="calibre21">    <b class="calibre14">evens = new int[numEvens];</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    size_t oddsPos { 0 }, evensPos { 0 };</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">        if (arr[i] % 2 == 1) {</code>
<code class="calibre21">            <b class="calibre14">odds[oddsPos++] = arr[i];</b></code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            <b class="calibre14">evens[evensPos++] = arr[i];</b></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        In this case, the
        <code class="calibre21">
         odds
        </code>
        and
        <code class="calibre21">
         evens
        </code>
        parameters are references to
        <code class="calibre21">
         int*
        </code>
        s.
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        can modify the
        <code class="calibre21">
         int*
        </code>
        s that are used as arguments to the function (through the reference), without any explicit dereferencing. The same logic applies to
        <code class="calibre21">
         numOdds
        </code>
        and
        <code class="calibre21">
         numEvens
        </code>
        , which are references to
        <code class="calibre21">
         size_t
        </code>
        s. With this version of the function, you no longer need to pass the addresses of the pointers or
        <code class="calibre21">
         size_t
        </code>
        s; the reference parameters handle it for you automatically:
       </p>
       <pre class="calibre26" id="c01-code-0267"><code class="calibre21">separateOddsAndEvens(unSplit, std::size(unSplit),</code>
<code class="calibre21">    <b class="calibre14">oddNums, numOdds, evenNums, numEvens);</b></code></pre>
       <p class="calibre13">
        <span aria-label="68" class="calibre20" epub:type="pagebreak" id="Page_68" role="doc-pagebreak">
        </span>
        Even though using reference parameters is already much cleaner than using pointers, it is recommended that you avoid dynamically allocated arrays as much as possible. For example, by using the Standard Library
        <code class="calibre21">
         vector
        </code>
        container, the
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        function can be rewritten to be much safer, shorter, more elegant, and much more readable, because all memory allocations and deallocations happen automatically.
       </p>
       <pre class="calibre26" id="c01-code-0268"><code class="calibre21">void separateOddsAndEvens(const vector&lt;int&gt;&amp; arr,</code>
<code class="calibre21">    vector&lt;int&gt;&amp; odds, vector&lt;int&gt;&amp; evens)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (int i : arr) {</code>
<code class="calibre21">        if (i % 2 == 1) {</code>
<code class="calibre21">            odds.push_back(i);</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            evens.push_back(i);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        This version can be used as follows:
       </p>
       <pre class="calibre26" id="c01-code-0269"><code class="calibre21">vector&lt;int&gt; vecUnSplit { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">vector&lt;int&gt; odds, evens;</code>
<code class="calibre21">separateOddsAndEvens(vecUnSplit, odds, evens);</code></pre>
       <p class="calibre13" id="c01-para-0524">
        Note that you don't need to deallocate the
        <code class="calibre21">
         odds
        </code>
        and
        <code class="calibre21">
         evens
        </code>
        containers; the
        <code class="calibre21">
         vector
        </code>
        class takes care of this. This version is much easier to use than the versions using pointers or references.
       </p>
       <p class="calibre13" id="c01-para-0525">
        The version using
        <code class="calibre21">
         vector
        </code>
        s is already much better than the versions using pointers or references, but as I recommended earlier, output parameters should be avoided as much as possible. If a function needs to return something, it should just return it instead of using output parameters! Since C++17, a compiler is not allowed to perform any copying or moving of objects for statements of the form
        <code class="calibre21">
         return object;
        </code>
        where
        <code class="calibre21">
         object
        </code>
        is a nameless temporary. This is called
        <i class="calibre18">
         mandatory elision of copy/move operations
        </i>
        and means that there's no performance penalty at all by returning
        <code class="calibre21">
         object
        </code>
        by value. If
        <code class="calibre21">
         object
        </code>
        is a local variable that is not a function parameter,
        <i class="calibre18">
         non-mandatory elision of copy/move operations
        </i>
        is allowed, an optimization also known as
        <i class="calibre18">
         named return value optimization
        </i>
        (NRVO). This optimization is not guaranteed by the standard. Some compilers perform this optimization only for release builds but not for debug builds. With mandatory and non-mandatory elision, compilers can avoid any copying of objects that are returned from functions. This results in
        <i class="calibre18">
         zero-copy pass-by-value
        </i>
        semantics. Note that for NRVO, even though the copy/move constructors won't be called, they still need to be accessible; otherwise, the program is ill-formed according to the standard. Copy/move operations and constructors are discussed in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        , but those details are not important for the current discussion.
       </p>
       <p class="calibre13">
        The following version of
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        returns a simple
        <code class="calibre21">
         struct
        </code>
        of two
        <code class="calibre21">
         vector
        </code>
        s, instead of accepting two output
        <code class="calibre21">
         vector
        </code>
        s as parameters, and uses designated initializers.
       </p>
       <pre class="calibre26" id="c01-code-0270"><code class="calibre21">struct OddsAndEvens { vector&lt;int&gt; odds, evens; };</code>
<code class="calibre21"> </code>
<code class="calibre21">OddsAndEvens separateOddsAndEvens(const vector&lt;int&gt;&amp; arr)</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;int&gt; odds, evens;</code>
<code class="calibre21">    for (int i : arr) {</code>
<code class="calibre21">        if (i % 2 == 1) {</code>
<code class="calibre21">            odds.push_back(i);</code>
<span aria-label="69" class="calibre20" epub:type="pagebreak" id="Page_69" role="doc-pagebreak"></span><code class="calibre21">        } else {</code>
<code class="calibre21">            evens.push_back(i);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return OddsAndEvens { .odds = odds, .evens = evens };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        With these changes, the code to call
        <code class="calibre21">
         separateOddsAndEvens()
        </code>
        becomes compact yet easy to read and understand:
       </p>
       <pre class="calibre26" id="c01-code-0271"><code class="calibre21">vector&lt;int&gt; vecUnSplit { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">auto oddsAndEvens { separateOddsAndEvens(vecUnSplit) };</code>
<code class="calibre21"><span class="color">// Do something with oddsAndEvens.odds and oddsAndEvens.evens…</span></code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c01-para-0529">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Avoid output parameters. If a function needs to return something, just return it by value
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0125">
      </span>
      <h3 class="calibre27" id="head-3-89">
       const_cast()
      </h3>
      <p class="calibre13" id="c01-para-0530">
       In C++ every variable has a specific type. It is possible in certain situations to cast a variable of one type to a variable of another type. To that end, C++ provides five types of casts:
       <code class="calibre21">
        const_cast()
       </code>
       ,
       <code class="calibre21">
        static_cast()
       </code>
       ,
       <code class="calibre21">
        reinterpret_cast()
       </code>
       ,
       <code class="calibre21">
        dynamic_cast()
       </code>
       , and
       <code class="calibre21">
        std::bit_cast()
       </code>
       . This section discusses
       <code class="calibre21">
        const_cast()
       </code>
       . The second type of cast,
       <code class="calibre21">
        static_cast()
       </code>
       , is briefly introduced earlier in this chapter and discussed in more detail in
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       . The other remaining casts are also discussed in
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       .
      </p>
      <p class="calibre13">
       <code class="calibre21">
        const_cast()
       </code>
       is the most straightforward of the different casts available. You can use it to add
       <code class="calibre21">
        const
       </code>
       -ness to a variable or cast away
       <code class="calibre21">
        const
       </code>
       -ness of a variable. It is the only cast of the five that is allowed to cast away
       <code class="calibre21">
        const
       </code>
       -ness. Theoretically, of course, there should be no need for a
       <code class="calibre21">
        const
       </code>
       cast. If a variable is
       <code class="calibre21">
        const
       </code>
       , it should stay
       <code class="calibre21">
        const
       </code>
       . In practice, however, you sometimes find yourself in a situation where a function is specified to take a
       <code class="calibre21">
        const
       </code>
       parameter, which it must then pass to a function that takes a non-
       <code class="calibre21">
        const
       </code>
       parameter, and you are absolutely sure that the latter function will not modify its non-
       <code class="calibre21">
        const
       </code>
       argument. The “correct” solution would be to make
       <code class="calibre21">
        const
       </code>
       consistent in the program, but that is not always an option, especially if you are using third-party libraries. Thus, you sometimes need to cast away the
       <code class="calibre21">
        const
       </code>
       -ness of a variable, but again you should do this only when you are sure the function you are calling will not modify the object; otherwise, there is no other option than to restructure your program. Here is an example:
      </p>
      <pre class="calibre26" id="c01-code-0272"><code class="calibre21">void thirdPartyLibraryFunction(char* str);</code>
<code class="calibre21"> </code>
<code class="calibre21">void f(const char* str)</code>
<code class="calibre21">{</code>
<code class="calibre21">    thirdPartyLibraryFunction(const_cast&lt;char*&gt;(str));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Additionally, the Standard Library provides a helper function called
       <code class="calibre21">
        std::as_const()
       </code>
       , defined in
       <code class="calibre21">
        &lt;utility&gt;
       </code>
       , which returns a reference-to-
       <code class="calibre21">
        const
       </code>
       of its reference parameter. Basically,
       <code class="calibre21">
        as_const(obj)
       </code>
       is equivalent to
       <code class="calibre21">
        const_cast&lt;const T&amp;&gt;(obj)
       </code>
       , where
       <code class="calibre21">
        T
       </code>
       is the type of
       <code class="calibre21">
        obj
       </code>
       . Using
       <code class="calibre21">
        as_const()
       </code>
       results
       <span aria-label="70" class="calibre20" epub:type="pagebreak" id="Page_70" role="doc-pagebreak">
       </span>
       in shorter and more readable code compared to using
       <code class="calibre21">
        const_cast()
       </code>
       . Concrete use cases for
       <code class="calibre21">
        as_const()
       </code>
       are coming later in this book, but its basic use is as follows:
      </p>
      <pre class="calibre26" id="c01-code-0273"><code class="calibre21">string str { "C++" };</code>
<code class="calibre21">const string&amp; constStr { as_const(str) };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0126">
      </span>
      <h3 class="calibre27" id="head-3-90">
       Exceptions
      </h3>
      <p class="calibre13" id="c01-para-0533">
       C++ is a flexible language, but it does allow you to do unsafe things. For example, the compiler will let you write code that scribbles on random memory addresses or tries to divide by zero (computers don't deal well with infinity). One language feature that attempts to add a degree of safety is
       <i class="calibre18">
        exceptions
       </i>
       .
      </p>
      <p class="calibre13" id="c01-para-0534">
       An exception is an exceptional situation, that is, a situation that you don't expect or want in the normal flow of execution of a program. For example, if you are writing a function that retrieves a web page, several things could go wrong. The Internet host that contains the page might be down, the page might come back blank, or the connection could be lost. One way you could handle this situation is by returning a special value from the function, such as
       <code class="calibre21">
        nullptr
       </code>
       or an error code. Exceptions provide a much better mechanism for dealing with problems.
      </p>
      <p class="calibre13">
       Exceptions come with some new terminology. When a piece of code detects an exceptional situation, it
       <i class="calibre18">
        throws
       </i>
       an exception. Another piece of code
       <i class="calibre18">
        catches
       </i>
       the exception and takes appropriate action. The following example shows a function,
       <code class="calibre21">
        divideNumbers()
       </code>
       , that throws an exception if the caller passes in a denominator of zero. The
       <code class="calibre21">
        std::invalid_argument
       </code>
       exception is defined in
       <code class="calibre21">
        &lt;stdexcept&gt;
       </code>
       .
      </p>
      <pre class="calibre26" id="c01-code-0274"><code class="calibre21">double divideNumbers(double numerator, double denominator)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (denominator == 0) {</code>
<code class="calibre21">        throw invalid_argument { "Denominator cannot be 0." };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return numerator / denominator;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       When the
       <code class="calibre21">
        throw
       </code>
       statement is executed, the function immediately ends without returning a value. If the caller surrounds the function call with a
       <code class="calibre21">
        try/catch
       </code>
       block, as shown in the following code, it receives the exception and is able to handle it.
       <a class="calibre5" href="c14.xhtml">
        Chapter 14
       </a>
       , “Handling Errors,” goes into much more detail on exception handling, but for now, just remember that it is recommended to catch exceptions by reference-to-
       <code class="calibre21">
        const
       </code>
       , such as
       <code class="calibre21">
        const invalid_argument&amp;
       </code>
       in the following example. Also note that all Standard Library exception classes have a member function called
       <code class="calibre21">
        what()
       </code>
       , which returns a string containing a brief explanation of the exception.
      </p>
      <pre class="calibre26" id="c01-code-0275"><code class="calibre21">try {</code>
<code class="calibre21">    println("{}", divideNumbers(2.5, 0.5));</code>
<code class="calibre21">    println("{}", divideNumbers(2.3, 0));</code>
<code class="calibre21">    println("{}", divideNumbers(4.5, 2.5));</code>
<code class="calibre21">} catch (const invalid_argument&amp; exception) {</code>
<code class="calibre21">    println("Exception caught: {}", exception.what());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The first call to
       <code class="calibre21">
        divideNumbers()
       </code>
       executes successfully, and the result is printed on the screen. The second call throws an exception. No value is returned, and the only output is the error message that is printed when the exception is caught. The third call is never executed because the second call throws
       <span aria-label="71" class="calibre20" epub:type="pagebreak" id="Page_71" role="doc-pagebreak">
       </span>
       an exception, causing the program to jump to the
       <code class="calibre21">
        catch
       </code>
       block. The output for the preceding code snippet is as follows:
      </p>
      <pre class="calibre26" id="c01-code-0276"><code class="calibre21">5</code>
<code class="calibre21">Exception caught: Denominator cannot be 0.</code></pre>
      <p class="calibre13" id="c01-para-0538">
       Exceptions can get tricky in C++. To use exceptions properly, you need to understand what happens to the stack variables when an exception is thrown, and you have to be careful to properly catch and handle the necessary exceptions. Also, if you need to include more information about an error in an exception, you can write your own exception types. Lastly, the C++ compiler doesn't force you to catch every exception that might occur. If your code never catches any exceptions but an exception is thrown, the program will be terminated. These trickier aspects of exceptions are covered in detail in
       <a class="calibre5" href="c14.xhtml">
        Chapter 14
       </a>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0127">
      </span>
      <h3 class="calibre27" id="head-3-91">
       Type Aliases
      </h3>
      <p class="calibre13">
       A
       <i class="calibre18">
        type alias
       </i>
       provides a new name for an existing type declaration. You can think of a type alias as syntax for introducing a synonym for an existing type declaration without creating a new type. The following gives a new name,
       <code class="calibre21">
        IntPtr
       </code>
       , to the
       <code class="calibre21">
        int*
       </code>
       type declaration:
      </p>
      <pre class="calibre26" id="c01-code-0277"><code class="calibre21">using IntPtr = int*;</code></pre>
      <p class="calibre13">
       You can use the new type name and the definition it aliases interchangeably. For example, the following two lines are valid:
      </p>
      <pre class="calibre26" id="c01-code-0278"><code class="calibre21">int* p1;</code>
<code class="calibre21">IntPtr p2;</code></pre>
      <p class="calibre13">
       Variables created with the new type name are completely compatible with those created with the original type declaration. So, it is perfectly valid, given these definitions, to write the following, because they are not just compatible types; they are the same type:
      </p>
      <pre class="calibre26" id="c01-code-0279"><code class="calibre21">p1 = p2;</code>
<code class="calibre21">p2 = p1;</code></pre>
      <p class="calibre13">
       The most common use for type aliases is to provide manageable names when the real type declarations become too unwieldy. This situation commonly arises with templates. An example from the Standard Library itself is
       <code class="calibre21">
        std::basic_string&lt;T&gt;
       </code>
       to represent strings. It's a class template where
       <code class="calibre21">
        T
       </code>
       is the type of each character in the string, for example
       <code class="calibre21">
        char
       </code>
       . You have to specify the template type parameter any time you want to refer to such a type. For declaring variables, specifying function parameters, and so on, you would have to write
       <code class="calibre21">
        basic_string&lt;char&gt;
       </code>
       :
      </p>
      <pre class="calibre26" id="c01-code-0280"><code class="calibre21">void processVector(const vector&lt;<b class="calibre14">basic_string&lt;char&gt;</b>&gt;&amp; vec) { <span class="color">/* omitted */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;<b class="calibre14">basic_string&lt;char&gt;</b>&gt; myVector;</code>
<code class="calibre21">    processVector(myVector);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Since
       <code class="calibre21">
        basic_string&lt;char&gt;
       </code>
       is used that frequently, the Standard Library provides the following type alias as a shorter, more meaningful name:
      </p>
      <pre class="calibre26" id="c01-code-0281"><code class="calibre21">using string = basic_string&lt;char&gt;;</code></pre>
      <p class="calibre13">
       <span aria-label="72" class="calibre20" epub:type="pagebreak" id="Page_72" role="doc-pagebreak">
       </span>
       With this type alias, the previous code snippet can be written more elegantly:
      </p>
      <pre class="calibre26" id="c01-code-0282"><code class="calibre21">void processVector(const vector&lt;<b class="calibre14">string</b>&gt;&amp; vec) { <span class="color">/* omitted */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;<b class="calibre14">string</b>&gt; myVector;</code>
<code class="calibre21">    processVector(myVector);</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0128">
      </span>
      <h3 class="calibre27" id="head-3-92">
       typedefs
      </h3>
      <p class="calibre13" id="c01-para-0545">
       Type aliases were introduced in C++11. Before C++11, you had to use
       <code class="calibre21">
        typedef
       </code>
       s to accomplish something similar but in a more convoluted way. This old mechanism is still explained here because you will come across it in legacy code bases.
      </p>
      <p class="calibre13">
       Just as a type alias, a
       <code class="calibre21">
        typedef
       </code>
       provides a new name for an existing type declaration. For example, take the following type alias:
      </p>
      <pre class="calibre26" id="c01-code-0283"><code class="calibre21">using IntPtr = int*;</code></pre>
      <p class="calibre13">
       This can be written as follows with a
       <code class="calibre21">
        typedef
       </code>
       :
      </p>
      <pre class="calibre26" id="c01-code-0284"><code class="calibre21">typedef int* IntPtr;</code></pre>
      <p class="calibre13">
       As you can see, it's much less readable. The order is reversed, which causes a lot of confusion, even for professional C++ developers. Other than being more convoluted, a
       <code class="calibre21">
        typedef
       </code>
       behaves the same as a type alias. For example, the
       <code class="calibre21">
        typedef
       </code>
       can be used as follows:
      </p>
      <pre class="calibre26" id="c01-code-0285"><code class="calibre21">IntPtr p;</code></pre>
      <p class="calibre13">
       Type aliases and
       <code class="calibre21">
        typedef
       </code>
       s are not entirely equivalent, though. Compared to
       <code class="calibre21">
        typedef
       </code>
       s, type aliases are more powerful when used with templates, but that is a topic covered in
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       because it requires more details about templates.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c01-para-0550">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Always prefer type aliases over
           <code class="calibre21">
            typedef
           </code>
           s
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0130">
      </span>
      <h3 class="calibre27" id="head-3-93">
       Type Inference
      </h3>
      <p class="calibre13" id="c01-para-0551">
       <i class="calibre18">
        Type inference
       </i>
       allows the compiler to automatically deduce the type of an expression. There are two keywords for type inference:
       <code class="calibre21">
        auto
       </code>
       and
       <code class="calibre21">
        decltype
       </code>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0131">
       </span>
       <h4 class="calibre29" id="head-4-51">
        The auto Keyword
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         auto
        </code>
        keyword has a number of different uses:
       </p>
       <ul class="check" id="c01-list-0015">
        <li class="calibre9" id="c01-li-0055">
         To deduce a function's return type, as explained earlier in this chapter
        </li>
        <li class="calibre9" id="c01-li-0056">
         To define structured bindings, as explained earlier in this chapter
        </li>
        <li class="calibre9" id="c01-li-0057">
         To deduce the type of an expression, as discussed in this section
        </li>
        <li class="calibre9" id="c01-li-0058">
         <span aria-label="73" class="calibre20" epub:type="pagebreak" id="Page_73" role="doc-pagebreak">
         </span>
         To deduce the type of non-type template parameters; see
         <a class="calibre5" href="c12.xhtml">
          Chapter 12
         </a>
        </li>
        <li class="calibre9" id="c01-li-0059">
         To define abbreviated function templates; see
         <a class="calibre5" href="c12.xhtml">
          Chapter 12
         </a>
        </li>
        <li class="calibre9" id="c01-li-0060">
         To use with
         <code class="calibre21">
          decltype(auto)
         </code>
         ; see
         <a class="calibre5" href="c12.xhtml">
          Chapter 12
         </a>
        </li>
        <li class="calibre9" id="c01-li-0061">
         To write functions using the alternative function syntax; see
         <a class="calibre5" href="c12.xhtml">
          Chapter 12
         </a>
        </li>
        <li class="calibre9" id="c01-li-0062">
         To write generic lambda expressions; see
         <a class="calibre5" href="c19.xhtml">
          Chapter 19
         </a>
         , “Function Pointers, Function Objects, and Lambda Expressions”
        </li>
       </ul>
       <p class="calibre13">
        <code class="calibre21">
         auto
        </code>
        can be used to let the compiler automatically deduce the type of a variable at compile time. The following statement shows the simplest use of the
        <code class="calibre21">
         auto
        </code>
        keyword in that context:
       </p>
       <pre class="calibre26" id="c01-code-0286"><code class="calibre21">auto x { 123 };    <span class="color">// x is of type int.</span></code></pre>
       <p class="calibre13">
        In this example, you don't win much by typing
        <code class="calibre21">
         auto
        </code>
        instead of
        <code class="calibre21">
         int
        </code>
        ; however, it becomes useful for more complicated types. Suppose you have a function called
        <code class="calibre21">
         getFoo()
        </code>
        that has a complicated return type. If you want to assign the result of calling
        <code class="calibre21">
         getFoo()
        </code>
        to a variable, you can spell out the complicated type, or you can simply use
        <code class="calibre21">
         auto
        </code>
        and let the compiler figure it out:
       </p>
       <pre class="calibre26" id="c01-code-0287"><code class="calibre21">auto result { getFoo() };</code></pre>
       <p class="calibre13" id="c01-para-0555">
        This has the added benefit that you can easily change the function's return type without having to update all the places in the code where that function is called.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0132">
        </span>
        <h5 class="calibre35" id="head-5-14">
         The auto&amp; Syntax
        </h5>
        <p class="calibre13">
         Using
         <code class="calibre21">
          auto
         </code>
         to deduce the type of an expression strips away reference and
         <code class="calibre21">
          const
         </code>
         qualifiers. Suppose you have the following:
        </p>
        <pre class="calibre26" id="c01-code-0288"><code class="calibre21">const string message { "Test" };</code>
<code class="calibre21">const string&amp; foo() { return message; }</code></pre>
        <p class="calibre13">
         You can call
         <code class="calibre21">
          foo()
         </code>
         and store the result in a variable with the type specified as
         <code class="calibre21">
          auto
         </code>
         , as follows:
        </p>
        <pre class="calibre26" id="c01-code-0289"><code class="calibre21">auto f1 { foo() };</code></pre>
        <p class="calibre13">
         Because
         <code class="calibre21">
          auto
         </code>
         strips away reference and
         <code class="calibre21">
          const
         </code>
         qualifiers,
         <code class="calibre21">
          f1
         </code>
         is of type
         <code class="calibre21">
          string
         </code>
         , and thus a
         <i class="calibre18">
          copy
         </i>
         is made! If you want a reference-to-
         <code class="calibre21">
          const
         </code>
         , you can explicitly make it a reference and mark it
         <code class="calibre21">
          const
         </code>
         , as follows:
        </p>
        <pre class="calibre26" id="c01-code-0290"><code class="calibre21">const auto&amp; f2 { foo() };</code></pre>
        <p class="calibre13">
         Earlier in this chapter, the
         <code class="calibre21">
          as_const()
         </code>
         utility function is introduced. It returns a reference-to-
         <code class="calibre21">
          const
         </code>
         version of its reference parameter. Be careful when using
         <code class="calibre21">
          as_const()
         </code>
         in combination with
         <code class="calibre21">
          auto
         </code>
         . Since
         <code class="calibre21">
          auto
         </code>
         strips away reference and
         <code class="calibre21">
          const
         </code>
         qualifiers, the following
         <code class="calibre21">
          result
         </code>
         variable has type
         <code class="calibre21">
          string
         </code>
         , not
         <code class="calibre21">
          const string&amp;
         </code>
         , and hence a copy is made:
        </p>
        <pre class="calibre26" id="c01-code-0291"><code class="calibre21">string str { "C++" };</code>
<code class="calibre21">auto result { as_const(str) };</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c01-para-0561">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Always keep in mind that
             <code class="calibre21">
              auto
             </code>
             strips away reference and
            </i>
            <code class="calibre21">
             const
            </code>
            <i class="calibre18">
             qualifiers and thus creates a copy! If you do not want a copy, use
            </i>
            <code class="calibre21">
             auto
             <i class="calibre18">
              &amp;
             </i>
            </code>
            <i class="calibre18">
             or
            </i>
            <code class="calibre21">
             const auto&amp;
            </code>
            <i class="calibre18">
             .
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <span aria-label="74" class="calibre20" epub:type="pagebreak" id="Page_74" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0134">
        </span>
        <h5 class="calibre35" id="head-5-15">
         The auto* Syntax
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          auto
         </code>
         keyword can also be used for pointers. Here's an example:
        </p>
        <pre class="calibre26" id="c01-code-0292"><code class="calibre21">int i { 123 };</code>
<code class="calibre21">auto p { &amp;i };</code></pre>
        <p class="calibre13">
         The type of
         <code class="calibre21">
          p
         </code>
         is
         <code class="calibre21">
          int*
         </code>
         . There is no danger here to accidentally make a copy, unlike when working with references as discussed in the previous section. However, when working with pointers, I do recommend using the
         <code class="calibre21">
          auto*
         </code>
         syntax as it more clearly states that pointers are involved, for example:
        </p>
        <pre class="calibre26" id="c01-code-0293"><code class="calibre21">auto* p { &amp;i };</code></pre>
        <p class="calibre13">
         Additionally, using
         <code class="calibre21">
          auto*
         </code>
         versus just
         <code class="calibre21">
          auto
         </code>
         does resolve a strange behavior when using
         <code class="calibre21">
          auto
         </code>
         ,
         <code class="calibre21">
          const
         </code>
         , and pointers together. Suppose you write the following:
        </p>
        <pre class="calibre26" id="c01-code-0294"><code class="calibre21">const auto p1 { &amp;i };</code></pre>
        <p class="calibre13" id="c01-para-0565">
         Most of the time, this is not doing what you expect it to do!
        </p>
        <p class="calibre13">
         Often, when you use
         <code class="calibre21">
          const
         </code>
         , you want to protect the thing to which the pointer is pointing to. You would think that
         <code class="calibre21">
          p1
         </code>
         is of type
         <code class="calibre21">
          const int*
         </code>
         , but in fact, the type is
         <code class="calibre21">
          int* const
         </code>
         , so it's a
         <code class="calibre21">
          const
         </code>
         pointer to a non-
         <code class="calibre21">
          const
         </code>
         integer! Putting the
         <code class="calibre21">
          const
         </code>
         after the
         <code class="calibre21">
          auto
         </code>
         as follows doesn't help; the type is still
         <code class="calibre21">
          int* const
         </code>
         :
        </p>
        <pre class="calibre26" id="c01-code-0295"><code class="calibre21">auto const p2 { &amp;i };</code></pre>
        <p class="calibre13">
         When you use
         <code class="calibre21">
          auto*
         </code>
         in combination with
         <code class="calibre21">
          const
         </code>
         , then it is behaving as you would expect. Here's an example:
        </p>
        <pre class="calibre26" id="c01-code-0296"><code class="calibre21">const auto* p3 { &amp;i };</code></pre>
        <p class="calibre13">
         Now
         <code class="calibre21">
          p3
         </code>
         is of type
         <code class="calibre21">
          const int*
         </code>
         . If you really want a
         <code class="calibre21">
          const
         </code>
         pointer instead of a
         <code class="calibre21">
          const
         </code>
         integer, you put the
         <code class="calibre21">
          const
         </code>
         at the end:
        </p>
        <pre class="calibre26" id="c01-code-0297"><code class="calibre21">auto* const p4 { &amp;i };</code></pre>
        <p class="calibre13" id="c01-para-0569">
         <code class="calibre21">
          p4
         </code>
         has type
         <code class="calibre21">
          int* const
         </code>
         .
        </p>
        <p class="calibre13">
         Finally, with this syntax you can make both the pointer and the integer constant:
        </p>
        <pre class="calibre26" id="c01-code-0298"><code class="calibre21">const auto* const p5 { &amp;i };</code></pre>
        <p class="calibre13" id="c01-para-0571">
         <code class="calibre21">
          p5
         </code>
         is of type
         <code class="calibre21">
          const int* const
         </code>
         . You cannot achieve this if you omit the
         <code class="calibre21">
          *
         </code>
         .
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c01-sec-0135">
        </span>
        <h5 class="calibre35" id="head-5-16">
         Copy List vs. Direct List Initialization
        </h5>
        <p class="calibre13">
         There are two types of initializations that use braced initializer lists:
        </p>
        <ul class="check" id="c01-list-0016">
         <li class="calibre9" id="c01-li-0063">
          <b class="calibre14">
           Copy list initialization:
          </b>
          <code class="calibre21">
           T obj = {arg1, arg2, …};
          </code>
         </li>
         <li class="calibre9" id="c01-li-0064">
          <b class="calibre14">
           Direct list initialization:
          </b>
          <code class="calibre21">
           T obj {arg1, arg2, …};
          </code>
         </li>
        </ul>
        <p class="calibre13">
         In combination with auto type deduction, there is an important difference between copy- and direct list initialization. Here is an example:
        </p>
        <pre class="calibre26" id="c01-code-0299"><code class="calibre21"><span class="color">// Copy list initialization</span></code>
<code class="calibre21">auto a = { 11 };         <span class="color">// initializer_list&lt;int&gt;</span></code>
<code class="calibre21">auto b = { 11, 22 };     <span class="color">// initializer_list&lt;int&gt;</span></code>
<code class="calibre21"> </code>
<span aria-label="75" class="calibre20" epub:type="pagebreak" id="Page_75" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Direct list initialization</span></code>
<code class="calibre21">auto c { 11 };           <span class="color">// int</span></code>
<code class="calibre21">auto d { 11, 22 };       <span class="color">// Error, too many elements.</span></code></pre>
        <p class="calibre13">
         For copy list initialization, all the elements in the braced initializer must be of the same type. For example, the following does not compile:
        </p>
        <pre class="calibre26" id="c01-code-0300"><code class="calibre21">auto b = { 11, 22.33 };  <span class="color">// Compilation error</span></code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0136">
       </span>
       <h4 class="calibre29" id="head-4-52">
        The decltype Keyword
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         decltype
        </code>
        keyword takes an expression as argument and computes the type of that expression, as shown here:
       </p>
       <pre class="calibre26" id="c01-code-0301"><code class="calibre21">int x { 123 };</code>
<code class="calibre21"><b class="calibre14">decltype(x)</b> y { 456 };</code></pre>
       <p class="calibre13" id="c01-para-0576">
        In this example, the compiler deduces the type of
        <code class="calibre21">
         y
        </code>
        to be
        <code class="calibre21">
         int
        </code>
        because that is the type of
        <code class="calibre21">
         x
        </code>
        .
       </p>
       <p class="calibre13">
        The difference between
        <code class="calibre21">
         auto
        </code>
        and
        <code class="calibre21">
         decltype
        </code>
        is that
        <code class="calibre21">
         decltype
        </code>
        does not strip reference and
        <code class="calibre21">
         const
        </code>
        qualifiers. Take, again, a function
        <code class="calibre21">
         foo()
        </code>
        returning a reference-to-
        <code class="calibre21">
         const string
        </code>
        . Defining
        <code class="calibre21">
         f2
        </code>
        using
        <code class="calibre21">
         decltype
        </code>
        as follows results in
        <code class="calibre21">
         f2
        </code>
        being of type
        <code class="calibre21">
         const string&amp;
        </code>
        , and thus no copy is made:
       </p>
       <pre class="calibre26" id="c01-code-0302"><code class="calibre21"><b class="calibre14">decltype(foo())</b> f2 { foo() };</code></pre>
       <p class="calibre13" id="c01-para-0578">
        On first sight,
        <code class="calibre21">
         decltype
        </code>
        doesn't seem to add much value. However, it is powerful in the context of templates, discussed in
        <a class="calibre5" href="c12.xhtml">
         Chapters 12
        </a>
        and
        <a class="calibre5" href="c26.xhtml">
         26
        </a>
        .
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0137">
      </span>
      <h3 class="calibre27" id="head-3-94">
       The Standard Library
      </h3>
      <p class="calibre13" id="c01-para-0579">
       C++ comes with a Standard Library, which contains a lot of useful classes that can readily be used in your code. The benefit of using these classes is that you don't need to reinvent their functionality, and you don't need to waste time on implementing things that have already been implemented for you. Another benefit is that the classes available in the Standard Library are heavily tested and verified for correctness by thousands of users. The Standard Library classes are also optimized for performance, so using them will most likely result in better performance compared to making your own implementation.
      </p>
      <p class="calibre13" id="c01-para-0580">
       A lot of functionality is provided by the Standard Library.
       <a class="calibre5" href="c16.xhtml">
        Chapters 16
       </a>
       to
       <a class="calibre5" href="c24.xhtml">
        24
       </a>
       provide more details; however, when you start working with C++, it is good to have an idea of what the Standard Library can do for you from the beginning. This is especially important if you are a C programmer. As a C programmer, you might try to solve problems in C++ the same way you would solve them in C, but in C++ there is probably an easier and safer solution to the problem that involves using Standard Library classes.
      </p>
      <p class="calibre13" id="c01-para-0581">
       That is the reason why this chapter already introduces some Standard Library classes, such as
       <code class="calibre21">
        std::string
       </code>
       ,
       <code class="calibre21">
        array
       </code>
       ,
       <code class="calibre21">
        vector
       </code>
       ,
       <code class="calibre21">
        pair
       </code>
       , and
       <code class="calibre21">
        optional
       </code>
       . These are used throughout examples in this book from the beginning, to make sure you get into the habit of using Standard Library classes. Many more classes are introduced in
       <a class="calibre5" href="c16.xhtml">
        Chapters 16
       </a>
       to
       <a class="calibre5" href="c24.xhtml">
        24
       </a>
       .
      </p>
     </section>
    </section>
    <span aria-label="76" class="calibre20" epub:type="pagebreak" id="Page_76" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-54" class="calibre2">
     <span class="calibre" id="c01-sec-0138">
     </span>
     <h2 class="calibre6" id="head-2-54">
      YOUR FIRST BIGGER C++ PROGRAM
     </h2>
     <p class="calibre13" id="c01-para-0582">
      The following program builds on the employee database example used earlier in the discussion on structs. This time, you will end up with a fully functional C++ program that uses many of the features discussed in this chapter. This real-world example includes the use of classes, exceptions, streams,
      <code class="calibre21">
       vector
      </code>
      s, namespaces, references, and other language features.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0139">
      </span>
      <h3 class="calibre27" id="head-3-95">
       An Employee Records System
      </h3>
      <p class="calibre13">
       The next sections implement a program to manage a company's employee records with the following feature set:
      </p>
      <ul class="check" id="c01-list-0017">
       <li class="calibre9" id="c01-li-0065">
        Add and fire employees
       </li>
       <li class="calibre9" id="c01-li-0066">
        Promote and demote employees
       </li>
       <li class="calibre9" id="c01-li-0067">
        View all employees, past and present
       </li>
       <li class="calibre9" id="c01-li-0068">
        View all current employees
       </li>
       <li class="calibre9" id="c01-li-0069">
        View all former employees
       </li>
      </ul>
      <p class="calibre13" id="c01-para-0584">
       The design for this program divides the code into three parts. The
       <code class="calibre21">
        Employee
       </code>
       class encapsulates the information describing a single employee. The
       <code class="calibre21">
        Database
       </code>
       class manages all the employees of the company. Finally, a separate
       <code class="calibre21">
        UserInterface
       </code>
       file provides the interactivity of the program.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0140">
      </span>
      <h3 class="calibre27" id="head-3-96">
       The Employee Class
      </h3>
      <p class="calibre13" id="c01-para-0585">
       The
       <code class="calibre21">
        Employee
       </code>
       class maintains all the information about an employee. Its member functions provide a way to query and change that information. An
       <code class="calibre21">
        Employee
       </code>
       also knows how to display herself on the console. Additionally, member functions exist to adjust the employee's salary and employment status.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0141">
       </span>
       <h4 class="calibre29" id="head-4-53">
        Employee.cppm
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         Employee.cppm
        </code>
        module interface file defines the
        <code class="calibre21">
         Employee
        </code>
        class. The sections of this file are described individually in the text that follows. The first few lines are as follows:
       </p>
       <pre class="calibre26" id="c01-code-0303"><code class="calibre21">export module employee;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">namespace Records {</code></pre>
       <p class="calibre13" id="c01-para-0587">
        The first line is a module declaration and states that this file exports a module called
        <code class="calibre21">
         employee
        </code>
        , followed by an import for the Standard Library functionality. This code also declares that the subsequent code, contained within the curly braces, lives in the
        <code class="calibre21">
         Records
        </code>
        namespace.
        <code class="calibre21">
         Records
        </code>
        is the namespace that is used throughout this program for application-specific code.
       </p>
       <p class="calibre13">
        Next, the following two constants are defined inside the
        <code class="calibre21">
         Records
        </code>
        namespace. This book uses the convention to not prefix constants with any special letter and to start them with a capital letter to better contrast them with variables.
       </p>
       <pre class="calibre26" id="c01-code-0304"><code class="calibre21">    const int DefaultStartingSalary { 30'000 };</code>
<code class="calibre21">    export const int DefaultRaiseAndDemeritAmount { 1'000 };</code></pre>
       <p class="calibre13" id="c01-para-0589">
        <span aria-label="77" class="calibre20" epub:type="pagebreak" id="Page_77" role="doc-pagebreak">
        </span>
        The first constant represents the default starting salary for new employees. This constant is not exported, because code outside this module does not need access to it. Code in the
        <code class="calibre21">
         employee
        </code>
        module can access this constant as
        <code class="calibre21">
         Records::DefaultStartingSalary
        </code>
        .
       </p>
       <p class="calibre13" id="c01-para-0590">
        The second constant is the default amount for promoting or demoting an employee. This constant is exported, so code outside this module could, for example, promote an employee by twice the default amount.
       </p>
       <p class="calibre13">
        Next, the
        <code class="calibre21">
         Employee
        </code>
        class is defined and exported, along with its public member functions:
       </p>
       <pre class="calibre26" id="c01-code-0305"><code class="calibre21">    export class Employee</code>
<code class="calibre21">    {</code>
<code class="calibre21">        public:</code>
<code class="calibre21">            Employee(const std::string&amp; firstName,</code>
<code class="calibre21">                     const std::string&amp; lastName);</code>
<code class="calibre21"> </code>
<code class="calibre21">            void promote(int raiseAmount = DefaultRaiseAndDemeritAmount);</code>
<code class="calibre21">            void demote(int demeritAmount = DefaultRaiseAndDemeritAmount);</code>
<code class="calibre21">            void hire(); <span class="color">// Hires or rehires the employee</span></code>
<code class="calibre21">            void fire(); <span class="color">// Dismisses the employee</span></code>
<code class="calibre21">            void display() const; <span class="color">// Prints employee info to console</span></code>
<code class="calibre21"> </code>
<code class="calibre21">            <span class="color">// Getters and setters</span></code>
<code class="calibre21">            void setFirstName(const std::string&amp; firstName);</code>
<code class="calibre21">            const std::string&amp; getFirstName() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">            void setLastName(const std::string&amp; lastName);</code>
<code class="calibre21">            const std::string&amp; getLastName() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">            void setEmployeeNumber(int employeeNumber);</code>
<code class="calibre21">            int getEmployeeNumber() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">            void setSalary(int newSalary);</code>
<code class="calibre21">            int getSalary() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">            bool isHired() const;</code></pre>
       <p class="calibre13" id="c01-para-0592">
        A constructor is provided that accepts a first and last name. The
        <code class="calibre21">
         promote()
        </code>
        and
        <code class="calibre21">
         demote()
        </code>
        member functions both have integer parameters that have a default value equal to
        <code class="calibre21">
         DefaultRaiseAndDemeritAmount
        </code>
        . In this way, other code can omit the parameter, and the default will automatically be used. Member functions to hire and fire an employee are provided, together with a member function to display information about an employee. A number of setters and getters provide functionality to change the information or to query the current information of an employee.
       </p>
       <p class="calibre13">
        The data members are declared as
        <code class="calibre21">
         private
        </code>
        so that other parts of the code cannot modify them directly:
       </p>
       <pre class="calibre26" id="c01-code-0306"><code class="calibre21">        private:</code>
<code class="calibre21">            std::string m_firstName;</code>
<code class="calibre21">            std::string m_lastName;</code>
<code class="calibre21">            int m_employeeNumber { -1 };</code>
<code class="calibre21">            int m_salary { DefaultStartingSalary };</code>
<code class="calibre21">            bool m_hired { false };</code>
<code class="calibre21">    };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0594">
        <span aria-label="78" class="calibre20" epub:type="pagebreak" id="Page_78" role="doc-pagebreak">
        </span>
        The setters and getters provide the only public way of modifying or querying those values. The data members are directly initialized here inside the class definition instead of in a constructor. By default, new employees have no name, an employee number of –1, the default starting salary, and a status of not hired.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0142">
       </span>
       <h4 class="calibre29" id="head-4-54">
        Employee.cpp
       </h4>
       <p class="calibre13">
        The first few lines of the module implementation file are as follows:
       </p>
       <pre class="calibre26" id="c01-code-0307"><code class="calibre21">module employee;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code></pre>
       <p class="calibre13" id="c01-para-0596">
        The first line specifies for which module this source file is, followed by an import of
        <code class="calibre21">
         std
        </code>
        , and a
        <code class="calibre21">
         using
        </code>
        directive.
       </p>
       <p class="calibre13">
        The constructor accepting a first and last name just sets the corresponding data members:
       </p>
       <pre class="calibre26" id="c01-code-0308"><code class="calibre21">namespace Records {</code>
<code class="calibre21">    Employee::Employee(const string&amp; firstName, const string&amp; lastName)</code>
<code class="calibre21">        : m_firstName { firstName }, m_lastName { lastName }</code>
<code class="calibre21">    {</code>
<code class="calibre21">    }</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         promote()
        </code>
        and
        <code class="calibre21">
         demote()
        </code>
        member functions simply call
        <code class="calibre21">
         setSalary()
        </code>
        with a new value. The default values for the integer parameters are not repeated here; they are allowed only in a function declaration, not in a definition.
       </p>
       <pre class="calibre26" id="c01-code-0309"><code class="calibre21">    void Employee::promote(int raiseAmount)</code>
<code class="calibre21">    {</code>
<code class="calibre21">        setSalary(getSalary() + raiseAmount);</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    void Employee::demote(int demeritAmount)</code>
<code class="calibre21">    {</code>
<code class="calibre21">        setSalary(getSalary() - demeritAmount);</code>
<code class="calibre21">    }</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         hire()
        </code>
        and
        <code class="calibre21">
         fire()
        </code>
        member functions just set the
        <code class="calibre21">
         m_hired
        </code>
        data member appropriately:
       </p>
       <pre class="calibre26" id="c01-code-0310"><code class="calibre21">    void Employee::hire() { m_hired = true; }</code>
<code class="calibre21">    void Employee::fire() { m_hired = false; }</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         display()
        </code>
        member function uses
        <code class="calibre21">
         println()
        </code>
        to display information about the current employee. Because this code is part of the
        <code class="calibre21">
         Employee
        </code>
        class, it
        <i class="calibre18">
         could
        </i>
        access data members, such as
        <code class="calibre21">
         m_salary
        </code>
        , directly instead of using getters, such as
        <code class="calibre21">
         getSalary()
        </code>
        . However, it is considered good style to make use of getters and setters when they exist, even from within the class.
       </p>
       <pre class="calibre26" id="c01-code-0311"><code class="calibre21">    void Employee::display() const</code>
<code class="calibre21">    {</code>
<code class="calibre21">        println("Employee: {}, {}", getLastName(), getFirstName());</code>
<code class="calibre21">        println("-------------------------");</code>
<code class="calibre21">        println("{}", (isHired() ? "Current Employee" : "Former Employee"));</code>
<code class="calibre21">        println("Employee Number: {}", getEmployeeNumber());</code>
<code class="calibre21">        println("Salary: ${}", getSalary());</code>
<code class="calibre21">        println("");</code>
<code class="calibre21">    }</code></pre>
       <p class="calibre13">
        <span aria-label="79" class="calibre20" epub:type="pagebreak" id="Page_79" role="doc-pagebreak">
        </span>
        Finally, a number of getters and setters perform the task of getting and setting values:
       </p>
       <pre class="calibre26" id="c01-code-0312"><code class="calibre21">    <span class="color">// Getters and setters</span></code>
<code class="calibre21">    void Employee::setFirstName(const string&amp; firstName) {m_firstName = firstName;}</code>
<code class="calibre21">    const string&amp; Employee::getFirstName() const { return m_firstName; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    void Employee::setLastName(const string&amp; lastName) { m_lastName = lastName; }</code>
<code class="calibre21">    const string&amp; Employee::getLastName() const { return m_lastName; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    void Employee::setEmployeeNumber(int employeeNumber) {</code>
<code class="calibre21">        m_employeeNumber = employeeNumber; }</code>
<code class="calibre21">    int Employee::getEmployeeNumber() const { return m_employeeNumber; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    void Employee::setSalary(int salary) { m_salary = salary; }</code>
<code class="calibre21">    int Employee::getSalary() const { return m_salary; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    bool Employee::isHired() const { return m_hired; }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0602">
        Even though these member functions seem trivial, it's better to have trivial getters and setters than to make your data members
        <code class="calibre21">
         public
        </code>
        . For example, in the future, you may want to perform bounds checking in the
        <code class="calibre21">
         setSalary()
        </code>
        member function. Getters and setters also make debugging easier because you can insert a breakpoint in them to inspect values when they are retrieved or set. Another reason is that when you decide to change how you are storing the data in your class, you only need to modify these getters and setters, while other code using your class can remain untouched.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0143">
       </span>
       <h4 class="calibre29" id="head-4-55">
        EmployeeTest.cpp
       </h4>
       <p class="calibre13">
        As you write individual classes, it is often useful to test them in isolation. The following code includes a
        <code class="calibre21">
         main()
        </code>
        function that performs some simple operations using the
        <code class="calibre21">
         Employee
        </code>
        class. Once you are confident that the
        <code class="calibre21">
         Employee
        </code>
        class works, you should remove or comment out this file so that you don't attempt to compile your code with multiple
        <code class="calibre21">
         main()
        </code>
        functions.
       </p>
       <pre class="calibre26" id="c01-code-0313"><code class="calibre21">import std;</code>
<code class="calibre21">import employee;</code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">using namespace Records;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("Testing the Employee class.");</code>
<code class="calibre21">    Employee emp { "Jane", "Doe" };</code>
<code class="calibre21">    emp.setFirstName("John");</code>
<code class="calibre21">    emp.setLastName("Doe");</code>
<code class="calibre21">    emp.setEmployeeNumber(71);</code>
<code class="calibre21">    emp.setSalary(50'000);</code>
<code class="calibre21">    emp.promote();</code>
<code class="calibre21">    emp.promote(50);</code>
<code class="calibre21">    emp.hire();</code>
<code class="calibre21">    emp.display();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0604">
        Another and much better way to test individual classes is with
        <i class="calibre18">
         unit testing
        </i>
        , discussed in
        <a class="calibre5" href="c30.xhtml">
         Chapter 30
        </a>
        , “Becoming Adept at Testing.” Unit tests are small pieces of code to test specific functionality and that
        <span aria-label="80" class="calibre20" epub:type="pagebreak" id="Page_80" role="doc-pagebreak">
        </span>
        remain in the code base. All unit tests are frequently executed; for example, they can automatically be executed by your build system. The benefit of doing this is that if you make some changes to existing functionality, the unit tests will instantly warn you if you break something.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0144">
      </span>
      <h3 class="calibre27" id="head-3-97">
       The Database Class
      </h3>
      <p class="calibre13" id="c01-para-0605">
       The
       <code class="calibre21">
        Database
       </code>
       class is implemented next. It uses the
       <code class="calibre21">
        std::vector
       </code>
       class from the Standard Library to store
       <code class="calibre21">
        Employee
       </code>
       objects.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0145">
       </span>
       <h4 class="calibre29" id="head-4-56">
        Database.cppm
       </h4>
       <p class="calibre13">
        Here are the first few lines of the
        <code class="calibre21">
         database.cppm
        </code>
        module interface file:
       </p>
       <pre class="calibre26" id="c01-code-0314"><code class="calibre21">export module database;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">import employee;</code>
<code class="calibre21"> </code>
<code class="calibre21">namespace Records {</code>
<code class="calibre21">    const int FirstEmployeeNumber { 1'000 };</code></pre>
       <p class="calibre13" id="c01-para-0607">
        Because the database will take care of automatically assigning an employee number to a new employee, a constant defines where the numbering begins.
       </p>
       <p class="calibre13">
        Next, the
        <code class="calibre21">
         Database
        </code>
        class is defined and exported:
       </p>
       <pre class="calibre26" id="c01-code-0315"><code class="calibre21">    export class Database</code>
<code class="calibre21">    {</code>
<code class="calibre21">        public:</code>
<code class="calibre21">            Employee&amp; addEmployee(const std::string&amp; firstName,</code>
<code class="calibre21">                                  const std::string&amp; lastName);</code>
<code class="calibre21">            Employee&amp; getEmployee(int employeeNumber);</code>
<code class="calibre21">            Employee&amp; getEmployee(const std::string&amp; firstName,</code>
<code class="calibre21">                                  const std::string&amp; lastName);</code></pre>
       <p class="calibre13" id="c01-para-0609">
        The database provides an easy way to add a new employee by providing a first and last name. For convenience, this member function returns a reference to the new employee. External code can also get an employee reference by calling the
        <code class="calibre21">
         getEmployee()
        </code>
        member function. Two overloads of this member function are declared. One allows retrieval by employee number. The other requires a first and last name.
       </p>
       <p class="calibre13">
        Because the database is the central repository for all employee records, it has the following member functions to display all employees, the employees who are currently hired, and the employees who are no longer hired:
       </p>
       <pre class="calibre26" id="c01-code-0316"><code class="calibre21">            void displayAll() const;</code>
<code class="calibre21">            void displayCurrent() const;</code>
<code class="calibre21">            void displayFormer() const;</code></pre>
       <p class="calibre13">
        Finally, the
        <code class="calibre21">
         private
        </code>
        data members are defined as follows:
       </p>
       <pre class="calibre26" id="c01-code-0317"><code class="calibre21">        private:</code>
<code class="calibre21">            std::vector&lt;Employee&gt; m_employees;</code>
<code class="calibre21">            int m_nextEmployeeNumber { FirstEmployeeNumber };</code>
<code class="calibre21">    };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c01-para-0612">
        <span aria-label="81" class="calibre20" epub:type="pagebreak" id="Page_81" role="doc-pagebreak">
        </span>
        The
        <code class="calibre21">
         m_employees
        </code>
        data member contains the
        <code class="calibre21">
         Employee
        </code>
        objects, while
        <code class="calibre21">
         m_nextEmployeeNumber
        </code>
        keeps track of what employee number is assigned to a new employee and is initialized with the
        <code class="calibre21">
         FirstEmployeeNumber
        </code>
        constant.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0146">
       </span>
       <h4 class="calibre29" id="head-4-57">
        Database.cpp
       </h4>
       <p class="calibre13">
        Here is the implementation of the
        <code class="calibre21">
         addEmployee()
        </code>
        member function:
       </p>
       <pre class="calibre26" id="c01-code-0318"><code class="calibre21">module database;</code>
<code class="calibre21">import std;</code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21">namespace Records {</code>
<code class="calibre21">    Employee&amp; Database::addEmployee(const string&amp; firstName,</code>
<code class="calibre21">                                    const string&amp; lastName)</code>
<code class="calibre21">    {</code>
<code class="calibre21">        Employee theEmployee { firstName, lastName };</code>
<code class="calibre21">        theEmployee.setEmployeeNumber(m_nextEmployeeNumber++);</code>
<code class="calibre21">        theEmployee.hire();</code>
<code class="calibre21">        m_employees.push_back(theEmployee);</code>
<code class="calibre21">        return m_employees.back();</code>
<code class="calibre21">    }</code></pre>
       <p class="calibre13" id="c01-para-0614">
        The
        <code class="calibre21">
         addEmployee()
        </code>
        member function creates a new
        <code class="calibre21">
         Employee
        </code>
        object, fills in its information, and adds it to the
        <code class="calibre21">
         vector
        </code>
        . The
        <code class="calibre21">
         m_nextEmployeeNumber
        </code>
        data member is incremented after its use so that the next employee will get a new number. The
        <code class="calibre21">
         back()
        </code>
        member function of
        <code class="calibre21">
         vector
        </code>
        returns a reference to the last element in the
        <code class="calibre21">
         vector
        </code>
        , which is the newly added employee.
       </p>
       <p class="calibre13">
        One of the
        <code class="calibre21">
         getEmployee()
        </code>
        member functions is implemented as follows. The second overload is implemented similarly, hence not shown. They both loop over all employees in
        <code class="calibre21">
         m_employees
        </code>
        using a range-based
        <code class="calibre21">
         for
        </code>
        loop and check whether an
        <code class="calibre21">
         Employee
        </code>
        is a match for the information passed to the member function. An exception is thrown if no match is found. Notice the use of auto&amp; in the range-based for loop, because the loop doesn’t want to work with copies of Employees but with references to the Employees in the m_employees vector.
       </p>
       <pre class="calibre26" id="c01-code-0319"><code class="calibre21">    Employee&amp; Database::getEmployee(int employeeNumber)</code>
<code class="calibre21">    {</code>
<code class="calibre21">        for (auto&amp; employee : m_employees) {</code>
<code class="calibre21">            if (employee.getEmployeeNumber() == employeeNumber) {</code>
<code class="calibre21">                return employee;</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21">        throw logic_error { "No employee found." };</code>
<code class="calibre21">    }</code></pre>
       <p class="calibre13">
        The following display member functions all use a similar algorithm: they loop through all employees and ask each employee to display itself to the console if the criterion for display matches.
       </p>
       <pre class="calibre26" id="c01-code-0320"><code class="calibre21">    void Database::displayAll() const</code>
<code class="calibre21">    {</code>
<code class="calibre21">        for (const auto&amp; employee : m_employees) { employee.display(); }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<span aria-label="82" class="calibre20" epub:type="pagebreak" id="Page_82" role="doc-pagebreak"></span><code class="calibre21">    void Database::displayCurrent() const</code>
<code class="calibre21">    {</code>
<code class="calibre21">        for (const auto&amp; employee : m_employees) {</code>
<code class="calibre21">            if (employee.isHired()) { employee.display(); }</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    void Database::displayFormer() const</code>
<code class="calibre21">    {</code>
<code class="calibre21">        for (const auto&amp; employee : m_employees) {</code>
<code class="calibre21">            if (!employee.isHired()) { employee.display(); }</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c01-sec-0147">
       </span>
       <h4 class="calibre29" id="head-4-58">
        DatabaseTest.cpp
       </h4>
       <p class="calibre13">
        A simple test for the basic functionality of the database is shown here:
       </p>
       <pre class="calibre26" id="c01-code-0321"><code class="calibre21">import std;</code>
<code class="calibre21">import database;</code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">using namespace Records;</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Database myDB;</code>
<code class="calibre21">    Employee&amp; emp1 { myDB.addEmployee("Greg", "Wallis") };</code>
<code class="calibre21">    emp1.fire();</code>
<code class="calibre21"> </code>
<code class="calibre21">    Employee&amp; emp2 { myDB.addEmployee("Marc", "White") };</code>
<code class="calibre21">    emp2.setSalary(100'000);</code>
<code class="calibre21"> </code>
<code class="calibre21">    Employee&amp; emp3 { myDB.addEmployee("John", "Doe") };</code>
<code class="calibre21">    emp3.setSalary(10'000);</code>
<code class="calibre21">    emp3.promote();</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("All employees:\n==============");</code>
<code class="calibre21">    myDB.displayAll();</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("\nCurrent employees:\n==================");</code>
<code class="calibre21">    myDB.displayCurrent();</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("\nFormer employees:\n=================");</code>
<code class="calibre21">    myDB.displayFormer();</code>
<code class="calibre21">}</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0148">
      </span>
      <h3 class="calibre27" id="head-3-98">
       The User Interface
      </h3>
      <p class="calibre13" id="c01-para-0618">
       The final part of the program is a menu-based user interface that makes it easy for users to work with the employee database.
      </p>
      <p class="calibre13">
       The following
       <code class="calibre21">
        main()
       </code>
       function contains a loop that displays the menu, performs the selected action, and then does it all again. For most actions, separate functions are defined. For simpler actions, such as displaying employees, the actual code is put in the appropriate case.
      </p>
      <pre class="calibre26" id="c01-code-0322"><span aria-label="83" class="calibre20" epub:type="pagebreak" id="Page_83" role="doc-pagebreak"></span><code class="calibre21">import std;</code>
<code class="calibre21">import database;</code>
<code class="calibre21">import employee;</code>
<code class="calibre21"> </code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21">using namespace Records;</code>
<code class="calibre21"> </code>
<code class="calibre21">int displayMenu();</code>
<code class="calibre21">void doHire(Database&amp; db);</code>
<code class="calibre21">void doFire(Database&amp; db);</code>
<code class="calibre21">void doPromote(Database&amp; db);</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Database employeeDB;</code>
<code class="calibre21">    bool done { false };</code>
<code class="calibre21">    while (!done) {</code>
<code class="calibre21">        int selection { displayMenu() };</code>
<code class="calibre21">        switch (selection) {</code>
<code class="calibre21">        case 0:</code>
<code class="calibre21">            done = true;</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        case 1:</code>
<code class="calibre21">            doHire(employeeDB);</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        case 2:</code>
<code class="calibre21">            doFire(employeeDB);</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        case 3:</code>
<code class="calibre21">            doPromote(employeeDB);</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        case 4:</code>
<code class="calibre21">            employeeDB.displayAll();</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        case 5:</code>
<code class="calibre21">            employeeDB.displayCurrent();</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        case 6:</code>
<code class="calibre21">            employeeDB.displayFormer();</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        default:</code>
<code class="calibre21">            println(cerr, "Unknown command.");</code>
<code class="calibre21">            break;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        displayMenu()
       </code>
       function prints the menu and gets input from the user. One important note is that this code assumes that the user will “play nice” and type a number when a number is requested. When you read about I/O in
       <a class="calibre5" href="c13.xhtml">
        Chapter 13
       </a>
       , you will learn how to protect against bad input.
      </p>
      <pre class="calibre26" id="c01-code-0323"><code class="calibre21">int displayMenu()</code>
<code class="calibre21">{</code>
<code class="calibre21">    int selection;</code>
<code class="calibre21">    println("");</code>
<span aria-label="84" class="calibre20" epub:type="pagebreak" id="Page_84" role="doc-pagebreak"></span><code class="calibre21">    println("Employee Database");</code>
<code class="calibre21">    println("-----------------");</code>
<code class="calibre21">    println("1) Hire a new employee");</code>
<code class="calibre21">    println("2) Fire an employee");</code>
<code class="calibre21">    println("3) Promote an employee");</code>
<code class="calibre21">    println("4) List all employees");</code>
<code class="calibre21">    println("5) List all current employees");</code>
<code class="calibre21">    println("6) List all former employees");</code>
<code class="calibre21">    println("0) Quit");</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">    print("---&gt; ");</code>
<code class="calibre21">    cin &gt;&gt; selection;</code>
<code class="calibre21">    return selection;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        doHire()
       </code>
       function gets the new employee's name from the user and tells the database to add the employee:
      </p>
      <pre class="calibre26" id="c01-code-0324"><code class="calibre21">void doHire(Database&amp; db)</code>
<code class="calibre21">{</code>
<code class="calibre21">    string firstName;</code>
<code class="calibre21">    string lastName;</code>
<code class="calibre21"> </code>
<code class="calibre21">    print("First name? ");</code>
<code class="calibre21">    cin &gt;&gt; firstName;</code>
<code class="calibre21"> </code>
<code class="calibre21">    print("Last name? ");</code>
<code class="calibre21">    cin &gt;&gt; lastName;</code>
<code class="calibre21"> </code>
<code class="calibre21">    auto&amp; employee { db.addEmployee(firstName, lastName) };</code>
<code class="calibre21">    println("Hired employee {} {} with employee number {}.",</code>
<code class="calibre21">        firstName, lastName, employee.getEmployeeNumber());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        doFire()
       </code>
       and
       <code class="calibre21">
        doPromote()
       </code>
       both ask the database for an employee by their employee number and then use the
       <code class="calibre21">
        public
       </code>
       member functions of the
       <code class="calibre21">
        Employee
       </code>
       object to make changes:
      </p>
      <pre class="calibre26" id="c01-code-0325"><code class="calibre21">void doFire(Database&amp; db)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int employeeNumber;</code>
<code class="calibre21">    print("Employee number? ");</code>
<code class="calibre21">    cin &gt;&gt; employeeNumber;</code>
<code class="calibre21"> </code>
<code class="calibre21">    try {</code>
<code class="calibre21">        auto&amp; emp { db.getEmployee(employeeNumber) };</code>
<code class="calibre21">        emp.fire();</code>
<code class="calibre21">        println("Employee {} terminated.", employeeNumber);</code>
<code class="calibre21">    } catch (const std::logic_error&amp; exception) {</code>
<code class="calibre21">        println(cerr, "Unable to terminate employee: {}", exception.what());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void doPromote(Database&amp; db)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int employeeNumber;</code>
<code class="calibre21">    print("Employee number? ");</code>
<code class="calibre21">    cin &gt;&gt; employeeNumber;</code>
<code class="calibre21"> </code>
<span aria-label="85" class="calibre20" epub:type="pagebreak" id="Page_85" role="doc-pagebreak"></span><code class="calibre21">    int raiseAmount;</code>
<code class="calibre21">    print("How much of a raise? ");</code>
<code class="calibre21">    cin &gt;&gt; raiseAmount;</code>
<code class="calibre21"> </code>
<code class="calibre21">    try {</code>
<code class="calibre21">        auto&amp; emp { db.getEmployee(employeeNumber) };</code>
<code class="calibre21">        emp.promote(raiseAmount);</code>
<code class="calibre21">    } catch (const std::logic_error&amp; exception) {</code>
<code class="calibre21">        println(cerr, "Unable to promote employee: {}", exception.what());</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c01-sec-0149">
      </span>
      <h3 class="calibre27" id="head-3-99">
       Evaluating the Program
      </h3>
      <p class="calibre13" id="c01-para-0623">
       The preceding program covers a number of topics from the simple to the more complex. There are a number of ways that you could extend this program. For example, the user interface does not expose all the functionality of the
       <code class="calibre21">
        Database
       </code>
       and
       <code class="calibre21">
        Employee
       </code>
       classes. You could modify the UI to include those features. You could also try to implement additional functionality that you can think of for both classes, which would be a great exercise to practice the material you learned in this chapter.
      </p>
      <p class="calibre13" id="c01-para-0624">
       If there are parts of this program that don't make sense, consult the relevant sections in this chapter to review those topics. If something is still unclear, the best way to learn is to play with the code and try things. For example, if you're not sure how to use the conditional operator, write a short
       <code class="calibre21">
        main()
       </code>
       function that uses it.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-55" class="calibre2">
     <span class="calibre" id="c01-sec-0150">
     </span>
     <h2 class="calibre6" id="head-2-55">
      SUMMARY
     </h2>
     <p class="calibre13" id="c01-para-0625">
      After this crash course in C++ and the Standard Library, you are ready to become a professional C++ programmer. When you start getting deeper into the C++ language later in this book, you can refer to this chapter to brush up on parts of the language you may need to review. Going back to some of the sample code in this chapter may be all you need to bring a forgotten concept back to the forefront of your mind.
     </p>
     <p class="calibre13" id="c01-para-0626">
      The next chapter goes deeper in on how strings are handled in C++, because almost every program you'll write will have to work with strings one way or another.
     </p>
    </section>
    <section aria-labelledby="head-2-56" class="calibre2">
     <span class="calibre" id="c01-sec-0151">
     </span>
     <h2 class="calibre6" id="head-2-56">
      EXERCISES
     </h2>
     <p class="calibre13" id="c01-para-0627">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c01-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c01-ex-0001">
        <b class="calibre14">
         Exercise 1-1:
        </b>
        Modify the
        <code class="calibre21">
         Employee
        </code>
        structure from the beginning of this chapter by putting it in a namespace called
        <code class="calibre21">
         HR
        </code>
        . What modifications do you have to make to the code in
        <code class="calibre21">
         main()
        </code>
        to work with this new implementation? Additionally, modify the code to use designated initializers.
       </li>
       <li class="calibre9" id="c01-ex-0002">
        <span aria-label="86" class="calibre20" epub:type="pagebreak" id="Page_86" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Exercise 1-2:
        </b>
        Build further on the result of Exercise 1-1 and add an enumeration data member
        <code class="calibre21">
         title
        </code>
        to
        <code class="calibre21">
         Employee
        </code>
        to specify whether a certain employee is a Manager, Senior Engineer, or Engineer. Which kind of enumeration will you use and why? Whatever you need to add, add it to the
        <code class="calibre21">
         HR
        </code>
        namespace. Test your new
        <code class="calibre21">
         Employee
        </code>
        data member in the
        <code class="calibre21">
         main()
        </code>
        function. Use a
        <code class="calibre21">
         switch
        </code>
        statement to print out a human-readable string for the title.
       </li>
       <li class="calibre9" id="c01-ex-0003">
        <b class="calibre14">
         Exercise 1-3:
        </b>
        Use an
        <code class="calibre21">
         std::array
        </code>
        to store three
        <code class="calibre21">
         Employee
        </code>
        instances from Exercise 1-2 with different data. Subsequently, use a range-based
        <code class="calibre21">
         for
        </code>
        loop to print out the employees in the
        <code class="calibre21">
         array
        </code>
        .
       </li>
       <li class="calibre9" id="c01-ex-0004">
        <b class="calibre14">
         Exercise 1-4:
        </b>
        Do the same as Exercise 1-3, but use an
        <code class="calibre21">
         std::vector
        </code>
        instead of an
        <code class="calibre21">
         array
        </code>
        , and use
        <code class="calibre21">
         push_back()
        </code>
        to insert elements into the
        <code class="calibre21">
         vector
        </code>
        .
       </li>
       <li class="calibre9" id="c01-ex-0005">
        <b class="calibre14">
         Exercise 1-5:
        </b>
        Take your solution for Exercise 1-4 and replace the data members for the first and last initials with strings to represent the full first and last name.
       </li>
       <li class="calibre9" id="c01-ex-0006">
        <b class="calibre14">
         Exercise 1-6:
        </b>
        Now that you know about
        <code class="calibre21">
         const
        </code>
        and references, and what they are used for, modify the
        <code class="calibre21">
         AirlineTicket
        </code>
        class from earlier in this chapter to use references wherever possible and to be
        <code class="calibre21">
         const
        </code>
        correct.
       </li>
       <li class="calibre9" id="c01-ex-0007">
        <b class="calibre14">
         Exercise 1-7:
        </b>
        Modify the
        <code class="calibre21">
         AirlineTicket
        </code>
        class from Exercise 1-6 to include an optional frequent-flyer number. What is the best way to represent this optional data member? Add a setter and a getter to set and retrieve the frequent-flyer number. Modify the
        <code class="calibre21">
         main()
        </code>
        function to test your implementation.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c01_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c01_2">
     NOTE
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="c01_split_000.xhtml#R_c01-note-0001" id="c01-note-0001" role="doc-backlink">
       1
      </a>
      Developed by Google Brain, an artificial intelligence group at Google. It is used in AI processors and supported in hardware on the latest NVIDIA GPUs.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
