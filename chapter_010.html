<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   2
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_009.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_011.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div class="calibre2" id="_idContainer048">
    <h1 class="chapter-number" id="_idParaDest-40">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor040">
     </a>
     2
    </h1>
    <h1 class="calibre5" id="_idParaDest-41">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor041">
     </a>
     Event Handling – Signals and Slots
    </h1>
    <p class="calibre3">
     The signals and slots mechanism in Qt 6 is one of its most important features. It’s a method that allows communication between objects, which is a crucial part of a program’s graphical user interface. A signal can be emitted from any
     <strong class="source-inline">
      QObject
     </strong>
     object or its subclasses, which will then trigger any slot functions of any objects that are connected to
     <span>
      the signal.
     </span>
    </p>
    <p class="calibre3">
     In this chapter, we’re going to cover the following
     <span>
      main topics:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Signals and slots in
      <span>
       a nutshell
      </span>
     </li>
     <li class="calibre14">
      UI events with signals
      <span>
       and slots
      </span>
     </li>
     <li class="calibre14">
      Asynchronous programming
      <span>
       made easier
      </span>
     </li>
     <li class="calibre14">
      <span>
       Function callbacks
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-42">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor042">
     </a>
     Technical requirements
    </h1>
    <p class="calibre3">
     The technical requirements for this chapter include
     <strong class="bold">
      Qt 6.6.1 MinGW 64-bit
     </strong>
     and
     <strong class="bold">
      Qt Creator 12.0.2
     </strong>
     . All the code used in this chapter can be downloaded from the following GitHub
     <span>
      repository:
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02">
      <span>
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter02
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-43">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor043">
     </a>
     Signals and slots in a nutshell
    </h1>
    <p class="calibre3">
     Compared to
     <strong class="bold">
      callbacks
     </strong>
     (which Qt 6 also supports), the
     <strong class="bold">
      signals and slots
     </strong>
     mechanism is comparably more fluid and flexible for the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker118">
     </a>
     programmer to use. It is both type-safe and not strongly coupled to the processing function, which makes it better than
     <span>
      callback implementation.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-44">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor044">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s create a
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and open
      <span>
       up
      </span>
      <span>
       <strong class="source-inline1">
        mainwindow.ui
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      Drag and drop a
      <strong class="bold">
       PushButton
      </strong>
      widget from the
      <strong class="bold">
       Widget Box
      </strong>
      to the
      <span>
       UI canvas:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer037">
      <img alt="Figure 2.1 – Dragging and dropping a push button to the UI canvas" class="calibre4" src="image/B20976_02_001.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.1 – Dragging and dropping a push button to the UI canvas
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Right-click on the
      <strong class="bold">
       PushButton
      </strong>
      widget
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker119">
      </a>
      and select
      <strong class="bold">
       Go to slot
      </strong>
      . A window
      <span>
       will appear:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer038">
      <img alt="Figure 2.2 – Selecting the clicked() signal and pressing OK" class="calibre4" src="image/B20976_02_002.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.2 – Selecting the clicked() signal and pressing OK
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="4">
      You will see a list of built-in slot functions available for the push button. Let’s select the
      <strong class="bold">
       clicked()
      </strong>
      option and press
      <strong class="bold">
       OK
      </strong>
      . A slot function called
      <strong class="source-inline1">
       on_pushButton_clicked()
      </strong>
      will now appear in both
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      . Qt Creator
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker120">
      </a>
      automatically added the slot function to your source code after you pressed the
      <strong class="bold">
       OK
      </strong>
      button in the
      <strong class="bold">
       Go to slot
      </strong>
      window. If you check out
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      now, you should be able to see an extra function under the
      <strong class="source-inline1">
       private
      </strong>
      <span>
       <strong class="source-inline1">
        slots
       </strong>
      </span>
      <span>
       keyword:
      </span>
      <pre class="source-code">
class MainWindow : public QMainWindow {
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
private slots:
    <strong class="bold1">void on_pushButton_clicked();</strong>
private:
    Ui::MainWindow *ui;
};</pre>
     </li>
     <li class="calibre14">
      The same goes for
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      , where the
      <strong class="source-inline1">
       on_pushButton_clicked()
      </strong>
      function has been added
      <span>
       for you:
      </span>
      <pre class="source-code">
void MainWindow::on_pushButton_clicked()
{
}</pre>
     </li>
     <li class="calibre14">
      Now, let’s add a
      <strong class="source-inline1">
       QMessageBox
      </strong>
      header to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker121">
      </a>
      the top of your
      <span>
       source file:
      </span>
      <pre class="source-code">
#include &lt;QMessageBox&gt;</pre>
     </li>
     <li class="calibre14">
      Then, add the following code within the
      <span>
       <strong class="source-inline1">
        on_pushButton_clicked()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void MainWindow::on_pushButton_clicked() {
    <strong class="bold1">QMessageBox::information(this, «Hello», «Button has been clicked!»);</strong>
}</pre>
     </li>
     <li class="calibre14">
      Now, build and run the project. Then, click on the
      <strong class="bold">
       Push
      </strong>
      button; you should see that a message box
      <span>
       pops out:
      </span>
     </li>
    </ol>
    <p class="calibre3">
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer039">
      <img alt="Figure 2.3 – A message box pops out after pressing the push button" class="calibre4" src="image/B20976_02_003.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.3 – A message box pops out after pressing the push button
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="9">
      Next, we want to create our own
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker122">
      </a>
      signals and slot functions. Go to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      , then create a new C++ class under the
      <strong class="bold">
       Files and
      </strong>
      <span>
       <strong class="bold">
        Classes
       </strong>
      </span>
      <span>
       category:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer040">
      <img alt="Figure 2.4 – Creating a new C++ class" class="calibre4" src="image/B20976_02_004.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.4 – Creating a new C++ class
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="10">
      Then, we need to name our class
      <strong class="source-inline1">
       MyClass
      </strong>
      and make sure that the base class
      <span>
       is
      </span>
      <span>
       <strong class="bold">
        QObject
       </strong>
      </span>
      <span>
       :
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer041">
      <img alt="Figure 2.5 – Defining your custom class, which inherits the QObject class" class="calibre4" src="image/B20976_02_005.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.5 – Defining your custom class, which inherits the QObject class
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="11">
      Once you have created the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker123">
      </a>
      class, open up
      <strong class="source-inline1">
       myclass.h
      </strong>
      and add the following code, which is highlighted here
      <span>
       for clarity:
      </span>
      <pre class="source-code">
#include &lt;QObject&gt;
<strong class="bold1">#include &lt;QMainWindow&gt;</strong>
<strong class="bold1">#include &lt;QMessageBox&gt;</strong>
class MyClass : public QObject {
    Q_OBJECT
public:
    explicit MyClass(QObject *parent = nullptr);
public slots:
    <strong class="bold1">void doSomething();</strong>
};</pre>
     </li>
     <li class="calibre14">
      Then, open up
      <strong class="source-inline1">
       myclass.cpp
      </strong>
      and implement the
      <strong class="source-inline1">
       doSomething()
      </strong>
      slot function. We’ll copy the message box
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker124">
      </a>
      function from the
      <span>
       previous example:
      </span>
      <pre class="source-code">
#include "myclass.h"
MyClass::MyClass(QObject *parent) : QObject(parent) {}
void MyClass::doSomething() {
    <strong class="bold1">QMessageBox::information(this, «Hello», «Button has been clicked!»);</strong>
}</pre>
     </li>
     <li class="calibre14">
      Now, open up
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and include the
      <strong class="source-inline1">
       myclass.h
      </strong>
      header at
      <span>
       the top:
      </span>
      <pre class="source-code">
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
<strong class="bold1">#include "myclass.h"</strong>
namespace Ui {
class MainWindow;
}</pre>
     </li>
     <li class="calibre14">
      Also, declare a
      <strong class="source-inline1">
       doNow()
      </strong>
      signal
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        myclass.h
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
signals:
    <strong class="bold1">void doNow();</strong>
private slots:
    void on_pushButton_clicked();</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and define a
      <strong class="source-inline1">
       MyClass
      </strong>
      object. Then, we’ll connect the
      <strong class="source-inline1">
       doNow()
      </strong>
      signal that we created in the previous step with our
      <strong class="source-inline1">
       doSomething()
      </strong>
      <span>
       slot function:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow){
    ui-&gt;setupUi(this);
    <strong class="bold1">MyClass* myclass = new MyClass;</strong>
<strong class="bold1">    connect(this, &amp;MainWindow::doNow, myclass, &amp;MyClass::doSomething);</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, we have to change
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker125">
      </a>
      the code of the
      <strong class="source-inline1">
       on_pushButton_clicked()
      </strong>
      function to something
      <span>
       like this:
      </span>
      <pre class="source-code">
void MainWindow::on_pushButton_clicked() {
    <strong class="bold1">emit doNow();</strong>
}</pre>
     </li>
     <li class="calibre14">
      If you build and run the program now, you will get a result that is similar to what’s shown in the previous example. However, we have placed the message box code in the
      <strong class="source-inline1">
       MyClass
      </strong>
      object instead of
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        MainWindow
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
    </ol>
    <p class="calibre3">
     The preceding steps demonstrated how we can utilize the slot-and-signal feature in Qt 6 to easily link a widget action to an event function. It really is
     <span>
      that simple.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-45">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor045">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The signals and slots mechanism has
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker126">
     </a>
     gone through some changes in the recent version of Qt, most notably its coding syntax. Qt 6 no longer supports the older syntax; therefore, if you are trying to port your older Qt 5 project to Qt 6, you must change your code to comply with the
     <span>
      newer syntax.
     </span>
    </p>
    <p class="calibre3">
     In the good old days, we would typically connect a signal to a slot
     <span>
      like this:
     </span>
    </p>
    <pre class="source-code">
connect(
    sender, SIGNAL(valueChanged(QString)),
    receiver, SLOT(updateValue(QString))
);</pre>
    <p class="calibre3">
     However, things have changed slightly since then. In the new syntax, the
     <strong class="source-inline">
      SIGNAL
     </strong>
     and
     <strong class="source-inline">
      SLOT
     </strong>
     macros are now gone, and you
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker127">
     </a>
     must specify the type of your object, as shown in the
     <span>
      following code:
     </span>
    </p>
    <pre class="source-code">
connect(
    sender, &amp;Sender::valueChanged,
    receiver, &amp;Receiver::updateValue
);</pre>
    <p class="calibre3">
     The new syntax also allows you to connect a signal directly to a function instead
     <span>
      of
     </span>
     <span>
      <strong class="source-inline">
       QObject
      </strong>
     </span>
     <span>
      :
     </span>
    </p>
    <pre class="source-code">
connect(
    sender, &amp;Sender::valueChanged, myFunction
);</pre>
    <p class="calibre3">
     Additionally, you can also connect
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker128">
     </a>
     your signal to a
     <strong class="bold">
      lambda expression
     </strong>
     . We will talk more about this in the
     <em class="italic">
      Asynchronous programming made
     </em>
     <span>
      <em class="italic">
       easier
      </em>
     </span>
     <span>
      recipe.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     A signal of an
     <strong class="source-inline1">
      arbitrary
     </strong>
     class can trigger any private slots of an unrelated class that is going to be invoked, which is not possible
     <span>
      with callbacks.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-46">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor046">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     All Qt projects come with a project file with the
     <strong class="source-inline">
      .pro
     </strong>
     extension. This project file is used specifically by Qt’s own
     <strong class="bold">
      qmake
     </strong>
     build system, which
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker129">
     </a>
     helps simplify most of the complex build process by using a straightforward declarative style, defining standard variables to indicate the source and header files that are used in
     <span>
      the project.
     </span>
    </p>
    <p class="calibre3">
     There’s an alternative
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker130">
     </a>
     build system called
     <strong class="bold">
      CMake
     </strong>
     , which is also compatible with Qt. The Qt project file is not needed if you are using CMake. Instead, you can directly open
     <strong class="source-inline">
      CMakeLists.txt
     </strong>
     with Qt Creator and it will open the project just like using Qt’s project file. However, it’s not recommended
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker131">
     </a>
     for beginners to use CMake when developing their first application with Qt, as CMake is much more manual and it takes longer time to grasp
     <span>
      its functionality.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     To learn more about CMake, please
     <span>
      visit
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://doc.qt.io/qt-6/cmake-get-started.html">
      <span>
       https://doc.qt.io/qt-6/cmake-get-started.html
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     Qt categorizes its features and functionality in the form of modules and classes. Each module contains a set of related functionalities that can be added to your project separately when needed. This allows the programmer to keep their program in optimum size and performance. The Qt Core and Qt GUI modules are included in every Qt project by default. To add additional modules, you simply need to add the module keyword to your Qt project file or add the package and link its libraries in
     <strong class="source-inline">
      CMakeLists.txt
     </strong>
     if you are using CMake for
     <span>
      your project.
     </span>
    </p>
    <p class="calibre3">
     For example, if I want to add the Qt
     <strong class="source-inline">
      Network
     </strong>
     module to my project, I will add the following keyword to my Qt
     <span>
      project file:
     </span>
    </p>
    <pre class="console">
QT += network</pre>
    <p class="calibre3">
     In CMake, however, it gets
     <span>
      slightly longer:
     </span>
    </p>
    <pre class="console">
find_package(Qt6 REQUIRED COMPONENTS Network)
target_link_libraries(mytarget PRIVATE Qt6::Network)</pre>
    <p class="calibre3">
     After you have added the Qt
     <strong class="source-inline">
      Network
     </strong>
     module, you can now access its C++ classes such as
     <strong class="source-inline">
      QNetworkAccessManager
     </strong>
     ,
     <strong class="source-inline">
      QNetworkInterface
     </strong>
     ,
     <strong class="source-inline">
      QNetworkRequest
     </strong>
     , and so on. This modular approach creates an expandable ecosystem for Qt while allowing the developers to maintain this complex and powerful framework
     <span>
      with ease.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     To learn more about all the different Qt modules, please
     <span>
      visit
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://doc.qt.io/qt.html">
      <span>
       https://doc.qt.io/qt.html
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-47">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor047">
     </a>
     UI events with signals and slots
    </h1>
    <p class="calibre3">
     In the previous recipe, we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker132">
     </a>
     demonstrated the use of signals and slots on a
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker133">
     </a>
     push button. Now, let’s explore the signals and slots that are available in other common
     <span>
      widget types.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-48">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor048">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     To learn how to use signals and slots with UI events, follow
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s create a new
      <strong class="bold">
       Qt Widgets
      </strong>
      <span>
       <strong class="bold">
        Application
       </strong>
      </span>
      <span>
       project.
      </span>
     </li>
     <li class="calibre14">
      Drag and drop a
      <strong class="bold">
       PushButton
      </strong>
      ,
      <strong class="bold">
       Combo Box
      </strong>
      ,
      <strong class="bold">
       Line Edit
      </strong>
      ,
      <strong class="bold">
       Spin Box
      </strong>
      , and
      <strong class="bold">
       Slider
      </strong>
      widget from the
      <strong class="bold">
       Widget Box
      </strong>
      into your
      <span>
       UI canvas:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer042">
      <img alt="Figure 2.6 – Placing several widgets on the UI canvas" class="calibre4" src="image/B20976_02_006.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.6 – Placing several widgets on the UI canvas
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Then, right-click on the push button, select
      <strong class="bold">
       clicked()
      </strong>
      , and press the
      <strong class="bold">
       OK
      </strong>
      button to proceed. A slot function will be created for you by
      <span>
       Qt Creator:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer043">
      <img alt="Figure 2.7 – Selecting the clicked() signal and pressing OK" class="calibre4" src="image/B20976_02_007.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.7 – Selecting the clicked() signal and pressing OK
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="4">
      Repeat the previous step, but
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker134">
      </a>
      this time, select the next selection until every
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker135">
      </a>
      function in
      <strong class="source-inline1">
       QAbstractButton
      </strong>
      has been added to the
      <span>
       source code:
      </span>
      <pre class="source-code">
void on_pushButton_clicked();
void on_pushButton_clicked(bool checked);
void on_pushButton_pressed();
void on_pushButton_released();
void on_pushButton_toggled(bool checked);</pre>
     </li>
     <li class="calibre14">
      Next, repeat the same steps on the combo box until all the slot functions available under the
      <strong class="source-inline1">
       QComboBox
      </strong>
      class have been added to the
      <span>
       source code:
      </span>
      <pre class="source-code">
void on_comboBox_activated(const QString &amp;arg1);
void on_comboBox_activated(int index);
void on_comboBox_currentIndexChanged(const QString &amp;arg1);
void on_comboBox_currentIndexChanged(int index);
void on_comboBox_currentTextChanged(const QString &amp;arg1);
void on_comboBox_editTextChanged(const QString &amp;arg1);
void on_comboBox_highlighted(const QString &amp;arg1);
void on_comboBox_highlighted(int index);</pre>
     </li>
     <li class="calibre14">
      The same goes for
      <strong class="source-inline1">
       lineEdit
      </strong>
      , all
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker136">
      </a>
      of which are
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker137">
      </a>
      under the
      <span>
       <strong class="source-inline1">
        QLineEdit
       </strong>
      </span>
      <span>
       class:
      </span>
      <pre class="source-code">
void on_lineEdit_cursorPositionChanged(int arg1, int arg2);
void on_lineEdit_editingFinished();
void on_lineEdit_returnPressed();
void on_lineEdit_selectionChanged();
void on_lineEdit_textChanged(const QString &amp;arg1);
void on_lineEdit_textEdited(const QString &amp;arg1);</pre>
     </li>
     <li class="calibre14">
      After that, add the slot functions
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker138">
      </a>
      from the
      <strong class="source-inline1">
       QSpinBox
      </strong>
      class for our
      <strong class="source-inline1">
       spin box
      </strong>
      widget as well, which is
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker139">
      </a>
      <span>
       relatively short:
      </span>
      <pre class="source-code">
void on_spinBox_valueChanged(const QString &amp;arg1);
void on_spinBox_valueChanged(int arg1);</pre>
     </li>
     <li class="calibre14">
      Lastly, repeat the same step for our
      <strong class="source-inline1">
       slider
      </strong>
      widget, which yields
      <span>
       similar results:
      </span>
      <pre class="source-code">
void on_horizontalSlider_actionTriggered(int action);
void on_horizontalSlider_rangeChanged(int min, int max);
void on_horizontalSlider_sliderMoved(int position);
void on_horizontalSlider_sliderPressed();
void on_horizontalSlider_sliderReleased();
void on_horizontalSlider_valueChanged(int value);</pre>
     </li>
     <li class="calibre14">
      Once you’re done with
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker140">
      </a>
      that, open up
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker141">
      </a>
      add the
      <strong class="source-inline1">
       QDebug
      </strong>
      header, as highlighted in the
      <span>
       following code:
      </span>
      <pre class="source-code">
#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include &lt;QMainWindow&gt;
<strong class="bold1">#include &lt;QDebug&gt;</strong>
namespace Ui {
class MainWindow;
}</pre>
     </li>
     <li class="calibre14">
      Let’s implement the slot functions for our
      <span>
       push button:
      </span>
      <pre class="source-code">
void MainWindow::on_pushButton_clicked() {
    <strong class="bold1">qDebug() &lt;&lt; «Push button clicked»;</strong>
}
void MainWindow::on_pushButton_clicked(bool checked) {
    <strong class="bold1">qDebug() &lt;&lt; «Push button clicked: « &lt;&lt; checked;</strong>
}
void MainWindow::on_pushButton_pressed() {
    <strong class="bold1">qDebug() &lt;&lt; «Push button pressed»;</strong>
}
void MainWindow::on_pushButton_released() {
    <strong class="bold1">qDebug() &lt;&lt; «Push button released»;</strong>
}
void MainWindow::on_pushButton_toggled(bool checked) {
    <strong class="bold1">qDebug() &lt;&lt; «Push button toggled: « &lt;&lt; checked;</strong>
}</pre>
     </li>
     <li class="calibre14">
      If you build and run the project
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker142">
      </a>
      now, and then click on the push button, you will see that a different status gets
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker143">
      </a>
      printed out but at a slightly different time. This is due to different signals being emitted at different actions during the whole
      <span>
       clicking process:
      </span>
     </li>
    </ol>
    <pre class="console">
Push button pressed
Push button released
Push button clicked
Push button clicked: false</pre>
    <ol class="calibre13">
     <li class="calibre14" value="12">
      Next, we will move on to the combo box. Since the default combo box is empty, let’s add some options to it by double-clicking on it from
      <strong class="source-inline1">
       mainwindow.ui
      </strong>
      and adding the options that are shown in the
      <span>
       pop-up window:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer044">
      <img alt="Figure 2.8 – Adding more options to the combo box" class="calibre4" src="image/B20976_02_008.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.8 – Adding more options to the combo box
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="13">
      Then, let’s implement the slot
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker144">
      </a>
      functions for the combo box
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        mainwindow.cpp
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
void MainWindow::on_comboBox_activated(const QString &amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box activated: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_activated(int index) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box activated: « &lt;&lt; index;</strong>
}
void MainWindow::on_comboBox_currentIndexChanged(const QString &amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box current index changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_currentIndexChanged(int index) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box current index changed: « &lt;&lt; index;</strong>
}</pre>
     </li>
     <li class="calibre14">
      We will continue to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker145">
      </a>
      implement the rest of the slot functions for the
      <span>
       combo box:
      </span>
      <pre class="source-code">
void MainWindow::on_comboBox_currentTextChanged(const QString &amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box current text changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_editTextChanged(const QString
&amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box edit text changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_highlighted(const QString &amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box highlighted: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_comboBox_highlighted(int index) {
    <strong class="bold1">qDebug() &lt;&lt; «Combo box highlighted: « &lt;&lt; index;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Build and run the project. Then, try
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker146">
      </a>
      to click on the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker147">
      </a>
      combo box, hover over the other options, and select an option by clicking on it. You should see similar results to the following in your
      <span>
       debug output:
      </span>
      <pre class="source-code">
Combo box highlighted: 0
Combo box highlighted: "Option One"
Combo box highlighted: 1
Combo box highlighted: "Option Two"
Combo box highlighted: 2
Combo box highlighted: "Option Three"
Combo box current index changed: 2
Combo box current index changed: "Option Three"
Combo box current text changed: "Option Three"
Combo box activated: 2
Combo box activated: "Option Three"</pre>
     </li>
     <li class="calibre14">
      Next, we will move on to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker148">
      </a>
      line edit and implement its slot functions, as shown in the
      <span>
       following code:
      </span>
      <pre class="source-code">
void MainWindow::on_lineEdit_cursorPositionChanged(int arg1, int arg2) {
    <strong class="bold1">qDebug() &lt;&lt; «Line edit cursor position changed: « &lt;&lt; arg1 &lt;&lt; arg2;</strong>
}
void MainWindow::on_lineEdit_editingFinished() {
    <strong class="bold1">qDebug() &lt;&lt; «Line edit editing finished»;</strong>
}
void MainWindow::on_lineEdit_returnPressed() {
    <strong class="bold1">qDebug() &lt;&lt; «Line edit return pressed»;</strong>
}</pre>
     </li>
     <li class="calibre14">
      We will continue to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker149">
      </a>
      implement the rest of the slot functions of
      <span>
       line edit:
      </span>
      <pre class="source-code">
void MainWindow::on_lineEdit_selectionChanged() {
    <strong class="bold1">qDebug() &lt;&lt; «Line edit selection changed»;</strong>
}
void MainWindow::on_lineEdit_textChanged(const QString &amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Line edit text changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_lineEdit_textEdited(const QString &amp;arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Line edit text edited: « &lt;&lt; arg1;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Build and run the project. Then, click on the line edit and type
      <strong class="source-inline1">
       Hey
      </strong>
      . You should see results similar to the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker150">
      </a>
      following appearing in the debug
      <span>
       output panel:
      </span>
      <pre class="source-code">
Line edit cursor position changed: -1 0
Line edit text edited: "H"
Line edit text changed: "H"
Line edit cursor position changed: 0 1
Line edit text edited: "He"
Line edit text changed: "He"
Line edit cursor position changed: 1 2
Line edit text edited: "Hey"
Line edit text changed: "Hey"
Line edit cursor position changed: 2 3
Line edit editing finished</pre>
     </li>
     <li class="calibre14">
      After that, we need to implement the slot functions for the spin box widget, as shown in the
      <span>
       following
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker151">
       </a>
      </span>
      <span>
       code:
      </span>
      <pre class="source-code">
void MainWindow::on_spinBox_valueChanged(const QString &amp;arg1){
    <strong class="bold1">qDebug() &lt;&lt; «Spin box value changed: « &lt;&lt; arg1;</strong>
}
void MainWindow::on_spinBox_valueChanged(int arg1) {
    <strong class="bold1">qDebug() &lt;&lt; «Spin box value changed: « &lt;&lt; arg1;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Try to build and run the program. Then, click the arrow buttons on the spin box, or directly edit the value in the box – you should get something similar
      <span>
       to this:
      </span>
      <pre class="source-code">
Spin box value changed: "1"
Spin box value changed: 1
Spin box value changed: "2"
Spin box value changed: 2
Spin box value changed: "3"
Spin box value changed: 3
Spin box value changed: "2"
Spin box value changed: 2
Spin box value changed: "20"
Spin box value changed: 20</pre>
     </li>
     <li class="calibre14">
      Lastly, we’ll implement the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker152">
      </a>
      slot functions for the horizontal
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker153">
      </a>
      <span>
       slider widget:
      </span>
      <pre class="source-code">
void MainWindow::on_horizontalSlider_actionTriggered(int
action) {
    <strong class="bold1">qDebug() &lt;&lt; «Slider action triggered» &lt;&lt; action;</strong>
}
void MainWindow::on_horizontalSlider_rangeChanged(int min, int max) {
    <strong class="bold1">qDebug() &lt;&lt; «Slider range changed: « &lt;&lt; min &lt;&lt; max;</strong>
}
void MainWindow::on_horizontalSlider_sliderMoved(int position)
{
    <strong class="bold1">qDebug() &lt;&lt; «Slider moved: « &lt;&lt; position;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Continue to implement the slot function for the slider, as shown in the
      <span>
       following code:
      </span>
      <pre class="source-code">
void MainWindow::on_horizontalSlider_sliderPressed() {
    <strong class="bold1">qDebug() &lt;&lt; «Slider pressed»;</strong>
}
void MainWindow::on_horizontalSlider_sliderReleased() {
    <strong class="bold1">qDebug() &lt;&lt; «Slider released»;</strong>
}
void MainWindow::on_horizontalSlider_valueChanged(int value) {
    <strong class="bold1">qDebug() &lt;&lt; «Slider value changed: « &lt;&lt; value;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Build and run the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker154">
      </a>
      program. Then, click and drag the slider
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker155">
      </a>
      to the left and right – you should see results that are similar to
      <span>
       the following:
      </span>
      <pre class="source-code">
Slider pressed
Slider moved: 1
Slider action triggered 7
Slider value changed: 1
Slider moved: 2
Slider action triggered 7
Slider value changed: 2
Slider moved: 3
Slider action triggered 7
Slider value changed: 3
Slider moved: 4
Slider action triggered 7
Slider value changed: 4
Slider released</pre>
     </li>
    </ol>
    <p class="calibre3">
     Almost every widget has a set of slot functions associated with its usage or purpose. For example, a push button will start
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker156">
     </a>
     emitting signals that trigger the slot functions associated with it when it’s
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker157">
     </a>
     pressed or released. These expected behaviors that define the widget have slot functions that get called when the user triggers an action. As programmers, all we need to do is implement the slot functions and tell Qt what to do when these slot functions are
     <span>
      being triggered.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-49">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor049">
     </a>
     Asynchronous programming made easier
    </h1>
    <p class="calibre3">
     Since the signals and slots mechanism is
     <em class="italic">
      asynchronous
     </em>
     in nature, we can make use of it for things other than user interfaces. In programming terms, an
     <em class="italic">
      asynchronous operation
     </em>
     is a process that works independently, allowing the program to continue its operation without waiting for the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker158">
     </a>
     process to complete, which may stall the whole program. Qt 6 allows you to make use of its signals and slots mechanism to easily achieve asynchronous processes without much effort. This is even more true after Qt 6 enforced the new syntax for signals and slots, which allows a signal to trigger a normal function instead of a slot function from a
     <span>
      <strong class="source-inline">
       Qobject
      </strong>
     </span>
     <span>
      object.
     </span>
    </p>
    <p class="calibre3">
     In the following example, we will further explore this opportunity and learn how we can improve our program’s efficiency by using asynchronous operations through the signals and slots mechanism that’s provided by
     <span>
      Qt 6.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-50">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor050">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     To learn how to achieve asynchronous operations using the signals and slots mechanism, let’s follow
     <span>
      this example:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a
      <strong class="bold">
       Qt Console
      </strong>
      <span>
       <strong class="bold">
        Application
       </strong>
      </span>
      <span>
       project:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer045">
      <img alt="Figure 2.9 – Creating a new Qt Console Application project" class="calibre4" src="image/B20976_02_009.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.9 – Creating a new Qt Console Application project
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      This type of project will only
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker159">
      </a>
      provide a
      <strong class="source-inline1">
       main.cpp
      </strong>
      file for you, instead of
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      , like our previous example projects. Let’s open up
      <strong class="source-inline1">
       main.cpp
      </strong>
      and add the following headers
      <span>
       to it:
      </span>
      <pre class="source-code">
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li class="calibre14">
      Then, add the following code to our
      <strong class="source-inline1">
       main()
      </strong>
      function. We will be using the
      <strong class="source-inline1">
       QNetworkAccessManager
      </strong>
      class to initiate a
      <strong class="source-inline1">
       GET
      </strong>
      request to the following
      <span>
       web URL:
      </span>
      <pre class="source-code">
int main(int argc, char *argv[]) {
    QCoreApplication a(argc, argv);
    QString *html = new QString;
    qDebug() &lt;&lt; "Start";
    QNetworkAccessManager manager;
    QNetworkRequest req(QUrl("http://www.dustyfeet.com"));
    QNetworkReply* reply = manager.get(req);</pre>
     </li>
     <li class="calibre14">
      Then, we use C++11’s
      <strong class="bold">
       lambda expression
      </strong>
      to connect
      <strong class="source-inline1">
       QNetworkReply
      </strong>
      signals
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker160">
      </a>
      to
      <span>
       inline
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker161">
       </a>
      </span>
      <span>
       functions:
      </span>
      <pre class="source-code">
QObject::connect(reply, &amp;QNetworkReply::readyRead,
 [reply, html]() {
         html-&gt;append(QString(reply-&gt;readAll()));
     });
     QObject::connect(reply, &amp;QNetworkReply::downloadProgress, [reply](qint64 bytesReceived, qint64 bytesTotal) {
         qDebug() &lt;&lt; "Progress: " &lt;&lt; bytesReceived &lt;&lt; "bytes /" &lt;&lt; bytesTotal &lt;&lt; "bytes";
     });</pre>
     </li>
     <li class="calibre14">
      We can also use a lambda expression with
      <strong class="source-inline1">
       connect()
      </strong>
      to call a function that is not under a
      <span>
       <strong class="source-inline1">
        QObject
       </strong>
      </span>
      <span>
       class:
      </span>
      <pre class="source-code">
QObject::connect(reply, &amp;QNetworkReply::finished, [=]() {
        printHTML(*html);
    });
    return a.exec();
}</pre>
     </li>
     <li class="calibre14">
      Lastly, we define the
      <strong class="source-inline1">
       printHTML()
      </strong>
      function, as shown in the
      <span>
       following code:
      </span>
      <pre class="source-code">
void printHTML(QString html) {
    qDebug() &lt;&lt; "Done";
    qDebug() &lt;&lt; html;
}</pre>
     </li>
     <li class="calibre14">
      If you build and run the program now, you will see that it’s functional even without declaring any
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker162">
      </a>
      slot function.
      <strong class="bold">
       Lambda expressions
      </strong>
      make declaring a slot function optional, but
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker163">
      </a>
      this is only recommended if your code is
      <span>
       really short:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer046">
      <img alt="Figure 2.10 – Printing HTML source code on the terminal window" class="calibre4" src="image/B20976_02_010.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.10 – Printing HTML source code on the terminal window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="8">
      If the terminal window does not appear after you build and run your Qt console application project, go to
      <strong class="bold">
       Edit
      </strong>
      |
      <strong class="bold">
       Preferences
      </strong>
      |
      <strong class="bold">
       Build &amp; Run
      </strong>
      and select
      <strong class="bold">
       Enabled
      </strong>
      for the
      <strong class="bold">
       Default for “Run in
      </strong>
      <span>
       <strong class="bold">
        terminal”
       </strong>
      </span>
      <span>
       option.
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer047">
      <img alt="Figure 2.11 – Enabling the terminal window from the Preferences settings" class="calibre4" src="image/B20976_02_011.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 2.11 – Enabling the terminal window from the Preferences settings
    </p>
    <p class="calibre3">
     The preceding example demonstrated
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker164">
     </a>
     how we can run a lambda function within the network reply slot function. This way, we can ensure that our code is shorter and easier to debug, but the lambda function is only suitable if the function is meant to be called
     <span>
      only once.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-51">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor051">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The preceding example is a very simple application that showcases the use of lambda expressions to connect a signal with a lambda function or a regular function without declaring any slot function and thus does not need to be inherited from a
     <span>
      <strong class="source-inline">
       QObject
      </strong>
     </span>
     <span>
      class.
     </span>
    </p>
    <p class="calibre3">
     This is especially useful for calling asynchronous processes that are not under UI objects. Lambda expressions are functions that get defined within another function anonymously, which is quite similar to the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker165">
     </a>
     anonymous functions in
     <strong class="bold">
      JavaScript
     </strong>
     . The format of a lambda function looks
     <span>
      like this:
     </span>
    </p>
    <pre class="source-code">
[captured variables](arguments) {
    lambda code
}</pre>
    <p class="calibre3">
     You can insert variables into a lambda expression by placing them into the
     <strong class="source-inline">
      captured variables
     </strong>
     part, as we did in the example project in this recipe. We capture the
     <strong class="source-inline">
      QNetworkReply
     </strong>
     object called
     <strong class="source-inline">
      reply
     </strong>
     , and the
     <strong class="source-inline">
      QString
     </strong>
     object called
     <strong class="source-inline">
      html
     </strong>
     , and put them in our
     <span>
      lambda expression.
     </span>
    </p>
    <p class="calibre3">
     Then, we can use these variables
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker166">
     </a>
     within our lambda code, as shown in the
     <span>
      following code:
     </span>
    </p>
    <pre class="source-code">
[<strong class="bold1">reply, html</strong>]() {
    <strong class="bold1">html</strong>-&gt;append(QString(<strong class="bold1">reply</strong>-&gt;readAll()));
}</pre>
    <p class="calibre3">
     The argument part is similar to an ordinary function, where you input values to the arguments and use them within your lambda code. In this case, the values of
     <strong class="source-inline">
      bytesReceived
     </strong>
     and
     <strong class="source-inline">
      bytesTotal
     </strong>
     are coming from the
     <span>
      <strong class="source-inline">
       downloadProgress
      </strong>
     </span>
     <span>
      signal:
     </span>
    </p>
    <pre class="source-code">
QObject::connect(reply, &amp;QNetworkReply::downloadProgress,
[reply](qint64 <strong class="source-inline2">bytesReceived</strong>, qint64 <strong class="source-inline2">bytesTotal</strong>) {
    qDebug() &lt;&lt; "Progress: " &lt;&lt; <strong class="source-inline2">bytesReceived</strong> &lt;&lt; "bytes /" &lt;&lt; <strong class="source-inline2">bytesTotal</strong> &lt;&lt; "bytes";
});</pre>
    <p class="calibre3">
     You can also capture all variables that are used in your function using the
     <strong class="source-inline">
      =
     </strong>
     sign. In this case, we captured the
     <strong class="source-inline">
      html
     </strong>
     variable without specifying it in the
     <strong class="source-inline">
      captured
     </strong>
     <span>
      <strong class="source-inline">
       variables
      </strong>
     </span>
     <span>
      area:
     </span>
    </p>
    <pre class="source-code">
[=]() {
    printHTML(*html);
}</pre>
    <h1 class="calibre5" id="_idParaDest-52">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor052">
     </a>
     Function callbacks
    </h1>
    <p class="calibre3">
     Even though Qt 6 supports the signals and slots
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker167">
     </a>
     mechanism, some of the features in Qt 6 still use
     <strong class="bold">
      function callbacks
     </strong>
     , such as keyboard input, window resizing, graphics painting, and others. Since these events only need to be implemented once, there is no need to use the signals and
     <span>
      slots mechanism.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-53">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor053">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started by following
     <span>
      this example:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project, open
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker168">
      </a>
      up
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      , and add the
      <span>
       following headers:
      </span>
      <pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QResizeEvent&gt;
#include &lt;QKeyEvent&gt;
#include &lt;QMouseEvent&gt;</pre>
     </li>
     <li class="calibre14">
      Then, declare these functions
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        mainwindow.h
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold1">void resizeEvent(QResizeEvent *event);</strong>
<strong class="bold1">    void keyPressEvent(QKeyEvent *event);</strong>
<strong class="bold1">    void keyReleaseEvent(QKeyEvent *event);</strong>
<strong class="bold1">    void mouseMoveEvent(QMouseEvent *event);</strong>
<strong class="bold1">    void mousePressEvent(QMouseEvent *event);</strong>
<strong class="bold1">    void mouseReleaseEvent(QMouseEvent *event);</strong></pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and add the following code to the
      <span>
       class constructor:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold1">this-&gt;setMouseTracking(true);</strong>
<strong class="bold1">    ui-&gt;centralWidget-&gt;setMouseTracking(true);</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, define
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker169">
      </a>
      the
      <strong class="source-inline1">
       resizeEvent()
      </strong>
      and
      <span>
       <strong class="source-inline1">
        keyPressedEvent()
       </strong>
      </span>
      <span>
       functions:
      </span>
      <pre class="source-code">
void MainWindow::resizeEvent(QResizeEvent *event) {
    qDebug() &lt;&lt; "Old size:" &lt;&lt; event-&gt;oldSize() &lt;&lt; ", New size:" &lt;&lt; event-&gt;size();
}
void MainWindow::keyPressEvent(QKeyEvent *event) {
    if (event-&gt;key() == Qt::Key_Escape) {
        this-&gt;close();
    }
    qDebug() &lt;&lt; event-&gt;text() &lt;&lt; "has been pressed";
}</pre>
     </li>
     <li class="calibre14">
      Continue to implement the rest of
      <span>
       the functions:
      </span>
      <pre class="source-code">
void MainWindow::keyReleaseEvent(QKeyEvent *event) {
    qDebug() &lt;&lt; event-&gt;text() &lt;&lt; "has been released";
}
void MainWindow::mouseMoveEvent(QMouseEvent *event) {
    qDebug() &lt;&lt; "Position: " &lt;&lt; event-&gt;pos();
}
void MainWindow::mousePressEvent(QMouseEvent *event) {
    qDebug() &lt;&lt; "Mouse pressed:" &lt;&lt; event-&gt;button();
}
void MainWindow::mouseReleaseEvent(QMouseEvent *event) {
    qDebug() &lt;&lt; "Mouse released:" &lt;&lt; event-&gt;button();
}</pre>
     </li>
     <li class="calibre14">
      Build and run the program. Then, try and move the mouse around, rescale the main window, press some
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker170">
      </a>
      random keys on your keyboard, and finally press the
      <em class="italic">
       Esc
      </em>
      key on your keyboard to close
      <span>
       the program.
      </span>
     </li>
    </ol>
    <p class="calibre3">
     You should be seeing debug texts similar to the ones that are being printed out on the application
     <span>
      output window:
     </span>
    </p>
    <pre class="console">
Old size: QSize(-1, -1) , New size: QSize(400, 300)
Old size: QSize(400, 300) , New size: QSize(401, 300)
Old size: QSize(401, 300) , New size: QSize(402, 300)
Position: QPoint(465,348)
Position: QPoint(438,323)
Position: QPoint(433,317)
"a" has been pressed
"a" has been released
"r" has been pressed
"r" has been released
"d" has been pressed
"d" has been released
"\u001B" has been pressed</pre>
    <h2 class="calibre7" id="_idParaDest-54">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor054">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     Qt 6 objects, especially the main window, have a dozen built-in callback functions that exist as
     <strong class="bold">
      virtual functions
     </strong>
     . These functions can
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker171">
     </a>
     be overridden to perform your intended behavior when called. Qt 6 may invoke
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker172">
     </a>
     these
     <strong class="bold">
      callback functions
     </strong>
     when its expected condition has been met, such as a keyboard button has been pressed, the mouse cursor has been moved, the window has been resized, and
     <span>
      so on.
     </span>
    </p>
    <p class="calibre3">
     The functions that we declared in the
     <strong class="source-inline">
      mainwindow.h
     </strong>
     file are virtual functions that are built into the
     <strong class="source-inline">
      QWidget
     </strong>
     class. We are just overriding them with our own code to define their new behavior when they
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker173">
     </a>
     <span>
      are called.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     Do take note that you must call
     <strong class="source-inline1">
      setMouseTracking(true)
     </strong>
     for both
     <strong class="source-inline1">
      MainWindow
     </strong>
     and
     <strong class="source-inline1">
      centralWidget
     </strong>
     for the
     <strong class="source-inline1">
      mouseMoveEvent()
     </strong>
     callback
     <span>
      to work.
     </span>
    </p>
    <p class="calibre3">
     Without features such as function callbacks, signals and slots, we as programmers will have a more difficult time developing applications that are responsive and intuitive to use. Qt 6 shortens our development cycles and allows us to focus more on designing
     <span>
      user-friendly applications.
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
