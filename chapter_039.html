<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   25Customizing and Extending the Standard Library
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_038.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_040.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c25_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c25_1">
      <span aria-label="909" class="calibre17" epub:type="pagebreak" id="Page_909" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c25">
      </span>
      <span class="calibre">
       25
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Customizing and Extending the Standard Library
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c25-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c25-list-0001">
         <li class="calibre9" id="c25-li-0001">
          What allocators are
         </li>
         <li class="calibre9" id="c25-li-0002">
          How to write Standard Library–compliant custom algorithms, containers, and iterators
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c25-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-252">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c25-sec-0003">
        </span>
        <p class="calibre25" id="c25-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13">
      <a class="calibre5" href="c16.xhtml">
       Chapters 16
      </a>
      , “Overview of the C++ Standard Library,”
      <a class="calibre5" href="c18_split_000.xhtml">
       18
      </a>
      , “Standard Library Containers,” and
      <a class="calibre5" href="c20.xhtml">
       20
      </a>
      , “Mastering Standard Library Algorithms,” show that the Standard Library contains a powerful general-purpose collection of containers and algorithms. The information covered so far should be sufficient for most applications. However, those chapters show only the functionality of the library that is available out of the box. The Standard Library can be customized and extended however you like. For example, you can write your own Standard Library–compliant containers, algorithms, and iterators, compatible with existing Standard Library functionality. You can even specify your own memory allocation schemes for containers to use. This chapter provides a taste of these advanced features, primarily through the development of a
      <code class="calibre21">
       find_all
      </code>
      (
      <code class="calibre21">
       )
      </code>
      algorithm and a
      <code class="calibre21">
       directed_graph
      </code>
      container.
      <span aria-label="910" class="calibre20" epub:type="pagebreak" id="Page_910" role="doc-pagebreak">
      </span>
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c25-para-0005">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Customizing and extending the Standard Library is rarely necessary. If you're happy with the existing Standard Library containers and algorithms, you can skip this chapter. However, if you really want to understand the Standard Library, not just use it, give this chapter a chance. You should be comfortable with the operator-overloading material from
          <a class="calibre5" href="c15.xhtml">
           Chapter 15
          </a>
          , “Overloading C++ Operators,” and because this chapter uses templates extensively, you should also be comfortable with the template material from
          <a class="calibre5" href="c12.xhtml">
           Chapter 12
          </a>
          , “Writing Generic Code with Templates,” before continuing
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-253" class="calibre2">
     <span class="calibre" id="c25-sec-0005">
     </span>
     <h2 class="calibre6" id="head-2-253">
      ALLOCATORS
     </h2>
     <p class="calibre13">
      Every Standard Library container takes an
      <code class="calibre21">
       Allocator
      </code>
      type as a template type parameter, for which the default usually suffices. For example, the
      <code class="calibre21">
       vector
      </code>
      template definition looks like this:
     </p>
     <pre class="calibre26" id="c25-code-0001"><code class="calibre21">template &lt;class T, <b class="calibre14">class Allocator = allocator&lt;T&gt;&gt;</b> class vector;</code></pre>
     <p class="calibre13" id="c25-para-0007">
      The container constructors then allow you to pass in an object of type
      <code class="calibre21">
       Allocator
      </code>
      . This permits you to customize the way the containers allocate memory. Every memory allocation performed by a container is made with a call to the
      <code class="calibre21">
       allocate
      </code>
      (
      <code class="calibre21">
       )
      </code>
      member function of the
      <code class="calibre21">
       Allocator
      </code>
      object. Conversely, every deallocation is performed with a call to the
      <code class="calibre21">
       deallocate()
      </code>
      member function of the
      <code class="calibre21">
       Allocator
      </code>
      object. When a Standard Library container takes an
      <code class="calibre21">
       Allocator
      </code>
      parameter, that parameter always defaults to
      <code class="calibre21">
       std::allocator&lt;T&gt;
      </code>
      if not provided. The
      <code class="calibre21">
       allocate()
      </code>
      and
      <code class="calibre21">
       deallocate()
      </code>
      member functions of
      <code class="calibre21">
       std::allocator&lt;T&gt;
      </code>
      are simple wrappers around
      <code class="calibre21">
       new
      </code>
      and
      <code class="calibre21">
       delete
      </code>
      .
     </p>
     <p class="calibre13">
      Keep in mind that
      <code class="calibre21">
       allocate()
      </code>
      simply allocates a big-enough block of uninitialized memory and does not call any object constructor. Similarly,
      <code class="calibre21">
       deallocate()
      </code>
      simply frees the memory block and does not call any destructor. Once a memory block has been allocated, a placement
      <code class="calibre21">
       new
      </code>
      operator (see
      <a class="calibre5" href="c15.xhtml">
       Chapter 15
      </a>
      ) can be used to construct an object in place. The following code snippet shows a contrived example.
      <a class="calibre5" href="c29.xhtml">
       Chapter 29
      </a>
      , “Writing Efficient C++,” shows a more realistic use of an allocator for the implementation of an object pool.
     </p>
     <pre class="calibre26" id="c25-code-0002"><code class="calibre21">class MyClass {};</code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Create an allocator to use.</span></code>
<code class="calibre21">    std::allocator&lt;MyClass&gt; alloc;</code>
<code class="calibre21">    <span class="color">// Allocate an uninitialized memory block for 1 instance of MyClass.</span></code>
<code class="calibre21">    auto* memory { alloc.allocate(1) };</code>
<code class="calibre21">    <span class="color">// Use placement new operator to construct a MyClass in place.</span></code>
<code class="calibre21">    ::new (memory) MyClass{};</code>
<code class="calibre21">    <span class="color">// Destroy MyClass instance.</span></code>
<code class="calibre21">    std::destroy_at(memory);</code>
<code class="calibre21">    <span class="color">// Deallocate memory block.</span></code>
<code class="calibre21">    alloc.deallocate(memory, 1);</code>
<code class="calibre21">    memory = nullptr;</code></pre>
     <pre class="calibre26" id="c25-code-0003"><code class="calibre21">}</code></pre>
     <p class="calibre13" id="c25-para-0009">
      <span aria-label="911" class="calibre20" epub:type="pagebreak" id="Page_911" role="doc-pagebreak">
      </span>
      If you want containers in your program to use a custom memory allocation and deallocation scheme, you can write your own
      <code class="calibre21">
       Allocator
      </code>
      class. There are several reasons for using custom allocators. For example, if the underlying allocator has unacceptable performance, there are alternatives. When OS-specific capabilities, such as shared memory segments, must be allocated, using custom allocators allows the use of Standard Library containers in those shared memory segments. The use of custom allocators is complex, and there are many potential problems if you are not careful, so this should not be approached lightly.
     </p>
     <p class="calibre13" id="c25-para-0010">
      Any class that provides
      <code class="calibre21">
       allocate()
      </code>
      ,
      <code class="calibre21">
       deallocate()
      </code>
      , and several other required member functions and type aliases can be used in place of the default
      <code class="calibre21">
       allocator
      </code>
      class.
     </p>
     <p class="calibre13" id="c25-para-0011">
      Additionally, the Standard Library has the concept of
      <i class="calibre18">
       polymorphic memory allocators
      </i>
      . Basically, the problem with the allocator for a container being specified as a template type parameter is that two containers that are similar but have different allocator types are completely different types. For example,
      <code class="calibre21">
       vector&lt;int, A1&gt;
      </code>
      and
      <code class="calibre21">
       vector&lt;int, A2&gt;
      </code>
      are different and so cannot, e.g., be assigned to one another.
     </p>
     <p class="calibre13" id="c25-para-0012">
      The polymorphic memory allocators, defined in
      <code class="calibre21">
       &lt;memory_resource&gt;
      </code>
      in the
      <code class="calibre21">
       std::pmr
      </code>
      namespace, help to solve this problem. The class
      <code class="calibre21">
       std::pmr::polymorphic_allocator
      </code>
      is a proper
      <code class="calibre21">
       Allocator
      </code>
      class because it satisfies all the allocator requirements, such as having
      <code class="calibre21">
       allocate()
      </code>
      and
      <code class="calibre21">
       deallocate()
      </code>
      member functions. The allocation behavior of a
      <code class="calibre21">
       polymorphic_allocator
      </code>
      depends on the
      <code class="calibre21">
       memory_resource
      </code>
      it's given during construction, and not on any template type parameters. As such, different
      <code class="calibre21">
       polymorphic_allocator
      </code>
      s can behave in completely different ways when allocating and deallocating memory, even though they all have the same type, that is,
      <code class="calibre21">
       polymorphic_allocator
      </code>
      . The standard provides some built-in memory resources that you can use to initialize a polymorphic memory allocator:
      <code class="calibre21">
       synchronized_pool_resource
      </code>
      ,
      <code class="calibre21">
       unsynchronized_pool_resource
      </code>
      , and
      <code class="calibre21">
       monotonic_buffer_resource
      </code>
      . The Standard Library also provides template type aliases such as
      <code class="calibre21">
       std::pmr::vector&lt;T&gt;
      </code>
      for
      <code class="calibre21">
       std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;
      </code>
      . An
      <code class="calibre21">
       std::pmr::vector&lt;T&gt;
      </code>
      is still a different type from
      <code class="calibre21">
       std::vector&lt;T&gt;
      </code>
      and cannot be assigned from
      <code class="calibre21">
       std::vector&lt;T&gt;
      </code>
      . But an
      <code class="calibre21">
       std::pmr::vector&lt;T&gt;
      </code>
      affiliated with one memory resource is the same type as, and can be assigned from, a second
      <code class="calibre21">
       std::pmr::vector&lt;T&gt;
      </code>
      object affiliated with a different memory resource.
     </p>
     <p class="calibre13" id="c25-para-0013">
      However, in my experience, both custom allocators and polymorphic memory allocators are rather advanced and rarely used features in day-to-day coding. I've never used them myself, so a detailed discussion falls outside the scope of this book. For more information, consult one of the books listed in
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography,” that specifically covers the C++ Standard Library.
     </p>
    </section>
    <section aria-labelledby="head-2-254" class="calibre2">
     <span class="calibre" id="c25-sec-0006">
     </span>
     <h2 class="calibre6" id="head-2-254">
      EXTENDING THE STANDARD LIBRARY
     </h2>
     <p class="calibre13">
      The Standard Library includes many useful containers, algorithms, and iterators that you can use in your applications. It is impossible, however, for any library to include all possible utilities that all potential clients might need. Thus, the best libraries are extensible: they allow clients to adapt and add to the basic capabilities to obtain exactly the functionality they require. The Standard Library is inherently extensible because of its fundamental structure of separating data from the algorithms
      <span aria-label="912" class="calibre20" epub:type="pagebreak" id="Page_912" role="doc-pagebreak">
      </span>
      that operate on them. You can write your own containers that can work with the Standard Library algorithms by providing iterators that conform to the Standard Library guidelines. Similarly, you can write your own algorithms that work with iterators from the standard containers. Keep in mind, though, that you are not allowed to put your own containers and algorithms in the
      <code class="calibre21">
       std
      </code>
      namespace.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c25-para-0015">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          This book usually uses the convention to name functions and member functions without any underscores and where each word of the name is capitalized, except for the first word, for example:
         </i>
         <code class="calibre21">
          getIndex()
         </code>
         <i class="calibre18">
          . However, this chapter talks about extending the Standard Library, hence it uses the naming conventions used by the Standard Library. This means function and member function names are all lowercase with underscores separating the words, for example
         </i>
         <code class="calibre21">
          get_index()
         </code>
         <i class="calibre18">
          . Class names are also using the Standard Library naming conventions.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c25-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-476">
       Why Extend the Standard Library?
      </h3>
      <p class="calibre13" id="c25-para-0016">
       If you sit down to write an algorithm or container in C++, you can either make it adhere to the Standard Library conventions or not. For simple containers and algorithms, it might not be worth the extra effort to follow the Standard Library requirements. However, for substantial code that you plan to reuse, the effort pays off. First, the code will be easier for other C++ programmers to understand, because you follow well-established interface guidelines. Second, you will be able to use your container or algorithm with the other parts of the Standard Library (algorithms or containers) without needing to provide special hacks or adapters. Finally, it will force you to employ the necessary rigor required to develop solid code.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c25-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-477">
       Writing a Standard Library Algorithm
      </h3>
      <p class="calibre13" id="c25-para-0017">
       <a class="calibre5" href="c16.xhtml">
        Chapters 16
       </a>
       and
       <a class="calibre5" href="c20.xhtml">
        20
       </a>
       describe a useful set of algorithms that is part of the Standard Library, but you will inevitably encounter situations in your programs for which you need new algorithms. When that happens, it is usually not difficult to write your own algorithm that works with Standard Library iterators just like the standard algorithms.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0010">
       </span>
       <h4 class="calibre29" id="head-4-362">
        find_all
       </h4>
       <p class="calibre13" id="c25-para-0018">
        Suppose you want to find all elements, including their position, matching a predicate in a given range. The
        <code class="calibre21">
         find()
        </code>
        and
        <code class="calibre21">
         find_if()
        </code>
        algorithms are the most likely candidates, but each returns an iterator referring to only one element. You can use
        <code class="calibre21">
         copy_if()
        </code>
        to find all elements matching a given predicate, but it fills the output with copies of the found elements, so you lose their position. If you want to avoid copies, you can use
        <code class="calibre21">
         copy_if()
        </code>
        with a
        <code class="calibre21">
         back_insert_iterator
        </code>
        (see
        <a class="calibre5" href="c17.xhtml">
         Chapter 17
        </a>
        , “Understanding Iterators and the Ranges Library”) into a
        <code class="calibre21">
         vector&lt;reference:wrapper&lt;T&gt;&gt;
        </code>
        , but this does not give you the position of the found elements either. In fact, there is no standard algorithm to get iterators to all the elements matching a predicate. However, you can write your own version of this functionality called
        <code class="calibre21">
         find_all()
        </code>
        .
       </p>
       <p class="calibre13" id="c25-para-0019">
        <span aria-label="913" class="calibre20" epub:type="pagebreak" id="Page_913" role="doc-pagebreak">
        </span>
        In this first section, we'll look at an implementation of
        <code class="calibre21">
         find_all()
        </code>
        following the model of legacy unconstrained algorithms. Once that implementation is working, we'll see how it can be extended and adapted to follow the model of modern constrained algorithms by adding support for projections and more.
       </p>
       <p class="calibre13">
        The first task is to define the function prototype. You can follow the model established by
        <code class="calibre21">
         copy_if()
        </code>
        , that is, a function template with three template type parameters: the input iterator type, the output iterator type, and the predicate type. The parameters of the function are start and end iterators of the input sequence, a start iterator of the output sequence, and a predicate object. As with
        <code class="calibre21">
         copy_if()
        </code>
        , the algorithm returns an iterator into the output sequence that is one-past-the-last element stored in the output sequence. Of course, in modern C++ code, it's recommended to add proper constraints to template type parameters, so let's follow that advice. Here is the prototype:
       </p>
       <pre class="calibre26" id="c25-code-0004"><code class="calibre21">template &lt;forward_iterator ForwardIterator,</code>
<code class="calibre21">          output_iterator&lt;ForwardIterator&gt; OutputIterator,</code>
<code class="calibre21">          indirect_unary_predicate&lt;ForwardIterator&gt; Predicate&gt;</code>
<code class="calibre21">OutputIterator find_all(ForwardIterator first, ForwardIterator last,</code>
<code class="calibre21">                        OutputIterator dest, Predicate pred);</code></pre>
       <p class="calibre13" id="c25-para-0021">
        The
        <code class="calibre21">
         forward_iterator
        </code>
        concept specifies that an iterator must be dereferenceable and incrementable, among others. The
        <code class="calibre21">
         output_iterator&lt;ForwardIterator&gt;
        </code>
        concept requires that an iterator is an output iterator that accepts values of type
        <code class="calibre21">
         ForwardIterator
        </code>
        . The
        <code class="calibre21">
         indirect_unary_predicate
        </code>
        concept is a predefined set of requirements that algorithms can use to specify the requirements for unary predicate arguments. It's “indirect” because the requirements are applied to the type that its template type parameter,
        <code class="calibre21">
         ForwardIterator
        </code>
        in this case, refers to, and not to
        <code class="calibre21">
         ForwardIterator
        </code>
        itself.
       </p>
       <p class="calibre13" id="c25-para-0022">
        Another design choice would be to omit the output iterator and return an iterator into the input sequence that iterates over all the matching elements in the input sequence. This would require you to write your own iterator class, which is discussed later in this chapter.
       </p>
       <p class="calibre13">
        The next task is to write the implementation. The
        <code class="calibre21">
         find_all()
        </code>
        algorithm iterates over all elements in the input sequence, uses
        <code class="calibre21">
         invoke()
        </code>
        to call the predicate on each element, and stores iterators of matching elements in the output sequence. Here is the implementation:
       </p>
       <pre class="calibre26" id="c25-code-0005"><code class="calibre21">template &lt;forward_iterator ForwardIterator,</code>
<code class="calibre21">          output_iterator&lt;ForwardIterator&gt; OutputIterator,</code>
<code class="calibre21">          indirect_unary_predicate&lt;ForwardIterator&gt; Predicate&gt;</code>
<code class="calibre21">OutputIterator find_all(ForwardIterator first, ForwardIterator last,</code>
<code class="calibre21">                        OutputIterator dest, Predicate pred) </code>
<code class="calibre21">{</code>
<code class="calibre21">    while (first != last) {</code>
<code class="calibre21">        if (invoke(pred, *first)) { </code>
<code class="calibre21">            *dest = first;</code>
<code class="calibre21">            ++dest;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        ++first;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return dest;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Similar to
        <code class="calibre21">
         copy_if()
        </code>
        , the algorithm only overwrites existing elements in the output sequence, so make sure the output sequence is large enough to hold the result, or use an iterator adapter such as
        <span aria-label="914" class="calibre20" epub:type="pagebreak" id="Page_914" role="doc-pagebreak">
        </span>
        <code class="calibre21">
         back_insert_iterator
        </code>
        , as demonstrated in the following code. After finding all matching elements, the code counts the number of elements found, which is the number of iterators in
        <code class="calibre21">
         matches
        </code>
        . Then, it iterates through the result, printing each element.
       </p>
       <pre class="calibre26" id="c25-code-0006"><code class="calibre21">vector&lt;int&gt; vec { 5, 4, 5, 4, 10, 6, 5, 8, 10 }; </code>
<code class="calibre21">vector&lt;vector&lt;int&gt;::iterator&gt; matches;</code>
<code class="calibre21"> </code>
<code class="calibre21">find_all(begin(vec), end(vec), back_inserter(matches),</code>
<code class="calibre21">    [](int i){ return i == 10; });</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Found {} matching elements: ", matches.size());</code>
<code class="calibre21">for (const auto&amp; it : matches) {</code>
<code class="calibre21">    println("{} at position {}", *it, distance(begin(vec), it));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c25-code-0007"><code class="calibre21">Found 2 matching elements:</code>
<code class="calibre21">10 at position 4</code>
<code class="calibre21">10 at position 8</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-363">
        Modernized find_all
       </h4>
       <p class="calibre13">
        As
        <a class="calibre5" href="c17.xhtml">
         Chapter 17
        </a>
        explains, most constrained algorithms accept a projection parameter. The
        <code class="calibre21">
         find_all()
        </code>
        algorithm can be modernized to support such a projection parameter. Additionally, constrained algorithms usually don't have a begin and end iterator of the same type. Instead, the begin iterator is as usual, but the end marker can be of a different type and is then called a
        <i class="calibre18">
         sentinel
        </i>
        . Here is the updated algorithm:
       </p>
       <pre class="calibre26" id="c25-code-0008"><code class="calibre21">template &lt;forward_iterator ForwardIterator,</code>
<code class="calibre21">    sentinel_for&lt;ForwardIterator&gt; Sentinel,</code>
<code class="calibre21">    output_iterator&lt;ForwardIterator&gt; OutputIterator,</code>
<code class="calibre21">    typename Projection = std::identity,</code>
<code class="calibre21">    indirect_unary_predicate&lt;projected&lt;ForwardIterator, Projection&gt;&gt; Predicate&gt;</code>
<code class="calibre21">OutputIterator find_all(ForwardIterator first, Sentinel last,</code>
<code class="calibre21">                        OutputIterator dest, Predicate pred, Projection proj = {})</code>
<code class="calibre21">{</code>
<code class="calibre21">    while (first != last) {</code>
<code class="calibre21">        if (invoke(pred, invoke(proj, *first))) {</code>
<code class="calibre21">            *dest = first;</code>
<code class="calibre21">            ++dest;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        ++first;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return dest;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c25-para-0027">
        The
        <code class="calibre21">
         sentinel_for
        </code>
        constraint ensures that the expression
        <code class="calibre21">
         first != last
        </code>
        is valid. The
        <code class="calibre21">
         Projection
        </code>
        template type parameter is new and has a default value, the
        <code class="calibre21">
         identity
        </code>
        operation. The template type argument for
        <code class="calibre21">
         indirect_unary_predicate
        </code>
        changed slightly to
        <code class="calibre21">
         projected&lt;ForwardIterator,Projection&gt;
        </code>
        , which represents the type of applying the
        <code class="calibre21">
         Projection
        </code>
        function to a dereferenced
        <code class="calibre21">
         ForwardIterator
        </code>
        .
       </p>
       <p class="calibre13">
        <span aria-label="915" class="calibre20" epub:type="pagebreak" id="Page_915" role="doc-pagebreak">
        </span>
        The modernized
        <code class="calibre21">
         find_all()
        </code>
        can be tested as follows:
       </p>
       <pre class="calibre26" id="c25-code-0009"><code class="calibre21">find_all(begin(vec), end(vec), back_inserter(matches),</code>
<code class="calibre21">    [](int i) { return i == 10; },</code>
<code class="calibre21">    [](int i) { return i * 2; });</code></pre>
       <p class="calibre13">
        This invocation of
        <code class="calibre21">
         find_all()
        </code>
        is similar to the one from the previous section, except that it now includes a projection. For each element, the algorithm first transforms it using this projection function, and then passes it to the given predicate. In this case, each element is first doubled, and then checked whether the transformed element is equal to 10. Thus, the output now is as follows. Compare this with the output from the previous section.
       </p>
       <pre class="calibre26" id="c25-code-0010"><code class="calibre21">Found 3 matching elements:</code>
<code class="calibre21">5 at position 0</code>
<code class="calibre21">5 at position 2</code>
<code class="calibre21">5 at position 6</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c25-sec-0012">
      </span>
      <h3 class="calibre27" id="head-3-478">
       Writing a Standard Library Container
      </h3>
      <p class="calibre13" id="c25-para-0030">
       The C++ Standard Library contains a list of requirements that any container must fulfill to qualify as a Standard Library container. Additionally, if you want your container to be sequential (like a
       <code class="calibre21">
        vector
       </code>
       ), ordered associative (like a
       <code class="calibre21">
        map
       </code>
       ), or unordered associative (like an
       <code class="calibre21">
        unordered_map
       </code>
       ), it must conform to supplementary requirements.
      </p>
      <p class="calibre13" id="c25-para-0031">
       My suggestion when writing a custom container is to write the basic container first, following the general Standard Library rules such as making it a class template, but without worrying too much yet about the specific details of Standard Library conformity. After developing the basic implementation, add iterator support so that it can work with the Standard Library framework. Next, add member functions and type aliases to fulfill all basic container requirements, and finally, fulfill any additional container requirements. This chapter takes that approach to develop a
       <i class="calibre18">
        directed graph
       </i>
       data structure, also called a
       <i class="calibre18">
        digraph
       </i>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0013">
       </span>
       <h4 class="calibre29" id="head-4-364">
        A Basic Directed Graph
       </h4>
       <p class="calibre13" id="c25-para-0032">
        Certain C++ Standard Library containers might possibly use a graph in their implementation, but the standard does not make any graph-like data structures available to the user. So, implementing your own graph sounds like a perfect example of writing your own Standard Library–compliant container.
       </p>
       <p class="calibre13" id="c25-para-0033">
        Before starting with writing any code, let's first take a look at what kind of data structure a directed graph is and how to represent its data in memory.
        <a class="calibre5" href="#c25-fig-0001" id="R_c25-fig-0001">
         Figure 25.1
        </a>
        shows a visual representation of a directed graph example. Basically, a directed graph consists of a set of
        <i class="calibre18">
         nodes
        </i>
        , also called
        <i class="calibre18">
         vertices
        </i>
        , which are connected by
        <i class="calibre18">
         edges
        </i>
        . Additionally, every edge has a direction, indicated by the arrows, which is why it's called a
        <i class="calibre18">
         directed
        </i>
        graph.
       </p>
       <span aria-label="916" class="calibre20" epub:type="pagebreak" id="Page_916" role="doc-pagebreak">
       </span>
       <figure class="calibre36">
        <img alt="A diagram illustrates circles, each has a number, connected by arrows. There are eight circles numbered 1 to 7, 11 and 12. Circle 1 is central and has arrows pointing towards circles numbered 6, 3, and 7." class="center" src="images/c25f001.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c25-fig-0001" id="c25-fig-0001" role="doc-backlink">
            <b class="calibre14">
             FIGURE 25.1
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p class="calibre13" id="c25-para-0034">
        There are multiple ways to store such a data structure in memory, such as edge lists, adjacency matrices, and adjacency lists. This implementation uses
        <i class="calibre18">
         adjacency lists
        </i>
        . Nodes are stored in a
        <code class="calibre21">
         vector
        </code>
        with each node having an adjacency list listing its neighboring nodes. Let's look at an example. Suppose you have the directed graph from
        <a class="calibre5" href="#c25-fig-0002" id="R_c25-fig-0002">
         Figure 25.2
        </a>
        .
       </p>
       <figure class="calibre36">
        <img alt="A diagram illustrates a simple directed graph comprising three nodes. A, B, and C. There is an arrow from node A to node B, another arrow from node B to node C, and a final arrow from node A to node C." class="center" src="images/c25f002.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c25-fig-0002" id="c25-fig-0002" role="doc-backlink">
            <b class="calibre14">
             FIGURE 25.2
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p class="calibre13" id="c25-para-0035">
        Representing this graph with adjacency lists results in the following data structure:
       </p>
       <table border="1" class="calibre31">
        <thead class="calibre32">
         <tr class="calibre33">
          <th class="left" scope="col">
           NODE
          </th>
          <th class="left" scope="col">
           ADJACENCY LIST
          </th>
         </tr>
        </thead>
        <tbody class="calibre34">
         <tr class="calibre33">
          <td class="bgcolor">
           A
          </td>
          <td class="bgcolor">
           B, C
          </td>
         </tr>
         <tr class="calibre33">
          <td class="bgcolor">
           B
          </td>
          <td class="bgcolor">
           C
          </td>
         </tr>
         <tr class="calibre33">
          <td class="bgcolor">
           C
          </td>
          <td class="bgcolor">
          </td>
         </tr>
        </tbody>
       </table>
       <p class="calibre13" id="c25-para-0037">
        This can be stored as a
        <code class="calibre21">
         vector
        </code>
        where each element in the
        <code class="calibre21">
         vector
        </code>
        represents one row of the table; that is, each
        <code class="calibre21">
         vector
        </code>
        element represents a single node and its corresponding adjacency list. Let's start with a basic implementation without worrying too much about Standard Library compliance. This first section implements a simple, but fully functional,
        <code class="calibre21">
         directed_graph&lt;T&gt;
        </code>
        where
        <code class="calibre21">
         T
        </code>
        is the type of value to be stored in a single node. All values stored in a
        <code class="calibre21">
         directed_graph
        </code>
        must be unique. This might not be the best or most performant implementation of a directed graph, but that's not the point of this chapter. The point is to walk through the process of making a data structure following the Standard Library philosophy.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0014">
        </span>
        <h5 class="calibre35" id="head-5-138">
         The graph_node Class Template
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          directed_graph
         </code>
         implementation uses the concept of nodes, so the first piece of code to implement is a data structure representing a single node of a graph. A node has a value and a list of adjacent nodes, stored as a
         <code class="calibre21">
          set
         </code>
         of indices to those adjacent nodes. Using a
         <code class="calibre21">
          set
         </code>
         makes sure that no duplicate adjacent indices are stored in the list. The class has a constructor to construct a new
         <code class="calibre21">
          graph_node
         </code>
         for a given value and has a
         <code class="calibre21">
          value()
         </code>
         member function to retrieve the value of the node. Only a
         <code class="calibre21">
          const
         </code>
         overload of
         <code class="calibre21">
          value()
         </code>
         is provided, as values should never change. The definition is in a
         <code class="calibre21">
          directed_graph:node
         </code>
         partition file called
         <code class="calibre21">
          graph_node.cppm
         </code>
         , inside a namespace called
         <code class="calibre21">
          details
         </code>
         , and is not exported from the module, as users of
         <code class="calibre21">
          directed_graph
         </code>
         s should not directly use
         <code class="calibre21">
          graph_node
         </code>
         s themselves. Here is the interface of
         <code class="calibre21">
          graph_node
         </code>
         . Note the use of the
         <code class="calibre21">
          [[nodiscard]]
         </code>
         attribute, introduced in
         <a class="calibre5" href="c01_split_000.xhtml">
          Chapter 1
         </a>
         , “A Crash Course in C++ and the Standard Library”:
        </p>
        <pre class="calibre26" id="c25-code-0011"><code class="calibre21">export module directed_graph:node;</code>
<code class="calibre21">…</code>
<code class="calibre21">namespace details</code>
<code class="calibre21">{</code>
<code class="calibre21">    template &lt;typename T&gt;</code>
<code class="calibre21">    class graph_node</code>
<code class="calibre21">    {</code>
<code class="calibre21">        public:</code>
<code class="calibre21">            <span class="color">// Constructs a graph_node for the given value.</span></code>
<code class="calibre21">            explicit graph_node(directed_graph&lt;T&gt;* graph, T t)</code>
<code class="calibre21">                : m_graph { graph }, m_data(std::move(t)) { }</code>
<code class="calibre21"> </code>
<span aria-label="917" class="calibre20" epub:type="pagebreak" id="Page_917" role="doc-pagebreak"></span><code class="calibre21">            <span class="color">// Returns a reference to the stored value.</span></code>
<code class="calibre21">            [[nodiscard]] const T&amp; value() const noexcept { return m_data; }</code>
<code class="calibre21"> </code>
<code class="calibre21">            <span class="color">// Type alias for the container type used to store the adjacency list.</span></code>
<code class="calibre21">            using adjacency_list_type = std::set&lt;std::size_t&gt;;</code>
<code class="calibre21"> </code>
<code class="calibre21">            <span class="color">// Returns a reference to the adjacency list.</span></code>
<code class="calibre21">            [[nodiscard]] auto&amp; get_adjacent_nodes_indices() {</code>
<code class="calibre21">                return m_adjacentNodeIndices; }</code>
<code class="calibre21">            [[nodiscard]] const auto&amp; get_adjacent_nodes_indices() const {</code>
<code class="calibre21">                return m_adjacentNodeIndices; }</code>
<code class="calibre21">        private:</code>
<code class="calibre21">            <span class="color">// A pointer to the graph this node is in.</span></code>
<code class="calibre21">            directed_graph&lt;T&gt;* m_graph;</code>
<code class="calibre21"> </code>
<code class="calibre21">            T m_data;</code>
<code class="calibre21">            adjacency_list_type m_adjacentNodeIndices;</code>
<code class="calibre21">    };</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c25-para-0039">
         In this definition, no constraints are placed on the template type parameter
         <code class="calibre21">
          T
         </code>
         . The reason is that, just as
         <code class="calibre21">
          vector
         </code>
         , the element requirements depend on what operations are actually performed on the container.
        </p>
        <p class="calibre13" id="c25-para-0040">
         The initialization of
         <code class="calibre21">
          m_data
         </code>
         in the constructor initializer uses
         <code class="calibre21">
          m_data
          <b class="calibre14">
           (
          </b>
          std::move(t)
          <b class="calibre14">
           )
          </b>
         </code>
         . Using the uniform initialization syntax,
         <code class="calibre21">
          m_data
          <b class="calibre14">
           {
          </b>
          std::move(t)
          <b class="calibre14">
           }
          </b>
         </code>
         , might not compile because
         <code class="calibre21">
          T
         </code>
         is a user-defined type.
        </p>
        <p class="calibre13" id="c25-para-0041">
         Now that we have our
         <code class="calibre21">
          graph_node
         </code>
         implementation, let's look at the
         <code class="calibre21">
          directed_graph
         </code>
         class itself.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0015">
        </span>
        <h5 class="calibre35" id="head-5-139">
         The directed_graph Interface
        </h5>
        <p class="calibre13">
         A
         <code class="calibre21">
          directed_graph
         </code>
         supports three basic operations: insertion, deletion, and lookup; additionally, it is swappable. It is defined in a
         <code class="calibre21">
          directed_graph
         </code>
         module. Here is the
         <code class="calibre21">
          public
         </code>
         portion of the
         <code class="calibre21">
          directed_graph
         </code>
         class template:
        </p>
        <pre class="calibre26" id="c25-code-0012"><code class="calibre21">export module directed_graph;</code>
<code class="calibre21">…</code>
<code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// For insert to be successful, the value shall not be in the graph yet.</span></code>
<code class="calibre21">        <span class="color">// Returns true if a new node with given value has been added to</span></code>
<code class="calibre21">        <span class="color">// the graph, and false if there was already a node with the given value.</span></code>
<code class="calibre21">        bool insert(T node_value);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns true if the given node value was erased, false otherwise.</span></code>
<code class="calibre21">        bool erase(const T&amp; node_value);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns true if the edge was successfully created, false otherwise.</span></code>
<code class="calibre21">        bool insert_edge(const T&amp; from_node_value, const T&amp; to_node_value);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns true if the given edge was erased, false otherwise.</span></code>
<code class="calibre21">        bool erase_edge(const T&amp; from_node_value, const T&amp; to_node_value);</code>
<code class="calibre21"> </code>
<span aria-label="918" class="calibre20" epub:type="pagebreak" id="Page_918" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// Removes all nodes from the graph.</span></code>
<code class="calibre21">        void clear() noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns a reference to the value in the node with given index</span></code>
<code class="calibre21">        <span class="color">// without bounds checking.</span></code>
<code class="calibre21">        const T&amp; operator[](std::size_t index) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Two directed graphs are equal if their sets of nodes are equal (where</span></code>
<code class="calibre21">        <span class="color">// nodes with the same T value are considered equal) and the same number</span></code>
<code class="calibre21">        <span class="color">// of edges between each corresponding pair of nodes.</span></code>
<code class="calibre21">        <span class="color">// The order in which the nodes and edges have been added does not</span></code>
<code class="calibre21">        <span class="color">// affect equality.</span></code>
<code class="calibre21">        bool operator==(const directed_graph&amp; rhs) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Swaps all nodes between this graph and the given graph.</span></code>
<code class="calibre21">        void swap(directed_graph&amp; other_graph) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns the number of nodes in the graph.</span></code>
<code class="calibre21">        [[nodiscard]] std::size_t size() const noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns a set with the values of the adjacent nodes of a given node.</span></code>
<code class="calibre21">        <span class="color">// If the given node does not exist, an empty set is returned.</span></code>
<code class="calibre21">        [[nodiscard]] std::set&lt;T&gt; get_adjacent_nodes_values(</code>
<code class="calibre21">            const T&amp; node_value) const;</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Implementation details not shown yet.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c25-para-0043">
         The element type is a template type parameter, similar to the Standard Library
         <code class="calibre21">
          vector
         </code>
         container's. This interface looks straightforward. Note that this interface does not define any user-defined copy and move constructors, copy and move assignment operators, or destructor; i.e., the class follows the Rule of Zero as discussed in
         <a class="calibre5" href="c09.xhtml">
          Chapter 9
         </a>
         , “Mastering Classes and Objects.”
        </p>
        <p class="calibre13" id="c25-para-0044">
         Let's now look at concrete implementations of the
         <code class="calibre21">
          public
         </code>
         member functions.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0016">
        </span>
        <h5 class="calibre35" id="head-5-140">
         The Implementation
        </h5>
        <p class="calibre13">
         After you finalize the
         <code class="calibre21">
          directed_graph
         </code>
         interface, you need to choose the implementation model. As discussed earlier, this implementation stores a directed graph as a list of nodes where each node contains its value and its set of adjacent node indices. Since the adjacent node lists contain indices to other nodes, nodes should be accessible based on their indices. Thus, a
         <code class="calibre21">
          vector
         </code>
         is the most appropriate container for storing the nodes. Each node is represented as a
         <code class="calibre21">
          graph_node
         </code>
         instance. Thus, the final structure is a
         <code class="calibre21">
          vector
         </code>
         of
         <code class="calibre21">
          graph_node
         </code>
         s. Here are the first
         <code class="calibre21">
          private
         </code>
         members of the
         <code class="calibre21">
          directed_graph
         </code>
         class:
        </p>
        <pre class="calibre26" id="c25-code-0013"><code class="calibre21">private:</code>
<code class="calibre21">    using node_container_type = std::vector&lt;details::graph_node&lt;T&gt;&gt;;</code>
<code class="calibre21">    node_container_type m_nodes;</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0017">
        </span>
        <h5 class="calibre35" id="head-5-141">
         Searching Nodes
        </h5>
        <p class="calibre13">
         Insert and delete operations on a graph require code to find an element with a given node value. Thus, it is helpful to have a
         <code class="calibre21">
          private
         </code>
         helper member function that performs this task. Both a
         <code class="calibre21">
          const
         </code>
         and a non-
         <code class="calibre21">
          const
         </code>
         overload are provided:
        </p>
        <pre class="calibre26" id="c25-code-0014"><span aria-label="919" class="calibre20" epub:type="pagebreak" id="Page_919" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Helper member function to return an iterator to the given node, or the</span></code>
<code class="calibre21"><span class="color">// end iterator if the given node is not in the graph.</span></code>
<code class="calibre21">typename node_container_type::iterator find_node(const T&amp; node_value);</code>
<code class="calibre21">typename node_container_type::const_iterator find_node(const T&amp; node_value) const;</code></pre>
        <p class="calibre13">
         The implementation of the non-
         <code class="calibre21">
          const
         </code>
         overload of
         <code class="calibre21">
          find_node()
         </code>
         is as follows. The
         <code class="calibre21">
          const
         </code>
         overload has the same implementation.
        </p>
        <pre class="calibre26" id="c25-code-0015"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::node_container_type::iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::find_node(const T&amp; node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return std::find_if(std::begin(m_nodes), std::end(m_nodes),</code>
<code class="calibre21">        [&amp;](const auto&amp; node) { return node.value() == node_value; });</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c25-para-0048">
         The body of the member function is not too complicated. It uses the
         <code class="calibre21">
          find_if()
         </code>
         algorithm from the Standard Library, discussed in
         <a class="calibre5" href="c20.xhtml">
          Chapter 20
         </a>
         , to search all the nodes in the graph for a node with a value equal to the
         <code class="calibre21">
          node_value
         </code>
         parameter. If such a node is found in the graph, an iterator to that node is returned; otherwise, an end iterator is returned.
        </p>
        <p class="calibre13" id="c25-para-0049">
         The syntax in the function header of this member function is somewhat confusing, particularly the use of the
         <code class="calibre21">
          typename
         </code>
         keyword. You must use the
         <code class="calibre21">
          typename
         </code>
         keyword whenever you are using a type that is dependent on a template parameter. Specifically, the type
         <code class="calibre21">
          node_container_type::iterator
         </code>
         , which is
         <code class="calibre21">
          vector&lt;details::graph_node&lt;T&gt;&gt;::iterator
         </code>
         , is dependent on the
         <code class="calibre21">
          T
         </code>
         template type parameter.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0018">
        </span>
        <h5 class="calibre35" id="head-5-142">
         Inserting Nodes
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          insert()
         </code>
         must first check whether a node with a given value already exists in the graph. If it doesn't exist yet, a new node can be created for the given value. The
         <code class="calibre21">
          public
         </code>
         interface provides an
         <code class="calibre21">
          insert()
         </code>
         member function accepting a
         <code class="calibre21">
          T
         </code>
         by value. This is optimal in this case and follows the recommendation explained in the section “
         <a class="calibre5" href="c09.xhtml#c09-sec-0033">
          Optimal Way to Pass Arguments to Functions
         </a>
         ” in
         <a class="calibre5" href="c09.xhtml">
          Chapter 9
         </a>
         . The call to
         <code class="calibre21">
          emplace:back()
         </code>
         constructs a new
         <code class="calibre21">
          graph_node
         </code>
         by passing a pointer to the
         <code class="calibre21">
          directed_graph
         </code>
         and the node's value to the
         <code class="calibre21">
          graph_node
         </code>
         constructor:
        </p>
        <pre class="calibre26" id="c25-code-0016"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">bool directed_graph&lt;T&gt;::insert(T node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto iter { find_node(node_value) };</code>
<code class="calibre21">    if (iter != std::end(m_nodes)) {</code>
<code class="calibre21">        <span class="color">// Value is already in the graph, return false.</span></code>
<code class="calibre21">        return false;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    m_nodes.emplace:back(this, std::move(node_value));</code>
<code class="calibre21">    <span class="color">// Value successfully added to the graph, return true.</span></code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0019">
        </span>
        <h5 class="calibre35" id="head-5-143">
         Inserting Edges
        </h5>
        <p class="calibre13">
         Once nodes have been added to the graph, edges between those nodes can be constructed to build up a directed graph. For this, an
         <code class="calibre21">
          insert_edge()
         </code>
         member function is provided that requires two
         <span aria-label="920" class="calibre20" epub:type="pagebreak" id="Page_920" role="doc-pagebreak">
         </span>
         parameters: the value of the node from which the edge should start, and the value of the node to which the edge should point. The first thing the member function does is to search the graph for the from and to nodes. If either one of them is not found in the graph,
         <code class="calibre21">
          false
         </code>
         is returned. If both are found, then the code calculates the index of the node containing
         <code class="calibre21">
          to_node_value
         </code>
         by calling
         <code class="calibre21">
          get_index_of_node()
         </code>
         , a
         <code class="calibre21">
          private
         </code>
         helper function, and finally adds this index to the adjacency list of the node containing
         <code class="calibre21">
          from_node_value
         </code>
         . The
         <code class="calibre21">
          insert_edge()
         </code>
         member function returns
         <code class="calibre21">
          true
         </code>
         if and only if the graph changed as a result of the call. Remember from
         <a class="calibre5" href="c18_split_000.xhtml">
          Chapter 18
         </a>
         that
         <code class="calibre21">
          insert()
         </code>
         on a
         <code class="calibre21">
          set
         </code>
         returns a
         <code class="calibre21">
          pair&lt;iterator,bool&gt;
         </code>
         , where the Boolean represents whether the insert was successful, which is why
         <code class="calibre21">
          .second
         </code>
         is used on the result of
         <code class="calibre21">
          insert()
         </code>
         in the
         <code class="calibre21">
          return
         </code>
         statement.
        </p>
        <pre class="calibre26" id="c25-code-0017"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">bool directed_graph&lt;T&gt;::insert_edge(const T&amp; from_node_value,</code>
<code class="calibre21">    const T&amp; to_node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    const auto from { find_node(from_node_value) };</code>
<code class="calibre21">    const auto to { find_node(to_node_value) };</code>
<code class="calibre21">    if (from == std::end(m_nodes) || to == std::end(m_nodes)) {</code>
<code class="calibre21">        return false;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    const std::size_t to_index { get_index_of_node(to) };</code>
<code class="calibre21">    return from-&gt;get_adjacent_nodes_indices().insert(to_index).second;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The
         <code class="calibre21">
          get_index_of_node()
         </code>
         helper member function is implemented as follows:
        </p>
        <pre class="calibre26" id="c25-code-0018"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::size_t directed_graph&lt;T&gt;::get_index_of_node(</code>
<code class="calibre21">    typename node_container_type::const_iterator node) const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    return node - std::cbegin(m_nodes);</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0020">
        </span>
        <h5 class="calibre35" id="head-5-144">
         Deleting Nodes
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          erase()
         </code>
         follows the same pattern as
         <code class="calibre21">
          insert()
         </code>
         : it first attempts to find the given node by calling
         <code class="calibre21">
          find_node()
         </code>
         . If the node exists, it erases it from the graph. Otherwise, it does nothing. Removing an existing node from the graph is a two-step procedure:
        </p>
        <ol class="calibre7" id="c25-list-0002">
         <li class="calibre9" id="c25-li-0003">
          Remove the index of the to-be-deleted node from all adjacency lists of all other nodes.
         </li>
         <li class="calibre9" id="c25-li-0004">
          Remove the actual node from the list of nodes.
         </li>
        </ol>
        <p class="calibre13">
         For the first step, a helper member function
         <code class="calibre21">
          remove_node_index()
         </code>
         is added to
         <code class="calibre21">
          graph_node,
         </code>
         which removes a given node index from the adjacency list of a node and updates the remaining indices to account for the shift in indices. The implementation follows. One tricky part is that the adjacency list is a
         <code class="calibre21">
          set
         </code>
         , and a
         <code class="calibre21">
          set
         </code>
         does not allow modifications to its values. Instead, the second step in the implementation converts the
         <code class="calibre21">
          set
         </code>
         into a
         <code class="calibre21">
          vector
         </code>
         , uses the
         <code class="calibre21">
          for_each()
         </code>
         algorithm to update all indices that require updating, and finally clears the
         <code class="calibre21">
          set
         </code>
         and inserts the updated indices. Again, this might not be the most performant implementation, but, as mentioned earlier, that's not the point of this discussion.
        </p>
        <pre class="calibre26" id="c25-code-0019"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void graph_node&lt;T&gt;::remove_node_index(std::size_t node_index)</code>
<code class="calibre21">{</code>
<span aria-label="921" class="calibre20" epub:type="pagebreak" id="Page_921" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// First, remove references to the to-be-deleted node.</span></code>
<code class="calibre21">    m_adjacentNodeIndices.erase(node_index);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Second, modify all adjacency indices to account for the removal of a node.</span></code>
<code class="calibre21">    <span class="color">// std::set doesn't let us modify its elements in place,</span></code>
<code class="calibre21">    <span class="color">// so we rebuild the set from scratch.</span></code>
<code class="calibre21">    std::vector&lt;std::size_t&gt; indices(std::begin(m_adjacentNodeIndices),</code>
<code class="calibre21">        std::end(m_adjacentNodeIndices));</code>
<code class="calibre21">    std::for_each(std::begin(indices), std::end(indices),</code>
<code class="calibre21">        [node_index](std::size_t&amp; index) {</code>
<code class="calibre21">            if (index &gt; node_index) { --index; }</code>
<code class="calibre21">        });</code>
<code class="calibre21">    m_adjacentNodeIndices.clear();</code>
<code class="calibre21">    m_adjacentNodeIndices.insert(std::begin(indices), std::end(indices));</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         Next, a
         <code class="calibre21">
          remove_all_links_to()
         </code>
         helper member function is added to
         <code class="calibre21">
          directed_graph
         </code>
         . This member function updates remaining adjacent node indices in all nodes to account for the removal of a node from the graph. First, it calculates
         <code class="calibre21">
          node_index
         </code>
         , the index of the given node in the
         <code class="calibre21">
          vector
         </code>
         of nodes. Then, it iterates over all nodes and removes
         <code class="calibre21">
          node_index
         </code>
         from the adjacency list of each node.
        </p>
        <pre class="calibre26" id="c25-code-0020"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::remove_all_links_to(</code>
<code class="calibre21">    typename node_container_type::const_iterator node_iter)</code>
<code class="calibre21">{</code>
<code class="calibre21">    const std::size_t node_index { get_index_of_node(node_iter) };</code>
<code class="calibre21">    for (auto&amp;&amp; node : m_nodes) { node.remove_node_index(node_index); }</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         With this helper member function, the implementation of the actual
         <code class="calibre21">
          erase()
         </code>
         member function becomes easy:
        </p>
        <pre class="calibre26" id="c25-code-0021"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">bool directed_graph&lt;T&gt;::erase(const T&amp; node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto iter { find_node(node_value) };</code>
<code class="calibre21">    if (iter == std::end(m_nodes)) {</code>
<code class="calibre21"> return false;</code>
<code class="calibre21"> }</code>
<code class="calibre21">    remove_all_links_to(iter);</code>
<code class="calibre21">    m_nodes.erase(iter);</code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0021">
        </span>
        <h5 class="calibre35" id="head-5-145">
         Deleting Edges
        </h5>
        <p class="calibre13">
         The procedure to remove edges is quite similar to adding them. If either the from or to node is not found, nothing is done; otherwise, the index of the node with value
         <code class="calibre21">
          to_node_value
         </code>
         is removed from the adjacency list of the node with value
         <code class="calibre21">
          from_node_value
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0022"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">bool directed_graph&lt;T&gt;::erase_edge(const T&amp; from_node_value,</code>
<code class="calibre21">    const T&amp; to_node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    const auto from { find_node(from_node_value) };</code>
<span aria-label="922" class="calibre20" epub:type="pagebreak" id="Page_922" role="doc-pagebreak"></span><code class="calibre21">    const auto to { find_node(to_node_value) };</code>
<code class="calibre21">    if (from == std::end(m_nodes) || to == std::end(m_nodes)) {</code>
<code class="calibre21">        return false; // nothing to erase</code>
<code class="calibre21">    }</code>
<code class="calibre21">    const std::size_t to_index { get_index_of_node(to) };</code>
<code class="calibre21">    from-&gt;get_adjacent_nodes_indices().erase(to_index);</code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0022">
        </span>
        <h5 class="calibre35" id="head-5-146">
         Removing All Elements
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          clear()
         </code>
         simply clears the entire graph:
        </p>
        <pre class="calibre26" id="c25-code-0023"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::clear() noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_nodes.clear();</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0023">
        </span>
        <h5 class="calibre35" id="head-5-147">
         Swapping Graphs
        </h5>
        <p class="calibre13">
         Since
         <code class="calibre21">
          directed_graph
         </code>
         has only one data member, a
         <code class="calibre21">
          vector
         </code>
         container, swapping two
         <code class="calibre21">
          directed_graph
         </code>
         s just means swapping their single data member:
        </p>
        <pre class="calibre26" id="c25-code-0024"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::swap(directed_graph&amp; other_graph) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_nodes.swap(other_graph.m_nodes);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The following stand-alone exported
         <code class="calibre21">
          swap()
         </code>
         function is also provided, which simply forwards to the
         <code class="calibre21">
          public swap()
         </code>
         member function:
        </p>
        <pre class="calibre26" id="c25-code-0025"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">void swap(directed_graph&lt;T&gt;&amp; first, directed_graph&lt;T&gt;&amp; second) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    first.swap(second);</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0024">
        </span>
        <h5 class="calibre35" id="head-5-148">
         Accessing Nodes
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          public
         </code>
         interface of
         <code class="calibre21">
          directed_graph
         </code>
         supports accessing nodes based on their index with
         <code class="calibre21">
          operator[]
         </code>
         . Its implementation is straightforward. Just as with
         <code class="calibre21">
          vector
         </code>
         , the operator does not perform any bounds checking on the requested index:
        </p>
        <pre class="calibre26" id="c25-code-0026"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">const T&amp; directed_graph&lt;T&gt;::operator[](std::size_t index) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodes[index].value();</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0025">
        </span>
        <h5 class="calibre35" id="head-5-149">
         Comparing Graphs
        </h5>
        <p class="calibre13" id="c25-para-0062">
         Two
         <code class="calibre21">
          directed_graph
         </code>
         s are equal if and only if they contain the same set of nodes and the same set of edges between all the nodes. A slight complication arises from the fact that the two
         <code class="calibre21">
          directed_graph
         </code>
         s
         <span aria-label="923" class="calibre20" epub:type="pagebreak" id="Page_923" role="doc-pagebreak">
         </span>
         could have been created by adding nodes to them in different order; as such, the implementation cannot just compare the
         <code class="calibre21">
          m_nodes
         </code>
         data member but instead needs to do a bit more work.
        </p>
        <p class="calibre13">
         The code first checks the size of both
         <code class="calibre21">
          directed_graph
         </code>
         s. If the size is different, both graphs cannot be the same. If they have the same size, the code iterates over all the nodes of one of the graphs. For each node, it tries to find the same node in the other graph. If it doesn't find such a node, the graphs are not equal. If it does find such a node, the adjacent node indices are converted to adjacent node values using a
         <code class="calibre21">
          get_adjacent_nodes_values()
         </code>
         helper member function, and those values are then compared for equality.
        </p>
        <pre class="calibre26" id="c25-code-0027"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">bool directed_graph&lt;T&gt;::operator==(const directed_graph&amp; rhs) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (m_nodes.size() != rhs.m_nodes.size()) { return false; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    for (auto&amp;&amp; node : m_nodes) {</code>
<code class="calibre21">        const auto rhsNodeIter {   rhs.find_node(node.value()) };</code>
<code class="calibre21">        if (rhsNodeIter == std::end(rhs.m_nodes)) { return false; }</code>
<code class="calibre21"> </code>
<code class="calibre21">        const auto adjacent_values_lhs { get_adjacent_nodes_values(</code>
<code class="calibre21">            node.get_adjacent_nodes_indices()) };</code>
<code class="calibre21">        const auto adjacent_values_rhs { rhs.get_adjacent_nodes_values(</code>
<code class="calibre21">            rhsNodeIter-&gt;get_adjacent_nodes_indices()) };</code>
<code class="calibre21">        if (adjacent_values_lhs != adjacent_values_rhs) { return false; }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return true;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::set&lt;T&gt; directed_graph&lt;T&gt;::get_adjacent_nodes_values(</code>
<code class="calibre21">    const typename details::graph_node&lt;T&gt;::adjacency_list_type&amp; indices) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::set&lt;T&gt; values;</code>
<code class="calibre21">    for (auto&amp;&amp; index : indices) { values.insert(m_nodes[index].value()); }</code>
<code class="calibre21">    return values;</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0026">
        </span>
        <h5 class="calibre35" id="head-5-150">
         Getting Adjacent Nodes
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          public
         </code>
         interface provides a
         <code class="calibre21">
          get_adjacent_nodes_values()
         </code>
         member function accepting a
         <code class="calibre21">
          node_value
         </code>
         of type reference-to-
         <code class="calibre21">
          const T
         </code>
         as parameter. It returns a
         <code class="calibre21">
          set
         </code>
         containing the values of the nodes adjacent to the given node. If the given node does not exist, an empty
         <code class="calibre21">
          set
         </code>
         is returned. The implementation uses the
         <code class="calibre21">
          get_adjacent_nodes_values()
         </code>
         overload accepting a list of indices as implemented in the previous section:
        </p>
        <pre class="calibre26" id="c25-code-0028"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::set&lt;T&gt; directed_graph&lt;T&gt;::get_adjacent_nodes_values(const T&amp; node_value) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto iter { find_node(node_value) };</code>
<code class="calibre21">    if (iter == std::end(m_nodes)) { return {}; }</code>
<code class="calibre21">    return get_adjacent_nodes_values(iter-&gt;get_adjacent_nodes_indices());</code>
<code class="calibre21">}</code></pre>
       </section>
       <span aria-label="924" class="calibre20" epub:type="pagebreak" id="Page_924" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0027">
        </span>
        <h5 class="calibre35" id="head-5-151">
         Querying the Graph Size
        </h5>
        <p class="calibre13">
         Finally, the
         <code class="calibre21">
          size()
         </code>
         member function returns the number of nodes in the graph:
        </p>
        <pre class="calibre26" id="c25-code-0029"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::size_t directed_graph&lt;T&gt;::size() const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodes.size();</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0028">
        </span>
        <h5 class="calibre35" id="head-5-152">
         Printing Graphs
        </h5>
        <p class="calibre13">
         Graphs can be printed in a standard format called
         <i class="calibre18">
          DOT
         </i>
         , a
         <i class="calibre18">
          graph description language
         </i>
         . There are tools available that understand DOT-formatted graphs and that can convert them into graphical representations. To make it easier to test the
         <code class="calibre21">
          directed_graph
         </code>
         code, the following
         <code class="calibre21">
          to_dot()
         </code>
         conversion function can be used. An example of its use is given in the next section.
        </p>
        <pre class="calibre26" id="c25-code-0030"><code class="calibre21"><span class="color">// Returns a given graph in DOT format.</span></code>
<code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">std::string to_dot(const directed_graph&lt;T&gt;&amp; graph, std::string_view graph_name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::ostringstream output;</code>
<code class="calibre21">    std::println(output, "digraph {} {{", graph_name);</code>
<code class="calibre21">    for (std::size_t index { 0 }; index &lt; graph.size(); ++index) {</code>
<code class="calibre21">        const auto&amp; node_value { graph[index] };</code>
<code class="calibre21">        const auto adjacent_values { graph.get_adjacent_nodes_values(node_value) };</code>
<code class="calibre21">        if (adjacent_values.empty()) {</code>
<code class="calibre21">            std::println(output, "{}", node_value);</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            for (auto&amp;&amp; neighbor : adjacent_values) {</code>
<code class="calibre21">                std::println(output, "{} -&gt; {}", node_value, neighbor);</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    std::println(output, "}}");</code>
<code class="calibre21">    return std::move(output).str();</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0029">
        </span>
        <h5 class="calibre35" id="head-5-153">
         Using the Basic Directed Graph
        </h5>
        <p class="calibre13">
         We have now completed the full implementation of a basic directed graph class. It's high time to give this class a test drive. Here is a small program demonstrating the basic
         <code class="calibre21">
          directed_graph
         </code>
         class template:
        </p>
        <pre class="calibre26" id="c25-code-0031"><code class="calibre21">directed_graph&lt;int&gt; graph;</code>
<code class="calibre21"><span class="color">// Insert some nodes and edges.</span></code>
<code class="calibre21">graph.insert(11);</code>
<code class="calibre21">graph.insert(22);</code>
<code class="calibre21">graph.insert(33);</code>
<code class="calibre21">graph.insert(44);</code>
<code class="calibre21">graph.insert(55);</code>
<code class="calibre21">graph.insert_edge(11, 33);</code>
<code class="calibre21">graph.insert_edge(22, 33);</code>
<code class="calibre21">graph.insert_edge(22, 44);</code>
<code class="calibre21">graph.insert_edge(22, 55);</code>
<span aria-label="925" class="calibre20" epub:type="pagebreak" id="Page_925" role="doc-pagebreak"></span><code class="calibre21">graph.insert_edge(33, 44);</code>
<code class="calibre21">graph.insert_edge(44, 55);</code>
<code class="calibre21">println("{}", to_dot(graph, "Graph1"));</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Remove an edge and a node.</span></code>
<code class="calibre21">graph.erase_edge(22, 44);</code>
<code class="calibre21">graph.erase(44);</code>
<code class="calibre21">println("{}", to_dot(graph, "Graph1"));</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Print the size of the graph.</span></code>
<code class="calibre21">println("Size: {}", graph.size());</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c25-code-0032"><code class="calibre21">digraph Graph1 {</code>
<code class="calibre21">11 -&gt; 33</code>
<code class="calibre21">22 -&gt; 33</code>
<code class="calibre21">22 -&gt; 44</code>
<code class="calibre21">22 -&gt; 55</code>
<code class="calibre21">33 -&gt; 44</code>
<code class="calibre21">44 -&gt; 55</code>
<code class="calibre21">55</code>
<code class="calibre21">}</code>
<code class="calibre21">digraph Graph1 {</code>
<code class="calibre21">11 -&gt; 33</code>
<code class="calibre21">22 -&gt; 33</code>
<code class="calibre21">22 -&gt; 55</code>
<code class="calibre21">33</code>
<code class="calibre21">55</code>
<code class="calibre21">}</code>
<code class="calibre21">Size: 4</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-365">
        Making directed_graph a Standard Library Container
       </h4>
       <p class="calibre13" id="c25-para-0069">
        The basic
        <code class="calibre21">
         directed_graph
        </code>
        implemented in the previous sections follows the spirit, but not the letter, of the Standard Library. For most purposes, the preceding implementation is good enough. However, if you want to use the Standard Library algorithms on your
        <code class="calibre21">
         directed_graph
        </code>
        , you must do a bit more work. The C++ standard specifies member functions and type aliases that a class template must provide to qualify as a Standard Library container.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0031">
        </span>
        <h5 class="calibre35" id="head-5-154">
         Required Type Aliases
        </h5>
        <p class="calibre13" id="c25-para-0070">
         The C++ standard requires that every Standard Library container provide the following
         <code class="calibre21">
          public
         </code>
         type aliases:
        </p>
        <table border="1" class="calibre31">
         <thead class="calibre32">
          <tr class="calibre33">
           <th class="left" scope="col">
            TYPE NAME
           </th>
           <th class="left" scope="col">
            DESCRIPTION
           </th>
          </tr>
         </thead>
         <tbody class="calibre34">
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             value_type
            </span>
           </td>
           <td class="bgcolor">
            The element type stored in the container
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             reference
            </span>
           </td>
           <td class="bgcolor">
            A reference to the element type stored in the container
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             const_reference
            </span>
           </td>
           <td class="bgcolor">
            A reference-to-
            <span class="calibre21">
             const
            </span>
            to the element type stored in the container
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             iterator
            </span>
           </td>
           <td class="bgcolor">
            The type for iterating over elements of the container
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             const_iterator
            </span>
           </td>
           <td class="bgcolor">
            A version of
            <span class="calibre21">
             iterator
            </span>
            for iterating over
            <code class="calibre21">
             const
            </code>
            elements of the container
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             size_type
            </span>
           </td>
           <td class="bgcolor">
            A type that can represent the number of elements in the container; this is usually just
            <span class="calibre21">
             size_t
            </span>
            (from
            <code class="calibre21">
             &lt;cstddef&gt;
            </code>
            )
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             difference:type
            </span>
           </td>
           <td class="bgcolor">
            A type that can represent the difference of two
            <span class="calibre21">
             iterator
            </span>
            s for the container; this is usually just
            <code class="calibre21">
             ptrdiff_t
            </code>
            (from
            <code class="calibre21">
             &lt;cstddef&gt;
            </code>
            )
            <span aria-label="926" class="calibre20" epub:type="pagebreak" id="Page_926" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
        <p class="calibre13">
         Here are the definitions for the
         <code class="calibre21">
          directed_graph
         </code>
         class template of all these type aliases except
         <code class="calibre21">
          iterator
         </code>
         and
         <code class="calibre21">
          const_iterator
         </code>
         . Writing iterators is covered in detail later in this chapter.
        </p>
        <pre class="calibre26" id="c25-code-0033"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">using value_type = T;</b></code>
<code class="calibre21">        <b class="calibre14">using reference = value_type&amp;;</b></code>
<code class="calibre21">        <b class="calibre14">using const_reference = const value_type&amp;;</b></code>
<code class="calibre21">        <b class="calibre14">using size_type = std::size_t;</b></code>
<code class="calibre21">        <b class="calibre14">using difference:type = std::ptrdiff_t;</b></code>
<code class="calibre21">        <span class="color">// Remainder of class definition omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         With these type aliases, some member functions can be slightly modified. For example, here is the earlier definition for
         <code class="calibre21">
          operator[]
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0034"><code class="calibre21">const T&amp; operator[](std::size_t index) const;</code></pre>
        <p class="calibre13">
         With the new type aliases, this can be written as follows:
        </p>
        <pre class="calibre26" id="c25-code-0035"><code class="calibre21">const_reference operator[](size_type index) const;</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0032">
        </span>
        <h5 class="calibre35" id="head-5-155">
         Required Member Functions
        </h5>
        <p class="calibre13" id="c25-para-0076">
         In addition to the obligatory type aliases, every container must provide the following member functions:
        </p>
        <table border="1" class="calibre31">
         <thead class="calibre32">
          <tr class="calibre33">
           <th class="left" scope="col">
            MEMBER FUNCTION
           </th>
           <th class="left" scope="col">
            DESCRIPTION
           </th>
           <th class="left" scope="col">
            WORST-CASE COMPLEXITY
           </th>
          </tr>
         </thead>
         <tbody class="calibre34">
          <tr class="calibre33">
           <td class="bgcolor">
            Default constructor
           </td>
           <td class="bgcolor">
            Constructs an empty container
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            Copy constructor
           </td>
           <td class="bgcolor">
            Performs a deep copy of the container
           </td>
           <td class="bgcolor">
            Linear
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            Move constructor
           </td>
           <td class="bgcolor">
            Performs a move constructing operation
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            Copy assignment operator
           </td>
           <td class="bgcolor">
            Performs a deep copy of the container
           </td>
           <td class="bgcolor">
            Linear
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            Move assignment operator
           </td>
           <td class="bgcolor">
            Performs a move assignment operation
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            Destructor
           </td>
           <td class="bgcolor">
            Destroys any elements left in the container and frees their heap-allocated memory, if any
           </td>
           <td class="bgcolor">
            Linear
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0036"><code class="calibre21">iterator begin();</code>
<code class="calibre21">const_iterator</code>
<code class="calibre21"> begin() const;</code></pre>
           </td>
           <td class="bgcolor">
            Returns an iterator or
            <span class="calibre21">
             const
            </span>
            iterator referring to the first element in the container
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0037"><code class="calibre21">iterator end();</code>
<code class="calibre21">const_iterator</code>
<code class="calibre21"> end() const;</code></pre>
           </td>
           <td class="bgcolor">
            Returns an iterator or
            <span class="calibre21">
             const
            </span>
            iterator referring to one-past-the-last element in the container
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0038"><code class="calibre21">const_iterator</code>
<code class="calibre21"> cbegin() const;</code></pre>
           </td>
           <td class="bgcolor">
            Same as
            <span class="calibre21">
             begin() const
            </span>
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0039"><code class="calibre21">const_iterator</code>
<code class="calibre21"> cend() const;</code></pre>
           </td>
           <td class="bgcolor">
            Same as
            <span class="calibre21">
             end() const
            </span>
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0040"><code class="calibre21">operator==</code></pre>
           </td>
           <td class="bgcolor">
            Comparison operator that compares two containers
           </td>
           <td class="bgcolor">
            Linear
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0041"><code class="calibre21">void swap(Container&amp;)</code>
<code class="calibre21"> noexcept;</code></pre>
           </td>
           <td class="bgcolor">
            Swaps the contents of the container passed to the member function with the object on which the member function is called
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0042"><code class="calibre21">size_type size() const;</code></pre>
           </td>
           <td class="bgcolor">
            Returns the number of elements in the container
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0043"><code class="calibre21">size_type max_size() const;</code></pre>
           </td>
           <td class="bgcolor">
            Returns the maximum number of elements the container can hold
           </td>
           <td class="bgcolor">
            Constant
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <pre class="pre" id="c25-code-0044"><code class="calibre21">bool empty() const;</code></pre>
           </td>
           <td class="bgcolor">
            Returns whether the container has any elements
           </td>
           <td class="bgcolor">
            Constant
            <span aria-label="927" class="calibre20" epub:type="pagebreak" id="Page_927" role="doc-pagebreak">
            </span>
           </td>
          </tr>
         </tbody>
        </table>
        <p class="calibre13" id="c25-para-0088">
         As discussed earlier, the
         <code class="calibre21">
          directed_graph
         </code>
         implementation follows the rule of zero (see
         <a class="calibre5" href="c09.xhtml">
          Chapter 9
         </a>
         ); that is, it does not need an explicit copy/move constructor, copy/move assignment operator, or destructor.
        </p>
        <p class="calibre13">
         The following code snippet shows the declarations of the
         <code class="calibre21">
          size()
         </code>
         ,
         <code class="calibre21">
          max_size()
         </code>
         , and
         <code class="calibre21">
          empty()
         </code>
         member functions. The iterator-related member functions,
         <code class="calibre21">
          begin()
         </code>
         ,
         <code class="calibre21">
          end()
         </code>
         ,
         <code class="calibre21">
          cbegin()
         </code>
         , and
         <code class="calibre21">
          cend()
         </code>
         , are covered in the next section on writing iterators.
        </p>
        <pre class="calibre26" id="c25-code-0045"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">[[nodiscard]] size_type size() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">[[nodiscard]] size_type max_size() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">[[nodiscard]] bool empty() const noexcept;</b></code>
<code class="calibre21">        <span class="color">// Other member functions omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         <span aria-label="928" class="calibre20" epub:type="pagebreak" id="Page_928" role="doc-pagebreak">
         </span>
         The implementations of these three member functions are easy because they can simply forward to the similarly named member functions of the
         <code class="calibre21">
          m_nodes
         </code>
         container. Note that
         <code class="calibre21">
          size_type
         </code>
         is one of the type aliases defined in the class template. Because it is a member of the class template, such a return type in the implementation must be fully qualified with
         <code class="calibre21">
          typename directed_graph&lt;T&gt;
         </code>
         .
        </p>
        <pre class="calibre26" id="c25-code-0046"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::size_type directed_graph&lt;T&gt;::size() const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodes.size();</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::size_type directed_graph&lt;T&gt;::max_size() const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodes.max_size();</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">bool directed_graph&lt;T&gt;::empty() const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodes.empty();</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The current implementation of
         <code class="calibre21">
          directed_graph
         </code>
         has
         <code class="calibre21">
          operator[]
         </code>
         to get access to a node based on its index. This operator, just as with
         <code class="calibre21">
          operator[]
         </code>
         for
         <code class="calibre21">
          vector
         </code>
         , does not perform any bounds checking. Passing an out-of-bounds index could make your application crash. As for
         <code class="calibre21">
          vector
         </code>
         ,
         <code class="calibre21">
          directed_graph
         </code>
         can be augmented with an
         <code class="calibre21">
          at()
         </code>
         member function that does bounds checking and that throws an
         <code class="calibre21">
          std::out_of_range
         </code>
         exception if the passed index is out of bounds. Here is the definition:
        </p>
        <pre class="calibre26" id="c25-code-0047"><code class="calibre21">const_reference at(size_type index) const;</code></pre>
        <p class="calibre13">
         The implementation just forwards to the
         <code class="calibre21">
          m_nodes vector
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0048"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_reference</code>
<code class="calibre21">    directed_graph&lt;T&gt;::at(size_type index) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodes.at(index).value();</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0033">
        </span>
        <h5 class="calibre35" id="head-5-156">
         Writing an Iterator
        </h5>
        <p class="calibre13" id="c25-para-0093">
         The most important container requirement is iterator support. To work with the generic algorithms, every container must provide an iterator type for accessing the elements in the container. Your iterator should generally provide overloaded
         <code class="calibre21">
          operator++
         </code>
         ,
         <code class="calibre21">
          *
         </code>
         ,
         <code class="calibre21">
          -&gt;
         </code>
         , and
         <code class="calibre21">
          ==
         </code>
         , plus some other operations depending on its specific behavior. As long as your iterator provides the basic iteration operations, everything should be fine.
        </p>
        <p class="calibre13" id="c25-para-0094">
         The first decision to make about your iterator is what kind it will be: forward, bidirectional, random access, or contiguous. Bidirectional iterator support seems like a good choice for a
         <code class="calibre21">
          directed_graph
         </code>
         iterator. That means you must additionally provide
         <code class="calibre21">
          operator--
         </code>
         . Another option would be to implement random-access iterators for
         <code class="calibre21">
          directed_graph
         </code>
         , which involves adding the operators
         <code class="calibre21">
          +
         </code>
         ,
         <code class="calibre21">
          -
         </code>
         ,
         <code class="calibre21">
          +=
         </code>
         ,
         <code class="calibre21">
          -=
         </code>
         ,
         <code class="calibre21">
          &lt;
         </code>
         ,
         <code class="calibre21">
          &gt;
         </code>
         ,
         <code class="calibre21">
          &lt;=
         </code>
         ,
         <code class="calibre21">
          &gt;=
         </code>
         , and
         <code class="calibre21">
          []
         </code>
         . This could be a good exercise to practice writing iterators. Consult
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         for more details on the requirements for random-access iterators.
        </p>
        <p class="calibre13" id="c25-para-0095">
         <span aria-label="929" class="calibre20" epub:type="pagebreak" id="Page_929" role="doc-pagebreak">
         </span>
         The second decision is how to order the elements of your container. The
         <code class="calibre21">
          directed_graph
         </code>
         is unsorted, so iterating in a sorted order would not be efficient. The important thing about a Standard Library-compliant container is that iterating over its elements from
         <code class="calibre21">
          begin()
         </code>
         to
         <code class="calibre21">
          end()
         </code>
         will hit every element once; just because it is
         <b class="calibre14">
          <i class="calibre18">
           a
          </i>
         </b>
         sequence, doesn't mean that it is a
         <b class="calibre14">
          <i class="calibre18">
           specific
          </i>
         </b>
         sequence. Thus, the
         <code class="calibre21">
          directed_graph
         </code>
         iterator can just step through the nodes in the order in which they were added to the graph. This is the same as how iteration for
         <code class="calibre21">
          std::unordered_set
         </code>
         works.
        </p>
        <p class="calibre13" id="c25-para-0096">
         The third decision is how to represent your iterator internally. The representation is usually quite dependent on the internal implementation of the container. The first purpose of an iterator is to refer to a single element in the container. In the case of a
         <code class="calibre21">
          directed_graph
         </code>
         , all nodes are stored in the
         <code class="calibre21">
          m_nodes
         </code>
         vector, so perhaps a
         <code class="calibre21">
          directed_graph
         </code>
         iterator can be a wrapper around a
         <code class="calibre21">
          vector
         </code>
         iterator referring to the element in question.
        </p>
        <p class="calibre13" id="c25-para-0097">
         Once you've chosen your implementation, you must decide on a consistent representation for the end iterator. Recall that the end iterator should really be the “past-the-end” marker: the iterator that's reached by applying
         <code class="calibre21">
          ++
         </code>
         to an iterator referring to the final element in the container. A
         <code class="calibre21">
          directed_graph
         </code>
         iterator can use as its end iterator the end iterator of the
         <code class="calibre21">
          m_nodes vector
         </code>
         .
        </p>
        <p class="calibre13" id="c25-para-0098">
         Finally, a container needs to provide both
         <code class="calibre21">
          iterator
         </code>
         and
         <code class="calibre21">
          const_iterator
         </code>
         type aliases. This implementation defines both these type aliases in terms of a
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         class template. The reason is that values cannot be changed once in the graph. This follows the same principle as
         <code class="calibre21">
          std::set
         </code>
         .
        </p>
        <p class="calibre13" id="c25-para-0099">
         If you do need separate
         <code class="calibre21">
          iterator
         </code>
         and
         <code class="calibre21">
          const_iterator
         </code>
         types for your own data structure, keep in mind that an
         <code class="calibre21">
          iterator
         </code>
         must be convertible to a
         <code class="calibre21">
          const_iterator
         </code>
         .
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0034">
        </span>
        <h5 class="calibre35" id="head-5-157">
         The const_directed_graph_iterator_impl Class Template
        </h5>
        <p class="calibre13" id="c25-para-0100">
         Given the decisions made in the previous section, it's time to define the
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         class template. The first thing to note is that each
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         object is an iterator for a specific instantiation of
         <code class="calibre21">
          directed_graph
         </code>
         . To provide this one-to-one mapping, the
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         must also be a class template with the directed graph type as a template type parameter called
         <code class="calibre21">
          DirectedGraph
         </code>
         .
        </p>
        <p class="calibre13">
         The main question is how to conform to the bidirectional iterator requirements. Recall that anything that behaves like an iterator is an iterator. Your iterator is not required to derive from another class to qualify as a bidirectional iterator. However, if you want your iterator to be usable by the generic algorithms, you must specify its traits.
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         explains that
         <code class="calibre21">
          iterator_traits
         </code>
         is a class template that defines, for each iterator type, five type aliases:
         <code class="calibre21">
          value_type
         </code>
         ,
         <code class="calibre21">
          difference:type
         </code>
         ,
         <code class="calibre21">
          iterator_category
         </code>
         ,
         <code class="calibre21">
          pointer
         </code>
         , and
         <code class="calibre21">
          reference
         </code>
         . The default implementation of the
         <code class="calibre21">
          iterator_traits
         </code>
         class template just grabs the five type aliases out of the iterator itself. Thus, you can simply define those type aliases directly for your iterator. The
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         is a bidirectional iterator, so you specify
         <code class="calibre21">
          bidirectional_iterator_tag
         </code>
         as the iterator category. Other legal iterator categories are
         <code class="calibre21">
          input_iterator_tag
         </code>
         ,
         <code class="calibre21">
          output_iterator_tag
         </code>
         ,
         <code class="calibre21">
          forward_iterator_tag
         </code>
         ,
         <code class="calibre21">
          random_access_iterator_tag
         </code>
         , and
         <code class="calibre21">
          contiguous_iterator_tag
         </code>
         . A contiguous iterator is a random-access iterator for which adjacent elements are also adjacent in memory. For the
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         , the element type (
         <code class="calibre21">
          value_type
         </code>
         ) is
         <code class="calibre21">
          typename DirectedGraph::value_type
         </code>
         .
         <span aria-label="930" class="calibre20" epub:type="pagebreak" id="Page_930" role="doc-pagebreak">
         </span>
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c25-para-0102">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             In the past, it was recommended to derive custom iterators from the
            </i>
            <code class="calibre21">
             std::iterator
            </code>
            <i class="calibre18">
             class template, defined in
            </i>
            <code class="calibre21">
             &lt;iterator&gt;
            </code>
            <i class="calibre18">
             . This class template has been deprecated and should not be used anymore.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         Here is the
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         class template definition:
        </p>
        <pre class="calibre26" id="c25-code-0049"><code class="calibre21">template &lt;typename DirectedGraph&gt;</code>
<code class="calibre21">class const_directed_graph_iterator_impl</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        using value_type = typename DirectedGraph::value_type;</code>
<code class="calibre21">        using difference:type = std::ptrdiff_t;</code>
<code class="calibre21">        using iterator_category = std::bidirectional_iterator_tag;</code>
<code class="calibre21">        using pointer = const value_type*;</code>
<code class="calibre21">        using reference = const value_type&amp;;</code>
<code class="calibre21">        using node_container_iterator =</code>
<code class="calibre21">            typename DirectedGraph::node_container_type::const_iterator;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Bidirectional iterators must supply a default constructor.</span></code>
<code class="calibre21">        const_directed_graph_iterator_impl() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        explicit const_directed_graph_iterator_impl(node_container_iterator it);</code>
<code class="calibre21"> </code>
<code class="calibre21">        reference operator*() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Return type must be something to which -&gt; can be applied.</span></code>
<code class="calibre21">        <span class="color">// So, return a pointer.</span></code>
<code class="calibre21">        pointer operator-&gt;() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        const_directed_graph_iterator_impl&amp; operator++();</code>
<code class="calibre21">        const_directed_graph_iterator_impl operator++(int);</code>
<code class="calibre21"> </code>
<code class="calibre21">        const_directed_graph_iterator_impl&amp; operator--();</code>
<code class="calibre21">        const_directed_graph_iterator_impl operator--(int);</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Defaulted operator==.</span></code>
<code class="calibre21">        bool operator==(const const_directed_graph_iterator_impl&amp;) const = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        friend class directed_graph&lt;value_type&gt;;</code>
<code class="calibre21"> </code>
<code class="calibre21">        node_container_iterator m_nodeIterator;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c25-para-0104">
         Consult
         <a class="calibre5" href="c15.xhtml">
          Chapter 15
         </a>
         for details on operator overloading if the definitions and implementations (shown in the next section) of the overloaded operators confuse you. The
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         implementation does not need copy/move constructors and copy/move assignment operators, as the default behavior is what we want. The class also does not need an explicit destructor, as there's nothing to clean up. Hence, this class also follows the rule of zero.
        </p>
       </section>
       <span aria-label="931" class="calibre20" epub:type="pagebreak" id="Page_931" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0036">
        </span>
        <h5 class="calibre35" id="head-5-158">
         The const_directed_graph_iterator_impl Member Function Implementations
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         constructor initializes the data member:
        </p>
        <pre class="calibre26" id="c25-code-0050"><code class="calibre21">template &lt;typename DirectedGraph&gt;</code>
<code class="calibre21">const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::</code>
<code class="calibre21">    const_directed_graph_iterator_impl(node_container_iterator it)</code>
<code class="calibre21">        : m_nodeIterator { it } { }</code></pre>
        <p class="calibre13" id="c25-para-0106">
         The default constructor is defaulted so that clients can declare
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         variables without initializing them. An iterator constructed with the default constructor does not need to refer to any value, and attempting any operations on it is allowed to have undefined results.
        </p>
        <p class="calibre13">
         The implementations of the dereferencing operators are concise but can look tricky.
         <a class="calibre5" href="c15.xhtml">
          Chapter 15
         </a>
         explains that
         <code class="calibre21">
          operator*
         </code>
         and
         <code class="calibre21">
          -&gt;
         </code>
         are asymmetric:
        </p>
        <ul class="check" id="c25-list-0003">
         <li class="calibre9" id="c25-li-0005">
          <code class="calibre21">
           operator*
          </code>
          returns a reference to the actual underlying value, which in this case is the element to which the iterator refers.
         </li>
         <li class="calibre9" id="c25-li-0006">
          <code class="calibre21">
           operator-&gt;
          </code>
          must return something to which the arrow operator can be applied again, and thus returns a pointer to the element. The compiler then applies
          <code class="calibre21">
           -&gt;
          </code>
          to the pointer, which results in accessing a field or member function of the element.
         </li>
        </ul>
        <pre class="calibre26" id="c25-code-0051"><code class="calibre21"><span class="color">// Return a reference to the actual element.</span></code>
<code class="calibre21">template &lt;typename DirectedGraph&gt;</code>
<code class="calibre21">typename const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::reference</code>
<code class="calibre21">    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator*() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_nodeIterator-&gt;value();</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Return a pointer to the actual element, so the compiler can</span></code>
<code class="calibre21"><span class="color">// apply -&gt; to it to access the actual desired field.</span></code>
<code class="calibre21">template &lt;typename DirectedGraph&gt;</code>
<code class="calibre21">typename const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::pointer</code>
<code class="calibre21">    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator-&gt;() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return &amp;m_nodeIterator-&gt;value();</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The increment operators are implemented as follows. The decrement operators are not shown as they are implemented analogously.
        </p>
        <pre class="calibre26" id="c25-code-0052"><code class="calibre21">template &lt;typename DirectedGraph&gt;</code>
<code class="calibre21">const_directed_graph_iterator_impl&lt;DirectedGraph&gt;&amp;</code>
<code class="calibre21">    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator++()</code>
<code class="calibre21">{</code>
<code class="calibre21">    ++m_nodeIterator;</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="932" class="calibre20" epub:type="pagebreak" id="Page_932" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename DirectedGraph&gt;</code>
<code class="calibre21">const_directed_graph_iterator_impl&lt;DirectedGraph&gt;</code>
<code class="calibre21">    const_directed_graph_iterator_impl&lt;DirectedGraph&gt;::operator++(int)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto oldIt { *this };</code>
<code class="calibre21">    ++*this;</code>
<code class="calibre21">    return oldIt;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c25-para-0109">
         Iterators are not required to be any safer than raw pointers, so error-checking for things like incrementing an iterator already at the end is not required.
        </p>
        <p class="calibre13">
         The
         <code class="calibre21">
          node_container_iterator
         </code>
         type alias of
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         uses the private
         <code class="calibre21">
          node_container_type
         </code>
         type alias of
         <code class="calibre21">
          directed_graph
         </code>
         . Thus, the
         <code class="calibre21">
          directed_graph
         </code>
         class template must declare
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         to be a
         <code class="calibre21">
          friend
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0053"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Other member functions omitted for brevity.</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">friend class const_directed_graph_iterator_impl&lt;directed_graph&gt;;</b></code>
<code class="calibre21">};</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0037">
        </span>
        <h5 class="calibre35" id="head-5-159">
         Iterator Type Aliases and Access Member Functions
        </h5>
        <p class="calibre13">
         The final piece involved in providing iterator support for
         <code class="calibre21">
          directed_graph
         </code>
         is to supply the necessary type aliases in the
         <code class="calibre21">
          directed_graph
         </code>
         class template, and to write the
         <code class="calibre21">
          begin()
         </code>
         ,
         <code class="calibre21">
          end()
         </code>
         ,
         <code class="calibre21">
          cbegin()
         </code>
         , and
         <code class="calibre21">
          cend()
         </code>
         member functions. The type aliases and member function prototypes look like this:
        </p>
        <pre class="calibre26" id="c25-code-0054"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Other type aliases omitted for brevity.</span></code>
<code class="calibre21">        <b class="calibre14">using iterator = const_directed_graph_iterator_impl&lt;directed_graph&gt;;</b></code>
<code class="calibre21">        <b class="calibre14">using const_iterator = const_directed_graph_iterator_impl&lt;directed_graph&gt;;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Iterator member functions.</span></code>
<code class="calibre21">        <b class="calibre14">iterator begin() noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">iterator end() noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_iterator begin() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_iterator end() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_iterator cbegin() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_iterator cend() const noexcept;</b></code>
<code class="calibre21">        <span class="color">// Remainder of class definition omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c25-para-0112">
         Both
         <code class="calibre21">
          iterator
         </code>
         and
         <code class="calibre21">
          const_iterator
         </code>
         are type aliases for
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         , which means users cannot modify the values to which
         <code class="calibre21">
          directed_graph
         </code>
         iterators refer. Node values in a
         <code class="calibre21">
          directed_graph
         </code>
         must be unique. Allowing the user to modify the value of a node through an iterator would allow the possibility of introducing duplicate values. This follows the same principle as
         <code class="calibre21">
          std::set
         </code>
         , in which you also cannot modify elements.
        </p>
        <p class="calibre13" id="c25-para-0113">
         As
         <code class="calibre21">
          iterator
         </code>
         and
         <code class="calibre21">
          const_iterator
         </code>
         are both type aliases for
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         , the non-
         <code class="calibre21">
          const begin()
         </code>
         and
         <code class="calibre21">
          end()
         </code>
         member functions returning
         <code class="calibre21">
          iterator
         </code>
         are not strictly
         <span aria-label="933" class="calibre20" epub:type="pagebreak" id="Page_933" role="doc-pagebreak">
         </span>
         necessary; the
         <code class="calibre21">
          const
         </code>
         overloads are enough. However, the Standard Library requirements state that a container must supply non-
         <code class="calibre21">
          const begin()
         </code>
         and
         <code class="calibre21">
          end()
         </code>
         overloads.
        </p>
        <p class="calibre13">
         The
         <code class="calibre21">
          directed_graph
         </code>
         class template stores all its nodes in a simple
         <code class="calibre21">
          vector
         </code>
         . As such,
         <code class="calibre21">
          begin()
         </code>
         and
         <code class="calibre21">
          end()
         </code>
         can simply forward their work to the identically named member functions on
         <code class="calibre21">
          vector
         </code>
         and wrap those results in a
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0055"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::begin() noexcept { return iterator{ std::begin(m_nodes) }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::end() noexcept { return iterator { std::end(m_nodes) }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::begin() const noexcept</code>
<code class="calibre21">{ return const_iterator { std::begin(m_nodes) }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::end() const noexcept</code>
<code class="calibre21">{ return const_iterator { std::end(m_nodes) }; }</code></pre>
        <p class="calibre13">
         The
         <code class="calibre21">
          cbegin()
         </code>
         and
         <code class="calibre21">
          cend()
         </code>
         member functions forward the request to the
         <code class="calibre21">
          const
         </code>
         overloads of
         <code class="calibre21">
          begin()
         </code>
         and
         <code class="calibre21">
          end()
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0056"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::cbegin() const noexcept { return begin(); }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::cend() const noexcept { return end(); }</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0038">
        </span>
        <h5 class="calibre35" id="head-5-160">
         Modifying Other Member Functions to Use Iterators
        </h5>
        <p class="calibre13">
         Now that
         <code class="calibre21">
          directed_graph
         </code>
         supports iterators, other member functions can be slightly modified to work with iterators so that they follow the Standard Library guidelines. Let's look at the
         <code class="calibre21">
          insert()
         </code>
         member function first. In the earlier basic implementation, it is defined as follows:
        </p>
        <pre class="calibre26" id="c25-code-0057"><code class="calibre21"><span class="color">// For an insert to be successful, the value shall not be in the graph yet.</span></code>
<code class="calibre21"><span class="color">// Returns true if a new node with given value has been added to</span></code>
<code class="calibre21"><span class="color">// the graph, and false if there was already a node with the given value.</span></code>
<code class="calibre21">bool insert(T node_value);</code></pre>
        <p class="calibre13">
         To follow more closely the spirit of the Standard Library, this can be modified to return an
         <code class="calibre21">
          std::pair&lt;iterator, bool&gt;
         </code>
         where the Boolean is
         <code class="calibre21">
          true
         </code>
         if the element was added to the graph, and
         <code class="calibre21">
          false
         </code>
         if the element was already in the graph. The iterator of the
         <code class="calibre21">
          pair
         </code>
         refers to the newly added element or the element that was already in the graph.
        </p>
        <pre class="calibre26" id="c25-code-0058"><code class="calibre21">std::pair&lt;iterator, bool&gt; insert(T node_value);</code></pre>
        <p class="calibre13">
         The implementation is as follows. The changes compared to the version returning a simple
         <code class="calibre21">
          bool
         </code>
         are highlighted.
        </p>
        <pre class="calibre26" id="c25-code-0059"><span aria-label="934" class="calibre20" epub:type="pagebreak" id="Page_934" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21"><b class="calibre14">std::pair&lt;typename directed_graph&lt;T&gt;::iterator, bool&gt;</b></code>
<code class="calibre21">    directed_graph&lt;T&gt;::insert(T node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto iter { find_node(node_value) };</code>
<code class="calibre21">    if (iter != std::end(m_nodes)) {</code>
<code class="calibre21">        <span class="color">// Value is already in the graph.</span></code>
<code class="calibre21">        <b class="calibre14">return { iterator { iter }, false };</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">    m_nodes.emplace:back(this, std::move(node_value));</code>
<code class="calibre21">    <span class="color">// Value successfully added to the graph.</span></code>
<code class="calibre21">    <b class="calibre14">return { iterator { std::prev(std::end(m_nodes)) }, true };</b></code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         Additionally, an overload of
         <code class="calibre21">
          insert()
         </code>
         is provided that accepts an iterator hint. This hint is useless for a
         <code class="calibre21">
          directed_graph
         </code>
         , but it is provided for symmetry with other Standard Library containers, such as
         <code class="calibre21">
          std::vector
         </code>
         . The hint is ignored, and it merely calls the overload of
         <code class="calibre21">
          insert()
         </code>
         without the hint.
        </p>
        <pre class="calibre26" id="c25-code-0060"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::insert(const_iterator hint, T node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Ignore the hint, just forward to another insert().</span></code>
<code class="calibre21">    return insert(std::move(node_value)).first;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         A last overload of
         <code class="calibre21">
          insert()
         </code>
         accepts an iterator range. This overload is a member function template so that it can take an iterator range from any container, not just other
         <code class="calibre21">
          directed_graph
         </code>
         s. The actual implementation uses an
         <code class="calibre21">
          insert_iterator
         </code>
         , described
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         .
        </p>
        <pre class="calibre26" id="c25-code-0061"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;std::input_iterator Iter&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::insert(Iter first, Iter last)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Copy each element in the range by using an insert_iterator adapter.</span></code>
<code class="calibre21">    <span class="color">// Give end() as a dummy position -- insert ignores it anyway.</span></code>
<code class="calibre21">    std::copy(first, last, std::insert_iterator { *this, end() });</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The
         <code class="calibre21">
          erase()
         </code>
         member functions should be modified to work with iterators. The earlier definition has a node value as parameter and returns a
         <code class="calibre21">
          bool
         </code>
         :
        </p>
        <pre class="calibre26" id="c25-code-0062"><code class="calibre21"><span class="color">// Returns true if the given node value was erased, false otherwise.</span></code>
<code class="calibre21">bool erase(const T&amp; node_value);</code></pre>
        <p class="calibre13">
         To follow Standard Library principles,
         <code class="calibre21">
          directed_graph
         </code>
         is modified to provide two
         <code class="calibre21">
          erase()
         </code>
         member functions: one erasing a node to which an iterator refers and another one erasing a range of nodes given as an iterator range. Both return an iterator to the node after the last deleted node:
        </p>
        <pre class="calibre26" id="c25-code-0063"><code class="calibre21"><span class="color">// Returns an iterator to the element after the last deleted element.</span></code>
<code class="calibre21">iterator erase(const_iterator pos);</code>
<code class="calibre21">iterator erase(const_iterator first, const_iterator last);</code></pre>
        <p class="calibre13">
         Here are the implementations:
        </p>
        <pre class="calibre26" id="c25-code-0064"><span aria-label="935" class="calibre20" epub:type="pagebreak" id="Page_935" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::erase(const_iterator pos)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (pos.m_nodeIterator == std::end(m_nodes)) {</code>
<code class="calibre21">        return end();</code>
<code class="calibre21">    }</code>
<code class="calibre21">    remove_all_links_to(pos.m_nodeIterator);</code>
<code class="calibre21">    return iterator { m_nodes.erase(pos.m_nodeIterator) };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::erase(const_iterator first, const_iterator last)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto iter { first }; iter != last; ++iter) {</code>
<code class="calibre21">        remove_all_links_to(iter.m_nodeIterator);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return iterator { m_nodes.erase(first.m_nodeIterator, last.m_nodeIterator) };</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         Finally, the following public
         <code class="calibre21">
          find()
         </code>
         member function can be implemented returning an iterator. The implementation is left as an exercise at the end of this chapter.
        </p>
        <pre class="calibre26" id="c25-code-0065"><code class="calibre21">const_iterator find(const T&amp; node_value) const;</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0039">
        </span>
        <h5 class="calibre35" id="head-5-161">
         Using the directed_graph Iterators
        </h5>
        <p class="calibre13">
         Now that
         <code class="calibre21">
          directed_graph
         </code>
         supports iterators, you can iterate over its elements just as you would with any other Standard Library container, and you can pass the iterators to member functions and functions. Here are some examples:
        </p>
        <pre class="calibre26" id="c25-code-0066"><code class="calibre21">directed_graph&lt;int&gt; graph;</code>
<code class="calibre21"><span class="color">// Populate the graph, omitted (see downloadable source code archive) …</span></code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Try to insert a duplicate, and use structured bindings for the result.</span></code>
<code class="calibre21">auto [iter22, inserted] { graph.insert(22) };</code>
<code class="calibre21">if (!inserted) { println("Duplicate element."); }</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Print nodes using a for loop and iterators.</span></code>
<code class="calibre21">for (auto iter { graph.cbegin() }; iter != graph.cend(); ++iter) {</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code>
<code class="calibre21">println("");</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Print nodes using a for loop and iterators retrieved with the non-member</span></code>
<code class="calibre21"><span class="color">// functions cbegin() and cend().</span></code>
<code class="calibre21">for (auto iter { cbegin(graph) }; iter != cend(graph); ++iter) {</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code>
<code class="calibre21">println("");</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Print nodes using a range-based for loop.</span></code>
<code class="calibre21">for (auto&amp; node : graph) { print("{} ", node); }</code>
<code class="calibre21">println("");</code>
<code class="calibre21"> </code>
<span aria-label="936" class="calibre20" epub:type="pagebreak" id="Page_936" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Search a node using the find() Standard Library algorithm.</span></code>
<code class="calibre21">auto result { find(begin(graph), end(graph), 22) };</code>
<code class="calibre21">if (result != end(graph)) {</code>
<code class="calibre21"> println("Node 22 found.");</code>
<code class="calibre21">} else {</code>
<code class="calibre21"> println("Node 22 NOT found.");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Count all nodes with values &gt; 22.</span></code>
<code class="calibre21">auto count { count_if(begin(graph), end(graph),</code>
<code class="calibre21">    [](const auto&amp; node) { return node &gt; 22; }) };</code>
<code class="calibre21">println("{} nodes &gt; 22", count);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Use the iterator-based erase() member function in combination with find().</span></code>
<code class="calibre21">graph.erase(find(begin(graph), end(graph), 44));</code></pre>
        <p class="calibre13">
         This code snippet also shows that, thanks to the support for iterators, Standard Library algorithms can be used with a
         <code class="calibre21">
          directed_graph
         </code>
         . However, since
         <code class="calibre21">
          directed_graph
         </code>
         supports only
         <code class="calibre21">
          const
         </code>
         iterators, only non-modifying Standard Library algorithms are supported, just as with
         <code class="calibre21">
          std::set
         </code>
         . For example, the following code snippet using the remove-erase idiom does not compile:
        </p>
        <pre class="calibre26" id="c25-code-0067"><code class="calibre21">graph.erase(remove_if(begin(graph), end(graph),</code>
<code class="calibre21">    [](const auto&amp; node) { return node &gt; 22; }), end(graph));</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0040">
        </span>
        <h5 class="calibre35" id="head-5-162">
         Adding Support for Reverse Iterators
        </h5>
        <p class="calibre13" id="c25-para-0127">
         If your container supplies bidirectional iterators, it is considered
         <i class="calibre18">
          reversible
         </i>
         . Reversible containers should have two additional type aliases:
        </p>
        <table border="1" class="calibre31">
         <thead class="calibre32">
          <tr class="calibre33">
           <th class="left" scope="col">
            TYPE NAME
           </th>
           <th class="left" scope="col">
            DESCRIPTION
           </th>
          </tr>
         </thead>
         <tbody class="calibre34">
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             reverse_iterator
            </span>
           </td>
           <td class="bgcolor">
            The type for iterating over elements of the container in reverse order
           </td>
          </tr>
          <tr class="calibre33">
           <td class="bgcolor">
            <span class="calibre21">
             const_reverse_iterator
            </span>
           </td>
           <td class="bgcolor">
            A version of
            <span class="calibre21">
             reverse_iterator
            </span>
            for iterating over
            <code class="calibre21">
             const
            </code>
            elements of the container in reverse order
           </td>
          </tr>
         </tbody>
        </table>
        <p class="calibre13" id="c25-para-0129">
         Additionally, the container should provide
         <code class="calibre21">
          rbegin()
         </code>
         and
         <code class="calibre21">
          rend()
         </code>
         , which are symmetric with
         <code class="calibre21">
          begin()
         </code>
         and
         <code class="calibre21">
          end()
         </code>
         ; and it should provide
         <code class="calibre21">
          crbegin()
         </code>
         and
         <code class="calibre21">
          crend()
         </code>
         , which are symmetric with
         <code class="calibre21">
          cbegin()
         </code>
         and
         <code class="calibre21">
          cend()
         </code>
         .
        </p>
        <p class="calibre13">
         The
         <code class="calibre21">
          directed_graph
         </code>
         iterators are bidirectional, which means they should support reverse iteration. The following code snippet highlights the necessary changes. The two new type aliases use the
         <code class="calibre21">
          std::reverse_iterator
         </code>
         adapter provided by the Standard Library and described in
         <a class="calibre5" href="c17.xhtml">
          Chapter 17
         </a>
         to convert the
         <code class="calibre21">
          directed_graph
         </code>
         iterators to behave as reverse iterators.
        </p>
        <pre class="calibre26" id="c25-code-0068"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Other type aliases omitted for brevity.</span></code>
<code class="calibre21">        <b class="calibre14">using reverse_iterator = std::reverse_iterator&lt;iterator&gt;;</b></code>
<code class="calibre21">        <b class="calibre14">using const_reverse_iterator = std::reverse_iterator&lt;const_iterator&gt;;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Reverse iterator member functions.</span></code>
<code class="calibre21">        <b class="calibre14">reverse_iterator rbegin() noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">reverse_iterator rend() noexcept;</b></code>
<span aria-label="937" class="calibre20" epub:type="pagebreak" id="Page_937" role="doc-pagebreak"></span><code class="calibre21">        <b class="calibre14">const_reverse_iterator rbegin() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_reverse_iterator rend() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_reverse_iterator crbegin() const noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">const_reverse_iterator crend() const noexcept;</b></code>
<code class="calibre21">        <span class="color">// Remainder of class definition omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         The implementations of the reverse iterator member functions are as follows.
        </p>
        <pre class="calibre26" id="c25-code-0069"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::reverse_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::rbegin() noexcept { return reverse_iterator { end() }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::reverse_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::rend() noexcept { return reverse_iterator { begin() }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::rbegin() const noexcept</code>
<code class="calibre21">{ return const_reverse_iterator { end() }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::rend() const noexcept</code>
<code class="calibre21">{ return const_reverse_iterator { begin() }; }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::crbegin() const noexcept { return rbegin(); }</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::const_reverse_iterator</code>
<code class="calibre21">    directed_graph&lt;T&gt;::crend() const noexcept { return rend(); }</code></pre>
        <p class="calibre13">
         The following code snippet shows how to print all the nodes of a graph in reverse order:
        </p>
        <pre class="calibre26" id="c25-code-0070"><code class="calibre21">for (auto iter { graph.rbegin() }; iter != graph.rend(); ++iter) {</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0041">
        </span>
        <h5 class="calibre35" id="head-5-163">
         Iterating over Adjacent Nodes
        </h5>
        <p class="calibre13" id="c25-para-0133">
         A
         <code class="calibre21">
          directed_graph
         </code>
         keeps a
         <code class="calibre21">
          vector
         </code>
         of nodes, where each node contains the node's value and a list of adjacent nodes. Let's improve the
         <code class="calibre21">
          directed_graph
         </code>
         interface to support iteration over the adjacent nodes of a given node without copying those nodes into another container as it is done in the earlier implementation of
         <code class="calibre21">
          get_adjacent_nodes_values()
         </code>
         . The first thing to add is a
         <code class="calibre21">
          const_adjacent_nodes_iterator_impl
         </code>
         class template following the same principles as
         <code class="calibre21">
          const_directed_graph_iterator_impl
         </code>
         so the code is not shown. Consult the downloadable source code archive to see the full code.
        </p>
        <p class="calibre13">
         The next step is to augment the
         <code class="calibre21">
          directed_graph
         </code>
         interface with a new type alias, a helper structure to represent adjacent nodes as a range, and a member function to get access to the adjacent nodes of a
         <span aria-label="938" class="calibre20" epub:type="pagebreak" id="Page_938" role="doc-pagebreak">
         </span>
         given node value. The
         <code class="calibre21">
          nodes_adjacent_to()
         </code>
         member function returns an empty
         <code class="calibre21">
          optional
         </code>
         when the given node value cannot be found.
        </p>
        <pre class="calibre26" id="c25-code-0071"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">class directed_graph</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Other type aliases omitted for brevity.</span></code>
<code class="calibre21">        <b class="calibre14">using const_adjacent_nodes_iterator =</b></code>
<code class="calibre21">            <b class="calibre14">const_adjacent_nodes_iterator_impl&lt;directed_graph&gt;;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Helper structure to represent a range of adjacent nodes.</span></code>
<code class="calibre21">        <b class="calibre14">struct nodes_adjacent_to_result</b></code>
<code class="calibre21">        <b class="calibre14">{</b></code>
<code class="calibre21">            <b class="calibre14">const_adjacent_nodes_iterator m_begin;</b></code>
<code class="calibre21">            <b class="calibre14">const_adjacent_nodes_iterator m_end;</b></code>
<code class="calibre21">            <b class="calibre14">const_adjacent_nodes_iterator begin() const noexcept{ return m_begin; }</b></code>
<code class="calibre21">            <b class="calibre14">const_adjacent_nodes_iterator end() const noexcept { return m_end; }</b></code>
<code class="calibre21">        <b class="calibre14">};</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Returns a range with the adjacent nodes for the given node value.</span></code>
<code class="calibre21">        <b class="calibre14">std::optional&lt;nodes_adjacent_to_result&gt; nodes_adjacent_to(</b></code>
<code class="calibre21">            <b class="calibre14">const T&amp; node_value) const noexcept;</b></code>
<code class="calibre21">        <span class="color">// Remainder of class definition omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Here is the implementation of the
         <code class="calibre21">
          nodes_adjacent_to()
         </code>
         member function:
        </p>
        <pre class="calibre26" id="c25-code-0072"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">std::optional&lt;typename directed_graph&lt;T&gt;::nodes_adjacent_to_result&gt;</code>
<code class="calibre21">    directed_graph&lt;T&gt;::nodes_adjacent_to(const T&amp; node_value) const noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto iter { find_node(node_value) };</code>
<code class="calibre21">    if (iter == std::end(m_nodes)) { return {}; }</code>
<code class="calibre21">    return nodes_adjacent_to_result {</code>
<code class="calibre21">        const_adjacent_nodes_iterator {</code>
<code class="calibre21">            std::cbegin(iter-&gt;get_adjacent_nodes_indices()), this },</code>
<code class="calibre21">        const_adjacent_nodes_iterator {</code>
<code class="calibre21">            std::cend(iter-&gt;get_adjacent_nodes_indices()), this }</code>
<code class="calibre21">    };</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         With
         <code class="calibre21">
          nodes_adjacent_to()
         </code>
         , accessing all adjacent nodes of a given node becomes trivial. Here is an example to print all adjacent nodes of the node with value 22.
        </p>
        <pre class="calibre26" id="c25-code-0073"><code class="calibre21">print("Adjacency list for node 22: ");</code>
<code class="calibre21">auto nodesAdjacentTo22 { graph.nodes_adjacent_to(22) };</code>
<code class="calibre21">if (!nodesAdjacentTo22.has_value()) {</code>
<code class="calibre21">    println("Value 22 not found.");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    for (const auto&amp; node : *nodesAdjacentTo22) { print("{} ", node); }</code>
<code class="calibre21">}</code></pre>
       </section>
       <span aria-label="939" class="calibre20" epub:type="pagebreak" id="Page_939" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c25-sec-0042">
        </span>
        <h5 class="calibre35" id="head-5-164">
         Printing Graphs
        </h5>
        <p class="calibre13">
         Now that
         <code class="calibre21">
          directed_graph
         </code>
         supports
         <code class="calibre21">
          nodes_adjacent_to()
         </code>
         , the
         <code class="calibre21">
          to_dot()
         </code>
         helper function template to print a graph can be simplified:
        </p>
        <pre class="calibre26" id="c25-code-0074"><code class="calibre21">export template &lt;typename T&gt;</code>
<code class="calibre21">std::string to_dot(const directed_graph&lt;T&gt;&amp; graph, std::string_view graph_name)</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::ostringstream output;</code>
<code class="calibre21">    std::println(output, "digraph {} {{", graph_name);</code>
<code class="calibre21">    for (auto&amp;&amp; node : graph) {</code>
<code class="calibre21">        auto adjacent_nodes { graph.nodes_adjacent_to(node) };</code>
<code class="calibre21">        if (adjacent_nodes-&gt;begin() == adjacent_nodes-&gt;end()) {</code>
<code class="calibre21">            std::println(output, "{}", node);</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            for (const auto&amp; adjacent_node : *adjacent_nodes) {</code>
<code class="calibre21">                std::println(output, "{} -&gt; {}", node, adjacent_node);</code>
<code class="calibre21">            }</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    std::println(output, "}}");</code>
<code class="calibre21">    return std::move(output).str();</code>
<code class="calibre21">}</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0043">
       </span>
       <h4 class="calibre29" id="head-4-366">
        Additional Standard Library–Like Functionality
       </h4>
       <p class="calibre13">
        A few more Standard Library–like features can be added to the
        <code class="calibre21">
         directed_graph
        </code>
        class template. First, let's add
        <code class="calibre21">
         assign()
        </code>
        member functions like
        <code class="calibre21">
         vector
        </code>
        has. The
        <code class="calibre21">
         assign()
        </code>
        member function accepting an iterator range is again a member function template, just like the iterator-based
        <code class="calibre21">
         insert()
        </code>
        discussed earlier in this chapter:
       </p>
       <pre class="calibre26" id="c25-code-0075"><code class="calibre21">template &lt;std::input_iterator Iter&gt;</code>
<code class="calibre21">void assign(Iter first, Iter last);</code>
<code class="calibre21"> </code>
<code class="calibre21">void assign(std::initializer_list&lt;T&gt; il);</code></pre>
       <p class="calibre13">
        These allow you to assign all elements of a given iterator range or an
        <code class="calibre21">
         initializer_list
        </code>
        , discussed in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        , to a directed graph. Assignment means that the current graph is cleared, and new nodes are inserted. Despite the syntax, the implementations are easy:
       </p>
       <pre class="calibre26" id="c25-code-0076"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;std::input_iterator Iter&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::assign(Iter first, Iter last)</code>
<code class="calibre21">{</code>
<code class="calibre21">    clear();</code>
<code class="calibre21">    for (auto iter { first }; iter != last; ++iter) { insert(*iter); }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::assign(std::initializer_list&lt;T&gt; il)</code>
<code class="calibre21">{</code>
<code class="calibre21">    assign(std::begin(il), std::end(il));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="940" class="calibre20" epub:type="pagebreak" id="Page_940" role="doc-pagebreak">
        </span>
        An
        <code class="calibre21">
         initializer_list
        </code>
        overload of
        <code class="calibre21">
         insert()
        </code>
        is provided as well:
       </p>
       <pre class="calibre26" id="c25-code-0077"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::insert(std::initializer_list&lt;T&gt; il)</code>
<code class="calibre21">{</code>
<code class="calibre21">    insert(std::begin(il), std::end(il));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        With this overload of
        <code class="calibre21">
         insert()
        </code>
        , nodes can be added as follows:
       </p>
       <pre class="calibre26" id="c25-code-0078"><code class="calibre21">graph.insert({ 66, 77, 88 });</code></pre>
       <p class="calibre13">
        Next, an
        <code class="calibre21">
         initializer_list
        </code>
        constructor and assignment operator can be added. As this is the first explicit
        <code class="calibre21">
         directed_graph
        </code>
        constructor and assignment operator, the default, copy, and move constructors, and the copy and move assignment operators need to be explicitly defaulted as well.
       </p>
       <pre class="calibre26" id="c25-code-0079"><code class="calibre21"><span class="color">// Default, copy, and move constructors.</span></code>
<code class="calibre21">directed_graph() = default;</code>
<code class="calibre21">directed_graph(const directed_graph&amp;) = default;</code>
<code class="calibre21">directed_graph(directed_graph&amp;&amp;) noexcept = default;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// initializer_list constructor.</span></code>
<code class="calibre21">directed_graph(std::initializer_list&lt;T&gt; il);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Copy and move assignment operators.</span></code>
<code class="calibre21">directed_graph&amp; operator=(const directed_graph&amp;) = default;</code>
<code class="calibre21">directed_graph&amp; operator=(directed_graph&amp;&amp;) noexcept = default;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// initializer_list assignment operator.</span></code>
<code class="calibre21">directed_graph&amp; operator=(std::initializer_list&lt;T&gt; il);</code></pre>
       <p class="calibre13">
        Here are the implementations of the
        <code class="calibre21">
         initializer_list
        </code>
        constructor and assignment operator:
       </p>
       <pre class="calibre26" id="c25-code-0080"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">directed_graph&lt;T&gt;::directed_graph(std::initializer_list&lt;T&gt; il)</code>
<code class="calibre21">{</code>
<code class="calibre21">    assign(std::begin(il), std::end(il));</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">directed_graph&lt;T&gt;&amp; directed_graph&lt;T&gt;::operator=(</code>
<code class="calibre21">    std::initializer_list&lt;T&gt; il)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Use a copy-and-swap-like algorithm to guarantee strong exception safety.</span></code>
<code class="calibre21">    <span class="color">// Do all the work in a temporary instance.</span></code>
<code class="calibre21">    directed_graph new_graph { il };</code>
<code class="calibre21">    <span class="color">swap(new_graph); // Commit the work with only non-throwing operations.</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        With these in place, a
        <code class="calibre21">
         directed_graph
        </code>
        can be constructed using uniform initialization, as follows:
       </p>
       <pre class="calibre26" id="c25-code-0081"><code class="calibre21">directed_graph&lt;int&gt; graph { 11, 22, 33 };</code></pre>
       <p class="calibre13">
        <span aria-label="941" class="calibre20" epub:type="pagebreak" id="Page_941" role="doc-pagebreak">
        </span>
        instead of the following:
       </p>
       <pre class="calibre26" id="c25-code-0082"><code class="calibre21">directed_graph&lt;int&gt; graph;</code>
<code class="calibre21">graph.insert(11);</code>
<code class="calibre21">graph.insert(22);</code>
<code class="calibre21">graph.insert(33);</code></pre>
       <p class="calibre13">
        And you can assign to a graph as follows:
       </p>
       <pre class="calibre26" id="c25-code-0083"><code class="calibre21">graph = { 66, 77, 88 };</code></pre>
       <p class="calibre13">
        Thanks to the
        <code class="calibre21">
         initializer_list
        </code>
        constructor and class template argument deduction (CTAD), you can even drop the element type when constructing a
        <code class="calibre21">
         directed_graph
        </code>
        , just as with
        <code class="calibre21">
         vector
        </code>
        :
       </p>
       <pre class="calibre26" id="c25-code-0084"><code class="calibre21">directed_graph graph { 11, 22, 33 };</code></pre>
       <p class="calibre13">
        A constructor accepting an iterator range of elements can be added as well. This is again a member function template, similar to
        <code class="calibre21">
         assign()
        </code>
        accepting an iterator range. The implementation simply forwards the work to
        <code class="calibre21">
         assign()
        </code>
        :
       </p>
       <pre class="calibre26" id="c25-code-0085"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;std::input_iterator Iter&gt;</code>
<code class="calibre21">directed_graph&lt;T&gt;::directed_graph(Iter first, Iter last)</code>
<code class="calibre21">{</code>
<code class="calibre21">    assign(first, last);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        C++23 adds an
        <code class="calibre21">
         insert_range()
        </code>
        member function to most Standard Library containers, which can be added to
        <code class="calibre21">
         directed_graph
        </code>
        as well. This implementation uses the
        <code class="calibre21">
         std::ranges::input_range
        </code>
        concept to constrain the
        <code class="calibre21">
         Range
        </code>
        template type parameter.
       </p>
       <pre class="calibre26" id="c25-code-0086"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">template &lt;std::ranges::input_range Range&gt;</code>
<code class="calibre21">void directed_graph&lt;T&gt;::insert_range(Range&amp;&amp; range)</code>
<code class="calibre21">{</code>
<code class="calibre21">    insert(std::ranges::begin(range), std::ranges::end(range));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        With
        <code class="calibre21">
         insert_range()
        </code>
        you can easily insert elements from any range, for example, from a
        <code class="calibre21">
         vector
        </code>
        :
       </p>
       <pre class="calibre26" id="c25-code-0087"><code class="calibre21">vector moreNodes { 66, 77 };</code>
<code class="calibre21">graph.insert_range(moreNodes);</code></pre>
       <p class="calibre13">
        Finally, an extra overload of
        <code class="calibre21">
         erase()
        </code>
        accepting a node value can be added. Similar to
        <code class="calibre21">
         std::set
        </code>
        , it returns the number of nodes erased, which is always 0 or 1 for
        <code class="calibre21">
         directed_graph
        </code>
        .
       </p>
       <pre class="calibre26" id="c25-code-0088"><code class="calibre21">template &lt;typename T&gt;</code>
<code class="calibre21">typename directed_graph&lt;T&gt;::size_type directed_graph&lt;T&gt;::erase(</code>
<code class="calibre21">    const T&amp; node_value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    const auto iter { find_node(node_value) };</code>
<code class="calibre21">    if (iter != std::end(m_nodes)) {</code>
<code class="calibre21">        remove_all_links_to(iter);</code>
<code class="calibre21">        m_nodes.erase(iter);</code>
<code class="calibre21">        return 1;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return 0;</code>
<code class="calibre21">}</code></pre>
      </section>
      <span aria-label="942" class="calibre20" epub:type="pagebreak" id="Page_942" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0044">
       </span>
       <h4 class="calibre29" id="head-4-367">
        Further Improvements
       </h4>
       <p class="calibre13">
        There are several improvements that can be made to the
        <code class="calibre21">
         directed_graph
        </code>
        class template. Here are a few:
       </p>
       <ul class="check" id="c25-list-0004">
        <li class="calibre9" id="c25-li-0007">
         The current implementation does not check for cycles in the graph. Such a check could be added to make the graph a
         <i class="calibre18">
          directed acyclic graph
         </i>
         .
        </li>
        <li class="calibre9" id="c25-li-0008">
         Instead of supporting bidirectional iterators, support for random-access iterators could be implemented.
        </li>
        <li class="calibre9" id="c25-li-0009">
         The Standard Library associative containers support node-related functionality, see
         <a class="calibre5" href="c18_split_000.xhtml">
          Chapter 18
         </a>
         . The
         <code class="calibre21">
          directed_graph
         </code>
         class template could be improved to include a
         <code class="calibre21">
          node_type
         </code>
         type alias and member functions such as
         <code class="calibre21">
          extract()
         </code>
         .
        </li>
        <li class="calibre9" id="c25-li-0010">
         A more complicated improvement might be to add support for custom allocators, just as all Standard Library containers have. This would require using Standard Library functionality from
         <code class="calibre21">
          std::allocator_traits&lt;A&gt;
         </code>
         , such as
         <code class="calibre21">
          construct()
         </code>
         ,
         <code class="calibre21">
          destroy()
         </code>
         ,
         <code class="calibre21">
          propagate_on_container_move_assignment
         </code>
         ,
         <code class="calibre21">
          propagate_on_container_copy_assignment
         </code>
         ,
         <code class="calibre21">
          propagate_on_container_swap
         </code>
         , and more.
        </li>
       </ul>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c25-sec-0045">
       </span>
       <h4 class="calibre29" id="head-4-368">
        Other Container Types
       </h4>
       <p class="calibre13" id="c25-para-0153">
        The
        <code class="calibre21">
         directed_graph
        </code>
        class template is basically a sequential container, but due to the nature of graphs, it does implement certain functionality from associative containers, such as the return types of the
        <code class="calibre21">
         insert()
        </code>
        member functions.
       </p>
       <p class="calibre13" id="c25-para-0154">
        You could also write a pure sequential container, unordered associative container, or ordered associative container. In that case, you would need to follow a specific set of requirements mandated by the Standard Library. Instead of listing them here, it's easier to point out that the
        <code class="calibre21">
         deque
        </code>
        container follows the prescribed sequential container requirements almost exactly. The only difference is that it provides an extra
        <code class="calibre21">
         resize()
        </code>
        member function (not required by the standard). An example of an ordered associative container is
        <code class="calibre21">
         map
        </code>
        , on which you can model your own ordered associative containers. And
        <code class="calibre21">
         unordered_map
        </code>
        is an example of an unordered associative container.
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-255" class="calibre2">
     <span class="calibre" id="c25-sec-0046">
     </span>
     <h2 class="calibre6" id="head-2-255">
      SUMMARY
     </h2>
     <p class="calibre13" id="c25-para-0155">
      This chapter introduced you to the concept of allocators that allow you to customize how memory is allocated and deallocated for containers. It also showed you how to write your own algorithms that can work with data from Standard Library containers. Finally, the major part of this chapter showed almost the complete development of a Standard Library–compliant
      <code class="calibre21">
       directed_graph
      </code>
      container. Thanks to its iterator support,
      <code class="calibre21">
       directed_graph
      </code>
      is compatible with Standard Library algorithms.
     </p>
     <p class="calibre13" id="c25-para-0156">
      In the process of reading this chapter, you ideally gained an appreciation for the steps involved in developing algorithms and containers. Even if you never write another Standard Library algorithm or container, you understand better the Standard Library's mentality and capabilities, and you can put it to better use.
     </p>
     <p class="calibre13" id="c25-para-0157">
      <span aria-label="943" class="calibre20" epub:type="pagebreak" id="Page_943" role="doc-pagebreak">
      </span>
      This chapter concludes the tour of the C++ Standard Library. Even with all the details given in this book, some features are still omitted. If this material excited you, and you would like more information, consult some of the resources in
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      . Don't feel compelled to use all the features discussed in these chapters. Forcing them into your programs without a true need will just complicate your code. However, I encourage you to consider incorporating aspects of the Standard Library into your programs where they make sense. Start with the containers, maybe throw in an algorithm or two, and before you know it, you'll be a convert!
     </p>
    </section>
    <section aria-labelledby="head-2-256" class="calibre2">
     <span class="calibre" id="c25-sec-0047">
     </span>
     <h2 class="calibre6" id="head-2-256">
      EXERCISES
     </h2>
     <p class="calibre13" id="c25-para-0158">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c25-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c25-ex-0001">
        <b class="calibre14">
         Exercise 25-1:
        </b>
        Write an algorithm called
        <code class="calibre21">
         transform_if()
        </code>
        , similar to the Standard Library's
        <code class="calibre21">
         transform()
        </code>
        , discussed in
        <a class="calibre5" href="c20.xhtml">
         Chapter 20
        </a>
        . The difference is that
        <code class="calibre21">
         transform_if()
        </code>
        should accept an extra predicate and that it only transforms elements for which the predicate returns
        <code class="calibre21">
         true
        </code>
        . Other elements are left untouched. To test your algorithm, create an
        <code class="calibre21">
         array
        </code>
        of integers, and then use
        <code class="calibre21">
         transform_if()
        </code>
        to copy the integers into a
        <code class="calibre21">
         vector
        </code>
        while multiplying all odd values by 2.
       </li>
       <li class="calibre9" id="c25-ex-0002">
        <b class="calibre14">
         Exercise 25-2:
        </b>
        Write an algorithm called
        <code class="calibre21">
         generate_fibonacci()
        </code>
        , which fills a given range with a Fibonacci series of numbers.
        <a aria-describedby="c25-note-0001" class="calibre5" epub:type="noteref" href="#c25-note-0001" id="R_c25-note-0001" role="doc-noteref">
         <sup class="calibre22">
          1
         </sup>
        </a>
        The Fibonacci series starts with 0 and 1, and any subsequent value is the sum of the two previous values, so: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, and so on. Your implementation is not allowed to contain any manually written loops or be implemented using a recursive algorithm. Instead, you should use the Standard Library's
        <code class="calibre21">
         generate()
        </code>
        algorithm to do most of the work.
       </li>
       <li class="calibre9" id="c25-ex-0003">
        <b class="calibre14">
         Exercise 25-3:
        </b>
        Implement a
        <code class="calibre21">
         find(const T&amp;)
        </code>
        member function for the
        <code class="calibre21">
         directed_graph
        </code>
        class template.
       </li>
       <li class="calibre9" id="c25-ex-0004">
        <b class="calibre14">
         Exercise 25-4:
        </b>
        All associative containers have a
        <code class="calibre21">
         contains()
        </code>
        member function that returns
        <code class="calibre21">
         true
        </code>
        if a given element is in the container and
        <code class="calibre21">
         false
        </code>
        otherwise. As this could be useful for a
        <code class="calibre21">
         directed_graph
        </code>
        as well, add an implementation of
        <code class="calibre21">
         contains()
        </code>
        to
        <code class="calibre21">
         directed_graph
        </code>
        .
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c25_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c25_2">
     NOTE
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c25-note-0001" id="c25-note-0001" role="doc-backlink">
       1
      </a>
      The ratio of two successive Fibonacci numbers converges to the golden ratio, 1.618034 … The Fibonacci numbers and the golden ratio often occur in nature, such as branching in trees, flowering of artichokes, flower petals, shells, and many more. The golden ratio is artistically attractive for humans, and hence is often used by architects to design rooms, for the arrangements of plants in gardens, and more.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
