<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   20Mastering Standard Library Algorithms
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_015.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_017.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c20_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c20_1">
      <span aria-label="791" class="calibre17" epub:type="pagebreak" id="Page_791" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c20">
      </span>
      <span class="calibre">
       20
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Mastering Standard Library Algorithms
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c20-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c20-list-0001">
         <li class="calibre9" id="c20-li-0001">
          What Standard Library algorithms are and what principles they are built on
         </li>
         <li class="calibre9" id="c20-li-0002">
          Details of the algorithms provided by the Standard Library
         </li>
         <li class="calibre9" id="c20-li-0003">
          How to execute algorithms in parallel to improve performance
         </li>
         <li class="calibre9" id="c20-li-0004">
          What constrained algorithms are
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c20-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-216">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c20-sec-0003">
        </span>
        <p class="calibre25" id="c20-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c20-para-0005">
      As
      <a class="calibre5" href="c18_split_000.xhtml">
       Chapter 18
      </a>
      , “Standard Library Containers,” shows, the Standard Library provides an impressive collection of generic data structures. Most libraries stop there. The Standard Library, however, contains an additional assortment of generic algorithms that can, with some exceptions, be applied to elements from any container. Using these algorithms, you can find, sort, and process elements in containers and perform a host of other operations. The beauty of the algorithms is that they are independent not only of the types of the underlying elements, but also of the types of the containers on which they operate. Algorithms perform their work using only the iterator or ranges interfaces, discussed in
      <a class="calibre5" href="c17.xhtml">
       Chapter 17
      </a>
      , “Understanding Iterators and the Ranges Library.”
     </p>
     <p class="calibre13" id="c20-para-0006">
      The Standard Library comes with a large set of
      <i class="calibre18">
       unconstrained algorithms
      </i>
      , all working solely with iterators. These algorithms don't have any constraints in the form of concepts; see
      <span aria-label="792" class="calibre20" epub:type="pagebreak" id="Page_792" role="doc-pagebreak">
      </span>
      <a class="calibre5" href="c12.xhtml">
       Chapter 12
      </a>
      , “Writing Generic Code with Templates,” attached to them. The Standard Library additionally has a large collection of
      <i class="calibre18">
       constrained algorithms
      </i>
      , sometimes called
      <i class="calibre18">
       range-based algorithms
      </i>
      . These are able to work with iterators and ranges and are properly constrained, so the compiler can produce more readable error messages when an algorithm is used wrongly. This chapter focuses first on the unconstrained algorithms, as these are the ones used in most existing and legacy code bases; hence, you need to know how they work. Once you know how they work, it will be refreshing to see how the constrained algorithms make things easier.
     </p>
     <p class="calibre13" id="c20-para-0007">
      <a class="calibre5" href="c16.xhtml">
       Chapter 16
      </a>
      , “Overview of the C++ Standard Library,” gives a high-level overview of all the Standard Library algorithms, but without any coding details. Combined with the knowledge of
      <a class="calibre5" href="c19.xhtml">
       Chapter 19
      </a>
      , “Function Pointers, Function Objects, and Lambda Expressions,” now it's time to look at how those algorithms can be used in practice and discover their true power.
     </p>
    </section>
    <section aria-labelledby="head-2-217" class="calibre2">
     <span class="calibre" id="c20-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-217">
      OVERVIEW OF ALGORITHMS
     </h2>
     <p class="calibre13" id="c20-para-0008">
      The “magic” behind the unconstrained algorithms is that they work on iterator intermediaries instead of on the containers themselves. In that way, they are not tied to specific container implementations. All the Standard Library algorithms are implemented as function templates, where the template type parameters are usually iterator types. The iterators themselves are specified as arguments to the function. Function templates can usually deduce the template types from the function arguments, so you can generally call the algorithms as if they were normal functions, not templates.
     </p>
     <p class="calibre13" id="c20-para-0009">
      Most algorithms require a source sequence on which to apply the algorithm. For the unconstrained algorithms, a source sequence is specified as an iterator pair, a begin and end iterator, which is called a
      <i class="calibre18">
       common range
      </i>
      . As
      <a class="calibre5" href="c17.xhtml">
       Chapter 17
      </a>
      explains, common ranges are half-open for most containers such that they include the first element in the range but exclude the last. The end iterator is really a “past-the-end” marker.
     </p>
     <p class="calibre13" id="c20-para-0010">
      Algorithms pose certain requirements on iterators passed to them. For instance,
      <code class="calibre21">
       copy_backward
      </code>
      (
      <code class="calibre21">
       )
      </code>
      , which copies elements from one sequence to another, starting with the last element, is an example of an algorithm that requires a bidirectional iterator. Similarly,
      <code class="calibre21">
       stable_sort()
      </code>
      , which sorts elements in place while preserving the order of duplicate elements, is an example of an algorithm requiring random access iterators. This means that such algorithms cannot work on containers that do not provide the necessary iterators.
      <code class="calibre21">
       forward_list
      </code>
      is an example of a container supporting only forward iterators, no bidirectional or random-access iterators; thus,
      <code class="calibre21">
       copy_backward()
      </code>
      and
      <code class="calibre21">
       stable_sort()
      </code>
      cannot work on
      <code class="calibre21">
       forward_list
      </code>
      .
     </p>
     <p class="calibre13" id="c20-para-0011">
      The majority of the algorithms are defined in
      <code class="calibre21">
       &lt;algorithm&gt;
      </code>
      , with some numerical algorithms defined in
      <code class="calibre21">
       &lt;numeric&gt;
      </code>
      . All of them are in the
      <code class="calibre21">
       std
      </code>
      namespace.
     </p>
     <p class="calibre13" id="c20-para-0012">
      Most algorithms are
      <code class="calibre21">
       constexpr
      </code>
      , which means they can be used in the implementation of
      <code class="calibre21">
       constexpr
      </code>
      functions. Consult a Standard Library Reference (see
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography”) to discover exactly which algorithms are
      <code class="calibre21">
       constexpr
      </code>
      .
     </p>
     <p class="calibre13" id="c20-para-0013">
      The best way to understand the algorithms is to look at some examples in detail first. After you've seen how a few of them work, it's easy to pick up the others. This section describes the
      <code class="calibre21">
       find()
      </code>
      ,
      <code class="calibre21">
       find_if()
      </code>
      , and
      <code class="calibre21">
       accumulate()
      </code>
      algorithms in detail. The subsequent sections discuss each of the classes of algorithms with representative samples.
     </p>
     <span aria-label="793" class="calibre20" epub:type="pagebreak" id="Page_793" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-435">
       The find and find_if Algorithms
      </h3>
      <p class="calibre13">
       <code class="calibre21">
        find()
       </code>
       looks for a specific element in a common range. You can use it on elements in any container type. It returns an iterator referring to the element found or the end iterator of the range in case the element is not found. Note that the range specified in the call to
       <code class="calibre21">
        find()
       </code>
       need not be the entire range of elements in a container; it could be a subset.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0015">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           If
          </i>
          <code class="calibre21">
           find()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             fails to find an element, it returns an iterator equal to the end iterator specified in the function call, not the end iterator of the underlying container
            </i>
            .
           </i>
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Before looking at
       <code class="calibre21">
        find()
       </code>
       , let's define a function template to populate a container with integers. This function template is used throughout this chapter. It's a function template parameterized on the type of container. A constraint enforces that the given container type supports
       <code class="calibre21">
        push_back(int)
       </code>
       .
      </p>
      <pre class="calibre26" id="c20-code-0001"><code class="calibre21">template &lt;typename Container&gt;</code>
<code class="calibre21">    requires requires(Container&amp; c, int i) { c.push_back(i); }</code>
<code class="calibre21">void populateContainer(Container&amp; cont)</code>
<code class="calibre21">{</code>
<code class="calibre21">    while (true) {</code>
<code class="calibre21">        print("Enter a number (0 to stop): ");</code>
<code class="calibre21">        int value;</code>
<code class="calibre21">        cin &gt;&gt; value;</code>
<code class="calibre21">        if (value == 0) { break; }</code>
<code class="calibre21">        cont.push_back(value);</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Now we can look at how to use
       <code class="calibre21">
        std::find()
       </code>
       . This example and the populateContainer() function template assume that the user plays nice and enters valid numbers; it does not perform any error checking on the user input. Performing error checking on stream input is discussed in
       <a class="calibre5" href="c13.xhtml">
        Chapter 13
       </a>
       , “Demystifying C++ I/O.”
      </p>
      <pre class="calibre26" id="c20-code-0002"><code class="calibre21">vector&lt;int&gt; myVector;</code>
<code class="calibre21">populateContainer(myVector);</code>
<code class="calibre21"> </code>
<code class="calibre21">while (true) {</code>
<code class="calibre21">    print("Enter a number to lookup (0 to stop): ");</code>
<code class="calibre21">    int number;</code>
<code class="calibre21">    cin &gt;&gt; number;</code>
<code class="calibre21">    if (number == 0) { break; }</code>
<code class="calibre21">    auto endIt { cend(myVector) };</code>
<code class="calibre21">    <b class="calibre14">auto it { find(cbegin(myVector), endIt, number) };</b></code>
<code class="calibre21">    if (it == endIt) {</code>
<code class="calibre21">        println("Could not find {}", number);</code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        println("Found {}", *it);</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c20-para-0018">
       <span aria-label="794" class="calibre20" epub:type="pagebreak" id="Page_794" role="doc-pagebreak">
       </span>
       To search all the elements of the
       <code class="calibre21">
        vector
       </code>
       ,
       <code class="calibre21">
        find()
       </code>
       is called with
       <code class="calibre21">
        cbegin(myVector)
       </code>
       and
       <code class="calibre21">
        endIt
       </code>
       as iterator arguments, where
       <code class="calibre21">
        endIt
       </code>
       is defined as
       <code class="calibre21">
        cend(myVector)
       </code>
       . If you want to search in a subrange, you can change these two iterators.
      </p>
      <p class="calibre13">
       Here is a sample run of the program:
      </p>
      <pre class="calibre26" id="c20-code-0003"><code class="calibre21">Enter a number (0 to stop): 3</code>
<code class="calibre21">Enter a number (0 to stop): 4</code>
<code class="calibre21">Enter a number (0 to stop): 5</code>
<code class="calibre21">Enter a number (0 to stop): 6</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Enter a number to lookup (0 to stop): 5</code>
<code class="calibre21">Found 5</code>
<code class="calibre21">Enter a number to lookup (0 to stop): 8</code>
<code class="calibre21">Could not find 8</code>
<code class="calibre21">Enter a number to lookup (0 to stop): 0</code></pre>
      <p class="calibre13">
       With initializers for
       <code class="calibre21">
        if
       </code>
       statements, the call to
       <code class="calibre21">
        find()
       </code>
       and checking the result can be done with one statement as follows:
      </p>
      <pre class="calibre26" id="c20-code-0004"><code class="calibre21"><b class="calibre14">if (auto it { find(cbegin(myVector), endIt, number) }; it == endIt) {</b></code>
<code class="calibre21">    println("Could not find {}", number);</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Found {}", *it);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Some containers, such as
       <code class="calibre21">
        map
       </code>
       and
       <code class="calibre21">
        set
       </code>
       , provide their own versions of
       <code class="calibre21">
        find()
       </code>
       as class member functions, as demonstrated with examples during the discussion of those containers in
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0022">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           If a container provides a member function with the same functionality as a generic algorithm, you should use the member function instead, because it's faster. For example, the generic
          </i>
          <code class="calibre21">
           find()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             algorithm runs in linear time, even on a
            </i>
           </i>
           <code class="calibre21">
            map
           </code>
           , while the
          </i>
          <code class="calibre21">
           find()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             member function on a
            </i>
           </i>
           <code class="calibre21">
            map
           </code>
           runs in logarithmic time
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <code class="calibre21">
        find_if()
       </code>
       is similar to
       <code class="calibre21">
        find()
       </code>
       , except that it accepts a
       <i class="calibre18">
        predicate function callback
       </i>
       returning
       <code class="calibre21">
        true
       </code>
       or
       <code class="calibre21">
        false
       </code>
       , instead of a simple element to match. The
       <code class="calibre21">
        find_if()
       </code>
       algorithm calls the predicate on each element in the range until the predicate returns
       <code class="calibre21">
        true
       </code>
       , in which case
       <code class="calibre21">
        find_if()
       </code>
       returns an iterator referring to that element. The following program reads test scores from the user, then checks whether any of the scores are “perfect.” A perfect score is a score of
       <code class="calibre21">
        100
       </code>
       or higher. The program is similar to the previous example. Only the major differences are highlighted:
      </p>
      <pre class="calibre26" id="c20-code-0005"><code class="calibre21"><b class="calibre14">bool perfectScore(int num) { return num &gt;= 100; }</b></code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;int&gt; myVector;</code>
<code class="calibre21">    populateContainer(myVector);</code>
<code class="calibre21"> </code>
<code class="calibre21">    auto endIt { cend(myVector) };</code>
<code class="calibre21">    <b class="calibre14">auto it { find_if(cbegin(myVector), endIt, perfectScore) };</b></code>
<span aria-label="795" class="calibre20" epub:type="pagebreak" id="Page_795" role="doc-pagebreak"></span><code class="calibre21">    if (it == endIt) {</code>
<code class="calibre21">        <b class="calibre14">println("No perfect scores");</b></code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        <b class="calibre14">println("Found a \"perfect\" score of {}", *it);</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c20-para-0024">
       This program passes a pointer to the
       <code class="calibre21">
        perfectScore()
       </code>
       function to
       <code class="calibre21">
        find_if()
       </code>
       , which the algorithm then calls on each element until it returns
       <code class="calibre21">
        true
       </code>
       .
      </p>
      <p class="calibre13">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Instead of passing a function pointer to
       <code class="calibre21">
        find_if()
       </code>
       , you can also pass a functor.
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       , “Overloading C++ Operators,” explains that, starting with C++23, the function call operator of a functor can be marked as
       <code class="calibre21">
        static
       </code>
       if it doesn't need access to any non-
       <code class="calibre21">
        static
       </code>
       data members and member functions of the functor class. The
       <code class="calibre21">
        perfectScore()
       </code>
       function could be changed to a
       <code class="calibre21">
        PerfectScore
       </code>
       functor with a
       <code class="calibre21">
        static
       </code>
       function call operator as follows:
      </p>
      <pre class="calibre26" id="c20-code-0006"><code class="calibre21">class PerfectScore</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        static bool operator()(int num) { return num &gt;= 100; }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The call to
       <code class="calibre21">
        find_if()
       </code>
       then needs to change as follows:
      </p>
      <pre class="calibre26" id="c20-code-0007"><code class="calibre21">auto it { find_if(cbegin(myVector), endIt, <b class="calibre14">&amp;PerfectScore::operator()</b>) };</code></pre>
      <p class="calibre13">
       Finally, instead of a
       <code class="calibre21">
        perfectScore()
       </code>
       function or a
       <code class="calibre21">
        PerfectScore
       </code>
       functor, you can use a lambda expression, discussed in
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       .
      </p>
      <pre class="calibre26" id="c20-code-0008"><code class="calibre21">auto it { find_if(cbegin(myVector), endIt, <b class="calibre14">[](int i){ return i &gt;= 100; }</b>) };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-436">
       The accumulate Algorithm
      </h3>
      <p class="calibre13">
       It's often useful to calculate the sum, or some other arithmetic quantity, of elements in a container. The
       <code class="calibre21">
        accumulate()
       </code>
       function—defined in
       <code class="calibre21">
        &lt;numeric&gt;
       </code>
       , not in
       <code class="calibre21">
        &lt;algorithm&gt;
       </code>
       —does just that. In its most basic form, it calculates the sum of the elements in a specified range. For example, the following function calculates the arithmetic mean of a sequence of integers given as a
       <code class="calibre21">
        span
       </code>
       . The arithmetic mean is simply the sum of all the elements divided by the number of elements:
      </p>
      <pre class="calibre26" id="c20-code-0009"><code class="calibre21">double arithmeticMean(span&lt;const int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    double sum { accumulate(cbegin(values), cend(values), 0.0) };</code>
<code class="calibre21">    return sum / values.size();</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c20-para-0030">
       The
       <code class="calibre21">
        accumulate()
       </code>
       algorithm takes as its third parameter an initial value for the sum, which in this case should be
       <code class="calibre21">
        0.0
       </code>
       (the identity for addition) to start a fresh sum.
      </p>
      <p class="calibre13">
       A second overload of
       <code class="calibre21">
        accumulate()
       </code>
       allows the caller to specify an operation to perform instead of the default addition. This operation takes the form of a binary callback. Suppose that you want to calculate the geometric mean, which is the product of all the numbers in the sequence to the power of the inverse of the size. In that case, you would want to use
       <code class="calibre21">
        accumulate()
       </code>
       to calculate the product instead of the sum. You could write it like this:
      </p>
      <pre class="calibre26" id="c20-code-0010"><span aria-label="796" class="calibre20" epub:type="pagebreak" id="Page_796" role="doc-pagebreak"></span><code class="calibre21">int product(int value1, int value2) { return value1 * value2; }</code>
<code class="calibre21"> </code>
<code class="calibre21">double geometricMean(span&lt;const int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int mult { accumulate(cbegin(values), cend(values), 1, <b class="calibre14">product</b>) };</code>
<code class="calibre21">    return pow(mult, 1.0 / values.size());  <span class="color">// pow() is defined in &lt;cmath&gt;</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c20-para-0032">
       Note that the
       <code class="calibre21">
        product()
       </code>
       function is passed as a callback to
       <code class="calibre21">
        accumulate()
       </code>
       and that the initial value for the accumulation is
       <code class="calibre21">
        1
       </code>
       (the identity for multiplication).
      </p>
      <p class="calibre13">
       Instead of a separate
       <code class="calibre21">
        product()
       </code>
       function, you could use a lambda expression:
      </p>
      <pre class="calibre26" id="c20-code-0011"><code class="calibre21">double geometricMeanLambda(span&lt;const int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int mult { accumulate(cbegin(values), cend(values), 1,</code>
<code class="calibre21">        <b class="calibre14">[](int value1, int value2) { return value1 * value2; }</b>) };</code>
<code class="calibre21">    return pow(mult, 1.0 / values.size());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You could also use the transparent
       <code class="calibre21">
        multiplies&lt;&gt;
       </code>
       function object, discussed in
       <a class="calibre5" href="c19.xhtml">
        Chapter 19
       </a>
       , to implement the
       <code class="calibre21">
        geometricMean()
       </code>
       function:
      </p>
      <pre class="calibre26" id="c20-code-0012"><code class="calibre21">double geometricMeanFunctor(span&lt;const int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int mult { accumulate(cbegin(values), cend(values), 1, <b class="calibre14">multiplies&lt;&gt;{}</b>) };</code>
<code class="calibre21">    return pow(mult, 1.0 / values.size());</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-437">
       Move Semantics with Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0035">
       Just like Standard Library containers, Standard Library algorithms are also optimized to use move semantics at appropriate times; that is, they can move objects instead of performing potential expensive copy operations. This can greatly speed up certain algorithms, for example,
       <code class="calibre21">
        remove()
       </code>
       , discussed in detail later in this chapter. For this reason, it is highly recommended that you implement move semantics in your custom element classes that you want to store in containers. Move semantics can be added to any class by implementing a move constructor and a move assignment operator. As discussed in
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       , both should be marked as
       <code class="calibre21">
        noexcept
       </code>
       , otherwise they won't be used by Standard Library containers and algorithms. Consult the “Implementing Move Semantics” section in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” for details on how to add move semantics to your classes.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0010">
      </span>
      <h3 class="calibre27" id="head-3-438">
       Algorithm Callbacks
      </h3>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0037">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           The algorithms are allowed to make multiple copies of given callbacks, such as functors and lambda expressions, and call different copies for different elements
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c20-para-0038">
       The fact that multiple copies of a callback can be made places strong restrictions on the side effects of such callbacks. Basically, the callbacks must be stateless. For functors, this means that the function call operator needs to be
       <code class="calibre21">
        const
       </code>
       ; thus, you cannot write functors such that they count on any internal
       <span aria-label="797" class="calibre20" epub:type="pagebreak" id="Page_797" role="doc-pagebreak">
       </span>
       state of the object being consistent between calls. Similar for lambda expressions, they cannot be marked as
       <code class="calibre21">
        mutable
       </code>
       .
      </p>
      <p class="calibre13" id="c20-para-0039">
       There are some exceptions. The
       <code class="calibre21">
        generate()
       </code>
       and
       <code class="calibre21">
        generate_n()
       </code>
       algorithms can accept stateful callbacks, but even these make one copy of the callback. On top of that, they don't return that copy, so you don't have access to the changes made to the state once the algorithm is finished. The only exception is
       <code class="calibre21">
        for_each()
       </code>
       . It copies the given predicate once into the
       <code class="calibre21">
        for_each()
       </code>
       algorithm and returns that copy when finished. You can access the changed state through this returned value.
      </p>
      <p class="calibre13">
       To prevent callbacks from getting copied by algorithms, you can use the
       <code class="calibre21">
        std::ref()
       </code>
       helper function to pass a callback reference to the algorithm instead. This ensures that the algorithm always uses the same callback. For example, the following code snippet is based on an earlier example in this chapter but uses a lambda expression stored in a variable named
       <code class="calibre21">
        isPerfectScore
       </code>
       . The lambda expression counts how often it gets called and writes that to standard output.
       <code class="calibre21">
        isPerfectScore
       </code>
       is passed to the
       <code class="calibre21">
        find_if()
       </code>
       algorithm, not yet using
       <code class="calibre21">
        ref()
       </code>
       . The last statement of the snippet explicitly calls
       <code class="calibre21">
        isPerfectScore
       </code>
       one additional time.
      </p>
      <pre class="calibre26" id="c20-code-0013"><code class="calibre21">auto isPerfectScore { [tally = 0] (int i) mutable {</code>
<code class="calibre21">    println("{}", ++tally);  return i &gt;= 100; } };</code>
<code class="calibre21"> </code>
<code class="calibre21">auto endIt { cend(myVector) };</code>
<code class="calibre21">auto it { find_if(cbegin(myVector), endIt, <b class="calibre14">isPerfectScore</b>) };</code>
<code class="calibre21">if (it != endIt) { println("Found a \"perfect\" score of {}", *it); }</code>
<code class="calibre21">println("---");</code>
<code class="calibre21">isPerfectScore(1);</code></pre>
      <p class="calibre13">
       The output can be as followed:
      </p>
      <pre class="calibre26" id="c20-code-0014"><code class="calibre21">Enter a number (0 to stop): 11</code>
<code class="calibre21">Enter a number (0 to stop): 22</code>
<code class="calibre21">Enter a number (0 to stop): 33</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">1</code>
<code class="calibre21">2</code>
<code class="calibre21">3</code>
<code class="calibre21">---</code>
<code class="calibre21">1</code></pre>
      <p class="calibre13" id="c20-para-0042">
       The output shows that the
       <code class="calibre21">
        find_if()
       </code>
       algorithm calls
       <code class="calibre21">
        isPerfectScore
       </code>
       three times producing the output 1, 2, 3. The last line shows that the explicit call to
       <code class="calibre21">
        isPerfectScore
       </code>
       occurs on a different instance of
       <code class="calibre21">
        isPerfectScore
       </code>
       as it starts again at 1.
      </p>
      <p class="calibre13">
       Now, change the call to
       <code class="calibre21">
        find_if()
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c20-code-0015"><code class="calibre21">auto it { find_if(cbegin(myVector), endIt, <b class="calibre14">ref(isPerfectScore)</b>) };</code></pre>
      <p class="calibre13" id="c20-para-0044">
       The output now will be 1, 2, 3, 4, showing that no copies of
       <code class="calibre21">
        isPerfectScore
       </code>
       are made.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-218" class="calibre2">
     <span class="calibre" id="c20-sec-0012">
     </span>
     <h2 class="calibre6" id="head-2-218">
      ALGORITHM DETAILS
     </h2>
     <p class="calibre13" id="c20-para-0045">
      <a class="calibre5" href="c16.xhtml">
       Chapter 16
      </a>
      lists all available Standard Library algorithms, divided into different categories. Most of the algorithms are defined in
      <code class="calibre21">
       &lt;algorithm&gt;
      </code>
      , but a few are located in
      <code class="calibre21">
       &lt;numeric&gt;
      </code>
      . They are all in the
      <code class="calibre21">
       std
      </code>
      namespace.
     </p>
     <p class="calibre13" id="c20-para-0046">
      <span aria-label="798" class="calibre20" epub:type="pagebreak" id="Page_798" role="doc-pagebreak">
      </span>
      The goal of this chapter is not to provide a reference-style overview of all available algorithms. Instead, I have picked a number of categories and provided examples for them. Once you know how to use these algorithms, you should have no problems with other algorithms. Consult a Standard Library Reference (see
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      ) for a full reference of
      <i class="calibre18">
       all
      </i>
      the algorithms.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0013">
      </span>
      <h3 class="calibre27" id="head-3-439">
       Non-modifying Sequence Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0047">
       Non-modifying sequence algorithms are algorithms that do not modify the sequence of elements they operate on. These include algorithms for searching elements in a range and for comparing two ranges to each other; they also include a number of counting algorithms.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0014">
       </span>
       <h4 class="calibre29" id="head-4-312">
        Search Algorithms
       </h4>
       <p class="calibre13" id="c20-para-0048">
        You've already seen examples of two search algorithms earlier in this chapter:
        <code class="calibre21">
         find()
        </code>
        and
        <code class="calibre21">
         find_if()
        </code>
        . The Standard Library provides several other variations of the basic
        <code class="calibre21">
         find()
        </code>
        algorithm that work on sequences of elements. The section “
        <a class="calibre5" href="#c20-sec-0047">
         Search Algorithms
        </a>
        ” in
        <a class="calibre5" href="c16.xhtml">
         Chapter 16
        </a>
        describes the different search algorithms that are available, including their complexity.
       </p>
       <p class="calibre13" id="c20-para-0049">
        All the algorithms use
        <code class="calibre21">
         operator==
        </code>
        or
        <code class="calibre21">
         &lt;
        </code>
        as the default comparison operator, but also provide overloaded versions that allow you to specify a different comparison callback.
       </p>
       <p class="calibre13">
        Here are examples of some of the search algorithms in action:
       </p>
       <pre class="calibre26" id="c20-code-0016"><code class="calibre21"><span class="color">// The list of elements to be searched.</span></code>
<code class="calibre21">vector myVector { 5, 6, 9, 8, 8, 3 };</code>
<code class="calibre21">auto beginIter { cbegin(myVector) };</code>
<code class="calibre21">auto endIter { cend(myVector) };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Find the first element that does not satisfy the given lambda expression.</span></code>
<code class="calibre21"><b class="calibre14">auto it { find_if_not(beginIter, endIter, [](int i){ return i &lt; 8; }) };</b></code>
<code class="calibre21">if (it != endIter) {</code>
<code class="calibre21">    println("First element not &lt; 8 is {}", *it);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Find the first pair of matching consecutive elements.</span></code>
<code class="calibre21"><b class="calibre14">it = adjacent_find(beginIter, endIter);</b></code>
<code class="calibre21">if (it != endIter) {</code>
<code class="calibre21">    println("Found two consecutive equal elements with value {}", *it);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Find the first of two values.</span></code>
<code class="calibre21">vector targets { 8, 9 };</code>
<code class="calibre21"><b class="calibre14">it = find_first_of(beginIter, endIter, cbegin(targets), cend(targets));</b></code>
<code class="calibre21">if (it != endIter) {</code>
<code class="calibre21">    println("Found one of 8 or 9: {}", *it);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Find the first subsequence.</span></code>
<code class="calibre21">vector sub { 8, 3 };</code>
<code class="calibre21"><b class="calibre14">it = search(beginIter, endIter, cbegin(sub), cend(sub));</b></code>
<code class="calibre21">if (it != endIter) {</code>
<code class="calibre21">    println("Found subsequence {{8,3}}");</code>
<span aria-label="799" class="calibre20" epub:type="pagebreak" id="Page_799" role="doc-pagebreak"></span><code class="calibre21">} else {</code>
<code class="calibre21">    println("Unable to find subsequence {{8,3}}");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Find the last subsequence (which is the same as the first in this example).</span></code>
<code class="calibre21"><b class="calibre14">auto it2 { find_end(beginIter, endIter, cbegin(sub), cend(sub)) };</b></code>
<code class="calibre21">if (it != it2) {</code>
<code class="calibre21">    println("Error: search and find_end found different subsequences "</code>
<code class="calibre21">         "even though there is only one match.");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Find the first subsequence of two consecutive 8s.</span></code>
<code class="calibre21"><b class="calibre14">it = search_n(beginIter, endIter, 2, 8);</b></code>
<code class="calibre21">if (it != endIter) {</code>
<code class="calibre21">    println("Found two consecutive 8s");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Unable to find two consecutive 8s");</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Here is the output:
       </p>
       <pre class="calibre26" id="c20-code-0017"><code class="calibre21">First element not &lt; 8 is 9</code>
<code class="calibre21">Found two consecutive equal elements with value 8</code>
<code class="calibre21">Found one of 8 or 9: 9</code>
<code class="calibre21">Found subsequence {8,3}</code>
<code class="calibre21">Found two consecutive 8s</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0053">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Remember that some of the containers have member functions equivalent to generic algorithms. If that's the case, it's recommended to use those member functions instead of the generic algorithms, because the member functions are more efficient. An example is the
           </i>
           <code class="calibre21">
            find()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              member function of
             </i>
            </i>
           </i>
           <code class="calibre21">
            std::set
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              and
             </i>
            </i>
           </i>
           <code class="calibre21">
            std::map
           </code>
           <i class="calibre18">
            <i class="calibre18">
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-313">
        Specialized Searchers
       </h4>
       <p class="calibre13">
        An optional parameter to the
        <code class="calibre21">
         search()
        </code>
        algorithm allows you to specify which search algorithm to use. You have three options—
        <code class="calibre21">
         default_searcher
        </code>
        ,
        <code class="calibre21">
         boyer_moore_searcher
        </code>
        , or
        <code class="calibre21">
         boyer_moore_horspool_searcher
        </code>
        —all defined in
        <code class="calibre21">
         &lt;functional&gt;
        </code>
        . The last two options implement the well-known
        <i class="calibre18">
         Boyer-Moore
        </i>
        and
        <i class="calibre18">
         Boyer-Moore-Horspool
        </i>
        search algorithms. These are more efficient than the default searcher and can be used to find a substring in a larger piece of text. The complexity of the Boyer-Moore searchers is as follows (
        <i class="calibre18">
         N
        </i>
        is the size of the sequence to search in, the haystack, and
        <i class="calibre18">
         M
        </i>
        is the size of the pattern to find, the needle):
       </p>
       <ul class="check" id="c20-list-0002">
        <li class="calibre9" id="c20-li-0005">
         If the pattern is not found, the worst-case complexity is
         <i class="calibre18">
          O
         </i>
         (
         <i class="calibre18">
          N
         </i>
         +
         <i class="calibre18">
          M
         </i>
         ).
        </li>
        <li class="calibre9" id="c20-li-0006">
         If the pattern is found, the worst-case complexity is
         <i class="calibre18">
          O
         </i>
         (
         <i class="calibre18">
          N*M
         </i>
         ).
        </li>
       </ul>
       <p class="calibre13" id="c20-para-0055">
        These are the theoretical worst-case complexities. In practice, these specialized searchers are sublinear, better than
        <i class="calibre18">
         O
        </i>
        (
        <i class="calibre18">
         N
        </i>
        ), which means they are much faster than the default one! They are sublinear because
        <span aria-label="800" class="calibre20" epub:type="pagebreak" id="Page_800" role="doc-pagebreak">
        </span>
        they are able to skip characters instead of looking at each single character in the haystack. They also have an interesting property that the longer the needle is, the faster they work, as they will be able to skip more characters in the haystack. The difference between the Boyer-Moore and the Boyer-Moore-Horspool algorithm is that the latter has less constant overhead for its initialization and in each loop iteration of its algorithm; however, its worst-case complexity can be significantly higher than for the Boyer-Moore algorithm. So, which one to choose depends on your specific use case.
       </p>
       <p class="calibre13">
        Here is an example of using a Boyer-Moore searcher:
       </p>
       <pre class="calibre26" id="c20-code-0018"><code class="calibre21">string text { "This is the haystack to search a needle in." };</code>
<code class="calibre21">string toSearchFor { "needle" };</code>
<code class="calibre21"><b class="calibre14">boyer_moore_searcher searcher { cbegin(toSearchFor), cend(toSearchFor) };</b></code>
<code class="calibre21"><b class="calibre14">auto result { search(cbegin(text), cend(text), searcher) };</b></code>
<code class="calibre21">if (result != cend(text)) {</code>
<code class="calibre21">    println("Found the needle.");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Needle not found.");</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0017">
       </span>
       <h4 class="calibre29" id="head-4-314">
        Comparison Algorithms
       </h4>
       <p class="calibre13">
        You can compare entire ranges of elements in several different ways:
        <code class="calibre21">
         equal()
        </code>
        ,
        <code class="calibre21">
         mismatch()
        </code>
        ,
        <code class="calibre21">
         lexicographical_compare()
        </code>
        , and
        <code class="calibre21">
         lexicographical_compare_three_way()
        </code>
        . These algorithms have the advantage that you can compare sequences from different containers. For example, you can compare the contents of a
        <code class="calibre21">
         vector
        </code>
        with the contents of a
        <code class="calibre21">
         list
        </code>
        . In general, these algorithms work best with sequential containers. They work by comparing the values in corresponding positions of the two collections to each other. The following list describes how each algorithm works:
       </p>
       <ul class="check" id="c20-list-0003">
        <li class="calibre9" id="c20-li-0007">
         <b class="calibre14">
          <code class="calibre21">
           equal()
          </code>
         </b>
         returns
         <code class="calibre21">
          true
         </code>
         if all corresponding elements are equal. Originally,
         <code class="calibre21">
          equal()
         </code>
         accepted three iterators: begin and end iterators for the first range, and a begin iterator for the second range. This version required both ranges to have the same number of elements. Since C++14, there is an overload accepting four iterators: begin and end iterators for the first range, and begin and end iterators for the second range. This version can cope with ranges of different sizes. It's recommended to always use the four-iterator version because it's safer!
        </li>
        <li class="calibre9" id="c20-li-0008">
         <b class="calibre14">
          <code class="calibre21">
           mismatch()
          </code>
         </b>
         returns iterators, one iterator for each range, to indicate where in the range the corresponding elements mismatch. There are three-iterator and four-iterator versions available, just as with
         <code class="calibre21">
          equal()
         </code>
         . It's again recommended to use the four-iterator version, because of safety!
        </li>
        <li class="calibre9" id="c20-li-0009">
         <b class="calibre14">
          <code class="calibre21">
           lexicographical_compare()
          </code>
         </b>
         compares the elements that have the same position in both supplied ranges against each other (sequentially). It returns
         <code class="calibre21">
          true
         </code>
         if the first unequal element in the first range is less than its corresponding element in the second range, or if the first range has fewer elements than the second and all elements in the first range are equal to their corresponding initial subsequence in the second set.
         <code class="calibre21">
          lexicographical_compare()
         </code>
         gets its name because it resembles the rules for comparing strings in dictionaries, but extends this set of rules to deal with objects of any type.
        </li>
        <li class="calibre9" id="c20-li-0010">
         <b class="calibre14">
          <code class="calibre21">
           lexicographical_compare_three_way()
          </code>
         </b>
         is similar to
         <code class="calibre21">
          lexicographical_compare()
         </code>
         except that it performs a three-way comparison and returns a comparison category type (
         <code class="calibre21">
          strong_ordering
         </code>
         ,
         <code class="calibre21">
          weak_ordering
         </code>
         , or
         <code class="calibre21">
          partial_ordering
         </code>
         , discussed in
         <a class="calibre5" href="c01_split_000.xhtml">
          Chapter 1
         </a>
         , “A Crash Course in C++ and the Standard Library”) instead of a Boolean.
        </li>
       </ul>
       <p class="calibre13">
        <span aria-label="801" class="calibre20" epub:type="pagebreak" id="Page_801" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0058">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            If you want to compare all elements of two containers of the same type, you can just use operators such as
           </i>
           <code class="calibre21">
            operator==
           </code>
           <i class="calibre18">
            <i class="calibre18">
             or
            </i>
           </i>
           <code class="calibre21">
            operator&lt;
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              instead of one of these algorithms. The algorithms are useful for comparing subranges, C-style arrays, sequences of elements from different container types, and so on
             </i>
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Here are some examples of these algorithms in action:
       </p>
       <pre class="calibre26" id="c20-code-0019"><code class="calibre21">vector&lt;int&gt; myVector;</code>
<code class="calibre21">list&lt;int&gt; myList;</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Populate the vector:");</code>
<code class="calibre21">populateContainer(myVector);</code>
<code class="calibre21">println("Populate the list:");</code>
<code class="calibre21">populateContainer(myList);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Compare the two containers</span></code>
<code class="calibre21"><b class="calibre14">if (equal(cbegin(myVector), cend(myVector),</b></code>
<code class="calibre21">          <b class="calibre14">cbegin(myList), cend(myList))) {</b></code>
<code class="calibre21">    println("The two containers have equal elements");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    <span class="color">// If the containers were not equal, find out why not</span></code>
<code class="calibre21">    <b class="calibre14">auto miss { mismatch(cbegin(myVector), cend(myVector),</b></code>
<code class="calibre21">                         <b class="calibre14">cbegin(myList), cend(myList)) };</b></code>
<code class="calibre21">    println("The following initial elements are the same in "</code>
<code class="calibre21">        "the vector and the list:");</code>
<code class="calibre21">    for (auto iter { cbegin(myVector) }; iter != miss.first; ++iter) {</code>
<code class="calibre21">        print("{}\t", *iter);</code>
<code class="calibre21">    }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Now order them.</span></code>
<code class="calibre21"><b class="calibre14">if (lexicographical_compare(cbegin(myVector), cend(myVector),</b></code>
<code class="calibre21">                            <b class="calibre14">cbegin(myList), cend(myList))) {</b></code>
<code class="calibre21">    println("The vector is lexicographically first.");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("The list is lexicographically first.");</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Here is a sample run of the program:
       </p>
       <pre class="calibre26" id="c20-code-0020"><code class="calibre21">Populate the vector:</code>
<code class="calibre21">Enter a number (0 to stop): 5</code>
<code class="calibre21">Enter a number (0 to stop): 6</code>
<code class="calibre21">Enter a number (0 to stop): 7</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Populate the list:</code>
<code class="calibre21">Enter a number (0 to stop): 5</code>
<code class="calibre21">Enter a number (0 to stop): 6</code>
<code class="calibre21">Enter a number (0 to stop): 9</code>
<code class="calibre21">Enter a number (0 to stop): 8</code>
<span aria-label="802" class="calibre20" epub:type="pagebreak" id="Page_802" role="doc-pagebreak"></span><code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">The following initial elements are the same in the vector and the list:</code>
<code class="calibre21">5      6</code>
<code class="calibre21">The vector is lexicographically first.</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0019">
       </span>
       <p class="calibre13">
        Additionally, the following comparison algorithms work on a single range: all_of(), any_of(), and none_of(). Here are some examples:
       </p>
       <pre class="calibre26" id="c20-code-0021"><code class="calibre21"><span class="color">// all_of()</span></code>
<code class="calibre21">vector vec2 { 1, 1, 1, 1 };</code>
<code class="calibre21"><b class="calibre14">if (all_of(cbegin(vec2), cend(vec2), [](int i){ return i == 1; })) {</b></code>
<code class="calibre21">    println("All elements are == 1");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Not all elements are == 1");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// any_of()</span></code>
<code class="calibre21">vector vec3 { 0, 0, 1, 0 };</code>
<code class="calibre21"><b class="calibre14">if (any_of(cbegin(vec3), cend(vec3), [](int i){ return i == 1; })) {</b></code>
<code class="calibre21">    println("At least one element == 1");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("No elements are == 1");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// none_of()</span></code>
<code class="calibre21">vector vec4 { 0, 0, 0, 0 };</code>
<code class="calibre21"><b class="calibre14">if (none_of(cbegin(vec4), cend(vec4), [](int i){ return i == 1; })) {</b></code>
<code class="calibre21">    println("All elements are != 1");</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Some elements are == 1");</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0022"><code class="calibre21">All elements are == 1</code>
<code class="calibre21">At least one element == 1</code>
<code class="calibre21">All elements are != 1</code></pre>
       <section class="calibre2">
        <span class="calibre" id="c20-sec-1019">
        </span>
        Counting Algorithms
        <p class="calibre13">
         The non-modifying counting algorithms are count() and count_if(). The following example uses the
         <code class="calibre21">
          count_if()
         </code>
         algorithm to count the number of elements in a
         <code class="calibre21">
          vector
         </code>
         that satisfy a certain condition. The condition is given in the form of a lambda expression, which captures the
         <code class="calibre21">
          value
         </code>
         variable from its enclosing scope by value:
        </p>
        <pre class="calibre26" id="c20-code-0023"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9 };</code>
<code class="calibre21">int value { 3 };</code>
<code class="calibre21"><b class="calibre14">auto tally { count_if(cbegin(values), cend(values),</b></code>
<code class="calibre21">    <b class="calibre14">[value](int i){ return i &gt; value; }) };</b></code>
<code class="calibre21">println("Found {} values &gt; {}.", tally, value);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c20-code-0024"><code class="calibre21">Found 6 values&gt; 3</code></pre>
        <p class="calibre13">
         <span aria-label="803" class="calibre20" epub:type="pagebreak" id="Page_803" role="doc-pagebreak">
         </span>
         The example can be extended to demonstrate capturing variables by reference. The following lambda expression counts the number of times it is called by incrementing a variable in the enclosing scope that is captured by reference:
        </p>
        <pre class="calibre26" id="c20-code-0025"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9 };</code>
<code class="calibre21">int value { 3 };</code>
<code class="calibre21"><b class="calibre14">int callCounter { 0 };</b></code>
<code class="calibre21"><b class="calibre14">auto tally { count_if(cbegin(values), cend(values),</b></code>
<code class="calibre21">    <b class="calibre14">[value, &amp;callCounter](int i){ ++callCounter; return i &gt; value; }) };</b></code>
<code class="calibre21"><b class="calibre14">println("The lambda expression was called {} times.", callCounter);</b></code>
<code class="calibre21">println("Found {} values &gt; {}.", tally, value);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c20-code-0026"><code class="calibre21">The lambda expression was called 9 times.</code>
<code class="calibre21">Found 6 values &gt; 3</code></pre>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0020">
      </span>
      <h3 class="calibre27" id="head-3-440">
       Modifying Sequence Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0067">
       The Standard Library provides a variety of
       <i class="calibre18">
        modifying sequence algorithms
       </i>
       that perform tasks such as copying elements from one range to another, removing elements, or reversing the order of elements in a range.
      </p>
      <p class="calibre13" id="c20-para-0068">
       Some modifying algorithms use the concept of a
       <i class="calibre18">
        source
       </i>
       and a
       <i class="calibre18">
        destination
       </i>
       range. The elements are read from the source range and modified in the destination range. An example of such an algorithm is
       <code class="calibre21">
        copy()
       </code>
       .
      </p>
      <p class="calibre13">
       Other algorithms perform their work
       <i class="calibre18">
        in-place
       </i>
       ; that is, they require only one range, for example the
       <code class="calibre21">
        generate()
       </code>
       algorithm.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0070">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           The modifying algorithms cannot insert elements into a destination. They can only overwrite/modify whatever elements are in the destination already
          </i>
          .
          <a class="calibre5" href="c17.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           17
          </a>
          <i class="calibre18">
           describes how iterator adapters can be used to really insert elements into a destination
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0071">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Ranges from
           <code class="calibre21">
            map
           </code>
           s and
          </i>
          <code class="calibre21">
           multimap
          </code>
          <i class="calibre18">
           s cannot be used as destinations of modifying algorithms. These algorithms overwrite entire elements, which in a
           <code class="calibre21">
            map
           </code>
           consist of key/value pairs. However,
           <code class="calibre21">
            map
           </code>
           s and
          </i>
          <code class="calibre21">
           multimap
          </code>
          <i class="calibre18">
           s mark the key as
          </i>
          <code class="calibre21">
           const
          </code>
          <i class="calibre18">
           , so it cannot be assigned to. The same holds for
          </i>
          <code class="calibre21">
           set
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           multiset
          </code>
          <i class="calibre18">
           . Your alternative is to use an insert iterator, described in
          </i>
          <a class="calibre5" href="c17.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           17
          </a>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c20-para-0072">
       The section “
       <a class="calibre5" href="#c20-sec-0020">
        Modifying Sequence Algorithms
       </a>
       ” in
       <a class="calibre5" href="c16.xhtml">
        Chapter 16
       </a>
       lists all available modifying algorithms with a description of each one. This section provides code examples for a selection of
       <span aria-label="804" class="calibre20" epub:type="pagebreak" id="Page_804" role="doc-pagebreak">
       </span>
       those algorithms. If you understand how to use the algorithms explained in this section, you should not have any problems using the other algorithms for which no examples are given.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0023">
       </span>
       <h4 class="calibre29" id="head-4-315">
        generate
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         generate()
        </code>
        algorithm requires a common range and replaces the values in that range with the values returned from the function callback given as third argument. The following example uses the
        <code class="calibre21">
         generate()
        </code>
        algorithm together with a lambda expression to put the numbers 2, 4, 8, 16, and so on, in a
        <code class="calibre21">
         vector
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0027"><code class="calibre21">vector&lt;int&gt; values(10); <span class="color">// Create a vector of 10 elements.</span></code>
<code class="calibre21">int value { 1 };</code>
<code class="calibre21"><b class="calibre14">generate(begin(values), end(values), [&amp;value]{ value *= 2; return value; });</b></code>
<code class="calibre21">println("{:n}", values);</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0028"><code class="calibre21">2, 4, 8, 16, 32, 64, 128, 256, 512, 1024</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0024">
       </span>
       <h4 class="calibre29" id="head-4-316">
        transform
       </h4>
       <p class="calibre13">
        There are multiple overloads of the
        <code class="calibre21">
         transform()
        </code>
        algorithm. One overload applies a callback to each element in a range and expects the callback to generate a new element, which it stores in the specified destination range. The source and destination ranges can be the same if you want
        <code class="calibre21">
         transform()
        </code>
        to work in-place. The parameters are a begin and end iterator of the source sequence, a begin iterator of the destination sequence, and the callback. For example, the following code snippet adds 100 to each element in a
        <code class="calibre21">
         vector
        </code>
        . The
        <code class="calibre21">
         populateContainer()
        </code>
        function is the same as defined earlier in this chapter.
       </p>
       <pre class="calibre26" id="c20-code-0029"><code class="calibre21">vector&lt;int&gt; myVector;</code>
<code class="calibre21">populateContainer(myVector);</code>
<code class="calibre21"> </code>
<code class="calibre21">println("The vector contains: {:n}", myVector);</code>
<code class="calibre21"><b class="calibre14">transform(begin(myVector), end(myVector), begin(myVector),</b></code>
<code class="calibre21">    <b class="calibre14">[](int i){ return i + 100;});</b></code>
<code class="calibre21">println("The vector contains: {:n}", myVector);</code></pre>
       <p class="calibre13">
        A possible output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0030"><code class="calibre21">Enter a number (0 to stop): 1</code>
<code class="calibre21">Enter a number (0 to stop): 11</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">The vector contains: 1, 11</code>
<code class="calibre21">The vector contains: 101, 111</code></pre>
       <p class="calibre13">
        Another overload of
        <code class="calibre21">
         transform()
        </code>
        calls a binary function on pairs of elements from two ranges. It requires a begin and end iterator of the first range, a begin iterator of the second range, and a begin iterator of the destination range. The following example creates two
        <code class="calibre21">
         vector
        </code>
        s and uses
        <code class="calibre21">
         transform()
        </code>
        to calculate the sum of pairs of elements and to store the result back in the first
        <code class="calibre21">
         vector
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0031"><code class="calibre21">vector&lt;int&gt; vec1, vec2;</code>
<code class="calibre21">println("Vector1:"); populateContainer(vec1);</code>
<code class="calibre21">println("Vector2:"); populateContainer(vec2);</code>
<code class="calibre21">if (vec2.size() &lt; vec1.size())</code>
<code class="calibre21">{</code>
<span aria-label="805" class="calibre20" epub:type="pagebreak" id="Page_805" role="doc-pagebreak"></span><code class="calibre21">    println("Vector2 should be at least the same size as vector1.");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Vector1: {:n}", vec1); </code>
<code class="calibre21">println("Vector2: {:n}", vec2); </code>
<code class="calibre21"><b class="calibre14">transform(begin(vec1), end(vec1), begin(vec2), begin(vec1),</b></code>
<code class="calibre21">    <b class="calibre14">[](int a, int b){ return a + b; });</b></code>
<code class="calibre21">println("Vector1: {:n}", vec1); </code>
<code class="calibre21">println("Vector2: {:n}", vec2); </code></pre>
       <p class="calibre13">
        The output could look like this:
       </p>
       <pre class="calibre26" id="c20-code-0032"><code class="calibre21">Vector1:</code>
<code class="calibre21">Enter a number (0 to stop): 1</code>
<code class="calibre21">Enter a number (0 to stop): 2</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Vector2:</code>
<code class="calibre21">Enter a number (0 to stop): 11</code>
<code class="calibre21">Enter a number (0 to stop): 22</code>
<code class="calibre21">Enter a number (0 to stop): 33</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Vector1: 1, 2</code>
<code class="calibre21">Vector2: 11, 22, 33</code>
<code class="calibre21">Vector1: 12, 24</code>
<code class="calibre21">Vector2: 11, 22, 33</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0080">
           <b class="calibre14">
            NOTE
           </b>
           <code class="calibre21">
            transform()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              and the other modifying algorithms often return an iterator referring to the past-the-end value of the destination range. The examples in this book usually ignore that return value
             </i>
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0026">
       </span>
       <h4 class="calibre29" id="head-4-317">
        copy
       </h4>
       <p class="calibre13" id="c20-para-0081">
        The
        <code class="calibre21">
         copy()
        </code>
        algorithm allows you to copy elements from one range to another, starting with the first element and proceeding to the last element in the range. The source and destination ranges must be different, but, with restrictions, they can overlap. The restrictions are as follows: for
        <code class="calibre21">
         copy(b,e,d)
        </code>
        , overlapping is fine if
        <code class="calibre21">
         d
        </code>
        is before
        <code class="calibre21">
         b
        </code>
        ; however, if
        <code class="calibre21">
         d
        </code>
        is within
        <code class="calibre21">
         [b,e)
        </code>
        , then the behavior is undefined. As with all modifying algorithms,
        <code class="calibre21">
         copy()
        </code>
        cannot insert elements into the destination. It just overwrites whatever elements are there already.
        <a class="calibre5" href="c17.xhtml">
         Chapter 17
        </a>
        describes how to use iterator adapters to insert elements into a container or stream with
        <code class="calibre21">
         copy()
        </code>
        .
       </p>
       <p class="calibre13">
        Here is a simple example of
        <code class="calibre21">
         copy()
        </code>
        that uses the
        <code class="calibre21">
         resize()
        </code>
        member function on a
        <code class="calibre21">
         vector
        </code>
        to ensure that there is enough space in the destination container. It copies all elements from
        <code class="calibre21">
         vec1
        </code>
        to
        <code class="calibre21">
         vec2
        </code>
        .
       </p>
       <pre class="calibre26" id="c20-code-0033"><code class="calibre21">vector&lt;int&gt; vec1, vec2;</code>
<code class="calibre21">populateContainer(vec1);</code>
<code class="calibre21">vec2.resize(size(vec1));</code>
<code class="calibre21"><b class="calibre14">copy(cbegin(vec1), cend(vec1), begin(vec2));</b></code>
<code class="calibre21">println("{:n}", vec2);</code></pre>
       <p class="calibre13">
        <span aria-label="806" class="calibre20" epub:type="pagebreak" id="Page_806" role="doc-pagebreak">
        </span>
        There is also a
        <code class="calibre21">
         copy_backward()
        </code>
        algorithm, which copies the elements from the source backward to the destination. In other words, it starts with the last element of the source, puts it in the last position in the destination range, and then moves backward after each copy. Also for
        <code class="calibre21">
         copy_backward()
        </code>
        , the source and destination ranges must be different, but, with restrictions, they can again overlap. The restrictions this time are as follows: for
        <code class="calibre21">
         copy_backward(b,e,d)
        </code>
        , overlapping is fine if
        <code class="calibre21">
         d
        </code>
        is after
        <code class="calibre21">
         e
        </code>
        , however, if
        <code class="calibre21">
         d
        </code>
        is within
        <code class="calibre21">
         (b,e]
        </code>
        , then the behavior is undefined. The preceding example can be modified to use
        <code class="calibre21">
         copy_backward()
        </code>
        instead of
        <code class="calibre21">
         copy()
        </code>
        , as follows. Note that you need to specify
        <code class="calibre21">
         end(vec2)
        </code>
        as the third argument instead of
        <code class="calibre21">
         begin(vec2)
        </code>
        . The output is the same as the version using
        <code class="calibre21">
         copy()
        </code>
        .
       </p>
       <pre class="calibre26" id="c20-code-0034"><code class="calibre21"><b class="calibre14">copy_backward(cbegin(vec1), cend(vec1), end(vec2));</b></code></pre>
       <p class="calibre13">
        <code class="calibre21">
         copy_if()
        </code>
        works by having an input range specified by two iterators, an output destination specified by one iterator, and a predicate (for example, a function or lambda expression). The algorithm copies all elements that satisfy the given predicate to the destination. Remember, copy does not create or extend containers; it merely replaces existing elements, so the destination should be big enough to hold all elements to be copied. Of course, after copying the elements, it might be desirable to remove the space “beyond” where the last element was copied to. To facilitate this,
        <code class="calibre21">
         copy_if()
        </code>
        returns an iterator to the one-past-the-last-copied element in the destination range. This can be used to determine how many elements should be removed from the destination container. The following example demonstrates this by copying only the even numbers to
        <code class="calibre21">
         vec2
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0035"><code class="calibre21">vector&lt;int&gt; vec1, vec2;</code>
<code class="calibre21">populateContainer(vec1);</code>
<code class="calibre21">vec2.resize(size(vec1));</code>
<code class="calibre21"><b class="calibre14">auto endIterator { copy_if(cbegin(vec1), cend(vec1),</b></code>
<code class="calibre21">         <b class="calibre14">begin(vec2), [](int i){ return i % 2 == 0; }) };</b></code>
<code class="calibre21"><b class="calibre14">vec2.erase(endIterator, end(vec2));</b></code>
<code class="calibre21">println("{:n}", vec2);</code></pre>
       <p class="calibre13">
        <code class="calibre21">
         copy_n()
        </code>
        copies
        <code class="calibre21">
         n
        </code>
        elements from the source to the destination. The first parameter of
        <code class="calibre21">
         copy_n()
        </code>
        is the start iterator. The second parameter is an integer specifying the number of elements to copy, and the third parameter is the destination iterator. The
        <code class="calibre21">
         copy_n()
        </code>
        algorithm does not perform any bounds checking, so you must make sure that the start iterator, incremented by the number of elements to copy, does not exceed the
        <code class="calibre21">
         end()
        </code>
        of the source collection or your program will have undefined behavior. Here is an example:
       </p>
       <pre class="calibre26" id="c20-code-0036"><code class="calibre21">vector&lt;int&gt; vec1, vec2;</code>
<code class="calibre21">populateContainer(vec1);</code>
<code class="calibre21">size_t tally { 0 };</code>
<code class="calibre21">print("Enter number of elements you want to copy: ");</code>
<code class="calibre21">cin &gt;&gt; tally;</code>
<code class="calibre21">tally = min(tally, size(vec1));</code>
<code class="calibre21">vec2.resize(tally);</code>
<code class="calibre21"><b class="calibre14">copy_n(cbegin(vec1), tally, begin(vec2));</b></code>
<code class="calibre21">println("{:n}", vec2);</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0027">
       </span>
       <h4 class="calibre29" id="head-4-318">
        move
       </h4>
       <p class="calibre13">
        There are two move-related algorithms:
        <code class="calibre21">
         move()
        </code>
        and
        <code class="calibre21">
         move_backward()
        </code>
        . They both use move semantics, discussed in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        . You have to provide a move assignment operator in your element classes if you want to use these algorithms on containers with elements of your own types, as demonstrated
        <span aria-label="807" class="calibre20" epub:type="pagebreak" id="Page_807" role="doc-pagebreak">
        </span>
        in the following example. The
        <code class="calibre21">
         main()
        </code>
        function creates a
        <code class="calibre21">
         vector
        </code>
        with three
        <code class="calibre21">
         MyClass
        </code>
        objects and then moves those elements from
        <code class="calibre21">
         vecSrc
        </code>
        to
        <code class="calibre21">
         vecDst
        </code>
        . Note that the code includes two different uses of
        <code class="calibre21">
         move()
        </code>
        . The
        <code class="calibre21">
         move()
        </code>
        function accepting a single argument converts an lvalue into an rvalue and is defined in
        <code class="calibre21">
         &lt;utility&gt;
        </code>
        , while
        <code class="calibre21">
         move()
        </code>
        accepting three arguments is the Standard Library
        <code class="calibre21">
         move()
        </code>
        algorithm to move elements between containers. Consult
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        for details on implementing move assignment operators and the use of the single parameter version of
        <code class="calibre21">
         std::move()
        </code>
        .
       </p>
       <pre class="calibre26" id="c20-code-0037"><code class="calibre21">class MyClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        MyClass() = default;</code>
<code class="calibre21">        MyClass(const MyClass&amp; src) = default;</code>
<code class="calibre21">        explicit MyClass(string str) : m_str { move(str) } {}</code>
<code class="calibre21">        virtual ˜MyClass() = default;</code>
<code class="calibre21"> </code>
<code class="calibre21">        <span class="color">// Move assignment operator</span></code>
<code class="calibre21">        MyClass&amp; operator=(MyClass&amp;&amp; rhs) noexcept {</code>
<code class="calibre21">            if (this == &amp;rhs) { return *this; }</code>
<code class="calibre21">            m_str = move(rhs.m_str);</code>
<code class="calibre21">            println("Move operator= (m_str={})", m_str);</code>
<code class="calibre21">            return *this;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        void setString(string str) { m_str = move(str); }</code>
<code class="calibre21">        const string&amp; getString() const { return m_str; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_str;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;MyClass&gt; vecSrc { MyClass { "a" }, MyClass { "b" }, MyClass { "c" } };</code>
<code class="calibre21">    vector&lt;MyClass&gt; vecDst(vecSrc.size());</code>
<code class="calibre21">    <b class="calibre14">move(begin(vecSrc), end(vecSrc), begin(vecDst));</b></code>
<code class="calibre21">    for (const auto&amp; c : vecDst) { print("{} ", c.getString()); }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0038"><code class="calibre21">Move operator= (m_str=a)</code>
<code class="calibre21">Move operator= (m_str=b)</code>
<code class="calibre21">Move operator= (m_str=c)</code>
<code class="calibre21">a b c</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0089">
           <b class="calibre14">
            NOTE
           </b>
           <a class="calibre5" href="c09.xhtml">
            <i class="calibre18">
             Chapter
            </i>
            9
           </a>
           <i class="calibre18">
            explains that source objects in a move operation are left in some valid but otherwise indeterminate state. For the previous example, this means you should not use the elements from
           </i>
           <code class="calibre21">
            vecSrc
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              anymore after the move operation, unless you bring them back to a determinate state, for example by calling a member function on them without any preconditions, such as
             </i>
            </i>
           </i>
           <code class="calibre21">
            setString()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c20-para-0090">
        <span aria-label="808" class="calibre20" epub:type="pagebreak" id="Page_808" role="doc-pagebreak">
        </span>
        <code class="calibre21">
         move_backward()
        </code>
        uses the same move mechanism as
        <code class="calibre21">
         move()
        </code>
        , but it moves the elements starting from the last to the first element. For both
        <code class="calibre21">
         move()
        </code>
        and
        <code class="calibre21">
         move_backward()
        </code>
        , the source and destination ranges are allowed to overlap with the same restrictions as for
        <code class="calibre21">
         copy()
        </code>
        and
        <code class="calibre21">
         copy_backward()
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0029">
       </span>
       <h4 class="calibre29" id="head-4-319">
        replace
       </h4>
       <p class="calibre13" id="c20-para-0091">
        The
        <code class="calibre21">
         replace()
        </code>
        and
        <code class="calibre21">
         replace:if()
        </code>
        algorithms replace elements in a range matching a value or predicate, respectively, with a new value. Take
        <code class="calibre21">
         replace:if()
        </code>
        as an example. Its first and second parameters specify the range of elements to process. The third parameter is a callback that returns
        <code class="calibre21">
         true
        </code>
        or
        <code class="calibre21">
         false
        </code>
        . If it returns
        <code class="calibre21">
         true
        </code>
        , the value in the container is replaced with the value given for the fourth parameter; if it returns
        <code class="calibre21">
         false
        </code>
        , it leaves the original value.
       </p>
       <p class="calibre13">
        For example, you might want to replace all odd values in a container with the value zero:
       </p>
       <pre class="calibre26" id="c20-code-0039"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"><b class="calibre14">replace:if(begin(values), end(values), [](int i){ return i % 2 != 0; }, 0);</b></code>
<code class="calibre21">println("{:n}", values);</code></pre>
       <p class="calibre13" id="c20-para-0093">
        There are also variants of
        <code class="calibre21">
         replace()
        </code>
        and
        <code class="calibre21">
         replace:if()
        </code>
        called
        <code class="calibre21">
         replace:copy()
        </code>
        and
        <code class="calibre21">
         replace:copy_if()
        </code>
        that copy the results to a different destination range. They are similar to
        <code class="calibre21">
         copy()
        </code>
        , in that the destination range must already be large enough to hold the copied elements.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-320">
        erase
       </h4>
       <p class="calibre13" id="c20-para-0094">
        As introduced in
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        ,
        <code class="calibre21">
         std::erase()
        </code>
        and
        <code class="calibre21">
         std::erase_if()
        </code>
        support almost all Standard Library containers. Officially, these operations are called
        <i class="calibre18">
         uniform container erasure
        </i>
        . The
        <code class="calibre21">
         erase()
        </code>
        function deletes all elements matching a given value from a container, while
        <code class="calibre21">
         erase_if()
        </code>
        deletes all elements matching a given predicate. These algorithms require a reference to a container, instead of a common range, and are the preferred way to erase elements from containers.
       </p>
       <p class="calibre13">
        For example, the following code snippet removes all empty strings from a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         string
        </code>
        s and uses
        <code class="calibre21">
         erase_if()
        </code>
        to do all the work:
       </p>
       <pre class="calibre26" id="c20-code-0040"><code class="calibre21">vector&lt;string&gt; values {"", "one", "", "two", "three", "four"};</code>
<code class="calibre21">println("{:n}", values);</code>
<code class="calibre21"><b class="calibre14">erase_if(values, [](const string&amp; str){ return str.empty(); });</b></code>
<code class="calibre21">println("{:n}", values);</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0041"><code class="calibre21">"", "one", "", "two", "three", "four"</code>
<code class="calibre21">"one", "two", "three", "four"</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0098">
           <b class="calibre14">
            NOTE
           </b>
           <code class="calibre21">
            std::erase()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              does not work with ordered and unordered associative containers, because these containers have a member function called
             </i>
            </i>
           </i>
           <code class="calibre21">
            erase(key)
           </code>
           <i class="calibre18">
            <i class="calibre18">
             ,
             <i class="calibre18">
              which is much more performant and should be used instead. On the other hand, the
             </i>
            </i>
           </i>
           <code class="calibre21">
            erase_if()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              function works with all containers
             </i>
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <span aria-label="809" class="calibre20" epub:type="pagebreak" id="Page_809" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0032">
       </span>
       <h4 class="calibre29" id="head-4-321">
        remove
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         erase()
        </code>
        and
        <code class="calibre21">
         erase_if()
        </code>
        algorithms discussed in the previous section have been available since C++20. Still, let's look at your options before C++20, as you will encounter them in legacy code. A first solution that you might think of is to check the documentation to see whether your container has an
        <code class="calibre21">
         erase()
        </code>
        member function and then iterate over all the elements and call
        <code class="calibre21">
         erase()
        </code>
        for each element that matches the condition. The
        <code class="calibre21">
         vector
        </code>
        is an example of a container that has such an
        <code class="calibre21">
         erase()
        </code>
        member function. However, if applied to the
        <code class="calibre21">
         vector
        </code>
        container, this solution is extremely inefficient as it will cause a lot of memory operations to keep the
        <code class="calibre21">
         vector
        </code>
        contiguous in memory, resulting in a quadratic complexity. This solution is also error-prone, because you need to be careful that you keep your iterators valid after a call to
        <code class="calibre21">
         erase()
        </code>
        . For example, here is a function that removes empty
        <code class="calibre21">
         string
        </code>
        s from a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         string
        </code>
        s without using algorithms. Note how
        <code class="calibre21">
         iter
        </code>
        is carefully manipulated inside the
        <code class="calibre21">
         for
        </code>
        loop.
       </p>
       <pre class="calibre26" id="c20-code-0042"><code class="calibre21">void removeEmptyStringsWithoutAlgorithms(vector&lt;string&gt;&amp; strings)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto iter { begin(strings) }; iter != end(strings); ) {</code>
<code class="calibre21">        if (iter-&gt;empty()) {</code>
<code class="calibre21">            iter = strings.erase(iter);</code>
<code class="calibre21">        } else {</code>
<code class="calibre21">            ++iter;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0101">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Quadratic complexity means that the running time is a function of the square of the input size, O(n
           </i>
           <sup class="calibre22">
            <i class="calibre18">
             2
            </i>
           </sup>
           <i class="calibre18">
            )
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c20-para-0102">
        This solution is inefficient and not recommended. A much better solution for this problem is the
        <i class="calibre18">
         remove-erase-idiom
        </i>
        , which runs in linear time and is explained next.
       </p>
       <p class="calibre13">
        The remove algorithms have access only to the iterator abstraction, not to the container. Thus, they cannot really remove elements from the underlying container. Instead, the algorithms work by replacing the elements that match a given value or predicate with the next element that does not match the given value or predicate. It does so using move assignments. The result is that all elements to be kept are moved toward the beginning of the range. The range becomes partitioned into two sets: the elements to be kept and the elements to be erased. An iterator is returned that points to the first element of the range of elements to be erased. Take care not to use any of the elements in that range, as they might have been moved. The only thing you must do with the returned iterator is to actually erase these elements from the container. So you first use the
        <code class="calibre21">
         remove()
        </code>
        or
        <code class="calibre21">
         remove_if()
        </code>
        algorithm, and then you must call
        <code class="calibre21">
         erase()
        </code>
        on the container to erase all the elements from the returned iterator up to the end of the range. This process is called the
        <i class="calibre18">
         remove-erase-idiom
        </i>
        . Here is an implementation of a
        <code class="calibre21">
         removeEmptyStrings()
        </code>
        function using this idiom:
       </p>
       <pre class="calibre26" id="c20-code-0043"><code class="calibre21">void removeEmptyStrings(vector&lt;string&gt;&amp; strings)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">auto it { remove_if(begin(strings), end(strings),</b></code>
<code class="calibre21">        <b class="calibre14">[](const string&amp; str){ return str.empty(); }) };</b></code>
<span aria-label="810" class="calibre20" epub:type="pagebreak" id="Page_810" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// Erase the removed elements.</span></code>
<code class="calibre21">    strings.erase(it, end(strings));</code>
<code class="calibre21">}</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0105">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            When using the remove-erase-idiom, make sure not to forget the second argument to
           </i>
           <code class="calibre21">
            erase()
           </code>
           <i class="calibre18">
            ! If you forget this second argument
           </i>
           ,
           <code class="calibre21">
            erase()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              will erase only a single element from the container, that is, the element referred to by the iterator passed as the first argument
             </i>
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        The
        <code class="calibre21">
         remove_copy()
        </code>
        and
        <code class="calibre21">
         remove_copy_if()
        </code>
        variations of
        <code class="calibre21">
         remove()
        </code>
        and
        <code class="calibre21">
         remove_if()
        </code>
        do not change the source range. Instead, they copy all kept elements to a different destination range. They are similar to
        <code class="calibre21">
         copy()
        </code>
        , in that the destination range must already be large enough to hold the new elements.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0107">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            The
           </i>
           <code class="calibre21">
            remove()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              family of functions are stable; i.e., they maintain the order of elements remaining in the container even while moving the retained elements toward the beginning
             </i>
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c20-para-0108">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            It's recommended to use the
           </i>
           <code class="calibre21">
            std::erase_if()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              and
             </i>
            </i>
           </i>
           <code class="calibre21">
            std::erase()
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              algorithms (or the
             </i>
            </i>
           </i>
           <code class="calibre21">
            erase(key)
           </code>
           <i class="calibre18">
            <i class="calibre18">
             <i class="calibre18">
              member function for associative containers) over the remove-erase-idiom, and definitely over handwritten loops
             </i>
             .
            </i>
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0037">
       </span>
       <h4 class="calibre29" id="head-4-322">
        unique
       </h4>
       <p class="calibre13" id="c20-para-0109">
        The
        <code class="calibre21">
         unique()
        </code>
        algorithm is a special case of
        <code class="calibre21">
         remove()
        </code>
        that removes all duplicate contiguous elements. The
        <code class="calibre21">
         list
        </code>
        container provides its own
        <code class="calibre21">
         unique()
        </code>
        member function that implements the same semantics. You should generally use
        <code class="calibre21">
         unique()
        </code>
        on sorted sequences, but nothing prevents you from running it on unsorted sequences.
       </p>
       <p class="calibre13" id="c20-para-0110">
        <code class="calibre21">
         unique()
        </code>
        works in a similar way as
        <code class="calibre21">
         remove()
        </code>
        : it moves all elements to be kept to the front of the range and returns an iterator that points to the first element of the range of elements to be erased. As with the remove-erase-idiom, calling
        <code class="calibre21">
         unique()
        </code>
        must be followed by a call to
        <code class="calibre21">
         erase()
        </code>
        .
       </p>
       <p class="calibre13" id="c20-para-0111">
        The basic form of
        <code class="calibre21">
         unique()
        </code>
        runs in place, but there is also a variant of the algorithm called
        <code class="calibre21">
         unique_copy()
        </code>
        that copies its results to a new destination range.
       </p>
       <p class="calibre13" id="c20-para-0112">
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        shows an example of the
        <code class="calibre21">
         list::unique()
        </code>
        algorithm in the section “
        <a class="calibre5" href="c18_split_000.xhtml#c18-sec-0067">
         list Example: Determining Enrollment
        </a>
        ,” so an example of the general form is omitted here.
       </p>
      </section>
      <span aria-label="811" class="calibre20" epub:type="pagebreak" id="Page_811" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0038">
       </span>
       <h4 class="calibre29" id="head-4-323">
        shuffle
       </h4>
       <p class="calibre13">
        <code class="calibre21">
         shuffle()
        </code>
        rearranges the elements of a range in a random order with a linear complexity. It's useful for implementing tasks like shuffling a deck of cards.
        <code class="calibre21">
         shuffle()
        </code>
        requires a start and end iterator for the range that you want to shuffle and a uniform random number generator object that specifies how random numbers should be generated. Here is an example (details on how to use random number generation engines and how to “seed” them are explained in
        <a class="calibre5" href="c23.xhtml">
         Chapter 23
        </a>
        , “Random Number Facilities”):
       </p>
       <pre class="calibre26" id="c20-code-0044"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9 };</code>
<code class="calibre21"> </code>
<code class="calibre21">random_device seeder;</code>
<code class="calibre21">default_random_engine generator { seeder() };</code>
<code class="calibre21"> </code>
<code class="calibre21">for (int i { 0 }; i &lt; 6; ++i) {</code>
<code class="calibre21">    <b class="calibre14">shuffle(begin(values), end(values), generator);</b></code>
<code class="calibre21">    println("{:n}", values); </code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Here is some possible output:
       </p>
       <pre class="calibre26" id="c20-code-0045"><code class="calibre21">8, 6, 7, 5, 4, 1, 2, 9, 3</code>
<code class="calibre21">4, 1, 6, 2, 3, 7, 5, 9, 8</code>
<code class="calibre21">1, 4, 2, 5, 6, 8, 7, 3, 9</code>
<code class="calibre21">8, 4, 2, 7, 5, 9, 1, 6, 3</code>
<code class="calibre21">8, 9, 1, 7, 4, 5, 2, 6, 3</code>
<code class="calibre21">1, 7, 8, 5, 4, 3, 9, 6, 2</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0039">
       </span>
       <h4 class="calibre29" id="head-4-324">
        sample
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         sample()
        </code>
        algorithm returns a selection of
        <i class="calibre18">
         n
        </i>
        randomly chosen elements from a given source range and stores them in a destination range. It requires five parameters:
       </p>
       <ul class="check" id="c20-list-0004">
        <li class="calibre9" id="c20-li-0011">
         A begin and end iterator of the range to sample
        </li>
        <li class="calibre9" id="c20-li-0012">
         A begin iterator of the destination range where to store the randomly selected elements
        </li>
        <li class="calibre9" id="c20-li-0013">
         The number of elements to select
        </li>
        <li class="calibre9" id="c20-li-0014">
         A random number generation engine
        </li>
       </ul>
       <p class="calibre13">
        Here is an example (details on how to use random number generation engines and how to “seed” them are explained in
        <a class="calibre5" href="c23.xhtml">
         Chapter 23
        </a>
        ):
       </p>
       <pre class="calibre26" id="c20-code-0046"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9 };</code>
<code class="calibre21">const size_t numberOfSamples { 5 };</code>
<code class="calibre21">vector&lt;int&gt; samples(numberOfSamples);</code>
<code class="calibre21"> </code>
<code class="calibre21">random_device seeder;</code>
<code class="calibre21">default_random_engine generator { seeder() };</code>
<code class="calibre21"> </code>
<code class="calibre21">for (int i { 0 }; i &lt; 6; ++i) {</code>
<code class="calibre21">    <b class="calibre14">sample(cbegin(values), cend(values), begin(samples),</b></code>
<code class="calibre21">        <b class="calibre14">numberOfSamples, generator);</b></code>
<code class="calibre21">    println("{:n}", samples);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="812" class="calibre20" epub:type="pagebreak" id="Page_812" role="doc-pagebreak">
        </span>
        Here is some possible output:
       </p>
       <pre class="calibre26" id="c20-code-0047"><code class="calibre21">1, 4, 7, 8, 9</code>
<code class="calibre21">1, 3, 4, 7, 9</code>
<code class="calibre21">2, 3, 4, 5, 7</code>
<code class="calibre21">3, 5, 6, 7, 9</code>
<code class="calibre21">1, 2, 3, 6, 7</code>
<code class="calibre21">1, 2, 4, 5, 8</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0040">
       </span>
       <h4 class="calibre29" id="head-4-325">
        reverse
       </h4>
       <p class="calibre13" id="c20-para-0118">
        The
        <code class="calibre21">
         reverse()
        </code>
        algorithm reverses the order of the elements in a range. The first element in the range is swapped with the last, the second with the second-to-last, and so on.
       </p>
       <p class="calibre13" id="c20-para-0119">
        The basic form of
        <code class="calibre21">
         reverse()
        </code>
        runs in place and requires two arguments: a start and end iterator for the range. There is also a variant of the algorithm called
        <code class="calibre21">
         reverse_copy()
        </code>
        that copies its results to a new destination range and requires three arguments: a start and end iterator for the source range, and a start iterator for the destination range. The destination range must already be large enough to hold the new elements.
       </p>
       <p class="calibre13">
        Here is an example using
        <code class="calibre21">
         reverse()
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0048"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"><b class="calibre14">reverse(begin(values), end(values));</b></code>
<code class="calibre21">println("{:n}", values);</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0041">
       </span>
       <h4 class="calibre29" id="head-4-326">
        Shifting Elements
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         shift_left()
        </code>
        and
        <code class="calibre21">
         shift_right()
        </code>
        algorithms shift elements in a given range by moving them to their new position.
        <code class="calibre21">
         shift_left()
        </code>
        returns an iterator to the end of the new range, while
        <code class="calibre21">
         shift_right()
        </code>
        returns an iterator to the beginning of the new range. After calling either algorithm, you must use the returned iterator in a call to
        <code class="calibre21">
         erase()
        </code>
        to delete elements that fell off either end of the range. Here is an example:
       </p>
       <pre class="calibre26" id="c20-code-0049"><code class="calibre21">vector values { 11, 22, 33, 44, 55 };</code>
<code class="calibre21">println("{:n}", values);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Shift elements to the left by 2 positions.</span></code>
<code class="calibre21"><b class="calibre14">auto newEnd { shift_left(begin(values), end(values), 2) };</b></code>
<code class="calibre21"><span class="color">// Resize the vector to its proper size.</span></code>
<code class="calibre21">values.erase(newEnd, end(values));</code>
<code class="calibre21">println("{:n}", values);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Shift elements to the right by 2 positions.</span></code>
<code class="calibre21"><b class="calibre14">auto newBegin { shift_right(begin(values), end(values), 2) };</b></code>
<code class="calibre21"><span class="color">// Resize the vector to its proper size.</span></code>
<code class="calibre21">values.erase(begin(values), newBegin);</code>
<code class="calibre21">println("{:n}", values);</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0050"><code class="calibre21">11, 22, 33, 44, 55</code>
<code class="calibre21">33, 44, 55</code>
<code class="calibre21">33</code></pre>
      </section>
     </section>
     <span aria-label="813" class="calibre20" epub:type="pagebreak" id="Page_813" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0042">
      </span>
      <h3 class="calibre27" id="head-3-441">
       Operational Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0123">
       There are only two algorithms in this category:
       <code class="calibre21">
        for_each()
       </code>
       and
       <code class="calibre21">
        for_each_n()
       </code>
       . They execute a callback on each element of a range,
       <code class="calibre21">
        for_each()
       </code>
       , or on the first
       <i class="calibre18">
        n
       </i>
       elements of a range,
       <code class="calibre21">
        for_each_n()
       </code>
       . The callback can modify elements in the range if the given iterator type is non-
       <code class="calibre21">
        const
       </code>
       . The algorithms are mentioned here so you know they exist; however, it's often easier and more readable to use a simple range-based
       <code class="calibre21">
        for
       </code>
       loop instead.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0043">
       </span>
       <h4 class="calibre29" id="head-4-327">
        for_each
       </h4>
       <p class="calibre13">
        The following is an example using a generic lambda expression, printing the elements from a
        <code class="calibre21">
         map
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0051"><code class="calibre21">map&lt;int, int&gt; myMap { { 4, 40 }, { 5, 50 }, { 6, 60 } };</code>
<code class="calibre21"><b class="calibre14">for_each(cbegin(myMap), cend(myMap), [](const auto&amp; p)</b></code>
<code class="calibre21">    <b class="calibre14">{ println("{} -&gt; {}", p.first, p.second); });</b></code></pre>
       <p class="calibre13">
        The type of
        <code class="calibre21">
         p
        </code>
        is
        <code class="calibre21">
         const pair&lt;int, int&gt;&amp;
        </code>
        . The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0052"><code class="calibre21">4 -&gt; 40</code>
<code class="calibre21">5 -&gt; 50</code>
<code class="calibre21">6 -&gt; 60</code></pre>
       <p class="calibre13">
        The following example shows how to use the
        <code class="calibre21">
         for_each()
        </code>
        algorithm and a lambda expression to calculate the sum and the product of a range of elements at the same time. The lambda expression explicitly captures only those variables it needs. It captures them by reference; otherwise, changes made to
        <code class="calibre21">
         sum
        </code>
        and
        <code class="calibre21">
         product
        </code>
        in the lambda expression would not be visible outside the lambda.
       </p>
       <pre class="calibre26" id="c20-code-0053"><code class="calibre21">vector&lt;int&gt; myVector;</code>
<code class="calibre21">populateContainer(myVector);</code>
<code class="calibre21"> </code>
<code class="calibre21">int sum { 0 };</code>
<code class="calibre21">int product { 1 };</code>
<code class="calibre21"><b class="calibre14">for_each(cbegin(myVector), cend(myVector),</b></code>
<code class="calibre21">    <b class="calibre14">[&amp;sum, &amp;product](int i){</b></code>
<code class="calibre21">        <b class="calibre14">sum += i;</b></code>
<code class="calibre21">        <b class="calibre14">product *= i;</b></code>
<code class="calibre21"><b class="calibre14">});</b></code>
<code class="calibre21">println("The sum is {}", sum);</code>
<code class="calibre21">println("The product is {}", product);</code></pre>
       <p class="calibre13">
        This example can also be written with a functor in which you accumulate information that you can retrieve after
        <code class="calibre21">
         for_each()
        </code>
        has finished processing all the elements. For example, you can calculate both the sum and product of the elements in one pass by writing a functor
        <code class="calibre21">
         SumAndProduct
        </code>
        that tracks both at the same time:
       </p>
       <pre class="calibre26" id="c20-code-0054"><code class="calibre21">class SumAndProduct</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void operator()(int value)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            m_sum += value;</code>
<code class="calibre21">            m_product *= value;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<span aria-label="814" class="calibre20" epub:type="pagebreak" id="Page_814" role="doc-pagebreak"></span><code class="calibre21">        int getSum() const { return m_sum; }</code>
<code class="calibre21">        int getProduct() const { return m_product; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_sum { 0 };</code>
<code class="calibre21">        int m_product { 1 };</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;int&gt; myVector;</code>
<code class="calibre21">    populateContainer(myVector);</code>
<code class="calibre21"> </code>
<code class="calibre21">    SumAndProduct calculator;</code>
<code class="calibre21">    <b class="calibre14">calculator = for_each(cbegin(myVector), cend(myVector), calculator);</b></code>
<code class="calibre21">    println("The sum is {}", calculator.getSum());</code>
<code class="calibre21">    println("The product is {}", calculator.getProduct());</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c20-para-0128">
        You might be tempted to ignore the return value of
        <code class="calibre21">
         for_each()
        </code>
        yet still try to read information from
        <code class="calibre21">
         calculator
        </code>
        after the algorithm is finished. However, that doesn't work because
        <code class="calibre21">
         for_each()
        </code>
        copies the functor, and at the end, this copy is returned from the call. You must capture the return value to ensure correct behavior.
       </p>
       <p class="calibre13">
        Another option is to pass
        <code class="calibre21">
         calculator
        </code>
        by reference using
        <code class="calibre21">
         std::ref()
        </code>
        , see earlier in this chapter:
       </p>
       <pre class="calibre26" id="c20-code-0055"><code class="calibre21"><b class="calibre14">for_each(cbegin(myVector), cend(myVector), ref(calculator));</b></code></pre>
       <p class="calibre13">
        A final point about
        <code class="calibre21">
         for_each()
        </code>
        (that also applies to
        <code class="calibre21">
         for_each_n()
        </code>
        discussed in the next section) is that the callback is allowed to have a reference-to-non-
        <code class="calibre21">
         const
        </code>
        as parameter and modify it. That has the effect of changing values in the actual range. Here is an example:
       </p>
       <pre class="calibre26" id="c20-code-0056"><code class="calibre21">vector values { 11, 22, 33, 44 };</code>
<code class="calibre21"><span class="color">// Double each element in the values vector.</span></code>
<code class="calibre21"><b class="calibre14">for_each(begin(values), end(values), [](auto&amp; value) { value *= 2; });</b></code>
<code class="calibre21">println("{:n}", values);</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0044">
       </span>
       <h4 class="calibre29" id="head-4-328">
        for_each_n
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         for_each_n()
        </code>
        algorithm requires a begin iterator of the range, the number of elements to iterate over, n, and a callback. It returns an iterator equal to begin + n. As usual, it does not perform any bounds checking. Here is an example that only iterates over the first two elements of a
        <code class="calibre21">
         map
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0057"><code class="calibre21">map&lt;int, int&gt; myMap { { 4, 40 }, { 5, 50 }, { 6, 60 } };</code>
<code class="calibre21"><b class="calibre14">for_each_n(cbegin(myMap), 2, [](const auto&amp; p)</b></code>
<code class="calibre21">    <b class="calibre14">{ println("{} -&gt; {}", p.first, p.second); });</b></code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0045">
      </span>
      <h3 class="calibre27" id="head-3-442">
       Partition Algorithms
      </h3>
      <p class="calibre13">
       <code class="calibre21">
        partition_copy()
       </code>
       copies elements from a source to two different destinations. The destination for each element is selected based on the result of a predicate, either
       <code class="calibre21">
        true
       </code>
       or
       <code class="calibre21">
        false
       </code>
       . The value returned by
       <code class="calibre21">
        partition_copy()
       </code>
       is a pair of iterators: iterators referring to one-past-the-last-copied element in the first and second destination range. These returned iterators can be used in combination with
       <code class="calibre21">
        erase()
       </code>
       to remove excess elements from the two destination ranges, just as in the earlier
       <code class="calibre21">
        copy_if()
       </code>
       <span aria-label="815" class="calibre20" epub:type="pagebreak" id="Page_815" role="doc-pagebreak">
       </span>
       example. The following code snippet asks the user to enter a number of integers, which are then
       <i class="calibre18">
        partitioned
       </i>
       into two destination
       <code class="calibre21">
        vector
       </code>
       s: one for the even numbers and one for the odd numbers:
      </p>
      <pre class="calibre26" id="c20-code-0058"><code class="calibre21">vector&lt;int&gt; values, vecOdd, vecEven;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21">vecOdd.resize(size(values));</code>
<code class="calibre21">vecEven.resize(size(values));</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">auto pairIters { partition_copy(cbegin(values), cend(values),</b></code>
<code class="calibre21">    <b class="calibre14">begin(vecEven), begin(vecOdd),</b></code>
<code class="calibre21">    <b class="calibre14">[](int i){ return i % 2 == 0; }) };</b></code>
<code class="calibre21"> </code>
<code class="calibre21">vecEven.erase(pairIters.first, end(vecEven));</code>
<code class="calibre21">vecOdd.erase(pairIters.second, end(vecOdd));</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Even numbers: {:n}", vecEven);</code>
<code class="calibre21">println("Odd numbers: {:n}", vecOdd);</code></pre>
      <p class="calibre13">
       The output can be as follows:
      </p>
      <pre class="calibre26" id="c20-code-0059"><code class="calibre21">Enter a number (0 to stop): 11</code>
<code class="calibre21">Enter a number (0 to stop): 22</code>
<code class="calibre21">Enter a number (0 to stop): 33</code>
<code class="calibre21">Enter a number (0 to stop): 44</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Even numbers: 22, 44</code>
<code class="calibre21">Odd numbers: 11, 33</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        partition()
       </code>
       algorithm sorts a sequence such that all elements for which a predicate returns
       <code class="calibre21">
        true
       </code>
       are before all elements for which it returns
       <code class="calibre21">
        false
       </code>
       , without preserving the original order of the elements within each partition. The following example demonstrates how to partition a
       <code class="calibre21">
        vector
       </code>
       into all even numbers followed by all odd numbers:
      </p>
      <pre class="calibre26" id="c20-code-0060"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"><b class="calibre14">partition(begin(values), end(values), [](int i){ return i % 2 == 0; });</b></code>
<code class="calibre21">println("Partitioned result: {:n}", values);</code></pre>
      <p class="calibre13">
       The output can be as follows:
      </p>
      <pre class="calibre26" id="c20-code-0061"><code class="calibre21">Enter a number (0 to stop): 55</code>
<code class="calibre21">Enter a number (0 to stop): 44</code>
<code class="calibre21">Enter a number (0 to stop): 33</code>
<code class="calibre21">Enter a number (0 to stop): 22</code>
<code class="calibre21">Enter a number (0 to stop): 11</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Partitioned result: 22, 44, 33, 55, 11</code></pre>
      <p class="calibre13" id="c20-para-0136">
       A few more partition algorithms are available as well. See
       <a class="calibre5" href="c16.xhtml">
        Chapter 16
       </a>
       for a list.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-443">
       Sorting Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0137">
       The Standard Library provides several variations of sorting algorithms. A sorting algorithm reorders the contents of a container such that an ordering is maintained between sequential elements of the collection. Thus, it applies only to sequential collections. Sorting is not relevant for ordered
       <span aria-label="816" class="calibre20" epub:type="pagebreak" id="Page_816" role="doc-pagebreak">
       </span>
       associative containers because they already maintain elements in a sorted order. Sorting is not relevant for the unordered associative containers either, because they have no concept of ordering. Some containers, such as
       <code class="calibre21">
        list
       </code>
       and
       <code class="calibre21">
        forward_list
       </code>
       , provide their own sorting member functions, because these member functions can be implemented more efficiently than a generic sorting mechanism. Consequently, the generic sorting algorithms are most useful for
       <code class="calibre21">
        vector
       </code>
       s,
       <code class="calibre21">
        deque
       </code>
       s,
       <code class="calibre21">
        array
       </code>
       s, and C-style arrays.
      </p>
      <p class="calibre13" id="c20-para-0138">
       The
       <code class="calibre21">
        sort()
       </code>
       algorithm sorts a range of elements in
       <i class="calibre18">
        O
       </i>
       (
       <i class="calibre18">
        N
       </i>
       log
       <i class="calibre18">
        N
       </i>
       ) time in general. Following the application of
       <code class="calibre21">
        sort()
       </code>
       to a range, the elements in the range are in nondecreasing order (lowest to highest), according to
       <code class="calibre21">
        operator&lt;
       </code>
       . If you don't like that order, you can specify a different comparator, such as
       <code class="calibre21">
        greater
       </code>
       .
      </p>
      <p class="calibre13" id="c20-para-0139">
       A variant of
       <code class="calibre21">
        sort()
       </code>
       , called
       <code class="calibre21">
        stable_sort()
       </code>
       , maintains the relative order of equal elements in a range, but it is less efficient than
       <code class="calibre21">
        sort()
       </code>
       .
      </p>
      <p class="calibre13">
       Here is an example of
       <code class="calibre21">
        sort()
       </code>
       using a transparent
       <code class="calibre21">
        greater&lt;&gt;
       </code>
       comparator:
      </p>
      <pre class="calibre26" id="c20-code-0062"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"><b class="calibre14">sort(begin(values), end(values), greater&lt;&gt;{});</b></code></pre>
      <p class="calibre13" id="c20-para-0141">
       There is also
       <code class="calibre21">
        is_sorted()
       </code>
       , returning
       <code class="calibre21">
        true
       </code>
       if a given range is sorted, and
       <code class="calibre21">
        is_sorted_until()
       </code>
       , returning an iterator such that everything before this iterator is sorted.
      </p>
      <p class="calibre13" id="c20-para-0142">
       <code class="calibre21">
        nth_element()
       </code>
       is a powerful
       <i class="calibre18">
        selection algorithm
       </i>
       . Given a range of elements and an iterator to the
       <i class="calibre18">
        n
       </i>
       <sup class="calibre22">
        th
       </sup>
       element in that range, the algorithm rearranges the elements in the range such that the element in the position pointed to by
       <i class="calibre18">
        n
       </i>
       <sup class="calibre22">
        th
       </sup>
       is the element that would be in that position if the whole range were sorted. Additionally, it rearranges all elements such that all elements preceding the
       <i class="calibre18">
        n
       </i>
       <sup class="calibre22">
        th
       </sup>
       element are less than the new
       <i class="calibre18">
        n
       </i>
       <sup class="calibre22">
        th
       </sup>
       element, and the ones following it are greater than the new
       <i class="calibre18">
        n
       </i>
       <sup class="calibre22">
        th
       </sup>
       element. The interesting thing about this algorithm is that it does all this in linear time,
       <i class="calibre18">
        O
       </i>
       (
       <i class="calibre18">
        n
       </i>
       ). Instead of using
       <code class="calibre21">
        nth_element()
       </code>
       , you could also just sort the whole range and then retrieve the data you are interested in, but that would result in a complexity that is linear logarithmic,
       <i class="calibre18">
        O
       </i>
       (
       <i class="calibre18">
        n
       </i>
       log
       <i class="calibre18">
        n
       </i>
       ).
      </p>
      <p class="calibre13">
       All this sounds complicated, so let's see this algorithm in action. A first example is to find the third largest element in a given range. It assumes the user enters at least three values.
      </p>
      <pre class="calibre26" id="c20-code-0063"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"><span class="color">// Find the third largest value.</span></code>
<code class="calibre21"><b class="calibre14">nth_element(begin(values), begin(values) + 2, end(values), greater&lt;&gt;{});</b></code>
<code class="calibre21">println("3rd largest value: {}", values[2]);</code></pre>
      <p class="calibre13">
       Another example is to get the five largest elements from a range in sorted order. It assumes the user enters at least five values.
      </p>
      <pre class="calibre26" id="c20-code-0064"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"><span class="color">// Get the 5 largest elements in sorted order.</span></code>
<code class="calibre21"><b class="calibre14">nth_element(begin(values), begin(values) + 4, end(values), greater&lt;&gt;{});</b></code>
<code class="calibre21"><span class="color">// nth_element() has partitioned the elements, now sort the first subrange.</span></code>
<code class="calibre21"><b class="calibre14">sort(begin(values), begin(values) + 5);</b></code>
<code class="calibre21"><span class="color">// And finally, output the sorted subrange.</span></code>
<code class="calibre21">for_each_n(begin(values), 5, [](const auto&amp; element) { print("{}  ", element); });</code></pre>
     </section>
     <span aria-label="817" class="calibre20" epub:type="pagebreak" id="Page_817" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-444">
       Binary Search Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0145">
       There are several search algorithms that work only on sequences that are sorted or that are at least partitioned on the element that is searched for. These algorithms are
       <code class="calibre21">
        binary_search()
       </code>
       ,
       <code class="calibre21">
        lower_bound()
       </code>
       ,
       <code class="calibre21">
        upper_bound()
       </code>
       , and
       <code class="calibre21">
        equal_range()
       </code>
       . Note that the associative containers, such as
       <code class="calibre21">
        map
       </code>
       and
       <code class="calibre21">
        set
       </code>
       , have equivalent member functions that you should use instead. See
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       for an example on how to use these member functions on such containers.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        lower_bound()
       </code>
       algorithm finds the first element in a sorted range not less than (greater or equal to) a given value. It is often used to find at which position in a sorted
       <code class="calibre21">
        vector
       </code>
       a new value should be inserted so that the
       <code class="calibre21">
        vector
       </code>
       remains sorted. Here is an example:
      </p>
      <pre class="calibre26" id="c20-code-0065"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Sort the container</span></code>
<code class="calibre21">sort(begin(values), end(values));</code>
<code class="calibre21">println("Sorted vector: {:n}", values);</code>
<code class="calibre21"> </code>
<code class="calibre21">while (true) {</code>
<code class="calibre21">    int number;</code>
<code class="calibre21">    print("Enter a number to insert (0 to stop): ");</code>
<code class="calibre21">    cin &gt;&gt; number;</code>
<code class="calibre21">    if (number == 0) { break; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <b class="calibre14">auto iter { lower_bound(begin(values), end(values), number) };</b></code>
<code class="calibre21">    <b class="calibre14">values.insert(iter, number);</b></code>
<code class="calibre21">    println("New vector: {:n}", values);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        binary_search()
       </code>
       algorithm finds a matching element in logarithmic time instead of linear time. It requires a start and end iterator specifying the range to search in, a value to search, and optionally a comparator callback. It returns
       <code class="calibre21">
        true
       </code>
       if the value is found in the specified range,
       <code class="calibre21">
        false
       </code>
       otherwise. Binary search requires the range to be sorted and works by first comparing the middle element of the range. Depending on whether that middle element is greater than or less than the value to search, it continues by comparing the middle element of the left or right half of the range, respectively. This continues until the element is found. Basically, on each iteration, the range is halved, hence the logarithmic complexity. The following example demonstrates this algorithm:
      </p>
      <pre class="calibre26" id="c20-code-0066"><code class="calibre21">vector&lt;int&gt; values;</code>
<code class="calibre21">populateContainer(values);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Sort the container</span></code>
<code class="calibre21">sort(begin(values), end(values));</code>
<code class="calibre21"> </code>
<code class="calibre21">while (true) {</code>
<code class="calibre21">    print("Enter a number to find (0 to stop): ");</code>
<code class="calibre21">    int number;</code>
<code class="calibre21">    cin &gt;&gt; number;</code>
<code class="calibre21">    if (number == 0) { break; }</code>
<code class="calibre21">    <b class="calibre14">if (binary_search(cbegin(values), cend(values), number)) {</b></code>
<code class="calibre21">        println("That number is in the vector.");</code>
<span aria-label="818" class="calibre20" epub:type="pagebreak" id="Page_818" role="doc-pagebreak"></span><code class="calibre21">    } else {</code>
<code class="calibre21">        println("That number is not in the vector.");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0048">
      </span>
      <h3 class="calibre27" id="head-3-445">
       Set Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0148">
       The set algorithms work on any sorted range. The
       <code class="calibre21">
        includes()
       </code>
       algorithm implements standard subset determination, checking whether all the elements of one sorted range are included in another sorted range, in any order.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        set_union()
       </code>
       ,
       <code class="calibre21">
        set_intersection()
       </code>
       ,
       <code class="calibre21">
        set_difference()
       </code>
       , and
       <code class="calibre21">
        set_symmetric_difference()
       </code>
       algorithms implement the standard semantics of those operations. In set theory, the result of a union is all the elements in either set. The result of an intersection is all the elements that are in both sets. The result of a difference is all the elements in the first set but not the second. The result of a symmetric difference is the “exclusive or” of sets: all the elements in one, but not both, sets.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0150">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Make sure that your result range is large enough to hold the result of the operations. For
          </i>
          <code class="calibre21">
           set_union()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           set_symmetric_difference()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            , the result is at most the sum of the sizes of the two input ranges. For
           </i>
          </i>
          <code class="calibre21">
           set_intersection()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            ,
            <i class="calibre18">
             the result is at most the size of the smallest input range, and for
            </i>
           </i>
          </i>
          <code class="calibre21">
           set_difference()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             it's at most the size of the first range
            </i>
            .
           </i>
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0151">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           You can't use common ranges from associative containers, including
           <code class="calibre21">
            set
           </code>
           s, to store the results because they don't allow changes to their keys
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Let's look at these set algorithms in action. First, a constrained
       <code class="calibre21">
        DumpRange()
       </code>
       function template is defined to write elements of a given range to the standard output stream; it is implemented as follows.
       <code class="calibre21">
        ranges::subrange()
       </code>
       converts a common range, given as a pair of iterators, to a range, which can then be passed to
       <code class="calibre21">
        println()
       </code>
       .
      </p>
      <pre class="calibre26" id="c20-code-0067"><code class="calibre21">template &lt;forward_iterator Iterator&gt;</code>
<code class="calibre21">void DumpRange(string_view message, Iterator begin, Iterator end)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("{}{:n}", message, ranges::subrange(begin, end));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       With this helper function defined, here are examples on using the set algorithms:
      </p>
      <pre class="calibre26" id="c20-code-0068"><code class="calibre21">vector&lt;int&gt; vec1, vec2, result;</code>
<code class="calibre21">println("Enter elements for set 1:");</code>
<code class="calibre21">populateContainer(vec1);</code>
<code class="calibre21">println("Enter elements for set 2:");</code>
<code class="calibre21">populateContainer(vec2);</code>
<code class="calibre21"> </code>
<span aria-label="819" class="calibre20" epub:type="pagebreak" id="Page_819" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// set algorithms require sorted ranges</span></code>
<code class="calibre21">sort(begin(vec1), end(vec1));</code>
<code class="calibre21">sort(begin(vec2), end(vec2));</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Set 1: {:n}", vec1);</code>
<code class="calibre21">println("Set 2: {:n}", vec2);</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">if (includes(cbegin(vec1), cend(vec1), cbegin(vec2), cend(vec2))) {</b></code>
<code class="calibre21">    println("The second set is a subset of the first.");</code>
<code class="calibre21">}</code>
<code class="calibre21"><b class="calibre14">if (includes(cbegin(vec2), cend(vec2), cbegin(vec1), cend(vec1))) {</b></code>
<code class="calibre21">    println("The first set is a subset of the second");</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">result.resize(size(vec1) + size(vec2));</code>
<code class="calibre21"><b class="calibre14">auto newEnd { set_union(cbegin(vec1), cend(vec1), cbegin(vec2),</b></code>
<code class="calibre21">    <b class="calibre14">cend(vec2), begin(result)) };</b></code>
<code class="calibre21">DumpRange("The union is: ", begin(result), newEnd);</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">newEnd = set_intersection(cbegin(vec1), cend(vec1), cbegin(vec2),</b></code>
<code class="calibre21">    <b class="calibre14">cend(vec2), begin(result));</b></code>
<code class="calibre21">DumpRange("The intersection is: ", begin(result), newEnd);</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">newEnd = set_difference(cbegin(vec1), cend(vec1), cbegin(vec2),</b></code>
<code class="calibre21">    <b class="calibre14">cend(vec2), begin(result));</b></code>
<code class="calibre21">DumpRange("The difference between set 1 and 2 is: ", begin(result), newEnd);</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">newEnd = set_symmetric_difference(cbegin(vec1), cend(vec1),</b></code>
<code class="calibre21">    <b class="calibre14">cbegin(vec2), cend(vec2), begin(result));</b></code>
<code class="calibre21">DumpRange("The symmetric difference is: ", begin(result), newEnd);</code></pre>
      <p class="calibre13">
       Here is a sample run of the program:
      </p>
      <pre class="calibre26" id="c20-code-0069"><code class="calibre21">Enter elements for set 1:</code>
<code class="calibre21">Enter a number (0 to stop): 5</code>
<code class="calibre21">Enter a number (0 to stop): 6</code>
<code class="calibre21">Enter a number (0 to stop): 7</code>
<code class="calibre21">Enter a number (0 to stop): 8</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Enter elements for set 2:</code>
<code class="calibre21">Enter a number (0 to stop): 8</code>
<code class="calibre21">Enter a number (0 to stop): 9</code>
<code class="calibre21">Enter a number (0 to stop): 10</code>
<code class="calibre21">Enter a number (0 to stop): 0</code>
<code class="calibre21">Set 1: 5, 6, 7, 8</code>
<code class="calibre21">Set 2: 8, 9, 10</code>
<code class="calibre21">The union is: 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">The intersection is: 8</code>
<code class="calibre21">The difference between set 1 and set 2 is: 5, 6, 7</code>
<code class="calibre21">The symmetric difference is: 5, 6, 7, 9, 10</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        merge()
       </code>
       algorithm allows you to merge two sorted ranges together, while maintaining the sorted order. The result is a sorted range containing all the elements of both source ranges. It works in linear time. The following parameters are required:
       <span aria-label="820" class="calibre20" epub:type="pagebreak" id="Page_820" role="doc-pagebreak">
       </span>
      </p>
      <ul class="check" id="c20-list-0005">
       <li class="calibre9" id="c20-li-0015">
        Start and end iterator of the first source range
       </li>
       <li class="calibre9" id="c20-li-0016">
        Start and end iterator of the second source range
       </li>
       <li class="calibre9" id="c20-li-0017">
        Start iterator of the destination range
       </li>
       <li class="calibre9" id="c20-li-0018">
        Optionally, a comparator callback
       </li>
      </ul>
      <p class="calibre13">
       Without
       <code class="calibre21">
        merge()
       </code>
       , you could still achieve the same effect by concatenating the two ranges and applying
       <code class="calibre21">
        sort()
       </code>
       to the result, but that would be less efficient,
       <i class="calibre18">
        O
       </i>
       (
       <i class="calibre18">
        N
       </i>
       log
       <i class="calibre18">
        N
       </i>
       ) instead of the linear complexity of
       <code class="calibre21">
        merge()
       </code>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0157">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Always ensure that you supply a big enough destination range to store the result of the merge!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       The following example demonstrates
       <code class="calibre21">
        merge()
       </code>
       :
      </p>
      <pre class="calibre26" id="c20-code-0070"><code class="calibre21">vector&lt;int&gt; vectorOne, vectorTwo, vectorMerged;</code>
<code class="calibre21">println("Enter values for first vector:");</code>
<code class="calibre21">populateContainer(vectorOne);</code>
<code class="calibre21">println("Enter values for second vector:");</code>
<code class="calibre21">populateContainer(vectorTwo);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Sort both containers</span></code>
<code class="calibre21">sort(begin(vectorOne), end(vectorOne));</code>
<code class="calibre21">sort(begin(vectorTwo), end(vectorTwo));</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Make sure the destination vector is large enough to hold the values</span></code>
<code class="calibre21"><span class="color">// from both source vectors.</span></code>
<code class="calibre21">vectorMerged.resize(size(vectorOne) + size(vectorTwo));</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">merge(cbegin(vectorOne), cend(vectorOne),</b></code>
<code class="calibre21">      <b class="calibre14">cbegin(vectorTwo), cend(vectorTwo), begin(vectorMerged));</b></code>
<code class="calibre21"> </code>
<code class="calibre21">println("Merged vector: {:n}", vectorMerged);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0052">
      </span>
      <h3 class="calibre27" id="head-3-446">
       Minimum/Maximum Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0159">
       The
       <code class="calibre21">
        min()
       </code>
       and
       <code class="calibre21">
        max()
       </code>
       algorithms compare two or more elements of any type using
       <code class="calibre21">
        operator&lt;
       </code>
       or a user-supplied binary predicate, returning a reference-to-
       <code class="calibre21">
        const
       </code>
       to the smallest or largest element, respectively. The
       <code class="calibre21">
        minmax()
       </code>
       algorithm returns a pair containing the minimum and maximum of two or more elements. These algorithms do not work with common ranges or ranges.
      </p>
      <p class="calibre13" id="c20-para-0160">
       The
       <code class="calibre21">
        min_element()
       </code>
       and
       <code class="calibre21">
        max_element()
       </code>
       algorithms work with common ranges and return an iterator to the smallest or largest element in a range, respectively. The
       <code class="calibre21">
        minmax_element()
       </code>
       algorithm also works with a common range and returns a pair containing iterators to the smallest and largest element in a range.
      </p>
      <p class="calibre13">
       The following program gives some examples:
      </p>
      <pre class="calibre26" id="c20-code-0071"><code class="calibre21">int x { 4 }, y { 5 };</code>
<code class="calibre21">println("x is {} and y is {}", x, y);</code>
<span aria-label="821" class="calibre20" epub:type="pagebreak" id="Page_821" role="doc-pagebreak"></span><code class="calibre21">println("Max is {}", <b class="calibre14">max(x, y)</b>);</code>
<code class="calibre21">println("Min is {}", <b class="calibre14">min(x, y)</b>);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Using max() and min() on more than two values.</span></code>
<code class="calibre21">int x1 { 2 }, x2 { 9 }, x3 { 3 }, x4 { 12 };</code>
<code class="calibre21">println("Max of 4 elements is {}", <b class="calibre14">max({ x1, x2, x3, x4 })</b>);</code>
<code class="calibre21">println("Min of 4 elements is {}", <b class="calibre14">min({ x1, x2, x3, x4 })</b>);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Using minmax().</span></code>
<code class="calibre21">auto p2 { <b class="calibre14">minmax({ x1, x2, x3, x4 })</b> }; <span class="color">// p2 is of type pair&lt;int, int&gt;.</span></code>
<code class="calibre21">println("Minmax of 4 elements is &lt;{},{}&gt;", p2.first, p2.second);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Using minmax() + structured bindings.</span></code>
<code class="calibre21">auto [min1, max1] { <b class="calibre14">minmax({ x1, x2, x3, x4 })</b> };</code>
<code class="calibre21">println("Minmax of 4 elements is &lt;{},{}&gt;", min1, max1);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Using minmax_element() + structured bindings.</span></code>
<code class="calibre21">vector values { 11, 33, 22 };</code>
<code class="calibre21">auto [min2, max2] { <b class="calibre14">minmax_element(cbegin(values), cend(values))</b> };</code>
<code class="calibre21">println("minmax_element() result: &lt;{},{}&gt;", *min2, *max2);</code></pre>
      <p class="calibre13">
       Here is the program output:
      </p>
      <pre class="calibre26" id="c20-code-0072"><code class="calibre21">x is 4 and y is 5</code>
<code class="calibre21">Max is 5</code>
<code class="calibre21">Min is 4</code>
<code class="calibre21">Max of 4 elements is 12</code>
<code class="calibre21">Min of 4 elements is 2</code>
<code class="calibre21">Minmax of 4 elements is &lt;2,12&gt;</code>
<code class="calibre21">Minmax of 4 elements is &lt;2,12&gt;</code>
<code class="calibre21">minmax_element() result: &lt;11,33&gt;</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0164">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Sometimes you might encounter non-standard macros to find the minimum and maximum. For example, the GNU C Library (glibc) has macros
           <code class="calibre21">
            MIN()
           </code>
           and
          </i>
          <code class="calibre21">
           MAX()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            ,
            <i class="calibre18">
             while the
            </i>
           </i>
          </i>
          <code class="calibre21">
           Windows.h
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             header file defines
            </i>
           </i>
          </i>
          <code class="calibre21">
           min()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           max()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             macros. Because these are macros, they have the potential to evaluate one of their arguments twice, whereas
            </i>
           </i>
          </i>
          <code class="calibre21">
           std::min()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           std::max()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             evaluate each argument exactly once. Make sure you always use the C++ versions,
            </i>
           </i>
          </i>
          <code class="calibre21">
           std::min()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           std::max()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            .
           </i>
          </i>
         </p>
         <p class="calibre25">
          <i class="calibre18">
           Even worse, such
          </i>
          <code class="calibre21">
           min()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           max()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             macros might interfere with using
            </i>
           </i>
          </i>
          <code class="calibre21">
           std::min()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             and
            </i>
           </i>
          </i>
          <code class="calibre21">
           std::max()
          </code>
          <i class="calibre18">
           . In that case, there are three workarounds:
          </i>
         </p>
         <ul class="check4" id="c20-list-0006">
          <li class="calibre9" id="c20-li-0019">
           Use
           <code class="calibre21">
            #undef min
           </code>
           and
           <code class="calibre21">
            #undef max
           </code>
           after having included the problematic header, e.g.,
           <code class="calibre21">
            Windows.h
           </code>
           .
          </li>
          <li class="calibre9" id="c20-li-0020">
           Add a
           <code class="calibre21">
            #define NOMINMAX
           </code>
           before you include
           <code class="calibre21">
            Windows.h
           </code>
           .
          </li>
          <li class="calibre9" id="c20-li-0021">
           Use an extra set of parentheses for
           <code class="calibre21">
            std::min()
           </code>
           and
           <code class="calibre21">
            std::max()
           </code>
           , as follows:
          </li>
         </ul>
         <pre class="calibre26" id="c20-code-0073"><code class="calibre21">    auto maxValue { <b class="calibre14">(std::max)</b>(1, 2) };</code></pre>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <span aria-label="822" class="calibre20" epub:type="pagebreak" id="Page_822" role="doc-pagebreak">
       </span>
       <code class="calibre21">
        std::clamp()
       </code>
       is a little helper function, defined in
       <code class="calibre21">
        &lt;algorithm&gt;
       </code>
       , that you can use to make sure that a value (
       <i class="calibre18">
        v
       </i>
       ) is between a given minimum (
       <i class="calibre18">
        lo
       </i>
       ) and maximum (
       <i class="calibre18">
        hi
       </i>
       ). It returns a reference to
       <i class="calibre18">
        lo
       </i>
       if
       <i class="calibre18">
        v
       </i>
       &lt;
       <i class="calibre18">
        lo
       </i>
       , returns a reference to
       <i class="calibre18">
        hi
       </i>
       if
       <i class="calibre18">
        v
       </i>
       &gt;
       <i class="calibre18">
        hi
       </i>
       , and otherwise returns a reference to
       <i class="calibre18">
        v
       </i>
       . Here is an example:
      </p>
      <pre class="calibre26" id="c20-code-0074"><code class="calibre21">println("{}", clamp(-3, 1, 10));</code>
<code class="calibre21">println("{}", clamp(3, 1, 10));</code>
<code class="calibre21">println("{}", clamp(22, 1, 10));</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c20-code-0075"><code class="calibre21">1</code>
<code class="calibre21">3</code>
<code class="calibre21">10</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0054">
      </span>
      <h3 class="calibre27" id="head-3-447">
       Parallel Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0168">
       C++ supports executing more than 60 Standard Library iterator-based algorithms in parallel to improve their performance. Examples include
       <code class="calibre21">
        std::for_each()
       </code>
       ,
       <code class="calibre21">
        all_of()
       </code>
       ,
       <code class="calibre21">
        copy()
       </code>
       ,
       <code class="calibre21">
        count_if()
       </code>
       ,
       <code class="calibre21">
        find()
       </code>
       ,
       <code class="calibre21">
        replace()
       </code>
       ,
       <code class="calibre21">
        search()
       </code>
       ,
       <code class="calibre21">
        sort()
       </code>
       ,
       <code class="calibre21">
        transform()
       </code>
       , and many more.
      </p>
      <p class="calibre13">
       Algorithms that support parallel execution have an optional
       <i class="calibre18">
        execution policy
       </i>
       as their first parameter. The execution policy allows you to specify whether an algorithm is allowed to be vectorized and/or executed in parallel. When a compiler vectorizes code, it replaces several CPU instructions with a single
       <i class="calibre18">
        vector CPU instruction
       </i>
       . A vector instruction performs some operation on multiple pieces of data with a single hardware instruction. These are also known as
       <i class="calibre18">
        single instruction multiple data
       </i>
       (SIMD) instructions. There are four standard execution policy types, and corresponding global instances of those types, all defined in
       <code class="calibre21">
        &lt;execution&gt;
       </code>
       in the
       <code class="calibre21">
        std::execution
       </code>
       namespace:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          EXECUTION POLICY TYPE
         </th>
         <th class="left" scope="col">
          GLOBAL INSTANCE
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           sequenced_policy
          </span>
         </td>
         <td class="bgcolor">
          <span class="calibre21">
           seq
          </span>
         </td>
         <td class="bgcolor">
          The algorithm is not allowed to parallelize or vectorize its execution.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           parallel_policy
          </span>
         </td>
         <td class="bgcolor">
          <span class="calibre21">
           par
          </span>
         </td>
         <td class="bgcolor">
          The algorithm is allowed to parallelize but not vectorize its execution.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           parallel_unsequenced_policy
          </span>
         </td>
         <td class="bgcolor">
          <span class="calibre21">
           par_unseq
          </span>
         </td>
         <td class="bgcolor">
          The algorithm is allowed to parallelize and vectorize its execution. It's also allowed to migrate its execution across threads.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           unsequenced_policy
          </span>
         </td>
         <td class="bgcolor">
          <span class="calibre21">
           unseq
          </span>
         </td>
         <td class="bgcolor">
          The algorithm is allowed to vectorize but not parallelize its execution.
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c20-para-0170">
       A Standard Library implementation is free to add additional execution policies.
      </p>
      <p class="calibre13">
       Let's look at how you can specify an execution policy for an algorithm. Here is an example of sorting the contents of a
       <code class="calibre21">
        vector
       </code>
       using a parallel policy:
      </p>
      <pre class="calibre26" id="c20-code-0076"><code class="calibre21">sort(execution::par, begin(values), end(values));</code></pre>
      <p class="calibre13">
       <span aria-label="823" class="calibre20" epub:type="pagebreak" id="Page_823" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0173">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Callbacks passed to parallel algorithms are not allowed to throw any uncaught exceptions. Doing so will trigger a call to
          </i>
          <code class="calibre21">
           std::terminate()
          </code>
          <i class="calibre18">
           <i class="calibre18">
            <i class="calibre18">
             which terminates the application
            </i>
            .
           </i>
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c20-para-0174">
       For algorithms executing with
       <code class="calibre21">
        parallel_unsequenced_policy
       </code>
       or
       <code class="calibre21">
        unsequenced_policy
       </code>
       , function calls to callbacks are allowed to get interleaved; that is, they are unsequenced. This helps the compiler to vectorize the code. However, this also means there are a lot of restrictions on what a function callback can do. For example, it cannot allocate/deallocate memory, acquire mutexes, use non-lock-free
       <code class="calibre21">
        std::atomic
       </code>
       s (see
       <a class="calibre5" href="c27.xhtml">
        Chapter 27
       </a>
       , “Multithreaded Programming with C++”), and more. For the other standard policies, the function calls are sequenced, but in an indeterminate sequence. Such policies do not impose restrictions on what the function callbacks can do.
      </p>
      <p class="calibre13" id="c20-para-0175">
       Parallel algorithms do not take any measures to prevent data races and deadlocks, so it is your responsibility to avoid them when executing an algorithm in parallel. Data race and deadlock prevention are discussed in detail in
       <a class="calibre5" href="c27.xhtml">
        Chapter 27
       </a>
       in the context of multithreaded programming.
      </p>
      <p class="calibre13" id="c20-para-0176">
       Parallel overloads of algorithms are not
       <code class="calibre21">
        constexpr
       </code>
       , even if the non-parallel overloads are.
      </p>
      <p class="calibre13">
       The return type of some of the parallel overloads of algorithms can be slightly different compared to the non-parallel overloads. For example, the non-parallel overload of
       <code class="calibre21">
        for_each()
       </code>
       returns the supplied callback, while the parallel overload does not return anything. Consult your favorite Standard Library Reference for a complete overview of all algorithms, including their parameter and return types, for both the parallel and non-parallel overloads.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0178">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           When working with large datasets or when you have to perform a large amount of work on each individual element in a dataset, use the parallel overloads of algorithms to increase performance
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c20-para-0179">
       Keep in mind, though, that using a parallel overload of an algorithm does not guarantee that its execution will be faster compared to a non-parallel overload. For example, when processing a small number of elements, a parallel overload might actually be slower due to the overhead that parallelization brings with it. Another example is when your container does not support random access iterators. To decide whether to use a parallel or a sequential overload for a specific use case, you must profile both and pick the most performant one.
       <a class="calibre5" href="c29.xhtml">
        Chapter 29
       </a>
       , “Writing Efficient C++,” discusses profiling.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0057">
      </span>
      <h3 class="calibre27" id="head-3-448">
       Numerical Processing Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0180">
       You've already seen an example of one numerical processing algorithm:
       <code class="calibre21">
        accumulate()
       </code>
       . The following sections give examples of some more numerical algorithms.
      </p>
      <span aria-label="824" class="calibre20" epub:type="pagebreak" id="Page_824" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0058">
       </span>
       <h4 class="calibre29" id="head-4-329">
        iota
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         iota()
        </code>
        algorithm, defined in
        <code class="calibre21">
         &lt;numeric&gt;
        </code>
        , generates a sequence of values in a specified range starting with a specified value and applying
        <code class="calibre21">
         operator++
        </code>
        to generate each successive value. The following example shows how to use this algorithm on a
        <code class="calibre21">
         vector
        </code>
        of integers, but it works on any element type that implements
        <code class="calibre21">
         operator++
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0077"><code class="calibre21">vector&lt;int&gt; values(10);</code>
<code class="calibre21"><b class="calibre14">iota(begin(values), end(values), 5);</b></code>
<code class="calibre21">println("{:n}", values);</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0078"><code class="calibre21">5, 6, 7, 8, 9, 10, 11, 12, 13, 14</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0059">
       </span>
       <h4 class="calibre29" id="head-4-330">
        Reduce Algorithms
       </h4>
       <p class="calibre13" id="c20-para-0183">
        The Standard Library has four
        <i class="calibre18">
         reduce algorithms
        </i>
        :
        <code class="calibre21">
         accumulate()
        </code>
        ,
        <code class="calibre21">
         reduce()
        </code>
        ,
        <code class="calibre21">
         inner_product()
        </code>
        , and
        <code class="calibre21">
         transform_reduce()
        </code>
        , all defined in
        <code class="calibre21">
         &lt;numeric&gt;
        </code>
        . The
        <code class="calibre21">
         accumulate()
        </code>
        algorithm is discussed earlier in this chapter. All reduce algorithms repeatedly apply an operator to combine two elements of a given range or two given ranges, until only one value remains. These are also called
        <i class="calibre18">
         accumulate
        </i>
        ,
        <i class="calibre18">
         aggregate
        </i>
        ,
        <i class="calibre18">
         compress
        </i>
        ,
        <i class="calibre18">
         inject
        </i>
        , or
        <i class="calibre18">
         fold
        </i>
        algorithms.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c20-sec-0060">
        </span>
        <h5 class="calibre35" id="head-5-135">
         reduce
        </h5>
        <p class="calibre13" id="c20-para-0184">
         <code class="calibre21">
          std::accumulate()
         </code>
         is one of the few algorithms that does not support parallel execution. Instead, you need to use
         <code class="calibre21">
          std::reduce()
         </code>
         to calculate a generalized sum with the option to execute it in parallel.
        </p>
        <p class="calibre13">
         For example, the following code calculates the same sum twice, once with
         <code class="calibre21">
          accumulate()
         </code>
         and once with
         <code class="calibre21">
          reduce()
         </code>
         . The latter runs a parallel and vectorized version and thus can be much faster on big input ranges. They both require a begin and end iterator of the range, and an initial value, 0 in this example.
        </p>
        <pre class="calibre26" id="c20-code-0079"><code class="calibre21">vector values { 1, 3, 6, 4, 6, 9 };</code>
<code class="calibre21"><b class="calibre14">int result1 { accumulate(cbegin(values), cend(values), 0) };</b></code>
<code class="calibre21"><b class="calibre14">int result2 { reduce(execution::par_unseq, cbegin(values), cend(values), 0) };</b></code></pre>
        <p class="calibre13">
         In general, both
         <code class="calibre21">
          accumulate()
         </code>
         and
         <code class="calibre21">
          reduce()
         </code>
         calculate the following sum for a range of elements [
         <i class="calibre18">
          x
         </i>
         <sub class="calibre42">
          0
         </sub>
         ,
         <i class="calibre18">
          x
         </i>
         <sub class="calibre42">
          n
         </sub>
         ), with a given initial value
         <i class="calibre18">
          Init
         </i>
         , and a given binary operator Ѳ:
        </p>
        <ul class="none" id="c20-list-1001">
         <li class="calibre9" id="c20-li-2001">
          Init Ѳ
          <i class="calibre18">
           x
          </i>
          <sub class="calibre42">
           0
          </sub>
          Ѳ
          <i class="calibre18">
           x
          </i>
          <sub class="calibre42">
           1
          </sub>
          Ѳ … Ѳ
          <i class="calibre18">
           x
          </i>
          <sub class="calibre42">
           n−1
          </sub>
         </li>
        </ul>
        <p class="calibre13" id="c20-para-0188">
         By default, the binary operator for
         <code class="calibre21">
          accumulate()
         </code>
         is
         <code class="calibre21">
          operator+
         </code>
         , and for
         <code class="calibre21">
          reduce()
         </code>
         it is
         <code class="calibre21">
          std::plus
         </code>
         .
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c20-sec-0061">
        </span>
        <h5 class="calibre35" id="head-5-136">
         inner_product
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          inner_product()
         </code>
         calculates the inner product of two sequences. For example, the inner product in the following example is calculated as
         <code class="calibre21">
          (1*9)+(2*8)+(3*7)+(4*6)
         </code>
         , which is 70:
        </p>
        <pre class="calibre26" id="c20-code-0080"><code class="calibre21">vector v1 { 1, 2, 3, 4 };</code>
<code class="calibre21">vector v2 { 9, 8, 7, 6 };</code>
<code class="calibre21"><b class="calibre14">println("{}", inner_product(cbegin(v1), cend(v1), cbegin(v2), 0));</b></code></pre>
        <p class="calibre13" id="c20-para-0190">
         <span aria-label="825" class="calibre20" epub:type="pagebreak" id="Page_825" role="doc-pagebreak">
         </span>
         <code class="calibre21">
          inner_product()
         </code>
         can accept two additional parameters, which are the two binary operators used in the calculation, by default
         <code class="calibre21">
          operator+
         </code>
         and
         <code class="calibre21">
          operator*
         </code>
         .
        </p>
        <p class="calibre13" id="c20-para-0191">
         <code class="calibre21">
          inner_product()
         </code>
         is another algorithm that does not support parallel execution. If parallel execution is required, use
         <code class="calibre21">
          transform_reduce()
         </code>
         , discussed next.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c20-sec-0062">
        </span>
        <h5 class="calibre35" id="head-5-137">
         transform_reduce
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          transform_reduce()
         </code>
         supports parallel execution and can be executed on a single range of elements or on two ranges. In its first version, it calculates the following sum for a range of elements [
         <i class="calibre18">
          x
         </i>
         <sub class="calibre42">
          0
         </sub>
         ,
         <i class="calibre18">
          x
         </i>
         <sub class="calibre42">
          n
         </sub>
         ), with a given initial value
         <i class="calibre18">
          Init
         </i>
         , a given unary function
         <i class="calibre18">
          f
         </i>
         , and a given binary operator Ѳ,
         <code class="calibre21">
          std::plus
         </code>
         by default:
        </p>
        <ul class="none" id="c20-list-7001">
         <li class="calibre9" id="c20-li-8001">
          Init Ѳ
          <i class="calibre18">
           f
          </i>
          (
          <i class="calibre18">
           x
          </i>
          <sub class="calibre42">
           0
          </sub>
          ) Ѳ
          <i class="calibre18">
           f
          </i>
          (
          <i class="calibre18">
           x
          </i>
          <sub class="calibre42">
           1
          </sub>
          ) Ѳ … Ѳ
          <i class="calibre18">
           f
          </i>
          (
          <i class="calibre18">
           x
          </i>
          <sub class="calibre42">
           n−1
          </sub>
          )
         </li>
        </ul>
        <p class="calibre13" id="c20-para-0194">
         When executing on two ranges, it behaves the same as
         <code class="calibre21">
          inner_product()
         </code>
         , except by default it uses the binary operators
         <code class="calibre21">
          std::plus
         </code>
         and
         <code class="calibre21">
          std::multiplies
         </code>
         , respectively, instead of
         <code class="calibre21">
          operator+
         </code>
         and
         <code class="calibre21">
          operator*
         </code>
         .
        </p>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0063">
       </span>
       <h4 class="calibre29" id="head-4-331">
        Scan Algorithms
       </h4>
       <p class="calibre13" id="c20-para-0195">
        <i class="calibre18">
         Scan algorithms
        </i>
        are also called
        <i class="calibre18">
         prefix sum
        </i>
        ,
        <i class="calibre18">
         cumulative sum
        </i>
        , or
        <i class="calibre18">
         partial sum
        </i>
        algorithms. The result of such an algorithm applied to a range is another range containing sums of the elements of the source range.
       </p>
       <p class="calibre13" id="c20-para-0196">
        There are five scan algorithms:
        <code class="calibre21">
         exclusive_scan()
        </code>
        ,
        <code class="calibre21">
         inclusive_scan()
        </code>
        /
        <code class="calibre21">
         partial_sum()
        </code>
        ,
        <code class="calibre21">
         transform_exclusive_scan()
        </code>
        , and
        <code class="calibre21">
         transform_inclusive_scan()
        </code>
        , all defined in
        <code class="calibre21">
         &lt;numeric&gt;
        </code>
        .
       </p>
       <p class="calibre13">
        The following table shows which sums [
        <i class="calibre18">
         y
        </i>
        <sub class="calibre42">
         0
        </sub>
        ,
        <i class="calibre18">
         y
        </i>
        <sub class="calibre42">
         n
        </sub>
        ) are calculated by
        <code class="calibre21">
         exclusive_scan()
        </code>
        and by
        <code class="calibre21">
         inclusive_scan()
        </code>
        /
        <code class="calibre21">
         partial_sum()
        </code>
        for a range of elements [
        <i class="calibre18">
         x
        </i>
        <sub class="calibre42">
         0
        </sub>
        ,
        <i class="calibre18">
         x
        </i>
        <sub class="calibre42">
         n
        </sub>
        ), with a given initial value
        <i class="calibre18">
         Init
        </i>
        (0 for
        <code class="calibre21">
         partial_sum()
        </code>
        ), and a given binary operator Ѳ:
       </p>
       <table border="1" class="calibre31">
        <thead class="calibre32">
         <tr class="calibre33">
          <th class="left" scope="col">
           EXCLUSIVE_SCAN()
          </th>
          <th class="left" scope="col">
           INCLUSIVE_SCAN()/PARTIAL_SUM()
          </th>
         </tr>
        </thead>
        <tbody class="calibre34">
         <tr class="calibre33">
          <td class="bgcolor">
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            0
           </sub>
           = Init
           <br class="calibre12"/>
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            1
           </sub>
           = Init Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            0
           </sub>
           <br class="calibre12"/>
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            2
           </sub>
           = Init Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            0
           </sub>
           Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            1
           </sub>
           <br class="calibre12"/>
           …
           <br class="calibre12"/>
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            n-1
           </sub>
           = Init Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            0
           </sub>
           Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            1
           </sub>
           Ѳ … Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            n-2
           </sub>
          </td>
          <td class="bgcolor">
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            0
           </sub>
           = Init Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            0
           </sub>
           <br class="calibre12"/>
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            1
           </sub>
           = Init Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            0
           </sub>
           Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            1
           </sub>
           <br class="calibre12"/>
           …
           <br class="calibre12"/>
           <i class="calibre18">
            y
           </i>
           <sub class="calibre42">
            n-1
           </sub>
           = Init Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            0
           </sub>
           Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            1
           </sub>
           Ѳ … Ѳ
           <i class="calibre18">
            x
           </i>
           <sub class="calibre42">
            n-1
           </sub>
          </td>
         </tr>
        </tbody>
       </table>
       <p class="calibre13" id="c20-para-0205">
        <code class="calibre21">
         transform_exclusive_scan()
        </code>
        and
        <code class="calibre21">
         transform_inclusive_scan()
        </code>
        both first apply a unary function to the elements before calculating the generalized sum, similar to how
        <code class="calibre21">
         transform_reduce()
        </code>
        applies a unary function to the elements before reducing.
       </p>
       <p class="calibre13" id="c20-para-0206">
        Note that these scan algorithms, except
        <code class="calibre21">
         partial_sum()
        </code>
        , can accept an optional execution policy to parallelize their execution. The order of evaluation is non-deterministic, while it is guaranteed left to right for
        <code class="calibre21">
         partial_sum()
        </code>
        and
        <code class="calibre21">
         accumulate()
        </code>
        . That's also the reason why
        <code class="calibre21">
         partial_sum()
        </code>
        and
        <code class="calibre21">
         accumulate()
        </code>
        cannot be parallelized.
       </p>
      </section>
     </section>
     <span aria-label="826" class="calibre20" epub:type="pagebreak" id="Page_826" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c20-sec-0064">
      </span>
      <h3 class="calibre27" id="head-3-449">
       Constrained Algorithms
      </h3>
      <p class="calibre13" id="c20-para-0207">
       Most of the algorithms have constrained variants in the
       <code class="calibre21">
        std::ranges
       </code>
       namespace. Consult your favorite Standard Library reference to find out exactly which constrained algorithms are available. These algorithms are also defined in
       <code class="calibre21">
        &lt;algorithm&gt;
       </code>
       and
       <code class="calibre21">
        &lt;numeric&gt;
       </code>
       , but unlike the equivalent unconstrained algorithms in the
       <code class="calibre21">
        std
       </code>
       namespace, the constrained variants use concepts (see
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       ) to constrain their template type parameters. This means you get better error messages from your compiler if you pass invalid arguments. For example, the
       <code class="calibre21">
        sort()
       </code>
       algorithm requires random-access iterators. Passing a pair of
       <code class="calibre21">
        std::list
       </code>
       iterators as arguments to
       <code class="calibre21">
        std::sort()
       </code>
       can result in a bunch of cryptic errors from your compiler. With the constrained
       <code class="calibre21">
        ranges::sort()
       </code>
       algorithm, the compiler tells you that the passed iterators are not random access.
      </p>
      <p class="calibre13">
       Another benefit of these constrained algorithms is that they work on a sequence of elements given as either a
       <i class="calibre18">
        begin and end iterator pair
       </i>
       , or as a
       <i class="calibre18">
        range
       </i>
       . Additionally, they can support projections. Ranges and projections are discussed in
       <a class="calibre5" href="c17.xhtml">
        Chapter 17
       </a>
       .
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c20-para-0209">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Constrained algorithms do not support parallel execution yet, so they do not accept a parallel execution policy as an argument
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c20-para-0210">
       Let's look at a few of these constrained algorithms in action.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0066">
       </span>
       <h4 class="calibre29" id="head-4-332">
        Constrained find
       </h4>
       <p class="calibre13">
        As with all constrained algorithms, the
        <code class="calibre21">
         std::ranges::find()
        </code>
        constrained algorithm can be called with a pair of iterators or with a range as argument. Calling it with an iterator pair works the same way as the unconstrained
        <code class="calibre21">
         std::find()
        </code>
        :
       </p>
       <pre class="calibre26" id="c20-code-0081"><code class="calibre21">vector values {1, 2, 3};</code>
<code class="calibre21"><b class="calibre14">auto result { ranges::find(cbegin(values), cend(values), 2) };</b></code>
<code class="calibre21">if (result != cend(values)) { println("{}", *result); }</code></pre>
       <p class="calibre13">
        However, if you want to apply an algorithm on
        <i class="calibre18">
         all
        </i>
        elements of a container, as is often the case, it's rather tedious to always have to specify a begin/end iterator pair to define your sequence. With ranges support, you can just specify a range with a single argument. The previous call to
        <code class="calibre21">
         find()
        </code>
        can be written more readable and less error prone as follows:
       </p>
       <pre class="calibre26" id="c20-code-0082"><code class="calibre21"><b class="calibre14">auto result { ranges::find(values, 2) };</b></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0067">
       </span>
       <h4 class="calibre29" id="head-4-333">
        Constrained generate
       </h4>
       <p class="calibre13">
        Here is another example, this time using the constrained
        <code class="calibre21">
         std::ranges::generate()
        </code>
        algorithm. The code first creates a lambda expression that simply returns a next number. Then it creates a
        <code class="calibre21">
         vector
        </code>
        of 10 integers and uses the
        <code class="calibre21">
         generate()
        </code>
        algorithm together with the
        <code class="calibre21">
         nextNumber
        </code>
        lambda expression to fill the
        <code class="calibre21">
         vector
        </code>
        with increasing integers. The contents of the
        <code class="calibre21">
         vector
        </code>
        are printed to the console, followed by four more invocations of the
        <code class="calibre21">
         nextNumber
        </code>
        lambda expression.
       </p>
       <pre class="calibre26" id="c20-code-0083"><code class="calibre21">auto nextNumber { [counter = 0] () mutable { return ++counter; } };</code>
<code class="calibre21">vector&lt;int&gt; values(10);</code>
<span aria-label="827" class="calibre20" epub:type="pagebreak" id="Page_827" role="doc-pagebreak"></span><code class="calibre21"><b class="calibre14">ranges::generate(values, nextNumber);</b></code>
<code class="calibre21">println("Vector contains {:n}", values);</code>
<code class="calibre21">print("Four more next numbers: ");</code>
<code class="calibre21">for (unsigned i { 0 }; i &lt; 4; ++i) { print("{}, ", nextNumber()); }</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0084"><code class="calibre21">Vector contains 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">Four more next numbers: 1, 2, 3, 4,</code></pre>
       <p class="calibre13">
        As the output demonstrates,
        <code class="calibre21">
         generate()
        </code>
        makes a copy of the lambda expression. This can be avoided using
        <code class="calibre21">
         std::ref()
        </code>
        , as explained earlier in this chapter, to pass a reference to the lambda expression instead of making a copy:
       </p>
       <pre class="calibre26" id="c20-code-0085"><code class="calibre21">ranges::generate(values, <b class="calibre14">ref(nextNumber)</b>);</code></pre>
       <p class="calibre13">
        The output now is:
       </p>
       <pre class="calibre26" id="c20-code-0086"><code class="calibre21">Vector contains 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">Four more next numbers: 11, 12, 13, 14,</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0068">
       </span>
       <h4 class="calibre29" id="head-4-334">
        Constrained for_each
       </h4>
       <p class="calibre13">
        The following example demonstrates using the
        <code class="calibre21">
         std::ranges::for_each()
        </code>
        algorithm on a filtered view created with
        <code class="calibre21">
         std::ranges::views::filter
        </code>
        (defined in
        <code class="calibre21">
         &lt;ranges&gt;
        </code>
        ). Only the even values from the
        <code class="calibre21">
         vector
        </code>
        are kept in the view. This filtered view is subsequently passed to
        <code class="calibre21">
         for_each()
        </code>
        , which multiplies the values by 10. Outputting the contents of the
        <code class="calibre21">
         vector
        </code>
        confirms that only the even values in the
        <code class="calibre21">
         vector
        </code>
        have been multiplied.
       </p>
       <pre class="calibre26" id="c20-code-0087"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">println("Before: {:n}", values);</code>
<code class="calibre21"><b class="calibre14">ranges::for_each(values | views::filter([](int value) { return value % 2 == 0; }),</b></code>
<code class="calibre21">    <b class="calibre14">[](int&amp; value) { value *= 10; });</b></code>
<code class="calibre21">println("After:  {:n}", values);</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c20-code-0088"><code class="calibre21">Before: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">After:  1, 20, 3, 40, 5, 60, 7, 80, 9, 100</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c20-sec-0069">
       </span>
       <h4 class="calibre29" id="head-4-335">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        Constrained-Only Algorithms
       </h4>
       <p class="calibre13" id="c20-para-0220">
        C++23 introduces new algorithms that are available only as constrained algorithms. They are all defined in the
        <code class="calibre21">
         std::ranges
        </code>
        namespace. These include the non-modifying sequence algorithms
        <code class="calibre21">
         contains()
        </code>
        ,
        <code class="calibre21">
         contains_subrange()
        </code>
        ,
        <code class="calibre21">
         starts_with()
        </code>
        ,
        <code class="calibre21">
         ends_with()
        </code>
        ,
        <code class="calibre21">
         find_last()
        </code>
        ,
        <code class="calibre21">
         find_last_if()
        </code>
        , and
        <code class="calibre21">
         find_last_if_not()
        </code>
        , and the fold algorithms
        <code class="calibre21">
         fold_left()
        </code>
        ,
        <code class="calibre21">
         fold_left_first()
        </code>
        ,
        <code class="calibre21">
         fold_right()
        </code>
        ,
        <code class="calibre21">
         fold_right_last()
        </code>
        ,
        <code class="calibre21">
         fold_left_with_iter()
        </code>
        , and
        <code class="calibre21">
         fold_left_first_with_iter()
        </code>
        .
       </p>
       <p class="calibre13">
        Here is an example of some of the non-modifying sequence algorithms:
       </p>
       <pre class="calibre26" id="c20-code-0089"><code class="calibre21">vector values { 11, 22, 33, 44, 55 };</code>
<code class="calibre21">vector v { 11, 22 };</code>
<code class="calibre21">println("{} contains 33 = {}", values, <b class="calibre14">ranges::contains(values, 33)</b>);</code>
<code class="calibre21">println("{} contains {} = {}", values, v, <b class="calibre14">ranges::contains_subrange(values, v)</b>);</code>
<code class="calibre21">println("{} starts with {} = {}", values, v, <b class="calibre14">ranges::starts_with(values, v)</b>);</code></pre>
       <p class="calibre13">
        <span aria-label="828" class="calibre20" epub:type="pagebreak" id="Page_828" role="doc-pagebreak">
        </span>
        This produces the following output:
       </p>
       <pre class="calibre26" id="c20-code-0090"><code class="calibre21">[11, 22, 33, 44, 55] contains 33 = true</code>
<code class="calibre21">[11, 22, 33, 44, 55] contains [11, 22] = true</code>
<code class="calibre21">[11, 22, 33, 44, 55] starts with [11, 22] = true</code></pre>
       <p class="calibre13">
        The following is an example of two of the folding algorithms.
        <code class="calibre21">
         fold_left()
        </code>
        and
        <code class="calibre21">
         fold_right()
        </code>
        accept an initial value as one of their arguments, while
        <code class="calibre21">
         fold_left_first()
        </code>
        uses the first element in a given range as the starting value, and
        <code class="calibre21">
         fold_right_last()
        </code>
        uses the last element in a given range as the starting value. The example demonstrates the difference between a left and a right fold. The
        <code class="calibre21">
         fold_left_first()
        </code>
        and
        <code class="calibre21">
         fold_right_last()
        </code>
        algorithms return an
        <code class="calibre21">
         optional
        </code>
        , so
        <code class="calibre21">
         value_or()
        </code>
        is used to handle an empty result.
       </p>
       <pre class="calibre26" id="c20-code-0091"><code class="calibre21">vector values { 500.0, 10.0, 2.0 };</code>
<code class="calibre21">auto foldedLeft { <b class="calibre14">ranges::fold_left_first(values, divides&lt;&gt;{})</b> };</code>
<code class="calibre21">auto foldedRight { <b class="calibre14">ranges::fold_right_last(values, divides&lt;&gt;{})</b> };</code>
<code class="calibre21">println("foldedLeft = {}", foldedLeft.value_or(0.0));</code>
<code class="calibre21">println("foldedRight = {}", foldedRight.value_or(0.0));</code></pre>
       <p class="calibre13">
        The output is:
       </p>
       <pre class="calibre26" id="c20-code-0092"><code class="calibre21">foldedLeft = 25</code>
<code class="calibre21">foldedRight = 100</code></pre>
       <p class="calibre13" id="c20-para-0225">
        The left fold operation calculates ((500.0 / 10.0) / 2.0), while the right fold operation calculates (500.0 / (10.0 / 2.0)).
       </p>
       <p class="calibre13" id="c20-para-0226">
        See your favorite Standard Library reference for more details on all these constrained algorithms.
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-219" class="calibre2">
     <span class="calibre" id="c20-sec-0070">
     </span>
     <h2 class="calibre6" id="head-2-219">
      SUMMARY
     </h2>
     <p class="calibre13" id="c20-para-0227">
      This chapter provided coding examples for a selection of Standard Library algorithms. It also showed you that combining these algorithms with lambda expressions allows you to write elegant and easy-to-understand code. Together with the previous chapters, I hope you gained an appreciation for the usefulness and the power of the Standard Library containers and algorithms.
     </p>
     <p class="calibre13" id="c20-para-0228">
      The following chapters continue the discussion of other C++ Standard Library functionality.
      <a class="calibre5" href="c21.xhtml">
       Chapter 21
      </a>
      discusses regular expressions.
      <a class="calibre5" href="c22.xhtml">
       Chapter 22
      </a>
      explains the date and time support.
      <a class="calibre5" href="c23.xhtml">
       Chapter 23
      </a>
      shows how to generate random numbers.
      <a class="calibre5" href="c24.xhtml">
       Chapter 24
      </a>
      covers a number of additional vocabulary types that are available for you to use. Finally,
      <a class="calibre5" href="c25.xhtml">
       Chapter 25
      </a>
      gives a taste of some more advanced features, such as allocators and how to write your own Standard Library–compliant algorithms and containers.
     </p>
    </section>
    <section aria-labelledby="head-2-220" class="calibre2">
     <span class="calibre" id="c20-sec-0071">
     </span>
     <h2 class="calibre6" id="head-2-220">
      EXERCISES
     </h2>
     <p class="calibre13" id="c20-para-0229">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <span aria-label="829" class="calibre20" epub:type="pagebreak" id="Page_829" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c20-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c20-ex-0001">
        <b class="calibre14">
         <b class="calibre14">
          Exercise 20-1:
         </b>
        </b>
        Use your favorite Standard Library Reference to look up the parameters for the
        <code class="calibre21">
         ranges::fill()
        </code>
        algorithm. Ask the user for a number, and then use
        <code class="calibre21">
         fill()
        </code>
        to fill a
        <code class="calibre21">
         vector
        </code>
        of 10 integers with the given number. Write the contents of the
        <code class="calibre21">
         vector
        </code>
        to the standard output for verification. Provide a second solution using the
        <code class="calibre21">
         std::fill()
        </code>
        algorithm.
       </li>
       <li class="calibre9" id="c20-ex-0002">
        <b class="calibre14">
         <b class="calibre14">
          Exercise 20-2:
         </b>
        </b>
        Look back at the “Permutation Algorithms” section in
        <a class="calibre5" href="c16.xhtml">
         Chapter 16
        </a>
        , and then use a Standard Library Reference to figure out their parameters. Write a program that asks the user to enter a few numbers, and then use one of the permutation algorithms to print out all possible permutations of those numbers. Provide two solutions, one using only constrained algorithms and a second using legacy, unconstrained algorithms.
       </li>
       <li class="calibre9" id="c20-ex-0003">
        <b class="calibre14">
         <b class="calibre14">
          Exercise 20-3:
         </b>
        </b>
        Write a function called
        <code class="calibre21">
         trim()
        </code>
        that removes all whitespace at the beginning and end of a given string and returns the result. Use only constrained algorithms. Tip: to check if a character
        <code class="calibre21">
         c
        </code>
        is a whitespace character, you can use
        <code class="calibre21">
         std::isspace(c)
        </code>
        , defined in
        <code class="calibre21">
         &lt;cctype&gt;
        </code>
        . It returns a non-zero value if
        <code class="calibre21">
         c
        </code>
        is a whitespace character, 0 otherwise. Test your implementation with several strings in your
        <code class="calibre21">
         main()
        </code>
        function.
       </li>
       <li class="calibre9" id="c20-ex-0004">
        <b class="calibre14">
         <b class="calibre14">
          Exercise 20-4:
         </b>
        </b>
        Use a constrained algorithm to create a
        <code class="calibre21">
         vector
        </code>
        containing the numbers 1 to 20. Then, using a single constrained algorithm, copy all even and odd numbers to
        <code class="calibre21">
         evens
        </code>
        and
        <code class="calibre21">
         odds
        </code>
        containers without doing any space reservation on those containers, and, still with this single algorithm call, make sure the even numbers are in ascending sequence, while the odd numbers are in descending sequence. Carefully choose the type for the
        <code class="calibre21">
         evens
        </code>
        and
        <code class="calibre21">
         odds
        </code>
        containers. Hint: maybe there is something in
        <a class="calibre5" href="c17.xhtml">
         Chapter 17
        </a>
        that you could use.
       </li>
       <li class="calibre9" id="c20-ex-0005">
        <b class="calibre14">
         <b class="calibre14">
          Exercise 20-5:
         </b>
        </b>
        The solution for Exercise 20-3 uses only constrained algorithms. Can you do the same using only legacy, unconstrained algorithms?
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
