<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   7: C++ revisions
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_015.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_017.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="251" epub:type="pagebreak" id="pagebreak_251" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0007" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000064">
      7: C++ revisions
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         The C++ standard went through its first major update with the introduction of C++11 in 2011. Since that time, the ISO standard committee has released several further updates on a regular cadence, including C++14, C++17, C++20, and C++23. This chapter takes each of these revisions in term and describes all the important application programming interface (API) design features introduced by each update. For example, smart points, enum classes, and the Rule of Five were introduced in C++11. The auto return type and deprecated attribute were added in C++14. Inline variables and the optional, any, and variant types were added to C++17. Modules and the spaceship operator appeared in C++20 and expected values were introduced in C++23. This chapter provides advice on how to select which revision of the standard you should adopt in your software projects, and for each revision a summary is provided of the most important features you may want to start using in your API designs and the impact that they may have on backward compatibility for your clients.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Auto; Enum class; Module; Move constructor; Smart pointer; std:any; std:expected; std:optional; std:variant; Template constraint
      </div>
     </section>
     <section>
      <p class="textfl" id="p0050">
       After the initial standardization of the C++ language in 1998 and a subsequent minor amendment in 2003, the language underwent a major revision in 2011 with C++11. Since that time, the ISO standard committee has committed to releasing updates to the language every 3
       <span title='hsp="0.25"'>
       </span>
       years. To date, we have seen C++14, C++17, C++20, and C++23. These have varied in scale, but generally they have sought to address problems or ambiguities in existing functionality as well as add new features to the core language and the Standard Library.
      </p>
      <p class="text" id="p0055">
       Rather than mix all of the features from all revisions together into a single discussion, I have chosen to break them out chronologically. The reason is that you will normally make a conscious choice about which revision of the standard you will use in each of your software projects, and so you only need to read up to the section that covers the revision you're using. Of course, you can always read beyond that point to learn about useful features that may inspire you to adopt a more recent version as well.
      </p>
      <p class="text" id="p0060">
       This chapter is not meant to be an exhaustive compendium of every feature introduced in each revision. Because this book is focused on application programming interface (API) design, I'll focus only on those features that have an impact on your interface designs. Although features such as the
       <span class="inlinecode">
        auto
       </span>
       keyword, range-based
       <span class="inlinecode">
        for
       </span>
       loops, lambda expressions, and new Standard Library algorithms are wonderful additions to the language, they have little impact on how you can deliver robust interfaces to your users, so I'll not spend time on those aspects.
      </p>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        Which C++ revision to use
       </h2>
       <p class="textfl" id="p0065">
        Given the range of C++ revisions that have been published to date, you may reasonably ask which one you should target for your projects. Some factors to consider in your decision include:
       </p>
       <div>
        <ul class="ce_list" id="olist0010">
         <li class="numlist" id="p0070">
          <a id="o0010">
          </a>
          1.
          <b>
           Dependencies:
          </b>
          The versions of C++ that your dependent libraries use can influence the choice of which version you can adopt.
         </li>
         <li class="numlist" id="p0075">
          <a id="o0015">
          </a>
          2.
          <b>
           Clients:
          </b>
          The end users of your library may have limitations on the version of C++ they can support.
         </li>
         <li class="numlist" id="p0080">
          <a id="o0020">
          </a>
          3.
          <b>
           Compilers:
          </b>
          Not all compilers on all platforms may fully support every new feature of the most recent versions of the language.
         </li>
         <li class="numlist" id="p0085">
          <a id="o0025">
          </a>
          4.
          <b>
           Features:
          </b>
          You may want to use a more recent revision because it gives you access to a newer feature that you want to use.
         </li>
        </ul>
       </div>
       <p class="text" id="p0090">
        An important question is whether you can mix and match different C++ versions within a single project. For example, can you use C++20 if your dependencies are all
        <a id="p252">
        </a>
        <span aria-label="252" epub:type="pagebreak" id="pagebreak_252" role="doc-pagebreak">
        </span>
        using C++17? A key factor here is whether you're building your dependencies from source or binary. If you have the source for the other libraries, there should be no problem: a C++20 compiler should be able to compile all earlier versions.
       </p>
       <p class="text" id="p0095">
        The situation becomes more complex if you're depending on only the precompiled binaries for your dependencies. The C++ standard does not define a standardized application binary interface (ABI). So by default, you should assume that you can't mix and match code that was compiled with different versions of the compiler.
       </p>
       <p class="text" id="p0100">
        Having said that, some compiler implementations do try hard to provide a compatible ABI. For example, both gcc and clang generally let you link code that was compiled with different stable versions. For example, C++17 and C++11 are binary compatible for these compilers. By contrast, Microsoft Visual C++ does not try to maintain ABI compatibility between versions. The Microsoft C Runtime (MSVCRT) is versioned per release of the compiler, and apps cannot mix multiple run times.
       </p>
       <p class="text" id="p0105">
        As for a specific recommendation, C++11 was a huge leap forward for the language. It introduced a robust memory model, concurrency, smart pointers, and much more. Any modern C++ project should be using at least C++11. Beyond that, you should try to use the most recent version you can while considering the constraints of your clients, source and binary dependencies, and the platforms you need to support.
       </p>
      </section>
      <section>
       <a id="s0015">
       </a>
       <h2 class="h1hd" id="cesectitle0025">
        C++11 API features
       </h2>
       <p class="textfl" id="p0110">
        C++11 was published in Sep. 2011 and introduced many changes to the language. These changes include improvements to the core language, built-in support for multithreading, templating enhancements, and significant changes to the C++ Standard Library. In the upcoming sections, I'll introduce the various features of C++11 that can further enhance your ability to deliver robust APIs, beyond the base functionality offered by C++03.
       </p>
       <p class="text" id="p0115">
        I'll not cover the new multithreading features introduced by C++11 here because I've dedicated an entire chapter to this important topic. Please refer to the Concurrency chapter for more details on this aspect of C++.
       </p>
       <p class="text" id="p0120">
        As some historical context, C++11 was referred to as C++0x during its development, because it was uncertain when the revision would be published. The x was meant to stand in for the year 2008 or 2009, although ultimately the update wasn't published until 2011.
       </p>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Move constructors and the Rule of Five
        </h3>
        <p class="textfl" id="p0125">
         The Rule of Three for C++03 code states that if a class defines one of the following special functions, then it must define all three:
        </p>
        <div>
         <ol id="ulist0010">
          <li class="bulllist" id="p0130">
           <a id="u0010">
           </a>
           • Destructor,
          </li>
          <li class="bulllist" id="p0135">
           <a id="u0015">
           </a>
           • Copy constructor,
          </li>
          <li class="bulllist" id="p0140">
           <a id="u0020">
           </a>
           • Assignment operator.
          </li>
         </ol>
        </div>
        <p class="textfl">
         <a id="p253">
         </a>
        </p>
        <div>
         <span aria-label="253" epub:type="pagebreak" id="pagebreak_253" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0145">
         The reason for this rule is that if one of these functions is required, then it's most likely because the class dynamically allocates some resource. It's therefore important that the class explicitly defines how that resource should be freed, copied, and assigned to another object. With C++11, two special functions were added to implement move semantics for a class:
        </p>
        <div>
         <ol id="ulist0015">
          <li class="bulllist" id="p0150">
           <a id="u0025">
           </a>
           • Move constructor,
          </li>
          <li class="bulllist" id="p0155">
           <a id="u0030">
           </a>
           • Move assignment operator.
          </li>
         </ol>
        </div>
        <p class="text" id="p0160">
         A move constructor is used to move the resources owned by one object to another. Whereas a copy constructor will leave the original object unchanged and create a copy of the object's data, a move constructor will transfer ownership of the data to the new object and update the original to stop referring to those data. Move constructors are therefore usually more efficient because they avoid unnecessary copying of an object's data. However, the use of a move constructor also implies that the original object will no longer be used.
        </p>
        <p class="text" id="p0165">
         A move assignment operator offers similar move semantics for assignment, such as to transfer a temporary object to an existing object (as opposed to a move constructor that creates a new object).
        </p>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <div class="b1textfl" id="bpar0010">
            <i>
             The Rule of Five for C++11 states that if you define a destructor
            </i>
            ,
            <i>
             copy constructor
            </i>
            ,
            <i>
             copy assignment operator
            </i>
            ,
            <i>
             move constructor
            </i>
            ,
            <i>
             or move assignment operator
            </i>
            ,
            <i>
             then you should define all five
            </i>
            .
           </div>
           <div class="b1text" id="bpar0015">
            <i>
             (But if you don't define a move constructor and/or move assignment operator
            </i>
            ,
            <i>
             your copy constructor and/or copy assignment operator will be used by default
            </i>
            .
            <i>
             )
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0170">
         The compiler can use a move constructor and move assignment operator to move data more efficiently between temporary variables that it creates. For example, when you store the result of a function call in a variable, such as
         <span class="inlinecode">
          auto f = func()
         </span>
         , the compiler can use your move constructor to avoid having to copy the function return value into your variable. You can also allow the compiler to trigger move semantics in your own code using the
         <span class="inlinecode">
          std::move
         </span>
         function. For example, this
         <span class="inlinecode">
          swap
         </span>
         function template will create temporary copies of the provided objects:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0010">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-001-9780443222191.jpg" width="727"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p254">
         </a>
        </p>
        <div>
         <span aria-label="254" epub:type="pagebreak" id="pagebreak_254" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0175">
         However, this alternate implementation of the function uses the move constructor and move assignment operator to swap the two objects more efficiently:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-002-9780443222191.jpg" width="866"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0180">
         (
         <span class="inlinecode">
          std::move
         </span>
         doesn't directly call a move constructor. It just casts an object to an rvalue reference such as
         <span class="inlinecode">
          MyClass &amp;&amp;
         </span>
         to indicate that it’s a temporary value that won't persist beyond the expression where it's used. This lets the compiler decide to use the move constructor if it can.)
        </p>
        <p class="text" id="p0185">
         If you don't define a move constructor, the compiler will just use the copy constructor, which should be functionally identical albeit less efficient. Similarly, if you don't define a move assignment operator, the compiler will fall back to using the copy assignment operator. So, although the Rule of Three was expanded to the Rule of Five for C++11, if you only conform to the original Rule of Three, then your code will still behave correctly, just less efficiently than it could do in some circumstances.
        </p>
        <p class="text" id="p0190">
         The next example shows the use of a traditional destructor, copy constructor, and copy assignment operator, as well as how to define a move constructor and move assignment operator:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0020">
           <img alt="image" height="1586" src="../../IMAGES/B9780443222191000064/main.assets/u07-003-9780443222191.jpg" width="1559"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p255">
         </a>
        </p>
        <div>
         <span aria-label="255" epub:type="pagebreak" id="pagebreak_255" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0195">
         The implementation of these functions looks like:
         <a id="p256">
         </a>
         <span aria-label="256" epub:type="pagebreak" id="pagebreak_256" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0025">
           <img alt="image" height="2339" src="../../IMAGES/B9780443222191000064/main.assets/u07-004p1-9780443222191.jpg" width="1706"/>
           <img alt="image" height="486" src="../../IMAGES/B9780443222191000064/main.assets/u07-004p2-9780443222191.jpg" width="2079"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0200">
         If we pass two instances of this class to the first version of the previous swap function, it will produce the output:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-005-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0205">
         whereas the second version of the swap function, using
         <span class="inlinecode">
          std::move
         </span>
         , produces this output, showing the use of the move constructor and move assignment operator:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0035">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-006-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Default and deleted functions
        </h3>
        <p class="textfl" id="p0210">
         C++03 gave you little control over the compiler's behavior of automatically generating special functions such as constructors, destructors, and assignment operators. For example, if you don't declare a copy constructor, a C++03 compiler will always generate one for you. However, with C++11, you have explicit control over whether the compiler generates, or does not generate, these special functions.
        </p>
        <div id="p0215">
         For instance, you can now specifically indicate that you want the compiler to generate its default implementation for any special function using the new
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          default
         </span>
         syntax in the function declaration, as in this example:
         <a id="p257">
         </a>
         <span aria-label="257" epub:type="pagebreak" id="pagebreak_257" role="doc-pagebreak">
         </span>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="1240" src="../../IMAGES/B9780443222191000064/main.assets/u07-007-9780443222191.jpg" width="1735"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0220">
         The resulting behavior should be the same as if you hadn't declared these functions at all: the compiler will generate its default implementation in both cases. However, the explicit default syntax makes your intention to use the compiler-generated implementation clearer.
        </p>
        <p class="text" id="p0225">
         A class that uses a compiler-generated default constructor is known as trivial. A trivial class offers certain properties such as being trivially copyable, so you can copy the object using
         <span class="inlinecode">
          memcpy
         </span>
         . However, if you provide your own default constructor implementation, then your class becomes nontrivial, even if you are only defining an empty implementation such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-008-9780443222191.jpg" width="867"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div id="p0230">
         Therefore, using
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          default
         </span>
         to enforce the compiler-generated implementation is helpful to keep the object trivial, if you need that property for your object.
        </div>
        <div id="p0235">
         You can also tell the compiler to disable certain functions that would otherwise be generated for you, using the new
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          delete
         </span>
         syntax. This is useful if you want to prevent a special function from being implemented. For example, this lets you make a class be noncopyable by deleting the copy constructor and copy assignment operator. Because this is C++11, you should include the move constructor and move assignment operator in that definition. For example:
         <a id="p258">
         </a>
         <span aria-label="258" epub:type="pagebreak" id="pagebreak_258" role="doc-pagebreak">
         </span>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="603" src="../../IMAGES/B9780443222191000064/main.assets/u07-009-9780443222191.jpg" width="1978"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0240">
         This is an alternative to the C++03 technique of declaring these functions as private, but the delete solution is better because in the private case you would still be able to access the copy constructor and assignment operator within the class where they're defined. Using the delete solution makes it certain that these functions can never be called from any context.
        </p>
        <div id="p0245">
         Moreover, you can put the
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          default
         </span>
         and
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          delete
         </span>
         specifiers in your
         <span class="inlinecode">
          .cpp
         </span>
         files instead of your headers. In fact, that can be a better strategy from the point of view of good API design because then you're not exposing and inlining the implementation of the function in your header files. For example:
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-010-9780443222191.jpg" width="1004"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0030">
        </a>
        <h3 class="h2hd" id="cesectitle0040">
         Object construction
        </h3>
        <p class="textfl" id="p0250">
         C++11 introduced several features relating to constructors and object initialization. The first feature we'll cover is the ability for one constructor to call another. For example, consider a simple class that stores a floating-point range and caches the median value of the range:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0060">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000064/main.assets/u07-011-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p259">
         </a>
        </p>
        <div>
         <span aria-label="259" epub:type="pagebreak" id="pagebreak_259" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0255">
         The implementation of these three constructors might look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0065">
           <img alt="image" height="1007" src="../../IMAGES/B9780443222191000064/main.assets/u07-012-9780443222191.jpg" width="1316"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0260">
         In this case, the logic to calculate the
         <span class="inlinecode">
          mMedian
         </span>
         data member is duplicated in each constructor. It's possible to introduce a mathematical error in one constructor that would cause the object to behave differently, depending on which constructor was used.
        </p>
        <p class="text" id="p0265">
         Instead, it would be more robust to implement the first two constructors in terms of the third, more general constructor. This was not possible with C++03 without creating an additional member function that all three constructors can call.
        </p>
        <p class="text" id="p0270">
         However, starting with C++11, one constructor, known as a delegating constructor, can call another constructor, known as the target constructor. With this capability, the first two constructors in our previous example can now be rewritten more succinctly as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0070">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-013-9780443222191.jpg" width="900"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0275">
         The first constructor calls the second constructor, which then calls the third constructor. If you're concerned about delegation cycles, your compiler should generate an error if, for example, you have one constructor that calls another constructor that then calls the first one again. If you use a delegating constructor, then you cannot include any other definitions in the constructor's initialization list.
        </p>
        <p class="text" id="p0280">
         This technique helps achieve the minimally complete API quality by defining the logic to calculate the median value in one place and reusing it across all constructors. As such, it's good practice to use delegating constructors where you can, to reduce redundancy.
         <a id="p260">
         </a>
        </p>
        <div>
         <span aria-label="260" epub:type="pagebreak" id="pagebreak_260" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0285">
         The second feature related to object initialization we'll cover here is data member initializers. With C++11, you can now provide a default value for any data members as part of the class declaration. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0075">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-014-9780443222191.jpg" width="1700"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0290">
         In this case, the constructor will initialize the value of the
         <span class="inlinecode">
          mName
         </span>
         data member to “ObjectName” when the object is created. As a result, you can omit defining the constructor if all it would do is set initial values for each data member. Instead, you can rely on the compiler-generated constructor to set the default values specified in the data member initializers.
        </p>
        <p class="text" id="p0295">
         This helps to achieve the so-called Rule of Zero, which states that you should avoid defining any special functions, such as constructors and destructors, if you can (i.e., you should rely upon the implicitly defined version of these functions that the compiler generates whenever possible).
        </p>
        <p class="text" id="p0300">
         It's still possible to define a value for each data member in the constructor. In that case, any initialization you implement in the constructor will override the value from the initializer. For example, we can add a constructor to the class as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0080">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000064/main.assets/u07-015-9780443222191.jpg" width="1700"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0305">
         In this case, the zero-argument constructor will still initialize the
         <span class="inlinecode">
          mName
         </span>
         data member with the string “ObjectName”, but the second constructor that accepts a string argument will override the data member initializer. For example,
         <span class="inlinecode">
          MyObject("OverrideName")
         </span>
         will set
         <span class="inlinecode">
          mName
         </span>
         to “OverrideName”.
        </p>
        <div>
         <aside aria-labelledby="b0015" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0015">
           <div class="b1textfl" id="bpar0020">
            <i>
             TIP
            </i>
            :
            <i>
             For simple data member initialization cases
            </i>
            ,
            <i>
             you can use C++11 data member initializers and avoid defining a custom constructor
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p261">
         </a>
        </p>
        <div>
         <span aria-label="261" epub:type="pagebreak" id="pagebreak_261" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         Initializer list constructors
        </h3>
        <p class="textfl" id="p0310">
         C++11 introduced support for list initialization using curly bracket syntax, letting you initialize containers thus:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-016-9780443222191.jpg" width="1596"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0315">
         or more simply,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-017-9780443222191.jpg" width="1492"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0320">
         You can also support initialization of your own classes using this syntax by defining a constructor that uses
         <span class="inlinecode">
          std::initializer_list
         </span>
         . For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-018-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0325">
         Inside the
         <span class="inlinecode">
          initializer_list
         </span>
         constructor, you can refer to
         <span class="inlinecode">
          intList.size()
         </span>
         to get the number of values, and you can use
         <span class="inlinecode">
          intList.begin()
         </span>
         and
         <span class="inlinecode">
          intList.end()
         </span>
         to iterate over the elements.
        </p>
        <p class="text" id="p0330">
         With that class declaration, you can do the following:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-019-9780443222191.jpg" width="1871"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0335">
         Calling
         <span class="inlinecode">
          MyClass{1}
         </span>
         will call the
         <span class="inlinecode">
          initializer_list
         </span>
         constructor, whereas the regular syntax
         <span class="inlinecode">
          MyClass(1)
         </span>
         will call the single int constructor. Also, empty curly braces will generally prefer calling the default constructor instead of the
         <span class="inlinecode">
          initializer_list
         </span>
         one, because an empty initializer list should behave like a default constructor, but the default constructor should be more efficient.
        </p>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         Smart pointers
        </h3>
        <p class="textfl" id="p0340">
         A smart pointer is a class template that wraps a raw (or bare) pointer and provides management of the heap-allocated resource. From an implementation perspective, it's just a class that overloads the
         <span class="inlinecode">
          -&gt;
         </span>
         and
         <span class="inlinecode">
          ∗
         </span>
         operators so that it behaves like a pointer, but with additional capabilities.
         <a id="p262">
         </a>
        </p>
        <div>
         <span aria-label="262" epub:type="pagebreak" id="pagebreak_262" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0345">
         The key benefit of smart pointers is that they take care of deleting the memory associated with the pointer at some well-defined point in time. This can help avoid many common memory errors such as leaking memory, writing to unallocated memory, and double freeing memory.
        </p>
        <p class="text" id="p0350">
         C++11 introduced several different types of smart pointer in the
         <span class="inlinecode">
          &lt;memory&gt;
         </span>
         header. We covered these in
         <a href="../B9780443222191000143/CH0002_25-80_B9780443222191000143.xhtml">
          Chapter 2
         </a>
         , but to recap them here they are:
        </p>
        <div>
         <ul class="ce_list" id="ulist0020">
          <li class="numlist" id="p0355">
           <a id="u0035">
           </a>
           -
           <span class="inlinecode">
            std::shared_ptr
           </span>
           : a reference-counted pointer in which the pointer is deallocated when the reference count reaches zero.
          </li>
          <li class="numlist" id="p0360">
           <a id="u0040">
           </a>
           -
           <span class="inlinecode">
            std::weak_ptr
           </span>
           : provides a way to refer to a
           <span class="inlinecode">
            shared_ptr
           </span>
           without influencing its reference count (e.g., to break reference cycles).
          </li>
          <li class="numlist" id="p0365">
           <a id="u0045">
           </a>
           -
           <span class="inlinecode">
            std::unique_ptr
           </span>
           : deallocates the pointer when the unique pointer goes out of scope.
          </li>
         </ul>
        </div>
        <p class="text" id="p0370">
         To illustrate these concepts more concretely, here is an example of a raw pointer in which the pointer must be specifically deallocated using the
         <span class="inlinecode">
          delete
         </span>
         keyword:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-020-9780443222191.jpg" width="1073"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0375">
         For simple code, it can be easy to ensure that the object is deleted at the right time. But for more complex code, in which the pointer might be passed around through different functions and stored by different objects, it can be difficult to know when to delete the object safely.
        </p>
        <p class="text" id="p0380">
         By contrast, an
         <span class="inlinecode">
          std::shared_ptr
         </span>
         will automatically delete the pointer when all references go out of scope, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-021-9780443222191.jpg" width="2287"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0385">
         If you're returning pointers from your API, then it's much safer to return them as shared pointers. I like to introduce a type definition for a shared pointer of any object that I intend to reference with a pointer, just to make the syntax easier to work with. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000064/main.assets/u07-022-9780443222191.jpg" width="1594"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p263">
         </a>
        </p>
        <div>
         <span aria-label="263" epub:type="pagebreak" id="pagebreak_263" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0390">
         In addition to returning pointers from your API, you can use a shared pointer to allocate a private data member object in your constructor and have it be automatically deallocated when the object is destroyed, without having to handle this explicitly in the destructor. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000064/main.assets/u07-023-9780443222191.jpg" width="1421"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0395">
         As for weak pointers, these are useful to return an object when you don't want to grant shared ownership of the underlying object to the client. That is, you don't want the client's act of holding on to the pointer to prevent the object from being cleaned up when all other references are released. A classic example of this is returning a pointer to an object in a cache, in which the object might get ejected from the cache and deleted, even if the client is still holding on to the weak pointer. This is better than returning a raw pointer because the client can check whether the underlying data have already been deleted by using the
         <span class="inlinecode">
          expired()
         </span>
         member function.
        </p>
        <p class="text" id="p0400">
         The final smart pointer type in C++11 is the unique pointer,
         <span class="inlinecode">
          std::unique_ptr
         </span>
         . This is a simpler version of
         <span class="inlinecode">
          std::shared_ptr
         </span>
         with no reference counting, meaning that you cannot copy a unique pointer. This is useful when you want to tie the lifetime of the object to a block of code. You can also use a unique pointer with a data member to avoid having to delete the pointer manually in the destructor, in the same way that we saw earlier for
         <span class="inlinecode">
          std::shared_ptr
         </span>
         . The difference in the
         <span class="inlinecode">
          std::unique_ptr
         </span>
         case is that the containing object will no longer be copyable. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0125">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000064/main.assets/u07-024-9780443222191.jpg" width="2289"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0405">
         To summarize, you should use
         <span class="inlinecode">
          std::shared_ptr
         </span>
         if ownership of a resource can be shared among several objects. You should use an
         <span class="inlinecode">
          std::unique_ptr
         </span>
         if the resource should
         <a id="p264">
         </a>
         <span aria-label="264" epub:type="pagebreak" id="pagebreak_264" role="doc-pagebreak">
         </span>
         be owned only by a single object. And you should use an
         <span class="inlinecode">
          std::weak_ptr
         </span>
         if you want to share temporary ownership of the resource.
        </p>
       </section>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         Enum classes
        </h3>
        <p class="textfl" id="p0410">
         Enumerated types are user-defined types with named values. They are useful for referring to a set of constants with meaningful names. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0130">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-025-9780443222191.jpg" width="380"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0415">
         However, C++03-style enums have several problems, including:
        </p>
        <div>
         <ul class="ce_list" id="olist0015">
          <li class="numlist" id="p0420">
           <a id="o0030">
           </a>
           1.
           <b>
            Type safety:
           </b>
           Enums are essentially integers. A value from one enum can be compared with a value from another enum, even though they may have no semantic relation. Also, enums can be implicitly converted to integers, which can sometimes lead to confusion.
          </li>
          <li class="numlist" id="p0425">
           <a id="o0035">
           </a>
           2.
           <b>
            Naming collisions:
           </b>
           All enum values exist at the same level of scope as the enum definition, which means that no two enums at the same scope can share the same value. To get around this, you must either use unique prefixes for each enum value (e.g.,
           <span class="inlinecode">
            MODE_READ
           </span>
           ) or define the enum within a class or a different namespace.
          </li>
          <li class="numlist" id="p0430">
           <a id="o0040">
           </a>
           3.
           <b>
            Undefined size:
           </b>
           The underlying integer type used to represent an enum is implementation-dependent and depends upon the definition of its values. Furthermore, you cannot directly specify the size of an enum.
          </li>
          <li class="numlist" id="p0435">
           <a id="o0045">
           </a>
           4.
           <b>
            No forward declarations:
           </b>
           Because the size of an enum is unknown, it's not possible to forward declare an enum type. As a result, if you want to refer to an enum, then you must include the header file where it's defined.
          </li>
         </ul>
        </div>
        <p class="text" id="p0440">
         To address these issues, C++11 introduced the concept of enum classes, sometimes also called scoped enums. The syntax for an enum class is similar to a traditional enum with the addition of the class (or struct) keyword:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0135">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-026-9780443222191.jpg" width="588"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0445">
         You must refer to the values of an enum class by prefixing them with the name of the enum (e.g.,
         <span class="inlinecode">
          Mode::Read
         </span>
         or
         <span class="inlinecode">
          Mode::Write)
         </span>
         . This means that you can define two enum classes at the same level of scope that have the same value names, such as:
         <a id="p265">
         </a>
         <span aria-label="265" epub:type="pagebreak" id="pagebreak_265" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0140">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-027-9780443222191.jpg" width="797"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0450">
         In this case,
         <span class="inlinecode">
          Mode::Read
         </span>
         and
         <span class="inlinecode">
          Permission::Read
         </span>
         do not clash with each other because of the enum class namespace. They also cannot be compared with or assigned to each other because they are different types.
        </p>
        <p class="text" id="p0455">
         Enum classes are also not implicitly converted to integers, which offers stronger type safety. For example, imagine a function that accepts an integer as an argument, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0145">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-028-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0460">
         It would be possible to call this function with a traditional enum value, such as
         <span class="inlinecode">
          SetSize(READ)
         </span>
         , which may not make a lot of sense. However, this is not possible with an enum class because it cannot be implicitly converted to an integer. For example,
         <span class="inlinecode">
          SetSize(Mode::Read)
         </span>
         will produce a compiler error.
        </p>
        <p class="text" id="p0465">
         Although the size of a traditional enum is undefined, the size of a class enum is defined to be the size of an int. You can change this if you need to by defining the base integral type of the enum (you can also do this for traditional enums as of C++11). For example, we could redefine our
         <span class="inlinecode">
          Mode
         </span>
         enum class to be the same size as a char:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0150">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-029-9780443222191.jpg" width="832"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0470">
         Finally, because the default size of an enum class is well-defined, it's now possible to forward declare these types. This is particularly useful in API design because it lets you refer to an enum type without having to include the header file directly where it's defined. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0155">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-030-9780443222191.jpg" width="1906"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0475">
         It should be clear that enum classes have many advantages over regular C++03 enums. They offer stronger type safety, scoping of value names, well-defined memory sizes, and the ability to forward declare them. For all of these reasons, you should prefer using enum classes over regular enums in your APIs whenever possible.
        </p>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <div class="b1textfl" id="bpar0025">
            <i>
             TIP
            </i>
            :
            <i>
             Always prefer using a C++11 enum class over a regular C++03 enum
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p266">
         </a>
        </p>
        <div>
         <span aria-label="266" epub:type="pagebreak" id="pagebreak_266" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0050">
        </a>
        <h3 class="h2hd" id="cesectitle0060">
         Override and final specifiers
        </h3>
        <p class="textfl" id="p0480">
         C++ supports an inheritance model in which a derived class can override the implementation of a virtual function in a base class. However, there are several ways to introduce subtle errors with the original C++03 inheritance syntax. For example, if you intend to override a function in a derived class, you should define the function in the base class as
         <span class="inlinecode">
          virtual
         </span>
         . However, if you don't do that, your code may still appear to work as expected in some cases. Consider these two classes:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0160">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000064/main.assets/u07-031-9780443222191.jpg" width="2221"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0485">
         This code declares a
         <span class="inlinecode">
          Func()
         </span>
         function in both the
         <span class="inlinecode">
          Base
         </span>
         and
         <span class="inlinecode">
          Derived
         </span>
         classes, but the function is not declared as
         <span class="inlinecode">
          virtual
         </span>
         in the
         <span class="inlinecode">
          Base
         </span>
         class. Nevertheless, this code still works as you would expect:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0165">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-032-9780443222191.jpg" width="554"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0490">
         produces the following output:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0170">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-033-9780443222191.jpg" width="519"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0495">
         The problem, however, is that the compiler will not be able to do dynamic binding at run time without the
         <span class="inlinecode">
          virtual
         </span>
         keyword. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0175">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000064/main.assets/u07-034-9780443222191.jpg" width="1004"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p267">
         </a>
        </p>
        <div>
         <span aria-label="267" epub:type="pagebreak" id="pagebreak_267" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0500">
         produces the unexpected output of:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0180">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-035-9780443222191.jpg" width="415"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0505">
         That is, the
         <span class="inlinecode">
          Base
         </span>
         class version of the function is called in the second case even though we pass in a pointer to a
         <span class="inlinecode">
          Derived
         </span>
         object. The solution is to declare the
         <span class="inlinecode">
          Base::Func()
         </span>
         function as
         <span class="inlinecode">
          virtual
         </span>
         to ensure that we get dynamic function binding instead of static binding; that is,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0185">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-036-9780443222191.jpg" width="2394"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0510">
         Another possible error that can be encountered overriding a function is if you don't match the function names exactly, either because you spelled the name wrong or you renamed the function in one class but forgot to rename it in the other. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0190">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000064/main.assets/u07-037-9780443222191.jpg" width="2394"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0515">
         In this case,
         <span class="inlinecode">
          Base::Func()
         </span>
         is declared as virtual. However, in the
         <span class="inlinecode">
          Derived
         </span>
         class, although the intent is to override the function, an error was made by using a lowercase version of the function name,
         <span class="inlinecode">
          Derived::func()
         </span>
         . This will compile, but it will not achieve the intended goal of overriding the base class function.
        </p>
        <p class="text" id="p0520">
         C++11 introduced syntax to solve both of these kinds of errors with a new
         <span class="inlinecode">
          override
         </span>
         specifier that can be defined on the overridden function. This lets the compiler know that you intend to override a virtual function in a base class. The compiler can then generate an error if the function is not marked as
         <span class="inlinecode">
          virtual
         </span>
         in the base class, or if the function does not exist in the base class. For example, this will not compile in C++11:
         <a id="p268">
         </a>
         <span aria-label="268" epub:type="pagebreak" id="pagebreak_268" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0195">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000064/main.assets/u07-038-9780443222191.jpg" width="2462"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0525">
         Similarly, this code will also not compile:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0200">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000064/main.assets/u07-039-9780443222191.jpg" width="2427"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0530">
         C++11 introduced another feature to provide more flexibility around object inheritance: the
         <span class="inlinecode">
          final
         </span>
         specifier. This can be used on a class to prevent it from being derived further. It can also be used on a virtual function to indicate that it can't be overridden in derived classes. For example, the following code will fail to compile because the
         <span class="inlinecode">
          Base
         </span>
         class is marked as
         <span class="inlinecode">
          final
         </span>
         and therefore cannot be used as a base class for the
         <span class="inlinecode">
          Derived
         </span>
         class.
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0205">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000064/main.assets/u07-040-9780443222191.jpg" width="2496"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0535">
         The next example illustrates using the
         <span class="inlinecode">
          final
         </span>
         specifier to prevent a specific function from being overridden in a derived class:
         <a id="p269">
         </a>
         <span aria-label="269" epub:type="pagebreak" id="pagebreak_269" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0210">
           <img alt="image" height="1065" src="../../IMAGES/B9780443222191000064/main.assets/u07-041-9780443222191.jpg" width="2462"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0540">
         The
         <span class="inlinecode">
          final
         </span>
         specifier can therefore be used to prevent your clients from deriving further subclasses or overriding virtual functions in further subclasses. It can also be used to improve performance by allowing a virtual function to be transformed into a direct method call, a process called devirtualization.
        </p>
        <p class="text" id="p0545">
         Microsoft introduced a
         <span class="inlinecode">
          sealed
         </span>
         keyword in Visual C++ before the
         <span class="inlinecode">
          final
         </span>
         keyword was added to the standard. The two keywords are equivalent, but
         <span class="inlinecode">
          final
         </span>
         is the one you should use to be standards compliant.
        </p>
        <p class="text" id="p0550">
         A good practice to adopt is to ensure that any virtual function you define uses only one of
         <span class="inlinecode">
          virtual
         </span>
         ,
         <span class="inlinecode">
          override
         </span>
         , or
         <span class="inlinecode">
          final
         </span>
         :
        </p>
        <div>
         <ul class="ce_list" id="olist0020">
          <li class="numlist" id="p0555">
           <a id="o0050">
           </a>
           1. Use
           <span class="inlinecode">
            virtual
           </span>
           to introduce a new virtual function.
          </li>
          <li class="numlist" id="p0560">
           <a id="o0055">
           </a>
           2. Use
           <span class="inlinecode">
            override
           </span>
           to declare a nonfinal overridden function.
          </li>
          <li class="numlist" id="p0565">
           <a id="o0060">
           </a>
           3. Use
           <span class="inlinecode">
            final
           </span>
           to declare a virtual function that cannot be overridden further.
          </li>
         </ul>
        </div>
        <div>
         <aside aria-labelledby="b0025" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0025">
           <div class="b1textfl" id="bpar0030">
            <i>
             TIP
            </i>
            :
            <i>
             Always use exactly one of
            </i>
            <span class="inlinecode">
             <i>
              virtual
             </i>
            </span>
            ,
            <span class="inlinecode">
             <i>
              override
             </i>
            </span>
            ,
            <i>
             or
            </i>
            <span class="inlinecode">
             <i>
              final
             </i>
            </span>
            <i>
             for every virtual function
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0055">
        </a>
        <h3 class="h2hd" id="cesectitle0065">
         The noexcept specifier
        </h3>
        <p class="textfl" id="p0570">
         C++11 introduced the
         <span class="inlinecode">
          noexcept
         </span>
         exception specifier, which you can add to a function signature to indicate that it can or won't throw an exception. There's also a
         <span class="inlinecode">
          noexcept
         </span>
         operator that can be used to perform a compile-time check to see if an expression may or won't throw an exception. For example:
         <a id="p270">
         </a>
         <span aria-label="270" epub:type="pagebreak" id="pagebreak_270" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0215">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-042-9780443222191.jpg" width="1665"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0575">
         You should obviously not use
         <span class="inlinecode">
          noexcept
         </span>
         on a function that throws an exception. Your compiler will likely tell you if you try to do this. Remember that allocating memory with the
         <span class="inlinecode">
          new
         </span>
         operator can throw an
         <span class="inlinecode">
          std::bad_alloc
         </span>
         exception if it runs out of memory, so you shouldn't use
         <span class="inlinecode">
          noexcept
         </span>
         on functions where you perform memory allocation.
        </p>
        <p class="text" id="p0580">
         So when should you use
         <span class="inlinecode">
          noexcept
         </span>
         ? The original reason for adding this specifier was to allow faster move constructors to be used within Standard Library code. For example, resizing an
         <span class="inlinecode">
          std::vector
         </span>
         can be implemented just by moving every element if it's known that the element's move constructor won't throw an exception. Otherwise, the slower copy constructor will have to be used if there's a chance that an exception can be thrown. So you can make your types behave more optimally in an
         <span class="inlinecode">
          std::vector
         </span>
         by specifying
         <span class="inlinecode">
          noexcept
         </span>
         for the move constructor and move assignment operator. This will happen by default for any implicitly defined move functions. Thus the
         <span class="inlinecode">
          noexcept
         </span>
         specifier is really of use only when you are defining your own move functions, or for code that you know uses
         <span class="inlinecode">
          std::move_if_noexcept
         </span>
         or
         <span class="inlinecode">
          std::is_nothrow_constructible
         </span>
         to provide a faster code path. Other than those cases, you probably don't need to worry about this feature.
        </p>
        <p class="text" id="p0585">
         The C++ language originally included a
         <span class="inlinecode">
          throw
         </span>
         exception specifier, which was deprecated in C++11 and removed in C++17. This would let you indicate which exceptions a function might throw, as well as that it will throw no exceptions. The first of these cases is generally considered bad practice, partly because the compiler can't enforce it, and so the
         <span class="inlinecode">
          throw
         </span>
         specifier was removed from the standard. The
         <span class="inlinecode">
          noexcept
         </span>
         specifier was added to cover the one reasonable use of
         <span class="inlinecode">
          throw
         </span>
         : to state whether a function will or won't throw an exception. You should therefore not use the
         <span class="inlinecode">
          throw
         </span>
         specifier and use
         <span class="inlinecode">
          noexcept
         </span>
         only in cases where it makes sense, as described earlier.
        </p>
       </section>
       <section>
        <a id="s0060">
        </a>
        <h3 class="h2hd" id="cesectitle0070">
         Inline namespaces
        </h3>
        <p class="textfl" id="p0590">
         Namespaces are an important feature for API design in C++ because they help to ensure that your names don't clash with symbols in other libraries. To recap, you can place your names within a namespace such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0220">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-043-9780443222191.jpg" width="866"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p271">
         </a>
        </p>
        <div>
         <span aria-label="271" epub:type="pagebreak" id="pagebreak_271" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0595">
         Then you would refer to your names using the namespace as a prefix, such as
         <span class="inlinecode">
          MyLibrary::MyFunction()
         </span>
         . You can also nest namespaces, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0225">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-044-9780443222191.jpg" width="762"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0600">
         where you would then refer to your function as
         <span class="inlinecode">
          Parent::Child::MyFunction()
         </span>
         .
        </p>
        <p class="text" id="p0605">
         C++11 extended the namespace functionality with a feature called inline namespaces, in which all members of the namespace are also automatically added to the enclosing namespace. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0230">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-045-9780443222191.jpg" width="831"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0610">
         This makes your function accessible as
         <span class="inlinecode">
          Parent::MyFunction()
         </span>
         in addition to
         <span class="inlinecode">
          Parent::Child::MyFunction()
         </span>
         . One reason to do this with respect to API design is to be able to offer different versions of your API and easily declare one of these as the current or default version. For example, consider these declarations:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0235">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000064/main.assets/u07-046-9780443222191.jpg" width="866"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0615">
         This API offers two nested namespaces:
         <span class="inlinecode">
          MyLibrary::v1
         </span>
         and
         <span class="inlinecode">
          MyLibrary::v2
         </span>
         . We have declared the second one to be
         <span class="inlinecode">
          inline
         </span>
         , so its symbols are added to the
         <span class="inlinecode">
          MyLibrary
         </span>
         namespace. As a result, your clients can simply refer to
         <span class="inlinecode">
          MyLibrary::MyFunction()
         </span>
         to get the latest definition of your function. But if they needed to, they could also refer directly to a specific version of the function, such as
         <span class="inlinecode">
          MyLibrary::v1::MyFunction()
         </span>
         or
         <span class="inlinecode">
          MyLibrary::v2::MyFunction()
         </span>
         .
         <a id="p272">
         </a>
        </p>
        <div>
         <span aria-label="272" epub:type="pagebreak" id="pagebreak_272" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0620">
         This also gives you a way to prerelease new functionality and let clients try it out before you officially release it. For example, you could add a
         <span class="inlinecode">
          MyLibrary::v3
         </span>
         namespace but not mark it as
         <span class="inlinecode">
          inline
         </span>
         initially. That way, clients who wanted to try out the new function could explicitly call the
         <span class="inlinecode">
          MyLibrary::v3::MyFunction()
         </span>
         version and give you any relevant feedback. Then, when you are ready, you could mark the
         <span class="inlinecode">
          v3
         </span>
         namespace as
         <span class="inlinecode">
          inline
         </span>
         to officially release the new version.
        </p>
        <p class="text" id="p0625">
         When you refer to the inlined symbol
         <span class="inlinecode">
          MyLibrary::MyFunction(
         </span>
         ) the compiler will resolve this to the full namespace in the generated object file. For example, in the previous instance that would be the symbol
         <span class="inlinecode">
          MyLibrary::v2::MyFunction()
         </span>
         . This means that if you release a new version, such as
         <span class="inlinecode">
          MyLibrary::v3
         </span>
         , any modules that are not recompiled with the new API version will continue to link against the
         <span class="inlinecode">
          v2
         </span>
         symbols. It's therefore important not to remove old version namespaces; otherwise you will break ABI backward compatibility.
        </p>
        <p class="text" id="p0630">
         I'll further discuss the use of inline namespaces to manage API versioning in the later chapter on Versioning.
        </p>
       </section>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         Type aliases with using
        </h3>
        <p class="textfl" id="p0635">
         C++ has always let you introduce an alias for a type name with the
         <span class="inlinecode">
          typedef
         </span>
         keyword, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0240">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-047-9780443222191.jpg" width="1213"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0640">
         This example introduces a type alias called
         <span class="inlinecode">
          IntVector
         </span>
         that can be used anywhere in place of
         <span class="inlinecode">
          std::vector&lt;int&gt;
         </span>
         . As of C++11, you can also express this same type alias with the
         <span class="inlinecode">
          using
         </span>
         keyword, as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0245">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-048-9780443222191.jpg" width="1212"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0645">
         The readability benefits of this new syntax become more obvious when you consider how to define a type alias for a function pointer. The
         <span class="inlinecode">
          typedef
         </span>
         syntax looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0250">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-049-9780443222191.jpg" width="1143"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0650">
         whereas the
         <span class="inlinecode">
          using
         </span>
         syntax is much more easy to interpret:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0255">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-050-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0655">
         The
         <span class="inlinecode">
          using
         </span>
         syntax offers the same semantics as the
         <span class="inlinecode">
          typedef
         </span>
         syntax, so they can be used interchangeably. In particular, neither of these options defines a new type, just an alias for the type. However, there are additional capabilities that the
         <span class="inlinecode">
          using
         </span>
         syntax offers for
         <a id="p273">
         </a>
         <span aria-label="273" epub:type="pagebreak" id="pagebreak_273" role="doc-pagebreak">
         </span>
         templates. The traditional
         <span class="inlinecode">
          typedef
         </span>
         syntax does not support templates, so the following is not valid C++:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0260">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-051-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0660">
         However, this is now possible with the new using syntax:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0265">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-052-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0665">
         Overall, the
         <span class="inlinecode">
          using
         </span>
         syntax offers the same functionality as
         <span class="inlinecode">
          typedef
         </span>
         , with additional support for templated type aliases, and it's also easier to read and understand. So the
         <span class="inlinecode">
          using
         </span>
         syntax should generally be preferred over typedef for modern C++ API development.
        </p>
        <div>
         <aside aria-labelledby="b0030" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0030">
           <div class="b1textfl" id="bpar0035">
            <i>
             TIP
            </i>
            :
            <i>
             Prefer
            </i>
            <span class="inlinecode">
             <i>
              using
             </i>
            </span>
            <i>
             instead of
            </i>
            <span class="inlinecode">
             <i>
              typedef
             </i>
            </span>
            <i>
             for better readability and template support
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         User-defined literals
        </h3>
        <p class="textfl" id="p0670">
         As we discussed in the Qualities chapter, a good API should be difficult to misuse. One possible area for misuse is providing the wrong value for a function parameter, either because you have multiple parameters of the same type or because it's not clear which units you should use. This is an area in which the new feature of user-defined literals can help.
        </p>
        <p class="text" id="p0675">
         C++ supports several different built-in formats to define literals of different types, including:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0270">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-053-9780443222191.jpg" width="832"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0680">
         As of C++11, you can define your own literal formats. This can be used to define units for certain quantities and to convert between those units. For example, imagine you have an API that accepts a weight parameter in units of grams. You can allow your clients to be specific that they are passing values in grams and allow them also to provide values in kilograms or pounds. The syntax for this looks like:
         <a id="p274">
         </a>
         <span aria-label="274" epub:type="pagebreak" id="pagebreak_274" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0275">
           <img alt="image" height="833" src="../../IMAGES/B9780443222191000064/main.assets/u07-054-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0685">
         With these definitions, clients can now use literals such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0280">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-055-9780443222191.jpg" width="241"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0690">
         For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0285">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-056-9780443222191.jpg" width="1179"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0695">
         We can also combine this feature with custom types for your quantities, so that you can support parameters with specific types rather than using generic primitive types. For example, here's the definition of a class that holds a temperature value in degrees Celsius:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0290">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000064/main.assets/u07-057-9780443222191.jpg" width="2359"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p275">
         </a>
        </p>
        <div>
         <span aria-label="275" epub:type="pagebreak" id="pagebreak_275" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0700">
         You'll see that I've added a couple of user-defined literals to allow clients to specify values for this class in either Celsius or Fahrenheit. Moreover, by making the constructor be
         <span class="inlinecode">
          explicit
         </span>
         , this prevents implicit type conversions, essentially forcing clients to use your new literals to specify the units of any values they provide, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0295">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-058-9780443222191.jpg" width="2324"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0705">
         This feature is therefore a great tool to help you build APIs that make it difficult for your users to misuse your design.
        </p>
        <p class="text" id="p0710">
         As a final note on this topic, you can define these custom literals for only a limited set of types, which is why I used
         <span class="inlinecode">
          long double
         </span>
         in my earlier examples and I had to deal with casting to
         <span class="inlinecode">
          double
         </span>
         . This list defines the set of supported parameters on literal operators in C++11:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0300">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000064/main.assets/u07-059-9780443222191.jpg" width="1075"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0715">
         C++20 added a couple of further types to this list:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0305">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-060-9780443222191.jpg" width="1387"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0075">
        </a>
        <h3 class="h2hd" id="cesectitle0085">
         Alternate function style
        </h3>
        <p class="textfl" id="p0720">
         C++11 introduced a new style for defining a function's return type. For example, consider a simple function declaration to return the sum of two integers:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0310">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-061-9780443222191.jpg" width="761"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0725">
         Starting with C++11, you can express this function signature using the trailing return type style:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0315">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-062-9780443222191.jpg" width="1040"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p276">
         </a>
        </p>
        <div>
         <span aria-label="276" epub:type="pagebreak" id="pagebreak_276" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0730">
         In this style, you use the
         <span class="inlinecode">
          auto
         </span>
         keyword in the normal return type position to indicate that you'll provide the return type later. Then you can provide the type information after all of the parameters have been declared. These two forms are functionally equivalent, so it's really a matter of personal taste which one you use in your APIs.
        </p>
        <p class="text" id="p0735">
         There was, however, a legitimate reason for adding this new syntax to the specification. It was introduced to solve a particular problem related to function templates, in which you need to define the return type based on the type of one or more function arguments. You might try to represent this using the traditional function style as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0320">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-063-9780443222191.jpg" width="2114"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0740">
         However, this is not valid C++ because the
         <span class="inlinecode">
          lhs
         </span>
         and
         <span class="inlinecode">
          rhs
         </span>
         variables are defined after the return type, so the compiler cannot deduce their types. (The
         <span class="inlinecode">
          decltype
         </span>
         keyword was introduced in C++11 to let you specify a type based on another entity or expression.)
        </p>
        <p class="text" id="p0745">
         The new trailing return type function style lets you solve this by putting the return type at the end of the function signature, once the types of
         <span class="inlinecode">
          lhs
         </span>
         and
         <span class="inlinecode">
          rhs
         </span>
         are known to the compiler:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0325">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-064-9780443222191.jpg" width="2394"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0750">
         (C++14 introduced automatic return type deduction to make this function syntax even simpler. Refer to the section on C++14 for more details on that update.)
        </p>
       </section>
       <section>
        <a id="s0080">
        </a>
        <h3 class="h2hd" id="cesectitle0090">
         Tuples
        </h3>
        <p class="textfl" id="p0755">
         A tuple is an ordered collection of a fixed number of heterogeneous values. Support for tuples was introduced in C++11 with the
         <span class="inlinecode">
          std::tuple
         </span>
         template. Tuples are a generalization of the
         <span class="inlinecode">
          std::pair
         </span>
         type from C++98, which can only hold exactly two values. Tuples can be used to return multiple results from a function. For example, this function returns a tuple containing information to describe a user:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0330">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-065-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0760">
         This function can be used as follows to access the elements of the tuple:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0335">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-066-9780443222191.jpg" width="1874"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p277">
         </a>
        </p>
        <div>
         <span aria-label="277" epub:type="pagebreak" id="pagebreak_277" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0765">
         The downside is that you can only reference each of the elements of the tuple using a compile-time constant index, such as
         <span class="inlinecode">
          std::get&lt;1&gt;(user)
         </span>
         . That is, you can't use a meaningful name to refer to the components of a tuple. In most cases when you're designing an API, you will want to return information that has some semantic meaning. As such, it will usually be better to use a named struct to hold the information so that the elements can be referred to by an appropriate name, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0340">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000064/main.assets/u07-067-9780443222191.jpg" width="1109"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0770">
         Your clients can then access the return values of the function by name; for example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0345">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-068-9780443222191.jpg" width="1665"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0035" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0035">
           <div class="b1textfl" id="bpar0040">
            <i>
             TIP
            </i>
            :
            <i>
             Use a tuple as a return type only when the values represent independent entities
            </i>
            .
            <i>
             Otherwise
            </i>
            ,
            <i>
             prefer using a class or struct to assign meaningful names to each element
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0085">
        </a>
        <h3 class="h2hd" id="cesectitle0095">
         Constant expressions
        </h3>
        <p class="textfl" id="p0775">
         C++98 offered the ability to declare a variable as
         <span class="inlinecode">
          const
         </span>
         , to indicate that its value should not be changed. The value of such a constant can be evaluated at run time, and the compiler then prevents the programmer from modifying it further.
        </p>
        <p class="text" id="p0780">
         C++11 introduced a new specifier called
         <span class="inlinecode">
          constexpr
         </span>
         , which provides the further constraint that it must be possible to calculate the constant value statically: that is, at compile time, not run time. A trivial example is:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0350">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-069-9780443222191.jpg" width="1039"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p278">
         </a>
        </p>
        <div>
         <span aria-label="278" epub:type="pagebreak" id="pagebreak_278" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0785">
         Although you could also use
         <span class="inlinecode">
          const
         </span>
         in this case, the additional benefit of declaring a variable as
         <span class="inlinecode">
          constexpr
         </span>
         is that it can be used at points where a compile-time constant is needed. A nonexhaustive list of examples includes:
        </p>
        <div>
         <ol id="ulist0025">
          <li class="bulllist" id="p0790">
           <a id="u0050">
           </a>
           • The value of a switch
           <span class="inlinecode">
            case
           </span>
           statement must be a compile-time constant.
          </li>
          <li class="bulllist" id="p0795">
           <a id="u0055">
           </a>
           • Nontype template parameters must be constant expressions.
          </li>
          <li class="bulllist" id="p0800">
           <a id="u0060">
           </a>
           • The expression in a
           <span class="inlinecode">
            static_assert()
           </span>
           call must be known at compile time.
          </li>
         </ol>
        </div>
        <p class="text" id="p0805">
         For example, consider this simple function, which calculates the factorial of a number:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0355">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-070-9780443222191.jpg" width="1631"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0810">
         This function cannot be used in the following cases where a compile-time constant is required. For example, all of the following code examples will fail to compile:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0360">
           <img alt="image" height="1123" src="../../IMAGES/B9780443222191000064/main.assets/u07-071-9780443222191.jpg" width="2394"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0815">
         To make that code work as of C++11, all you need to do is to declare the result of the
         <span class="inlinecode">
          Factorial
         </span>
         function to be
         <span class="inlinecode">
          constexpr
         </span>
         (i.e., to make it a constant expression function):
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0365">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-072-9780443222191.jpg" width="1631"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0820">
         With that change, all of the earlier examples will now compile (i.e., the result of this function can be calculated at compile time). Not every function can be defined as a constant expression. There are several constraints, including (among others):
        </p>
        <div>
         <ol id="ulist0030">
          <li class="bulllist" id="p0825">
           <a id="u0065">
           </a>
           • The function must not be virtual (until C++20).
           <a id="p279">
           </a>
          </li>
          <li>
           <span aria-label="279" epub:type="pagebreak" id="pagebreak_279" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p0830">
           <a id="u0070">
           </a>
           • The type of any return value or parameters must be a literal type, such as a scalar (e.g.,
           <span class="inlinecode">
            std::is_scalar&lt;T&gt;()
           </span>
           returns
           <span class="inlinecode">
            true
           </span>
           ) or reference type (e.g.,
           <span class="inlinecode">
            std::is_reference&lt;T&gt;()
           </span>
           returns
           <span class="inlinecode">
            true
           </span>
           ).
          </li>
          <li class="bulllist" id="p0835">
           <a id="u0075">
           </a>
           • The function should contain exactly one
           <span class="inlinecode">
            return
           </span>
           statement (unless it's a constructor).
          </li>
          <li class="bulllist" id="p0840">
           <a id="u0080">
           </a>
           • The function body cannot contain a
           <span class="inlinecode">
            try
           </span>
           block (until C++20), a
           <span class="inlinecode">
            goto
           </span>
           statement, a
           <span class="inlinecode">
            static
           </span>
           variable, or call a non
           <span class="inlinecode">
            constexpr
           </span>
           function.
          </li>
         </ol>
        </div>
        <div>
         <aside aria-labelledby="b0040" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0040">
           <div class="b1textfl" id="bpar0045">
            <i>
             TIP
            </i>
            :
            <i>
             Declare a constant or function as
            </i>
            <span class="inlinecode">
             <i>
              constexpr
             </i>
            </span>
            <i>
             if it might need to be evaluated at compile time
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0090">
        </a>
        <h3 class="h2hd" id="cesectitle0100">
         The nullptr keyword
        </h3>
        <p class="textfl" id="p0845">
         The C and C++98 programming languages use a macro called
         <span class="inlinecode">
          NULL
         </span>
         to represent a pointer value that's not pointing at valid data. The definition of this macro is implementation dependent, but it's often defined as
         <span class="inlinecode">
          (void ∗)0
         </span>
         . One issue with this is that
         <span class="inlinecode">
          NULL
         </span>
         can be implicitly converted to integral types, which can cause ambiguity issues such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0370">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-073-9780443222191.jpg" width="1768"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0850">
         This is an error because
         <span class="inlinecode">
          NULL
         </span>
         can be interpreted as both a pointer and an integer, so the compiler doesn't know which overloaded function to use. To address this issue, C++11 introduced a keyword called
         <span class="inlinecode">
          nullptr
         </span>
         that's of type
         <span class="inlinecode">
          std::nullptr_t
         </span>
         and is not implicitly convertible or comparable to integer types (i.e.,
         <span class="inlinecode">
          int x = nullptr
         </span>
         will not compile).
        </p>
        <p class="text" id="p0855">
         Now we can use
         <span class="inlinecode">
          nullptr
         </span>
         in the previous example and the compiler will know to use the overloaded version of
         <span class="inlinecode">
          Function
         </span>
         that uses a pointer parameter:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0375">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-074-9780443222191.jpg" width="1073"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0045" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0045">
           <div class="b1textfl" id="bpar0050">
            <i>
             TIP
            </i>
            :
            <i>
             Always prefer
            </i>
            <span class="inlinecode">
             <i>
              nullptr
             </i>
            </span>
            <i>
             over
            </i>
            <span class="inlinecode">
             <i>
              NULL
             </i>
            </span>
            <i>
             when working with pointer types to improve type safety
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p280">
         </a>
        </p>
        <div>
         <span aria-label="280" epub:type="pagebreak" id="pagebreak_280" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0095">
        </a>
        <h3 class="h2hd" id="cesectitle0105">
         Variadic templates
        </h3>
        <p class="textfl" id="p0860">
         Templates in C++03 could accept only a fixed number of arguments. However, C++11 introduced variadic templates, which are templates that can accept a variable number of arguments. This is achieved by introducing the concept of parameter packs that accept zero or more template arguments, in which each argument can be a type, a nontype, or a template. The basic syntax for a variadic function template is:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0380">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-075-9780443222191.jpg" width="865"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0865">
         Note the use of the ellipsis (
         <span class="inlinecode">
          ...
         </span>
         ) after the
         <span class="inlinecode">
          typename
         </span>
         keyword. This is referred to as a template parameter pack and specifies that the template can accept zero or more arguments. Each of the arguments can be of a different type. Also note the ellipsis in the function argument list. This is called a function parameter pack and indicates that the function can accept the same multiple arguments.
        </p>
        <p class="text" id="p0870">
         Often you want to enforce that one or more arguments are passed to the function, instead of only zero or more. The standard way to do that is to define a regular template parameter followed by a parameter pack, which looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0385">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-076-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0875">
         Let's look at a specific example. In this case, we will implement a variadic function template called
         <span class="inlinecode">
          printLine
         </span>
         that will output all of its arguments to stdout followed by a newline:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0390">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000064/main.assets/u07-077-9780443222191.jpg" width="1316"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0880">
         We can call this function as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0395">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-078-9780443222191.jpg" width="1247"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0885">
         which will produce the output:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0400">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-079-9780443222191.jpg" width="553"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p281">
         </a>
        </p>
        <div>
         <span aria-label="281" epub:type="pagebreak" id="pagebreak_281" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0890">
         Variadic templates are often implemented using recursion. That is, we process the first parameter and then call the function template again with the remaining parameters. This will bottom out with a call to an overloaded version of the function that ends the recursion, known as the base case. That's what the nontemplated
         <span class="inlinecode">
          printLine
         </span>
         function is for in the previous example. Walking through this in more detail,
        </p>
        <div>
         <ul class="ce_list" id="olist0025">
          <li class="numlist" id="p0895">
           <a id="o0065">
           </a>
           1. We start with the initial invocation:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0405">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-080-9780443222191.jpg" width="1248"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0030">
          <li class="numlist" id="p0900">
           <a id="o0070">
           </a>
           2. This causes the first argument to be output and then recursively calls the function with the remaining arguments:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0410">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-081-9780443222191.jpg" width="901"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0035">
          <li class="numlist" id="p0905">
           <a id="o0075">
           </a>
           3. Calling the function template again, the next argument is output and we recursively call the function with the last remaining argument:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0415">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-082-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0040">
          <li class="numlist" id="p0910">
           <a id="o0080">
           </a>
           4. We then output the last parameter and call the function with an empty parameter list:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0420">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-083-9780443222191.jpg" width="867"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0045">
          <li class="numlist" id="p0915">
           <a id="o0085">
           </a>
           5. This will call the nontemplated overload of
           <span class="inlinecode">
            printLine
           </span>
           that will output a newline character and terminate the recursion:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0425">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-084-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0920">
         Moreover, we can implement this variadic function template without having to define a base version of the function. We can do this by referring to the size of the parameter pack within the template using the
         <span class="inlinecode">
          sizeof...()
         </span>
         operator:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0430">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-085-9780443222191.jpg" width="1316"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p282">
         </a>
        </p>
        <div>
         <span aria-label="282" epub:type="pagebreak" id="pagebreak_282" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0925">
         C/C++ supported a mechanism to implement variable parameters for nontemplate functions before the introduction of variadic templates (i.e., through
         <span class="inlinecode">
          va_args
         </span>
         in the
         <span class="inlinecode">
          cstdarg
         </span>
         header). However, variadic templates offer a more type-safe solution in which the parameter expansion happens at compile time and therefore allows more compiler optimizations to be performed. As such, the use of C++11 variadic templates should be preferred over the C-style
         <span class="inlinecode">
          va_args
         </span>
         approach where feasible.
        </p>
        <div>
         <aside aria-labelledby="b0050" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0050">
           <div class="b1textfl" id="bpar0055">
            <i>
             TIP
            </i>
            :
            <i>
             Prefer the use of variadic templates when you need to define a function with a variable number of arguments
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0100">
        </a>
        <h3 class="h2hd" id="cesectitle0110">
         Migrating to C++11
        </h3>
        <p class="textfl" id="p0930">
         I have covered many C++11 features that can improve your API designs in this section. We'll conclude this discussion by talking about how you can migrate an existing C++03 API to C++11, and which features you may want to prioritize adopting over others. One of the core concerns you may have in this regard is how these new features will affect backward compatibility for your API, so I'll organize the section with that concern in mind:
        </p>
        <div>
         <ol id="ulist0035">
          <li class="bulllist" id="p0935">
           <a id="u0085">
           </a>
           •
           <b>
            Compatible Changes:
           </b>
           Although ABI compatibility is ultimately implementation dependent for your compiler, it should be possible to adopt the following C++11 features without breaking ABI (or source) compatibility:
          </li>
          <li class="bulllist">
           <ol id="ulist0040">
            <li class="bulllist1" id="p0940">
             <a id="u0090">
             </a>
             •
             <b>
              Delegating constructors:
             </b>
             Using a delegating constructor lets you change how the constructor is implemented, but it doesn't change the function signature.
            </li>
            <li class="bulllist1" id="p0945">
             <a id="u0095">
             </a>
             •
             <b>
              Data member initializers:
             </b>
             If you are simply removing initialization of a member variable from a constructor's initialization list and replacing it with a data member initializer, this will not change the signature of the constructor.
            </li>
            <li class="bulllist1" id="p0950">
             <a id="u0100">
             </a>
             •
             <b>
              Alternate function style:
             </b>
             The alternate function style, in which the return value is declared after the function parameters, is simply a syntactical difference. The binary representation of the function should be the same whether you're using the original function syntax or the new format.
            </li>
            <li class="bulllist1" id="p0955">
             <a id="u0105">
             </a>
             •
             <b>
              Using versus typedef:
             </b>
             Employing the
             <span class="inlinecode">
              using
             </span>
             keyword as an alternative to
             <span class="inlinecode">
              typedef
             </span>
             is again just syntactic sugar. More importantly, these define an alias for a new type, not an actual new type, so whether you use
             <span class="inlinecode">
              using
             </span>
             or
             <span class="inlinecode">
              typedef
             </span>
             should not make any functional difference. However, the
             <span class="inlinecode">
              using
             </span>
             syntax is a little easier to understand, so it's worth adopting for clarity reasons.
            </li>
            <li class="bulllist1" id="p0960">
             <a id="u0110">
             </a>
             •
             <b>
              Override keyword:
             </b>
             This keyword lets the compiler perform additional compile-time checks to ensure that you're overriding a virtual member function. However, it should not affect the generated binary code for your interface.
            </li>
            <li class="bulllist1" id="p0965">
             <a id="u0115">
             </a>
             •
             <b>
              Constant expressions:
             </b>
             Declaring your constants with
             <span class="inlinecode">
              constexpr
             </span>
             , where possible, should be backward compatible because it will just add the ability for your constants to be used in cases where a compile-time value is required.
            </li>
           </ol>
          </li>
          <li class="bulllist">
           <a id="p283">
           </a>
          </li>
          <li>
           <span aria-label="283" epub:type="pagebreak" id="pagebreak_283" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p0970">
           <a id="u0120">
           </a>
           •
           <b>
            Breaking Changes:
           </b>
           The following C++11 features are worth considering but could cause breaking changes for your clients:
          </li>
          <li class="bulllist">
           <ol id="ulist0045">
            <li class="bulllist1" id="p0975">
             <a id="u0125">
             </a>
             •
             <b>
              Smart pointers:
             </b>
             Switching from raw C pointers to smart pointers will involve representing your pointers with a different type. This will most likely require your clients to change their code (unless they are compiling from your source and have already changed their code to use the C++11 auto keyword to store your pointers). However, the safety benefits of using smart pointers are large, so it's worth strongly considering adopting them.
            </li>
            <li class="bulllist1" id="p0980">
             <a id="u0130">
             </a>
             •
             <b>
              Enum classes:
             </b>
             The size of an enum may be different from an enum class, so switching between them is not guaranteed to be binary compatible. Also, your clients will have to change their code to include the enum name when they refer to its values. It may not be worth breaking API compatibility to move to enum classes, but if you're adding new functionality, then enum classes should be preferred over traditional C++03 enums.
            </li>
            <li class="bulllist1" id="p0985">
             <a id="u0135">
             </a>
             •
             <b>
              Inline namespaces:
             </b>
             This feature is a great way to introduce robust versioning into your APIs. However, if you try to add this to an existing API, then it will change the name mangling of your symbols so it will break ABI compatibility. However, it should be possible to preserve source compatibility if you're diligent.
            </li>
            <li class="bulllist1" id="p0990">
             <a id="u0140">
             </a>
             •
             <b>
              Final keyword:
             </b>
             It's possible that adding a final specifier to an existing class will not break the ABI. However, if clients have already written code to override the final function, or inherit from the final class, then their code will now fail to compile because of your new constraint. This is therefore something you could chose to do for an existing API, but you should first check with your clients to see if their code would break, and to understand their use cases if it does.
            </li>
            <li class="bulllist1" id="p0995">
             <a id="u0145">
             </a>
             •
             <b>
              Variadic templates:
             </b>
             If you were previously using
             <span class="inlinecode">
              va_arg
             </span>
             to implement support for variable function arguments, you could consider using variadic templates instead to provide a more efficient and type-safe solution. However, although the function calling syntax can be made to be the same, these two approaches are not ABI compatible, so making this change will break your clients' projects if you're distributing your library in binary form.
            </li>
           </ol>
          </li>
         </ol>
        </div>
       </section>
      </section>
      <section>
       <a id="s0105">
       </a>
       <h2 class="h1hd" id="cesectitle0115">
        C++14 API features
       </h2>
       <p class="textfl" id="p1000">
        C++14 was published in Dec. 2014 as a minor update to C++11. It largely consisted of a few bug fixes and incremental improvements, so the list of features I'll cover here is not as large as for C++11. However, there are a few notable new features for your API designs that we'll discuss.
       </p>
       <p class="text" id="p1005">
        As of 2012, the C++ Standards Committee committed to a regular 3-year schedule to release updates to the C++ international standard. Nonetheless, C++14 was sometimes referred to as C++1y during its development before its final publication date was officially known, in the same way that C++11 was referred to as C++0x early on.
        <a id="p284">
        </a>
       </p>
       <div>
        <span aria-label="284" epub:type="pagebreak" id="pagebreak_284" role="doc-pagebreak">
        </span>
       </div>
       <section>
        <a id="s0110">
        </a>
        <h3 class="h2hd" id="cesectitle0120">
         The auto return type
        </h3>
        <p class="textfl" id="p1010">
         Recall that C++11 introduced a trailing return type function style that looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0435">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-086-9780443222191.jpg" width="1040"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1015">
         C++14 took this a step further by introducing function return type deduction. Essentially, you no longer need to define the function return type after the parameter list. Instead, the return type will be deduced based on the actual
         <span class="inlinecode">
          return
         </span>
         statements defined within the function body. The previous function signature can therefore be simplified to just:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0440">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-087-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1020">
         To support this syntax, all return values in the function body must be of the same type. For example, you could not have one
         <span class="inlinecode">
          return
         </span>
         statement return
         <span class="inlinecode">
          2
         </span>
         and another returning
         <span class="inlinecode">
          6.0
         </span>
         because those are different types (int and double, respectively). This would not be an error in a regular function where the return type is explicitly declared because the compiler can perform implicit conversion to the known return type.
        </p>
        <p class="text" id="p1025">
         More critically, functions declared in this way can be forward declared, but the compiler must be able to see the implementation of the function in the translation unit that uses it to deduce the return type. For example, imagine that our
         <span class="inlinecode">
          Add
         </span>
         function is declared in an
         <span class="inlinecode">
          add.h
         </span>
         header, which is used by client code in
         <span class="inlinecode">
          client.cpp
         </span>
         :
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0445">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000064/main.assets/u07-088-9780443222191.jpg" width="2323"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1030">
         This code will not compile, because the code in
         <span class="inlinecode">
          client.cpp
         </span>
         sees only the forward declaration of
         <span class="inlinecode">
          Add
         </span>
         and does not have access to the implementation body to deduce the return type. Nevertheless the client code will eventually link against the
         <span class="inlinecode">
          add.cpp
         </span>
         file with the implementation code. The key point is that the implementation is not available at compile time when compiling the
         <span class="inlinecode">
          client.cpp
         </span>
         translation unit.
        </p>
        <p class="text" id="p1035">
         In other words, in terms of API design, return type deduction forces you to expose your implementation details. You should therefore avoid using this feature in your APIs. An exception would be if you're using this for a function template in which you're forced to expose the implementation code in the header file anyway. Of course, it's also fine to
         <a id="p285">
         </a>
         <span aria-label="285" epub:type="pagebreak" id="pagebreak_285" role="doc-pagebreak">
         </span>
         use this feature within your implementation code, such as for static functions defined within your
         <span class="inlinecode">
          .cpp
         </span>
         files.
        </p>
        <div>
         <aside aria-labelledby="b0055" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0055">
           <div class="b1textfl" id="bpar0060">
            <i>
             TIP
            </i>
            :
            <i>
             Do not use function return type deduction in your APIs because it exposes implementation details (unless it's for already exposed details such as a function template)
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0115">
        </a>
        <h3 class="h2hd" id="cesectitle0125">
         The deprecated attribute
        </h3>
        <p class="textfl" id="p1040">
         An important part of the API life cycle is being able to deprecate older functionality (often giving your clients a new way to achieve the same thing) before finally removing the older functionality from a future version of the API. An important way to communicate that something is deprecated is to cause compiler warnings in your clients' code when they call the deprecated functionality. That way, they get a visible and annoying nudge that they need to update their use of your API.
        </p>
        <p class="text" id="p1045">
         Before C++14, there were compiler-specific ways to achieve this, but there was no standards-compliant solution. C++14 addressed this by introducing the
         <span class="inlinecode">
          [[deprecated]]
         </span>
         attribute. You can use this before any function signature to indicate that the function is deprecated. You can also optionally provide a message that will be included in the compiler warning. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0450">
           <img alt="image" height="1065" src="../../IMAGES/B9780443222191000064/main.assets/u07-089-9780443222191.jpg" width="2322"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1050">
         Compiling this code with clang produces the following compiler output:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0455">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-090-9780443222191.jpg" width="2531"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p286">
         </a>
        </p>
        <div>
         <span aria-label="286" epub:type="pagebreak" id="pagebreak_286" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1055">
         You can use
         <span class="inlinecode">
          [[deprecated]]
         </span>
         in front of a function signature, whether it is a free function, a function template, or a class method. You can also use it in front of a variable definition to deprecate any constants that your API may define. However, you cannot currently use it to deprecate an entire class, struct, or enum.
        </p>
        <div>
         <aside aria-labelledby="b0060" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0060">
           <div class="b1textfl" id="bpar0065">
            <i>
             TIP
            </i>
            :
            <i>
             Use the
            </i>
            <span class="inlinecode">
             <i>
              [[deprecated(msg)]]
             </i>
            </span>
            <i>
             attribute to indicate that a function may be removed in a future version of your API
            </i>
            .
            <i>
             Always include a useful message to describe how clients can update their code to avoid the deprecated functionality
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1060">
         I will go into more detail about deprecating and ultimately removing functionality from your APIs in the later chapter on Versioning.
        </p>
       </section>
       <section>
        <a id="s0120">
        </a>
        <h3 class="h2hd" id="cesectitle0130">
         Variable templates
        </h3>
        <p class="textfl" id="p1065">
         In C++03, you can create templated versions of classes and functions. C++11 added support for templating of type aliases with the
         <span class="inlinecode">
          using
         </span>
         keyword and C++14 added templating of variables. A variable template is a template that defines a family of variables or static data members based on one or more template parameters. The general syntax is:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0460">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-091-9780443222191.jpg" width="797"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1070">
         For example, we can provide a definition of the constant pi:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0465">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-092-9780443222191.jpg" width="1351"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1075">
         We can then instantiate this variable template for different types, such as
         <span class="inlinecode">
          pi&lt;float&gt;
         </span>
         and
         <span class="inlinecode">
          pi&lt;double&gt;
         </span>
         . An interesting aspect of this technique is that we can use template specialization to provide a custom value of the variable for different types. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0470">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-093-9780443222191.jpg" width="1421"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1080">
         (I'm using
         <span class="inlinecode">
          constexpr
         </span>
         in each of these templates, except for the
         <span class="inlinecode">
          std::string
         </span>
         specialization that uses
         <span class="inlinecode">
          const
         </span>
         . That's because you can't define a
         <span class="inlinecode">
          std::string constexpr
         </span>
         , at least until C++20, or until C++17 if you use
         <span class="inlinecode">
          std::string_view.
         </span>
         )
         <a id="p287">
         </a>
        </p>
        <div>
         <span aria-label="287" epub:type="pagebreak" id="pagebreak_287" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1085">
         The effect of these definitions can be demonstrated as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0475">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-094-9780443222191.jpg" width="1943"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1090">
         which will output the following results:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0480">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-095-9780443222191.jpg" width="345"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1095">
         So if you refer to
         <span class="inlinecode">
          pi&lt;float&gt;
         </span>
         you will get the specialized value 3.1415, and if you refer to
         <span class="inlinecode">
          pi&lt;std::string&gt;
         </span>
         you will get the self-descriptive string “pi”. Although this may be abstractly interesting, the main reason for introducing variable template support was because C++ didn't previously allow a template to declare a variable. One common workaround for this was to wrap a variable in a templated struct or class, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0485">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-096-9780443222191.jpg" width="1836"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1100">
         However, this meant having to refer to variables such as
         <span class="inlinecode">
          Pi&lt;float&gt;::value
         </span>
         instead of just
         <span class="inlinecode">
          pi&lt;float&gt;
         </span>
         , as is now possible with variable templates.
        </p>
        <p class="text" id="p1105">
         Variable templates can be declared only at the global (or namespace) scope or as static data members of a class. They are most useful for defining constants, and as such they are often declared as
         <span class="inlinecode">
          const
         </span>
         or
         <span class="inlinecode">
          constexpr
         </span>
         , as you saw in the previous examples.
        </p>
       </section>
       <section>
        <a id="s0125">
        </a>
        <h3 class="h2hd" id="cesectitle0135">
         Const expression improvements
        </h3>
        <p class="textfl" id="p1110">
         In the earlier C++11 section of this chapter, I introduced the use of
         <span class="inlinecode">
          constexpr
         </span>
         to evaluate the value of a variable or the result of a function at compile time. To make this feasible, various constraints were enforced on what you could do in the body of a function to allow it to be evaluated at compile time. With C++14, this set of constraints was relaxed to allow more complexity within constant expression function. Specifically, these functions can now contain:
        </p>
        <div>
         <ol id="ulist0050">
          <li class="bulllist" id="p1115">
           <a id="u0150">
           </a>
           • Declarations with initializers, except
           <span class="inlinecode">
            static
           </span>
           or
           <span class="inlinecode">
            thread_local
           </span>
           variables.
          </li>
          <li class="bulllist" id="p1120">
           <a id="u0155">
           </a>
           • Conditional branching statements (e.g.,
           <span class="inlinecode">
            if
           </span>
           and
           <span class="inlinecode">
            switch)
           </span>
           .
          </li>
          <li class="bulllist" id="p1125">
           <a id="u0160">
           </a>
           • Looping statements (e.g.,
           <span class="inlinecode">
            for
           </span>
           and
           <span class="inlinecode">
            while)
           </span>
           .
          </li>
          <li class="bulllist" id="p1130">
           <a id="u0165">
           </a>
           • Expressions that change the value of an object defined within the function.
          </li>
         </ol>
        </div>
        <p class="textfl">
         <a id="p288">
         </a>
        </p>
        <div>
         <span aria-label="288" epub:type="pagebreak" id="pagebreak_288" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1135">
         For example, this function will not compile with C++11 because of the use of looping and local variables. However it will compile in C++14:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0490">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-097-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1140">
         So if you are building your project in an environment that supports C++14 or later, you can have more complex constant expression functions that allow more opportunity for compile-time optimization.
        </p>
       </section>
       <section>
        <a id="s0130">
        </a>
        <h3 class="h2hd" id="cesectitle0140">
         Binary literals and digit separators
        </h3>
        <p class="textfl" id="p1145">
         C++ has always supported ways to declare numeric constants in different bases. There's the default base 10, of course, as well as hexadecimal (base 16) constants that use the
         <span class="inlinecode">
          0x
         </span>
         prefix (e.g.,
         <span class="inlinecode">
          0xdeadbeef
         </span>
         ) and octal (base 8) constants that use a 0 prefix (e.g.,
         <span class="inlinecode">
          0172)
         </span>
         . C++14 introduced the ability to define numeric literals in binary (base 2) using the
         <span class="inlinecode">
          0b
         </span>
         or
         <span class="inlinecode">
          0B
         </span>
         prefix. This might be useful when defining constants for your APIs that are better expressed in binary representation, such as bit masks. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0495">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-098-9780443222191.jpg" width="1491"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1150">
         Another C++14 change related to numeric literals is the introduction of the single quote character as a digit separator for both integer and floating-pointing literals. The quote character has no impact on the interpretation of the number, but it can be used to make it easier for humans to parse large numbers by breaking the value up into smaller sections, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0500">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-099-9780443222191.jpg" width="1802"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0135">
        </a>
        <h3 class="h2hd" id="cesectitle0145">
         Migrating to C++14
        </h3>
        <p class="textfl" id="p1155">
         As I noted in the introduction to this section, C++14 was a much smaller update than C++11 and focused largely on minor enhancements and bug fixes.
        </p>
        <p class="text" id="p1160">
         The main new C++14 feature that affects API design is the standardized support for deprecating functions and constants. This is a really important feature to have at our disposal because most long-lived APIs will need to go through design changes at some
         <a id="p289">
         </a>
         <span aria-label="289" epub:type="pagebreak" id="pagebreak_289" role="doc-pagebreak">
         </span>
         point to handle new functionality, offer more general capabilities, or even break backward compatibility. The most elegant ways to introduce these kinds of API design changes are to:
        </p>
        <div>
         <ul class="ce_list" id="olist0050">
          <li class="numlist" id="p1165">
           <a id="o0090">
           </a>
           1. Introduce a new way to perform some task in your API.
          </li>
          <li class="numlist" id="p1170">
           <a id="o0095">
           </a>
           2. Mark the existing way of performing the task as deprecated.
          </li>
          <li class="numlist" id="p1175">
           <a id="o0100">
           </a>
           3. Communicate the new way of performing the task to all of your clients so they can change their code accordingly.
          </li>
          <li class="numlist" id="p1180">
           <a id="o0105">
           </a>
           4. Once all clients have moved to the new approach, you can safely remove the deprecated way from the API.
          </li>
         </ul>
        </div>
        <p class="text" id="p1185">
         As such, having the ability to mark functions and constants as deprecated is an important part of the life cycle of an API. You should use the
         <span class="inlinecode">
          [[deprecated]]
         </span>
         attribute whenever you need to communicate your intent to make future breaking changes to your API.
        </p>
        <p class="text" id="p1190">
         Other than that, we covered a few other more minor C++14 features that could affect your API designs, including:
        </p>
        <div>
         <ol id="ulist0055">
          <li class="bulllist" id="p1195">
           <a id="u0170">
           </a>
           • Function return type deduction: as I noted, you should generally avoid using this in your public APIs unless it's part of a function template.
          </li>
          <li class="bulllist" id="p1200">
           <a id="u0175">
           </a>
           • Variable templates: these can be used to produce more concise constants in your templated code, such as
           <span class="inlinecode">
            pi&lt;float&gt;
           </span>
           instead of
           <span class="inlinecode">
            pi&lt;float&gt;::value
           </span>
           , but they will change your API surface and break backward compatibility.
          </li>
          <li class="bulllist" id="p1205">
           <a id="u0180">
           </a>
           • Constant expressions, binary literals, and digit separators: these are all minor enhancements that you can employ if you know that all of your clients are using a C++14 or later compiler.
          </li>
         </ol>
        </div>
       </section>
      </section>
      <section>
       <a id="s0140">
       </a>
       <h2 class="h1hd" id="cesectitle0150">
        C++17 API features
       </h2>
       <p class="textfl" id="p1210">
        The C++17 standard was published in Dec. 2017 after being referred to temporarily as C++1z during its development. This revision to the standard added many new features to the core language and the Standard Library, including several container classes such as
        <span class="inlinecode">
         std::optional
        </span>
        ,
        <span class="inlinecode">
         std::any
        </span>
        , and
        <span class="inlinecode">
         std:variant
        </span>
        . It also removed several older features, such as
        <span class="inlinecode">
         std::auto_ptr
        </span>
        (replaced by
        <span class="inlinecode">
         std::unique_ptr
        </span>
        ), the compiler hint keyword
        <span class="inlinecode">
         register
        </span>
        (deprecated in C++11), and dynamic exception specifications (such as
        <span class="inlinecode">
         void myFunc() throw(int)
        </span>
        ). In the following sections, I'll cover the key features of C++17 that you can use in your API designs.
       </p>
       <section>
        <a id="s0145">
        </a>
        <h3 class="h2hd" id="cesectitle0155">
         Inline variables
        </h3>
        <p class="textfl" id="p1215">
         With C++03, if you wanted to declare a global or namespace scope constant, you could try:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0505">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-100-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p290">
         </a>
        </p>
        <div>
         <span aria-label="290" epub:type="pagebreak" id="pagebreak_290" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1220">
         However, this would cause every translation unit that included the header to create a new internal (i.e., static) linkage copy of the variable, which will cause the final binary to hold multiple copies of the data and be larger than necessary. The normal way to avoid this was to declare the variable as
         <span class="inlinecode">
          extern
         </span>
         and then define the value within a
         <span class="inlinecode">
          .cpp
         </span>
         file. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0510">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-101-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1225">
         This solves the binary size issue, but it has the unfortunate downsides that clients can no longer see the value of the constant simply by inspecting your header file, and you must split the declaration and definition across two files.
        </p>
        <p class="text" id="p1230">
         C++17 introduced a solution to this with support for inline variables. This allows a global or namespace scope variable to be declared as
         <span class="inlinecode">
          inline
         </span>
         in a header file. The header can then be included in multiple translation units and the variable will have external linkage in each translation unit, so the linker will merge all instances of the variable into a single definition at link time. You can therefore avoid using
         <span class="inlinecode">
          extern
         </span>
         for your API constants and simply define everything in your headers, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0515">
           <img alt="image" height="140" src="../../IMAGES/B9780443222191000064/main.assets/u07-102-9780443222191.jpg" width="1421"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0065" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0065">
           <div class="b1textfl" id="bpar0070">
            <i>
             TIP
            </i>
            :
            <i>
             Use inline variables to define constants in your header files
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1235">
         You can also use inline variables for static class data members. For example, if you want to create a class scope constant in C++03, then you would have to do this:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0520">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-103-9780443222191.jpg" width="1525"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1240">
         You can't provide the value of the static data member in the header file. It must be defined in the associated
         <span class="inlinecode">
          .cpp
         </span>
         file. But as of C++17, you can declare the static data
         <a id="p291">
         </a>
         <span aria-label="291" epub:type="pagebreak" id="pagebreak_291" role="doc-pagebreak">
         </span>
         member as
         <span class="inlinecode">
          inline
         </span>
         , allowing you to provide the variable's value directly in the header file, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0525">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-104-9780443222191.jpg" width="1804"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1245">
         Moreover, any
         <span class="inlinecode">
          static constexpr
         </span>
         class data members are also implicitly
         <span class="inlinecode">
          inline
         </span>
         variables. So you can also just write something like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0530">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-105-9780443222191.jpg" width="1873"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1250">
         As a result of allowing global variables to be defined only in your header files, inline variables can also make it easier for you to create header-only libraries.
        </p>
       </section>
       <section>
        <a id="s0150">
        </a>
        <h3 class="h2hd" id="cesectitle0160">
         String views
        </h3>
        <p class="textfl" id="p1255">
         The original C language supports strings as either null-terminated character pointers or character arrays: for example,
         <span class="inlinecode">
          const char ∗
         </span>
         or
         <span class="inlinecode">
          char[]
         </span>
         . These are efficient to pass around because they are just pointers, but you must explicitly manage the memory for these strings yourself, normally with
         <span class="inlinecode">
          malloc()
         </span>
         and
         <span class="inlinecode">
          free()
         </span>
         .
        </p>
        <p class="text" id="p1260">
         C++98 introduced the
         <span class="inlinecode">
          std::string
         </span>
         object to hold a text string and offer various member functions to operate on the string. This object takes care of the memory management for you, but copying these objects by value can be more expensive, particularly for large strings. As a result, it's common practice to pass
         <span class="inlinecode">
          std::string
         </span>
         objects into functions as const references to avoid the cost of copying the string data.
        </p>
        <p class="text" id="p1265">
         C++17 introduced the
         <span class="inlinecode">
          std::string_view
         </span>
         class, which provides support for read-only strings that are cheaper to pass around. These strings views are normally implemented with just two quantities:
        </p>
        <div>
         <ul class="ce_list" id="olist0055">
          <li class="numlist" id="p1270">
           <a id="o0110">
           </a>
           1. A pointer to an existing character array, such as a
           <span class="inlinecode">
            const char ∗
           </span>
           .
          </li>
          <li class="numlist" id="p1275">
           <a id="o0115">
           </a>
           2. The size of the array, such as a
           <span class="inlinecode">
            size_t
           </span>
           .
          </li>
         </ul>
        </div>
        <p class="text" id="p1280">
         The character array itself is not owned by the string view or copied by the string view, so you must be careful not to use the string view after the underlying character data has been deleted. Also, unlike
         <span class="inlinecode">
          std::string
         </span>
         , an
         <span class="inlinecode">
          std::string_view
         </span>
         can hold a null pointer. Moreover, because a
         <span class="inlinecode">
          string_view
         </span>
         keeps a specific record of the size of the character array, the array does not need to hold a terminating null character.
         <a id="p292">
         </a>
        </p>
        <div>
         <span aria-label="292" epub:type="pagebreak" id="pagebreak_292" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1285">
         One useful feature of
         <span class="inlinecode">
          std::string_view
         </span>
         is that it offers implicit conversions from
         <span class="inlinecode">
          std::string
         </span>
         and
         <span class="inlinecode">
          const char ∗
         </span>
         types. So it's easy to pass in different kinds of strings to a function that uses string view arguments. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0535">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-106-9780443222191.jpg" width="1559"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1290">
         (It’s idiomatic to pass
         <span class="inlinecode">
          std::string_view
         </span>
         objects by value because they're cheap to copy and it gives the compiler greater opportunities for optimization.)
        </p>
        <p class="text" id="p1295">
         In addition to using
         <span class="inlinecode">
          std::string_view
         </span>
         for function arguments, you might think about returning an
         <span class="inlinecode">
          std::string_view
         </span>
         for an
         <span class="inlinecode">
          std::string
         </span>
         data member, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0540">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000064/main.assets/u07-107-9780443222191.jpg" width="1871"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1300">
         However, the string view does not take a copy of the string data, so if a client were to keep a hold of the string view returned by
         <span class="inlinecode">
          GetName()
         </span>
         after the object had been deleted, the behavior would be undefined and could lead to a crash. You can think of returning a string view as equivalent to returning a const reference or pointer, which I generally discourage because of the lifetime concerns I just mentioned and because it returns a handle to your private implementation details.
        </p>
        <p class="text" id="p1305">
         For these reasons, I would avoid returning
         <span class="inlinecode">
          std::string_view
         </span>
         from a function. There are certainly ways to make it safe (e.g., returning statically allocated data that will exist until the program ends), but unless the performance gain is really important to you, it's safer just to return an
         <span class="inlinecode">
          std::string
         </span>
         . It's also less surprising for your clients because string views don't offer the same richness of methods. For example, they do not have a
         <span class="inlinecode">
          c_str()
         </span>
         function because the string data may not be null terminated.
        </p>
        <p class="text" id="p1310">
         Similarly, I would avoid storing an
         <span class="inlinecode">
          std::string_view
         </span>
         in a class data member if you don't also own the underlying string data within your library or you don't otherwise know the lifetime of the data. This is for the same reason that it’s dangerous to hold on to a raw C pointer when you don't know when the memory will be deleted.
         <a id="p293">
         </a>
        </p>
        <div>
         <span aria-label="293" epub:type="pagebreak" id="pagebreak_293" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1315">
         The main takeaway is that string views are a performance optimization feature that you should fully understand before you commit to exposing them in your API designs. It's helpful to think of them as just a
         <span class="inlinecode">
          const char ∗
         </span>
         pointer and make the same API design decisions you would for such a type.
        </p>
        <p class="text" id="p1320">
         However, there is another benefit of
         <span class="inlinecode">
          std::string_view
         </span>
         , which is that it can be used to initialize constant expressions, which is something for which you can't use
         <span class="inlinecode">
          std::string
         </span>
         (at least until C++20) because it's not a literal type. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0545">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-108-9780443222191.jpg" width="2290"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1325">
         In these cases, the source string data are statically allocated by the compiler and will persist until the program ends, so you don't need to worry about lifetime concerns.
        </p>
        <div>
         <aside aria-labelledby="b0070" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0070">
           <div class="b1textfl" id="bpar0075">
            <i>
             TIP
            </i>
            :
            <i>
             Consider using
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :string_view
             </i>
            </span>
            <i>
             instead of
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :string
             </i>
            </span>
            <i>
             for a function argument if you don't need to own or modify the string data and if the associated performance gain is important for your use case
            </i>
            .
            <i>
             You can also use
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :string_view
             </i>
            </span>
            <i>
             to define compile-time string constants with
            </i>
            <span class="inlinecode">
             <i>
              constexpr
             </i>
            </span>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1330">
         Although
         <span class="inlinecode">
          std::string_view
         </span>
         is used to represent a read-only string, it does offer several methods that appear to modify the string but in fact just change the underlying pointer or size data members. For example, the
         <span class="inlinecode">
          remove_prefix()
         </span>
         method simply increases the pointer by
         <i>
          n
         </i>
         and reduces the size of the string by the same
         <i>
          n
         </i>
         . This is possible because the string view doesn't own the underlying data array, so it can be updated to point to any subset of characters within the array. However, if you need to change the contents of a string, you should use an
         <span class="inlinecode">
          std::string
         </span>
         .
        </p>
       </section>
       <section>
        <a id="s0155">
        </a>
        <h3 class="h2hd" id="cesectitle0165">
         Optional
        </h3>
        <p class="textfl" id="p1335">
         There are times when you may want to differentiate between a variable holding a value and holding no value. For example, if you are reading a true/false setting from a configuration file, you may want to know if a value for the setting was defined in the file and, if so, what that value was. If you simply use a
         <span class="inlinecode">
          bool
         </span>
         variable to represent the setting with a default of false, then you cannot differentiate between a configuration file that has no value for the setting and one that specifically sets the value to false. This might be important if you only wanted to change the current value of the setting if a value was explicitly provided.
        </p>
        <div id="p1340">
         One way to solve this is to use a
         <span class="inlinecode">
          bool
         </span>
         for the setting value and another
         <span class="inlinecode">
          bool
         </span>
         for whether the setting was defined in the file. However, this means representing every value with two variables. Another solution is to use a pointer, such as an
         <a id="p294">
         </a>
         <span aria-label="294" epub:type="pagebreak" id="pagebreak_294" role="doc-pagebreak">
         </span>
         <span class="inlinecode">
          std::shared_ptr&lt;bool&gt;
         </span>
         , in which you can use
         <span class="inlinecode">
          nullptr
         </span>
         to represent the absence of a value. However, in this case you have the additional overhead of dynamically allocating memory.
        </div>
        <p class="text" id="p1345">
         A common solution to this problem in many programming languages is the concept of an optional: essentially, the ability to state that a variable has no value. C++17 introduced functionality for this with the
         <span class="inlinecode">
          std::optional
         </span>
         class. Here's an example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0550">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-109-9780443222191.jpg" width="2255"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1350">
         The basic operations you can perform on an optional are:
        </p>
        <div>
         <ul class="ce_list" id="olist0060">
          <li class="numlist" id="p1355">
           <a id="o0120">
           </a>
           1.
           <b>
            Creation:
           </b>
           You can create either an empty optional or one that holds a value. There are various ways to do this, such as:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0555">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-110-9780443222191.jpg" width="1595"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0065">
          <li class="numlist" id="p1360">
           <a id="o0125">
           </a>
           2.
           <b>
            Setting/resetting:
           </b>
           You can set the value of an optional simply by assigning a value of the corresponding type. You can make the optional hold no value by assigning
           <span class="inlinecode">
            std::nullopt
           </span>
           to it or calling its
           <span class="inlinecode">
            reset()
           </span>
           method: that is:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0560">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-111-9780443222191.jpg" width="1178"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0070">
          <li class="numlist" id="p1365">
           <a id="o0130">
           </a>
           3.
           <b>
            Checking for a value:
           </b>
           You can check to see if an optional is holding a value by comparing it with
           <span class="inlinecode">
            std::nullopt
           </span>
           or by using the
           <span class="inlinecode">
            has_value()
           </span>
           method. For example,
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p295">
         </a>
         <span aria-label="295" epub:type="pagebreak" id="pagebreak_295" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0565">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-112-9780443222191.jpg" width="1387"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0075">
          <li class="numlist" id="p1370">
           <a id="o0135">
           </a>
           4.
           <b>
            Accessing the value:
           </b>
           If you have checked that the optional holds a value, you can access the value using the
           <span class="inlinecode">
            ∗
           </span>
           operator or the
           <span class="inlinecode">
            value()
           </span>
           method. If the optional holds an object, then you can use the
           <span class="inlinecode">
            -&gt;
           </span>
           <span title='hsp="0.25"'>
           </span>
           operator to access members of the object, such as:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0570">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-113-9780443222191.jpg" width="1351"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1375">
         An optional is normally implemented so that the value it contains is allocated as part of the optional object itself. That is, it does not contain a pointer that's dynamically allocated. However the interface for
         <span class="inlinecode">
          std::optional
         </span>
         uses the
         <span class="inlinecode">
          ∗
         </span>
         and
         <span class="inlinecode">
          -&gt;
         </span>
         <span title='hsp="0.25"'>
         </span>
         operators, which are normally associated with pointer types.
        </p>
        <div>
         <aside aria-labelledby="b0075" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0075">
           <div class="b1textfl" id="bpar0080">
            <i>
             TIP
            </i>
            :
            <i>
             Use
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :optional
             </i>
            </span>
            <i>
             when you need a quantity that can hold a value or that can represent having no value
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1380">
         To continue with the example of a configuration file, imagine that the settings from the file are returned in a
         <span class="inlinecode">
          Settings
         </span>
         object with accessors for each setting value. We could use an
         <span class="inlinecode">
          std::optional
         </span>
         as the return value for each accessor so that the client can differentiate between a value that appeared in the configuration file versus there being no value defined in the file. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0575">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-114-9780443222191.jpg" width="1594"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1385">
         The use of an optional as a function's return value can also help you differentiate between a valid return value and the absence of one. For example, consider a function that returns the offset of some item within a larger collection:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0580">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-115-9780443222191.jpg" width="2045"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p296">
         </a>
        </p>
        <div>
         <span aria-label="296" epub:type="pagebreak" id="pagebreak_296" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1390">
         In this case, the
         <span class="inlinecode">
          GetIndex()
         </span>
         function can return
         <span class="inlinecode">
          std::nullopt
         </span>
         if the item does not exist in the collection. This avoids the need to introduce a special sentinel value that you have to define for your clients (such as
         <span class="inlinecode">
          std::string::npos
         </span>
         , for example).
        </p>
        <p class="text" id="p1395">
         Some possible uses of
         <span class="inlinecode">
          std::optional
         </span>
         in your API designs include:
        </p>
        <div>
         <ul class="ce_list" id="olist0080">
          <li class="numlist" id="p1400">
           <a id="o0140">
           </a>
           1. Differentiating between a value and the absence of a value, such as knowing whether the user provided an overriding value for a setting.
          </li>
          <li class="numlist" id="p1405">
           <a id="o0145">
           </a>
           2. Returning the result of some computation in which the lack of a result is not inherently an error, such as searching for an item in a collection and handling the case in which the item doesn't appear.
          </li>
          <li class="numlist" id="p1410">
           <a id="o0150">
           </a>
           3. Allowing lazy loading of a potentially expensive resource, where you can pass around an optional and instantiate it with an actual value only when you need it.
          </li>
          <li class="numlist" id="p1415">
           <a id="o0155">
           </a>
           4. Supporting another way to express optional function parameters, particularly for arguments in which the optional value is intrinsic to the object, not just to the function signature (e.g., you may want to pass it through multiple function calls and preserve the optional nature), or when you wish to calculate the default value for the argument within the function body, either because of complexity or to hide it from your API.
          </li>
         </ul>
        </div>
        <p class="text" id="p1420">
         For cases in which you actually want to return both a valid result and some kind of error code or information, then a container such as
         <span class="inlinecode">
          std::pair
         </span>
         or
         <span class="inlinecode">
          std::tuple
         </span>
         would be more appropriate. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0585">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000064/main.assets/u07-116-9780443222191.jpg" width="2360"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1425">
         Or, if you are using C++23, you can use the
         <span class="inlinecode">
          std::expected
         </span>
         class template, which I'll cover in more detail later in this chapter.
        </p>
       </section>
       <section>
        <a id="s0160">
        </a>
        <h3 class="h2hd" id="cesectitle0170">
         Any
        </h3>
        <p class="textfl" id="p1430">
         C++ is a statically typed language, so the type of all variables must be known at compile time. This allows the compiler to do more checks and avoid certain classes of errors happening at run time. However, there are some cases in which you may want a variable to hold values of different types or you don't know the type until run time.
         <a id="p297">
         </a>
        </p>
        <div>
         <span aria-label="297" epub:type="pagebreak" id="pagebreak_297" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1435">
         As an example, the JSON file format supports heterogeneous arrays and dictionaries, so they can hold objects of different types. For example, this is a valid JSON dictionary:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0590">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-117-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1440">
         This dictionary has three values that are of different types (string, int, and bool). However, in C++ you must use a specific type for a
         <span class="inlinecode">
          std::vector
         </span>
         or
         <span class="inlinecode">
          std::map
         </span>
         container. For example,
         <span class="inlinecode">
          std::vector&lt;int&gt;
         </span>
         can hold only integer values and no other type. So if we wanted to read this JSON file into a C++ variable we would need some way to define an
         <span class="inlinecode">
          std::map
         </span>
         that could hold any type of variable as its value. That's exactly what the new
         <span class="inlinecode">
          std::any
         </span>
         type in C++17 does:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0595">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-118-9780443222191.jpg" width="1628"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1445">
         Before C++17, you might have used a
         <span class="inlinecode">
          void ∗
         </span>
         as a way to hold any type, but now
         <span class="inlinecode">
          std::any
         </span>
         provides a type-safe way to achieve the same thing. This is useful for several applications, such as passing arbitrary message values, representing the value of settings of different types, implementing aspects of a scripting language, and the previous example of parsing data files that support heterogeneous containers.
        </p>
        <div>
         <aside aria-labelledby="b0080" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0080">
           <div class="b1textfl" id="bpar0085">
            <i>
             TIP
            </i>
            :
            <i>
             Use
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :any
             </i>
            </span>
            <i>
             as a type-safe alternative to
            </i>
            <span class="inlinecode">
             <i>
              void ∗
             </i>
            </span>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1450">
         The basic operations you can perform on an
         <span class="inlinecode">
          std::any
         </span>
         type include the following, assuming an
         <span class="inlinecode">
          std::any
         </span>
         variable named
         <span class="inlinecode">
          anyVal
         </span>
         :
        </p>
        <div>
         <ol id="ulist0060">
          <li class="bulllist" id="p1455">
           <a id="u0185">
           </a>
           •
           <span class="inlinecode">
            anyVal.has_value()
           </span>
           : check whether the object holds a value.
          </li>
          <li class="bulllist" id="p1460">
           <a id="u0190">
           </a>
           •
           <span class="inlinecode">
            anyVal.reset()
           </span>
           : destroy any contained object producing an empty object.
          </li>
          <li class="bulllist" id="p1465">
           <a id="u0195">
           </a>
           •
           <span class="inlinecode">
            anyVal.type()
           </span>
           : return the
           <span class="inlinecode">
            typeid
           </span>
           of the contained object.
          </li>
          <li class="bulllist" id="p1470">
           <a id="u0200">
           </a>
           •
           <span class="inlinecode">
            std::any_cast&lt;T&gt;(anyVal)
           </span>
           : type-safe access to the contained object. Throws an exception if the contained object does not match the requested type.
          </li>
         </ol>
        </div>
        <p class="textfl">
         <a id="p298">
         </a>
        </p>
        <div>
         <span aria-label="298" epub:type="pagebreak" id="pagebreak_298" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1475">
         For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0600">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000064/main.assets/u07-119-9780443222191.jpg" width="1594"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1480">
         The main issue to be aware of when using
         <span class="inlinecode">
          std::any
         </span>
         is that it’s likely implemented with a
         <span class="inlinecode">
          void ∗
         </span>
         , because the maximum size of the contained type cannot be known at compile time. It therefore involves dynamic memory allocation that could be costly depending on your use. If you have a small set of possible types that need to be supported, then it may be more efficient to use an
         <span class="inlinecode">
          std::variant
         </span>
         , which I'll cover next.
        </p>
       </section>
       <section>
        <a id="s0165">
        </a>
        <h3 class="h2hd" id="cesectitle0175">
         Variant
        </h3>
        <p class="textfl" id="p1485">
         The
         <span class="inlinecode">
          std::variant
         </span>
         class template was introduced in C++17 as a type-safe alternative to the
         <span class="inlinecode">
          union
         </span>
         class type, which is an object that can hold only one of its nonstatic data members at any time and in which the size of the object is determined by the size of its largest member. For example, in C++98 (and plain C) you could define a union to hold one of several different primitive types. The standard convention is to pair this with a variable to track the type of the variable that is currently being held in the
         <span class="inlinecode">
          union
         </span>
         : that is,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0605">
           <img alt="image" height="950" src="../../IMAGES/B9780443222191000064/main.assets/u07-120-9780443222191.jpg" width="901"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1490">
         The downside of using a
         <span class="inlinecode">
          union
         </span>
         is that you can easily refer to a data member that's not the right type for the data value that's being stored, potentially returning a garbage value. For example, given the previous definition, you could set
         <span class="inlinecode">
          mFloatValue
         </span>
         to 3.1415 but still access the
         <span class="inlinecode">
          mIntValue
         </span>
         member. This would essentially return
         <span class="inlinecode">
          ∗((int ∗)&amp;mFloatValue)
         </span>
         ,
         <a id="p299">
         </a>
         <span aria-label="299" epub:type="pagebreak" id="pagebreak_299" role="doc-pagebreak">
         </span>
         which is likely not what you wanted. Instead, you can now use a variant to represent the same thing in a more type-safe fashion, as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0610">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-121-9780443222191.jpg" width="1039"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1495">
         This variant can hold an
         <span class="inlinecode">
          int
         </span>
         , a
         <span class="inlinecode">
          float
         </span>
         , or a
         <span class="inlinecode">
          bool
         </span>
         . For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0615">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-122-9780443222191.jpg" width="2116"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1500">
         Taking the example of the JSON file in the previous section on
         <span class="inlinecode">
          std::any
         </span>
         , if we know that the dictionary in the data file will hold only a string, int, or bool, then we could replace the use of
         <span class="inlinecode">
          std::any
         </span>
         for the dictionary value with an
         <span class="inlinecode">
          std::variant
         </span>
         . One benefit of this is that
         <span class="inlinecode">
          std::variant
         </span>
         does not dynamically allocate its value on the heap:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0620">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-123-9780443222191.jpg" width="2114"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0085" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0085">
           <div class="b1textfl" id="bpar0090">
            <i>
             TIP
            </i>
            :
            <i>
             Use
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :variant
             </i>
            </span>
            <i>
             as a type-safe alternative to
            </i>
            <span class="inlinecode">
             <i>
              union
             </i>
            </span>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1505">
         The basic operations that you can perform on a variant are, for a variant variable called
         <span class="inlinecode">
          varVal
         </span>
         :
        </p>
        <div>
         <ol id="ulist0065">
          <li class="bulllist" id="p1510">
           <a id="u0205">
           </a>
           •
           <span class="inlinecode">
            varVal.index()
           </span>
           : returns the zero-based index of the currently held alternative.
          </li>
          <li class="bulllist" id="p1515">
           <a id="u0210">
           </a>
           •
           <span class="inlinecode">
            std::get&lt;size_t&gt;(varVal)
           </span>
           : returns the value of the alternative at the given offset, such as 0 for the first type specified in the variant. Throws an exception for an out of bounds index.
          </li>
          <li class="bulllist" id="p1520">
           <a id="u0215">
           </a>
           •
           <span class="inlinecode">
            std::get&lt;T&gt;(varVal)
           </span>
           : returns the value of the alternative with the given type, such as
           <span class="inlinecode">
            std::string
           </span>
           . Throws an exception if the type does not exist in the variant.
          </li>
          <li class="bulllist" id="p1525">
           <a id="u0220">
           </a>
           •
           <span class="inlinecode">
            std::holds_alternative&lt;T&gt;(varVal)
           </span>
           : checks if the currently held alternative is of the given type, such as
           <span class="inlinecode">
            std::string
           </span>
           .
          </li>
         </ol>
        </div>
        <p class="text" id="p1530">
         You can also inherit from
         <span class="inlinecode">
          std::variant
         </span>
         . This might be useful if you want to extend the functionality of the variant, such as adding some simple accessors or to add support for output streams by defining a
         <span class="inlinecode">
          &lt;&lt;
         </span>
         operator. For example:
         <a id="p300">
         </a>
         <span aria-label="300" epub:type="pagebreak" id="pagebreak_300" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0625">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000064/main.assets/u07-124-9780443222191.jpg" width="2010"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0170">
        </a>
        <h3 class="h2hd" id="cesectitle0180">
         Nested namespaces
        </h3>
        <p class="textfl" id="p1535">
         As we've already seen, the use of namespaces is an important feature for your API designs to ensure that your symbols don't clash with those in other libraries. Namespaces can be nested, which is a useful feature to break up your symbol names into several categories, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0630">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-125-9780443222191.jpg" width="762"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1540">
         With C++17, you can now declare a nested namespace with a single
         <span class="inlinecode">
          namespace
         </span>
         statement, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0635">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-126-9780443222191.jpg" width="1005"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1545">
         In addition to being more compact, this syntax offers a satisfying symmetry with how you would refer to the nested namespace in a
         <span class="inlinecode">
          using
         </span>
         statement, or if you were to refer to a symbol in that namespace with its fully qualified name, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0640">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-127-9780443222191.jpg" width="1039"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1550">
         Making use of nested namespaces can often lead to long composite names, particularly in header files where you can't employ the
         <span class="inlinecode">
          using
         </span>
         directive. However, you can use namespace aliases to produce shorter alternate names to help with readability and reduce the amount of necessary typing for your clients. For example,
         <a id="p301">
         </a>
         <span aria-label="301" epub:type="pagebreak" id="pagebreak_301" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0645">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-128-9780443222191.jpg" width="1700"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0175">
        </a>
        <h3 class="h2hd" id="cesectitle0185">
         Fold expressions
        </h3>
        <p class="textfl" id="p1555">
         You may recall from earlier in this chapter that C++11 introduced the notion of variadic templates. This provided type-safe support for functions that can accept variable numbers of arguments of different types. As I noted, these are often implemented recursively, requiring an overloaded base case function to be defined to terminate the recursion. For example, the next C++11 code lets you multiply any number of values:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0650">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000064/main.assets/u07-129-9780443222191.jpg" width="1353"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1560">
         C++17 introduced a feature called fold expressions, which can help us simplify this code even further and avoid the use of recursion. This lets you apply a binary operator to all of the parameters in a parameter pack. For example, here's a fold expression using the multiply operator (the surrounding parentheses are required):
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0655">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-130-9780443222191.jpg" width="415"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1565">
         For a parameter pack with four arguments, the compiler will expand this in place to become:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0660">
           <img alt="image" height="95" src="../../IMAGES/B9780443222191000064/main.assets/u07-131-9780443222191.jpg" width="1117"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1570">
         This is referred to as a unary left fold. There's also a unary right fold as well as binary left and right folds. I define the general form for each of these four fold expression types in
         <a href="#t0010" id="Bt0010">
          Table 7.1
         </a>
         , along with an expanded example assuming a parameter pack with four arguments and the multiply operator.
         <a id="p302">
         </a>
        </p>
        <div>
         <span aria-label="302" epub:type="pagebreak" id="pagebreak_302" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="st0010">
         </a>
         <div class="pageavoid">
          <p class="tnum">
           <a href="#Bt0010">
            Table 7.1
           </a>
          </p>
          <table class="tbody" id="t0010">
           <caption class="ttitle">
            <a id="tspara0010">
            </a>
            Fold expression types introduced in C++17.
           </caption>
           <thead>
            <tr>
             <th class="tcolhd1" scope="col">
              Name
             </th>
             <th class="tcolhd1" scope="col">
              Fold expression and expanded example
             </th>
            </tr>
           </thead>
           <tbody>
            <tr>
             <th class="tb" scope="row">
              Unary left fold
             </th>
             <td class="tb">
              <div class="tb1">
               <span class="inlinecode">
                (... op args)
               </span>
              </div>
              <div class="tb1">
               <span class="inlinecode">
                (((args
                <sub>
                 1
                </sub>
                ∗ args
                <sub>
                 2
                </sub>
                ) ∗ args
                <sub>
                 3
                </sub>
                ) ∗ args
                <sub>
                 4
                </sub>
                )
               </span>
              </div>
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              Unary right fold
             </th>
             <td class="tb">
              <div class="tb1">
               <span class="inlinecode">
                (args op ...)
               </span>
              </div>
              <div class="tb1">
               <span class="inlinecode">
                (args
                <sub>
                 1
                </sub>
                ∗ (args
                <sub>
                 2
                </sub>
                ∗ (args
                <sub>
                 3
                </sub>
                ∗ args
                <sub>
                 4
                </sub>
                )))
               </span>
              </div>
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              Binary left fold
             </th>
             <td class="tb">
              <div class="tb1">
               <span class="inlinecode">
                (init op ... op args)
               </span>
              </div>
              <div class="tb1">
               <span class="inlinecode">
                ((((init ∗ args
                <sub>
                 1
                </sub>
                ) ∗ args
                <sub>
                 2
                </sub>
                ) ∗ args
                <sub>
                 3
                </sub>
                ) ∗ args
                <sub>
                 4
                </sub>
                )
               </span>
              </div>
             </td>
            </tr>
            <tr>
             <th class="tb" scope="row">
              Binary right fold
             </th>
             <td class="tb">
              <div class="tb1">
               <span class="inlinecode">
                (args op ... op init)
               </span>
              </div>
              <div class="tb1">
               <span class="inlinecode">
                (args
                <sub>
                 1
                </sub>
                ∗ (args
                <sub>
                 2
                </sub>
                ∗ (args
                <sub>
                 3
                </sub>
                ∗ (args
                <sub>
                 4
                </sub>
                ∗ init))))
               </span>
              </div>
             </td>
            </tr>
           </tbody>
          </table>
         </div>
        </section>
        <p class="text" id="p1575">
         Taking this C++11 variadic template example, we can express this using a fold expression, which allows us to remove the base case overloaded function and avoid the recursive implementation because the fold expression is expanded in place:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0665">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-132-9780443222191.jpg" width="1352"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1580">
         We can also simplify this further using the deduced return type functionality from C++14 and remove the need to declare an initial
         <span class="inlinecode">
          first
         </span>
         argument. (However, recall that I generally advise avoiding using deduced return types.)
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0670">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-133-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1585">
         As a further example, here's a simplified version of the
         <span class="inlinecode">
          printLine()
         </span>
         variadic template that I defined earlier in the C++11 section. Here I use a fold expression over the comma operator to generate a sequence of output stream operations, and then I add a newline at the end:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0675">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-134-9780443222191.jpg" width="1526"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p303">
         </a>
         <span aria-label="303" epub:type="pagebreak" id="pagebreak_303" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0090" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0090">
           <div class="b1textfl" id="bpar0095">
            <i>
             TIP
            </i>
            :
            <i>
             Consider using fold expressions with variadic templates as an alternative to a recursive implementation
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1590">
         While we're on this topic, it's worth noting a couple of alternative approaches to implementing variable parameters. For example, you can use multiple overloaded functions to implement different combinations of parameters, although of course, this works only if the number of possible parameter combinations is constrained, because you would have to define a separate function for each permutation.
        </p>
        <p class="text" id="p1595">
         Another approach would be to pass in a container object with multiple parameter values. If all of the parameters are of a known fixed type, such as
         <span class="inlinecode">
          std::vector&lt;std::string&gt;
         </span>
         , then that makes things simpler. Otherwise, you can use a container of “any” objects, or objects that can hold a value of any type. As we just learned, C++17 introduced the
         <span class="inlinecode">
          std::any
         </span>
         type to solve exactly this problem, letting us use
         <span class="inlinecode">
          std::vector&lt;std::any&gt;
         </span>
         as a way to define a heterogeneous array (i.e., a list of parameters of different types). We could even combine this approach with variadic templates, as in this example in which we initialize an
         <span class="inlinecode">
          std::any
         </span>
         vector with the parameter pack from a variadic function template and then iterate over the parameters:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0680">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-135-9780443222191.jpg" width="1630"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1600">
         In this example, calling
         <span class="inlinecode">
          printTypes(1, true, 3.0f)
         </span>
         will output:
         <span class="inlinecode">
          3 args: i b f
         </span>
        </p>
       </section>
       <section>
        <a id="s0180">
        </a>
        <h3 class="h2hd" id="cesectitle0190">
         Checking for header availability
        </h3>
        <p class="textfl" id="p1605">
         Your library may have optional dependencies, other libraries that you can take advantage of if present, but which your code will ignore if not. For example, perhaps your library depends on libz to compress some data, but if libz is not available at compile time, then your library will still compile successfully but will not support the ability to compress data. The traditional way to do this is to have some define in your code, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0685">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-136-9780443222191.jpg" width="1108"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p304">
         </a>
        </p>
        <div>
         <span aria-label="304" epub:type="pagebreak" id="pagebreak_304" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1610">
         Then your clients would use a compiler option (e.g.,
         <span class="inlinecode">
          -DHAVE_ZLIB)
         </span>
         to set the define when the library is available. Or you may use some configuration scripts that attempt to locate the library and, if found, update your compile line to include the define. This makes it more complicated to compile your code because the client must either manually specify the right set of defines for the environment or run some configuration script to do this.
        </p>
        <p class="text" id="p1615">
         C++17 introduced the ability for your code to check directly whether a header file is available (i.e., whether the
         <span class="inlinecode">
          #include
         </span>
         statement would succeed), which can greatly simplify such a situation. This is done with the
         <span class="inlinecode">
          __has_include
         </span>
         preprocessor directive; for example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0690">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-137-9780443222191.jpg" width="936"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1620">
         (You can use both
         <span class="inlinecode">
          "header"
         </span>
         and
         <span class="inlinecode">
          &lt;header&gt;
         </span>
         syntax with
         <span class="inlinecode">
          __has_include
         </span>
         .)
        </p>
        <p class="text" id="p1625">
         In this code snippet, the
         <span class="inlinecode">
          zlib.h
         </span>
         header will be included only if the compiler is able to find it in its header search path. Based on whether it can be included, then the code will also set or unset a
         <span class="inlinecode">
          HAVE_ZLIB
         </span>
         define. You can then use this to place
         <span class="inlinecode">
          #if
         </span>
         guards around other parts of the code where you try to reference symbols from the library. With this approach, your clients no longer need to set a define on the compile line because your code can figure out whether it can access the dependency itself.
        </p>
        <p class="text" id="p1630">
         If you need to support clients who are not using a compiler that supports C++17 (or later), you can still use this feature by placing an additional preprocessor check around it. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0695">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-138-9780443222191.jpg" width="936"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1635">
         If this code were to be encountered by a C++11 compiler that doesn't support the
         <span class="inlinecode">
          __has_include
         </span>
         directive, then it would fail to enter the first
         <span class="inlinecode">
          #if
         </span>
         and then unset the
         <span class="inlinecode">
          HAVE_ZLIB
         </span>
         define, whereas a C++17 (or later) compiler would enter the first
         <span class="inlinecode">
          #if
         </span>
         and then check for the existence of the
         <span class="inlinecode">
          zlib.h
         </span>
         header file. You could also make the non-C++17 code path attempt to include the header if
         <span class="inlinecode">
          HAVE_ZLIB
         </span>
         is defined, to support the traditional approach of using a compiler flag for those older compilers.
         <a id="p305">
         </a>
        </p>
        <div>
         <span aria-label="305" epub:type="pagebreak" id="pagebreak_305" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0185">
        </a>
        <h3 class="h2hd" id="cesectitle0195">
         Byte type
        </h3>
        <p class="textfl" id="p1640">
         C++17 introduced a new
         <span class="inlinecode">
          std::byte
         </span>
         type to represent the concept of a single byte of memory. Previously, it was common to use
         <span class="inlinecode">
          char
         </span>
         or
         <span class="inlinecode">
          unsigned char
         </span>
         to access raw memory, but these types imply that you're addressing character data, and they also allow arithmetic operations to be performed on them. By contrast,
         <span class="inlinecode">
          std::byte
         </span>
         is meant only to represent a collection of bits and it only defines bitwise operators, such as bit shifting and bitwise AND, OR, and XOR. The C++ standard defines
         <span class="inlinecode">
          std::byte
         </span>
         as an enum class with an underlying type of
         <span class="inlinecode">
          unsigned char
         </span>
         .
        </p>
        <p class="text" id="p1645">
         You can use
         <span class="inlinecode">
          std::byte
         </span>
         to pass around opaque blocks of memory. This might be useful for applications such as data serialization or networking calls in which you want to reference binary data as opposed to textual information. For example, you can use
         <span class="inlinecode">
          std::vector&lt;std::byte&gt;
         </span>
         to hold a contiguous block of raw data, or
         <span class="inlinecode">
          std::byte ∗
         </span>
         to represent a pointer to raw memory instead of
         <span class="inlinecode">
          char ∗
         </span>
         , which implies a pointer to textual characters, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0700">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-139-9780443222191.jpg" width="2184"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1650">
         The following code illustrates various ways to work with bytes:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0705">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000064/main.assets/u07-140-9780443222191.jpg" width="2322"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1655">
         (Although a byte is often composed of 8 bits on modern computers, this should not be assumed. Some older machines and specialized chips such as DSPs can use a different number of bits per byte, as defined by
         <span class="inlinecode">
          CHAR_BIT
         </span>
         in the
         <span class="inlinecode">
          limits.h
         </span>
         header.)
        </p>
       </section>
       <section>
        <a id="s0190">
        </a>
        <h3 class="h2hd" id="cesectitle0200">
         The maybe_unused attribute
        </h3>
        <p class="textfl" id="p1660">
         A new attribute was introduced in C++17 to suppress compiler warnings on unused entities. The
         <span class="inlinecode">
          [[maybe_unused]]
         </span>
         attribute can be applied to most types, such as classes, structs, unions, typedefs, and enums, although the most common use for a public API
         <a id="p306">
         </a>
         <span aria-label="306" epub:type="pagebreak" id="pagebreak_306" role="doc-pagebreak">
         </span>
         will likely be for function arguments, to indicate that an argument may not be used within the function body.
        </p>
        <p class="text" id="p1665">
         This attribute can appear on both a function declaration (in the
         <span class="inlinecode">
          .h
         </span>
         file) and its definition (in the
         <span class="inlinecode">
          .cpp
         </span>
         file). However, I would recommend putting this attribute only on the function definition because it pertains to the implementation details of the function and does not affect how clients should use it. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0710">
           <img alt="image" height="486" src="../../IMAGES/B9780443222191000064/main.assets/u07-141-9780443222191.jpg" width="2600"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1670">
         In this example, if the body of the
         <span class="inlinecode">
          Sum()
         </span>
         function does not refer to the
         <span class="inlinecode">
          policy
         </span>
         parameter, the compiler will not emit a warning because of the
         <span class="inlinecode">
          [[maybe_unused]]
         </span>
         attribute. There are, of course, a few other ways you could achieve the same result before C++17:
        </p>
        <div>
         <ul class="ce_list" id="olist0085">
          <li class="numlist" id="p1675">
           <a id="o0160">
           </a>
           1. Add a flag to the compiler command line to turn off warnings for unused function parameters, such as
           <span class="inlinecode">
            -Wunused-parameter
           </span>
           for clang and g++.
          </li>
          <li class="numlist" id="p1680">
           <a id="o0165">
           </a>
           2. Omit the parameter name in the function definition, such as:
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0715">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-142-9780443222191.jpg" width="1943"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ul class="ce_list" id="olist0090">
          <li class="numlist" id="p1685">
           <a id="o0170">
           </a>
           3. Add a
           <span class="inlinecode">
            (void)policy;
           </span>
           line to the function body to reference the parameter but do nothing with it.
          </li>
         </ul>
        </div>
        <p class="text" id="p1690">
         The benefit of the
         <span class="inlinecode">
          [[maybe_unused]]
         </span>
         approach is that it works for code where the parameter may be used in some cases but not others. One way this could happen is if you use a
         <span class="inlinecode">
          #ifdef
         </span>
         preprocessor statement inside the function body and only reference the parameter inside the preprocessor block. For example,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0720">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000064/main.assets/u07-143-9780443222191.jpg" width="2183"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p307">
         </a>
        </p>
        <div>
         <span aria-label="307" epub:type="pagebreak" id="pagebreak_307" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1695">
         In this example, a compiler could generate a warning if
         <span class="inlinecode">
          HAVE_PARALLEL_SUPPORT
         </span>
         is undefined. However, it would not issue a warning if the flag is defined. Adding the
         <span class="inlinecode">
          [[maybe_unused]]
         </span>
         attribute to the parameter would suppress the warning in all cases.
        </p>
       </section>
       <section>
        <a id="s0195">
        </a>
        <h3 class="h2hd" id="cesectitle0205">
         Migrating to C++17
        </h3>
        <p class="textfl" id="p1700">
         If you have an existing API and are considering migrating to C++17, this section will suggest some features to help improve your API design. As with earlier sections, I'll split this up into changes that can be made without breaking backward compatibility and those that are worth contemplating, but which could introduce breaking changes for your clients. I don't list all of the C++17 features I covered earlier, only those that I feel can have a worthwhile impact on your existing APIs:
        </p>
        <div>
         <ol id="ulist0070">
          <li class="bulllist" id="p1705">
           <a id="u0225">
           </a>
           •
           <b>
            Compatible Changes
           </b>
          </li>
          <li class="bulllist">
           <ol id="ulist0075">
            <li class="bulllist1" id="p1710">
             <a id="u0230">
             </a>
             •
             <b>
              Inline Variables:
             </b>
             These produces simpler and compact code and are a good feature to adopt as you upgrade to C++17. If you don't change the name of your global variables, adopting inline variables will be source compatible and for most compilers should also be binary compatible: extern versus inline symbols may be represented differently in your library binary, but the linker should still be able to resolve them without error.
            </li>
            <li class="bulllist1" id="p1715">
             <a id="u0235">
             </a>
             •
             <b>
              Nested Namespaces:
             </b>
             This is a purely syntactic change that will be both source and binary compatible. I personally prefer the simpler syntax of not having to define multiple namespace statements and balance multiple curly braces.
            </li>
            <li class="bulllist1" id="p1720">
             <a id="u0240">
             </a>
             •
             <b>
              Header Checks:
             </b>
             Making use of
             <span class="inlinecode">
              __has_include
             </span>
             can help make the compilation and use of your library more robust to missing optional dependencies and simplify the requirements for building your code.
            </li>
           </ol>
          </li>
          <li class="bulllist" id="p1725">
           <a id="u0245">
           </a>
           •
           <b>
            Breaking Changes
           </b>
          </li>
          <li class="bulllist">
           <ol id="ulist0080">
            <li class="bulllist1" id="p1730">
             <a id="u0250">
             </a>
             •
             <b>
              Fold Expressions:
             </b>
             If you're not using fold expressions to simplify the signature of your variadic template functions, using them within your function implementation should be a source compatible change. However fold expressions allow you to remove the base case function that terminates recursive expansion, so there's a possibility that your clients' code could have a reliance on that base case function symbol and fail to link against your new library without recompiling.
            </li>
            <li class="bulllist1" id="p1735">
             <a id="u0255">
             </a>
             •
             <b>
              Optional, Any, Variant:
             </b>
             These are useful new utility classes, but if you change any existing API function signatures to use them, then you'll break backward compatibility. Of course, using them in new functions would be safe.
            </li>
           </ol>
          </li>
         </ol>
        </div>
       </section>
      </section>
      <section>
       <a id="s0200">
       </a>
       <h2 class="h1hd" id="cesectitle0210">
        C++20 API features
       </h2>
       <p class="textfl" id="p1740">
        The C++20 version of the standard was published in Dec. 2020, replacing the prior C++17 version. This revision introduced some major features to the language, including support for modules and coroutines, which I'll cover in depth here.
        <a id="p308">
        </a>
       </p>
       <div>
        <span aria-label="308" epub:type="pagebreak" id="pagebreak_308" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p1745">
        There were many other updates that don't directly affect API designs, so we won't cover them here, but they still offer some great additions to the language, including new lambda function features, a
        <span class="inlinecode">
         contains()
        </span>
        method for associative containers, and the
        <span class="inlinecode">
         using enum
        </span>
        syntax to refer to enum class identifiers more concisely.
       </p>
       <p class="text" id="p1750">
        This revision also removed and deprecated several existing features, such as removing the use of
        <span class="inlinecode">
         throw()
        </span>
        as an exception specification and deprecating most uses of the
        <span class="inlinecode">
         volatile
        </span>
        keyword.
       </p>
       <section>
        <a id="s0205">
        </a>
        <h3 class="h2hd" id="cesectitle0215">
         Modules
        </h3>
        <p class="textfl" id="p1755">
         Modules represent a fundamental shift in how interfaces can be defined in C++. As of the time of writing this book, the feature is not broadly supported across all compilers, but as support and tooling improves, modules will likely become more prevalent as a way to define APIs.
        </p>
        <p class="text" id="p1760">
         A core tenant of this book is the physical separation of interface and implementation. Until C++20, the universal way to express this has been by declaring your interface in
         <span class="inlinecode">
          .h
         </span>
         header files and your implementation in
         <span class="inlinecode">
          .cpp
         </span>
         source files. This organization goes all the way back to the C language, with
         <span class="inlinecode">
          .h
         </span>
         and
         <span class="inlinecode">
          .c
         </span>
         files. One of the problems with this approach is that a C++ compiler treats each source file separately and it uses the preprocessor to expand all included header files recursively. This causes a large amount of repeated work. Even with the use of header guards or
         <span class="inlinecode">
          #pragma once
         </span>
         statements to ensure that a header is expanded only once, the work is repeated for every source file the compiler visits. Another solution is the use of precompiled headers, although these are not defined by the standard and therefore tend to be compiler specific.
        </p>
        <p class="text" id="p1765">
         Modules provide a standardized solution to this problem. There are two main types of modules that were introduced in C++20:
        </p>
        <div>
         <ul class="ce_list" id="olist0095">
          <li class="numlist" id="p1770">
           <a id="o0175">
           </a>
           1.
           <b>
            Named Modules:
           </b>
           These remove the use of header files and provide ways to separate your interface and implementation within your
           <span class="inlinecode">
            .cpp
           </span>
           files.
          </li>
          <li class="numlist" id="p1775">
           <a id="o0180">
           </a>
           2.
           <b>
            Header Units:
           </b>
           These provide a bridge and migration strategy between the use of header files and a full named module approach.
          </li>
         </ul>
        </div>
        <section>
         <a id="s0210">
         </a>
         <h4 class="h3hd" id="cesectitle0220">
          Named Modules
         </h4>
         <p class="textfl" id="p1780">
          A named module consists of one or more module units, in which a module unit is simply a
          <span class="inlinecode">
           .cpp
          </span>
          file that starts with a
          <span class="inlinecode">
           module
          </span>
          declaration in the form:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0725">
            <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-144-9780443222191.jpg" width="1559"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1785">
          One of the module units will export the module name with the
          <span class="inlinecode">
           export
          </span>
          keyword. This is called the module interface unit. If you spread the implementation of the module over other
          <span class="inlinecode">
           .cpp
          </span>
          files, these are called module implementation units. Symbols that you want to
          <a id="p309">
          </a>
          <span aria-label="309" epub:type="pagebreak" id="pagebreak_309" role="doc-pagebreak">
          </span>
          be accessible outside the module must be explicitly exported with the
          <span class="inlinecode">
           export
          </span>
          keyword. Let's look at an example:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0730">
            <img alt="image" height="2107" src="../../IMAGES/B9780443222191000064/main.assets/u07-145-9780443222191.jpg" width="1836"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1790">
          In this example, I created a module called
          <span class="inlinecode">
           MathModule
          </span>
          . I put the interface (what you would normally put in a header file) in the module interface unit,
          <span class="inlinecode">
           MathModule.cpp
          </span>
          , and the implementation in the module implementation unit,
          <span class="inlinecode">
           MathModuleImpl.cpp
          </span>
          . (clang requires you to name your interface unit files with a
          <span class="inlinecode">
           .cppm
          </span>
          extension.) The module exports a namespace, also called
          <span class="inlinecode">
           MathModule
          </span>
          , which exports two functions:
          <span class="inlinecode">
           Square()
          </span>
          and
          <span class="inlinecode">
           Cube()
          </span>
          .
         </p>
         <p class="text" id="p1795">
          Here are a few things to note about this example:
         </p>
         <div>
          <ol id="ulist0085">
           <li class="bulllist" id="p1800">
            <a id="u0260">
            </a>
            • You must use the
            <span class="inlinecode">
             import
            </span>
            keyword to access a module, not
            <span class="inlinecode">
             #include
            </span>
            .
           </li>
           <li class="bulllist" id="p1805">
            <a id="u0265">
            </a>
            • There are no header files. In fact, a module cannot include any headers, except in an optional global module fragment that, if present, must come before the module declaration. Modules don't emit macros. For example, the use of
            <span class="inlinecode">
             import std
            </span>
            will not expose Standard Library macros such as
            <span class="inlinecode">
             assert
            </span>
            ,
            <span class="inlinecode">
             errno
            </span>
            ,
            <span class="inlinecode">
             va_arg
            </span>
            , or
            <span class="inlinecode">
             INT_MAX
            </span>
            .
            <a id="p310">
            </a>
           </li>
           <li>
            <span aria-label="310" epub:type="pagebreak" id="pagebreak_310" role="doc-pagebreak">
            </span>
           </li>
           <li class="bulllist" id="p1810">
            <a id="u0270">
            </a>
            • Modules and namespaces are orthogonal concepts. In this example, I created a namespace with the same name as the module, but this is not required. You can, of course, also export symbols from a module at the global level.
           </li>
           <li class="bulllist" id="p1815">
            <a id="u0275">
            </a>
            • I explicitly exported the symbols that I want to be accessible from the module. Any symbols not marked with the
            <span class="inlinecode">
             export
            </span>
            keyword cannot be called outside the module. This standardizes the export behavior of symbols from translation units, which the standard previously left up to implementations (Microsoft compilers famously have a different default symbol exporting behavior to gcc/clang).
           </li>
           <li class="bulllist" id="p1820">
            <a id="u0280">
            </a>
            • I used
            <span class="inlinecode">
             import std
            </span>
            to pull in the entire Standard Library as a module, allowing me to access
            <span class="inlinecode">
             std::cout
            </span>
            . I also could have used
            <span class="inlinecode">
             import &lt;iostream&gt;
            </span>
            or even
            <span class="inlinecode">
             #include &lt;iostream&gt;
            </span>
            ; in other words, application code can intermingle modules and headers.
           </li>
          </ol>
         </div>
         <p class="text" id="p1825">
          There are several other features that let you manage the interface and implementation parts of your modules. For example, you can define a private module fragment within your module interface unit to provide definitions that are not exported from that file. There's also a concept of module partitions, which can be used to split up larger modules into smaller pieces. And you can choose to export only specific symbols selectively, rather than enclosing the entire file in a single
          <span class="inlinecode">
           export
          </span>
          scope. However, the approach I presented earlier keeps things simple and maps conceptually to how we've organized interface and implementation code for all time up until C++20.
         </p>
         <p class="text" id="p1830">
          Some of the benefits of adopting modules include improved compile times (because the compiler no longer needs to expand a large tree of header files into each translation unit) and greater reliability because the order of importing modules does not affect their semantics (because modules aren't affected by macros from other imports). There are, however, several practical considerations to be aware of when adopting modules. I've collected these caveats in the later section on Migrating to C++20.
         </p>
         <div>
          <aside aria-labelledby="b0095" epub:type="sidebar">
           <div class="box_top_space">
           </div>
           <div class="boxg1" id="b0095">
            <div class="b1textfl" id="bpar0100">
             <i>
              TIP
             </i>
             :
             <i>
              When adopting named modules
             </i>
             ,
             <i>
              you should still try to separate your interface and implementation code across a module interface unit and module implementation unit(s)
             </i>
             .
            </div>
           </div>
          </aside>
         </div>
        </section>
        <section>
         <a id="s0215">
         </a>
         <h4 class="h3hd" id="cesectitle0225">
          Header units
         </h4>
         <p class="textfl" id="p1835">
          In addition to named modules, C++20 introduced a concept known as header units to help ease the transition to modules. This feature allows you to import certain header files as modules with the
          <span class="inlinecode">
           import "header.h"
          </span>
          or
          <span class="inlinecode">
           import &lt;header.h&gt;
          </span>
          syntax. For example:
          <a id="p311">
          </a>
          <span aria-label="311" epub:type="pagebreak" id="pagebreak_311" role="doc-pagebreak">
          </span>
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0735">
            <img alt="image" height="949" src="../../IMAGES/B9780443222191000064/main.assets/u07-146-9780443222191.jpg" width="2150"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1840">
          This code assumes that you've compiled the associated
          <span class="inlinecode">
           MathHeader.cpp
          </span>
          file to a binary module interface file, so that the compiler can access it like a regular named module.
         </p>
         <p class="text" id="p1845">
          Just like named modules, header units aren't affected by macros in other headers, but unlike named modules they expose any macros defined in the header files. This means they are useful for cases in which you still need to depend on any macros defined in the header files. The key benefit is that you don't have to remove the header files from your API and restructure your project to adopt named modules fully.
         </p>
         <div>
          <aside aria-labelledby="b0100" epub:type="sidebar">
           <div class="box_top_space">
           </div>
           <div class="boxg1" id="b0100">
            <div class="b1textfl" id="bpar0105">
             <i>
              TIP
             </i>
             :
             <i>
              Header units can be useful to get many of the benefits of modules without having to restructure your code as much
             </i>
             .
            </div>
           </div>
          </aside>
         </div>
        </section>
       </section>
       <section>
        <a id="s0220">
        </a>
        <h3 class="h2hd" id="cesectitle0230">
         The spaceship operator
        </h3>
        <p class="textfl" id="p1850">
         C++ lets you define various comparison operators to describe the result of comparing two objects. These are the
         <span title='hsp="0.25"'>
         </span>
         ==,
         <span class="inlinecode">
          !=
         </span>
         ,
         <span class="inlinecode">
          &lt;
         </span>
         ,
         <span class="inlinecode">
          &lt;=
         </span>
         ,
         <span class="inlinecode">
          &gt;
         </span>
         , and
         <span class="inlinecode">
          &gt;=
         </span>
         operators. This list of operators was expanded in C++20 to include the spaceship (or three-way) comparison operator. Unlike the other comparison operators that return a
         <span class="inlinecode">
          bool
         </span>
         result, the spaceship operator returns a three-way result that can be negative, zero, or positive. You can think of this as being conceptually similar to how the plain C
         <span class="inlinecode">
          strcmp
         </span>
         function works. The name spaceship operator comes from the fact that the characters used for this operator look like an ASCII art TIE fighter:
         <span class="inlinecode">
          &lt;=&gt;
         </span>
         .
        </p>
        <p class="text" id="p1855">
         Let's start by reviewing the use of the original comparison operators. I'll use a simple object called
         <span class="inlinecode">
          Magnitude
         </span>
         that holds a numeric value:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0740">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-147-9780443222191.jpg" width="901"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p312">
         </a>
        </p>
        <div>
         <span aria-label="312" epub:type="pagebreak" id="pagebreak_312" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1860">
         Trying to compare two objects of this class will fail because no comparison operators have been defined; that is,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0745">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-148-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1865">
         To make this work, we need to define the
         <span title='hsp="0.25"'>
         </span>
         == operator for the class. Here's what the code looks like to add support for all comparison operators to the class:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0750">
           <img alt="image" height="2049" src="../../IMAGES/B9780443222191000064/main.assets/u07-149-9780443222191.jpg" width="1630"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1870">
         The benefit of the spaceship operator is that you can remove most or all these operator definitions just by providing a definition for the spaceship operator. The compiler will then use your spaceship operator to provide an implementation for all other operators. The compiler can even generate a default implementation of the spaceship operator for you, so that class definition can be simplified to:
         <a id="p313">
         </a>
         <span aria-label="313" epub:type="pagebreak" id="pagebreak_313" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0755">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000064/main.assets/u07-150-9780443222191.jpg" width="1975"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1875">
         Now this code will compile and work correctly:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0760">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-151-9780443222191.jpg" width="1700"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0105" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0105">
           <div class="b1textfl" id="bpar0110">
            <i>
             TIP
            </i>
            :
            <i>
             Use the spaceship operator
            </i>
            ,
            <span class="inlinecode">
             <i>
              &lt;=&gt;
             </i>
            </span>
            ,
            <i>
             to avoid having to define all comparison operators for your classes
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1880">
         The default spaceship operator implementation will do a member-wise comparison of each of the data members within your class. It does this by first comparing any base class members and then the nonstatic members in declaration order. For example, given the definition of a
         <span class="inlinecode">
          Vector
         </span>
         class:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0765">
           <img alt="image" height="834" src="../../IMAGES/B9780443222191000064/main.assets/u07-152-9780443222191.jpg" width="1839"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p314">
         </a>
        </p>
        <div>
         <span aria-label="314" epub:type="pagebreak" id="pagebreak_314" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1885">
         the generated implementation will be equivalent to the code:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0770">
           <img alt="image" height="949" src="../../IMAGES/B9780443222191000064/main.assets/u07-153-9780443222191.jpg" width="1420"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1890">
         This default behavior may not always be what you want, such as if the data members need to be compared in a different order or a more complex comparison algorithm is required. In that case, you can provide a custom implementation for the spaceship operator. This will require you to choose among three different return types to control how the other two-way comparison operators are generated. Those are:
        </p>
        <div>
         <ul class="ce_list" id="olist0100">
          <li class="numlist" id="p1895">
           <a id="o0185">
           </a>
           1.
           <span class="inlinecode">
            std::strong_ordering
           </span>
           : This result type is used for cases in which it's possible to determine that two objects are exactly equal (i.e., one can be substituted for the other). This implies that every data member is compared by the operator. Possible values for this type are:
          </li>
          <li class="numlist">
           <ul class="ce_list" id="olist0105">
            <li class="numlist1" id="p1900">
             <a id="o0190">
             </a>
             a.
             <span class="inlinecode">
              std::strong_ordering::less
             </span>
            </li>
            <li class="numlist1" id="p1905">
             <a id="o0195">
             </a>
             b.
             <span class="inlinecode">
              std::strong_ordering::equal
             </span>
            </li>
            <li class="numlist1" id="p1910">
             <a id="o0200">
             </a>
             c.
             <span class="inlinecode">
              std::strong_ordering::greater
             </span>
            </li>
           </ul>
          </li>
          <li class="numlist" id="p1915">
           <a id="o0205">
           </a>
           2.
           <span class="inlinecode">
            std::weak_ordering
           </span>
           : This type is used for the weaker relationship in which you can determine only whether two objects are equivalent rather than equal. The difference is that equivalent objects may have irrelevant differences whereas equal objects are indistinguishable. Possible weak ordering values are:
          </li>
          <li class="numlist">
           <ul class="ce_list" id="olist0110">
            <li class="numlist1" id="p1920">
             <a id="o0210">
             </a>
             a.
             <span class="inlinecode">
              std::weak_ordering::less
             </span>
            </li>
            <li class="numlist1" id="p1925">
             <a id="o0215">
             </a>
             b.
             <span class="inlinecode">
              std::weak_ordering::equivalent
             </span>
            </li>
            <li class="numlist1" id="p1930">
             <a id="o0220">
             </a>
             c.
             <span class="inlinecode">
              std::weak_ordering::greater
             </span>
            </li>
           </ul>
          </li>
          <li class="numlist" id="p1935">
           <a id="o0225">
           </a>
           3.
           <span class="inlinecode">
            std::partial_ordering
           </span>
           : This type is similar to weak ordering but with the added feature that there may be values that cannot be compared with each other, such as a NaN float. Possible partial ordering values are:
          </li>
          <li class="numlist">
           <ul class="ce_list" id="olist0115">
            <li class="numlist1" id="p1940">
             <a id="o0230">
             </a>
             a.
             <span class="inlinecode">
              std::partial_ordering::less
             </span>
            </li>
            <li class="numlist1" id="p1945">
             <a id="o0235">
             </a>
             b.
             <span class="inlinecode">
              std::partial_ordering::equivalent
             </span>
            </li>
            <li class="numlist1" id="p1950">
             <a id="o0240">
             </a>
             c.
             <span class="inlinecode">
              std::partial_ordering::greater
             </span>
            </li>
            <li class="numlist1" id="p1955">
             <a id="o0245">
             </a>
             d.
             <span class="inlinecode">
              std::partial_ordering::unordered
             </span>
            </li>
           </ul>
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p315">
         </a>
        </p>
        <div>
         <span aria-label="315" epub:type="pagebreak" id="pagebreak_315" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1960">
         For example, let's assume that for our
         <span class="inlinecode">
          Vector
         </span>
         class we want the comparison operators to compare the magnitude of the vector, in which magnitude is the square root of the sum of each element squared:
         <span class="inlinecode">
          sqrt(mX∗mX + mY∗mY)
         </span>
         . We can remove the square root operator for performance reasons because we just care about relative comparisons, not the absolute value. We could therefore implement our spaceship operator as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0775">
           <img alt="image" height="1876" src="../../IMAGES/B9780443222191000064/main.assets/u07-154-9780443222191.jpg" width="2127"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div id="p1965">
         If you provide a custom spaceship operator implementation (as opposed to the compiler default implementation), then the compiler will require you to implement the
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          =
         </span>
         operator, if you want the
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          =
         </span>
         and
         <span class="inlinecode">
          !=
         </span>
         operators to work. The reasoning for this is that if you need a custom implementation for
         <span class="inlinecode">
          &lt;=&gt;
         </span>
         , then you most likely also need a custom implementation for
         <span title='hsp="0.25"'>
         </span>
         =
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          =
         </span>
         , because using
         <span class="inlinecode">
          &lt;=&gt;
         </span>
         to test for equality may be inefficient. For example, when comparing a vector or a string for equality, it would be more efficient first to check whether the lengths are the same before iterating over each element.
         <a id="p316">
         </a>
        </div>
        <div>
         <span aria-label="316" epub:type="pagebreak" id="pagebreak_316" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0225">
        </a>
        <h3 class="h2hd" id="cesectitle0235">
         Constraints and concepts
        </h3>
        <p class="textfl" id="p1970">
         One of the most common complaints about C++ templates is that compiler errors can be verbose and difficult to understand. This is because errors are often triggered deep within the template implementation, making it hard to figure out what the real problem is. C++20 introduced features called constraints and concepts to improve this situation. These let you add compile-time constraints to template parameters, allowing compilers to emit more useful errors if clients try to use the template in a manner that doesn't meet those constraints.
        </p>
        <p class="text" id="p1975">
         As an example, let's consider a simple function template to return the minimum of two values:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0780">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-155-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1980">
         This function has an implicit constraint that the type of the two values being compared must define a less than operator,
         <span class="inlinecode">
          &lt;
         </span>
         . If you pass in a type that doesn't meet that expectation, then you'll get a compile error, and that error will most likely be located within the template implementation:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0785">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000064/main.assets/u07-156-9780443222191.jpg" width="2044"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1985">
         Using constraints, we can now augment the function template declaration to specify that it’s valid to call the function only with integer or floating-point parameters. This is done with the new
         <span class="inlinecode">
          requires
         </span>
         keyword, which takes a compile-time constant expression, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0790">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-157-9780443222191.jpg" width="1769"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1990">
         Now the compiler will generate an error message at the actual call site of the function, not within the function template implementation, if it's called with nonnumeric parameters. You can also place the
         <span class="inlinecode">
          requires
         </span>
         expression after the function signature if you prefer.
         <a id="p317">
         </a>
         <span aria-label="317" epub:type="pagebreak" id="pagebreak_317" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0110" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0110">
           <div class="b1textfl" id="bpar0115">
            <i>
             TIP
            </i>
            :
            <i>
             Use constraints to define the expectations your code has for any template parameter types
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1995">
         The
         <span class="inlinecode">
          std::integral
         </span>
         and
         <span class="inlinecode">
          std::floating_point
         </span>
         symbols are called concepts. More specifically they are built-in concepts provided by the C++ Standard Library. A concept is essentially a named set of requirements that can be used with the
         <span class="inlinecode">
          requires
         </span>
         keyword. Here's a list of all of the built-in concepts that were added in C++20. These are all included in the new
         <span class="inlinecode">
          &lt;concepts&gt;
         </span>
         header, except where I indicate otherwise:
        </p>
        <div>
         <ol id="ulist0090">
          <li class="bulllist" id="p2000">
           <a id="u0285">
           </a>
           •
           <span class="inlinecode">
            std::same_as
           </span>
           : the type is the same as another type.
          </li>
          <li class="bulllist" id="p2005">
           <a id="u0290">
           </a>
           •
           <span class="inlinecode">
            std::derived_from
           </span>
           : the type is derived from another type.
          </li>
          <li class="bulllist" id="p2010">
           <a id="u0295">
           </a>
           •
           <span class="inlinecode">
            std::convertible_to
           </span>
           : the type is implicitly convertible to another type.
          </li>
          <li class="bulllist" id="p2015">
           <a id="u0300">
           </a>
           •
           <span class="inlinecode">
            std::common_reference_with
           </span>
           : two types share a common reference type.
          </li>
          <li class="bulllist" id="p2020">
           <a id="u0305">
           </a>
           •
           <span class="inlinecode">
            std::common_with
           </span>
           : two types share a common type.
          </li>
          <li class="bulllist" id="p2025">
           <a id="u0310">
           </a>
           •
           <span class="inlinecode">
            std::integral
           </span>
           : the type is an integral type.
          </li>
          <li class="bulllist" id="p2030">
           <a id="u0315">
           </a>
           •
           <span class="inlinecode">
            std::signed_integral
           </span>
           : the type is a signed integral type.
          </li>
          <li class="bulllist" id="p2035">
           <a id="u0320">
           </a>
           •
           <span class="inlinecode">
            std::unsigned_integral
           </span>
           : the type is an unsigned integral type.
          </li>
          <li class="bulllist" id="p2040">
           <a id="u0325">
           </a>
           •
           <span class="inlinecode">
            std::floating_point
           </span>
           : the type is a floating-point type.
          </li>
          <li class="bulllist" id="p2045">
           <a id="u0330">
           </a>
           •
           <span class="inlinecode">
            std::assignable_from
           </span>
           : the type is assignable from another type.
          </li>
          <li class="bulllist" id="p2050">
           <a id="u0335">
           </a>
           •
           <span class="inlinecode">
            std::swappable
           </span>
           : the type can be swapped (e.g., with
           <span class="inlinecode">
            std::swap)
           </span>
           .
          </li>
          <li class="bulllist" id="p2055">
           <a id="u0340">
           </a>
           •
           <span class="inlinecode">
            std::swappable_with
           </span>
           : two types can be swapped with each other.
          </li>
          <li class="bulllist" id="p2060">
           <a id="u0345">
           </a>
           •
           <span class="inlinecode">
            std::destructible
           </span>
           : an object of the type can be destroyed.
          </li>
          <li class="bulllist" id="p2065">
           <a id="u0350">
           </a>
           •
           <span class="inlinecode">
            std::constructible_from
           </span>
           : a variable of the type can be initialized with the given set of argument types.
          </li>
          <li class="bulllist" id="p2070">
           <a id="u0355">
           </a>
           •
           <span class="inlinecode">
            std::default_initializable
           </span>
           : an object of the type can be default constructed.
          </li>
          <li class="bulllist" id="p2075">
           <a id="u0360">
           </a>
           •
           <span class="inlinecode">
            std::move_constructible
           </span>
           : an object of the type can be move constructed.
          </li>
          <li class="bulllist" id="p2080">
           <a id="u0365">
           </a>
           •
           <span class="inlinecode">
            std::copy_constructible
           </span>
           : an object of the type can be copy and move constructed.
          </li>
          <li class="bulllist" id="p2085">
           <a id="u0370">
           </a>
           •
           <span class="inlinecode">
            std::equality_comparable
           </span>
           : operators
           <span title='hsp="0.25"'>
           </span>
           =
           <span title='hsp="0.25"'>
           </span>
           <span class="inlinecode">
            =
           </span>
           and
           <span class="inlinecode">
            !=
           </span>
           specify an equivalence relation.
          </li>
          <li class="bulllist" id="p2090">
           <a id="u0375">
           </a>
           •
           <span class="inlinecode">
            std::equality_comparable_with
           </span>
           : operators
           <span title='hsp="0.25"'>
           </span>
           =
           <span title='hsp="0.25"'>
           </span>
           <span class="inlinecode">
            =
           </span>
           and
           <span class="inlinecode">
            !=
           </span>
           specify an equivalence relation for two types.
          </li>
          <li class="bulllist" id="p2095">
           <a id="u0380">
           </a>
           •
           <span class="inlinecode">
            std::totally_ordered
           </span>
           : the type comparison operators yield a total order.
          </li>
          <li class="bulllist" id="p2100">
           <a id="u0385">
           </a>
           •
           <span class="inlinecode">
            std::totally_ordered_with
           </span>
           : the comparison operators for two types yield a total order.
          </li>
          <li class="bulllist" id="p2105">
           <a id="u0390">
           </a>
           •
           <span class="inlinecode">
            std::three_way_comparable
           </span>
           : operator
           <span class="inlinecode">
            &lt;=&gt;
           </span>
           produces consistent comparison results (defined in
           <span class="inlinecode">
            &lt;compare&gt;
           </span>
           ).
          </li>
          <li class="bulllist" id="p2110">
           <a id="u0395">
           </a>
           •
           <span class="inlinecode">
            std::three_way_comparable_with
           </span>
           : operator
           <span class="inlinecode">
            &lt;=&gt;
           </span>
           produces consistent comparison results for two types (defined in
           <span class="inlinecode">
            &lt;compare&gt;
           </span>
           ).
          </li>
          <li class="bulllist" id="p2115">
           <a id="u0400">
           </a>
           •
           <span class="inlinecode">
            std::movable
           </span>
           : an object of the type can be moved and swapped.
          </li>
          <li class="bulllist" id="p2120">
           <a id="u0405">
           </a>
           •
           <span class="inlinecode">
            std::copyable
           </span>
           : an object of the type can be copied, moved, and swapped.
           <a id="p318">
           </a>
          </li>
          <li>
           <span aria-label="318" epub:type="pagebreak" id="pagebreak_318" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p2125">
           <a id="u0410">
           </a>
           •
           <span class="inlinecode">
            std::semiregular
           </span>
           : an object of the type can be copied, moved, swapped, and default constructed.
          </li>
          <li class="bulllist" id="p2130">
           <a id="u0415">
           </a>
           •
           <span class="inlinecode">
            std::regular
           </span>
           : the type that is both
           <span class="inlinecode">
            semiregular
           </span>
           and
           <span class="inlinecode">
            equality_comparable
           </span>
           .
          </li>
          <li class="bulllist" id="p2135">
           <a id="u0420">
           </a>
           •
           <span class="inlinecode">
            std::invocable
           </span>
           : the callable type that can be invoked with a given set of argument types using
           <span class="inlinecode">
            std::invoke
           </span>
           .
          </li>
          <li class="bulllist" id="p2140">
           <a id="u0425">
           </a>
           •
           <span class="inlinecode">
            std::regular_invocable
           </span>
           : the callable type that can be invoked with
           <span class="inlinecode">
            std::invoke
           </span>
           where the invoke expression is equality preserving.
          </li>
          <li class="bulllist" id="p2145">
           <a id="u0430">
           </a>
           •
           <span class="inlinecode">
            std::predicate
           </span>
           : the callable type is a Boolean predicate.
          </li>
          <li class="bulllist" id="p2150">
           <a id="u0435">
           </a>
           •
           <span class="inlinecode">
            std::relation
           </span>
           : the callable type is a binary relation.
          </li>
          <li class="bulllist" id="p2155">
           <a id="u0440">
           </a>
           •
           <span class="inlinecode">
            std::equivalence_relation
           </span>
           : the relation imposes an equivalence relation.
          </li>
          <li class="bulllist" id="p2160">
           <a id="u0445">
           </a>
           •
           <span class="inlinecode">
            std::strict_weak_order
           </span>
           : the relation imposes a strict weak ordering.
          </li>
         </ol>
        </div>
        <p class="text" id="p2165">
         In addition to these built-in concepts, you can define your own with the
         <span class="inlinecode">
          concept
         </span>
         keyword. For example, continuing our earlier
         <span class="inlinecode">
          min()
         </span>
         function template, we could introduce a new concept for whether the type defines the
         <span class="inlinecode">
          &lt;
         </span>
         operator, rather than constraining the function to only integral and floating-point types. This can be done as follows:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0795">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-158-9780443222191.jpg" width="1698"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2170">
         We can now use our custom concept to redefine the
         <span class="inlinecode">
          min()
         </span>
         function template:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0800">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-159-9780443222191.jpg" width="1108"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2175">
         Constraints are a great way to give your clients more information about how you expect your templates to be used. They also allow the compiler to provide more helpful error messages if your clients pass in parameter types that don't conform to those expectations. You can use built-in concepts in the Standard Library to define these template parameter constraints or you can write your own concepts to express the requirements for your constraints more directly.
        </p>
       </section>
       <section>
        <a id="s0230">
        </a>
        <h3 class="h2hd" id="cesectitle0240">
         Abbreviated function templates
        </h3>
        <p class="textfl" id="p2180">
         The syntax for defining templates in C++ can be verbose and sometimes intimidating. To address this, C++20 introduced simpler syntax to express templates. Taking our
         <span class="inlinecode">
          min()
         </span>
         function template from the previous section:
         <a id="p319">
         </a>
         <span aria-label="319" epub:type="pagebreak" id="pagebreak_319" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0805">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-160-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2185">
         This can now be expressed more tersely using the
         <span class="inlinecode">
          auto
         </span>
         keyword as just:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0810">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-161-9780443222191.jpg" width="935"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2190">
         You can also use the abbreviated syntax to refer to a constraint directly within the parameter list. For example, our constrained version of the function template from the previous sections looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0815">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-162-9780443222191.jpg" width="1108"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2195">
         This can be simplified to the abbreviated form:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0820">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-163-9780443222191.jpg" width="2287"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2200">
         Although abbreviated templates are just a simplification of the existing template syntax, not all templating features can be expressed in abbreviated form. There are cases in which you will need to use the original nonabbreviated syntax. For example,
        </p>
        <div>
         <ol id="ulist0095">
          <li class="bulllist" id="p2205">
           <a id="u0450">
           </a>
           • In the previous abbreviated form of
           <span class="inlinecode">
            min()
           </span>
           , each
           <span class="inlinecode">
            auto
           </span>
           parameter could potentially be a different type. If you want to enforce that both parameters should be of the same type, T, then you should use the original nonabbreviated syntax.
          </li>
          <li class="bulllist" id="p2210">
           <a id="u0455">
           </a>
           • If you want to specify a template parameter with a default type, then you should use the nonabbreviated syntax (e.g.,
           <span class="inlinecode">
            template&lt;typename T = void&gt;)
           </span>
           .
          </li>
          <li class="bulllist" id="p2215">
           <a id="u0460">
           </a>
           • If you want to use variadic template parameter packs, then these will also require the nonabbreviated form (e.g.,
           <span class="inlinecode">
            template&lt;typename... T&gt;)
           </span>
           .
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0235">
        </a>
        <h3 class="h2hd" id="cesectitle0245">
         The consteval specifier
        </h3>
        <p class="textfl" id="p2220">
         C++11 introduced the
         <span class="inlinecode">
          constexpr
         </span>
         specifier to allow functions or variables to be used in constant expressions. With C++20, we now also have the
         <span class="inlinecode">
          consteval
         </span>
         specifier, which is
         <a id="p320">
         </a>
         <span aria-label="320" epub:type="pagebreak" id="pagebreak_320" role="doc-pagebreak">
         </span>
         used to declare an “immediate” function (i.e., a function that must produce a constant at compile time).
        </p>
        <p class="text" id="p2225">
         The difference between
         <span class="inlinecode">
          constexpr
         </span>
         and
         <span class="inlinecode">
          consteval
         </span>
         is that the former is a hint to the compiler to evaluate the function at compile time if possible, whereas
         <span class="inlinecode">
          consteval
         </span>
         requires the function to be evaluated at compile time. The compiler will generate an error if it cannot. Also,
         <span class="inlinecode">
          constexpr
         </span>
         can be applied to functions and variables, whereas
         <span class="inlinecode">
          consteval
         </span>
         can be applied only to functions. Here's an example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0825">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-164-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2230">
         This
         <span class="inlinecode">
          consteval
         </span>
         function can be evaluated at compile time, allowing the compiler to insert the constant result instead of making a function call. An implication of this is the compiled object code would not need to have a
         <span class="inlinecode">
          Deg2Rad
         </span>
         symbol. You can therefore think about this as a way to get the functionality of C preprocessor function macros using pure C++ syntax and with full type checking. In other words, this
         <span class="inlinecode">
          consteval
         </span>
         function could replace a macro such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0830">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000064/main.assets/u07-165-9780443222191.jpg" width="1628"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0115" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0115">
           <div class="b1textfl" id="bpar0120">
            <i>
             TIP
            </i>
            :
            <i>
             Prefer using a
            </i>
            <span class="inlinecode">
             <i>
              consteval
             </i>
            </span>
            <i>
             function instead of a preprocessor function macro
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0240">
        </a>
        <h3 class="h2hd" id="cesectitle0250">
         The constinit specifier
        </h3>
        <p class="textfl" id="p2235">
         A related specifier that was also introduced in C++20 is
         <span class="inlinecode">
          constinit
         </span>
         . This is used to ensure that a static or thread storage variable is initialized at compile time to avoid the well-known problems with static initialization order at library load time.
        </p>
        <p class="text" id="p2240">
         The
         <span class="inlinecode">
          constinit
         </span>
         specifier can only be applied to variables (you can use
         <span class="inlinecode">
          consteval
         </span>
         to evaluate a function at compile time, as I just described). A compile error will be generated if you try to initialize a
         <span class="inlinecode">
          constinit
         </span>
         variable with a value that can't be evaluated at compile time, or if you try to use it on a local variable within a function. Let's look at an example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0835">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-166-9780443222191.jpg" width="2047"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p321">
         </a>
        </p>
        <div>
         <span aria-label="321" epub:type="pagebreak" id="pagebreak_321" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p2245">
         In this example, I've declared
         <span class="inlinecode">
          PROJECT_NAME
         </span>
         as
         <span class="inlinecode">
          constinit
         </span>
         , so it'll be initialized at compile time, avoiding any potential static initialization issues at library load time. To do that, the
         <span class="inlinecode">
          GetName()
         </span>
         function had to be declared
         <span class="inlinecode">
          constexpr
         </span>
         to indicate that it can be evaluated at compile time.
        </p>
        <div>
         <aside aria-labelledby="b0120" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0120">
           <div class="b1textfl" id="bpar0125">
            <i>
             TIP
            </i>
            :
            <i>
             Use
            </i>
            <span class="inlinecode">
             <i>
              constinit
             </i>
            </span>
            <i>
             to initialize static or thread storage variables at compile time
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0245">
        </a>
        <h3 class="h2hd" id="cesectitle0255">
         Migrating to C++20
        </h3>
        <p class="textfl" id="p2250">
         If you're looking to move your API to support C++20, then perhaps the biggest feature to consider using is modules. Modules offer several useful features for building large software projects, including the potential for improved compile times and the lack of side effects when importing modules. However, there are also a few caveats to be aware of:
        </p>
        <div>
         <ol id="ulist0100">
          <li class="bulllist" id="p2255">
           <a id="u0465">
           </a>
           • Right now, support for modules is limited. Microsoft has good support for modules in its MSVC compiler, but the latest clang compiler included with Xcode does not yet support modules (although you can use
           <span class="inlinecode">
            brew install llvm
           </span>
           to install a version with partial modules support on macOS). In particular, the current clang documentation describes header unit support as highly experimental as of 2023.
          </li>
          <li class="bulllist" id="p2260">
           <a id="u0470">
           </a>
           • The format used to represent a module is left as a compiler implementation detail, meaning that they are not portable across different compilers and perhaps not even between different versions of the same compiler.
          </li>
          <li class="bulllist" id="p2265">
           <a id="u0475">
           </a>
           • One of the benefits of modules is the potential to improve compile time performance, but we also need to think about how modules can be used as a distributing mechanism for APIs. For binary distributions, today you will provide clients with a prebuilt library and header files. If you are using modules, then you will presumably also need to package the precompiled module binary files (although just the module interface units, not any implementation units).
          </li>
          <li class="bulllist" id="p2270">
           <a id="u0480">
           </a>
           • Modules must be compiled in a specific order to handle dependencies correctly. If module A imports module B, then module B must be compiled first so that its binary module interface file is accessible to module A. With traditional header files, the C++ compiler could parallelize compilation of translation units to speed up compilation times. This is no longer possible with modules. At a minimum, any parallelization effort would need to be constrained by the module dependency ordering.
          </li>
          <li class="bulllist" id="p2275">
           <a id="u0485">
           </a>
           • Distributing header files with library binaries has the benefit that they can be read by humans in a text editor. However a binary module file cannot be interpreted as easily. Therefore either we must rely on good documentation generation tools or we need to distribute the source code for our module interface units so that clients
           <a id="p322">
           </a>
           <span aria-label="322" epub:type="pagebreak" id="pagebreak_322" role="doc-pagebreak">
           </span>
           know how to use your API (or in the case of header units, you can just share your header files as you would do normally). This provides another reason to split your interface and implementation across different module units: so you don't need to share your implementation code if you don't want to.
          </li>
         </ol>
        </div>
        <p class="text" id="p2280">
         Presumably many of these caveats will be addressed over time as modules are used more widely and become more mature. I look forward to the opportunity to update this section in a future revision of this book to cover those learnings and improvements.
        </p>
        <p class="text" id="p2285">
         In terms of other C++20 features to consider adopting in your APIs, template constraints are a great addition that will improve template error messages for your clients and make it more clear what types they can use as template parameters. Because constraints are a compile-time check, you should be able to add them to your APIs without breaking binary compatibility. Although it's possible that adding a constraint will mean that client code will now fail to compile where it worked before, it's more likely that those cases were already invalid uses of your interface that failed to compile in earlier versions of your API as well.
        </p>
        <p class="text" id="p2290">
         The use of abbreviated function syntax is purely a stylistic choice. If you like the terser syntax, then feel free to use it. Just remember that there are some template features that can't be expressed in the abbreviated syntax.
        </p>
        <p class="text" id="p2295">
         The
         <span class="inlinecode">
          consteval
         </span>
         specifier is a type-safe alternative to using preprocess function-like macros, and as such it is a good feature to consider using. Nevertheless if you convert an existing nonmacro function to a
         <span class="inlinecode">
          consteval
         </span>
         function, then the symbol will no longer be defined in your library binary, so binary compatibility will be broken.
        </p>
        <p class="text" id="p2300">
         The
         <span class="inlinecode">
          constinit
         </span>
         specifier can help to reduce the cost and dangers of static initialization when your library code is loaded, so it, too, is worth adopting where feasible. Not all static or thread storage variable definitions can be converted to use
         <span class="inlinecode">
          constinit
         </span>
         , only those that can be calculated at compile time. However the use of this specifier should be backward compatible because it just optimizes the initialization of a variable before function
         <span class="inlinecode">
          main()
         </span>
         is called.
        </p>
       </section>
      </section>
      <section>
       <a id="s0250">
       </a>
       <h2 class="h1hd" id="cesectitle0260">
        C++23 API features
       </h2>
       <p class="textfl" id="p2305">
        The most recent C++ revision that I'll cover in this edition of the book is C++23. At the time of writing, this revision has not yet been published; however, the set of proposed new features is well-established.
       </p>
       <p class="text" id="p2310">
        Although the early working group meetings for C++23 were affected by the COVID-19 pandemic, a large number of new features are being added to this revision of the standard, such as a
        <span class="inlinecode">
         contains()
        </span>
        function for
        <span class="inlinecode">
         std::string
        </span>
        and
        <span class="inlinecode">
         std::string_view
        </span>
        , additional monadic members on
        <span class="inlinecode">
         std::optional
        </span>
        like
        <span class="inlinecode">
         and_then()
        </span>
        and
        <span class="inlinecode">
         or_else()
        </span>
        , and a
        <span class="inlinecode">
         #warning
        </span>
        preprocessor directive. Modules support for the Standard Library is also being added with the introduction of
        <span class="inlinecode">
         std
        </span>
        and
        <span class="inlinecode">
         std.compat
        </span>
        named modules.
        <a id="p323">
        </a>
       </p>
       <div>
        <span aria-label="323" epub:type="pagebreak" id="pagebreak_323" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p2315">
        There are also several new features that can affect API design, including the
        <span class="inlinecode">
         std::expected
        </span>
        template, multidimensional subscript operators, and several new preprocessor directives. I'll cover these new features in these final sections of the chapter.
       </p>
       <section>
        <a id="s0255">
        </a>
        <h3 class="h2hd" id="cesectitle0265">
         Expected values
        </h3>
        <p class="textfl" id="p2320">
         The
         <span class="inlinecode">
          std::expected
         </span>
         class template provides a way to return either a valid object or an error. This can be useful as a function return value when you want to be able to return a valid result but also provide additional information in the case of an error. In that case, it's common to use an integer or an enum to represent the error value. For example, here's an image loading function that can return either the image data or an error enum:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0840">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000064/main.assets/u07-167-9780443222191.jpg" width="2322"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0125" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0125">
           <div class="b1textfl" id="bpar0130">
            <i>
             TIP
            </i>
            :
            <i>
             Use
            </i>
            <span class="inlinecode">
             <i>
              std
             </i>
             :
             <i>
              :expected
             </i>
            </span>
            <i>
             when you want a function to return either a valid result or details about the error (such as an error code or enum) if there was a failure
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p2325">
         Callers of this function can check the
         <span class="inlinecode">
          has_value()
         </span>
         member of the
         <span class="inlinecode">
          std::expected
         </span>
         return result to see whether it holds a valid value. If this is
         <span class="inlinecode">
          true
         </span>
         , then the
         <span class="inlinecode">
          value()
         </span>
         member function can be used to access the value; otherwise
         <span class="inlinecode">
          error()
         </span>
         can be used to access to error. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0845">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000064/main.assets/u07-168-9780443222191.jpg" width="2253"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2330">
         You can also use simpler pointer-like syntax to check whether there is a valid value and to access members of the value object, as shown here:
         <a id="p324">
         </a>
         <span aria-label="324" epub:type="pagebreak" id="pagebreak_324" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0850">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-169-9780443222191.jpg" width="2012"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2335">
         Clients can also use the
         <span class="inlinecode">
          value_or()
         </span>
         member of
         <span class="inlinecode">
          std::expected
         </span>
         to access the value or to use a default value if there was an error, e.g.,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0855">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000064/main.assets/u07-170-9780443222191.jpg" width="2114"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2340">
         In the past, you might have used an
         <span class="inlinecode">
          std::optional
         </span>
         to return a value but also indicate if an error happened. However, in that case you cannot provide additional information about the error, just that something unexpected happened and there is no valid value. The
         <span class="inlinecode">
          std::expected
         </span>
         template is therefore a better choice if you want to return a valid object or return some error code or enum if the operation failed.
        </p>
       </section>
       <section>
        <a id="s0260">
        </a>
        <h3 class="h2hd" id="cesectitle0270">
         Multidimensional subscript operator
        </h3>
        <p class="textfl" id="p2345">
         C++ lets you to define a subscript operator,
         <span class="inlinecode">
          []
         </span>
         , to access the underlying data in your classes using an array subscript syntax, such as
         <span class="inlinecode">
          object[0]
         </span>
         . For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0860">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-171-9780443222191.jpg" width="1353"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2350">
         This lets you use
         <span class="inlinecode">
          array[n]
         </span>
         syntax to access elements of
         <span class="inlinecode">
          SparseArray
         </span>
         , and you can also assign values to the array using the overload with the reference return type: for example,
         <span class="inlinecode">
          array[n] = 2
         </span>
         .
        </p>
        <p class="text" id="p2355">
         However, this support is limited to one-dimensional arrays. There are many problem domains where multidimensional arrays are useful, such as representing matrices in linear algebra, 2D or 3D coordinate systems for games, and images for graphics. Common workarounds to this limitation include:
        </p>
        <div>
         <ol id="ulist0105">
          <li class="bulllist" id="p2360">
           <a id="u0490">
           </a>
           • Using a regular function call, such as
           <span class="inlinecode">
            array.at(x, y, z)
           </span>
           .
          </li>
          <li class="bulllist" id="p2365">
           <a id="u0495">
           </a>
           • Overloading the call operator for an object, such as
           <span class="inlinecode">
            array(x, y, z)
           </span>
           .
          </li>
          <li class="bulllist" id="p2370">
           <a id="u0500">
           </a>
           • Using a chain of one-dimensional arrays, such as
           <span class="inlinecode">
            array[x][y][z]
           </span>
           .
          </li>
         </ol>
        </div>
        <p class="text" id="p2375">
         However, as of C++23, we now have direct support for multidimensional arrays. For example, here is an example of defining a 2D array using C++23:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0865">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000064/main.assets/u07-172-9780443222191.jpg" width="1559"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p325">
         </a>
        </p>
        <div>
         <span aria-label="325" epub:type="pagebreak" id="pagebreak_325" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p2380">
         Clients can now get and set elements of this array using
         <span class="inlinecode">
          array[x, y]
         </span>
         syntax; for example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0870">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-173-9780443222191.jpg" width="1039"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0130" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0130">
           <div class="b1textfl" id="bpar0135">
            <i>
             TIP
            </i>
            :
            <i>
             Use the multidimensional subscript operator when you want to model 2D
            </i>
            ,
            <i>
             3D
            </i>
            ,
            <i>
             or higher dimensionality concepts
            </i>
            .
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p2385">
         This new syntax is possible because the use of the comma operator in subscript expressions was deprecated in C++20. This paved the way for C++23 to reuse the syntax to represent multidimensional arrays.
        </p>
        <p class="text" id="p2390">
         You can also use variadic templates in combination with the new multidimensional subscript operator. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0875">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000064/main.assets/u07-174-9780443222191.jpg" width="1802"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2395">
         This allows clients to use a variable number of indices for the array access. For example, you could enforce a default value for a 3D coordinate if no index is provided, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0880">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000064/main.assets/u07-175-9780443222191.jpg" width="761"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0265">
        </a>
        <h3 class="h2hd" id="cesectitle0275">
         Preprocessor directives
        </h3>
        <p class="textfl" id="p2400">
         The C preprocessor provides several directives to support conditional compilation in header and source files. These are the
         <span class="inlinecode">
          #if
         </span>
         ,
         <span class="inlinecode">
          #else
         </span>
         ,
         <span class="inlinecode">
          #elif
         </span>
         , and
         <span class="inlinecode">
          #endif
         </span>
         directives. There's also the
         <span class="inlinecode">
          #ifdef
         </span>
         directive, which is another way to write
         <span class="inlinecode">
          #if defined()
         </span>
         , and
         <span class="inlinecode">
          #ifndef
         </span>
         , which is alternate syntax for
         <span class="inlinecode">
          #if !defined()
         </span>
         . The
         <span class="inlinecode">
          defined()
         </span>
         operator is used to verify whether a macro has been defined.
         <a id="p326">
         </a>
        </p>
        <div>
         <span aria-label="326" epub:type="pagebreak" id="pagebreak_326" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p2405">
         However, there are no equivalent shorthand versions for the
         <span class="inlinecode">
          #elif
         </span>
         directive. This is generally considered an oversight in the original C language and was addressed in C++23 with the introduction of:
        </p>
        <div>
         <ol id="ulist0110">
          <li class="bulllist" id="p2410">
           <a id="u0505">
           </a>
           •
           <span class="inlinecode">
            #elifdef
           </span>
           : shorthand for
           <span class="inlinecode">
            #elif defined()
           </span>
           .
          </li>
          <li class="bulllist" id="p2415">
           <a id="u0510">
           </a>
           •
           <span class="inlinecode">
            #elifndef
           </span>
           : shorthand for
           <span class="inlinecode">
            #elif !defined()
           </span>
           .
          </li>
         </ol>
        </div>
        <p class="text" id="p2420">
         For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0885">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000064/main.assets/u07-176-9780443222191.jpg" width="1767"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2425">
         If this code is compiled with a compiler that does not support the new directives, then they will be skipped and the logic will move from the first
         <span class="inlinecode">
          #ifdef
         </span>
         to the #
         <span class="inlinecode">
          else
         </span>
         . You can use this behavior to detect whether your compiler supports the new directives:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0890">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000064/main.assets/u07-177-9780443222191.jpg" width="969"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2430">
         C++23 also introduced another preprocessor directive:
         <span class="inlinecode">
          #warning
         </span>
         , which provides a compile-time warning when clients compile against your API. Many compilers already provided this feature, but it was not officially part of the standard until C++23. This feature provides a complement to the
         <span class="inlinecode">
          #error
         </span>
         directive, which will issue a compile-time error. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0895">
           <img alt="image" height="545" src="../../IMAGES/B9780443222191000064/main.assets/u07-178-9780443222191.jpg" width="1872"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2435">
         One further preprocessor directive introduced in C++23 is
         <span class="inlinecode">
          #embed
         </span>
         . This provides a standard way to include binary data in an executable. For example, this can be used to embed the binary data easily for an image, video, or sound file in your code. Although you may generally prefer to use this feature within your source files, you can combine
         <a id="p327">
         </a>
         <span aria-label="327" epub:type="pagebreak" id="pagebreak_327" role="doc-pagebreak">
         </span>
         this with features such as
         <span class="inlinecode">
          constinit
         </span>
         and
         <span class="inlinecode">
          inline
         </span>
         to define an inline variable that provides the raw binary data for certain resources provided by your API. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0900">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-179-9780443222191.jpg" width="1351"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p2440">
         The
         <span class="inlinecode">
          #embed
         </span>
         directive will load the specified file at compile time and insert the contents of the file as a comma-separated list of integers. So that code will be expanded to something like the following once the preprocessor phase has completed:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0905">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000064/main.assets/u07-180-9780443222191.jpg" width="1352"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0270">
        </a>
        <h3 class="h2hd" id="cesectitle0280">
         Migrating to C++23
        </h3>
        <p class="textfl" id="p2445">
         If you're planning to move your API's minimum supported C++ version to C++23, then adding support for
         <span class="inlinecode">
          std::expected
         </span>
         can provide an elegant way to return a valid result from a function or an error with more context regarding what went wrong. However this will, of course, break source and binary compatibility.
        </p>
        <p class="text" id="p2450">
         If your API naturally deals with multidimensional quantities, then you may want to consider adding support for the new subscript operator. This would be a new capability that you add to your API, so it should not break existing code.
        </p>
        <p class="text" id="p2455">
         Finally, using
         <span class="inlinecode">
          #warning
         </span>
         and
         <span class="inlinecode">
          #error
         </span>
         can be useful to provide compile-time feedback to your clients if they're missing some required or optional dependency. You could also use the new conditional compilation directives,
         <span class="inlinecode">
          #elifdef
         </span>
         and
         <span class="inlinecode">
          #elifndef
         </span>
         , if you prefer this syntax over the more verbose alternative. Even though these two new directives were introduced in C++23, the standard encourages compiler implementors to backport these features to older language modes as well. As noted earlier,
         <span class="inlinecode">
          #warning
         </span>
         was already implemented by many compilers before C++23. So you may be able to take advantage of these features in most compilers even before upgrading to C++23.
        </p>
       </section>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
