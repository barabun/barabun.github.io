<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   8
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_015.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_017.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div class="calibre2" id="_idContainer123">
    <h1 class="chapter-number" id="_idParaDest-170">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor170">
     </a>
     8
    </h1>
    <h1 class="calibre5" id="_idParaDest-171">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor171">
     </a>
     Threading Basics –Asynchronous Programming
    </h1>
    <p class="calibre3">
     Most modern software runs its processes in parallel and offloads tasks to different threads to take advantage of modern CPU multicore architecture. This way, software can be more efficient by running multiple processes simultaneously without affecting performance. In this chapter, we will learn how to make
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker532">
     </a>
     use of
     <strong class="bold">
      threads
     </strong>
     to boost our Qt 6 application’s performance
     <span>
      and efficiency.
     </span>
    </p>
    <p class="calibre3">
     This chapter will cover the
     <span>
      following recipes:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <span>
       Using threads
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       QObject
      </strong>
      <span>
       and
      </span>
      <span>
       <strong class="source-inline1">
        QThread
       </strong>
      </span>
     </li>
     <li class="calibre14">
      Data protection and sharing data
      <span>
       between threads
      </span>
     </li>
     <li class="calibre14">
      Working with
      <span>
       <strong class="source-inline1">
        QRunnable
       </strong>
      </span>
      <span>
       processes
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-172">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor172">
     </a>
     Technical requirements
    </h1>
    <p class="calibre3">
     The technical requirements for this chapter include Qt 6.6.1 and Qt Creator 12.0.2. All the code used in this chapter can be downloaded from the following GitHub
     <span>
      repository:
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08">
      <span>
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter08
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-173">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor173">
     </a>
     Using threads
    </h1>
    <p class="calibre3">
     Qt 6 provides
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker533">
     </a>
     multiple methods to create and use threads. You can choose between high-level methods and low-level ones. High-level methods are much easier to get started but are limited in what you can do with them. Conversely, low-level methods are more flexible but not beginner-friendly. In this recipe, we will learn how to use one of the high-level methods to easily create a multithreading Qt
     <span>
      6 application.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-174">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor174">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s learn how to create multithreading applications by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a
      <strong class="bold">
       Qt widget application
      </strong>
      and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker534">
      </a>
      open up
      <strong class="source-inline1">
       main.cpp
      </strong>
      . Then, add the following headers at the top of
      <span>
       the file:
      </span>
      <pre class="source-code">
#include &lt;QFuture&gt;
#include &lt;QtConcurrent/QtConcurrent&gt;
#include &lt;QFutureWatcher&gt;
#include &lt;QThread&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li class="calibre14">
      Then, create
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker535">
      </a>
      a function called
      <strong class="source-inline1">
       printText()
      </strong>
      before the
      <span>
       <strong class="source-inline1">
        main()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void printText(QString text, int count) {
    for (int i = 0; i &lt; count; ++i)
        qDebug() &lt;&lt; text &lt;&lt; QThread::currentThreadId();
    qDebug() &lt;&lt; text &lt;&lt; "Done";
}</pre>
     </li>
     <li class="calibre14">
      After that, add the following code to the
      <span>
       <strong class="source-inline1">
        main()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
<strong class="bold1">    printText("A", 100);</strong>
<strong class="bold1">    printText("B", 100);</strong>
    return a.exec();
}</pre>
     </li>
     <li class="calibre14">
      If you build and run the program now, you should see that
      <strong class="source-inline1">
       A
      </strong>
      gets printed first before
      <strong class="source-inline1">
       B
      </strong>
      . Note that their thread IDs are all the same. This is because we are running the
      <strong class="source-inline1">
       printText()
      </strong>
      functions in the
      <span>
       main thread:
      </span>
      <pre class="source-code">
...
"A" 0x2b82c
"A" 0x2b82c
"A" 0x2b82c
"A" Done
...
"B" 0x2b82c
"B" 0x2b82c
"B" 0x2b82c
"B" Done</pre>
     </li>
     <li class="calibre14">
      To separate them
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker536">
      </a>
      into different threads, let’s use a high-level class provided by Qt 6 called
      <strong class="source-inline1">
       QFuture
      </strong>
      . Comment out the two
      <strong class="source-inline1">
       printText()
      </strong>
      functions in
      <strong class="source-inline1">
       main()
      </strong>
      and use the following
      <span>
       code instead:
      </span>
      <pre class="source-code">
    QFuture&lt;void&gt; f1 = QtConcurrent::run(printText, QString("A"), 100);
    QFuture&lt;void&gt; f2 = QtConcurrent::run(printText, QString("B"), 100);
    QFuture&lt;void&gt; f3 = QtConcurrent::run(printText, QString("C"), 100);
    f1.waitForFinished();
    f2.waitForFinished();
    f3.waitForFinished();</pre>
     </li>
     <li class="calibre14">
      If you build and run the program again, you should see something like the following being printed out on the debug window, which means that the three
      <strong class="source-inline1">
       printText()
      </strong>
      functions now run
      <span>
       in parallel:
      </span>
      <pre class="source-code">
...
"A" 0x271ec
"C" 0x26808
"B" 0x27a40
"A" 0x271ec
"C" Done
"B" 0x27a40
"A" Done
"B" Done</pre>
     </li>
     <li class="calibre14">
      We can also use the
      <strong class="source-inline1">
       QFutureWatcher
      </strong>
      class to notify a
      <strong class="source-inline1">
       QObject
      </strong>
      class through a
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker537">
      </a>
      signals and slots mechanism. The
      <strong class="source-inline1">
       QFutureWatcher
      </strong>
      class allows us to monitor
      <strong class="source-inline1">
       QFuture
      </strong>
      using signals
      <span>
       and slots:
      </span>
      <pre class="source-code">
    QFuture&lt;void&gt; f1 = QtConcurrent::run(printText, QString("A"), 100);
    QFuture&lt;void&gt; f2 = QtConcurrent::run(printText, QString("B"), 100);
    QFuture&lt;void&gt; f3 = QtConcurrent::run(printText, QString("C"), 100);
    <strong class="bold1">QFutureWatcher&lt;void&gt; futureWatcher;</strong>
    <strong class="bold1">QObject::connect(&amp;futureWatcher,</strong>
    <strong class="bold1">QFutureWatcher&lt;void&gt;::finished, &amp;w, MainWindow::mySlot);</strong>
    <strong class="bold1">futureWatcher.setFuture(f1);</strong>
    f1.waitForFinished();
    f2.waitForFinished();
    f3.waitForFinished();</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and declare the
      <span>
       slot function:
      </span>
      <pre class="source-code">
public slots:
    void mySlot();</pre>
     </li>
     <li class="calibre14">
      The
      <strong class="source-inline1">
       mySlot()
      </strong>
      function looks like this
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        mainwindow.cpp
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
void MainWindow::mySlot() {
    qDebug() &lt;&lt; "Done!" &lt;&lt; QThread::currentThreadId();
}</pre>
     </li>
     <li class="calibre14">
      If you build and run
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker538">
      </a>
      the program again, this time, you will see results
      <span>
       like this:
      </span>
      <pre class="source-code">
...
"A" 0x271ec
"C" 0x26808
"B" 0x27a40
"A" 0x271ec
"C" Done
"B" 0x27a40
"A" Done
"B" Done
<strong class="bold1">Done! 0x27ac0</strong></pre>
     </li>
     <li class="calibre14">
      Even though
      <strong class="source-inline1">
       QFutureWatcher
      </strong>
      is linked to
      <strong class="source-inline1">
       f1
      </strong>
      , the
      <strong class="source-inline1">
       Done!
      </strong>
      message only gets printed after all of the threads have finished executing. This is because
      <strong class="source-inline1">
       mySlot()
      </strong>
      runs in the main thread, proven by the thread ID shown in the debug window alongside the
      <span>
       <strong class="source-inline1">
        Done!
       </strong>
      </span>
      <span>
       message.
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-175">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor175">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     By default, there is a main thread (also known as a GUI thread) in any Qt 6 application. Other threads that you create are
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker539">
     </a>
     called the
     <span>
      <strong class="bold">
       worker threads
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     GUI-related classes, such as
     <strong class="source-inline">
      QWidget
     </strong>
     and
     <strong class="source-inline">
      QPixmap
     </strong>
     , can only exist in the main thread, so you must be extra careful when dealing with
     <span>
      these classes.
     </span>
    </p>
    <p class="calibre3">
     <strong class="source-inline">
      QFuture
     </strong>
     is a high-level class that deals
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker540">
     </a>
     with
     <span>
      <strong class="bold">
       asynchronous computation
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     We use the
     <strong class="source-inline">
      QFutureWatcher
     </strong>
     class to let
     <strong class="source-inline">
      QFuture
     </strong>
     interact with signals and slots. You can even use
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker541">
     </a>
     this to display the progress of the operation on a
     <span>
      progress bar.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-176">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor176">
     </a>
     QObject and QThread
    </h1>
    <p class="calibre3">
     Next, we want to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker542">
     </a>
     explore some
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker543">
     </a>
     other methods so that we can use threads in Qt 6 applications. Qt 6 provides a class called
     <strong class="source-inline">
      QThread
     </strong>
     , which gives you more control over how you create and execute a thread. A
     <strong class="source-inline">
      QThread
     </strong>
     object begins to execute its event loops in a thread by calling the
     <strong class="source-inline">
      run()
     </strong>
     function. In this example, we will learn how to make the
     <strong class="source-inline">
      QObject
     </strong>
     class work together asynchronously through the
     <span>
      <strong class="source-inline">
       Qthread
      </strong>
     </span>
     <span>
      class.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-177">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor177">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started by performing the
     <span>
      following steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a new Qt widget application project. Then, go to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project...
      </strong>
      and create a
      <strong class="bold">
       C++
      </strong>
      <span>
       <strong class="bold">
        Class
       </strong>
      </span>
      <span>
       file:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer121">
      <img alt="Figure 8.1 – Create a new C++ class" class="calibre4" src="image/B20976_08_001.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 8.1 – Create a new C++ class
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      After that, name
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker544">
      </a>
      the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker545">
      </a>
      new class
      <strong class="source-inline1">
       MyWorker
      </strong>
      and make it inherit from the
      <strong class="source-inline1">
       QObject
      </strong>
      class. Don’t forget to include the
      <strong class="source-inline1">
       QObject
      </strong>
      class by default
      <span>
       as well:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer122">
      <img alt="Figure 8.2 – Define the MyWorker C++ class" class="calibre4" src="image/B20976_08_002.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 8.2 – Define the MyWorker C++ class
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Once you have created the
      <strong class="source-inline1">
       MyWorker
      </strong>
      class, open up
      <strong class="source-inline1">
       myworker.h
      </strong>
      and add the following headers at
      <span>
       the top:
      </span>
      <pre class="source-code">
#include &lt;QObject&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li class="calibre14">
      After that, add the following signals and slot functions to the file
      <span>
       as well:
      </span>
      <pre class="source-code">
signals:
    void showResults(int res);
    void doneProcess();
public slots:
    void process();</pre>
     </li>
     <li class="calibre14">
      Next, open up
      <strong class="source-inline1">
       myworker.cpp
      </strong>
      and implement the
      <span>
       <strong class="source-inline1">
        process()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void MyWorker::process() {
    int result = 0;
    for (int i = 0; i &lt; 2000000000; ++i) {
    result += 1;
    }
    emit showResults(result);
    emit doneProcess();
}</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and add the following headers at
      <span>
       the top:
      </span>
      <pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QThread&gt;
#include "myworker.h"</pre>
     </li>
     <li class="calibre14">
      Then, declare a
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker546">
      </a>
      slot
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker547">
      </a>
      function, as shown in the
      <span>
       following code:
      </span>
      <pre class="source-code">
public slots:
    void handleResults(int res);</pre>
     </li>
     <li class="calibre14">
      Once you’re done, open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and implement the
      <span>
       <strong class="source-inline1">
        handResults()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void MainWindow::handleResults(int res) {
    qDebug() &lt;&lt; "Handle results" &lt;&lt; res;
}</pre>
     </li>
     <li class="calibre14">
      Lastly, we will add the following code to the class constructor of the
      <span>
       <strong class="source-inline1">
        MainWindow
       </strong>
      </span>
      <span>
       class:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) :     QMainWindow(parent), ui(new Ui::MainWindow){
    ui-&gt;setupUi(this);
    QThread* workerThread = new QThread;
    MyWorker *workerObject = new MyWorker;
    workerObject-&gt;moveToThread(workerThread);
    connect(workerThread, &amp;QThread::started,  workerObject, &amp;MyWorker::process);
    connect(workerObject, &amp;MyWorker::doneProcess,  workerThread, &amp;QThread::quit);
    connect(workerObject, &amp;MyWorker::doneProcess, workerObject, &amp;MyWorker::deleteLater);
    connect(workerObject, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread, &amp;QThread::finished, workerObject, &amp;MyWorker::deleteLater);
    workerThread-&gt;start();
}</pre>
     </li>
     <li class="calibre14">
      Build and run the program now. You should see that the main window pops out and does nothing for
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker548">
      </a>
      a
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker549">
      </a>
      couple of seconds before a line of message is printed on the
      <span>
       debug window:
      </span>
      <pre class="source-code">
Final result: 2000000000</pre>
     </li>
     <li class="calibre14">
      The result was calculated in a separate thread, which is why the main window can display smoothly and can even be moved around by a mouse during the calculation. To see the difference when running the calculation on the main thread, let’s comment out some of the code and call the
      <strong class="source-inline1">
       process()
      </strong>
      <span>
       function directly:
      </span>
      <pre class="source-code">
    //QThread* workerThread = new QThread;
    MyWorker *workerObject = new MyWorker;
    //workerObject-&gt;moveToThread(workerThread);
    //connect(workerThread, &amp;QThread::started, workerObject, &amp;MyWorker::process);
    //connect(workerObject, &amp;MyWorker::doneProcess, workerThread, &amp;QThread::quit);
    connect(workerObject, &amp;MyWorker::doneProcess, workerObject, &amp;MyWorker::deleteLater);
    connect(workerObject, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    //connect(workerThread, &amp;QThread::finished, workerObject, &amp;MyWorker::deleteLater);
    //workerThread-&gt;start();
    <strong class="bold1">workerObject-&gt;process();</strong></pre>
     </li>
     <li class="calibre14">
      Build and run the project now. This time, the main window will only appear on the screen once the calculation has been done. This is because the calculation was blocking the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker550">
      </a>
      main
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker551">
      </a>
      thread (or GUI thread) and prevented the main window from
      <span>
       being displayed.
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-178">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor178">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     <strong class="source-inline">
      QThread
     </strong>
     is an alternative method to run a process asynchronously, besides using the
     <strong class="source-inline">
      QFuture
     </strong>
     class. It gives us more control compared with
     <strong class="source-inline">
      QFuture
     </strong>
     , which we will demonstrate in the
     <span>
      following recipe.
     </span>
    </p>
    <p class="calibre3">
     Do note that the
     <strong class="source-inline">
      QObject
     </strong>
     class that gets moved to the working thread cannot have any parent, as Qt is designed in such a way that an entire object tree must exist in the same thread. Therefore, all of the children of a
     <strong class="source-inline">
      QObject
     </strong>
     class will also be moved to the working thread when you
     <span>
      call
     </span>
     <span>
      <strong class="source-inline">
       moveToThread()
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     Use a signals and slots mechanism if you want your working thread to communicate with the main thread. We use the started signal that’s provided by the
     <strong class="source-inline">
      QThread
     </strong>
     class to inform our working object to start the calculation, since the working thread has already
     <span>
      been created.
     </span>
    </p>
    <p class="calibre3">
     Then, when the calculation
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker552">
     </a>
     has
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker553">
     </a>
     been completed, we emit the
     <strong class="source-inline">
      showResult
     </strong>
     and
     <strong class="source-inline">
      doneProcess
     </strong>
     signals to inform the thread to quit, while passing the final result to the main thread for it to
     <span>
      be printed.
     </span>
    </p>
    <p class="calibre3">
     Lastly, we also use the signals and slots mechanism to safely delete both the working thread and working object when everything
     <span>
      is done.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-179">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor179">
     </a>
     Data protection and sharing data between threads
    </h1>
    <p class="calibre3">
     Even though
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker554">
     </a>
     multithreading
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker555">
     </a>
     makes processes run
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker556">
     </a>
     asynchronously, there will be times when threads must stop and wait for other threads. This usually happens when both threads modify the same variable simultaneously. It is common to force threads to wait for one another to protect shared resources, such as data. Qt 6 also provides both low-level methods and high-level mechanisms to
     <span>
      synchronize threads.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-180">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor180">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     We will continue to use the code from the previous example project, since we have already established a working program
     <span>
      with multithreading:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       myworker.h
      </strong>
      and add the
      <span>
       following header:
      </span>
      <pre class="source-code">
#include &lt;QObject&gt;
#include &lt;QDebug&gt;
<strong class="bold1">#include &lt;QMutex&gt;</strong></pre>
     </li>
     <li class="calibre14">
      Then, we will add two new variables and make some changes to the
      <span>
       class constructor:
      </span>
      <pre class="source-code">
public:
    explicit MyWorker<strong class="bold1">(QMutex *mutex);</strong>
    <strong class="bold1">int* myInputNumber;</strong>
    <strong class="bold1">QMutex* myMutex;</strong>
signals:
    void showResults(int res);
    void doneProcess();</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       myworker.cpp
      </strong>
      and change the class constructor to look like the following code. We no longer require the parent input, since the object will not have
      <span>
       a parent:
      </span>
      <pre class="source-code">
MyWorker::MyWorker<strong class="bold1">(QMutex *mutex)</strong> {
    <strong class="bold1">myMutex = mutex;</strong>
}</pre>
     </li>
     <li class="calibre14">
      We will also change the
      <strong class="source-inline1">
       process()
      </strong>
      function to look
      <span>
       like this:
      </span>
      <pre class="source-code">
void MyWorker::process() {
    myMutex-&gt;lock();
    for (int i = 1; i &lt; 100000; ++i){
    *myInputNumber += i * i + 2 * i + 3 * i;
    }
    myMutex-&gt;unlock();
    emit showResults(*myInputNumber);
    emit doneProcess();
}</pre>
     </li>
     <li class="calibre14">
      Once you’re
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker557">
      </a>
      done, open
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker558">
      </a>
      up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and make some changes to
      <span>
       the code:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
    ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    int myNumber = 5;
    QMutex* newMutex = new QMutex;
    QThread* workerThread = new QThread;
    QThread* workerThread2 = new QThread;
    QThread* workerThread3 = new QThread;
    MyWorker *workerObject = new MyWorker(newMutex);
    MyWorker *workerObject2 = new MyWorker(newMutex);
    MyWorker *workerObject3 = new MyWorker(newMutex);</pre>
     </li>
     <li class="calibre14">
      After that, we will set the
      <strong class="source-inline1">
       myInputNumber
      </strong>
      variable of the worker object to
      <strong class="source-inline1">
       myNumber
      </strong>
      . Note that we are referencing its pointer instead of
      <span>
       the value:
      </span>
      <pre class="source-code">
    workerObject-&gt;myInputNumber = &amp;myNumber;
    workerObject-&gt;moveToThread(workerThread);
    connect(workerThread, &amp;QThread::started, workerObject, &amp;MyWorker::process);
    connect(workerObject, &amp;MyWorker::doneProcess, workerThread, &amp;QThread::quit);
    connect(workerObject, &amp;MyWorker::doneProcess, workerObject, &amp;MyWorker::deleteLater);
    connect(workerObject, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread, &amp;QThread::finished, workerObject, &amp;MyWorker::deleteLater);</pre>
     </li>
     <li class="calibre14">
      Repeat the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker559">
      </a>
      previous
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker560">
      </a>
      step twice more to set
      <strong class="source-inline1">
       workerObject2
      </strong>
      ,
      <strong class="source-inline1">
       workerThread2
      </strong>
      ,
      <strong class="source-inline1">
       workerObject3
      </strong>
      ,
      <span>
       and
      </span>
      <span>
       <strong class="source-inline1">
        workerThread3
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    workerObject2-&gt;myInputNumber = &amp;myNumber;
    workerObject2-&gt;moveToThread(workerThread2);
    connect(workerThread2, &amp;QThread::started, workerObject2, &amp;MyWorker::process);
    connect(workerObject2, &amp;MyWorker::doneProcess, workerThread2, &amp;QThread::quit);
    connect(workerObject2, &amp;MyWorker::doneProcess, workerObject2, &amp;MyWorker::deleteLater);
    connect(workerObject2, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread2, &amp;QThread::finished, workerObject2, &amp;MyWorker::deleteLater);
    workerObject3-&gt;myInputNumber = &amp;myNumber;
    workerObject3-&gt;moveToThread(workerThread3);
    connect(workerThread3, &amp;QThread::started, workerObject3, &amp;MyWorker::process);
    connect(workerObject3, &amp;MyWorker::doneProcess, workerThread3, &amp;QThread::quit);
    connect(workerObject3, &amp;MyWorker::doneProcess, workerObject3, &amp;MyWorker::deleteLater);
    connect(workerObject3, &amp;MyWorker::showResults, this, &amp;MainWindow::handleResults);
    connect(workerThread3, &amp;QThread::finished, workerObject3, &amp;MyWorker::deleteLater);</pre>
     </li>
     <li class="calibre14">
      Finally, we will start running those threads by
      <span>
       calling
      </span>
      <span>
       <strong class="source-inline1">
        start()
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    workerThread-&gt;start();
    workerThread2-&gt;start();
    workerThread3-&gt;start();</pre>
     </li>
     <li class="calibre14">
      If you build and run the program now, you should see a consistent result, no matter how
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker561">
      </a>
      many
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker562">
      </a>
      times you
      <span>
       run it:
      </span>
      <pre class="source-code">
Final result: -553579035
Final result: -1107158075
Final result: -1660737115</pre>
     </li>
     <li class="calibre14">
      We get results every time we run the program because the mutex lock ensures that only one of the threads can modify the data while other threads await their completion. To see the difference without mutex locking, let’s comment out
      <span>
       the code:
      </span>
      <pre class="source-code">
void MyWorker::process() {
    <strong class="bold1">//myMutex-&gt;lock();</strong>
    for (int i = 1; i &lt; 100000; ++i) {
        *myInputNumber += i * i + 2 * i + 3 * i;
        }
    <strong class="bold1">//myMutex-&gt;unlock();</strong>
    emit showResults(*myInputNumber);
    emit doneProcess();
}</pre>
     </li>
     <li class="calibre14">
      Build and run the program again. This time, you will get a very different result when you run the program. For example, I’ve obtained the following results when running it
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker563">
      </a>
      on
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker564">
      </a>
      <span>
       three occasions:
      </span>
      <pre class="source-code">
1st time:
Final result: -589341102
Final result: 403417142
Final result: -978935318
2nd time:
Final result: 699389030
Final result: -175723048
Final result: 1293365532
3rd time:
Final result: 1072831160
Final result: 472989964
Final result: -534842088</pre>
     </li>
     <li class="calibre14">
      This happens because the
      <strong class="source-inline1">
       myNumber
      </strong>
      data is manipulated by all the threads simultaneously in a random order, due to the nature of parallel computation. By locking the mutex, we make sure that the data can only be modified by a single thread and, hence, eliminate
      <span>
       this issue.
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-181">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor181">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     Qt 6 provides two classes, namely
     <strong class="source-inline">
      QMutex
     </strong>
     and
     <strong class="source-inline">
      QReadWriteLock
     </strong>
     , for data protection when multiple threads access and modify the same data. We only used
     <strong class="source-inline">
      QMutex
     </strong>
     in the previous example, but both classes are very similar in nature. The only difference is that
     <strong class="source-inline">
      QReadWriteLock
     </strong>
     allows data to be read simultaneously by other threads while the data is written. Unlike
     <strong class="source-inline">
      QMutex
     </strong>
     , it separates the read and write states, but only one can occur at a time (either lock for read or lock for write), and not both. For complex functions and statements, use the high-level
     <strong class="source-inline">
      QMutexLocker
     </strong>
     class instead of
     <strong class="source-inline">
      QMutex
     </strong>
     for simplifying the code and
     <span>
      easier debugging.
     </span>
    </p>
    <p class="calibre3">
     The downside of this method is that all of the other threads will stand idle while the data is modified by a single thread. It is best not to share data with multiple threads unless there is no other
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker565">
     </a>
     way
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker566">
     </a>
     to do so, as it will halt the other threads and defeat the object of
     <span>
      parallel computation.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-182">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor182">
     </a>
     Working with QRunnable processes
    </h1>
    <p class="calibre3">
     In this recipe, we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker567">
     </a>
     will learn how to use another type of high-level method to easily create a multithreading Qt 6 application. We will use the
     <strong class="source-inline">
      QRunnable
     </strong>
     and
     <strong class="source-inline">
      QThreadPool
     </strong>
     classes in
     <span>
      this recipe.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-183">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor183">
     </a>
     How to do it…
    </h2>
    <ol class="calibre13">
     <li class="calibre14">
      Create a new Qt widget application project and then a new C++ class called
      <strong class="source-inline1">
       MyProcess
      </strong>
      , which inherits the
      <span>
       <strong class="source-inline1">
        QRunnable
       </strong>
      </span>
      <span>
       class.
      </span>
     </li>
     <li class="calibre14">
      Next, open up
      <strong class="source-inline1">
       myprocess.h
      </strong>
      and add the
      <span>
       following headers:
      </span>
      <pre class="source-code">
#include &lt;QRunnable&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li class="calibre14">
      Then, declare the
      <strong class="source-inline1">
       run()
      </strong>
      function,
      <span>
       as follows:
      </span>
      <pre class="source-code">
class MyProcess : public QRunnable {
    public:
            MyProcess();
            <strong class="bold1">void run();</strong>
};</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       myprocess.cpp
      </strong>
      and define the
      <span>
       <strong class="source-inline1">
        run()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void MyProcess::run() {
    int myNumber = 0;
    for (int i = 0; i &lt; 100000000; ++i) {
    myNumber += i;
    }
    qDebug() &lt;&lt; myNumber;
}</pre>
     </li>
     <li class="calibre14">
      Once you’re done, add the following headers
      <span>
       to
      </span>
      <span>
       <strong class="source-inline1">
        mainwindow.h
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
#include &lt;QMainWindow&gt;
<strong class="bold1">#include &lt;QThreadPool&gt;</strong>
<strong class="bold1">#include "myprocess.h"</strong></pre>
     </li>
     <li class="calibre14">
      After that, we will
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker568">
      </a>
      implement the class constructor by adding the
      <span>
       following code:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
    ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    MyProcess* process = new MyProcess;
    MyProcess* process2 = new MyProcess;
    MyProcess* process3 = new MyProcess;
    MyProcess* process4 = new MyProcess;
    QThreadPool::globalInstance()-&gt;start(process);
    QThreadPool::globalInstance()-&gt;start(process2);
    QThreadPool::globalInstance()-&gt;start(process3);
    QThreadPool::globalInstance()-&gt;start(process4);
    qDebug() &lt;&lt; QThreadPool::globalInstance()-       &gt;activeThreadCount();
}</pre>
     </li>
     <li class="calibre14">
      Now, build and run the project. You should see that the processes are successfully run in different threads where the active thread count
      <span>
       is four.
      </span>
     </li>
     <li class="calibre14">
      The
      <strong class="source-inline1">
       QThreadPool
      </strong>
      class automatically deactivates threads when its last process has been executed. Let’s try and prove that by pausing the program for three seconds and printing out the active thread
      <span>
       count again:
      </span>
      <pre class="source-code">
    qDebug() &lt;&lt; QThreadPool::globalInstance()-&gt;activeThreadCount();
    <strong class="bold1">this-&gt;thread()-&gt;sleep(3);</strong>
    <strong class="bold1">qDebug() &lt;&lt; QThreadPool::globalInstance()-&gt;activeThreadCount();</strong></pre>
     </li>
     <li class="calibre14">
      Build and run the program again. This time, you should see that the active thread count is
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker569">
      </a>
      four, and then, after three seconds, the active thread count becomes zero. This is because all of the processes have
      <span>
       been executed.
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-184">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor184">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The
     <strong class="source-inline">
      QRunnable
     </strong>
     class works hand in hand with the
     <strong class="source-inline">
      QThreadPool
     </strong>
     class, which manages a collection of threads. The
     <strong class="source-inline">
      QThreadPool
     </strong>
     class automatically manages and recycles individual
     <strong class="source-inline">
      QThreads
     </strong>
     objects to avoid creating and destroying threads too frequently, which helps in reducing
     <span>
      computing costs.
     </span>
    </p>
    <p class="calibre3">
     To use
     <strong class="source-inline">
      QThreadPool
     </strong>
     , you must sub-class the
     <strong class="source-inline">
      QRunnable
     </strong>
     object and implement the virtual function called
     <strong class="source-inline">
      run()
     </strong>
     . By default,
     <strong class="source-inline">
      QThreadPool
     </strong>
     will automatically delete the
     <strong class="source-inline">
      QRunnable
     </strong>
     object when the last thread exits the
     <strong class="source-inline">
      run
     </strong>
     function. You can change this behavior by calling
     <strong class="source-inline">
      setAutoDelete()
     </strong>
     to change the
     <strong class="source-inline">
      autoDelete
     </strong>
     variable
     <span>
      to
     </span>
     <span>
      <strong class="source-inline">
       false
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     By default, threads that are unused for more than 30 seconds will expire. You can change this duration by calling
     <strong class="source-inline">
      setExpiryTimeout()
     </strong>
     before the thread runs. Otherwise, there will be no effect on the
     <span>
      timeout setting.
     </span>
    </p>
    <p class="calibre3">
     You can also set the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker570">
     </a>
     maximum number of threads that can be used by calling
     <strong class="source-inline">
      setMaxThreadCount()
     </strong>
     . To get the total number of currently active threads, simply
     <span>
      call
     </span>
     <span>
      <strong class="source-inline">
       activeThreadCount()
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
