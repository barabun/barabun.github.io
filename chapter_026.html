<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   15Overloading C++ Operators
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_025.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_027.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c15_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c15_1">
      <span aria-label="577" epub:type="pagebreak" id="Page_577" role="doc-pagebreak">
      </span>
      <span id="c15">
      </span>
      <span class="chapterNumber">
       15
      </span>
      <br/>
      <span class="chapterTitle">
       Overloading C++ Operators
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c15-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c15-list-0001">
         <li id="c15-li-0001">
          What operator overloading is
         </li>
         <li id="c15-li-0002">
          Rationale for overloading operators
         </li>
         <li id="c15-li-0003">
          Limitations, caveats, and choices in operator overloading
         </li>
         <li id="c15-li-0004">
          Summary of operators you can, cannot, and should not overload
         </li>
         <li id="c15-li-0005">
          How to overload unary plus, unary minus, increment, and decrement
         </li>
         <li id="c15-li-0006">
          How to overload the I/O stream operators (
          <code>
           operator&lt;&lt;
          </code>
          and
          <code>
           operator&gt;&gt;
          </code>
          )
         </li>
         <li id="c15-li-0007">
          How to overload the subscripting (array index) operator
         </li>
         <li id="c15-li-0008">
          How to write multidimensional subscripting operators
         </li>
         <li id="c15-li-0009">
          How to overload the function call operator
         </li>
         <li id="c15-li-0010">
          How to overload the dereferencing operators (
          <code>
           *
          </code>
          and
          <code>
           -&gt;
          </code>
          )
         </li>
         <li id="c15-li-0011">
          How to write conversion operators
         </li>
         <li id="c15-li-0012">
          How to overload the memory allocation and deallocation operators
         </li>
         <li id="c15-li-0013">
          How to define your own user-defined literal operators
         </li>
         <li id="c15-li-0014">
          The available standard literal operators
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3 id="head-2-171">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span id="c15-sec-0003">
        </span>
        <p id="c15-para-0004">
         Please note that all the code examples for this chapter are available as part of the chapter's code download on this book's website at
         <code>
          <code>
           <a href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c15-para-0005">
      <span aria-label="578" epub:type="pagebreak" id="Page_578" role="doc-pagebreak">
      </span>
      C++ allows you to redefine the meanings of operators, such as
      <code>
       +
      </code>
      ,
      <code>
       -
      </code>
      , and
      <code>
       =
      </code>
      , for your classes. Many object-oriented languages do not provide this capability, so you might be tempted to disregard its usefulness in C++. However, it is instrumental for making your classes behave similarly to built-in types such as
      <code>
       int
      </code>
      s and
      <code>
       double
      </code>
      s. It is even possible to write classes that look like arrays, functions, or pointers.
     </p>
     <p id="c15-para-0006">
      <a href="c05.xhtml">
       Chapter 5
      </a>
      , “Designing with Classes,” and
      <a href="c06.xhtml">
       Chapter 6
      </a>
      , “Designing for Reuse,” introduce object-oriented design and operator overloading, respectively.
      <a href="c08.xhtml">
       Chapter 8
      </a>
      , “Gaining Proficiency with Classes and Objects,” and
      <a href="c09.xhtml">
       Chapter 9
      </a>
      , “Mastering Classes and Objects,” present the syntax details for objects and for basic operator overloading. This chapter picks up operator overloading where
      <a href="c09.xhtml">
       Chapter 9
      </a>
      left off.
     </p>
    </section>
    <section aria-labelledby="head-2-172">
     <span id="c15-sec-0004">
     </span>
     <h2 id="head-2-172">
      OVERVIEW OF OPERATOR OVERLOADING
     </h2>
     <p id="c15-para-0007">
      As
      <a href="c01.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library,” explains, operators in C++ are symbols such as
      <code>
       +
      </code>
      ,
      <code>
       &lt;
      </code>
      ,
      <code>
       *
      </code>
      , and
      <code>
       &lt;&lt;
      </code>
      . They work on built-in types such as
      <code>
       int
      </code>
      and
      <code>
       double
      </code>
      to allow you to perform arithmetic, logical, and other operations. There are also operators such as
      <code>
       -&gt;
      </code>
      and
      <code>
       *
      </code>
      that allow you to dereference pointers. The concept of operators in C++ is broad, and even includes
      <code>
       []
      </code>
      (array index),
      <code>
       ()
      </code>
      (function call), casting, and the memory allocation and deallocation operators. Operator overloading allows you to change the behavior of language operators for your classes. However, this capability comes with rules, limitations, and choices.
     </p>
     <section>
      <span id="c15-sec-0005">
      </span>
      <h3 id="head-3-327">
       Why Overload Operators?
      </h3>
      <p id="c15-para-0008">
       Before learning how to overload operators, you probably want to know why you would ever want to do so. The reasons vary for the different operators, but the general guiding principle is to make your classes behave like built-in types. The closer your classes are to built-in types, the easier they will be for clients to use. For example, if you want to write a class to represent fractions, it's quite helpful to have the ability to define what
       <code>
        +
       </code>
       ,
       <code>
        -
       </code>
       ,
       <code>
        *
       </code>
       , and
       <code>
        /
       </code>
       mean when applied to objects of that class.
      </p>
      <p id="c15-para-0009">
       Another reason to overload operators is to gain greater control over the behavior in your program. For example, you can overload memory allocation and deallocation operators for your classes to specify exactly how memory should be distributed and reclaimed for each new object.
      </p>
      <p id="c15-para-0010">
       It's important to emphasize that operator overloading doesn't necessarily make things easier for you as the class developer; its main purpose is to make things easier for users of the class.
      </p>
     </section>
     <section>
      <span id="c15-sec-0006">
      </span>
      <h3 id="head-3-328">
       Limitations to Operator Overloading
      </h3>
      <p>
       Here is a list of things you cannot do when you overload operators:
      </p>
      <ul class="check1" id="c15-list-0002">
       <li id="c15-li-0015">
        You cannot add new operator symbols. You can only redefine the meanings of operators already in the language. The table in the section “
        <a href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        ” later in this chapter lists all of the operators that you can overload.
       </li>
       <li id="c15-li-0016">
        There are a few operators that you cannot overload, such as
        <code>
         .
        </code>
        and
        <code>
         .*
        </code>
        (member access in an object),
        <code>
         ::
        </code>
        (scope resolution operator), and
        <code>
         ?:
        </code>
        (the conditional operator). The table lists all the operators that you
        <i>
         can
        </i>
        overload. The operators that you can't overload are usually not those you would care to overload anyway, so you shouldn't find this restriction limiting.
       </li>
       <li id="c15-li-0017">
        <span aria-label="579" epub:type="pagebreak" id="Page_579" role="doc-pagebreak">
        </span>
        The
        <i>
         arity
        </i>
        describes the number of arguments, or
        <i>
         operands
        </i>
        , associated with the operator. You can change the arity only for the function call, new, and delete operators, and, since C++23, also for the subscripting operator (array index),
        <code>
         []
        </code>
        . For all other operators, you cannot change the arity. Unary operators, such as
        <code>
         ++
        </code>
        , work on only one operand. Binary operators, such as
        <code>
         /
        </code>
        , work on two operands.
       </li>
       <li id="c15-li-0018">
        You cannot change the
        <i>
         precedence
        </i>
        nor the
        <i>
         associativity
        </i>
        of an operator. The precedence is used to decide which operators need to be executed before other operators, while the associativity can be either left-to-right or right-to-left and specifies in which order operators of the same precedence are executed. Again, this constraint shouldn't be cause for concern in most programs because there are rarely benefits to changing the order of evaluation, but, in certain domains, it's something to keep in mind. For example, if you are writing a class to represent mathematical vectors and would like to overload the
        <code>
         ^
        </code>
        operator to be able to raise a vector to a certain power, then keep in mind that
        <code>
         ^
        </code>
        has lower precedence compared to many other operators such as
        <code>
         +
        </code>
        . For instance, suppose
        <code>
         x
        </code>
        and
        <code>
         y
        </code>
        are mathematical vectors, writing
        <code>
         x^3+y
        </code>
        will be evaluated as
        <code>
         x^(3+y)
        </code>
        and not as
        <code>
         (x^3)+y
        </code>
        as you probably intended.
       </li>
       <li id="c15-li-0019">
        You cannot redefine operators for built-in types. The operator must be a member function in a class, or at least one of the arguments to a global overloaded operator function must be a user-defined type (for example, a class). This means that you can't do something ridiculous, such as redefine
        <code>
         +
        </code>
        for
        <code>
         int
        </code>
        s to mean subtraction (though you could do so for your own classes). The one exception to this rule is the memory allocation and deallocation operators; you can replace the global operators for all memory allocations in your program.
       </li>
      </ul>
      <p id="c15-para-0012">
       Some of the operators already mean two different things. For example,
       <code>
        operator-
       </code>
       can be used as a binary operator (as in
       <code>
        x=y-z;
       </code>
       ) or as a unary operator (as in
       <code>
        x=-y;
       </code>
       ). The
       <code>
        *
       </code>
       operator can be used for multiplication or for dereferencing a pointer. The &lt;&lt; operator is the stream insertion operator or the left-shift operator, depending on the context. For such dual-meaning operators, you can overload both meanings.
      </p>
     </section>
     <section>
      <span id="c15-sec-0007">
      </span>
      <h3 id="head-3-329">
       Choices in Operator Overloading
      </h3>
      <p>
       When you overload an operator, you write a global function or member function with the name
       <code>
        operatorX
       </code>
       , where
       <code>
        X
       </code>
       is the symbol for some operator, and with optional whitespace between
       <code>
        operator
       </code>
       and
       <code>
        X
       </code>
       . For example,
       <a href="c09.xhtml">
        Chapter 9
       </a>
       declares
       <code>
        operator+
       </code>
       for
       <code>
        SpreadsheetCell
       </code>
       objects like this:
      </p>
      <pre id="c15-code-0001"><code>SpreadsheetCell operator+(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs);</code></pre>
      <p id="c15-para-0014">
       The following sections describe several choices involved in each overloaded operator you write.
      </p>
      <section>
       <span id="c15-sec-0008">
       </span>
       <h4 id="head-4-245">
        Member Function or Global Function
       </h4>
       <p id="c15-para-0015">
        First, you must decide whether your operator should be a member function of your class or a global function. The latter can be a
        <code>
         friend
        </code>
        of the class, although that should be a last resort — adding
        <code>
         friend
        </code>
        s to a class should be limited as much as possible, as they can access
        <code>
         private
        </code>
        data members directly and thus circumvent the data-hiding principle.
       </p>
       <p id="c15-para-0016">
        How do you choose between a member function or a global function? First, you need to understand the difference between these two choices. When the operator is a member function of a class, the
        <span aria-label="580" epub:type="pagebreak" id="Page_580" role="doc-pagebreak">
        </span>
        left-hand side of the operator expression must always be an object of that class. If you write a global function, the left-hand side can be an object of a different type.
       </p>
       <p>
        There are three different types of operators:
       </p>
       <ul class="check1" id="c15-list-0003">
        <li id="c15-li-0020">
         <b>
          Operators that must be member functions.
         </b>
         The C++ language requires some operators to be member functions of a class because they don't make sense outside of a class. For example,
         <code>
          operator=
         </code>
         is tied so closely to the class that it can't exist anywhere else. The table in the section “
         <a href="#c15-sec-0013">
          Summary of Overloadable Operators
         </a>
         ” lists those operators that must be member functions. Most operators do not impose this requirement.
        </li>
        <li id="c15-li-0021">
         <b>
          Operators that must be global functions.
         </b>
         Whenever you need to allow the left-hand side of the operator to be a variable of a different type than your class, you must make the operator a global function. This rule applies specifically to the
         <code>
          &lt;&lt;
         </code>
         and
         <code>
          &gt;&gt;
         </code>
         insertion and extraction streaming operators, where the left-hand side is an
         <code>
          iostream
         </code>
         object, not an object of your class. It also applies to commutative operators like binary
         <code>
          +
         </code>
         and
         <code>
          –
         </code>
         , which should allow variables that are not objects of your class on the left-hand side. A global function is required if implicit conversions are desired for the left operand of a binary operator.
         <a href="c09.xhtml">
          Chapter 9
         </a>
         discusses this problem.
        </li>
        <li id="c15-li-0022">
         <b>
          Operators that can be either member functions or global functions.
         </b>
         There is some disagreement in the C++ community on whether it's better to write member functions or global functions to overload operators. However, I recommend the following rule: make every operator a member function unless you must make it a global function, as described previously. One major advantage to this rule is that member functions can be
         <code>
          virtual
         </code>
         , while global functions obviously cannot. Therefore, when you plan to write overloaded operators in an inheritance tree, you should make them member functions if possible.
        </li>
       </ul>
       <p id="c15-para-0018">
        When you write an overloaded operator as a member function, you should mark it
        <code>
         const
        </code>
        if it doesn't change the object. That way, it can be called on
        <code>
         const
        </code>
        objects.
       </p>
       <p id="c15-para-0019">
        When you write an overloaded operator as a global function, put it in the same namespace that contains the class for which the operator is written.
       </p>
      </section>
      <section>
       <span id="c15-sec-0009">
       </span>
       <h4 id="head-4-246">
        Choosing Argument Types
       </h4>
       <p id="c15-para-0020">
        You are somewhat limited in your choice of argument types because, as stated earlier, for most operators you cannot change the number of arguments. For example,
        <code>
         operator/
        </code>
        must always have two arguments if it is a global function, and one argument if it's a member function. The compiler issues an error if it differs from this standard. In this sense, the operator functions are different from normal functions, which you can overload with any number of parameters. Additionally, although you can write the operator for whichever types you want, the choice is usually constrained by the class for which you are writing the operator. For example, if you want to implement addition for class
        <code>
         T
        </code>
        , you don't write an
        <code>
         operator+
        </code>
        that takes two
        <code>
         string
        </code>
        s! The real choice arises when you try to determine whether to take parameters by value or by reference and whether to make them
        <code>
         const
        </code>
        .
       </p>
       <p id="c15-para-0021">
        The choice of value versus reference is easy: you should take every non-primitive parameter type by reference, unless the function always makes a copy of the passed object, see
        <a href="c09.xhtml">
         Chapter 9
        </a>
        .
       </p>
       <p id="c15-para-0022">
        <span aria-label="581" epub:type="pagebreak" id="Page_581" role="doc-pagebreak">
        </span>
        The
        <code>
         const
        </code>
        decision is also trivial: mark every parameter
        <code>
         const
        </code>
        unless you actually modify it. The table in the section “
        <a href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        ” shows sample prototypes for each operator, with the arguments marked
        <code>
         const
        </code>
        and reference as appropriate.
       </p>
      </section>
      <section>
       <span id="c15-sec-0010">
       </span>
       <h4 id="head-4-247">
        Choosing Return Types
       </h4>
       <p id="c15-para-0023">
        C++ doesn't determine overload resolution based on return type. Thus, you can specify any return type you want when you write overloaded operators. However, just because you
        <i>
         can
        </i>
        do something doesn't mean you
        <i>
         should
        </i>
        do it. This flexibility implies that you could write confusing code in which comparison operators return pointers, and arithmetic operators return
        <code>
         bool
        </code>
        s. However, you shouldn't do that. Instead, you should write your overloaded operators such that they return the same types as the operators do for the built-in types. If you write a comparison operator, return a
        <code>
         bool
        </code>
        . If you write an arithmetic operator, return an object representing the result. Sometimes the return type is not obvious at first. For example, as
        <a href="c08.xhtml">
         Chapter 8
        </a>
        mentions,
        <code>
         operator=
        </code>
        should return a reference to the object on which it's called in order to support chained assignments. Other operators have similarly tricky return types, all of which are summarized in the table in the section “
        <a href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        .”
       </p>
       <p id="c15-para-0024">
        The same choices of reference and
        <code>
         const
        </code>
        apply to return types as well. However, for return values, the choices are more difficult. The general rule for value or reference is to return a reference if you can; otherwise, return a value. How do you know when you can return a reference? This choice applies only to operators that return objects: the choice is moot for the comparison operators that return
        <code>
         bool
        </code>
        , the conversion operators that have no return type, and the function call operator, which may return any type you want. If your operator constructs a new object, then you must return that new object by value. If it does not construct a new object, you can return a reference to the object on which the operator is called, or one of its arguments. The table in the section “
        <a href="#c15-sec-0013">
         Summary of Overloadable Operators
        </a>
        ” shows examples.
       </p>
       <p id="c15-para-0025">
        A return value that can be modified as an
        <i>
         lvalue
        </i>
        (e.g., on the left-hand side of an assignment expression) must be non-
        <code>
         const
        </code>
        . Otherwise, it should be
        <code>
         const
        </code>
        . More operators than you might expect require that you return lvalues, including all of the assignment operators (
        <code>
         operator=
        </code>
        ,
        <code>
         operator+=
        </code>
        ,
        <code>
         operator-=
        </code>
        , and so on).
       </p>
      </section>
      <section>
       <span id="c15-sec-0011">
       </span>
       <h4 id="head-4-248">
        Choosing Behavior
       </h4>
       <p id="c15-para-0026">
        You can provide whichever implementation you want in an overloaded operator. For example, you could write an
        <code>
         operator+
        </code>
        that launches a game of Scrabble. However, as
        <a href="c06.xhtml">
         Chapter 6
        </a>
        describes, you should generally constrain your implementations to provide behaviors that clients expect. Write
        <code>
         operator+
        </code>
        so that it performs addition, or something like addition, such as string concatenation. This chapter explains how you
        <i>
         should
        </i>
        implement your overloaded operators. In exceptional circumstances, you might want to differ from these recommendations; but, in general, you should follow the standard patterns.
       </p>
      </section>
     </section>
     <section>
      <span id="c15-sec-0012">
      </span>
      <h3 id="head-3-330">
       Operators You Shouldn't Overload
      </h3>
      <p id="c15-para-0027">
       Some operators should not be overloaded, even though it is permitted. Specifically, the address-of operator (
       <code>
        operator&amp;
       </code>
       ) is not particularly useful to overload and leads to confusion if you do because
       <span aria-label="582" epub:type="pagebreak" id="Page_582" role="doc-pagebreak">
       </span>
       <span aria-label="583" epub:type="pagebreak" id="Page_583" role="doc-pagebreak">
       </span>
       you are changing fundamental language behavior (taking addresses of variables) in potentially unexpected ways. The entire Standard Library, which uses operator overloading extensively, never overloads the address-of operator.
      </p>
      <p id="c15-para-0028">
       Additionally, you should avoid overloading the binary Boolean operators
       <code>
        operator&amp;&amp;
       </code>
       and
       <code>
        ||
       </code>
       because you lose C++'s short-circuit evaluation rules. Short-circuiting is not possible in that case because all operands need to be evaluated before they can be passed to your overloaded operator function. If your class needs logical operators, provide
       <code>
        operator&amp;
       </code>
       and
       <code>
        |
       </code>
       instead.
      </p>
      <p>
       Finally, you should not overload the comma operator (
       <code>
        operator,
       </code>
       ). Yes, you read that correctly: there really is a comma operator in C++. It's also called the
       <i>
        sequencing operator
       </i>
       , and is used to separate two expressions in a single statement, while guaranteeing that they are evaluated left to right. The following snippet demonstrates the comma operator:
      </p>
      <pre id="c15-code-0002"><code>int x { 1 };</code>
<code>println("{}", (++x, 2 * x)); <span class="color3">// Increments x to 2, doubles it, and prints 4.</span></code></pre>
      <p id="c15-para-0030">
       There is rarely a good reason to overload the comma operator.
      </p>
     </section>
     <section>
      <span id="c15-sec-0013">
      </span>
      <span aria-label="584" epub:type="pagebreak" id="Page_584" role="doc-pagebreak">
      </span>
      <span aria-label="585" epub:type="pagebreak" id="Page_585" role="doc-pagebreak">
      </span>
      <h3 id="head-3-331">
       Summary of Overloadable Operators
      </h3>
      <p id="c15-para-0031">
       The following table lists the operators you can overload, specifies whether they should be member functions of the class or global functions, summarizes when you should (or should not) overload them, and provides sample prototypes showing the proper parameter and return value types. Operators that cannot be overloaded, such as
       <code>
        .
       </code>
       ,
       <code>
        .*
       </code>
       ,
       <code>
        ::
       </code>
       , and
       <code>
        ?:
       </code>
       are not in this list.
      </p>
      <p id="c15-para-0032">
       This table is a useful reference for the future when you want to write an overloaded operator. You're bound to forget which return type you should use and whether or not the function should be a member function.
      </p>
      <p id="c15-para-0033">
       In this table,
       <code>
        T
       </code>
       is the name of the class for which the overloaded operator is written, and
       <code>
        E
       </code>
       is a different type. The sample prototypes given are not exhaustive; often there are other combinations of
       <code>
        T
       </code>
       and
       <code>
        E
       </code>
       possible for a given operator:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          OPERATOR
         </th>
         <th class="left bgcolor2" scope="col">
          NAME OR CATEGORY
         </th>
         <th class="left bgcolor2" scope="col">
          MEMBER FUNCTION OR GLOBAL FUNCTION
         </th>
         <th class="left bgcolor2" scope="col">
          WHEN TO OVERLOAD
         </th>
         <th class="left bgcolor2" scope="col">
          SAMPLE PROTOTYPES
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator+
          </code>
          <br/>
          <code>
           operator-
          </code>
          <br/>
          <code>
           operator*
          </code>
          <br/>
          <code>
           operator/
          </code>
          <br/>
          <code>
           operator%
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Binary arithmetic
         </td>
         <td class="left bor1 bgcolor3">
          Global function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide these operations for your class
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T operator+(const T&amp;, const T&amp;);
          </code>
          <br/>
          <code>
           T operator+(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator-
          </code>
          <br/>
          <code>
           operator+
          </code>
          <br/>
          <code>
           operator˜
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Unary arithmetic and bitwise operators
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide these operations for your class
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T operator-() const;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator++
          </code>
          <br/>
          <code>
           operator--
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Pre-increment and pre-decrement
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you overload
          <code>
           +=
          </code>
          and
          <code>
           -=
          </code>
          taking an arithmetic argument (
          <code>
           int
          </code>
          ,
          <code>
           long
          </code>
          , …)
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T&amp; operator++();
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator++
          </code>
          <br/>
          <code>
           operator--
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Post-increment and post-decrement
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you overload
          <code>
           +=
          </code>
          and
          <code>
           -=
          </code>
          taking an arithmetic argument (
          <code>
           int
          </code>
          ,
          <code>
           long
          </code>
          , …)
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T operator++(int);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Assignment operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function required
         </td>
         <td class="left bor1 bgcolor3">
          Whenever your class has dynamically allocated resources, or members that are references
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T&amp; operator=(const T&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator+=
          </code>
          <br/>
          <code>
           operator-=
          </code>
          <br/>
          <code>
           operator*=
          </code>
          <br/>
          <code>
           operator/=
          </code>
          <br/>
          <code>
           operator%=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Shorthand / compound arithmetic assignment operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you overload the binary arithmetic operators and your class is not designed to be immutable
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T&amp; operator+=(const T&amp;);
          </code>
          <br/>
          <code>
           T&amp; operator+=(const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&lt;&lt;
          </code>
          <br/>
          <code>
           operator&gt;&gt;
          </code>
          <br/>
          <code>
           operator&amp;
          </code>
          <br/>
          <code>
           operator|
          </code>
          <br/>
          <code>
           operator^
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Binary bitwise operators
         </td>
         <td class="left bor1 bgcolor3">
          Global function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide these operations
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T operator&lt;&lt;(const T&amp;, const T&amp;);
          </code>
          <br/>
          <code>
           T operator&lt;&lt;(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&lt;&lt;=
          </code>
          <br/>
          <code>
           operator&gt;&gt;=
          </code>
          <br/>
          <code>
           operator&amp;=
          </code>
          <br/>
          <code>
           operator|=
          </code>
          <br/>
          <code>
           operator^=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Shorthand / compound bitwise assignment operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you overload the binary bitwise operators and your class is not designed to be immutable
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T&amp; operator&lt;&lt;=(const T&amp;);
          </code>
          <br/>
          <code>
           T&amp; operator&lt;&lt;=(const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&lt;=&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Three-way comparison operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide comparison support for your class; if possible, this should be defaulted using
          <code>
           =default
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           auto operator&lt;=&gt;(const T&amp;) const = default;
          </code>
          <br/>
          <code>
           partial_ordering operator&lt;=&gt;(const E&amp;) const;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator==
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Binary equality operator
         </td>
         <td class="left bor1 bgcolor3">
          Post-C++20: member function recommended
          <br/>
          Pre-C++20: global function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide comparison support for your class, and you cannot default the three-way comparison operator
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bool operator==(const T&amp;) const;
          </code>
          <br/>
          <code>
           bool operator==(const E&amp;) const;
          </code>
          <br/>
          <code>
           bool operator==(const T&amp;, const T&amp;);
          </code>
          <br/>
          <code>
           bool operator==(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator!=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Binary inequality operator
         </td>
         <td class="left bor1 bgcolor3">
          Post-C++20: member function recommended
          <br/>
          Pre-C++20: global function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Post-C++20: not needed as the compiler automatically provides
          <code>
           !=
          </code>
          when
          <code>
           ==
          </code>
          is supported
          <br/>
          Pre-C++20: Whenever you want to provide comparison support for your class
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bool operator!=(const T&amp;) const;
          </code>
          <br/>
          <code>
           bool operator!=(const E&amp;) const;
          </code>
          <br/>
          <code>
           bool operator!=(const T&amp;, const T&amp;);
          </code>
          <br/>
          <code>
           bool operator!=(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&lt;
          </code>
          <br/>
          <code>
           operator&gt;
          </code>
          <br/>
          <code>
           operator&lt;=
          </code>
          <br/>
          <code>
           operator&gt;=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Binary comparison operators
         </td>
         <td class="left bor1 bgcolor3">
          Global function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide these operations; not needed when
          <code>
           &lt;=&gt;
          </code>
          is provided
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bool operator&lt;(const T&amp;, const T&amp;);
          </code>
          <br/>
          <code>
           bool operator&lt;(const T&amp;, const E&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&lt;&lt;
          </code>
          <br/>
          <code>
           operator&gt;&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          I/O stream operators (insertion and extraction)
         </td>
         <td class="left bor1 bgcolor3">
          Global function required
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you want to provide these operations
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ostream&amp; operator&lt;&lt;(ostream&amp;, const T&amp;);
          </code>
          <br/>
          <code>
           istream&amp; operator&gt;&gt;(istream&amp;, T&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator!
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Boolean negation operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Rarely; use
          <code>
           bool
          </code>
          or
          <code>
           void*
          </code>
          conversion instead
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bool operator!() const;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&amp;&amp;
          </code>
          <br/>
          <code>
           operator||
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Binary Boolean operators
         </td>
         <td class="left bor1 bgcolor3">
          Global function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Rarely, if ever, because you lose short-circuiting; it's better to overload
          <code>
           &amp;
          </code>
          and
          <code>
           |
          </code>
          instead, as these never short-circuit
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bool operator&amp;&amp;(const T&amp;, const T&amp;);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator[]
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Subscripting (array index) operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function required
         </td>
         <td class="left bor1 bgcolor3">
          When you want to support subscripting
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           E&amp; operator[](size_t);
           <br/>
           const E&amp; operator[](size_t) const;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Function call operator
         </td>
         <td class="left bor1 bgcolor3">
          Member function required
         </td>
         <td class="left bor1 bgcolor3">
          When you want objects to behave like function pointers
         </td>
         <td class="left bor1 bgcolor3">
          Return type and parameters can vary; see later examples in this chapter
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator type()
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Conversion, or cast, operators (separate operator for each type)
         </td>
         <td class="left bor1 bgcolor3">
          Member function required
         </td>
         <td class="left bor1 bgcolor3">
          When you want to provide conversions from your class to other types
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           operator double() const;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator ""_
           <i>
            x
           </i>
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          User-defined literal operator
         </td>
         <td class="left bor1 bgcolor3">
          Global function required
         </td>
         <td class="left bor1 bgcolor3">
          When you want to support user-defined literals
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           T operator""_i(long double d);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator new
          </code>
          <br/>
          <code>
           operator new[]
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Memory allocation routines
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          When you want to control memory allocation for your classes (rarely)
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           void* operator new(size_t size);
          </code>
          <br/>
          <code>
           void* operator new[](size_t size);
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator delete
          </code>
          <br/>
          <code>
           operator delete[]
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Memory deallocation routines
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended
         </td>
         <td class="left bor1 bgcolor3">
          Whenever you overload the memory allocation routines (rarely)
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           void operator delete(void* ptr) noexcept;
          </code>
          <br/>
          <code>
           void operator delete[](void* ptr) noexcept;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator*
          </code>
          <br/>
          <code>
           operator-&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Dereferencing operators
         </td>
         <td class="left bor1 bgcolor3">
          Member function recommended for
          <code>
           operator*
          </code>
          <br/>
          Member function required for
          <code>
           operator-&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Useful for smart pointers
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           E&amp; operator*() const;
          </code>
          <br/>
          <code>
           E* operator-&gt;() const;
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator&amp;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Address-of operator
         </td>
         <td class="left bor1 bgcolor3">
          N/A
         </td>
         <td class="left bor1 bgcolor3">
          Never
         </td>
         <td class="left bor1 bgcolor3">
          N/A
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator-&gt;*
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Dereference pointer-to-member
         </td>
         <td class="left bor1 bgcolor3">
          N/A
         </td>
         <td class="left bor1 bgcolor3">
          Never
         </td>
         <td class="left bor1 bgcolor3">
          N/A
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           operator,
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Comma operator
         </td>
         <td class="left bor1 bgcolor3">
          N/A
         </td>
         <td class="left bor1 bgcolor3">
          Never
         </td>
         <td class="left bor1 bgcolor3">
          N/A
          <span aria-label="586" epub:type="pagebreak" id="Page_586" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
     </section>
     <section>
      <span id="c15-sec-0014">
      </span>
      <h3 id="head-3-332">
       Rvalue References
      </h3>
      <p>
       <a href="c09.xhtml">
        Chapter 9
       </a>
       discusses move semantics and rvalue references. It demonstrates these by defining move assignment operators, which are used by the compiler in cases where the source object is a temporary object that will be destroyed after the assignment, or an object that is explicitly moved from using
       <code>
        std::move()
       </code>
       . The normal assignment operator from the preceding table has the following prototype:
      </p>
      <pre id="c15-code-0003"><code>T&amp; operator=(const T&amp;);</code></pre>
      <p>
       The move assignment operator has almost the same prototype, but uses an rvalue reference. It modifies the argument so it cannot be passed as
       <code>
        const
       </code>
       . See
       <a href="c09.xhtml">
        Chapter 9
       </a>
       for details.
      </p>
      <pre id="c15-code-0004"><code>T&amp; operator=(T&amp;&amp;) noexcept;</code></pre>
      <p>
       <span aria-label="587" epub:type="pagebreak" id="Page_587" role="doc-pagebreak">
       </span>
       The preceding table does not include sample prototypes with rvalue references. However, for most operators it can make sense to write both a version using normal lvalue references and a version using rvalue references. Whether or not it does make sense depends on implementation details of your class. The
       <code>
        operator=
       </code>
       is one example from
       <a href="c09.xhtml">
        Chapter 9
       </a>
       . Another example is
       <code>
        operator+
       </code>
       to prevent unnecessary memory allocations. The
       <code>
        std::string
       </code>
       class from the Standard Library, for example, implements an
       <code>
        operator+
       </code>
       using rvalue references as follows (simplified):
      </p>
      <pre id="c15-code-0005"><code>string operator+(string&amp;&amp; lhs, string&amp;&amp; rhs);</code></pre>
      <p>
       The implementation of this operator reuses memory of one of the arguments because they are being passed as rvalue references, meaning both are temporary objects that will be destroyed when this
       <code>
        operator+
       </code>
       is finished. The implementation of this
       <code>
        operator+
       </code>
       has the following effect depending on the size and the capacity of both operands:
      </p>
      <pre id="c15-code-0006"><code>return move(lhs.append(rhs));</code></pre>
      <p>
       or
      </p>
      <pre id="c15-code-0007"><code>return move(rhs.insert(0, lhs));</code></pre>
      <p>
       In fact,
       <code>
        string
       </code>
       defines several
       <code>
        operator+
       </code>
       overloads accepting two
       <code>
        string
       </code>
       s as arguments and different combinations of lvalue and rvalue references. Here is a list (simplified):
      </p>
      <pre id="c15-code-0008"><code>string operator+(const string&amp; lhs, const string&amp; rhs); <span class="color3">// No memory reuse.</span></code>
<code>string operator+(string&amp;&amp; lhs, const string&amp; rhs); <span class="color3">// Can reuse memory of lhs.</span></code>
<code>string operator+(const string&amp; lhs, string&amp;&amp; rhs); <span class="color3">// Can reuse memory of rhs.</span></code>
<code>string operator+(string&amp;&amp; lhs, string&amp;&amp; rhs); <span class="color3">// Can reuse memory of lhs or rhs.</span></code></pre>
      <p id="c15-para-0119">
       Reusing memory of one of the rvalue reference arguments is implemented in the same way as it is explained for move assignment operators in
       <a href="c09.xhtml">
        Chapter 9
       </a>
       .
      </p>
     </section>
     <section>
      <span id="c15-sec-0015">
      </span>
      <h3 id="head-3-333">
       Precedence and Associativity
      </h3>
      <p id="c15-para-0120">
       In statements containing multiple operators, the
       <i>
        precedence
       </i>
       of the operators is used to decide which operators need to be executed before other operators. For example,
       <code>
        *
       </code>
       and
       <code>
        /
       </code>
       are always executed before
       <code>
        +
       </code>
       and
       <code>
        -
       </code>
       .
      </p>
      <p id="c15-para-0121">
       The
       <i>
        associativity
       </i>
       can be either left-to-right or right-to-left and specifies in which order operators of the same precedence are executed.
      </p>
      <p id="c15-para-0122">
       The following table lists the precedence and associativity of all available C++ operators, including those that you cannot overload and operators you haven't seen mentioned in this book yet. Operators with a lower precedence number are executed before operators with a higher precedence number. In the table,
       <code>
        T
       </code>
       represents a type, while
       <code>
        x
       </code>
       ,
       <code>
        y
       </code>
       , and
       <code>
        z
       </code>
       represent objects:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          PRECEDENCE
         </th>
         <th class="left bgcolor2" scope="col">
          OPERATOR
         </th>
         <th class="left bgcolor2" scope="col">
          ASSOCIATIVITY
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          1
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ::
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          2
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           x++ x-- x() x[] T() T{} . -&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          3
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ++x --x +x -x ! ˜ *x &amp;x (T)
          </code>
          <br/>
          <code>
           sizeof co_await new delete new[] delete[]
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Right-to-left
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          4
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           .* -&gt;*
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          5
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           x*y x/y x%y
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          6
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           x+y x-y
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          7
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           &lt;&lt; &gt;&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          8
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           &lt;=&gt;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          9
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           &lt; &lt;= &gt; &gt;=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          10
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           == !=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          11
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           x&amp;y
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          12
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ^
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          13
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           |
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          14
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           &amp;&amp;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          15
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ||
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          16
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           x?y:z throw co_yield
          </code>
          <br/>
          <code>
           = += -= *= /= %= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Right-to-left
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          17
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ,
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          Left-to-right
          <span aria-label="588" epub:type="pagebreak" id="Page_588" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
     </section>
     <section>
      <span id="c15-sec-0016">
      </span>
      <h3 id="head-3-334">
       Relational Operators
      </h3>
      <p>
       The following set of function templates for relational operators are defined in
       <code>
        &lt;utility&gt;
       </code>
       in the
       <code>
        std::rel_ops
       </code>
       namespace:
      </p>
      <pre id="c15-code-0009"><code>template&lt;class T&gt; bool operator!=(const T&amp; a, const T&amp; b);<span class="color3">// Needs operator==</span></code>
<code>template&lt;class T&gt; bool operator&gt;(const T&amp; a, const T&amp; b); <span class="color3">// Needs operator&lt;</span></code>
<code>template&lt;class T&gt; bool operator&lt;=(const T&amp; a, const T&amp; b);<span class="color3">// Needs operator&lt;</span></code>
<code>template&lt;class T&gt; bool operator&gt;=(const T&amp; a, const T&amp; b);<span class="color3">// Needs operator&lt;</span></code></pre>
      <p id="c15-para-0129">
       These function templates define the operators
       <code>
        !=
       </code>
       ,
       <code>
        &gt;
       </code>
       ,
       <code>
        &lt;=
       </code>
       , and
       <code>
        &gt;=
       </code>
       in terms of the
       <code>
        ==
       </code>
       and
       <code>
        &lt;
       </code>
       operators for any class. So, if you implement
       <code>
        operator==
       </code>
       and
       <code>
        &lt;
       </code>
       for your class, you get the other relational operators for free with these templates.
      </p>
      <p id="c15-para-0130">
       However, there are a lot of problems with this technique. A first problem is that those operators might be created for all classes that you use in relational operations, not only for your own class.
      </p>
      <p id="c15-para-0131">
       A second problem with this technique is that utility templates such as
       <code>
        std::greater&lt;T&gt;
       </code>
       (discussed in
       <a href="c19.xhtml">
        Chapter 19
       </a>
       , “Function Pointers, Function Objects, and Lambda Expressions”) do not work with those automatically generated relational operators.
      </p>
      <p id="c15-para-0132">
       Yet another problem with these is that implicit conversions won't work.
      </p>
      <p>
       <span aria-label="589" epub:type="pagebreak" id="Page_589" role="doc-pagebreak">
       </span>
       Finally, with C++20's three-way comparison operator and the fact that C++20 has deprecated the
       <code>
        std::rel_ops
       </code>
       namespace, there is no longer any reason to still use
       <code>
        rel_ops
       </code>
       .
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0134">
          <b>
           WARNING
          </b>
          <i>
           Never use
           <code>
            std::rel_ops
           </code>
           ; it has been deprecated since C++20! Instead, to add support for all six comparison operators to a class, just explicitly default or implement
          </i>
          <code>
           operator&lt;=&gt;
          </code>
          <i>
           and possibly
          </i>
          <code>
           operator==
          </code>
          <i>
           for the class. See
           <a href="c09.xhtml">
            Chapter 9
           </a>
           for details.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c15-sec-0018">
      </span>
      <h3 id="head-3-335">
       Alternative Notation
      </h3>
      <p id="c15-para-0135">
       C++ supports the following alternative notations for a selection of operators. These were mainly used in the old days when using character sets that didn't include certain characters such as ˜, |, and ^.
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          OPERATOR
         </th>
         <th class="left bgcolor2" scope="col">
          ALTERNATIVE NOTATION
         </th>
         <th scope="col">
          <b>
          </b>
         </th>
         <th class="left bgcolor2" scope="col">
          OPERATOR
         </th>
         <th class="left bgcolor2" scope="col">
          ALTERNATIVE NOTATION
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           &amp;&amp;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           and
          </code>
         </td>
         <td>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           !=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           not_eq
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           &amp;=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           and_eq
          </code>
         </td>
         <td>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ||
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           or
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           &amp;
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bitand
          </code>
         </td>
         <td>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           |=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           or_eq
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           |
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           bitor
          </code>
         </td>
         <td>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ^
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           xor
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           ˜
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           compl
          </code>
         </td>
         <td>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           ^=
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           xor_eq
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           !
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           not
          </code>
         </td>
         <td>
         </td>
         <td class="left bor1 bgcolor3">
         </td>
         <td class="left bor1 bgcolor3">
         </td>
        </tr>
       </tbody>
      </table>
     </section>
    </section>
    <section aria-labelledby="head-2-173">
     <span id="c15-sec-0019">
     </span>
     <h2 id="head-2-173">
      OVERLOADING THE ARITHMETIC OPERATORS
     </h2>
     <p id="c15-para-0137">
      <a href="c09.xhtml">
       Chapter 9
      </a>
      shows how to write the binary arithmetic operators and the shorthand arithmetic assignment operators, but it does not cover how to overload the other arithmetic operators.
     </p>
     <section>
      <span id="c15-sec-0020">
      </span>
      <h3 id="head-3-336">
       Overloading Unary Minus and Unary Plus
      </h3>
      <p>
       C++ has several unary arithmetic operators. Two of these are unary minus and unary plus. Here is an example of these operators using
       <code>
        int
       </code>
       s:
      </p>
      <pre id="c15-code-0010"><code>int i, j { 4 };</code>
<code>i = -j;    <span class="color3">// Unary minus</span></code>
<code>i = +i;    <span class="color3">// Unary plus</span></code>
<code>j = +(-i); <span class="color3">// Apply unary plus to the result of applying unary minus to i.</span></code>
<code>j = -(-i); <span class="color3">// Apply unary minus to the result of applying unary minus to i.</span></code></pre>
      <p id="c15-para-0139">
       Unary minus negates the operand, while unary plus returns the operand directly. Note that you can apply unary plus or unary minus to the result of unary plus or unary minus. These operators don't change the object on which they are called so you should make them
       <code>
        const
       </code>
       .
      </p>
      <p>
       <span aria-label="590" epub:type="pagebreak" id="Page_590" role="doc-pagebreak">
       </span>
       Here is an example of a unary
       <code>
        operator-
       </code>
       as a member function for a
       <code>
        SpreadsheetCell
       </code>
       class. Unary plus is usually an identity operation, so this class doesn't overload it.
      </p>
      <pre id="c15-code-0011"><code>SpreadsheetCell SpreadsheetCell::operator-() const</code>
<code>{</code>
<code>    return SpreadsheetCell { -getValue() };</code>
<code>}</code></pre>
      <p>
       <code>
        operator-
       </code>
       doesn't change the operand, so this member function must construct a new
       <code>
        SpreadsheetCell
       </code>
       with the negated value and return it. Hence, it can't return a reference. You can use this operator as follows:
      </p>
      <pre id="c15-code-0012"><code>SpreadsheetCell c1 { 4 };</code>
<code>SpreadsheetCell c3 { -c1 };</code></pre>
     </section>
     <section>
      <span id="c15-sec-0021">
      </span>
      <h3 id="head-3-337">
       Overloading Increment and Decrement
      </h3>
      <p>
       There are several ways to add 1 to a variable:
      </p>
      <pre id="c15-code-0013"><code>i = i + 1;</code>
<code>i = 1 + i;</code>
<code>i += 1;</code>
<code>++i;</code>
<code>i++;</code></pre>
      <p id="c15-para-0143">
       The last two forms are called the
       <i>
        increment
       </i>
       operators. The first of these is
       <i>
        prefix increment
       </i>
       , which adds 1 to the variable and then returns the newly incremented value for use in the rest of the expression. The second is
       <i>
        postfix increment
       </i>
       , which also adds 1 to the variable but returns the old (non-incremented) value for use in the rest of the expression. The decrement operators work similarly.
      </p>
      <p id="c15-para-0144">
       The two possible meanings for
       <code>
        operator++
       </code>
       and
       <code>
        operator--
       </code>
       (prefix and postfix) present a problem when you want to overload them. When you write an overloaded
       <code>
        operator++
       </code>
       , for example, how do you specify whether you are overloading the prefix or the postfix version? C++ introduced a hack to allow you to make this distinction: the prefix versions of
       <code>
        operator++
       </code>
       and
       <code>
        operator--
       </code>
       take no arguments, while the postfix versions take one unused argument of type
       <code>
        int
       </code>
       .
      </p>
      <p>
       The prototypes of these overloaded operators for the
       <code>
        SpreadsheetCell
       </code>
       class look like this:
      </p>
      <pre id="c15-code-0014"><code>SpreadsheetCell&amp; operator++();   <span class="color3">// Prefix</span></code>
<code>SpreadsheetCell operator++(int); <span class="color3">// Postfix</span></code>
<code>SpreadsheetCell&amp; operator--();   <span class="color3">// Prefix</span></code>
<code>SpreadsheetCell operator--(int); <span class="color3">// Postfix</span></code></pre>
      <p id="c15-para-0146">
       The return value in the prefix forms is the same as the end value of the operand, so prefix increment and decrement can return a reference to the object on which they are called. The postfix versions of increment and decrement, however, return values that are different from the end values of the operands, so they cannot return references.
      </p>
      <p>
       Here are the implementations for
       <code>
        operator++
       </code>
       :
      </p>
      <pre id="c15-code-0015"><code>SpreadsheetCell&amp; SpreadsheetCell::operator++()</code>
<code>{</code>
<code>    set(getValue() + 1);</code>
<code>    return *this;</code>
<code>}</code>
<code> </code>
<span aria-label="591" epub:type="pagebreak" id="Page_591" role="doc-pagebreak"></span><code>SpreadsheetCell SpreadsheetCell::operator++(int)</code>
<code>{</code>
<code>    auto oldCell { *this }; <span class="color3">// Save current value</span></code>
<code>    ++(*this);              <span class="color3">// Increment using prefix ++</span></code>
<code>    return oldCell;         <span class="color3">// Return the old value</span></code>
<code>}</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0149">
          <b>
           NOTE
          </b>
          <i>
           It is recommended to implement the postfix operator in terms of the prefix operator
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       The implementations for
       <code>
        operator--
       </code>
       are virtually identical. Now you can increment and decrement
       <code>
        SpreadsheetCell
       </code>
       objects to your heart's content:
      </p>
      <pre id="c15-code-0016"><code>SpreadsheetCell c1 { 4 };</code>
<code>SpreadsheetCell c2 { 4 };</code>
<code>c1++;</code>
<code>++c2;</code></pre>
      <p id="c15-para-0151">
       Increment and decrement operators also work on pointers. When you write classes that are smart pointers, for example, you can overload
       <code>
        operator++
       </code>
       and
       <code>
        operator--
       </code>
       to provide pointer incrementing and decrementing.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-174">
     <span id="c15-sec-0023">
     </span>
     <h2 id="head-2-174">
      OVERLOADING THE BITWISE AND BINARY LOGICAL OPERATORS
     </h2>
     <p id="c15-para-0152">
      The bitwise operators are similar to the arithmetic operators, and the bitwise shorthand assignment operators are similar to the arithmetic shorthand assignment operators. However, they are significantly less common, so no examples are shown here. The table in the section “
      <a href="#c15-sec-0013">
       Summary of Overloadable Operators
      </a>
      ” shows sample prototypes, so you should be able to implement them easily if the need ever arises.
     </p>
     <p id="c15-para-0153">
      The logical operators are trickier. It's not recommended to overload
      <code>
       &amp;&amp;
      </code>
      and
      <code>
       ||
      </code>
      . These operators don't really apply to individual types: they aggregate results of Boolean expressions. Additionally, when overloading these operators, you lose the short-circuit evaluation, because both the left-hand side and the right-hand side have to be evaluated before they can be bound to the parameters of your overloaded operator
      <code>
       &amp;&amp;
      </code>
      and
      <code>
       ||
      </code>
      . Thus, it rarely, if ever, makes sense to overload them for specific types.
     </p>
    </section>
    <section aria-labelledby="head-2-175">
     <span id="c15-sec-0024">
     </span>
     <h2 id="head-2-175">
      OVERLOADING THE INSERTION AND EXTRACTION OPERATORS
     </h2>
     <p>
      In C++, you use operators not only for arithmetic operations but also for reading from, and writing to, streams. For example, when you write
      <code>
       int
      </code>
      s and
      <code>
       string
      </code>
      s to
      <code>
       cout
      </code>
      , you use the insertion operator
      <code>
       &lt;&lt;
      </code>
      :
     </p>
     <pre id="c15-code-0017"><code>int number { 10 };</code>
<code>cout &lt;&lt; "The number is " &lt;&lt; number &lt;&lt; endl;</code></pre>
     <p>
      <span aria-label="592" epub:type="pagebreak" id="Page_592" role="doc-pagebreak">
      </span>
      When you read from streams, you use the extraction operator
      <code>
       &gt;&gt;
      </code>
      :
     </p>
     <pre id="c15-code-0018"><code>int number;</code>
<code>string str;</code>
<code>cin &gt;&gt; number &gt;&gt; str;</code></pre>
     <p>
      You can write insertion and extraction operators that work on your classes as well, so that you can read and write them like this:
     </p>
     <pre id="c15-code-0019"><code>SpreadsheetCell myCell, anotherCell, aThirdCell;</code>
<code>cin &gt;&gt; myCell &gt;&gt; anotherCell &gt;&gt; aThirdCell;</code>
<code>cout &lt;&lt; myCell &lt;&lt; " " &lt;&lt; anotherCell &lt;&lt; " " &lt;&lt; aThirdCell &lt;&lt; endl;</code></pre>
     <p id="c15-para-0157">
      Before you write the insertion and extraction operators, you need to decide how you want to stream your class out and how you want to read it in. In this example, the
      <code>
       SpreadsheetCell
      </code>
      s simply read and write a single
      <code>
       double
      </code>
      value.
     </p>
     <p>
      The object on the left of an extraction or insertion operator is an
      <code>
       istream
      </code>
      or
      <code>
       ostream
      </code>
      (such as
      <code>
       cin
      </code>
      or
      <code>
       cout
      </code>
      ), not a
      <code>
       SpreadsheetCell
      </code>
      object. Because you can't add a member function to the
      <code>
       istream
      </code>
      or
      <code>
       ostream
      </code>
      classes, you must write the extraction and insertion operators as global functions. The declaration of these functions looks like this:
     </p>
     <pre id="c15-code-0020"><code>export std::ostream&amp; operator&lt;&lt;(std::ostream&amp; ostr, const SpreadsheetCell&amp; cell);</code>
<code>export std::istream&amp; operator&gt;&gt;(std::istream&amp; istr, SpreadsheetCell&amp; cell);</code></pre>
     <p id="c15-para-0159">
      By making the insertion operator take a reference to an
      <code>
       ostream
      </code>
      as its first parameter, you allow it to be used for file output streams, string output streams,
      <code>
       cout
      </code>
      ,
      <code>
       cerr
      </code>
      ,
      <code>
       clog
      </code>
      , and more. See
      <a href="c13.xhtml">
       Chapter 13
      </a>
      , “Demystifying C++ I/O,” for details on streams. Similarly, by making the extraction operator take a reference to an
      <code>
       istream
      </code>
      , you make it work with any input stream, such as a file input stream, string input stream, and
      <code>
       cin
      </code>
      .
     </p>
     <p id="c15-para-0160">
      The second parameter to
      <code>
       operator&lt;&lt;
      </code>
      and
      <code>
       operator&gt;&gt;
      </code>
      is a reference to the
      <code>
       SpreadsheetCell
      </code>
      object that you want to write or read. The insertion operator doesn't change the
      <code>
       SpreadsheetCell
      </code>
      it writes, so the parameter is of type reference-to-
      <code>
       const
      </code>
      . The extraction operator, however, modifies the
      <code>
       SpreadsheetCell
      </code>
      object, requiring the parameter to be a reference-to-non-
      <code>
       const
      </code>
      .
     </p>
     <p>
      Both operators return a reference to the stream they were given as their first parameter so that calls to the operator can be nested. Remember that the operator syntax is shorthand for calling the global
      <code>
       operator&gt;&gt;
      </code>
      or
      <code>
       operator&lt;&lt;
      </code>
      functions explicitly. Consider this line:
     </p>
     <pre id="c15-code-0021"><code>cin&gt;&gt; myCell&gt;&gt; anotherCell&gt;&gt; aThirdCell;</code></pre>
     <p>
      This line is shorthand for:
     </p>
     <pre id="c15-code-0022"><code>operator&gt;&gt;(operator&gt;&gt;(operator&gt;&gt;(cin, myCell), anotherCell), aThirdCell);</code></pre>
     <p id="c15-para-0163">
      As you can see, the return value of the first call to
      <code>
       operator&gt;&gt;
      </code>
      is used as input to the next call. Thus, you must return the stream reference so that it can be used in the next nested call. Otherwise, the nesting won't compile.
     </p>
     <p>
      Here are the implementations for
      <code>
       operator&lt;&lt;
      </code>
      and
      <code>
       &gt;&gt;
      </code>
      for the
      <code>
       SpreadsheetCell
      </code>
      class:
     </p>
     <pre id="c15-code-0023"><code>ostream&amp; operator&lt;&lt;(ostream&amp; ostr, const SpreadsheetCell&amp; cell)</code>
<code>{</code>
<code>    ostr &lt;&lt; cell.getValue();</code>
<code>    return ostr;</code>
<code>}</code>
<code><span aria-label="593" epub:type="pagebreak" id="Page_593" role="doc-pagebreak"></span> </code>
<code>istream&amp; operator &gt;&gt;(istream&amp; istr, SpreadsheetCell&amp; cell)</code>
<code>{</code>
<code>    double value;</code>
<code>    istr &gt;&gt; value;</code>
<code>    cell.set(value);</code>
<code>    return istr;</code>
<code>}</code></pre>
    </section>
    <section aria-labelledby="head-2-176">
     <span id="c15-sec-0025">
     </span>
     <h2 id="head-2-176">
      OVERLOADING THE SUBSCRIPTING OPERATOR
     </h2>
     <p>
      Pretend for a few minutes that you have never heard of the
      <code>
       vector
      </code>
      or
      <code>
       array
      </code>
      class templates in the Standard Library, and so you have decided to write your own dynamically allocated array class. This class would allow you to set and retrieve elements at specified indices and would take care of all memory allocation “behind the scenes.” A first stab at the class definition for a dynamically allocated array might look like this:
     </p>
     <pre id="c15-code-0024"><code>export template &lt;typename T&gt;</code>
<code>class Array</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Creates an array with a default size that will grow as needed.</span></code>
<code>        Array();</code>
<code>        virtual ˜Array();</code>
<code> </code>
<code>        <span class="color3">// Disallow copy constructor and copy assignment.</span></code>
<code>        Array&amp; operator=(const Array&amp; rhs) = delete;</code>
<code>        Array(const Array&amp; src) = delete;</code>
<code> </code>
<code>        <span class="color3">// Move constructor and move assignment operator.</span></code>
<code>        Array(Array&amp;&amp; src) noexcept;</code>
<code>        Array&amp; operator=(Array&amp;&amp; rhs) noexcept;</code>
<code> </code>
<code>        <span class="color3">// Returns the value at index x. Throws an exception of type</span></code>
<code>        <span class="color3">// out_of_range if index x does not exist in the array.</span></code>
<code>        const T&amp; getElementAt(std::size_t x) const;</code>
<code> </code>
<code>        <span class="color3">// Sets the value at index x. If index x is out of range,</span></code>
<code>        <span class="color3">// allocates more space to make it in range.</span></code>
<code>        void setElementAt(std::size_t x, const T&amp; value);</code>
<code> </code>
<code>        <span class="color3">// Returns the number of elements in the array.</span></code>
<code>        std::size_t getSize() const noexcept;</code>
<code>    private:</code>
<code>        static constexpr std::size_t AllocSize { 4 };</code>
<code>        void resize(std::size_t newSize);</code>
<code>        T* m_elements { nullptr };</code>
<code>        std::size_t m_size { 0 };</code>
<code>};</code></pre>
     <p id="c15-para-0166">
      The interface supports setting and accessing elements. It provides random-access guarantees: a client could create a default array and set elements
      <code>
       1
      </code>
      ,
      <code>
       100
      </code>
      and
      <code>
       1000
      </code>
      without worrying about memory management.
     </p>
     <p>
      <span aria-label="594" epub:type="pagebreak" id="Page_594" role="doc-pagebreak">
      </span>
      Here are the implementations of the member functions:
     </p>
     <pre id="c15-code-0025"><code>template &lt;typename T&gt; Array&lt;T&gt;::Array()</code>
<code>{</code>
<code>    m_elements = new T[AllocSize] {}; <span class="color3">// Elements are zero-initialized!</span></code>
<code>    m_size = AllocSize;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; Array&lt;T&gt;::˜Array()</code>
<code>{</code>
<code>    delete[] m_elements;</code>
<code>    m_elements = nullptr;</code>
<code>    m_size = 0;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; Array&lt;T&gt;::Array(Array&amp;&amp; src) noexcept</code>
<code>    : m_elements { std::exchange(src.m_elements, nullptr) }</code>
<code>    , m_size { std::exchange(src.m_size, 0) }</code>
<code>{</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; Array&lt;T&gt;&amp; Array&lt;T&gt;::operator=(Array&lt;T&gt;&amp;&amp; rhs) noexcept</code>
<code>{</code>
<code>    if (this == &amp;rhs) { return *this; }</code>
<code>    delete[] m_elements;</code>
<code>    m_elements = std::exchange(rhs.m_elements, nullptr);</code>
<code>    m_size = std::exchange(rhs.m_size, 0);</code>
<code>    return *this;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; void Array&lt;T&gt;::resize(std::size_t newSize)</code>
<code>{</code>
<code>    <span class="color3">// Create new bigger array with zero-initialized elements.</span></code>
<code>    auto newArray { std::make_unique&lt;T[]&gt;(newSize) };</code>
<code> </code>
<code>    <span class="color3">// The new size is always bigger than the old size (m_size).</span></code>
<code>    for (std::size_t i { 0 }; i &lt; m_size; ++i) {</code>
<code>        <span class="color3">// Copy the elements from the old array to the new one.</span></code>
<code>        newArray[i] = m_elements[i];</code>
<code>    }</code>
<code> </code>
<code>    <span class="color3">// Delete the old array, and set the new array.</span></code>
<code>    delete[] m_elements;</code>
<code>    m_size = newSize;</code>
<code>    m_elements = newArray.release();</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; const T&amp; Array&lt;T&gt;::getElementAt(std::size_t x) const</code>
<code>{</code>
<code>    if (x &gt;= m_size) { throw std::out_of_range { "" }; }</code>
<code>    return m_elements[x];</code>
<code>}</code>
<code> </code>
<span aria-label="595" epub:type="pagebreak" id="Page_595" role="doc-pagebreak"></span><code>template &lt;typename T&gt; void Array&lt;T&gt;::setElementAt(std::size_t x, const T&amp; val)</code>
<code>{</code>
<code>    if (x &gt;= m_size) {</code>
<code>        <span class="color3">// Allocate AllocSize past the element the client wants.</span></code>
<code>        resize(x + AllocSize);</code>
<code>    }</code>
<code>    m_elements[x] = val;</code>
<code>}</code>
<code> </code>
<code>template &lt;typename T&gt; std::size_t Array&lt;T&gt;::getSize() const noexcept</code>
<code>{</code>
<code>    return m_size;</code>
<code>}</code></pre>
     <p id="c15-para-0168">
      Pay attention to the exception-safe implementation of the
      <code>
       resize()
      </code>
      member function. First, it creates a new array of appropriate size using
      <code>
       make_unique()
      </code>
      and stores it in a
      <code>
       unique_ptr
      </code>
      . Then, all elements are copied from the old array to the new array. If anything goes wrong while copying the values, the
      <code>
       unique_ptr
      </code>
      cleans up the newly allocated memory automatically. Finally, when both the allocation of the new array and copying all the elements is successful, that is, no exceptions have been thrown, only then do we delete the old
      <code>
       m_elements
      </code>
      array and assign the new array to it. The last line has to use
      <code>
       release()
      </code>
      to release the ownership of the new array from the
      <code>
       unique_ptr
      </code>
      ; otherwise, the array would get destroyed when the destructor for the
      <code>
       unique_ptr
      </code>
      is called.
     </p>
     <p id="c15-para-0169">
      To guarantee strong exception safety (see
      <a href="c14.xhtml">
       Chapter 14
      </a>
      , “Handling Errors”),
      <code>
       resize()
      </code>
      copies elements from the old array to the newly allocated array.
      <a href="c26.xhtml">
       Chapter 26
      </a>
      , “Advanced Templates,” discusses and implements a
      <code>
       move_assign_if_noexcept()
      </code>
      helper function. This helper function can be used in the implementation of
      <code>
       resize()
      </code>
      so that elements are moved from the old array to the new array, but only if the move assignment operator of the element type is marked as
      <code>
       noexcept
      </code>
      . If that's not the case, the elements are copied. With that change, whether elements are moved or copied, strong exception safety remains guaranteed.
     </p>
     <p>
      Here is a small example of how you could use this class:
     </p>
     <pre id="c15-code-0026"><code>Array&lt;int&gt; myArray;</code>
<code>for (size_t i { 0 }; i &lt; 20; i += 2) {</code>
<code>    myArray.setElementAt(i, 100);</code>
<code>}</code>
<code>for (size_t i { 0 }; i &lt; 20; ++i) {</code>
<code>    print("{} ", myArray.getElementAt(i));</code>
<code>}</code></pre>
     <p>
      The output is as follows:
     </p>
     <pre id="c15-code-0027"><code>100 0 100 0 100 0 100 0 100 0 100 0 100 0 100 0 100 0 100 0</code></pre>
     <p>
      As you can see, you never have to tell the array how much space you need. It allocates as much space as it requires to store the elements you give it.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c15-para-0173">
         <b>
          NOTE
         </b>
         <i>
          This is not a memory efficient implementation. If you create an array and only assign a value to the element with index 4000, then it allocates memory for 4004 elements, all zero initialized except for the element with index 4000
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c15-para-0174">
      <span aria-label="596" epub:type="pagebreak" id="Page_596" role="doc-pagebreak">
      </span>
      However, it's inconvenient to always have to use the
      <code>
       setElementAt()
      </code>
      and
      <code>
       getElementAt()
      </code>
      member functions.
     </p>
     <p>
      This is where the overloaded subscripting operator comes in. You can add an
      <code>
       operator[]
      </code>
      to the class as follows:
     </p>
     <pre id="c15-code-0028"><code>export template &lt;typename T&gt;</code>
<code>class Array</code>
<code>{</code>
<code>    public:</code>
<code>        <b>T&amp; operator[](std::size_t x);</b></code>
<code>        <span class="color3">// Remainder omitted for brevity.</span></code>
<code>};</code></pre>
     <p>
      Here is the implementation:
     </p>
     <pre id="c15-code-0029"><code>template &lt;typename T&gt; T&amp; Array&lt;T&gt;::operator[](std::size_t x)</code>
<code>{</code>
<code>    if (x &gt;= m_size) {</code>
<code>        <span class="color3">// Allocate AllocSize past the element the client wants.</span></code>
<code>        resize(x + AllocSize);</code>
<code>    }</code>
<code>    return m_elements[x];</code>
<code>}</code></pre>
     <p>
      With this change, you can use conventional array index notation like this:
     </p>
     <pre id="c15-code-0030"><code>Array&lt;int&gt; myArray;</code>
<code>for (size_t i { 0 }; i &lt; 20; i += 2) {</code>
<code>    <b>myArray[i] = 100;</b></code>
<code>}</code>
<code>for (size_t i { 0 }; i &lt; 20; ++i) {</code>
<code>    <b>print("{} ", myArray[i]);</b></code>
<code>}</code></pre>
     <p id="c15-para-0178">
      The
      <code>
       operator[]
      </code>
      can be used to both set and get elements because it returns a reference to the element at location
      <code>
       x
      </code>
      . This reference can be used to assign to that element. When
      <code>
       operator[]
      </code>
      is used on the left-hand side of an assignment statement, the assignment actually changes the value at location
      <code>
       x
      </code>
      in the
      <code>
       m_elements
      </code>
      array.
     </p>
     <section>
      <span id="c15-sec-0027">
      </span>
      <h3 id="head-3-338">
       Providing Read-Only Access with operator[]
      </h3>
      <p>
       Although it's sometimes convenient for
       <code>
        operator[]
       </code>
       to return an element that can serve as an lvalue, you don't always want that behavior. It would be nice to be able to provide read-only access to the elements of the array as well, by returning a reference-to-
       <code>
        const
       </code>
       . To provide for this, you need two
       <code>
        operator[]
       </code>
       overloads: one returning a reference-to-non-
       <code>
        const
       </code>
       and one returning a reference-to-
       <code>
        const
       </code>
       :
      </p>
      <pre id="c15-code-0031"><code>T&amp; operator[](std::size_t x);</code>
<code><b>const T&amp; operator[](std::size_t x) const;</b></code></pre>
      <p id="c15-para-0180">
       Remember that you can't overload a member function or operator based only on the return type, so the second overload returns a reference-to-
       <code>
        const
       </code>
       <i>
        and
       </i>
       is marked as
       <code>
        const
       </code>
       .
      </p>
      <p>
       <span aria-label="597" epub:type="pagebreak" id="Page_597" role="doc-pagebreak">
       </span>
       Here is the implementation of the
       <code>
        const operator[]
       </code>
       . It throws an exception if the index is out of range instead of trying to allocate new space. It doesn't make sense to allocate new space when you're only trying to read the element value.
      </p>
      <pre id="c15-code-0032"><code>template &lt;typename T&gt; const T&amp; Array&lt;T&gt;::operator[](std::size_t x) const</code>
<code>{</code>
<code>    if (x &gt;= m_size) { throw std::out_of_range { "" }; }</code>
<code>    return m_elements[x];</code>
<code>}</code></pre>
      <p>
       The following code demonstrates these two forms of
       <code>
        operator[]
       </code>
       :
      </p>
      <pre id="c15-code-0033"><code>void printArray(const Array&lt;int&gt;&amp; arr)</code>
<code>{</code>
<code>    for (size_t i { 0 }; i &lt; arr.getSize(); ++i) {</code>
<code>        print("{} ", arr[i]);  <span class="color3">// Calls the const operator[] because arr is</span></code>
<code>                               <span class="color3">// a const object.</span></code>
<code>    }</code>
<code>    println("");</code>
<code>}</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    Array&lt;int&gt; myArray;</code>
<code>    for (size_t i { 0 }; i &lt; 20; i += 2) {</code>
<code>        myArray[i] = 100; <span class="color3">// Calls the non-const operator[] because</span></code>
<code>                          <span class="color3">// myArray is a non-const object.</span></code>
<code>    }</code>
<code>    printArray(myArray);</code>
<code>}</code></pre>
      <p id="c15-para-0183">
       Note that the
       <code>
        const operator[]
       </code>
       is called in
       <code>
        printArray()
       </code>
       only because the parameter
       <code>
        arr
       </code>
       is
       <code>
        const
       </code>
       . If
       <code>
        arr
       </code>
       were not
       <code>
        const
       </code>
       , the non-
       <code>
        const operator[]
       </code>
       would be called, despite that the result is not modified.
      </p>
      <p>
       The
       <code>
        const operator[]
       </code>
       is called for
       <code>
        const
       </code>
       objects, so it cannot grow the size of the array. The current implementation throws an exception when the given index is out of bounds. An alternative would be to return a zero-initialized element instead of throwing. This can be done as follows:
      </p>
      <pre id="c15-code-0034"><code>template &lt;typename T&gt; const T&amp; Array&lt;T&gt;::operator[](std::size_t x) const</code>
<code>{</code>
<code>    if (x &gt;= m_size) {</code>
<code>        static T nullValue { T{} };</code>
<code>        return nullValue;</code>
<code>    }</code>
<code>    return m_elements[x];</code>
<code>}</code></pre>
      <p>
       The
       <code>
        nullValue static
       </code>
       variable is initialized using the zero-initialization syntax
       <code>
        T{}
       </code>
       . It's up to you and your specific use case whether you opt for the throwing version or the version returning a null value.
       <span aria-label="598" epub:type="pagebreak" id="Page_598" role="doc-pagebreak">
       </span>
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0186">
          <b>
           NOTE
          </b>
          <i>
           Zero-initialization constructs objects with the default constructor and initializes primitive integer types (such as
          </i>
          <code>
           char
          </code>
          <i>
           ,
          </i>
          <code>
           int
          </code>
          <i>
           , and so on) to zero, primitive floating-point types to 0.0, and pointer types to
          </i>
          <code>
           nullptr
          </code>
          <i>
           .
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c15-sec-0029">
      </span>
      <h3 id="head-3-339">
       <img alt="C++23" src="../images\images/icon1.png"/>
       Multidimensional Subscripting Operator
      </h3>
      <p id="c15-para-0188">
       Starting with C++23, a subscripting operator can support multidimensional indexing. The syntax is straightforward. Instead of writing a subscripting operator accepting a single index parameter, you write a subscripting operator with as many index parameters as dimensions you need.
      </p>
      <p>
       To demonstrate, let's revisit the
       <code>
        Grid
       </code>
       class template from
       <a href="c12.xhtml">
        Chapter 12
       </a>
       , “Writing Generic Code with Templates.” Its interface contains a
       <code>
        const
       </code>
       and non-
       <code>
        const
       </code>
       overload of an
       <code>
        at(x,y)
       </code>
       member function. These
       <code>
        at()
       </code>
       member functions can be replaced with two-dimensional
       <code>
        const
       </code>
       and non-
       <code>
        const
       </code>
       subscripting operators as follows:
      </p>
      <pre id="c15-code-0035"><code>template &lt;typename T&gt;</code>
<code>class Grid</code>
<code>{</code>
<code>    public:</code>
<code>        std::optional&lt;T&gt;&amp; <b>operator[](std::size_t x, std::size_t y)</b>;</code>
<code>        const std::optional&lt;T&gt;&amp; <b>operator[](std::size_t x, std::size_t y)</b> const;</code>
<code>        <span class="color3">// Remainder omitted for brevity.</span></code>
<code>};</code></pre>
      <p>
       The syntax simply specifies two parameters,
       <code>
        x
       </code>
       and
       <code>
        y
       </code>
       , for these two-dimensional subscripting operators. The implementations are almost identical to the implementations of the original
       <code>
        at()
       </code>
       member functions:
      </p>
      <pre id="c15-code-0036"><code>template &lt;typename T&gt;</code>
<code>const std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::<b>operator[](std::size_t x, std::size_t y)</b> const</code>
<code>{</code>
<code>    verifyCoordinate(x, y);</code>
<code>    return m_cells[x + y * m_width];</code>
<code>}</code>
<code>template &lt;typename T&gt;</code>
<code>std::optional&lt;T&gt;&amp; Grid&lt;T&gt;::<b>operator[](std::size_t x, std::size_t y)</b></code>
<code>{</code>
<code>    return const_cast&lt;std::optional&lt;T&gt;&amp;&gt;(std::as_const(*this)<b>[x, y]</b>);</code>
<code>}</code></pre>
      <p>
       Here is an example of these new operators in action:
      </p>
      <pre id="c15-code-0037"><code>Grid&lt;int&gt; myIntGrid { 4, 4 };</code>
<code>int counter { 0 };</code>
<code>for (size_t y { 0 }; y &lt; myIntGrid.getHeight(); ++y) {</code>
<code>    for (size_t x { 0 }; x &lt; myIntGrid.getWidth(); ++x) {</code>
<code>        <b>myIntGrid[x, y]</b> = ++counter;</code>
<code>    }</code>
<code>}</code>
<code>for (size_t y { 0 }; y &lt; myIntGrid.getHeight(); ++y) {</code>
<code>    for (size_t x { 0 }; x &lt; myIntGrid.getWidth(); ++x) {</code>
<code>        print("{:3} ", <b>myIntGrid[x, y]</b>.value_or(0));</code>
<span aria-label="599" epub:type="pagebreak" id="Page_599" role="doc-pagebreak"></span><code>    }</code>
<code>    println("");</code>
<code>}</code></pre>
      <p>
       The output is:
      </p>
      <pre id="c15-code-0038"><code>  1   2   3   4 </code>
<code>  5   6   7   8 </code>
<code>  9  10  11  12 </code>
<code> 13  14  15  16</code></pre>
     </section>
     <section>
      <span id="c15-sec-0030">
      </span>
      <h3 id="head-3-340">
       Non-integral Array Indices
      </h3>
      <p id="c15-para-0193">
       It is a natural extension of the paradigm of “indexing” into a collection to provide a key of some sort; a
       <code>
        vector
       </code>
       (or in general, any linear array) is a special case where the “key” is just a position in the array. Think of the argument of
       <code>
        operator[]
       </code>
       as providing a mapping between two domains: the domain of keys and the domain of values. Thus, you can write an
       <code>
        operator[]
       </code>
       that uses any type as its index. This type does not need to be an integer type. This is done for the Standard Library associative containers, like
       <code>
        std::map
       </code>
       , which are discussed in
       <a href="c18.xhtml">
        Chapter 18
       </a>
       , “Standard Library Containers.”
      </p>
      <p id="c15-para-0194">
       For example, you could create an
       <i>
        associative array
       </i>
       in which you use
       <code>
        string
       </code>
       keys instead of integral indices. The
       <code>
        operator[]
       </code>
       for such a class would accept a
       <code>
        string
       </code>
       , or better yet
       <code>
        string_view
       </code>
       , as an argument. Implementing such a class is an exercise for you at the end of this chapter.
      </p>
     </section>
     <section>
      <span id="c15-sec-0031">
      </span>
      <h3 id="head-3-341">
       <img alt="C++23" src="../images\images/icon1.png"/>
       static Subscripting Operator
      </h3>
      <p>
       With C++23, the subscripting operator can be marked as
       <code>
        static
       </code>
       as long as the implementation of the operator does not require access to
       <code>
        this
       </code>
       , or, in other words, does not need access to non-
       <code>
        static
       </code>
       data members and non-
       <code>
        static
       </code>
       member functions. This allows the compiler to better optimize the code as it doesn't need to worry about any
       <code>
        this
       </code>
       pointer. Here is an example where
       <code>
        operator[]
       </code>
       is marked as
       <code>
        static
       </code>
       ,
       <code>
        constexpr
       </code>
       (see
       <a href="c09.xhtml">
        Chapter 9
       </a>
       ), and
       <code>
        noexcept
       </code>
       (
       <a href="c14.xhtml">
        Chapter 14
       </a>
       ):
      </p>
      <pre id="c15-code-0039"><code>enum class Figure { Diamond, Heart, Spade, Club };</code>
<code> </code>
<code>class FigureEnumToString</code>
<code>{</code>
<code>    public:</code>
<code>        <b>static constexpr string_view operator[](Figure figure) noexcept</b></code>
<code>        {</code>
<code>            switch (figure) {</code>
<code>                case Figure::Diamond: return "Diamond";</code>
<code>                case Figure::Heart:   return "Heart";</code>
<code>                case Figure::Spade:   return "Spade";</code>
<code>                case Figure::Club:    return "Club";</code>
<code>            }</code>
<code>        }</code>
<code>};</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    Figure f { Figure::Spade };</code>
<span aria-label="600" epub:type="pagebreak" id="Page_600" role="doc-pagebreak"></span><code>    FigureEnumToString converter;</code>
<code>    println("{}", <b>converter[f]</b>);</code>
<code>    println("{}", <b>FigureEnumToString{}[f]</b>);</code>
<code>}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-177">
     <span id="c15-sec-0032">
     </span>
     <h2 id="head-2-177">
      OVERLOADING THE FUNCTION CALL OPERATOR
     </h2>
     <p>
      C++ allows you to overload the function call operator, written as
      <code>
       operator()
      </code>
      . If you write an
      <code>
       operator()
      </code>
      for your class, you can use objects of that class as if they were function pointers. An object of a class with a function call operator is called a
      <i>
       function object
      </i>
      , or
      <i>
       functor
      </i>
      , for short. Here is an example of a simple class with an overloaded
      <code>
       operator()
      </code>
      and a class member function with the same behavior:
     </p>
     <pre id="c15-code-0040"><code>class Squarer</code>
<code>{</code>
<code>    public:</code>
<code>        int operator()(int value) const; <span class="color3">// Overloaded function call operator.</span></code>
<code>        int doSquare(int value) const;   <span class="color3">// Normal member function.</span></code>
<code>};</code>
<code><span class="color3">// Implementation of overloaded function call operator.</span></code>
<code>int Squarer::operator()(int value) const { return doSquare(value); }</code>
<code><span class="color3">// Implementation of normal member function.</span></code>
<code>int Squarer::doSquare(int value) const { return value * value; }</code></pre>
     <p>
      Here is an example of code that uses the function call operator, contrasted with a call to the normal member function of the class:
     </p>
     <pre id="c15-code-0041"><code>int x { 3 };</code>
<code>Squarer square;</code>
<code>int xSquared { <b>square(x)</b> };                     <span class="color3">// Call the function call operator.</span></code>
<code>int xSquaredAgain { <b>square.doSquare(xSquared)</b> };<span class="color3">// Call the normal member function.</span></code>
<code>println("{} squared is {}, and squared again is {}.", x, xSquared, xSquaredAgain);</code></pre>
     <p>
      The output is as follows:
     </p>
     <pre id="c15-code-0042"><code>3 squared is 9, and squared again is 81.</code></pre>
     <p id="c15-para-0200">
      At first, the function call operator probably seems a little strange. Why would you want to write a special member function for a class to make objects of the class look like function pointers? Why wouldn't you just write a global function or a standard member function of a class?
     </p>
     <p id="c15-para-0201">
      The advantage of function objects over standard member functions of objects is simple: these objects can sometimes masquerade as function pointers; that is, you can pass function objects as callback functions to other functions. This is discussed in more detail in
      <a href="c19.xhtml">
       Chapter 19
      </a>
      .
     </p>
     <p>
      The advantages of function objects over global functions are more intricate. There are two main benefits:
     </p>
     <ul class="check1" id="c15-list-0004">
      <li id="c15-li-0023">
       Objects can retain information in their data members between repeated calls to their function call operators. For example, a function object might be used to keep a running sum of numbers collected from each call to the function call operator.
      </li>
      <li id="c15-li-0024">
       <span aria-label="601" epub:type="pagebreak" id="Page_601" role="doc-pagebreak">
       </span>
       You can customize the behavior of a function object by setting data members. For example, you could write a function object to compare an argument to the function call operator against a data member. This data member could be configurable so that the object could be customized for whatever comparison you want.
      </li>
     </ul>
     <p id="c15-para-0203">
      Of course, you could implement either of the preceding benefits with global or
      <code>
       static
      </code>
      variables. However, function objects provide a cleaner way to do it, and besides, using global or
      <code>
       static
      </code>
      variables should be avoided and can cause problems in a multithreaded application. The true benefits of function objects are demonstrated with the Standard Library in
      <a href="c20.xhtml">
       Chapter 20
      </a>
      , “Mastering Standard Library Algorithms.”
     </p>
     <p>
      By following the normal member function overloading rules, you can write as many
      <code>
       operator()
      </code>
      s for your classes as you want. For example, you could add an
      <code>
       operator()
      </code>
      to the
      <code>
       Squarer
      </code>
      class that takes a
      <code>
       double
      </code>
      :
     </p>
     <pre id="c15-code-0043"><code>int operator()(int value) const;</code>
<code><b>double operator()(double value) const;</b></code></pre>
     <p>
      This
      <code>
       double
      </code>
      overload can be implemented as follows:
     </p>
     <pre id="c15-code-0044"><code>double Squarer::operator()(double value) const { return value * value; }</code></pre>
     <section>
      <span id="c15-sec-0033">
      </span>
      <h3 id="head-3-342">
       <img alt="C++23" src="../images\images/icon1.png"/>
       static Function Call Operator
      </h3>
      <p id="c15-para-0207">
       Starting with C++23, a function call operator can be marked as
       <code>
        static
       </code>
       if its implementation does not require access to
       <code>
        this
       </code>
       , or, in other words, does not need access to non-
       <code>
        static
       </code>
       data members and non-
       <code>
        static
       </code>
       member functions. This is similar to how subscripting operators, discussed earlier in this chapter, can be marked as
       <code>
        static
       </code>
       , and doing so allows the compiler to better optimize the code.
      </p>
      <p>
       Here is an example, a reduced
       <code>
        Squarer
       </code>
       functor with a
       <code>
        static
       </code>
       ,
       <code>
        constexpr
       </code>
       , and
       <code>
        noexcept
       </code>
       function call operator:
      </p>
      <pre id="c15-code-0045"><code>class Squarer</code>
<code>{</code>
<code>    public:</code>
<code>        <b>static constexpr int operator()(int value) noexcept</b></code>
<code>        {</code>
<code>            return value * value;</code>
<code>        }</code>
<code>};</code></pre>
      <p>
       This functor can be used as follows:
      </p>
      <pre id="c15-code-0046"><code>int x { 3 };</code>
<code>int xSquared { <b>Squarer::operator()(x)</b> };</code>
<code>int xSquaredAgain { <b>Squarer{}(xSquared)</b> };</code>
<code>println("{} squared is {}, and squared again is {}.", x, xSquared, xSquaredAgain);</code></pre>
      <p id="c15-para-0210">
       Another benefit of
       <code>
        static
       </code>
       function call operators is that you can easily take their address, for example,
       <code>
        &amp;Squarer::operator()
       </code>
       , which allows you to use them as if they were function pointers. This can improve the performance when working with the Standard Library algorithms discussed in
       <span aria-label="602" epub:type="pagebreak" id="Page_602" role="doc-pagebreak">
       </span>
       detail in
       <a href="c20.xhtml">
        Chapter 20
       </a>
       . Quite a few of those algorithms accept a callable, such as a functor, to customize their behavior. If your functor has a
       <code>
        static
       </code>
       function call operator, then passing the address of that function call operator to such algorithms allows the compiler to generate more performant code than with a non-
       <code>
        static
       </code>
       function call operator. The reason is that with a
       <code>
        static
       </code>
       function call operator, the compiler doesn't need to worry about any
       <code>
        this
       </code>
       pointer.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-178">
     <span id="c15-sec-0034">
     </span>
     <h2 id="head-2-178">
      OVERLOADING THE DEREFERENCING OPERATORS
     </h2>
     <p>
      You can overload three dereferencing operators:
      <code>
       *
      </code>
      ,
      <code>
       -&gt;
      </code>
      , and
      <code>
       -&gt;*
      </code>
      . Ignoring
      <code>
       -&gt;*
      </code>
      for the moment (I'll come back to it later), consider the built-in meanings of
      <code>
       *
      </code>
      and
      <code>
       -&gt;
      </code>
      . The
      <code>
       *
      </code>
      operator dereferences a pointer to give you direct access to its value, while
      <code>
       -&gt;
      </code>
      is shorthand for a
      <code>
       *
      </code>
      dereference followed by a
      <code>
       .
      </code>
      member selection. The following code shows the equivalences:
     </p>
     <pre id="c15-code-0047"><code>SpreadsheetCell* cell { new SpreadsheetCell };</code>
<code>(*cell).set(5); <span class="color3">// Dereference plus member selection.</span></code>
<code>cell-&gt;set(5);   <span class="color3">// Shorthand arrow dereference and member selection together.</span></code></pre>
     <p>
      You can overload the dereferencing operators for your classes to make objects of the classes behave like pointers. The main use of this capability is for implementing smart pointers, introduced in
      <a href="c07.xhtml">
       Chapter 7
      </a>
      , “Memory Management.” It is also useful for iterators, which the Standard Library uses extensively. Iterators are discussed in
      <a href="c17.xhtml">
       Chapter 17
      </a>
      , “Understanding Iterators and the Ranges Library.” This chapter teaches you the basic mechanics for overloading the relevant operators in the context of a simple smart pointer class template.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c15-para-0213">
         <b>
          WARNING
         </b>
         <i>
          C++ has two standard smart pointers called
         </i>
         <code>
          std::unique_ptr
         </code>
         <i>
          and
         </i>
         <code>
          shared_ptr
         </code>
         <i>
          . You should use these standard smart pointers instead of writing your own. The example here is given only to demonstrate how to write dereferencing operators
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p>
      Here is an example of a smart pointer class template definition, without the dereferencing operators filled in yet:
     </p>
     <pre id="c15-code-0048"><code>export template &lt;typename T&gt; class Pointer</code>
<code>{</code>
<code>    public:</code>
<code>        explicit Pointer(T* ptr) : m_ptr { ptr } {}</code>
<code>        virtual ˜Pointer() { reset(); }</code>
<code>        <span class="color3">// Disallow copy constructor and copy assignment.</span></code>
<code>        Pointer(const Pointer&amp; src) = delete;</code>
<code>        Pointer&amp; operator=(const Pointer&amp; rhs) = delete;</code>
<code>        <span class="color3">// Allow move construction.</span></code>
<code>        Pointer(Pointer&amp;&amp; src) noexcept : m_ptr{ std::exchange(src.m_ptr, nullptr)}</code>
<code>        { }</code>
<code>        <span class="color3">// Allow move assignment.</span></code>
<code>        Pointer&amp; operator=(Pointer&amp;&amp; rhs) noexcept</code>
<code>        {</code>
<code>            if (this != &amp;rhs) {</code>
<span aria-label="603" epub:type="pagebreak" id="Page_603" role="doc-pagebreak"></span><code>                reset();</code>
<code>                m_ptr = std::exchange(rhs.m_ptr, nullptr);</code>
<code>            }</code>
<code>            return *this;</code>
<code>        }</code>
<code> </code>
<code>        <span class="color3">// Dereferencing operators will go here…</span></code>
<code>    private:</code>
<code>        void reset()</code>
<code>        {</code>
<code>            delete m_ptr;</code>
<code>            m_ptr = nullptr;</code>
<code>        }</code>
<code>        T* m_ptr { nullptr };</code>
<code>};</code></pre>
     <p id="c15-para-0215">
      This smart pointer is about as simple as you can get. All it does is store a dumb raw pointer, and the storage pointed to by the pointer is deleted when the smart pointer is destroyed. The implementation is equally simple: the constructor takes a raw pointer, which is stored as the only data member in the class. The destructor frees the storage referenced by the pointer.
     </p>
     <p>
      You want to be able to use the smart pointer class template like this:
     </p>
     <pre id="c15-code-0049"><code>Pointer&lt;int&gt; smartInt { new int };</code>
<code>*smartInt = 5; <span class="color3">// Dereference the smart pointer.</span></code>
<code>println("{} ", *smartInt);</code>
<code> </code>
<code>Pointer&lt;SpreadsheetCell&gt; smartCell { new SpreadsheetCell };</code>
<code>smartCell-&gt;set(5); <span class="color3">// Dereference and member select the set() member function.</span></code>
<code>println("{} ", smartCell-&gt;getValue());</code></pre>
     <p>
      As you can see from this example, you have to provide implementations of
      <code>
       operator*
      </code>
      and
      <code>
       operator-&gt;
      </code>
      for this class. These are implemented in the next two sections.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c15-para-0218">
         <b>
          WARNING
         </b>
         <i>
          You should rarely, if ever, write an implementation of just one of
         </i>
         <code>
          operator*
         </code>
         <i>
          and
         </i>
         <code>
          operator-&gt;
         </code>
         <i>
          . You should almost always write both operators together. It would confuse the users of your class if you failed to provide both
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <span id="c15-sec-0037">
      </span>
      <h3 id="head-3-343">
       Implementing operator*
      </h3>
      <p id="c15-para-0219">
       When you dereference a pointer, you expect to be able to access the memory to which the pointer points. If that memory contains a simple type such as an
       <code>
        int
       </code>
       , you should be able to change its value directly. If the memory contains a more complicated type, such as an object, you should be able to access its data members or member functions with the
       <code>
        .
       </code>
       operator.
      </p>
      <p>
       To provide these semantics, you should return a reference from
       <code>
        operator*
       </code>
       . For the
       <code>
        Pointer
       </code>
       class this is done as follows:
      </p>
      <pre id="c15-code-0050"><code>export template &lt;typename T&gt; class Pointer</code>
<code>{</code>
<span aria-label="604" epub:type="pagebreak" id="Page_604" role="doc-pagebreak"></span><code>    public:</code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>        <b>T&amp; operator*() { return *m_ptr; }</b></code>
<code>        <b>const T&amp; operator*() const { return *m_ptr; }</b></code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>};</code></pre>
      <p id="c15-para-0221">
       As you can see,
       <code>
        operator*
       </code>
       returns a reference to the object or variable to which the underlying raw pointer points. As with overloading the subscripting operators earlier in this chapter, it's useful to provide both
       <code>
        const
       </code>
       and non-
       <code>
        const
       </code>
       overloads of the member function, which return a reference-to-
       <code>
        const
       </code>
       and a reference-to-non-
       <code>
        const
       </code>
       , respectively.
      </p>
     </section>
     <section>
      <span id="c15-sec-0038">
      </span>
      <h3 id="head-3-344">
       Implementing operator–&gt;
      </h3>
      <p>
       The arrow operator is a bit trickier. The result of applying the arrow operator should be a member or member function of an object. However, to implement it like that, you would have to be able to implement the equivalent of
       <code>
        operator*
       </code>
       followed by
       <code>
        operator.
       </code>
       ; C++ doesn't allow you to overload
       <code>
        operator.
       </code>
       for good reason: it's impossible to write a single prototype that allows you to capture any possible member or member function selection. Therefore, C++ treats
       <code>
        operator-&gt;
       </code>
       as a special case. Consider this line:
      </p>
      <pre id="c15-code-0051"><code>smartCell-&gt;set(5);</code></pre>
      <p>
       C++ translates this to the following:
      </p>
      <pre id="c15-code-0052"><code>(smartCell.operator-&gt;())-&gt;set(5);</code></pre>
      <p>
       As you can see, C++ applies another
       <code>
        operator-&gt;
       </code>
       to whatever you return from your overloaded
       <code>
        operator-&gt;
       </code>
       . Therefore, you must return a pointer, like this:
      </p>
      <pre id="c15-code-0053"><code>export template &lt;typename T&gt; class Pointer</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>        <b>T* operator-&gt;() { return m_ptr; }</b></code>
<code>        <b>const T* operator-&gt;() const { return m_ptr; }</b></code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>};</code></pre>
      <p id="c15-para-0225">
       You may find it confusing that
       <code>
        operator*
       </code>
       and
       <code>
        operator-&gt;
       </code>
       are asymmetric, but once you see them a few times, you'll get used to it.
      </p>
     </section>
     <section>
      <span id="c15-sec-0039">
      </span>
      <h3 id="head-3-345">
       What in the World Are operator.* and operator–&gt;*?
      </h3>
      <p id="c15-para-0226">
       It's perfectly legitimate in C++ to take the address of class data members and member functions to obtain pointers to them. However, you can't access a non-
       <code>
        static
       </code>
       data member or call a non-
       <code>
        static
       </code>
       member function without an object. The whole point of class data members and member functions is that they exist on a per-object basis. Thus, when you want to call the member function or access the data member via the pointer, you must dereference the pointer in the context of an object. The syntax details for using
       <code>
        operator.*
       </code>
       and
       <code>
        -&gt;*
       </code>
       is deferred until
       <a href="c19.xhtml">
        Chapter 19
       </a>
       , as it requires knowledge of how to define function pointers.
      </p>
      <p id="c15-para-0227">
       C++ does not allow you to overload
       <code>
        operator.*
       </code>
       (just as you can't overload
       <code>
        operator.
       </code>
       ), but you could overload
       <code>
        operator-&gt;*
       </code>
       . However, it is tricky, and, given that most C++ programmers don't
       <span aria-label="605" epub:type="pagebreak" id="Page_605" role="doc-pagebreak">
       </span>
       even know that you can access member functions and data members through pointers, it's probably not worth the trouble. The
       <code>
        shared_ptr
       </code>
       smart pointer in the Standard Library, for example, does not overload
       <code>
        operator-&gt;*
       </code>
       .
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-179">
     <span id="c15-sec-0040">
     </span>
     <h2 id="head-2-179">
      WRITING CONVERSION OPERATORS
     </h2>
     <p>
      Going back to the
      <code>
       SpreadsheetCell
      </code>
      example, consider these two lines of code:
     </p>
     <pre id="c15-code-0054"><code>SpreadsheetCell cell { 1.23 };</code>
<code>double d1 { cell }; <span class="color3">// DOES NOT COMPILE!</span></code></pre>
     <p>
      A
      <code>
       SpreadsheetCell
      </code>
      contains a
      <code>
       double
      </code>
      representation, so it seems logical that you could assign it to a
      <code>
       double
      </code>
      variable. Well, you can't. The compiler tells you that it doesn't know how to convert a
      <code>
       SpreadsheetCell
      </code>
      to a
      <code>
       double
      </code>
      . You might be tempted to try forcing the compiler to do what you want, like this:
     </p>
     <pre id="c15-code-0055"><code>double d1 { (double)cell }; <span class="color3">// STILL DOES NOT COMPILE!</span></code></pre>
     <p id="c15-para-0230">
      First, the preceding code still doesn't compile because the compiler still doesn't know
      <i>
       how
      </i>
      to convert the
      <code>
       SpreadsheetCell
      </code>
      to a
      <code>
       double
      </code>
      . It already knew from the first line what you wanted it to do, and it would do it if it could. Second, it's a bad idea in general to add gratuitous casts to your program.
     </p>
     <p>
      If you want to allow this kind of conversion, you must tell the compiler how to perform it. Specifically, you can write a conversion operator to convert
      <code>
       SpreadsheetCell
      </code>
      s to
      <code>
       double
      </code>
      s. The prototype looks like this:
     </p>
     <pre id="c15-code-0056"><code>operator double() const;</code></pre>
     <p>
      The name of the function is
      <code>
       operator double
      </code>
      . It has no return type because the return type is specified by the name of the operator:
      <code>
       double
      </code>
      . It is
      <code>
       const
      </code>
      because it doesn't change the object on which it is called. The implementation looks like this:
     </p>
     <pre id="c15-code-0057"><code>SpreadsheetCell::operator double() const</code>
<code>{</code>
<code>    return getValue();</code>
<code>}</code></pre>
     <p>
      That's all you need to do to write a conversion operator from
      <code>
       SpreadsheetCell
      </code>
      to
      <code>
       double
      </code>
      . Now the compiler accepts the following lines and does the right thing at run time:
     </p>
     <pre id="c15-code-0058"><code>SpreadsheetCell cell { 1.23 };</code>
<code>double d1 { cell }; <span class="color3">// Works as expected</span></code></pre>
     <p>
      You can write conversion operators for any type with this same syntax. For example, here is an
      <code>
       std::string
      </code>
      conversion operator for
      <code>
       SpreadsheetCell
      </code>
      :
     </p>
     <pre id="c15-code-0059"><code>operator std::string() const;</code></pre>
     <p>
      And here is an implementation:
     </p>
     <pre id="c15-code-0060"><code>SpreadsheetCell::operator std::string() const</code>
<code>{</code>
<code>    return doubleToString(getValue());</code>
<code>}</code></pre>
     <p>
      <span aria-label="606" epub:type="pagebreak" id="Page_606" role="doc-pagebreak">
      </span>
      Now you can convert a
      <code>
       SpreadsheetCell
      </code>
      to a
      <code>
       string
      </code>
      . However, due to the constructors provided by
      <code>
       string
      </code>
      , the following does not work:
     </p>
     <pre id="c15-code-0061"><code>string str { cell };</code></pre>
     <p>
      Instead, you can either use normal assignment syntax instead of uniform initialization, or use an explicit
      <code>
       static_cast()
      </code>
      as follows:
     </p>
     <pre id="c15-code-0062"><code>string str1 = cell;</code>
<code>string str2 { static_cast&lt;string&gt;(cell) };</code></pre>
     <section>
      <span id="c15-sec-0041">
      </span>
      <h3 id="head-3-346">
       Operator auto
      </h3>
      <p>
       Instead of explicitly specifying the type that a conversion operator returns, you can specify
       <code>
        auto
       </code>
       and let the compiler deduce it for you. For example, the
       <code>
        double
       </code>
       conversion operator of
       <code>
        SpreadsheetCell
       </code>
       could be written as follows:
      </p>
      <pre id="c15-code-0063"><code>operator auto() const { return getValue(); }</code></pre>
      <p id="c15-para-0239">
       There is one caveat, the implementation of member functions with
       <code>
        auto
       </code>
       return type deduction must be visible to users of the class. Hence, this example puts the implementation directly in the class definition.
      </p>
      <p>
       Also, remember from
       <a href="c01.xhtml">
        Chapter 1
       </a>
       that
       <code>
        auto
       </code>
       strips away reference and
       <code>
        const
       </code>
       qualifiers. So, if your operator
       <code>
        auto
       </code>
       returns a reference to a type
       <code>
        T
       </code>
       , then the deduced type will be
       <code>
        T
       </code>
       returned by value, resulting in a copy being made. If needed, you can explicitly add reference and
       <code>
        const
       </code>
       qualifiers; here's an example:
      </p>
      <pre id="c15-code-0064"><code>operator const auto&amp;() const { <span class="color3">/* … */</span> }</code></pre>
     </section>
     <section>
      <span id="c15-sec-0042">
      </span>
      <h3 id="head-3-347">
       Solving Ambiguity Problems with Explicit Conversion Operators
      </h3>
      <p>
       Writing the
       <code>
        double
       </code>
       conversion operator for the
       <code>
        SpreadsheetCell
       </code>
       object introduces an
       <i>
        ambiguity
       </i>
       problem. Consider this line:
      </p>
      <pre id="c15-code-0065"><code>SpreadsheetCell cell { 6.6 };</code>
<code><b>double d1 { cell + 3.4 };</b> <span class="color3">// DOES NOT COMPILE IF YOU DEFINE operator double()</span></code></pre>
      <p id="c15-para-0242">
       This line now fails to compile. It worked before you wrote
       <code>
        operator double()
       </code>
       , so what's the problem now? The issue is that the compiler doesn't know if it should convert
       <code>
        cell
       </code>
       to a
       <code>
        double
       </code>
       with
       <code>
        operator double()
       </code>
       and perform
       <code>
        double
       </code>
       addition, or convert
       <code>
        3.4
       </code>
       to a
       <code>
        SpreadsheetCell
       </code>
       with the
       <code>
        double
       </code>
       constructor and perform
       <code>
        SpreadsheetCell
       </code>
       addition. Before you wrote
       <code>
        operator double()
       </code>
       , the compiler had only one choice: convert
       <code>
        3.4
       </code>
       to a
       <code>
        SpreadsheetCell
       </code>
       with the
       <code>
        double
       </code>
       constructor and perform
       <code>
        SpreadsheetCell
       </code>
       addition. However, now the compiler could do either. It doesn't want to make a choice you might not like, so it refuses to make any choice at all.
      </p>
      <p>
       The usual pre-C++11 solution to this conundrum is to make the constructor in question
       <code>
        explicit
       </code>
       so that the automatic conversion using that constructor is prevented (see
       <a href="c08.xhtml">
        Chapter 8
       </a>
       ). However, you don't want that constructor to be
       <code>
        explicit
       </code>
       because you generally like the automatic conversion of
       <code>
        double
       </code>
       s to
       <code>
        SpreadsheetCell
       </code>
       s. Since C++11, you can solve this problem by making the
       <code>
        double
       </code>
       conversion operator
       <code>
        explicit
       </code>
       instead of the constructor:
      </p>
      <pre id="c15-code-0066"><code><b>explicit operator double() const;</b></code></pre>
      <p>
       <span aria-label="607" epub:type="pagebreak" id="Page_607" role="doc-pagebreak">
       </span>
       With this change the following line compiles fine:
      </p>
      <pre id="c15-code-0067"><code>double d1 { cell + 3.4 };  <span class="color3">// 10</span></code></pre>
      <p id="c15-para-0245">
       The operator
       <code>
        auto
       </code>
       as discussed in the previous section can also be marked as
       <code>
        explicit
       </code>
       .
      </p>
     </section>
     <section>
      <span id="c15-sec-0043">
      </span>
      <h3 id="head-3-348">
       Conversions for Boolean Expressions
      </h3>
      <p>
       Sometimes it is useful to be able to use objects in Boolean expressions. For example, programmers often use pointers in conditional statements like this:
      </p>
      <pre id="c15-code-0068"><code>if (ptr != nullptr) { <span class="color3">/* Perform some dereferencing action. */</span> }</code></pre>
      <p>
       Sometimes they write shorthand conditions such as this:
      </p>
      <pre id="c15-code-0069"><code>if (ptr) { <span class="color3">/* Perform some dereferencing action. */</span> }</code></pre>
      <p>
       Other times, you see code as follows:
      </p>
      <pre id="c15-code-0070"><code>if (!ptr) { <span class="color3">/* Do something. */</span> }</code></pre>
      <p>
       Currently, none of the preceding expressions compile with the
       <code>
        Pointer
       </code>
       smart pointer class template defined earlier. To make them work, we can add a conversion operator to the class to convert it to a pointer type. Then, the comparisons to
       <code>
        nullptr
       </code>
       , as well as the object alone in an
       <code>
        if
       </code>
       statement, will trigger the conversion to the pointer type. The usual pointer type for the conversion operator is
       <code>
        void*
       </code>
       , because that's a pointer type with which you cannot do much except test it in Boolean expressions. Here is the implementation:
      </p>
      <pre id="c15-code-0071"><code>operator void*() const { return m_ptr; }</code></pre>
      <p>
       Now the following code compiles and does what you expect:
      </p>
      <pre id="c15-code-0072"><code>void process(const Pointer&lt;SpreadsheetCell&gt;&amp; p)</code>
<code>{</code>
<code>    if (p != nullptr) { println("not nullptr"); }</code>
<code>    if (p != 0)       { println("not 0"); }</code>
<code>    if (p)            { println("not nullptr"); }</code>
<code>    if (!p)           { println("nullptr"); }</code>
<code>}</code>
<code> </code>
<code>int main()</code>
<code>{</code>
<code>    Pointer&lt;SpreadsheetCell&gt; smartCell { nullptr };</code>
<code>    process(smartCell);</code>
<code>    println("");</code>
<code> </code>
<code>    Pointer&lt;SpreadsheetCell&gt; anotherSmartCell { new SpreadsheetCell { 5.0 } };</code>
<code>    process(anotherSmartCell);</code>
<code>}</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c15-code-0073"><code>nullptr</code>
<code> </code>
<code>not nullptr</code>
<code>not 0</code>
<code>not nullptr</code></pre>
      <p>
       <span aria-label="608" epub:type="pagebreak" id="Page_608" role="doc-pagebreak">
       </span>
       Another alternative is to overload
       <code>
        operator bool()
       </code>
       as follows instead of
       <code>
        operator void*()
       </code>
       . After all, you're using the object in a Boolean expression; why not convert it directly to a
       <code>
        bool
       </code>
       ?
      </p>
      <pre id="c15-code-0074"><code>operator bool() const { return m_ptr != nullptr; }</code></pre>
      <p>
       The following comparisons still work:
      </p>
      <pre id="c15-code-0075"><code>if (p != 0)    { println("not 0"); }</code>
<code>if (p)         { println("not nullptr"); }</code>
<code>if (!p)        { println("nullptr"); }</code></pre>
      <p>
       However, with
       <code>
        operator bool()
       </code>
       , the following comparison with
       <code>
        nullptr
       </code>
       results in a compilation error:
      </p>
      <pre id="c15-code-0076"><code>if (p != nullptr) { println("not nullptr"); }  <span class="color3">// Error</span></code></pre>
      <p>
       This is because
       <code>
        nullptr
       </code>
       has its own type called
       <code>
        nullptr_t
       </code>
       , which is not automatically converted to the integer 0 (
       <code>
        false
       </code>
       ). The compiler cannot find an
       <code>
        operator!=
       </code>
       that takes a
       <code>
        Pointer
       </code>
       object and a
       <code>
        nullptr_t
       </code>
       object. You could implement such an
       <code>
        operator!=
       </code>
       as a
       <code>
        friend
       </code>
       of the
       <code>
        Pointer
       </code>
       class:
      </p>
      <pre id="c15-code-0077"><code>export template &lt;typename T&gt;</code>
<code>class Pointer</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>        template &lt;typename T&gt;</code>
<code>        friend bool operator!=(const Pointer&lt;T&gt;&amp; lhs, std::nullptr_t rhs);</code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>};</code>
<code> </code>
<code>export template &lt;typename T&gt;</code>
<code>bool operator!=(const Pointer&lt;T&gt;&amp; lhs, std::nullptr_t rhs)</code>
<code>{</code>
<code>    return lhs.m_ptr != rhs;</code>
<code>}</code></pre>
      <p>
       However, after implementing this
       <code>
        operator!=
       </code>
       , the following comparison stops working, because the compiler no longer knows which
       <code>
        operator!=
       </code>
       to use:
      </p>
      <pre id="c15-code-0078"><code>if (p != 0)    { println("not 0"); }</code></pre>
      <p>
       From this example, you might conclude that the
       <code>
        operator bool()
       </code>
       technique only seems appropriate for objects that don't represent pointers and for which conversion to a pointer type really doesn't make sense. Unfortunately, even then, adding a conversion operator to
       <code>
        bool
       </code>
       presents some other unanticipated consequences. C++ applies
       <i>
        promotion
       </i>
       rules to silently convert
       <code>
        bool
       </code>
       to
       <code>
        int
       </code>
       whenever the opportunity arises. Therefore, with the
       <code>
        operator bool()
       </code>
       , the following code compiles and runs:
      </p>
      <pre id="c15-code-0079"><code>Pointer&lt;SpreadsheetCell&gt; anotherSmartCell { new SpreadsheetCell { 5.0 } };</code>
<code>int i { anotherSmartCell }; <span class="color3">// Converts Pointer to bool to int.</span></code></pre>
      <p id="c15-para-0258">
       That's usually not behavior that you expect or desire. To prevent such assignments, you could explicitly delete the conversion operators to
       <code>
        int
       </code>
       ,
       <code>
        long
       </code>
       ,
       <code>
        long long
       </code>
       , and so on. However, this is getting messy. So, many programmers prefer
       <code>
        operator void*()
       </code>
       instead of
       <code>
        operator bool()
       </code>
       .
      </p>
      <p id="c15-para-0259">
       As you can see, there is a design element to overloading operators. Your decisions about which operators to overload directly influence the ways in which clients can use your classes.
      </p>
     </section>
    </section>
    <span aria-label="609" epub:type="pagebreak" id="Page_609" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-180">
     <span id="c15-sec-0044">
     </span>
     <h2 id="head-2-180">
      OVERLOADING THE MEMORY ALLOCATION AND DEALLOCATION OPERATORS
     </h2>
     <p>
      C++ gives you the ability to redefine the way memory allocation and deallocation work in your programs. You can provide this customization both on the global level and the class level. This capability is most useful when you are worried about memory fragmentation, which can occur if you allocate and deallocate a lot of small objects. For example, instead of going to the default C++ memory allocation each time you need memory, you could write a memory pool allocator that reuses fixed-size chunks of memory. This section explains the subtleties of the memory allocation and deallocation routines and shows you how to customize them. With these tools, you should be able to write your own allocator if the need ever arises.
     </p>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature1">
        <p id="c15-para-0261">
         <b>
          WARNING
         </b>
         <i>
          Unless you know a lot about memory allocation strategies, attempts to overload the memory allocation routines are rarely worth the trouble. Don't overload them just because it sounds like a neat idea. Only do so if you have a genuine requirement and the necessary knowledge
         </i>
         .
        </p>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <section>
      <span id="c15-sec-0046">
      </span>
      <h3 id="head-3-349">
       How new and delete Really Work
      </h3>
      <p>
       One of the trickiest aspects of C++ is the details of
       <code>
        new
       </code>
       and
       <code>
        delete
       </code>
       . Consider this line of code:
      </p>
      <pre id="c15-code-0080"><code>SpreadsheetCell* cell { new SpreadsheetCell {} };</code></pre>
      <p id="c15-para-0263">
       The part
       <code>
        new SpreadsheetCell{}
       </code>
       is called the
       <i>
        new-expression
       </i>
       . It does two things. First, it allocates space for the
       <code>
        SpreadsheetCell
       </code>
       object by making a call to
       <code>
        operator new
       </code>
       . Second, it calls the constructor for the object. Only after the constructor has completed does it return the pointer to you.
      </p>
      <p>
       <code>
        delete
       </code>
       works analogously. Consider this line of code:
      </p>
      <pre id="c15-code-0081"><code>delete cell;</code></pre>
      <p id="c15-para-0265">
       This line is called the
       <i>
        delete-expression
       </i>
       . It first calls the destructor for
       <code>
        cell
       </code>
       and then calls
       <code>
        operator delete
       </code>
       to free the memory.
      </p>
      <p id="c15-para-0266">
       You can overload
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       to control memory allocation and deallocation, but you cannot overload the new-expression or the delete-expression. Thus, you can customize the actual memory allocation and deallocation, but not the calls to the constructor and destructor.
      </p>
      <section>
       <span id="c15-sec-0047">
       </span>
       <h4 id="head-4-249">
        The New-Expression and operator new
       </h4>
       <p>
        There are six different forms of the
        <i>
         new-expression
        </i>
        , each of which has a corresponding
        <code>
         operator new
        </code>
        . Earlier chapters in this book already show four new-expressions:
        <code>
         new
        </code>
        ,
        <code>
         new[]
        </code>
        ,
        <code>
         new(nothrow)
        </code>
        , and
        <code>
         new(nothrow)[]
        </code>
        . The following list shows the corresponding four
        <code>
         operator new
        </code>
        overloads defined in
        <code>
         &lt;new&gt;
        </code>
        :
       </p>
       <pre id="c15-code-0082"><code>void* operator new(std::size_t size);</code>
<code>void* operator new[](std::size_t size);</code>
<code>void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;</code>
<code>void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;</code></pre>
       <p>
        <span aria-label="610" epub:type="pagebreak" id="Page_610" role="doc-pagebreak">
        </span>
        There are two special new-expressions that don't do any allocation but invoke the constructor on an already allocated piece of memory. These are called
        <i>
         placement new operators
        </i>
        (including both single and array forms). They allow you to construct an object in pre-allocated memory like this:
       </p>
       <pre id="c15-code-0083"><code>void* ptr { allocateMemorySomehow() };</code>
<code>SpreadsheetCell* cell { new (ptr) SpreadsheetCell {} };</code></pre>
       <p>
        The two corresponding
        <code>
         operator new
        </code>
        overloads for these look as follows; however, the C++ standard forbids you to overload them:
       </p>
       <pre id="c15-code-0084"><code>void* operator new(std::size_t size, void* p) noexcept;</code>
<code>void* operator new[](std::size_t size, void* p) noexcept;</code></pre>
       <p id="c15-para-0270">
        This feature is a bit obscure, but it's important to know that it exists. It can come in handy if you want to implement memory pools by reusing memory without freeing it in between. This allows you to construct and destruct instances of an object without re-allocating memory for each new instance.
        <a href="c29.xhtml">
         Chapter 29
        </a>
        , “Writing Efficient C++,” gives an example of a memory pool implementation.
       </p>
      </section>
      <section>
       <span id="c15-sec-0048">
       </span>
       <h4 id="head-4-250">
        The Delete-Expression and operator delete
       </h4>
       <p id="c15-para-0271">
        There are only two different forms of the
        <i>
         delete-expression
        </i>
        that you can call:
        <code>
         delete
        </code>
        , and
        <code>
         delete[]
        </code>
        ; there are no
        <code>
         nothrow
        </code>
        or placement forms. However, there are all six overloads of
        <code>
         operator delete
        </code>
        . Why the asymmetry? The two
        <code>
         nothrow
        </code>
        and two placement overloads are used only if an exception is thrown from a constructor. In that case, the
        <code>
         operator delete
        </code>
        is called that matches the
        <code>
         operator new
        </code>
        that was used to allocate the memory prior to the constructor call. However, if you delete a pointer normally,
        <code>
         delete
        </code>
        calls
        <code>
         operator delete
        </code>
        and
        <code>
         delete[]
        </code>
        calls
        <code>
         operator delete[]
        </code>
        (never the
        <code>
         nothrow
        </code>
        or placement forms). Practically, this doesn't really matter because the C++ standard says that throwing an exception from
        <code>
         delete
        </code>
        (for example, from a destructor called by
        <code>
         delete
        </code>
        ) results in undefined behavior. This means
        <code>
         delete
        </code>
        should never throw an exception anyway, so the
        <code>
         nothrow
        </code>
        overload of
        <code>
         operator delete
        </code>
        is superfluous. Also, placement
        <code>
         delete
        </code>
        should be a no-op, because placement
        <code>
         new
        </code>
        doesn't allocate any memory, so there's nothing to free.
       </p>
       <p>
        Here are the prototypes for the six
        <code>
         operator delete
        </code>
        overloads corresponding to the six
        <code>
         operator new
        </code>
        overloads:
       </p>
       <pre id="c15-code-0085"><code>void operator delete(void* ptr) noexcept;</code>
<code>void operator delete[](void* ptr) noexcept;</code>
<code>void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code>void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code>void operator delete(void* ptr, void*) noexcept;</code>
<code>void operator delete[](void* ptr, void*) noexcept;</code></pre>
      </section>
     </section>
     <section>
      <span id="c15-sec-0049">
      </span>
      <h3 id="head-3-350">
       Overloading operator new and operator delete
      </h3>
      <p>
       You can replace the global
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       routines if you want. These functions are called for every new-expression and delete-expression in the program, unless there are more specific routines in individual classes. However, to quote Bjarne Stroustrup, “… replacing the global
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       is not for the fainthearted” (
       <i>
        The C++ Programming Language
       </i>
       , third edition, Addison-Wesley, 1997). I don't recommend it either!
       <span aria-label="611" epub:type="pagebreak" id="Page_611" role="doc-pagebreak">
       </span>
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0274">
          <b>
           WARNING
          </b>
          <i>
           If you fail to heed my advice and decide to replace the global
          </i>
          <code>
           operator new
          </code>
          <i>
           , keep in mind that you cannot put any code in the operator that makes a call to
          </i>
          <code>
           new
          </code>
          <i>
           because this will cause an infinite recursion. For example, you cannot write a message to the console with
          </i>
          <code>
           print()
          </code>
          <i>
           .
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       A more useful technique is to overload
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       for specific classes. These overloaded operators will be called only when you allocate and deallocate objects of that particular class. Here is an example of a class that overloads the four non-placement forms of
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       :
      </p>
      <pre id="c15-code-0086"><code>export class MemoryDemo</code>
<code>{</code>
<code>    public:</code>
<code>        virtual ˜MemoryDemo() = default;</code>
<code> </code>
<code>        void* operator new(std::size_t size);</code>
<code>        void operator delete(void* ptr) noexcept;</code>
<code> </code>
<code>        void* operator new[](std::size_t size);</code>
<code>        void operator delete[](void* ptr) noexcept;</code>
<code> </code>
<code>        void* operator new(std::size_t size, const std::nothrow_t&amp;) noexcept;</code>
<code>        void operator delete(void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code> </code>
<code>        void* operator new[](std::size_t size, const std::nothrow_t&amp;) noexcept;</code>
<code>        void operator delete[](void* ptr, const std::nothrow_t&amp;) noexcept;</code>
<code>};</code></pre>
      <p>
       Here are implementations of these operators that simply write out a message to the standard output and pass the arguments through to calls to the global versions of the operators. Note that
       <code>
        nothrow
       </code>
       is actually a variable of type
       <code>
        nothrow_t
       </code>
       .
      </p>
      <pre id="c15-code-0087"><code>void* MemoryDemo::operator new(size_t size)</code>
<code>{</code>
<code>    println("operator new");</code>
<code>    return ::operator new(size);</code>
<code>}</code>
<code>void MemoryDemo::operator delete(void* ptr) noexcept</code>
<code>{</code>
<code>    println("operator delete");</code>
<code>    ::operator delete(ptr);</code>
<code>}</code>
<code>void* MemoryDemo::operator new[](size_t size)</code>
<code>{</code>
<code>    println("operator new[]");</code>
<code>    return ::operator new[](size);</code>
<code>}</code>
<code>void MemoryDemo::operator delete[](void* ptr) noexcept</code>
<code>{</code>
<code>    println("operator delete[]");</code>
<code>    ::operator delete[](ptr);</code>
<code>}</code>
<span aria-label="612" epub:type="pagebreak" id="Page_612" role="doc-pagebreak"></span><code>void* MemoryDemo::operator new(size_t size, const nothrow_t&amp;) noexcept</code>
<code>{</code>
<code>    println("operator new nothrow");</code>
<code>    return ::operator new(size, nothrow);</code>
<code>}</code>
<code>void MemoryDemo::operator delete(void* ptr, const nothrow_t&amp;) noexcept</code>
<code>{</code>
<code>    println("operator delete nothrow");</code>
<code>    ::operator delete(ptr, nothrow);</code>
<code>}</code>
<code>void* MemoryDemo::operator new[](size_t size, const nothrow_t&amp;) noexcept</code>
<code>{</code>
<code>    println("operator new[] nothrow");</code>
<code>    return ::operator new[](size, nothrow);</code>
<code>}</code>
<code>void MemoryDemo::operator delete[](void* ptr, const nothrow_t&amp;) noexcept</code>
<code>{</code>
<code>    println("operator delete[] nothrow");</code>
<code>    ::operator delete[](ptr, nothrow);</code>
<code>}</code></pre>
      <p>
       Here is some code that allocates and frees objects of this class in several ways:
      </p>
      <pre id="c15-code-0088"><code>MemoryDemo* mem { new MemoryDemo{} };</code>
<code>delete mem;</code>
<code>mem = new MemoryDemo[10];</code>
<code>delete [] mem;</code>
<code>mem = new (nothrow) MemoryDemo{};</code>
<code>delete mem;</code>
<code>mem = new (nothrow) MemoryDemo[10];</code>
<code>delete [] mem;</code></pre>
      <p>
       Here is the output from running the program:
      </p>
      <pre id="c15-code-0089"><code>operator new</code>
<code>operator delete</code>
<code>operator new[]</code>
<code>operator delete[]</code>
<code>operator new nothrow</code>
<code>operator delete</code>
<code>operator new[] nothrow</code>
<code>operator delete[]</code></pre>
      <p>
       These implementations of
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       are obviously trivial and not particularly useful. They are intended only to give you an idea of the syntax in case you ever want to implement nontrivial versions of them.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0280">
          <b>
           WARNING
          </b>
          <i>
           Whenever you overload
          </i>
          <code>
           operator new
          </code>
          <i>
           , overload the corresponding form of
          </i>
          <code>
           operator delete
          </code>
          <i>
           . Otherwise, memory will be allocated as you specify but freed according to the built-in semantics, which may not be compatible
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       <span aria-label="613" epub:type="pagebreak" id="Page_613" role="doc-pagebreak">
       </span>
       It might seem overkill to overload all the various forms of
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       . However, it's generally a good idea to do so to prevent inconsistencies in memory allocations. If you don't want to provide implementations for certain overloads, you can explicitly delete these using
       <code>
        =delete
       </code>
       to prevent anyone from using them. See the next section for more information.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0282">
          <b>
           WARNING
          </b>
          <i>
           Overload all forms of
          </i>
          <code>
           operator new
          </code>
          <i>
           and
          </i>
          <code>
           operator delete
          </code>
          <i>
           , or explicitly delete overloads that you don't want to get used, to prevent inconsistencies in the memory allocations
          </i>
          .
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c15-sec-0053">
      </span>
      <h3 id="head-3-351">
       Explicitly Deleting or Defaulting operator new and operator delete
      </h3>
      <p>
       <a href="c08.xhtml">
        Chapter 8
       </a>
       shows how you can explicitly delete or default a constructor or assignment operator. Explicitly deleting or defaulting is not limited to constructors and assignment operators. For example, the following class deletes
       <code>
        operator new
       </code>
       and
       <code>
        new[]
       </code>
       , which means that objects of this class cannot be dynamically allocated using
       <code>
        new
       </code>
       or
       <code>
        new[]
       </code>
       :
      </p>
      <pre id="c15-code-0090"><code>class MyClass</code>
<code>{</code>
<code>    public:</code>
<code>        void* operator new(std::size_t) = delete;</code>
<code>        void* operator new[](std::size_t) = delete;</code>
<code>        void* operator new(std::size_t, const std::nothrow_t&amp;) noexcept = delete;</code>
<code>        void* operator new[](std::size_t, const std::nothrow_t&amp;) noexcept = delete;</code>
<code>};</code></pre>
      <p>
       Using this class as follows results in compilation errors:
      </p>
      <pre id="c15-code-0091"><code>MyClass* p1 { new MyClass };</code>
<code>MyClass* p2 { new MyClass[2] };</code>
<code>MyClass* p3 { new (std::nothrow) MyClass };</code></pre>
     </section>
     <section>
      <span id="c15-sec-0054">
      </span>
      <h3 id="head-3-352">
       Overloading operator new and operator delete with Extra Parameters
      </h3>
      <p id="c15-para-0285">
       In addition to overloading the standard forms of
       <code>
        operator new
       </code>
       , you can write your own versions with extra parameters. These extra parameters can be useful for passing various flags or counters to your memory allocation routines. For instance, some runtime libraries use this in debug mode to provide the filename and line number where an object is allocated, so when there is a memory leak, the offending line that did the allocation can be identified.
      </p>
      <p>
       As an example, here are the prototypes for an additional
       <code>
        operator new
       </code>
       and
       <code>
        operator delete
       </code>
       with an extra integer parameter for the
       <code>
        MemoryDemo
       </code>
       class:
      </p>
      <pre id="c15-code-0092"><code>void* operator new(std::size_t size, int extra);</code>
<code>void operator delete(void* ptr, int extra) noexcept;</code></pre>
      <p>
       <span aria-label="614" epub:type="pagebreak" id="Page_614" role="doc-pagebreak">
       </span>
       The implementations are as follows:
      </p>
      <pre id="c15-code-0093"><code>void* MemoryDemo::operator new(std::size_t size, int extra)</code>
<code>{</code>
<code>    println("operator new with extra int: {}", extra);</code>
<code>    return ::operator new(size);</code>
<code>}</code>
<code>void MemoryDemo::operator delete(void* ptr, int extra) noexcept</code>
<code>{</code>
<code>    println("operator delete with extra int: {}", extra);</code>
<code>    return ::operator delete(ptr);</code>
<code>}</code></pre>
      <p>
       When you write an overloaded
       <code>
        operator new
       </code>
       with extra parameters, the compiler automatically allows the corresponding new-expression. The extra arguments to
       <code>
        new
       </code>
       are passed with function call syntax (as with
       <code>
        nothrow
       </code>
       overloads). So, you can now write code like this:
      </p>
      <pre id="c15-code-0094"><code>MemoryDemo* memp { new(5) MemoryDemo{} };</code>
<code>delete memp;</code></pre>
      <p>
       The output is as follows:
      </p>
      <pre id="c15-code-0095"><code>operator new with extra int: 5</code>
<code>operator delete</code></pre>
      <p id="c15-para-0290">
       When you define an
       <code>
        operator new
       </code>
       with extra parameters, you should also define the corresponding
       <code>
        operator delete
       </code>
       with the same extra parameters. However, you cannot call this
       <code>
        operator delete
       </code>
       with extra parameters yourself; it will be called only when you use your
       <code>
        operator new
       </code>
       with extra parameters and the constructor of your object throws an exception.
      </p>
     </section>
     <section>
      <span id="c15-sec-0055">
      </span>
      <h3 id="head-3-353">
       Overloading operator delete with Size of Memory as Parameter
      </h3>
      <p>
       An alternate form of
       <code>
        operator delete
       </code>
       gives you the size of the memory that should be freed as well as the pointer. Simply declare the prototype for
       <code>
        operator delete
       </code>
       with an extra size parameter.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c15-para-0292">
          <b>
           WARNING
          </b>
          <i>
           If a class declares two overloads of
          </i>
          <code>
           operator delete
          </code>
          <i>
           with one overload taking the size as a parameter and the other doesn't, the overload without the size parameter will always get called. If you want the overload with the size parameter to be used, write only that overload.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
      <p>
       You can replace
       <code>
        operator delete
       </code>
       with an overload that takes a size for any of the overloads of
       <code>
        operator delete
       </code>
       independently. Here is the
       <code>
        MemoryDemo
       </code>
       class definition with the first
       <code>
        operator delete
       </code>
       modified to take the size of the memory to be deleted:
      </p>
      <pre id="c15-code-0096"><code>export class MemoryDemo</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>        void* operator new(std::size_t size);</code>
<code>        <b>void operator delete(void* ptr, std::size_t size) noexcept;</b></code>
<code>        <span class="color3">// Omitted for brevity</span></code>
<code>};</code></pre>
      <p>
       <span aria-label="615" epub:type="pagebreak" id="Page_615" role="doc-pagebreak">
       </span>
       The implementation of this
       <code>
        operator delete
       </code>
       again simply calls the global
       <code>
        operator delete
       </code>
       :
      </p>
      <pre id="c15-code-0097"><code>void MemoryDemo::operator delete(void* ptr, size_t size) noexcept</code>
<code>{</code>
<code>    println("operator delete with size {}", size);</code>
<code>    ::operator delete(ptr, size);</code>
<code>}</code></pre>
      <p id="c15-para-0295">
       This capability is useful only if you are writing a complicated memory allocation and deallocation scheme for your classes.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-181">
     <span id="c15-sec-0057">
     </span>
     <h2 id="head-2-181">
      OVERLOADING USER-DEFINED LITERAL OPERATORS
     </h2>
     <p>
      C++ has a number of built-in literal types that you can use in your code. Here are some examples:
     </p>
     <ul class="check1" id="c15-list-0005">
      <li id="c15-li-0025">
       <code>
        'a'
       </code>
       : Character
      </li>
      <li id="c15-li-0026">
       <code>
        "A string"
       </code>
       : Zero-terminated sequence of characters, C-style string
      </li>
      <li id="c15-li-0027">
       <code>
        3.14f
       </code>
       :
       <code>
        float
       </code>
       single-precision floating-point value
      </li>
      <li id="c15-li-0028">
       <code>
        0xabc
       </code>
       : Hexadecimal value
      </li>
     </ul>
     <p id="c15-para-0297">
      C++ also allows you to define your own literals, and the Standard Library does exactly that; it provides a number of additional literal types to construct Standard Library objects. Let's take a look at these first and then see how you can define your own.
     </p>
     <section>
      <span id="c15-sec-0058">
      </span>
      <h3 id="head-3-354">
       Standard Library Literals
      </h3>
      <p id="c15-para-0298">
       The C++ Standard Library defines the following standard literals. Note that these literals do not start with an underscore:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          LITERAL
         </th>
         <th class="left bgcolor2" scope="col">
          CREATES INSTANCES OF …
         </th>
         <th class="left bgcolor2" scope="col">
          EXAMPLE
         </th>
         <th class="left bgcolor2" scope="col">
          REQUIRES NAMESPACE
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           s
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           string
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           auto myString { "Hello"s };
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           string_literals
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           sv
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           string_view
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           auto myStringView { "Hello"sv };
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           string_view_literals
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           h,
           <code>
            min
           </code>
           ,
           <code>
            s
           </code>
           ,
           <code>
            ms
           </code>
           ,
           <code>
            us
           </code>
           ,
           <code>
            ns
           </code>
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           chrono::duration
           <a href="#c15-note-0001" id="R_c15-note-0001">
            <sup>
             1
            </sup>
           </a>
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           auto myDuration { 42min };
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           chrono_literals
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           y,
           <code>
            d
           </code>
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           chrono::year
          </code>
          and
          <code>
           day
          </code>
          <sup>
           <a href="#c15-note-0001">
            <code>
             1
            </code>
           </a>
          </sup>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           auto thisYear { 2024y };
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           chrono_literals
          </code>
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           i,
           <code>
            il
           </code>
           ,
           <code>
            if
           </code>
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           complex&lt;T&gt;
          </code>
          with
          <code>
           T
          </code>
          equal to
          <code>
           double
          </code>
          ,
          <code>
           long double
          </code>
          ,
          <code>
           float
          </code>
          , respectively
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           auto myComplexNumber { 1.3i };
          </code>
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           complex_literals
          </code>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="tableFootnote" id="c15-note-0001">
       <a href="#R_c15-note-0001" role="doc-backlink">
        <sup>
         1
        </sup>
       </a>
       Discussed in
       <a href="c22.xhtml">
        Chapter 22
       </a>
       , “Date and Time Utilities.”
      </p>
      <p>
       <span aria-label="616" epub:type="pagebreak" id="Page_616" role="doc-pagebreak">
       </span>
       Technically, all of these are defined in subnamespaces of
       <code>
        std::literals
       </code>
       , for example
       <code>
        std::literals::string_literals
       </code>
       . However, both
       <code>
        string_literals
       </code>
       and
       <code>
        literals
       </code>
       are inline namespaces that automatically make their contents available in their parent namespace. Hence, if you want to use
       <code>
        s
       </code>
       string literals, you can use any of the following
       <code>
        using
       </code>
       directives:
      </p>
      <pre id="c15-code-0098"><code>using namespace std;</code>
<code>using namespace std::literals;</code>
<code>using namespace std::string_literals;</code>
<code>using namespace std::literals::string_literals;</code></pre>
     </section>
     <section>
      <span id="c15-sec-0059">
      </span>
      <h3 id="head-3-355">
       User-Defined Literals
      </h3>
      <p id="c15-para-0302">
       User-defined literals should start with exactly one underscore. Some examples are
       <code>
        _i
       </code>
       ,
       <code>
        _s
       </code>
       ,
       <code>
        _km
       </code>
       ,
       <code>
        _miles
       </code>
       ,
       <code>
        _K
       </code>
       , and so on.
      </p>
      <p id="c15-para-0303">
       User-defined literals are implemented by writing
       <i>
        literal operators
       </i>
       . A literal operator can work in
       <i>
        raw
       </i>
       or
       <i>
        cooked
       </i>
       mode. In raw mode, your literal operator receives a sequence of characters, while in cooked mode your literal operator receives a specific interpreted type. For example, take the C++ literal
       <code>
        123
       </code>
       . A raw literal operator receives this as a sequence of characters
       <code>
        '1'
       </code>
       ,
       <code>
        '2'
       </code>
       ,
       <code>
        '3'
       </code>
       . A cooked literal operator receives this as the integer 123. The literal
       <code>
        0x23
       </code>
       is received by a raw operator as the characters
       <code>
        '0'
       </code>
       ,
       <code>
        'x'
       </code>
       ,
       <code>
        '2'
       </code>
       ,
       <code>
        '3'
       </code>
       , while a cooked operator receives the integer 35. A literal such as
       <code>
        3.14
       </code>
       is received by a raw operator as
       <code>
        '3'
       </code>
       ,
       <code>
        '.'
       </code>
       ,
       <code>
        '1'
       </code>
       ,
       <code>
        '4'
       </code>
       , while a cooked operator receives the floating-point value 3.14.
      </p>
      <section>
       <span id="c15-sec-0060">
       </span>
       <h4 id="head-4-251">
        Cooked-Mode Literal Operator
       </h4>
       <p>
        A cooked-mode literal operator should have either of the following:
       </p>
       <ul class="check1" id="c15-list-0006">
        <li id="c15-li-0029">
         <b>
          To process numeric values:
         </b>
         One parameter of type
         <code>
          unsigned long long
         </code>
         ,
         <code>
          long double
         </code>
         ,
         <code>
          char
         </code>
         ,
         <code>
          wchar_t
         </code>
         ,
         <code>
          char8_t
         </code>
         ,
         <code>
          char16_t
         </code>
         , or
         <code>
          char32_t
         </code>
        </li>
        <li id="c15-li-0030">
         <b>
          To process strings:
         </b>
         Two parameters where the first is a C-style string and the second is the length of the string, for instance,
         <code>
          (const char* str
         </code>
         ,
         <code>
          std::size_t len)
         </code>
        </li>
       </ul>
       <p>
        For example, the following code defines a
        <code>
         Length
        </code>
        class storing a length in meters. The constructor is
        <code>
         private
        </code>
        because users should only be able to construct a
        <code>
         Length
        </code>
        instance using the provided user-defined literals. The code provides cooked literal operators for user-defined literal operators
        <code>
         _km
        </code>
        and
        <code>
         _m
        </code>
        . Both of these are friends of
        <code>
         Length
        </code>
        so that they can access the
        <code>
         private
        </code>
        constructor. There must not be any space between the
        <code>
         ""
        </code>
        and the underscore of these operators.
       </p>
       <pre id="c15-code-0099"><code><span class="color3">// A class representing a length. The length is always stored in meters.</span></code>
<code>class Length</code>
<code>{</code>
<code>    public:</code>
<code>        long double getMeters() const { return m_length; }</code>
<code>        <span class="color3">// The user-defined literals _km and _m are friends of Length so they</span></code>
<code>        <span class="color3">// can use the private constructor.</span></code>
<code>        friend Length operator ""_km(long double d);</code>
<code>        friend Length operator ""_m(long double d);</code>
<code>    private:</code>
<code>        <span class="color3">// Private constructor because users should only be able to construct a</span></code>
<code>        <span class="color3">// Length using the provided user-defined literals.</span></code>
<code>        Length(long double length) : m_length { length } {}</code>
<code>        long double m_length;</code>
<span aria-label="617" epub:type="pagebreak" id="Page_617" role="doc-pagebreak"></span><code>};</code>
<code>Length operator ""_km(long double d) <span class="color3">// Cooked _km literal operator</span></code>
<code>{</code>
<code>    return Length { d * 1000 }; <span class="color3">// Convert to meters.</span></code>
<code>}</code>
<code><span class="color3">Length operator ""_m(long double d) // Cooked _m literal operator</span></code>
<code>{</code>
<code>    return Length { d };</code>
<code>}</code></pre>
       <p>
        These literal operators can be used as follows:
       </p>
       <pre id="c15-code-0100"><code>Length d1 { 1.2_km };</code>
<code>auto d2 { 1.2_m };</code>
<code>println("d1 = {}m; d2 = {}m", d1.getMeters(), d2.getMeters());</code></pre>
       <p>
        Here is the output:
       </p>
       <pre id="c15-code-0101"><code>d1 = 1200m; d2 = 1.2m</code></pre>
       <p>
        To demonstrate the variant of a cooked literal operator accepting a
        <code>
         const char*
        </code>
        and a
        <code>
         size_t
        </code>
        , we can re-create the standard string literal,
        <code>
         s
        </code>
        , provided by the Standard Library, to construct an
        <code>
         std::string
        </code>
        . Let's call the literal
        <code>
         _s
        </code>
        .
       </p>
       <pre id="c15-code-0102"><code>string operator ""_s(const char* str, size_t len)</code>
<code>{</code>
<code>    return string { str, len };</code>
<code>}</code></pre>
       <p>
        This literal operator can be used as follows:
       </p>
       <pre id="c15-code-0103"><code>string str1 { "Hello World"_s };</code>
<code>auto str2 { "Hello World"_s };   <span class="color3">// str2 has as type string</span></code></pre>
       <p>
        Without the
        <code>
         _s
        </code>
        literal operator, the
        <code>
         auto
        </code>
        type deduction would result in
        <code>
         const char*
        </code>
        :
       </p>
       <pre id="c15-code-0104"><code>auto str3 { "Hello World" };     <span class="color3">// str3 has as type const char*</span></code></pre>
      </section>
      <section>
       <span id="c15-sec-0061">
       </span>
       <h4 id="head-4-252">
        Raw-Mode Literal Operator
       </h4>
       <p>
        A raw-mode literal operator requires one parameter of type
        <code>
         const char*
        </code>
        , a zero-terminated C-style string. The following example defines the earlier literal operator
        <code>
         _m
        </code>
        as a raw literal operator:
       </p>
       <pre id="c15-code-0105"><code>Length operator ""_m(const char* str)</code>
<code>{</code>
<code>    <span class="color3">// Implementation omitted; it requires parsing the C-style string</span></code>
<code>    <span class="color3">// converting it to a long double, and constructing a Length.</span></code>
<code>    <span class="color3">…</span></code>
<code>}</code></pre>
       <p>
        Using this raw-mode literal operator is the same as using the cooked version.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c15-para-0313">
           <b>
            NOTE
           </b>
           <i>
            Raw-mode literal operators work only with non-string literals. For example,
           </i>
           <code>
            1.23_m
           </code>
           <i>
            could be implemented with a raw-mode literal operator, but
           </i>
           <code>
            "1.23"_m
           </code>
           <i>
            cannot. The latter one requires a cooked-mode literal with two parameters: the zero-terminated string and its length.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
    </section>
    <span aria-label="618" epub:type="pagebreak" id="Page_618" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-182">
     <span id="c15-sec-0063">
     </span>
     <h2 id="head-2-182">
      SUMMARY
     </h2>
     <p id="c15-para-0314">
      This chapter summarized the rationale for operator overloading and provided examples and explanations for overloading the various categories of operators. Ideally, this chapter taught you to appreciate the power that it gives you. Throughout this book, operator overloading is used to provide abstractions and easy-to-use class interfaces.
     </p>
     <p id="c15-para-0315">
      Now it's time to start delving into the C++ Standard Library. The next chapter starts with an overview of the functionality provided by the C++ Standard Library, followed by chapters that go deeper into specific features of the library.
     </p>
    </section>
    <section aria-labelledby="head-2-183">
     <span id="c15-sec-0064">
     </span>
     <h2 id="head-2-183">
      EXERCISES
     </h2>
     <p id="c15-para-0316">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section>
      <span id="c15-exsec-0001">
      </span>
      <ol class="none">
       <li id="c15-ex-0001">
        <b>
         Exercise 15-1:
        </b>
        Implement an
        <code>
         AssociativeArray
        </code>
        class template. The class should store a number of elements in a
        <code>
         vector
        </code>
        , where each element consists of a key and a value. The key is always a
        <code>
         string
        </code>
        , while the type of the value can be specified using a template type parameter. Provide overloaded subscripting operators so that elements can be retrieved based on their key. Test your implementation in your
        <code>
         main()
        </code>
        function. Note: this exercise is just to practice implementing subscripting operators using non-integral indices. In practice, you should just use the
        <code>
         std::map
        </code>
        class template provided by the Standard Library and discussed in
        <a href="c18.xhtml">
         Chapter 18
        </a>
        for such an associative array.
       </li>
       <li id="c15-ex-0002">
        <b>
         Exercise 15-2:
        </b>
        Take your
        <code>
         Person
        </code>
        class implementation from Exercise 13-2 and add implementations of the insertion and extraction operators to it. Make sure that your extraction operator can read back what your insertion operator writes out.
       </li>
       <li id="c15-ex-0003">
        <b>
         Exercise 15-3:
        </b>
        Add a
        <code>
         string
        </code>
        conversion operator to your solution of Exercise 15-2. The operator simply returns a
        <code>
         string
        </code>
        constructed from the first and last name of the person.
       </li>
       <li id="c15-ex-0004">
        <b>
         Exercise 15-4:
        </b>
        Start from your solution of Exercise 15-3 and add a user-defined literal operator
        <code>
         _p
        </code>
        that constructs a
        <code>
         Person
        </code>
        from a string literal. It should support spaces in last names, but not in first names. For example,
        <code>
         "Peter Van Weert"_p
        </code>
        should result in a
        <code>
         Person
        </code>
        object with first name Peter and last name Van Weert.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
