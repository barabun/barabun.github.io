<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   14
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_017.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_019.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="_idContainer256">
    <h1 class="chapter-number" id="_idParaDest-284">
     <a id="_idTextAnchor284">
     </a>
     14
    </h1>
    <h1 id="_idParaDest-285">
     <a id="_idTextAnchor285">
     </a>
     Performance Optimization
    </h1>
    <p>
     Qt 6 is known for its optimized performance. However, performance issues may still occur if your code is poorly written. There are many ways we can identify these issues and fix them before releasing the software to
     <span class="No-Break">
      our users.
     </span>
    </p>
    <p>
     In this chapter, we will cover the
     <span class="No-Break">
      following recipes:
     </span>
    </p>
    <ul>
     <li>
      Optimizing forms
      <span class="No-Break">
       and C++
      </span>
     </li>
     <li>
      Profiling and
      <span class="No-Break">
       optimizing QML
      </span>
     </li>
     <li>
      Rendering
      <span class="No-Break">
       and animation
      </span>
     </li>
    </ul>
    <h1 id="_idParaDest-286">
     <a id="_idTextAnchor286">
     </a>
     Technical requirements
    </h1>
    <p>
     The technical requirements for this chapter include Qt 6.6.1 MinGW 64 bit, Qt Creator 12.0.2, and Windows 11. All the code used in this chapter can be downloaded from the following GitHub repository
     <span class="No-Break">
      at
     </span>
     <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14">
      <span class="No-Break">
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter14
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <h1 id="_idParaDest-287">
     <a id="_idTextAnchor287">
     </a>
     Optimizing forms and C++
    </h1>
    <p>
     It’s
     <a id="_idIndexMarker931">
     </a>
     very important to learn how to optimize your form-based Qt 6 applications that are built with C++. The best way to do that is to learn how to measure and compare the different methods that are used and decide which one works the best
     <span class="No-Break">
      for you.
     </span>
    </p>
    <h2 id="_idParaDest-288">
     <a id="_idTextAnchor288">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s get started by following
     <span class="No-Break">
      these steps:
     </span>
    </p>
    <ol>
     <li>
      Let’s
      <a id="_idIndexMarker932">
      </a>
      create a
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and open up
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      . After that, add the following headers to the top of the
      <span class="No-Break">
       source code:
      </span>
      <pre class="source-code">
#include &lt;QPushButton&gt;
#include &lt;QGridLayout&gt;
#include &lt;QMessageBox&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li>
      Create a
      <strong class="source-inline">
       QGridLayout
      </strong>
      object and set its parent
      <span class="No-Break">
       to
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        centralWidget
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);
    <strong class="bold">QGridLayout *layout = new QGridLayout(ui-&gt;centralWidget);</strong></pre>
     </li>
     <li>
      Create a
      <strong class="source-inline">
       QElapsedTimer
      </strong>
      object. We will be using this to measure the performance of our
      <span class="No-Break">
       next operation:
      </span>
      <pre class="source-code">
    QElapsedTimer* time = new QElapsedTimer;
    time-&gt;start();</pre>
     </li>
     <li>
      We will use two loops to add 600 push buttons to our grid layout and connect all of them to a lambda function when clicked. We will then measure the elapsed time and print out the result,
      <span class="No-Break">
       as follows:
      </span>
      <pre class="source-code">
    for (int i = 0; i &lt; 40; ++i) {
        for (int j = 0; j &lt; 15; ++j) {
            QPushButton* newWidget = new QPushButton();
            newWidget-&gt;setText("Button");
            layout-&gt;addWidget(newWidget, i, j);
            connect(newWidget, QPushButton::clicked, [this]() {
            QMessageBox::information(this, "Clicked", "Button has been clicked!");
            });
        }
    }
    qDebug() &lt;&lt; "Test GUI:" &lt;&lt; time-&gt;elapsed() &lt;&lt; "msec";</pre>
     </li>
     <li>
      If we
      <a id="_idIndexMarker933">
      </a>
      build and run the project now, we will see a window filled with lots of buttons. When we click on one of them, a message box will pop up on the screen. It only took around nine milliseconds on my computer to create and lay out all of the 600 buttons on the main window. There is also no performance issue when we move the window around or resize it, which is quite impressive. It proves that Qt 6 can handle this pretty well. However, please be aware that your users might be using older machines, and you might want to be extra careful when designing your
      <span class="No-Break">
       user interface:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer241">
      <img alt="Figure 14.1 – Spawn 600 buttons on a Qt window" src="../images\image/B20976_14_001.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.1 – Spawn 600 buttons on a Qt window
    </p>
    <ol>
     <li value="6">
      Let’s
      <a id="_idIndexMarker934">
      </a>
      add a style sheet to each of the buttons,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
QPushButton* newWidget = new QPushButton();
newWidget-&gt;setText("Button");
newWidget-&gt;setStyleSheet("background-color: blue; color: white;");
layout-&gt;addWidget(newWidget, i, j);</pre>
     </li>
     <li>
      Build and run the program again. This time, it took roughly 75 milliseconds to set up the GUI. This means that the style sheet does have some impact on the performance of
      <span class="No-Break">
       your program:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer242">
      <img alt="Figure 14.2 – Apply the style sheet to all 600 buttons" src="../images\image/B20976_14_002.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.2 – Apply the style sheet to all 600 buttons
    </p>
    <ol>
     <li value="8">
      Once you
      <a id="_idIndexMarker935">
      </a>
      are done with that, let’s do some performance tests on different types of C++ containers. Open up
      <strong class="source-inline">
       main.cpp
      </strong>
      and add the
      <span class="No-Break">
       following headers:
      </span>
      <pre class="source-code">
#include "mainwindow.h"
#include &lt;QApplication&gt;
#include &lt;QDebug&gt;
#include &lt;QElapsedTimer&gt;
#include &lt;vector&gt;
#include &lt;QVector&gt;</pre>
     </li>
     <li>
      Create
      <a id="_idIndexMarker936">
      </a>
      a
      <strong class="source-inline">
       testArray()
      </strong>
      function before the
      <span class="No-Break">
       <strong class="source-inline">
        main()
       </strong>
      </span>
      <span class="No-Break">
       function:
      </span>
      <pre class="source-code">
int testArray(int count) {
    int sum = 0;
    int *myarray = new int[count];
    for (int i = 0; i &lt; count; ++i)
        myarray[i] = i;
    for (int j = 0; j &lt; count; ++j)
        sum += myarray[j];
    delete [] myarray;
    return sum;
}</pre>
     </li>
     <li>
      Create another function called
      <strong class="source-inline">
       testVector()
      </strong>
      ,
      <span class="No-Break">
       as follows:
      </span>
      <pre class="source-code">
int testVector(int count) {
    int sum = 0;
    std::vector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</pre>
     </li>
     <li>
      Once you are done with that, proceed to create yet another function
      <span class="No-Break">
       called
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        testQtVector()
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
int testQtVector(int count) {
    int sum = 0;
    QVector&lt;int&gt; myarray;
    for (int i = 0; i &lt; count; ++i)
        myarray.push_back(i);
    for (int j = 0; j &lt; count; ++j)
        sum += myarray.at(j);
    return sum;
}</pre>
     </li>
     <li>
      Inside
      <a id="_idIndexMarker937">
      </a>
      the
      <strong class="source-inline">
       main()
      </strong>
      function, define a
      <strong class="source-inline">
       QElapsedTimer
      </strong>
      object and an integer variable
      <span class="No-Break">
       called
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        lastElapse
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    <strong class="bold">QElapsedTimer* time = new QElapsedTimer;</strong>
    <strong class="bold">time-&gt;start();</strong>
    <strong class="bold">int lastElapse = 0;</strong></pre>
     </li>
     <li>
      We will call the three functions we created in the previous steps to test
      <span class="No-Break">
       their performance:
      </span>
      <pre class="source-code">
    int result = testArray(100000000);
    qDebug() &lt;&lt; "Array:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result2 = testVector(100000000);
    qDebug() &lt;&lt; "STL vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();
    int result3 = testQtVector(100000000);
    qDebug() &lt;&lt; "Qt vector:" &lt;&lt; (time-&gt;elapsed() - lastElapse) &lt;&lt; "msec";
    lastElapse = time-&gt;elapsed();</pre>
     </li>
     <li>
      Build and run the program now; we will see the performance differences between these containers. On my computer, the array took 650 milliseconds to execute, while the STL vector took roughly 3,830 milliseconds, and the Qt vector took around 5,400 milliseconds
      <span class="No-Break">
       to execute.
      </span>
     </li>
    </ol>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     As a result, the array is still the container that yields the best performance, despite its lack of features compared to the other two. Surprisingly, Qt’s own vector class works slightly slower than the vector container provided by the C++
     <span class="No-Break">
      standard library.
     </span>
    </p>
    <h2 id="_idParaDest-289">
     <a id="_idTextAnchor289">
     </a>
     How it works…
    </h2>
    <p>
     When
     <a id="_idIndexMarker938">
     </a>
     creating a
     <strong class="bold">
      Qt Widgets Application
     </strong>
     project, try to do the following to
     <span class="No-Break">
      improve performance:
     </span>
    </p>
    <ul>
     <li>
      Avoid adding too many pages to a stacked widget and filling them with widgets, as Qt needs to find all of them recursively during the rendering process and event handling, which will highly impact the
      <span class="No-Break">
       program’s performance.
      </span>
     </li>
     <li>
      Do note that the
      <strong class="source-inline">
       QWidget
      </strong>
      class uses the Raster Engine, a software renderer, to render the widgets instead of using the GPU. However, it is lightweight enough to keep the performance good most of the time. Alternatively, you could consider using QML for your program’s GUI instead, since it is fully
      <span class="No-Break">
       hardware accelerated.
      </span>
     </li>
     <li>
      Turn off
      <strong class="bold">
       mouseTracking
      </strong>
      ,
      <strong class="bold">
       tabletTracking
      </strong>
      , and other event catching for your widgets if they do not need it. This tracking and catchings adds to the CPU usage costs of
      <span class="No-Break">
       your program:
      </span>
     </li>
    </ul>
    <div>
     <div class="IMG---Figure" id="_idContainer243">
      <img alt="Figure 14.3 – Disable mouseTracking and tabletTracking for optimization" src="../images\image/B20976_14_003.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.3 – Disable mouseTracking and tabletTracking for optimization
    </p>
    <ul>
     <li>
      Keep
      <a id="_idIndexMarker939">
      </a>
      your style sheets as simple as possible. A large style sheet needs a longer time for Qt to parse the information into the rendering system, which will also
      <span class="No-Break">
       impact performance.
      </span>
     </li>
     <li>
      Different C++ containers produce different speeds, as we showed in the preceding example. Surprisingly, Qt’s vector container is slightly slower than STL’s (the C++ standard library) vector container. Overall, the good old C++ array is still the fastest, but does not provide sorting functionality. Use what is best for
      <span class="No-Break">
       your requirements.
      </span>
     </li>
     <li>
      For large operations, use
      <em class="italic">
       asynchronous
      </em>
      methods whenever possible as it will not stall the main process and will keep your program
      <span class="No-Break">
       running smoothly.
      </span>
     </li>
     <li>
      <em class="italic">
       Multi-threading
      </em>
      is
      <a id="_idIndexMarker940">
      </a>
      really good for running different operations in parallel event loops. However, it can also become quite ugly if not done right, for example, creating and destroying threads frequently, or with inter-thread communications that are not
      <span class="No-Break">
       planned well.
      </span>
     </li>
     <li>
      Try to avoid using the web engine unless absolutely necessary. This is because embedding a full web browser on your program is really heavy overkill, especially for a small application. You can consider using QML instead of making a hybrid application if you want to create user
      <span class="No-Break">
       interface-centric software.
      </span>
     </li>
     <li>
      By
      <a id="_idIndexMarker941">
      </a>
      doing performance tests as we did in the preceding example project, you can easily determine which method is the best choice for your project and how to make your program
      <span class="No-Break">
       perform better.
      </span>
     </li>
    </ul>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     In Qt 5, we can use the
     <strong class="source-inline">
      QTime
     </strong>
     class to do the test as seen in this section. However, functions such as
     <strong class="source-inline">
      start()
     </strong>
     and
     <strong class="source-inline">
      elapsed()
     </strong>
     have been deprecated from the
     <strong class="source-inline">
      QTime
     </strong>
     class in Qt 6. Since Qt 6, the player must use
     <strong class="source-inline">
      QElapsedTimer
     </strong>
     to
     <span class="No-Break">
      handle this.
     </span>
    </p>
    <h1 id="_idParaDest-290">
     <a id="_idTextAnchor290">
     </a>
     Profiling and optimizing QML
    </h1>
    <p>
     The QML engine in Qt 6 took advantage of hardware acceleration to make its rendering capability and performance superior to the old widgets user interface. However, this does not mean that you do not need to worry about optimization, because small performance issues may snowball into bigger problems over time and cause damage to your
     <span class="No-Break">
      product’s reputation.
     </span>
    </p>
    <h2 id="_idParaDest-291">
     <a id="_idTextAnchor291">
     </a>
     How to do it…
    </h2>
    <p>
     Follow these steps to start profiling
     <a id="_idIndexMarker942">
     </a>
     and optimizing
     <a id="_idIndexMarker943">
     </a>
     a
     <span class="No-Break">
      QML application:
     </span>
    </p>
    <ol>
     <li>
      Let’s create a
      <strong class="bold">
       Qt Quick
      </strong>
      <span class="No-Break">
       <strong class="bold">
        Application
       </strong>
      </span>
      <span class="No-Break">
       project:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer244">
      <img alt="Figure 14.4 – Create a Qt Quick Application project" src="../images\image/B20976_14_004.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.4 – Create a Qt Quick Application project
    </p>
    <ol>
     <li value="2">
      Then, go
      <a id="_idIndexMarker944">
      </a>
      to
      <strong class="bold">
       Analyze | QML Profiler
      </strong>
      and
      <a id="_idIndexMarker945">
      </a>
      run the
      <strong class="bold">
       QML
      </strong>
      <span class="No-Break">
       <strong class="bold">
        Profiler
       </strong>
      </span>
      <span class="No-Break">
       tool:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer245">
      <img alt="Figure 14.5 – Run the QML Profiler to check the QML performance" src="../images\image/B20976_14_005.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.5 – Run the QML Profiler to check the QML performance
    </p>
    <ol>
     <li value="3">
      Your Qt Quick project will then be run by the QML Profiler. The
      <strong class="bold">
       QML Profiler
      </strong>
      window will also appear under the code editor. Click the
      <strong class="bold">
       Stop
      </strong>
      button located at the top bar of the
      <strong class="bold">
       QML Profiler
      </strong>
      window after the program has passed the test point, which in this case meant successfully creating the
      <span class="No-Break">
       empty window:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer246">
      <img alt="Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon" src="../images\image/B20976_14_006.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.6 – Stop the QML Profiler by pressing the button with the red rectangle icon
    </p>
    <ol>
     <li value="4">
      After you
      <a id="_idIndexMarker946">
      </a>
      stop the profiler analysis, a timeline will be
      <a id="_idIndexMarker947">
      </a>
      displayed in the
      <strong class="bold">
       Timeline
      </strong>
      tab under the
      <strong class="bold">
       QML Profiler
      </strong>
      window. There are four tabs that you can switch between, namely
      <strong class="bold">
       Timeline
      </strong>
      ,
      <strong class="bold">
       Flame Graph
      </strong>
      ,
      <strong class="bold">
       Quick3D Frame
      </strong>
      , and
      <strong class="bold">
       Statistics
      </strong>
      , at the bottom of the
      <strong class="bold">
       QML
      </strong>
      <span class="No-Break">
       <strong class="bold">
        Profiler
       </strong>
      </span>
      <span class="No-Break">
       window:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer247">
      <img alt="Figure 14.7 – You can look at different data on different tabs" src="../images\image/B20976_14_007.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.7 – You can look at different data on different tabs
    </p>
    <ol>
     <li value="5">
      Let’s check out the
      <strong class="bold">
       Timeline
      </strong>
      tab. We can see six different categories under the timeline display:
      <strong class="bold">
       Scene Graph
      </strong>
      ,
      <strong class="bold">
       Memory Usage
      </strong>
      ,
      <strong class="bold">
       Input Events
      </strong>
      ,
      <strong class="bold">
       Compiling
      </strong>
      ,
      <strong class="bold">
       Creating
      </strong>
      , and
      <strong class="bold">
       Binding
      </strong>
      . These categories give us an overview of the different stages and processes of our program throughout its execution. We can also see some colorful bars displayed on the timeline. Let’s click on one of the bars under the
      <strong class="bold">
       Creating
      </strong>
      category that says
      <strong class="bold">
       QtQuick/Window
      </strong>
      . Once clicked, we will see the total duration for this operation and the location of the code displayed in a rectangular window located at the top of the QML
      <span class="No-Break">
       Profiler window:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer248">
      <img alt="Figure 14.8 – The Timeline tab" src="../images\image/B20976_14_008.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.8 – The Timeline tab
    </p>
    <ol>
     <li value="6">
      Once you are
      <a id="_idIndexMarker948">
      </a>
      done with that, let’s move on and open up
      <a id="_idIndexMarker949">
      </a>
      the
      <strong class="bold">
       Flame Graph
      </strong>
      tab instead. Under the
      <strong class="bold">
       Flame Graph
      </strong>
      tab, you will see the visualization of the total time, memory, and allocation of your application in the form of percentages. You can switch between total time, memory, and allocation by clicking on the selection box that’s located at the top-right corner of the
      <strong class="bold">
       QML
      </strong>
      <span class="No-Break">
       <strong class="bold">
        Profiler
       </strong>
      </span>
      <span class="No-Break">
       window:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer249">
      <img alt="Figure 14.9 – The Flame Graph tab" src="../images\image/B20976_14_009.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.9 – The Flame Graph tab
    </p>
    <ol>
     <li value="7">
      Not only
      <a id="_idIndexMarker950">
      </a>
      that, you will also see the percentage value
      <a id="_idIndexMarker951">
      </a>
      displayed on your QML
      <span class="No-Break">
       code editor:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer250">
      <img alt="Figure 14.10 – Percentage values are shown on the right" src="../images\image/B20976_14_010.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.10 – Percentage values are shown on the right
    </p>
    <ol>
     <li value="8">
      Open up the
      <strong class="bold">
       Quick3D Frame
      </strong>
      category under the
      <strong class="bold">
       QML Profiler
      </strong>
      window. This tab is where you check the performance of 3D rendering. It is currently empty because we are not doing any
      <span class="No-Break">
       3D rendering.
      </span>
     </li>
     <li>
      Next, let’s open up the
      <strong class="bold">
       Statistics
      </strong>
      category. This tab basically shows us information about the processes in
      <span class="No-Break">
       table form:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer251">
      <img alt="Figure 14.11 – The Statistics tab" src="../images\image/B20976_14_011.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.11 – The Statistics tab
    </p>
    <h2 id="_idParaDest-292">
     <a id="_idTextAnchor292">
     </a>
     How it works…
    </h2>
    <p>
     This is similar to what we did in the previous example project that used C++ and widgets except, this time, it is automatically analyzed by the
     <strong class="bold">
      QML Profiler
     </strong>
     tool that’s provided by
     <span class="No-Break">
      Qt 6.
     </span>
    </p>
    <p>
     The QML Profiler not only produces the total time used for running a specific process, but also displays the memory allocation, the execution timeline of your application, and other information that gives you insight into the performance of
     <span class="No-Break">
      your software.
     </span>
    </p>
    <p>
     By looking at the data that was analyzed by the QML Profiler, you will be able to find out which part of your code slows down the program, allowing you to fix any
     <span class="No-Break">
      problems quickly.
     </span>
    </p>
    <p>
     There are
     <a id="_idIndexMarker952">
     </a>
     some rules that you need to be aware of when writing
     <a id="_idIndexMarker953">
     </a>
     QML to avoid performance bottlenecks. For instance, type conversion can sometimes be expensive, especially between types that are not closely matched (string to number, for example). Small issues like this will likely snowball into bottlenecks as your project grows larger
     <span class="No-Break">
      over time.
     </span>
    </p>
    <p>
     Other than that, try not to use
     <strong class="source-inline">
      id
     </strong>
     for an item lookup multiple times in blocks of code that are run often, as in the
     <span class="No-Break">
      following example:
     </span>
    </p>
    <pre class="source-code">
Item {
    width: 400
    height: 400
    Rectangle {
    id: rect
    anchors.fill: parent
    color: "green"
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            console.log("red", rect.color.r);
            console.log("green", rect.color.g);
            console.log("blue", rect.color.b);
            console.log("alpha", rect.color.a);
        }
    }</pre>
    <p>
     Instead, we can use a variable to cache the data and avoid multiple look-ups on the same item over and
     <span class="No-Break">
      over again:
     </span>
    </p>
    <pre class="source-code">
Component.onCompleted: {
    var rectColor = rect.color;
    for (var i = 0; i &lt; 1000; ++i) {
        console.log("red", rectColor.r);
        console.log("green", rectColor.g);
        console.log("blue", rectColor.b);
        console.log("alpha", rectColor.a);
    }
}</pre>
    <p>
     Besides, if you
     <a id="_idIndexMarker954">
     </a>
     change the property of a binding expression, especially
     <a id="_idIndexMarker955">
     </a>
     in a loop, Qt will be forced to re-evaluate it repeatedly. This will cause some performance issues. Instead of doing this, the user should follow the next
     <span class="No-Break">
      code snippet:
     </span>
    </p>
    <pre class="source-code">
Item {
    id: myItem
    width: 400
    height: 400
    property int myValue: 0
    Text {
        anchors.fill: parent
        text: myItem.myValue.toString()
    }
    Component.onCompleted: {
        for (var i = 0; i &lt; 1000; ++i) {
            myValue += 1;
        }
    }
}</pre>
    <p>
     Instead, we can
     <a id="_idIndexMarker956">
     </a>
     use a temporary variable for storing the data of
     <strong class="source-inline">
      myValue
     </strong>
     , then
     <a id="_idIndexMarker957">
     </a>
     apply the final result back to
     <strong class="source-inline">
      myValue
     </strong>
     once the loop has
     <span class="No-Break">
      been completed:
     </span>
    </p>
    <pre class="source-code">
Component.onCompleted: {
    var temp = myValue;
    for (var i = 0; i &lt; 1000; ++i) {
        temp += 1;
    }
    myValue = temp;
}</pre>
    <p>
     Consider using an anchor to position your UI items instead of using bindings. Item positioning with bindings is really slow and inefficient, although it allows for
     <span class="No-Break">
      maximum flexibility.
     </span>
    </p>
    <h1 id="_idParaDest-293">
     <a id="_idTextAnchor293">
     </a>
     Rendering and animation
    </h1>
    <p>
     When it
     <a id="_idIndexMarker958">
     </a>
     comes to an application that renders graphics and
     <a id="_idIndexMarker959">
     </a>
     animation, good performance is critical. Users can easily notice performance issues when graphics are not animated smoothly on screen. In the following example, we will look at how we can further optimize a graphics-heavy Qt
     <span class="No-Break">
      Quick application.
     </span>
    </p>
    <h2 id="_idParaDest-294">
     <a id="_idTextAnchor294">
     </a>
     How to do it…
    </h2>
    <p>
     To
     <a id="_idIndexMarker960">
     </a>
     learn how to
     <a id="_idIndexMarker961">
     </a>
     render animation in QML, follow
     <span class="No-Break">
      this example:
     </span>
    </p>
    <ol>
     <li>
      Create a
      <strong class="bold">
       Qt Quick Application
      </strong>
      project. Then, right-click on the
      <strong class="bold">
       Resources
      </strong>
      icon under our project panel and add
      <strong class="source-inline">
       tux.png
      </strong>
      to our
      <span class="No-Break">
       project’s resources:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer252">
      <img alt="Figure 14.12 – Include main.qml and tux.png into your project resources" src="../images\image/B20976_14_012.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.12 – Include main.qml and tux.png into your project resources
    </p>
    <ol>
     <li value="2">
      Open up
      <strong class="bold">
       main.qml
      </strong>
      and change the window size to
      <strong class="source-inline">
       650
      </strong>
      x
      <strong class="source-inline">
       650
      </strong>
      . We will also add
      <strong class="source-inline">
       id
      </strong>
      to the
      <strong class="source-inline">
       window
      </strong>
      item and name
      <span class="No-Break">
       it
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        window
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
Window {
    id: window
    visible: true
    width: 650
    height: 650</pre>
     </li>
     <li>
      Add the following code inside the
      <span class="No-Break">
       <strong class="source-inline">
        window
       </strong>
      </span>
      <span class="No-Break">
       item:
      </span>
      <pre class="source-code">
    property int frame: 0;
    onAfterRendering: { frame++; }
    Timer {
    id: timer
    interval: 1000
    running: true
    repeat: true
    onTriggered: { frame = 0; }
}</pre>
     </li>
     <li>
      Right
      <a id="_idIndexMarker962">
      </a>
      after
      <a id="_idIndexMarker963">
      </a>
      that, add
      <strong class="source-inline">
       Repeater
      </strong>
      and
      <strong class="source-inline">
       Image
      </strong>
      <span class="No-Break">
       under it:
      </span>
      <pre class="source-code">
    Repeater {
        model: 10
        delegate:
        Image {
        id: tux
        source: "tux.png"
        sourceSize.width: 50
        sourceSize.height: 60
        width: 50
        height: 60
        smooth: false
        antialiasing: false
        asynchronous: true</pre>
     </li>
     <li>
      We will proceed and add the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
        property double startX: Math.random() * 600;
        property double startY: Math.random() * 600;
        property double endX: Math.random() * 600;
        property double endY: Math.random() * 600;
        property double speed: Math.random() * 3000 + 1000;
        RotationAnimation on rotation{
        loops: Animation.Infinite
        from: 0
        to: 360
        duration: Math.random() * 3000 + 1000;
}</pre>
     </li>
     <li>
      Once
      <a id="_idIndexMarker964">
      </a>
      you are
      <a id="_idIndexMarker965">
      </a>
      done with that, add the following code below the
      <span class="No-Break">
       previous code:
      </span>
      <pre class="source-code">
    SequentialAnimation {
        running: true
        loops: Animation.Infinite
        ParallelAnimation {
        NumberAnimation {
        target: tux
        property: "x"
        from: startX
        to: endX
        duration: speed
        easing.type: Easing.InOutQuad
    }</pre>
     </li>
     <li>
      The preceding code animates the
      <strong class="source-inline">
       x
      </strong>
      property of the image. We need another
      <strong class="source-inline">
       NumberAnimation
      </strong>
      property to animate the
      <span class="No-Break">
       <strong class="source-inline">
        y
       </strong>
      </span>
      <span class="No-Break">
       property:
      </span>
      <pre class="source-code">
    NumberAnimation {
        target: tux
        property: "y"
        from: startY
        to: endY
        duration: speed
        easing.type: Easing.InOutQuad
    }
}</pre>
     </li>
     <li>
      After that, we
      <a id="_idIndexMarker966">
      </a>
      repeat the entire code of
      <strong class="source-inline">
       ParallelAnimation
      </strong>
      , except this time, we
      <a id="_idIndexMarker967">
      </a>
      swap the
      <strong class="source-inline">
       from
      </strong>
      and
      <strong class="source-inline">
       to
      </strong>
      values,
      <span class="No-Break">
       like so:
      </span>
      <pre class="source-code">
    ParallelAnimation {
        NumberAnimation {
            target: tux
            property: "x"
            from: endX
            to: startX
            duration: speed
            easing.type: Easing.InOutQuad
        }</pre>
     </li>
     <li>
      The same goes for
      <strong class="source-inline">
       NumberAnimation
      </strong>
      for the
      <span class="No-Break">
       <strong class="source-inline">
        y
       </strong>
      </span>
      <span class="No-Break">
       property:
      </span>
      <pre class="source-code">
        NumberAnimation {
            target: tux
            property: "y"
            from: endY
            to: startY
            duration: speed
            easing.type: Easing.InOutQuad
        }
    }</pre>
     </li>
     <li>
      Then, we
      <a id="_idIndexMarker968">
      </a>
      add a
      <strong class="source-inline">
       Text
      </strong>
      item for displaying the frame rate of
      <span class="No-Break">
       our
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker969">
       </a>
      </span>
      <span class="No-Break">
       application:
      </span>
      <pre class="source-code">
Text {
    property int frame: 0
    color: "red"
    text: "FPS: 0 fps"
    x: 20
    y: 20
    font.pointSize: 20</pre>
     </li>
     <li>
      Let’s add
      <strong class="source-inline">
       Timer
      </strong>
      under
      <strong class="source-inline">
       Text
      </strong>
      and update the frame rate to display
      <span class="No-Break">
       every second:
      </span>
      <pre class="source-code">
    Timer {
        id: fpsTimer
        repeat: true
        interval: 1000
        running: true
        onTriggered: {
        parent.text = "FPS: " + frame + " fps"
        }
    }
}</pre>
     </li>
     <li>
      If we build and run the program now, we will be able to see several penguins moving around the screen with a steady
      <span class="No-Break">
       60 fps:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer253">
      <img alt="Figure 14.13 – 10 penguins floating around the window" src="../images\image/B20976_14_013.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.13 – 10 penguins floating around the window
    </p>
    <ol>
     <li value="13">
      Let’s go
      <a id="_idIndexMarker970">
      </a>
      back to our code and change the
      <strong class="source-inline">
       model
      </strong>
      property
      <a id="_idIndexMarker971">
      </a>
      of the
      <strong class="source-inline">
       Repeater
      </strong>
      item to
      <strong class="source-inline">
       10000
      </strong>
      . Build and run the program again; you should see that your window is full of moving penguins and that the frame rate has significantly dropped to roughly 39 fps, which is not too bad, considering the amount of penguins
      <span class="No-Break">
       we have:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer254">
      <img alt="Figure 14.14 – 10,000 penguins floating around the window" src="../images\image/B20976_14_014.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.14 – 10,000 penguins floating around the window
    </p>
    <ol>
     <li value="14">
      Next, let’s
      <a id="_idIndexMarker972">
      </a>
      go back to our source code and comment out both
      <a id="_idIndexMarker973">
      </a>
      of the
      <strong class="source-inline">
       sourceSize
      </strong>
      properties. We also set the
      <strong class="source-inline">
       smooth
      </strong>
      and
      <strong class="source-inline">
       antialiasing
      </strong>
      properties to
      <strong class="source-inline">
       false
      </strong>
      , while setting the
      <strong class="source-inline">
       asynchronous
      </strong>
      property
      <span class="No-Break">
       to
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        false
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
Image {
    id: tux
    source: "tux.png"
    <strong class="bold">//sourceSize.width: 50</strong>
    <strong class="bold">//sourceSize.height: 60</strong>
    width: 50
    height: 60
    <strong class="bold">smooth: true</strong>
    <strong class="bold">antialiasing: false</strong>
    <strong class="bold">asynchronous: false</strong></pre>
     </li>
     <li>
      Let’s build
      <a id="_idIndexMarker974">
      </a>
      and run the program again. This time, the frame rate
      <a id="_idIndexMarker975">
      </a>
      dropped slightly to 32 fps, but the penguins look smoother and are of better quality, even
      <span class="No-Break">
       when moving:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer255">
      <img alt="Figure 14.15 – Our penguins look much smoother now without slowing down too much" src="../images\image/B20976_14_015.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 14.15 – Our penguins look much smoother now without slowing down too much
    </p>
    <h2 id="_idParaDest-295">
     <a id="_idTextAnchor295">
     </a>
     How it works…
    </h2>
    <p>
     The
     <a id="_idIndexMarker976">
     </a>
     QML engine that powers Qt Quick applications is very optimized and
     <a id="_idIndexMarker977">
     </a>
     powerful when it comes to rendering animated graphics on screen. However, there are still some tips that we can follow to make it
     <span class="No-Break">
      even faster.
     </span>
    </p>
    <p>
     Try and make use of the built-in features provided by Qt 6 instead of implementing your own, such as
     <strong class="source-inline">
      Repeater
     </strong>
     ,
     <strong class="source-inline">
      NumberAnimation
     </strong>
     , and
     <strong class="source-inline">
      SequentialAnimation
     </strong>
     . This is because Qt 6 developers have put great effort into optimizing these features so that you don’t
     <span class="No-Break">
      have to.
     </span>
    </p>
    <p>
     The
     <strong class="source-inline">
      sourceSize
     </strong>
     properties tell Qt to resize the image before loading it into memory so that large images do not use more memory
     <span class="No-Break">
      than necessary.
     </span>
    </p>
    <p>
     The
     <strong class="source-inline">
      smooth
     </strong>
     property, when enabled, tells Qt to filter the image to make look it smoother when scaled or transformed from its natural size. It will not make any difference if the image is rendered at the same as its
     <strong class="source-inline">
      sourceSize
     </strong>
     value. This property will impact the performance of your application on some
     <span class="No-Break">
      older hardware.
     </span>
    </p>
    <p>
     The
     <strong class="source-inline">
      antialiasing
     </strong>
     property tells Qt to remove the aliasing artifacts around the edge of the image and make it look smoother. This property will also impact the performance of
     <span class="No-Break">
      your program.
     </span>
    </p>
    <p>
     The
     <strong class="source-inline">
      asynchronous
     </strong>
     property tells Qt to load the image under a low-priority thread, which means that your program will not stall when loading huge
     <span class="No-Break">
      image files.
     </span>
    </p>
    <p>
     We used the frame rate to indicate the performance of our program. Since
     <strong class="source-inline">
      onAfterRendering
     </strong>
     always gets called on every frame, we can then accumulate the frame variable on every render. Then, we used
     <strong class="source-inline">
      Timer
     </strong>
     to reset the frame value
     <span class="No-Break">
      every second.
     </span>
    </p>
    <p>
     Finally, we displayed the value on screen using a
     <span class="No-Break">
      <strong class="source-inline">
       Text
      </strong>
     </span>
     <span class="No-Break">
      item.
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
