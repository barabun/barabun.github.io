<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   7Memory Management
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_017.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_019.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c07_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c07_1">
      <span aria-label="221" class="calibre17" epub:type="pagebreak" id="Page_221" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c07">
      </span>
      <span class="calibre">
       7
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Memory Management
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c07-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c07-list-0001">
         <li class="calibre9" id="c07-li-0001">
          Different ways to use and manage memory
         </li>
         <li class="calibre9" id="c07-li-0002">
          The often-perplexing relationship between arrays and pointers
         </li>
         <li class="calibre9" id="c07-li-0003">
          A low-level look at working with memory
         </li>
         <li class="calibre9" id="c07-li-0004">
          Common memory pitfalls
         </li>
         <li class="calibre9" id="c07-li-0005">
          Smart pointers and how to use them
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c07-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-93">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p class="calibre25" id="c07-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c07-para-0004">
      When you use modern constructs, such as
      <code class="calibre21">
       std::vector
      </code>
      ,
      <code class="calibre21">
       std::string
      </code>
      , and so on, as is done starting from
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library,” and throughout all the other chapters of this book, then C++ is a safe language. The language provides many roads, lines, and traffic lights, such as the C++ Core Guidelines (see
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography”), static code analyzers to analyze the correctness of code, and many more.
     </p>
     <p class="calibre13" id="c07-para-0005">
      However, C++ does allow you to drive off-road. One example of driving off-road is manual memory management (allocation and deallocation). Such manual memory management is a particularly error-prone area of C++ programming. To write high-quality C++ programs, professional C++ programmers need to understand how memory works behind the scenes. This first chapter of
      <a class="calibre5" href="p03.xhtml">
       Part III
      </a>
      explores the ins and outs of memory management. You will learn about the pitfalls of dynamic memory and some techniques for avoiding and eliminating them.
     </p>
     <p class="calibre13">
      <span aria-label="222" class="calibre20" epub:type="pagebreak" id="Page_222" role="doc-pagebreak">
      </span>
      This chapter discusses low-level memory handling because professional C++ programmers will encounter such code. However, in modern C++ code you should avoid low-level memory operations as much as possible. For example, instead of dynamically allocated C-style arrays, you should use Standard Library containers, such as
      <code class="calibre21">
       vector
      </code>
      , which handle all memory management automatically for you. Instead of raw pointers, you should use smart pointers, such as
      <code class="calibre21">
       unique_ptr
      </code>
      and
      <code class="calibre21">
       shared_ptr
      </code>
      both discussed later in this chapter, which automatically free the underlying resource, such as memory, when it's not needed anymore. Basically, the goal is to avoid having calls to memory allocation routines such as
      <code class="calibre21">
       new/new[]
      </code>
      and
      <code class="calibre21">
       delete/delete[]
      </code>
      in your code. Of course, it might not always be possible, and in existing code it will most likely not be the case, so as a professional C++ programmer, you still need to know how memory works behind the scenes.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c07-para-0007">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          In modern C++ code you should avoid low-level memory operations as much as possible, avoid raw pointers when ownership is involved, and avoid using old C-style constructs and functions. Instead, use safe C++ alternatives, such as objects that automatically manage their memory, like the C++
         </i>
         <code class="calibre21">
          string
         </code>
         <i class="calibre18">
          class, the
         </i>
         <code class="calibre21">
          vector
         </code>
         <i class="calibre18">
          container, smart pointers, and so on!
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-94" class="calibre2">
     <span class="calibre" id="c07-sec-0005">
     </span>
     <h2 class="calibre6" id="head-2-94">
      WORKING WITH DYNAMIC MEMORY
     </h2>
     <p class="calibre13" id="c07-para-0008">
      Memory is a low-level component of the computer that sometimes unfortunately rears its head even in a high-level programming language like C++. A solid understanding of how dynamic memory really works in C++ is essential to becoming a professional C++ programmer.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-155">
       How to Picture Memory
      </h3>
      <p class="calibre13" id="c07-para-0009">
       Understanding dynamic memory is much easier if you have a mental model for what objects look like in memory. In this book, a unit of memory is shown as a box with a label next to it. The label indicates a variable name that corresponds to the memory. The data inside the box displays the current value of the memory.
      </p>
      <p class="calibre13">
       For example,
       <a class="calibre5" href="#c07-fig-0001" id="R_c07-fig-0001">
        Figure 7.1
       </a>
       shows the state of memory after the following line of code is executed. The line should be in a function, so that
       <code class="calibre21">
        i
       </code>
       is a local variable:
      </p>
      <pre class="calibre26" id="c07-code-0001"><code class="calibre21">int i { 7 };</code></pre>
      <figure class="calibre36">
       <img alt="A set of three boxes. The first box reads stack. The second box reads free store. The third box reads i 7." class="center" src="images/c07f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c07-fig-0001" id="c07-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 7.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c07-para-0011">
       <code class="calibre21">
        i
       </code>
       is called an
       <i class="calibre18">
        automatic variable
       </i>
       allocated on the stack. It is automatically deallocated when the program flow leaves the scope in which the variable is declared.
      </p>
      <p class="calibre13">
       When you use the
       <code class="calibre21">
        new
       </code>
       keyword, memory is allocated on the free store. If not explicitly initialized, memory allocated by a call to
       <code class="calibre21">
        new
       </code>
       is uninitialized; i.e., it contains whatever random data is left at that location in memory. This uninitialized state is represented with a question mark in diagrams in this chapter. The following code creates a variable
       <code class="calibre21">
        ptr
       </code>
       on the stack initialized with
       <code class="calibre21">
        nullptr
       </code>
       and then allocates memory on the free store to which
       <code class="calibre21">
        ptr
       </code>
       points:
      </p>
      <pre class="calibre26" id="c07-code-0002"><span aria-label="223" class="calibre20" epub:type="pagebreak" id="Page_223" role="doc-pagebreak"></span><code class="calibre21">int* ptr { nullptr };</code>
<code class="calibre21">ptr = new int;</code></pre>
      <p class="calibre13">
       This can also be written as a one-liner:
      </p>
      <pre class="calibre26" id="c07-code-0003"><code class="calibre21">int* ptr { new int };</code></pre>
      <p class="calibre13">
       <a class="calibre5" href="#c07-fig-0002" id="R_c07-fig-0002">
        Figure 7.2
       </a>
       shows the state of memory after this code is executed. Notice that the variable
       <code class="calibre21">
        ptr
       </code>
       is still on the stack even though it points to memory on the free store. A pointer is just a variable and can live on either the stack or the free store, although this fact is easy to forget. Dynamic memory, however, is always allocated on the free store.
      </p>
      <figure class="calibre36">
       <img alt="A set of four boxes. The first box reads stack. The second box reads free store. The third box reads p t r. The fourth box reads question mark and superscript star p t r." class="center" src="images/c07f002.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c07-fig-0002" id="c07-fig-0002" role="doc-backlink">
           <b class="calibre14">
            FIGURE 7.2
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c07-para-0015">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           As mandated by the C++ Core Guidelines,
          </i>
          <a aria-describedby="c07-note-0001" class="calibre5" epub:type="noteref" href="#c07-note-0001" id="R_c07-note-0001" role="doc-noteref">
           <sup class="calibre22">
            1
           </sup>
          </a>
          <i class="calibre18">
           every time you declare a pointer variable, you should immediately initialize it with either a proper pointer or
          </i>
          <code class="calibre21">
           nullptr
          </code>
          <i class="calibre18">
           . Don't leave it uninitialized!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       The next example shows that pointers can exist both on the stack and on the free store:
      </p>
      <pre class="calibre26" id="c07-code-0004"><code class="calibre21">int** handle { nullptr };</code>
<code class="calibre21">handle = new int*;</code>
<code class="calibre21">*handle = new int;</code></pre>
      <p class="calibre13" id="c07-para-0017">
       This code first declares a pointer to a pointer to an integer as the variable
       <code class="calibre21">
        handle
       </code>
       . It then dynamically allocates enough memory to hold a pointer to an integer, storing the pointer to that new memory in
       <code class="calibre21">
        handle
       </code>
       . Next, that memory (
       <code class="calibre21">
        *handle
       </code>
       ) is assigned a pointer to another section of dynamic memory that is big enough to hold the integer.
       <a class="calibre5" href="#c07-fig-0003" id="R_c07-fig-0003">
        Figure 7.3
       </a>
       shows the two levels of pointers with one pointer residing on the stack (
       <code class="calibre21">
        handle
       </code>
       ) and the other residing on the free store (
       <code class="calibre21">
        *handle
       </code>
       ).
      </p>
      <figure class="calibre36">
       <img alt="A set of five boxes. The first box reads stack. The second box reads free store. The third box reads handle. The fourth box reads superscript star handle. The fifth box reads question mark and superscript two stars handle." class="center" src="images/c07f003.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c07-fig-0003" id="c07-fig-0003" role="doc-backlink">
           <b class="calibre14">
            FIGURE 7.3
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-156">
       Allocation and Deallocation
      </h3>
      <p class="calibre13" id="c07-para-0018">
       To create space for a variable, you use the
       <code class="calibre21">
        new
       </code>
       keyword. To release that space for use by other parts of the program, you use the
       <code class="calibre21">
        delete
       </code>
       keyword.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0009">
       </span>
       <h4 class="calibre29" id="head-4-125">
        Using new and delete
       </h4>
       <p class="calibre13" id="c07-para-0019">
        When you want to allocate a block of memory, you call
        <code class="calibre21">
         new
        </code>
        with the type of variable for which you need space.
        <code class="calibre21">
         new
        </code>
        returns a pointer to that memory, although it is up to you to store that pointer in a
        <span aria-label="224" class="calibre20" epub:type="pagebreak" id="Page_224" role="doc-pagebreak">
        </span>
        variable. If you ignore the return value of
        <code class="calibre21">
         new
        </code>
        or if the pointer variable goes out of scope, the memory becomes
        <i class="calibre18">
         orphaned
        </i>
        because you no longer have a way to access it. This is called a
        <i class="calibre18">
         memory leak
        </i>
        .
       </p>
       <p class="calibre13">
        For example, the following code orphans enough memory to hold an
        <code class="calibre21">
         int
        </code>
        .
        <a class="calibre5" href="#c07-fig-0004" id="R_c07-fig-0004">
         Figure 7.4
        </a>
        shows the state of memory after the code is executed. When there are blocks of data on the free store with no access, direct or indirect, from the stack, the memory is orphaned or leaked.
       </p>
       <figure class="calibre36">
        <img alt="A set of three boxes. The first box reads stack. The second box reads free store. The third box reads question mark and leaked integer." class="center" src="images/c07f004.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c07-fig-0004" id="c07-fig-0004" role="doc-backlink">
            <b class="calibre14">
             FIGURE 7.4
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <pre class="calibre26" id="c07-code-0005"><code class="calibre21">void leaky()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">new int;   // BUG! Orphans/leaks memory!</span></code>
<code class="calibre21">    println("I just leaked an int!");</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Until they find a way to make computers with an infinite supply of fast memory, you will need to tell the compiler when the memory associated with an object can be released and reused for another purpose. To free memory on the free store, you use the
        <code class="calibre21">
         delete
        </code>
        keyword with a pointer to the memory, as shown here:
       </p>
       <pre class="calibre26" id="c07-code-0006"><code class="calibre21">int* ptr { new int };</code>
<code class="calibre21"><b class="calibre14">delete ptr;</b></code>
<code class="calibre21"><b class="calibre14">ptr = nullptr;</b></code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0023">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            As a rule of thumb, every line of code that allocates memory with
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            , and that uses a raw pointer instead of storing the pointer in a smart pointer, should correspond to another line of code that releases the same memory with
           </i>
           <code class="calibre21">
            delete
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0024">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            It is recommended to set a pointer to
           </i>
           <code class="calibre21">
            nullptr
           </code>
           <i class="calibre18">
            after having freed its memory. That way, you do not accidentally use a pointer to memory that has already been deallocated. It's also worth noting that you are allowed to call
            <code class="calibre21">
             delete
            </code>
            on a
           </i>
           <code class="calibre21">
            nullptr
           </code>
           <i class="calibre18">
            pointer; it simply will not do anything.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0012">
       </span>
       <h4 class="calibre29" id="head-4-126">
        What About My Good Friend malloc?
       </h4>
       <p class="calibre13" id="c07-para-0025">
        If you are a C programmer, you may be wondering what is wrong with the
        <code class="calibre21">
         malloc()
        </code>
        function. In C,
        <code class="calibre21">
         malloc()
        </code>
        is used to allocate a given number of bytes of memory. For the most part, using
        <code class="calibre21">
         malloc()
        </code>
        is simple and straightforward. The
        <code class="calibre21">
         malloc()
        </code>
        function still exists in C++, but you should avoid it. The main advantage of
        <code class="calibre21">
         new
        </code>
        over
        <code class="calibre21">
         malloc()
        </code>
        is that
        <code class="calibre21">
         new
        </code>
        doesn't just allocate memory, it constructs objects!
       </p>
       <p class="calibre13">
        For example, consider the following two lines of code, which use a hypothetical class called
        <code class="calibre21">
         Foo
        </code>
        :
       </p>
       <pre class="calibre26" id="c07-code-0007"><code class="calibre21">Foo* myFoo { (Foo*)malloc(sizeof(Foo)) };</code>
<code class="calibre21">Foo* myOtherFoo { new Foo{} };</code></pre>
       <p class="calibre13" id="c07-para-0027">
        <span aria-label="225" class="calibre20" epub:type="pagebreak" id="Page_225" role="doc-pagebreak">
        </span>
        After executing these lines, both
        <code class="calibre21">
         myFoo
        </code>
        and
        <code class="calibre21">
         myOtherFoo
        </code>
        point to areas of memory on the free store that are big enough for a
        <code class="calibre21">
         Foo
        </code>
        object. Data members and member functions of
        <code class="calibre21">
         Foo
        </code>
        can be accessed using both pointers. The difference is that the
        <code class="calibre21">
         Foo
        </code>
        object pointed to by
        <code class="calibre21">
         myFoo
        </code>
        isn't a proper object because its constructor was never called. The
        <code class="calibre21">
         malloc()
        </code>
        function only sets aside a piece of memory of a certain size. It doesn't know about or care about objects. In contrast, the call to
        <code class="calibre21">
         new
        </code>
        allocates the appropriate size of memory and also calls an appropriate constructor to construct the object.
       </p>
       <p class="calibre13">
        A similar difference exists between the
        <code class="calibre21">
         free()
        </code>
        function and the
        <code class="calibre21">
         delete
        </code>
        operator. With
        <code class="calibre21">
         free()
        </code>
        , the object's destructor is not called. With
        <code class="calibre21">
         delete
        </code>
        , the destructor is called and the object is properly cleaned up.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0029">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Avoid the use of
           </i>
           <code class="calibre21">
            malloc()
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            free
           </code>
           <i class="calibre18">
            <code class="calibre21">
             ()
            </code>
            in C++
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0014">
       </span>
       <h4 class="calibre29" id="head-4-127">
        When Memory Allocation Fails
       </h4>
       <p class="calibre13" id="c07-para-0030">
        Many, if not most, programmers write code with the assumption that
        <code class="calibre21">
         new
        </code>
        will always be successful. The rationale is that if
        <code class="calibre21">
         new
        </code>
        fails, it means that memory is very low and life is very, very bad. It is often an unfathomable state to be in because it's unclear what your program could possibly do in this situation.
       </p>
       <p class="calibre13" id="c07-para-0031">
        By default, an exception is thrown when
        <code class="calibre21">
         new
        </code>
        fails, for example if there is not enough memory available for the request. If this exception is not caught, the program will be terminated. In many programs, this behavior is acceptable.
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        introduces exceptions, and
        <a class="calibre5" href="c14.xhtml">
         Chapter 14
        </a>
        , “Handling Errors,” explains exceptions in more details and provides possible approaches to recover gracefully from an out-of-memory situation.
       </p>
       <p class="calibre13">
        There is also an alternative version of
        <code class="calibre21">
         new
        </code>
        , which does not throw an exception. Instead, it returns
        <code class="calibre21">
         nullptr
        </code>
        if allocation fails, similar to the behavior of
        <code class="calibre21">
         malloc()
        </code>
        in C. The syntax for using this version is as follows:
       </p>
       <pre class="calibre26" id="c07-code-0008"><code class="calibre21">int* ptr { new(nothrow) int };</code></pre>
       <p class="calibre13" id="c07-para-0033">
        The syntax is a little strange: you really do write “nothrow” as if it's an argument to
        <code class="calibre21">
         new
        </code>
        (which it is).
       </p>
       <p class="calibre13" id="c07-para-0034">
        Of course, you still have the same problem as the version that throws an exception—what do you do when the result is
        <code class="calibre21">
         nullptr
        </code>
        ? The compiler doesn't require you to check the result, so the
        <code class="calibre21">
         nothrow
        </code>
        version of
        <code class="calibre21">
         new
        </code>
        is more likely to lead to other bugs than the version that throws an exception. For this reason, it's suggested that you use the standard version of
        <code class="calibre21">
         new
        </code>
        . If out-of-memory recovery is important to your program, the techniques covered in
        <a class="calibre5" href="c14.xhtml">
         Chapter 14
        </a>
        give you all the tools you need.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0015">
      </span>
      <h3 class="calibre27" id="head-3-157">
       Arrays
      </h3>
      <p class="calibre13" id="c07-para-0035">
       Arrays package multiple variables of the same type into a single variable with indices. Working with arrays quickly becomes natural to a novice programmer because it is easy to think about values in numbered slots. The in-memory representation of an array is not far off from this mental model.
      </p>
      <span aria-label="226" class="calibre20" epub:type="pagebreak" id="Page_226" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-128">
        Arrays of Primitive Types
       </h4>
       <p class="calibre13">
        When your program allocates memory for an array, it is allocating
        <i class="calibre18">
         contiguous
        </i>
        pieces of memory, where each piece is large enough to hold a single element of the array. For example, a local array of five
        <code class="calibre21">
         int
        </code>
        s can be declared on the stack as follows:
       </p>
       <pre class="calibre26" id="c07-code-0009"><code class="calibre21">int myArray[5];</code></pre>
       <p class="calibre13">
        The individual elements of such a primitive type array are uninitialized; that is, they contain whatever is at that location in memory.
        <a class="calibre5" href="#c07-fig-0005" id="R_c07-fig-0005">
         Figure 7.5
        </a>
        shows the state of memory after the array is created. When creating arrays on the stack, the size must be a constant value known at compile time.
       </p>
       <figure class="calibre36">
        <img alt="A set of two boxes. The first box reads stack. The second box reads free store. There are five boxes in a row ranging from myArray 0 to 4." class="center" src="images/c07f005.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c07-fig-0005" id="c07-fig-0005" role="doc-backlink">
            <b class="calibre14">
             FIGURE 7.5
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0038">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Some compilers allow variable-sized arrays on the stack. This is not a standard feature of C++, so I recommend cautiously backing away when you see it
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        When creating an array on the stack, an initializer list can be used to provide initial elements:
       </p>
       <pre class="calibre26" id="c07-code-0010"><code class="calibre21">int myArray[5] { 1, 2, 3, 4, 5 };</code></pre>
       <p class="calibre13">
        If the initializer list contains less elements than the size of the array, the remaining elements of the array are zero-initialized (see
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        ), for example:
       </p>
       <pre class="calibre26" id="c07-code-0011"><code class="calibre21">int myArray[5] { 1, 2 }; <span class="color">// 1, 2, 0, 0, 0</span></code>
<code class="calibre21"></code></pre>
       <p class="calibre13">
        To zero-initialize all elements, you can simply write:
       </p>
       <pre class="calibre26" id="c07-code-0012"><code class="calibre21"><span class="color">int myArray[5] { };      // 0, 0, 0, 0, 0</span></code></pre>
       <p class="calibre13">
        When using an initializer list, the compiler can deduce the number of elements automatically, removing the need to explicitly state the size of the array:
       </p>
       <pre class="calibre26" id="c07-code-0013"><code class="calibre21">int myArray[] { 1, 2, 3, 4, 5 };</code></pre>
       <p class="calibre13">
        Declaring arrays on the free store is no different, except that you use a pointer to refer to the location of the array. The following code allocates memory for an array of five uninitialized
        <code class="calibre21">
         int
        </code>
        s and stores a pointer to the memory in a variable called
        <code class="calibre21">
         myArrayPtr
        </code>
        :
       </p>
       <pre class="calibre26" id="c07-code-0014"><code class="calibre21">int* myArrayPtr { new int[5] };</code></pre>
       <p class="calibre13" id="c07-para-0044">
        As
        <a class="calibre5" href="#c07-fig-0006" id="R_c07-fig-0006">
         Figure 7.6
        </a>
        illustrates, the free store-based array is similar to a stack-based array, but in a different location. The
        <code class="calibre21">
         myArrayPtr
        </code>
        variable points to the 0th element of the array.
       </p>
       <p class="calibre13">
        As with the
        <code class="calibre21">
         new
        </code>
        operator,
        <code class="calibre21">
         new[]
        </code>
        accepts a
        <code class="calibre21">
         nothrow
        </code>
        argument to return
        <code class="calibre21">
         nullptr
        </code>
        instead of throwing an exception if allocation fails:
       </p>
       <pre class="calibre26" id="c07-code-0015"><code class="calibre21">int* myArrayPtr { new(nothrow) int[5] };</code></pre>
       <figure class="calibre36">
        <img alt="A set of three boxes. The first box reads stack. The second box reads free store. The third box reads myArrayPtr. There are five boxes in a row ranging from myArrayPtr 0 to 4." class="center" src="images/c07f006.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c07-fig-0006" id="c07-fig-0006" role="doc-backlink">
            <b class="calibre14">
             FIGURE 7.6
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p class="calibre13">
        <span aria-label="227" class="calibre20" epub:type="pagebreak" id="Page_227" role="doc-pagebreak">
        </span>
        Dynamically created arrays on the free store can also be initialized with an initializer list:
       </p>
       <pre class="calibre26" id="c07-code-0016"><code class="calibre21">int* myArrayPtr { new int[] { 1, 2, 3, 4, 5 } };</code></pre>
       <p class="calibre13">
        Each call to
        <code class="calibre21">
         new[]
        </code>
        should be paired with a call to
        <code class="calibre21">
         delete[]
        </code>
        to clean up the memory. Note the empty square brackets,
        <code class="calibre21">
         []
        </code>
        , behind
        <code class="calibre21">
         delete[]
        </code>
        !
       </p>
       <pre class="calibre26" id="c07-code-0017"><code class="calibre21">delete [] myArrayPtr;</code>
<code class="calibre21">myArrayPtr = nullptr;</code></pre>
       <p class="calibre13">
        The advantage of putting an array on the free store is that you can define its size at run time. For example, the following code snippet receives a desired number of documents from a hypothetical function named
        <code class="calibre21">
         askUserForNumberOfDocuments()
        </code>
        and uses that result to create an array of
        <code class="calibre21">
         Document
        </code>
        objects.
       </p>
       <pre class="calibre26" id="c07-code-0018"><code class="calibre21">Document* createDocumentArray()</code>
<code class="calibre21">{</code>
<code class="calibre21">    size_t numberOfDocuments { askUserForNumberOfDocuments() };</code>
<code class="calibre21">    Document* documents { new Document[numberOfDocuments] };</code>
<code class="calibre21">    return documents;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c07-para-0049">
        Remember that each call to
        <code class="calibre21">
         new[]
        </code>
        should be paired with a call to
        <code class="calibre21">
         delete[]
        </code>
        , so in this example, it's important that the caller of
        <code class="calibre21">
         createDocumentArray()
        </code>
        uses
        <code class="calibre21">
         delete[]
        </code>
        to clean up the returned memory. Another problem is that C-style arrays don't know their size; thus, callers of
        <code class="calibre21">
         createDocumentArray()
        </code>
        have no idea how many elements there are in the returned array!
       </p>
       <p class="calibre13">
        In the preceding function,
        <code class="calibre21">
         documents
        </code>
        is a dynamically allocated array. Do not get this confused with a
        <i class="calibre18">
         dynamic array
        </i>
        . The array itself is not dynamic because its size does not change once it is allocated. Dynamic memory lets you specify the size of an allocated block at run time, but it does not automatically adjust its size to accommodate the data.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0051">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            There are data structures that do dynamically adjust their size and that do know their actual size, for example Standard Library containers. You should use such containers instead of C-style arrays because they are much safer to use
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        There is a function in C++ called
        <code class="calibre21">
         realloc()
        </code>
        , which is a holdover from the C language. Do not use it! In C,
        <code class="calibre21">
         realloc()
        </code>
        is used to effectively change the size of an array by allocating a new block of
        <span aria-label="228" class="calibre20" epub:type="pagebreak" id="Page_228" role="doc-pagebreak">
        </span>
        memory of the new size, copying all of the old data to the new location, and deleting the original block. This approach is extremely dangerous in C++ because user-defined objects will not respond well to bitwise copying.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0053">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Never use
           </i>
           <code class="calibre21">
            realloc()
           </code>
           <i class="calibre18">
            in C++! It is not your friend.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0020">
       </span>
       <h4 class="calibre29" id="head-4-129">
        Arrays of Objects
       </h4>
       <p class="calibre13" id="c07-para-0054">
        Arrays of objects are no different than arrays of primitive/fundamental types, except for how their elements are initialized. When you use
        <code class="calibre21">
         new[N]
        </code>
        to allocate an array of
        <i class="calibre18">
         N
        </i>
        objects, enough space is allocated for
        <i class="calibre18">
         N
        </i>
        contiguous blocks where each block is large enough for a single object. For an array of objects,
        <code class="calibre21">
         new[]
        </code>
        automatically calls the zero-argument (= default) constructor for each of the objects, while an array of primitive types by default has uninitialized elements. In this way, allocating an array of objects using
        <code class="calibre21">
         new[]
        </code>
        returns a pointer to an array of fully constructed and initialized objects.
       </p>
       <p class="calibre13">
        For example, consider the following class:
       </p>
       <pre class="calibre26" id="c07-code-0019"><code class="calibre21">class Simple</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Simple() { println("Simple constructor called!"); }</code>
<code class="calibre21">        ˜Simple() { println("Simple destructor called!"); }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        If you allocate an array of four
        <code class="calibre21">
         Simple
        </code>
        objects, the
        <code class="calibre21">
         Simple
        </code>
        constructor is called four times.
       </p>
       <pre class="calibre26" id="c07-code-0020"><code class="calibre21">Simple* mySimpleArray { new Simple[4] };</code></pre>
       <p class="calibre13" id="c07-para-0057">
        <a class="calibre5" href="#c07-fig-0007" id="R_c07-fig-0007">
         Figure 7.7
        </a>
        shows the memory diagram for this array. As you can see, it is no different than an array of basic types.
       </p>
       <figure class="calibre36">
        <img alt="A set of three boxes. The first box reads stack. The second box reads free store. The third box reads mysimpleArray. There are five boxes in a row ranging from mysimpleArray 0 to 4." class="center" src="images/c07f007.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c07-fig-0007" id="c07-fig-0007" role="doc-backlink">
            <b class="calibre14">
             FIGURE 7.7
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0021">
       </span>
       <h4 class="calibre29" id="head-4-130">
        Deleting Arrays
       </h4>
       <p class="calibre13">
        When you allocate memory with
        <code class="calibre21">
         new[]
        </code>
        (i.e., the array version of
        <code class="calibre21">
         new
        </code>
        ), you must release it with
        <code class="calibre21">
         delete[]
        </code>
        (i.e., the array version of
        <code class="calibre21">
         delete
        </code>
        ). This version automatically destructs the objects in the array in addition to releasing the memory associated with them.
       </p>
       <pre class="calibre26" id="c07-code-0021"><code class="calibre21">Simple* mySimpleArray { new Simple[4] };</code>
<code class="calibre21"><span class="color">// Use mySimpleArray…</span></code>
<span aria-label="229" class="calibre20" epub:type="pagebreak" id="Page_229" role="doc-pagebreak"></span><code class="calibre21"><b class="calibre14">delete [] mySimpleArray;</b></code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">mySimpleArray = nullptr;</b></code></pre>
       <p class="calibre13">
        If you do not use the array version of
        <code class="calibre21">
         delete
        </code>
        , your program may behave in odd ways. With some compilers, only the destructor for the first element of the array will be called because the compiler only knows that you are deleting a pointer to an object, and all the other elements of the array will become orphaned objects. With other compilers, memory corruption may occur because
        <code class="calibre21">
         new
        </code>
        and
        <code class="calibre21">
         new[]
        </code>
        can use completely different memory allocation schemes.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0060">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Always use
           </i>
           <code class="calibre21">
            delete
           </code>
           <i class="calibre18">
            on anything allocated with
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            , and always use
           </i>
           <code class="calibre21">
            delete[]
           </code>
           <i class="calibre18">
            on anything allocated with
           </i>
           <code class="calibre21">
            new[]
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Of course, the destructors are called only if the elements of the array are objects. If you have an array of pointers, you still need to delete each object pointed to individually just as you allocated each object individually, as shown in the following code:
       </p>
       <pre class="calibre26" id="c07-code-0022"><code class="calibre21">const size_t size { 4 };</code>
<code class="calibre21">Simple** mySimplePtrArray { new Simple*[size] };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Allocate an object for each pointer.</span></code>
<code class="calibre21">for (size_t i { 0 }; i &lt; size; ++i) { mySimplePtrArray[i] = new Simple{}; }</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Use mySimplePtrArray…</span></code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Delete each allocated object.</span></code>
<code class="calibre21">for (size_t i { 0 }; i &lt; size; ++i) {</code>
<code class="calibre21">    delete mySimplePtrArray[i];</code>
<code class="calibre21">    mySimplePtrArray[i] = nullptr;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Delete the array itself.</span></code>
<code class="calibre21">delete [] mySimplePtrArray;</code>
<code class="calibre21">mySimplePtrArray = nullptr;</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0063">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            In modern C++ you should avoid using raw C-style pointers when ownership is involved. Instead of storing raw pointers in C-style arrays, you should store smart pointers in modern Standard Library containers, such as
           </i>
           <code class="calibre21">
            std::vector
           </code>
           <i class="calibre18">
            . Smart pointers, discussed later in this chapter, automatically deallocate the memory associated with them at the right time
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0024">
       </span>
       <h4 class="calibre29" id="head-4-131">
        Multidimensional Arrays
       </h4>
       <p class="calibre13">
        Multidimensional arrays extend the notion of indexed values to multiple indices. For example, a tic-tac-toe game might use a two-dimensional array to represent a three-by-three grid. The following
        <span aria-label="230" class="calibre20" epub:type="pagebreak" id="Page_230" role="doc-pagebreak">
        </span>
        example shows such an array declared on the stack, zero-initialized, and accessed with some test code:
       </p>
       <pre class="calibre26" id="c07-code-0023"><code class="calibre21">char board[3][3] {};</code>
<code class="calibre21"><span class="color">// Test code</span></code>
<code class="calibre21"><span class="color">board[0][0] = 'X';   // X puts marker in position (0,0).</span></code>
<code class="calibre21"><span class="color">board[2][1] = 'O';   // O puts marker in position (2,1).</span></code></pre>
       <p class="calibre13" id="c07-para-0065">
        You may be wondering whether the first subscript in a two-dimensional array is the x-coordinate or the y-coordinate. The truth is that it doesn't really matter, as long as you are consistent. A four-by-seven grid could be declared as
        <code class="calibre21">
         char board[4][7]
        </code>
        or
        <code class="calibre21">
         char board[7][4]
        </code>
        . For most applications, it is easiest to think of the first subscript as the x-axis and the second as the y-axis.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c07-sec-0025">
        </span>
        <h5 class="calibre35" id="head-5-54">
         Multidimensional Stack Arrays
        </h5>
        <p class="calibre13" id="c07-para-0066">
         In memory, the three-by-three stack-based two-dimensional
         <code class="calibre21">
          board
         </code>
         array looks like
         <a class="calibre5" href="#c07-fig-0008" id="R_c07-fig-0008">
          Figure 7.8
         </a>
         . Because memory doesn't have two axes (addresses are merely sequential), the computer represents a two-dimensional array just like a one-dimensional array. The difference is in the size of the array and the method used to access it.
        </p>
        <figure class="calibre36">
         <img alt="A set of two boxes. The first box reads stack. The second box reads free store. Three sets of nine boxes in a row ranging from board 0 0 to board 2 2." class="center" src="images/c07f008.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c07-fig-0008" id="c07-fig-0008" role="doc-backlink">
             <b class="calibre14">
              FIGURE 7.8
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <p class="calibre13" id="c07-para-0067">
         The size of a multidimensional array is all of its dimensions multiplied together and then multiplied by the size of a single element in the array. In
         <a class="calibre5" href="#c07-fig-0008">
          Figure 7.8
         </a>
         , the three-by-three board is 3 × 3 × 1 = 9 bytes, assuming that a character is 1 byte. For a four-by-seven board of characters, the array would be 4 × 7 × 1 = 28 bytes.
        </p>
        <p class="calibre13" id="c07-para-0068">
         To access a value in a multidimensional array, the computer treats each subscript as if it were accessing another subarray within the multidimensional array. For example, in the three-by-three grid, the expression
         <code class="calibre21">
          board[0]
         </code>
         actually refers to the subarray highlighted in
         <a class="calibre5" href="#c07-fig-0009" id="R_c07-fig-0009">
          Figure 7.9
         </a>
         . When you add a second subscript, such as
         <code class="calibre21">
          board[0][2]
         </code>
         , the computer is able to access the correct element by looking up the second subscript within the subarray, as shown in
         <a class="calibre5" href="#c07-fig-0010" id="R_c07-fig-0010">
          Figure 7.10
         </a>
         .
        </p>
        <p class="calibre13" id="c07-para-0069">
         These techniques are extended to
         <i class="calibre18">
          N
         </i>
         -dimensional arrays, though dimensions higher than three tend to be difficult to conceptualize and are rarely used.
        </p>
        <figure class="calibre36">
         <img alt="A set of two boxes. The first box reads stack. The second box reads free store. Three sets of nine boxes in a row ranging from board 0 0 to board 2 2. The first three are highlighted." class="center" src="images/c07f009.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c07-fig-0009" id="c07-fig-0009" role="doc-backlink">
             <b class="calibre14">
              FIGURE 7.9
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <figure class="calibre36">
         <img alt="A set of two boxes. The first box reads stack. The second box reads free store. Three sets of nine boxes in a row ranging from board 0 0 to board 2 2. The third is highlighted." class="center" src="images/c07f010.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c07-fig-0010" id="c07-fig-0010" role="doc-backlink">
             <b class="calibre14">
              FIGURE 7.10
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
       </section>
       <span aria-label="231" class="calibre20" epub:type="pagebreak" id="Page_231" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c07-sec-0026">
        </span>
        <h5 class="calibre35" id="head-5-55">
         Multidimensional Free Store Arrays
        </h5>
        <p class="calibre13">
         If you need to determine the dimensions of a multidimensional array at run time, you can use a free store-based array. Just as a single-dimensional dynamically allocated array is accessed through a pointer, a multidimensional dynamically allocated array is also accessed through a pointer. The only difference is that in a two-dimensional array, you need to start with a pointer-to-a-pointer; and in an
         <i class="calibre18">
          N
         </i>
         -dimensional array, you need
         <i class="calibre18">
          N
         </i>
         levels of pointers. At first, it might seem as if the correct way to declare and allocate a dynamically allocated multidimensional array is as follows:
        </p>
        <pre class="calibre26" id="c07-code-0024"><code class="calibre21"><span class="color">char** board { new char[i][j] }; // BUG! Doesn't compile</span></code></pre>
        <p class="calibre13" id="c07-para-0071">
         This code doesn't compile because multidimensional free store-based arrays don't work like stack-based arrays. Their memory layout isn't contiguous. Instead, you start by allocating a single contiguous array for the first subscript dimension of a free store-based array. Each element of that array is actually a pointer to another array that stores the elements for the second subscript dimension.
         <a class="calibre5" href="#c07-fig-0011" id="R_c07-fig-0011">
          Figure 7.11
         </a>
         shows this layout for a two-by-two dynamically allocated board.
        </p>
        <figure class="calibre36">
         <img alt="A set of two boxes. The first box reads stack. The second box reads free store. Three sets of six boxes in a row ranging from board 0 to board 1 1." class="center" src="images/c07f011.png"/>
         <figcaption class="calibre37">
          <p class="calibre13">
           <span class="figurelabel">
            <a class="calibre5" href="#R_c07-fig-0011" id="c07-fig-0011" role="doc-backlink">
             <b class="calibre14">
              FIGURE 7.11
             </b>
            </a>
           </span>
          </p>
         </figcaption>
        </figure>
        <p class="calibre13">
         Unfortunately, the compiler doesn't allocate memory for the subarrays on your behalf. You can allocate the first-dimension array just like a single-dimensional free store-based array, but the individual subarrays must be explicitly allocated. The following function properly allocates memory for a two-dimensional array:
        </p>
        <pre class="calibre26" id="c07-code-0025"><code class="calibre21">char** allocateCharacterBoard(size_t xDimension, size_t yDimension)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">char** myArray { new char*[xDimension] }; // Allocate first dimension</span></code>
<span aria-label="232" class="calibre20" epub:type="pagebreak" id="Page_232" role="doc-pagebreak"></span><code class="calibre21">    for (size_t i { 0 }; i &lt; xDimension; ++i) {</code>
<code class="calibre21">        <span class="color">myArray[i] = new char[yDimension];    // Allocate ith subarray</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">    return myArray;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         Similarly, when you want to release the memory associated with a multidimensional free store-based array, the array
         <code class="calibre21">
          delete[]
         </code>
         syntax will not clean up the subarrays on your behalf. Your code to release an array should mirror the code to allocate it, as in the following function:
        </p>
        <pre class="calibre26" id="c07-code-0026"><code class="calibre21">void releaseCharacterBoard(char**&amp; myArray, size_t xDimension)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; xDimension; ++i) {</code>
<code class="calibre21">        <span class="color">delete [] myArray[i];    // Delete ith subarray</span></code>
<code class="calibre21">        myArray[i] = nullptr;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    <span class="color">delete [] myArray;           // Delete first dimension</span></code>
<code class="calibre21">    myArray = nullptr;</code>
<code class="calibre21">}</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c07-para-0075">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             This example of allocating a multidimensional array is not the most efficient solution. It first allocates memory for the first dimension, followed by allocating memory for each subarray. This results in memory blocks scattered around in memory, which will have a performance impact on algorithms working on such data structures. Algorithms run much faster if they can work with contiguous memory. A better solution is to allocate a single block of memory large enough to store
            </i>
            <code class="calibre21">
             xDimension * yDimension
            </code>
            <i class="calibre18">
             elements, and to access an element at position (x,y) with a formula such as
             <code class="calibre21">
              x
             </code>
            </i>
            <code class="calibre21">
             * yDimension +
            </code>
            <i class="calibre18">
             <code class="calibre21">
              y
             </code>
             .
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         Now that you know all the details to work with arrays, it is recommended to avoid these old C-style arrays as much as possible because they do not provide any memory safety. They are explained here because you will encounter them in legacy code. In new code, you should use the C++ Standard Library containers such as
         <code class="calibre21">
          std::array
         </code>
         and
         <code class="calibre21">
          vector
         </code>
         . For example, use
         <code class="calibre21">
          vector&lt;T&gt;
         </code>
         for a one-dimensional dynamic array. For a two-dimensional dynamic array, you could use
         <code class="calibre21">
          vector&lt;vector&lt;T&gt;&gt;
         </code>
         , and similar for higher dimensions. Of course, working directly with data structures such as
         <code class="calibre21">
          vector&lt;vector&lt;T&gt;&gt;
         </code>
         is still tedious, especially for constructing them, and they suffer from the same memory fragmentation problem as discussed in the previous note. So, if you do need
         <i class="calibre18">
          N
         </i>
         -dimensional dynamic arrays in your application, consider writing helper classes that provide an easier to use interface. For example, to work with two-dimensional data with equally long rows, you should consider writing (or reusing of course) a
         <code class="calibre21">
          Matrix&lt;T&gt;
         </code>
         or
         <code class="calibre21">
          Table&lt;T&gt;
         </code>
         class template that hides the memory allocation/deallocation and element access algorithms from the user. See
         <a class="calibre5" href="c12.xhtml">
          Chapter 12
         </a>
         , “Writing Generic Code with Templates,” for details on writing class templates.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c07-para-0077">
            <b class="calibre14">
             WARNING
            </b>
            <i class="calibre18">
             Use C++ Standard Library containers such as
            </i>
            <code class="calibre21">
             std::array
            </code>
            <i class="calibre18">
             ,
            </i>
            <code class="calibre21">
             vector
            </code>
            <i class="calibre18">
             , and so on, instead of C-style arrays!
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
     </section>
     <span aria-label="233" class="calibre20" epub:type="pagebreak" id="Page_233" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0029">
      </span>
      <h3 class="calibre27" id="head-3-158">
       Working with Pointers
      </h3>
      <p class="calibre13">
       Pointers get their bad reputation from the relative ease with which you can abuse them. Because a pointer is just a memory address, you could theoretically change that address manually, even doing something as scary as the following line of code:
      </p>
      <pre class="calibre26" id="c07-code-0027"><code class="calibre21">char* scaryPointer { (char*)7 };</code></pre>
      <p class="calibre13" id="c07-para-0079">
       This line builds a pointer to the memory address 7, which is likely to be random garbage or memory used elsewhere in the application. If you start to use areas of memory that weren't set aside on your behalf, for example with
       <code class="calibre21">
        new
       </code>
       or on the stack, eventually you will corrupt the memory associated with an object, or the memory involved with the management of the free store, and your program will malfunction. Such a malfunction can manifest itself in several ways. For example, it can reveal itself as invalid results because the data has been corrupted, or as hardware exceptions being triggered due to accessing non-existent memory, or attempting to write to protected memory. If you are lucky, you will get one of the serious errors that usually result in program termination by the operating system or the C++ runtime library; if you are unlucky, you will just get wrong results.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-132">
        A Mental Model for Pointers
       </h4>
       <p class="calibre13" id="c07-para-0080">
        There are two ways to think about pointers. More mathematically minded readers might view pointers as addresses. This view makes pointer arithmetic, covered later in this chapter, a bit easier to understand. Pointers aren't mysterious pathways through memory; they are numbers that happen to correspond to a location in memory.
        <a class="calibre5" href="#c07-fig-0012" id="R_c07-fig-0012">
         Figure 7.12
        </a>
        illustrates a two-by-two grid in the address-based view of the world.
        <a aria-describedby="c07-note-0002" class="calibre5" epub:type="noteref" href="#c07-note-0002" id="R_c07-note-0002" role="doc-noteref">
         <sup class="calibre22">
          2
         </sup>
        </a>
       </p>
       <figure class="calibre36">
        <img alt="A set of two boxes. The first box reads stack. The second box reads free store. The left box is board 1000. Three sets of six boxes in a row ranging from board 1000 to board 5001." class="center" src="images/c07f012.png"/>
        <figcaption class="calibre37">
         <p class="calibre13">
          <span class="figurelabel">
           <a class="calibre5" href="#R_c07-fig-0012" id="c07-fig-0012" role="doc-backlink">
            <b class="calibre14">
             FIGURE 7.12
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p class="calibre13" id="c07-para-0081">
        Readers who are more comfortable with spatial representations might derive more benefit from the “arrow” view of pointers. A pointer is a level of indirection that says to the program, “Hey! Look over there.” With this view, multiple levels of pointers become individual steps on the path to the data.
        <a class="calibre5" href="#c07-fig-0011">
         Figure 7.11
        </a>
        shows a graphical view of pointers in memory.
       </p>
       <p class="calibre13" id="c07-para-0082">
        When you
        <i class="calibre18">
         dereference
        </i>
        a pointer, by using the
        <code class="calibre21">
         *
        </code>
        operator, you are telling the program to look one level deeper in memory. In the address-based view, think of a dereference as a jump in memory to the address indicated by the pointer. With the graphical view, every dereference corresponds to following an arrow from its base to its head.
       </p>
       <p class="calibre13" id="c07-para-0083">
        When you take the address of a location, using the
        <code class="calibre21">
         &amp;
        </code>
        operator, you are adding a level of indirection in memory. In the address-based view, the program is noting the numerical address of the location, which can be stored as a pointer. In the graphical view, the
        <code class="calibre21">
         &amp;
        </code>
        operator creates a new arrow whose head ends at the location designated by the expression. The base of the arrow can be stored as a pointer.
       </p>
      </section>
      <span aria-label="234" class="calibre20" epub:type="pagebreak" id="Page_234" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0031">
       </span>
       <h4 class="calibre29" id="head-4-133">
        Casting with Pointers
       </h4>
       <p class="calibre13">
        Because pointers are just memory addresses (or arrows to somewhere), they are somewhat weakly typed. A pointer to an XML document is the same size as a pointer to an integer. The compiler lets you easily cast any pointer type to any other pointer type using a
        <i class="calibre18">
         C-style cast
        </i>
        :
       </p>
       <pre class="calibre26" id="c07-code-0028"><code class="calibre21">Document* documentPtr { getDocument() };</code>
<code class="calibre21"><b class="calibre14">char* myCharPtr { (char*)documentPtr };</b></code></pre>
       <p class="calibre13">
        Of course, using the resulting pointer can result in catastrophic run-time errors. A
        <i class="calibre18">
         static cast
        </i>
        offers a bit more safety. The compiler refuses to perform a static cast on pointers to unrelated data types:
       </p>
       <pre class="calibre26" id="c07-code-0029"><code class="calibre21">Document* documentPtr { getDocument() };</code>
<code class="calibre21"><span class="color"><b class="calibre14">char* myCharPtr { static_cast&lt;char*&gt;(documentPtr) };</b>   // BUG! Won't compile</span></code></pre>
       <p class="calibre13" id="c07-para-0086">
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        , “Discovering Inheritance Techniques,” discusses the different styles of casts in detail.
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-95" class="calibre2">
     <span class="calibre" id="c07-sec-0032">
     </span>
     <h2 class="calibre6" id="head-2-95">
      ARRAY-POINTER DUALITY
     </h2>
     <p class="calibre13" id="c07-para-0087">
      You have already seen some of the overlap between pointers and arrays. Free store-allocated arrays are referred to by a pointer to their first element. Stack-based arrays are referred to by using the array syntax (
      <code class="calibre21">
       []
      </code>
      ) with an otherwise normal variable declaration. As you are about to learn, however, the overlap doesn't end there. Pointers and arrays have a complicated relationship.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0033">
      </span>
      <h3 class="calibre27" id="head-3-159">
       Arrays Decay to Pointers
      </h3>
      <p class="calibre13">
       A free store-based array is not the only place where you can use a pointer to refer to an array. You can also use the pointer syntax to access elements of a stack-based array. The address of an array is really the address of the first element (index 0). The compiler knows that when you refer to an array in its entirety by its variable name, you are really referring to the address of the first element. In this way, the pointer works just like with a free store-based array. The following code creates a zero-initialized array on the stack, and uses a pointer to access it:
      </p>
      <pre class="calibre26" id="c07-code-0030"><code class="calibre21">int myIntArray[10] {};</code>
<code class="calibre21"> </code>
<code class="calibre21">int* myIntPtr { myIntArray };</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Access the array through the pointer.</span></code>
<code class="calibre21">myIntPtr[4] = 5;</code></pre>
      <p class="calibre13">
       The ability to refer to a stack-based array through a pointer is useful when passing arrays into functions. The following function accepts an array of integers as a pointer. Note that the caller needs to explicitly pass in the size of the array because the pointer implies nothing about size. That is another reason why you should use modern containers such as those provided by the Standard Library.
      </p>
      <pre class="calibre26" id="c07-code-0031"><code class="calibre21">void doubleInts(int* theArray, size_t size)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) { theArray[i] *= 2; }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The caller of this function can pass a stack-based or free store-based array. In the case of a free store-based array, the pointer already exists and is passed by value into the function. In the case of a stack-based array, the caller can pass the array variable, and the compiler automatically treats the array
       <span aria-label="235" class="calibre20" epub:type="pagebreak" id="Page_235" role="doc-pagebreak">
       </span>
       variable as a pointer to the array, or you can explicitly pass the address of the first element. All three forms are shown here:
      </p>
      <pre class="calibre26" id="c07-code-0032"><code class="calibre21">size_t arrSize { 4 };</code>
<code class="calibre21">int* freeStoreArray { new int[arrSize]{ 1, 5, 3, 4 } };</code>
<code class="calibre21"><b class="calibre14">doubleInts(freeStoreArray, arrSize);</b></code>
<code class="calibre21">delete [] freeStoreArray;</code>
<code class="calibre21">freeStoreArray = nullptr;</code>
<code class="calibre21"> </code>
<code class="calibre21">int stackArray[] { 5, 7, 9, 11 };</code>
<code class="calibre21"><span class="color">arrSize = std::size(stackArray);    // Since C++17, requires &lt;array&gt;</span></code>
<code class="calibre21"><span class="color">//arrSize = sizeof(stackArray) / sizeof(stackArray[0]); // Pre-C++17, see Ch1</span></code>
<code class="calibre21"><b class="calibre14">doubleInts(stackArray, arrSize);</b></code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">doubleInts(&amp;stackArray[0], arrSize);</b></code></pre>
      <p class="calibre13">
       The parameter-passing semantics of arrays is uncannily similar to that of pointers, because the compiler treats an array as a pointer when it is passed to a function. A function that takes an array as an argument and changes values inside the array is actually changing the original array, not a copy. Just like a pointer, passing an array effectively mimics pass-by-reference functionality because what you really pass to the function is the address of the original array, not a copy. The following implementation of
       <code class="calibre21">
        doubleInts()
       </code>
       changes the original array even though the parameter is an array, not a pointer:
      </p>
      <pre class="calibre26" id="c07-code-0033"><code class="calibre21"><b class="calibre14">void doubleInts(int theArray[], size_t size)</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; size; ++i) { theArray[i] *= 2; }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Any number between the square brackets after
       <code class="calibre21">
        theArray
       </code>
       in the function prototype is simply ignored. The following three versions are identical:
      </p>
      <pre class="calibre26" id="c07-code-0034"><code class="calibre21">void doubleInts(int* theArray, size_t size);</code>
<code class="calibre21">void doubleInts(int theArray[], size_t size);</code>
<code class="calibre21">void doubleInts(int theArray[2], size_t size);</code></pre>
      <p class="calibre13" id="c07-para-0093">
       You may be wondering why things work this way. Why doesn't the compiler just copy the array when array syntax is used in the function definition? This is done for efficiency—it takes time to copy the elements of an array, and they potentially take up a lot of memory. By always passing a pointer, the compiler doesn't need to include the code to copy the array.
      </p>
      <p class="calibre13">
       There is a way to pass known-length stack-based arrays “by reference” to a function, although the syntax is non-obvious. This does not work for free store-based arrays. For example, the following
       <code class="calibre21">
        doubleIntsStack()
       </code>
       accepts only stack-based arrays of size 4:
      </p>
      <pre class="calibre26" id="c07-code-0035"><code class="calibre21">void doubleIntsStack(int (&amp;theArray)[4]);</code></pre>
      <p class="calibre13">
       A function template, discussed in detail in
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       , can be used to let the compiler deduce the size of the stack-based array automatically:
      </p>
      <pre class="calibre26" id="c07-code-0036"><code class="calibre21">template &lt;size_t N&gt;</code>
<code class="calibre21">void doubleIntsStack(int (&amp;theArray)[N])</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; N; ++i) { theArray[i] *= 2; }</code>
<code class="calibre21">} </code></pre>
      <p class="calibre13">
       <span aria-label="236" class="calibre20" epub:type="pagebreak" id="Page_236" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c07-para-0097">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Instead of passing a C-style array directly to a function, it is recommended for the function to have a parameter of type
          </i>
          <code class="calibre21">
           std::span
          </code>
          <i class="calibre18">
           , discussed in
          </i>
          <a class="calibre5" href="c18_split_000.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           18
          </a>
          <i class="calibre18">
           , “Standard Library Containers.”
          </i>
          <code class="calibre21">
           span
          </code>
          <i class="calibre18">
           wraps a pointer to an array and its size!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0035">
      </span>
      <h3 class="calibre27" id="head-3-160">
       Not All Pointers Are Arrays!
      </h3>
      <p class="calibre13" id="c07-para-0098">
       Because the compiler lets you pass in an array where a pointer is expected, as in the
       <code class="calibre21">
        doubleInts()
       </code>
       function in the previous section, you may be led to believe that pointers and arrays are the same. In fact, there are subtle, but important, differences. Pointers and arrays share many properties and can sometimes be used interchangeably (as shown earlier), but they are not the same.
      </p>
      <p class="calibre13">
       A pointer by itself is meaningless. It may point to random memory, a single object, or an array. You can always use array syntax with a pointer, but doing so is not always appropriate because pointers aren't always arrays. For example, consider the following line of code:
      </p>
      <pre class="calibre26" id="c07-code-0037"><code class="calibre21">int* ptr { new int };</code></pre>
      <p class="calibre13">
       The pointer
       <code class="calibre21">
        ptr
       </code>
       is a valid pointer, but it is not an array. You can access the pointed-to value using array syntax (
       <code class="calibre21">
        ptr[0]
       </code>
       ), but doing so is stylistically questionable and provides no real benefit. In fact, using array syntax with non-array pointers is an invitation for bugs. The memory at
       <code class="calibre21">
        ptr[1]
       </code>
       could be anything!
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c07-para-0101">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Arrays automatically decay to pointers, but not all pointers are arrays
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-96" class="calibre2">
     <span class="calibre" id="c07-sec-0037">
     </span>
     <h2 class="calibre6" id="head-2-96">
      LOW-LEVEL MEMORY OPERATIONS
     </h2>
     <p class="calibre13" id="c07-para-0102">
      One of the great advantages of C++ over C is that you don't need to worry quite as much about memory. If you code using objects, you just need to make sure that each individual class properly manages its own memory. Through construction and destruction, the compiler helps you manage memory by telling you when to do it. Hiding the management of memory within classes makes a huge difference in usability, as demonstrated by the Standard Library classes. However, with some applications or with legacy code, you may encounter the need to work with memory at a lower level. Whether for legacy, efficiency, debugging, or curiosity, knowing some techniques for working with raw bytes can be helpful.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0038">
      </span>
      <h3 class="calibre27" id="head-3-161">
       Pointer Arithmetic
      </h3>
      <p class="calibre13">
       The C++ compiler uses the declared types of pointers to allow you to perform
       <i class="calibre18">
        pointer arithmetic
       </i>
       . If you declare a pointer to an
       <code class="calibre21">
        int
       </code>
       and increase it by 1, the pointer moves ahead in memory by the size of an
       <code class="calibre21">
        int
       </code>
       , not by a single byte. This type of operation is most useful with arrays, because they contain homogeneous data that is sequential in memory. For example, assume you declare an array of
       <code class="calibre21">
        int
       </code>
       s on the free store:
      </p>
      <pre class="calibre26" id="c07-code-0038"><code class="calibre21">int* myArray { new int[8] };</code></pre>
      <p class="calibre13">
       <span aria-label="237" class="calibre20" epub:type="pagebreak" id="Page_237" role="doc-pagebreak">
       </span>
       You are already familiar with the following syntax for setting the value at index 2:
      </p>
      <pre class="calibre26" id="c07-code-0039"><code class="calibre21">myArray[2] = 33;</code></pre>
      <p class="calibre13">
       With pointer arithmetic, you can equivalently use the following syntax, which obtains a pointer to the memory that is “2
       <code class="calibre21">
        int
       </code>
       s ahead” of
       <code class="calibre21">
        myArray
       </code>
       and then dereferences it to set the value:
      </p>
      <pre class="calibre26" id="c07-code-0040"><code class="calibre21">*(myArray + 2) = 33;</code></pre>
      <p class="calibre13" id="c07-para-0106">
       As an alternative syntax for accessing individual elements, pointer arithmetic doesn't seem too appealing. Its real power lies in the fact that an expression like
       <code class="calibre21">
        myArray+2
       </code>
       is still a pointer to an
       <code class="calibre21">
        int
       </code>
       and thus can represent a smaller
       <code class="calibre21">
        int
       </code>
       array.
      </p>
      <p class="calibre13">
       Let's look at an example using wide strings. Wide strings are discussed in
       <a class="calibre5" href="c21.xhtml">
        Chapter 21
       </a>
       , “String Localization and Regular Expressions,” but the details are not important at this point. For now, it is enough to know that wide strings support Unicode characters to represent, for example, Japanese strings. The
       <code class="calibre21">
        wchar_t
       </code>
       type is a character type that can accommodate such Unicode characters, and it is usually bigger than a
       <code class="calibre21">
        char
       </code>
       ; i.e., it's more than one byte. To tell the compiler that a string literal is a wide-string literal, prefix it with an
       <code class="calibre21">
        L
       </code>
       . For example, suppose you have the following wide string:
      </p>
      <pre class="calibre26" id="c07-code-0041"><code class="calibre21">const wchar_t* myString { L"Hello, World" };</code></pre>
      <p class="calibre13">
       Suppose further that you have a function that takes in a wide string and returns a new string that contains a capitalized version of the input:
      </p>
      <pre class="calibre26" id="c07-code-0042"><code class="calibre21">wchar_t* toCaps(const wchar_t* text);</code></pre>
      <p class="calibre13">
       You can capitalize
       <code class="calibre21">
        myString
       </code>
       by passing it into this function. However, if you only want to capitalize
       <i class="calibre18">
        part
       </i>
       of
       <code class="calibre21">
        myString
       </code>
       , you can use pointer arithmetic to refer to only a latter part of the string. The following code calls
       <code class="calibre21">
        toCaps()
       </code>
       on the
       <code class="calibre21">
        World
       </code>
       part of the wide string by just adding 7 to the pointer, even though
       <code class="calibre21">
        wchar_t
       </code>
       is usually more than 1 byte:
      </p>
      <pre class="calibre26" id="c07-code-0043"><code class="calibre21">toCaps(myString + 7);</code></pre>
      <p class="calibre13" id="c07-para-0110">
       Another useful application of pointer arithmetic involves subtraction. Subtracting one pointer from another of the same type gives you the number of elements of the pointed-to type between the two pointers, not the absolute number of bytes between them.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0039">
      </span>
      <h3 class="calibre27" id="head-3-162">
       Custom Memory Management
      </h3>
      <p class="calibre13" id="c07-para-0111">
       For 99 percent of the cases you will encounter (some might say 100 percent of the cases), the built-in memory allocation facilities in C++ are adequate. Behind the scenes,
       <code class="calibre21">
        new
       </code>
       and
       <code class="calibre21">
        delete
       </code>
       do all the work of handing out memory in properly sized chunks, maintaining a list of available areas of memory and releasing chunks of memory back to that list upon deletion.
      </p>
      <p class="calibre13" id="c07-para-0112">
       When resource constraints are extremely tight, or under very special conditions, such as managing shared memory, implementing custom memory management may be a viable option. Don't worry—it's not as scary as it sounds. Basically, managing memory yourself means that classes allocate a large chunk of memory and dole out that memory in pieces as it is needed.
      </p>
      <p class="calibre13" id="c07-para-0113">
       How is this approach any better? Managing your own memory can potentially reduce overhead. When you use
       <code class="calibre21">
        new
       </code>
       to allocate memory, the program also needs to set aside a small amount of space to record how much memory was allocated. That way, when you call
       <code class="calibre21">
        delete
       </code>
       , the proper amount of
       <span aria-label="238" class="calibre20" epub:type="pagebreak" id="Page_238" role="doc-pagebreak">
       </span>
       memory can be released. For most objects, the overhead is so much smaller than the memory allocated that it makes little difference. However, for small objects or programs with enormous numbers of objects, the overhead can have an impact.
      </p>
      <p class="calibre13" id="c07-para-0114">
       When you manage memory yourself, you might know the size of each object a priori, so you might be able to avoid the overhead for each object. The difference can be enormous for large numbers of small objects. Performing custom memory management requires overloading the operators
       <code class="calibre21">
        new
       </code>
       and
       <code class="calibre21">
        delete
       </code>
       , a topic for
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       , “Overloading C++ Operators.”
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0040">
      </span>
      <h3 class="calibre27" id="head-3-163">
       Garbage Collection
      </h3>
      <p class="calibre13" id="c07-para-0115">
       With environments that support
       <i class="calibre18">
        garbage collection
       </i>
       , the programmer rarely, if ever, explicitly frees memory associated with an object. Instead, objects to which there are no longer any references will be cleaned up automatically at some point by the runtime library.
      </p>
      <p class="calibre13" id="c07-para-0116">
       Garbage collection is not built into the C++ language as it is in C# and Java. In modern C++, you use smart pointers to manage memory, while in legacy code you will see memory management at the object level through
       <code class="calibre21">
        new
       </code>
       and
       <code class="calibre21">
        delete
       </code>
       . Smart pointers such as
       <code class="calibre21">
        shared_ptr
       </code>
       (discussed later in this chapter) provide something very similar to garbage-collected memory; that is, when the last
       <code class="calibre21">
        shared_ptr
       </code>
       instance for a certain resource is destroyed, at that point in time the resource is destroyed as well. It is possible but not easy to implement true garbage collection in C++, but freeing yourself from the task of releasing memory would probably introduce new headaches.
      </p>
      <p class="calibre13" id="c07-para-0117">
       One approach to garbage collection is called
       <i class="calibre18">
        mark and sweep
       </i>
       . With this approach, the garbage collector periodically examines every single pointer in your program and annotates the fact that the referenced memory is still in use. At the end of the cycle, any memory that hasn't been marked is deemed to be not in-use and is freed. Implementing such an algorithm in C++ is not trivial, and if done wrongly, it can be even more error-prone than using
       <code class="calibre21">
        delete
       </code>
       !
      </p>
      <p class="calibre13">
       Attempts at safe and easy mechanisms for garbage collection have been made in C++, but even if a perfect implementation of garbage collection in C++ came along, it wouldn't necessarily be appropriate to use for all applications. Among the downsides of garbage collection are the following:
      </p>
      <ul class="check" id="c07-list-0002">
       <li class="calibre9" id="c07-li-0006">
        When the garbage collector is actively running, the program might become unresponsive.
       </li>
       <li class="calibre9" id="c07-li-0007">
        With garbage collectors, you have non-deterministic destructors. Because an object is not destroyed until it is garbage-collected, the destructor is not executed immediately when the object leaves its scope. This means that cleaning up resources (such as closing a file, releasing a lock, and so on), which is done by the destructor, is not performed until some indeterminate time in the future.
       </li>
      </ul>
      <p class="calibre13" id="c07-para-0119">
       Writing a garbage collection mechanism is very hard. You will undoubtedly do it wrong, it will be error prone, and more than likely it will be slow. So, if you do want to use garbage-collected memory in your application, I recommend you to research existing specialized garbage-collection libraries that you can reuse.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-164">
       Object Pools
      </h3>
      <p class="calibre13" id="c07-para-0120">
       Garbage collection is like buying plates for a picnic and leaving any used plates out in the yard where someone at some point will pick them up and throw them away. Surely, there must be a more ecological approach to memory management.
      </p>
      <p class="calibre13" id="c07-para-0121">
       <span aria-label="239" class="calibre20" epub:type="pagebreak" id="Page_239" role="doc-pagebreak">
       </span>
       Object pools are the equivalent of recycling. You buy a reasonable number of plates, and after using a plate, you clean it so that it can be reused later. Object pools are ideal for situations where you need to use many objects of the same type over time, and creating each one incurs overhead.
      </p>
      <p class="calibre13" id="c07-para-0122">
       <a class="calibre5" href="c29.xhtml">
        Chapter 29
       </a>
       , “Writing Efficient C++,” contains further details on using object pools for performance efficiency.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-97" class="calibre2">
     <span class="calibre" id="c07-sec-0042">
     </span>
     <h2 class="calibre6" id="head-2-97">
      COMMON MEMORY PITFALLS
     </h2>
     <p class="calibre13" id="c07-para-0123">
      Handling dynamic memory using
      <code class="calibre21">
       new
      </code>
      /
      <code class="calibre21">
       delete
      </code>
      /
      <code class="calibre21">
       new[]
      </code>
      /
      <code class="calibre21">
       delete[]
      </code>
      , and low-level memory operations are prone to errors. It is difficult to pinpoint the exact situations that can lead to a memory-related bug. Every memory leak or bad pointer has its own nuances. There is no magic bullet for resolving memory issues. This section discusses several common categories of problems and some tools you can use to detect and resolve them.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-165">
       Underallocating Data Buffers and Out-of-Bounds Memory Access
      </h3>
      <p class="calibre13" id="c07-para-0124">
       Underallocation is a common problem with C-style strings, where it arises when the programmer fails to allocate an extra character for the trailing
       <code class="calibre21">
        '\0'
       </code>
       sentinel. Underallocation of strings also occurs when programmers assume a certain fixed maximum size. The basic built-in C-style string functions do not adhere to a fixed size—they will happily write off the end of the string into uncharted memory.
      </p>
      <p class="calibre13">
       The following code demonstrates underallocation. It reads data off a network connection and puts it in a C-style string. This is done in a loop because the network connection receives only a small amount of data at a time. On each loop,
       <code class="calibre21">
        getMoreData()
       </code>
       is called, which returns a pointer to dynamically allocated memory. When
       <code class="calibre21">
        nullptr
       </code>
       is returned from
       <code class="calibre21">
        getMoreData()
       </code>
       , all of the data has been received.
       <code class="calibre21">
        strcat()
       </code>
       is a C function that concatenates the C-style string given as a second argument to the end of the C-style string given as a first argument. It expects the destination buffer to be big enough.
      </p>
      <pre class="calibre26" id="c07-code-0044"><code class="calibre21"><span class="color">char buffer[1024] { 0 };   // Allocate a whole bunch of memory.</span></code>
<code class="calibre21">while (true) {</code>
<code class="calibre21">    char* nextChunk { getMoreData() };</code>
<code class="calibre21">    if (nextChunk == nullptr) {</code>
<code class="calibre21">        break;</code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        <span class="color">strcat(buffer, nextChunk); // BUG! No guarantees against buffer overrun!</span></code>
<code class="calibre21">        delete [] nextChunk;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       There are three ways to resolve the possible underallocation problem in this example. In decreasing order of preference, they are as follows:
      </p>
      <ol class="calibre7" id="c07-list-0003">
       <li class="calibre9" id="c07-li-0008">
        Use C++-style strings, which handle the memory associated with concatenation on your behalf.
       </li>
       <li class="calibre9" id="c07-li-0009">
        Instead of allocating a buffer as a global variable or on the stack, allocate it on the free store. When there is insufficient space left, allocate a new buffer large enough to hold at least the
        <span aria-label="240" class="calibre20" epub:type="pagebreak" id="Page_240" role="doc-pagebreak">
        </span>
        current contents plus the new chunk, copy the original buffer into the new buffer, append the new contents, and delete the original buffer.
       </li>
       <li class="calibre9" id="c07-li-0010">
        Create a version of
        <code class="calibre21">
         getMoreData()
        </code>
        that takes a maximum count (including the
        <code class="calibre21">
         '\0'
        </code>
        character) and returns no more characters than that; then track the amount of space left, and the current position, in the buffer.
       </li>
      </ol>
      <p class="calibre13" id="c07-para-0127">
       Underallocation of data buffers usually leads to out-of-bounds memory access. For example, if you are filling a memory buffer with data, you might start writing outside the allocated data buffer when you assume the buffer is bigger than it actually is. It is only a matter of time before an essential part of memory is overwritten and the program crashes. Consider what might happen if the memory associated with the objects in your program is suddenly overwritten. It's not pretty!
      </p>
      <p class="calibre13">
       Out-of-bounds memory access also occurs when handling C-style strings that have somehow lost their
       <code class="calibre21">
        '\0'
       </code>
       termination character. For example, if an improperly terminated string is handed to the following function, it will fill the string with
       <code class="calibre21">
        'm'
       </code>
       characters and will happily continue to fill the contents of memory after the string with
       <code class="calibre21">
        'm'
       </code>
       s, overwriting memory outside the bounds of the string.
      </p>
      <pre class="calibre26" id="c07-code-0045"><code class="calibre21">void fillWithM(char* text)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int i { 0 };</code>
<code class="calibre21">    while (text[i] != '\0') {</code>
<code class="calibre21">        text[i] = 'm';</code>
<code class="calibre21">        ++i;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Bugs that result in writing to memory past the end of an array are often called
       <i class="calibre18">
        buffer overflow errors
       </i>
       . These bugs have been exploited by several high-profile malware programs such as viruses and worms. A devious hacker can take advantage of the ability to overwrite portions of memory to inject code into a running program.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c07-para-0130">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Avoid using old C-style strings and arrays that offer no protection whatsoever. Instead, use modern and safe constructs such as C++
          </i>
          <code class="calibre21">
           string
          </code>
          <i class="calibre18">
           s and
          </i>
          <code class="calibre21">
           vector
          </code>
          <i class="calibre18">
           s that manage all their memory for you.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0045">
      </span>
      <h3 class="calibre27" id="head-3-166">
       Memory Leaks
      </h3>
      <p class="calibre13" id="c07-para-0131">
       In modern C++, there are no memory leaks. All memory management is handled by higher-level classes, such as
       <code class="calibre21">
        std::vector
       </code>
       ,
       <code class="calibre21">
        string
       </code>
       , and so on. Only when you drive off-road and perform manual memory allocation and deallocation can memory leaks crop up.
      </p>
      <p class="calibre13" id="c07-para-0132">
       Finding and fixing such memory leaks can be frustrating. Your program finally works and appears to give the correct results. Then, you start to notice that your program gobbles up more and more memory as it runs. Your program has a memory leak.
      </p>
      <p class="calibre13">
       Memory leaks occur when you allocate memory and neglect to release it. At first, this sounds like the result of careless programming that could easily be avoided. After all, if every
       <code class="calibre21">
        new
       </code>
       has a
       <span aria-label="241" class="calibre20" epub:type="pagebreak" id="Page_241" role="doc-pagebreak">
       </span>
       corresponding
       <code class="calibre21">
        delete
       </code>
       in every class you write, there should be no memory leaks, right? Actually, that's not always true. For example, in the following code, the
       <code class="calibre21">
        Simple
       </code>
       class is properly written to release any memory that it allocates. However, when
       <code class="calibre21">
        doSomething()
       </code>
       is called, the
       <code class="calibre21">
        outSimplePtr
       </code>
       pointer is changed to another
       <code class="calibre21">
        Simple
       </code>
       object without deleting the old one to demonstrate a memory leak. Once you lose a pointer to an object, it's nearly impossible to delete it.
      </p>
      <pre class="calibre26" id="c07-code-0046"><code class="calibre21">class Simple</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Simple() { m_intPtr = new int{}; }</code>
<code class="calibre21">        ˜Simple() { delete m_intPtr; }</code>
<code class="calibre21">        void setValue(int value) { *m_intPtr = value; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int* m_intPtr;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">void doSomething(Simple*&amp; outSimplePtr)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">outSimplePtr = new Simple{}; // BUG! Doesn't delete the original.</span></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">Simple* simplePtr { new Simple{} }; // Allocate a Simple object.</span></code>
<code class="calibre21">    doSomething(simplePtr);</code>
<code class="calibre21">    <span class="color">delete simplePtr; // Only cleans up the second object.</span></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c07-para-0135">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Keep in mind that this code is only for demonstration purposes! In production-quality code, both
          </i>
          <code class="calibre21">
           m_intPtr
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           simplePtr
          </code>
          <i class="calibre18">
           should not be raw pointers, but should be smart pointers discussed later in this chapter.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c07-para-0136">
       In cases like the previous example, the memory leak probably arose from poor communication between programmers or poor documentation of the code. The caller of
       <code class="calibre21">
        doSomething()
       </code>
       may not have realized that the variable was passed by reference and thus had no reason to expect that the pointer would be reassigned. If they did notice that the parameter was a reference-to-non-
       <code class="calibre21">
        const
       </code>
       pointer, they may have suspected that something strange was happening, but there is no comment around
       <code class="calibre21">
        doSomething()
       </code>
       that explains this behavior.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0047">
       </span>
       <h4 class="calibre29" id="head-4-134">
        Finding and Fixing Memory Leaks in Windows with Visual C++
       </h4>
       <p class="calibre13">
        Memory leaks are hard to track down because you can't easily look at memory and see what objects are not in use and where they were originally allocated. However, there are programs that can do this for you. Memory leak detection tools range from expensive professional software packages to free downloadable tools. If you work with Microsoft Visual C++, its debug library has built-in support for memory leak detection. This memory leak detection is not enabled by default, unless you create an MFC project. To enable it in other projects, you need to start by including the following three lines at the beginning of your code. These use the
        <code class="calibre21">
         #define
        </code>
        preprocessor macro, explained in
        <a class="calibre5" href="c11.xhtml">
         Chapter 11
        </a>
        ,
        <span aria-label="242" class="calibre20" epub:type="pagebreak" id="Page_242" role="doc-pagebreak">
        </span>
        “Modules, Header Files, and Miscellaneous Topics.” However, for now, just use the three lines verbatim as they are.
       </p>
       <pre class="calibre26" id="c07-code-0047"><code class="calibre21">#define _CRTDBG_MAP_ALLOC</code>
<code class="calibre21">#include &lt;cstdlib&gt;</code>
<code class="calibre21">#include &lt;crtdbg.h&gt;</code></pre>
       <p class="calibre13">
        These lines should be in the exact order as shown. Next, you need to redefine the
        <code class="calibre21">
         new
        </code>
        operator as follows. This uses a few other preprocessor macros, all explained in
        <a class="calibre5" href="c11.xhtml">
         Chapter 11
        </a>
        . Again, just use them as is for now.
       </p>
       <pre class="calibre26" id="c07-code-0048"><code class="calibre21">#ifdef _DEBUG</code>
<code class="calibre21">    #ifndef DBG_NEW</code>
<code class="calibre21">        #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )</code>
<code class="calibre21">        #define new DBG_NEW</code>
<code class="calibre21">    #endif</code>
<code class="calibre21"><span class="color">#endif  // _DEBUG</span></code></pre>
       <p class="calibre13" id="c07-para-0139">
        The
        <code class="calibre21">
         #ifdef _DEBUG
        </code>
        statement makes sure that the redefinition of
        <code class="calibre21">
         new
        </code>
        is done only when compiling a debug version of your application. This is what you normally want. Release builds usually do not do any memory leak detection, because of the performance penalty.
       </p>
       <p class="calibre13">
        The last thing you need to do is to add the following line as the first line in your
        <code class="calibre21">
         main()
        </code>
        function:
       </p>
       <pre class="calibre26" id="c07-code-0049"><code class="calibre21">_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);</code></pre>
       <p class="calibre13">
        This tells the Visual C++ CRT (C RunTime) library to write all detected memory leaks to the debug output console when the application exits. For the earlier leaky program, the debug console will contain lines similar to the following:
       </p>
       <pre class="calibre26" id="c07-code-0050"><code class="calibre21">Detected memory leaks!</code>
<code class="calibre21">Dumping objects -&gt;</code>
<code class="calibre21">c:\leaky\leaky.cpp(15) : {147} normal block at 0x014FABF8, 4 bytes long.</code>
<code class="calibre21"> Data: &lt;  &gt; 00 00 00 00</code>
<code class="calibre21">c:\leaky\leaky.cpp(33) : {146} normal block at 0x014F5048, 4 bytes long.</code>
<code class="calibre21"> Data: &lt;Pa&gt; 50 61 20 01</code>
<code class="calibre21">Object dump complete.</code></pre>
       <p class="calibre13">
        <?sup Start??>
        The output clearly shows in which file and on which line memory was allocated but never deallocated. The line number is between parentheses immediately behind the filename. The number between the curly braces is a counter for the memory allocations. For example, {147} means the 147th allocation in your program since it started. You can use the VC++
        <code class="calibre21">
         _CrtSetBreakAlloc()
        </code>
        function to tell the VC++ debug runtime to break into the debugger when a certain allocation is performed. For example, you can add the following line to the beginning of your
        <code class="calibre21">
         main()
        </code>
        function to instruct the debugger to break on the 147th allocation:
       </p>
       <pre class="calibre26" id="c07-code-0051"><code class="calibre21">_CrtSetBreakAlloc(147);</code></pre>
       <p class="calibre13" id="c07-para-0143">
        In this leaky program, there are two leaks: the first
        <code class="calibre21">
         Simple
        </code>
        object that is never deleted (line 33) and the integer on the free store that it creates (line 15). In the Visual C++ debugger output window, you can simply double-click one of the memory leaks, and it will automatically jump to that line in your code.
       </p>
       <p class="calibre13" id="c07-para-0144">
        Of course, programs like Microsoft Visual C++ (discussed in this section) and Valgrind (discussed in the next section) can't actually fix the leak for you—what fun would that be? These tools provide
        <span aria-label="243" class="calibre20" epub:type="pagebreak" id="Page_243" role="doc-pagebreak">
        </span>
        information that you can use to find the actual problem. Normally, that involves stepping through the code to find out where the pointer to an object was overwritten without the original object being released. Most debuggers provide “watch point” functionality that can break execution of the program when this occurs.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0048">
       </span>
       <h4 class="calibre29" id="head-4-135">
        Finding and Fixing Memory Leaks in Linux with Valgrind
       </h4>
       <p class="calibre13" id="c07-para-0145">
        Valgrind is an example of a free open-source tool for Linux that, among other things, pinpoints the exact line in your code where a leaked object was allocated.
       </p>
       <p class="calibre13">
        The following output, generated by running Valgrind on the earlier leaky program, pinpoints the exact locations where memory was allocated but never released. Valgrind finds the same two memory leaks—the first
        <code class="calibre21">
         Simple
        </code>
        object never deleted and the integer on the free store that it creates:
       </p>
       <pre class="calibre26" id="c07-code-0052"><code class="calibre21">==15606== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</code>
<code class="calibre21">==15606== malloc/free: in use at exit: 8 bytes in 2 blocks.</code>
<code class="calibre21">==15606== malloc/free: 4 allocs, 2 frees, 16 bytes allocated.</code>
<code class="calibre21">==15606== For counts of detected errors, rerun with: -v</code>
<code class="calibre21">==15606== searching for pointers to 2 not-freed blocks.</code>
<code class="calibre21">==15606== checked 4455600 bytes.</code>
<code class="calibre21">==15606==</code>
<code class="calibre21"><b class="calibre14">==15606== 4 bytes in 1 blocks are still reachable in loss record 1 of 2</b></code>
<code class="calibre21">==15606==    at 0x4002978F: __builtin_new (vg_replace:malloc.c:172)</code>
<code class="calibre21">==15606==    by 0x400297E6: operator new(unsigned) (vg_replace:malloc.c:185)</code>
<code class="calibre21"><b class="calibre14">==15606==    by 0x804875B: Simple::Simple() (leaky.cpp:4)</b></code>
<code class="calibre21">==15606==    by 0x8048648: main (leaky.cpp:24)</code>
<code class="calibre21">==15606==</code>
<code class="calibre21">==15606==</code>
<code class="calibre21"><b class="calibre14">==15606== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2</b></code>
<code class="calibre21">==15606==    at 0x4002978F: __builtin_new (vg_replace:malloc.c:172)</code>
<code class="calibre21">==15606==    by 0x400297E6: operator new(unsigned) (vg_replace:malloc.c:185)</code>
<code class="calibre21"><b class="calibre14">==15606==    by 0x8048633: main (leaky.cpp:20)</b></code>
<code class="calibre21">==15606==    by 0x4031FA46: __libc_start_main (in /lib/libc-2.3.2.so)</code>
<code class="calibre21">==15606==</code>
<code class="calibre21">==15606== LEAK SUMMARY:</code>
<code class="calibre21">==15606==    definitely lost: 4 bytes in 1 blocks.</code>
<code class="calibre21">==15606==    possibly lost:   0 bytes in 0 blocks.</code>
<code class="calibre21">==15606==    still reachable: 4 bytes in 1 blocks.</code>
<code class="calibre21">==15606==         suppressed: 0 bytes in 0 blocks.</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0148">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            It is strongly recommended to use
           </i>
           <code class="calibre21">
            std::vector
           </code>
           <i class="calibre18">
            ,
           </i>
           <code class="calibre21">
            array
           </code>
           <i class="calibre18">
            ,
           </i>
           <code class="calibre21">
            string
           </code>
           <i class="calibre18">
            , smart pointers (discussed later in this chapter), and other modern C++ constructs to avoid memory leaks.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0050">
      </span>
      <h3 class="calibre27" id="head-3-167">
       Double-Deletion and Invalid Pointers
      </h3>
      <p class="calibre13" id="c07-para-0149">
       Once you release memory associated with a pointer using
       <code class="calibre21">
        delete
       </code>
       , the memory is available for use by other parts of your program. Nothing stops you, however, from attempting to continue to use the pointer, which is now a
       <i class="calibre18">
        dangling pointer
       </i>
       . Double deletion is also a problem. If you use
       <code class="calibre21">
        delete
       </code>
       <span aria-label="244" class="calibre20" epub:type="pagebreak" id="Page_244" role="doc-pagebreak">
       </span>
       a second time on a pointer, the program could be releasing memory that has since been assigned to another object.
      </p>
      <p class="calibre13" id="c07-para-0150">
       Double deletion and use of already released memory are both difficult problems to track down because the symptoms may not show up immediately. If two deletions occur within a relatively short amount of time, the program potentially could work indefinitely because the associated memory might not have been reused that quickly. Similarly, if a deleted object is used immediately after being deleted, most likely it will still be intact.
      </p>
      <p class="calibre13" id="c07-para-0151">
       Of course, there is no guarantee that such behavior will work or continue to work. The memory allocator is under no obligation to preserve any object once it has been deleted. Even if it does work, it is extremely poor programming style to use objects that have been deleted.
      </p>
      <p class="calibre13" id="c07-para-0152">
       To avoid double deletion and use of already released memory, you should set your pointers to
       <code class="calibre21">
        nullptr
       </code>
       after deallocating their memory.
      </p>
      <p class="calibre13" id="c07-para-0153">
       Many memory leak-detection programs are also capable of detecting double deletion and use of released objects.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-98" class="calibre2">
     <span class="calibre" id="c07-sec-0051">
     </span>
     <h2 class="calibre6" id="head-2-98">
      SMART POINTERS
     </h2>
     <p class="calibre13" id="c07-para-0154">
      As the previous section demonstrated, memory management in C++ is a perennial source of errors and bugs. Many of these bugs arise from the use of dynamic memory allocation and pointers. When you extensively use dynamic memory allocation in your program and pass many pointers between objects, it's difficult to remember to call
      <code class="calibre21">
       delete
      </code>
      on each pointer exactly once and at the right time. The consequences of getting it wrong are severe: when you free dynamically allocated memory more than once or use a pointer to memory that was already free, you can cause memory corruption or a fatal run-time error; when you forget to free dynamically allocated memory, you cause memory leaks.
     </p>
     <p class="calibre13" id="c07-para-0155">
      Smart pointers help you manage your dynamically allocated memory and are the recommended technique for avoiding memory leaks. Conceptually, a smart pointer can hold a dynamically allocated resource, such as memory. When a smart pointer goes out of scope or is reset, it can automatically free the resource it holds. Smart pointers can be used to manage dynamically allocated resources in the scope of a function, or as data members in classes. They can also be used to pass ownership of dynamically allocated resources through function arguments.
     </p>
     <p class="calibre13" id="c07-para-0156">
      C++ provides several language features that make smart pointers attractive. First, you can write a type-safe smart pointer class for any pointer type using templates; see
      <a class="calibre5" href="c12.xhtml">
       Chapter 12
      </a>
      . Second, you can provide an interface to the smart pointer objects using operator overloading (see
      <a class="calibre5" href="c15.xhtml">
       Chapter 15
      </a>
      ) that allows code to use the smart pointer objects as if they were dumb raw pointers. Specifically, you can overload the
      <code class="calibre21">
       *
      </code>
      , –
      <code class="calibre21">
       &gt;
      </code>
      , and
      <code class="calibre21">
       []
      </code>
      operators such that client code can dereference a smart pointer object the same way it dereferences a normal pointer.
     </p>
     <p class="calibre13" id="c07-para-0157">
      There are several types of smart pointers. The simplest type takes sole/unique ownership of a resource. Being the single owner of a resource, the smart pointer can automatically free the referenced resource when it goes out of scope or is reset. The Standard Library provides
      <code class="calibre21">
       std::unique_ptr
      </code>
      , which is a smart pointer with
      <i class="calibre18">
       unique ownership
      </i>
      semantics.
     </p>
     <p class="calibre13" id="c07-para-0158">
      <span aria-label="245" class="calibre20" epub:type="pagebreak" id="Page_245" role="doc-pagebreak">
      </span>
      A slightly more advanced type of smart pointer allows for
      <i class="calibre18">
       shared ownership
      </i>
      ; that is, several of these smart pointers can refer to the same resource. When such a smart pointer goes out of scope or is reset, it frees the referenced resource only if it's the last smart pointer referring to that resource. The Standard Library provides
      <code class="calibre21">
       std::shared_ptr
      </code>
      supporting shared ownership.
     </p>
     <p class="calibre13">
      Both standard smart pointers,
      <code class="calibre21">
       unique_ptr
      </code>
      and
      <code class="calibre21">
       shared_ptr
      </code>
      , are defined in
      <code class="calibre21">
       &lt;memory&gt;
      </code>
      and are discussed in detail in the next sections.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c07-para-0160">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Your default smart pointer should be
         </i>
         <code class="calibre21">
          unique_ptr
         </code>
         <i class="calibre18">
          . Use
         </i>
         <code class="calibre21">
          shared_ptr
         </code>
         <i class="calibre18">
          only when you really need to share the resource.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c07-para-0161">
         <b class="calibre14">
          WARNING
         </b>
         <i class="calibre18">
          Never assign the result of a resource allocation to a raw pointer! Whatever resource allocation method you use, always immediately store the resource pointer in a smart pointer, either
         </i>
         <code class="calibre21">
          unique_ptr
         </code>
         <i class="calibre18">
          or
         </i>
         <code class="calibre21">
          shared_ptr
         </code>
         <i class="calibre18">
          , or use other RAII classes. RAII stands for Resource Acquisition Is Initialization. An RAII class takes ownership of a certain resource and handles its deallocation at the right time. It's a design technique discussed in
         </i>
         <a class="calibre5" href="c32.xhtml">
          <i class="calibre18">
           Chapter
          </i>
          32
         </a>
         <i class="calibre18">
          , “Incorporating Design Techniques and Frameworks.”
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0054">
      </span>
      <h3 class="calibre27" id="head-3-168">
       unique_ptr
      </h3>
      <p class="calibre13" id="c07-para-0162">
       A
       <code class="calibre21">
        unique_ptr
       </code>
       has sole ownership of a resource. When the
       <code class="calibre21">
        unique_ptr
       </code>
       is destroyed or reset, the resource is automatically freed. One advantage is that memory and resources are always freed, even when
       <code class="calibre21">
        return
       </code>
       statements are executed or when exceptions are thrown. This, for example, simplifies coding when a function has multiple
       <code class="calibre21">
        return
       </code>
       statements, because you don't have to remember to free resources before each
       <code class="calibre21">
        return
       </code>
       statement.
      </p>
      <p class="calibre13" id="c07-para-0163">
       As a rule of thumb, always store dynamically allocated resources having a single owner in instances of
       <code class="calibre21">
        unique_ptr
       </code>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0055">
       </span>
       <h4 class="calibre29" id="head-4-136">
        Creating unique_ptrs
       </h4>
       <p class="calibre13">
        Consider the following function that blatantly leaks memory by allocating a
        <code class="calibre21">
         Simple
        </code>
        object on the free store and neglecting to release it:
       </p>
       <pre class="calibre26" id="c07-code-0053"><code class="calibre21">void leaky()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">Simple* mySimplePtr { new Simple{} };  // BUG! Memory is never released!</span></code>
<code class="calibre21">    mySimplePtr-&gt;go();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Sometimes you might think that your code is properly deallocating dynamically allocated memory. Unfortunately, it most likely is
        <i class="calibre18">
         not correct
        </i>
        in all situations. Take the following function:
       </p>
       <pre class="calibre26" id="c07-code-0054"><span aria-label="246" class="calibre20" epub:type="pagebreak" id="Page_246" role="doc-pagebreak"></span><code class="calibre21">void couldBeLeaky()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Simple* mySimplePtr { new Simple{} };</code>
<code class="calibre21">    mySimplePtr-&gt;go();</code>
<code class="calibre21">    delete mySimplePtr;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c07-para-0166">
        This function dynamically allocates a
        <code class="calibre21">
         Simple
        </code>
        object, uses the object, and then properly calls
        <code class="calibre21">
         delete
        </code>
        . However, you can still have memory leaks in this example! If the
        <code class="calibre21">
         go()
        </code>
        member function throws an exception, the call to
        <code class="calibre21">
         delete
        </code>
        is never executed, causing a memory leak.
       </p>
       <p class="calibre13" id="c07-para-0167">
        Instead, you should use a
        <code class="calibre21">
         unique_ptr
        </code>
        , created using the
        <code class="calibre21">
         std::make_unique()
        </code>
        helper function.
        <code class="calibre21">
         unique_ptr
        </code>
        is a generic smart pointer that can point to any kind of memory. That's why it is a class template, and
        <code class="calibre21">
         make_unique()
        </code>
        a function template. Both require a template parameter between angle brackets, &lt; &gt;, specifying the type of memory you want the
        <code class="calibre21">
         unique_ptr
        </code>
        to point to. Templates are discussed in detail in
        <a class="calibre5" href="c12.xhtml">
         Chapter 12
        </a>
        , but those details are not important to understand how to use smart pointers.
       </p>
       <p class="calibre13">
        The following function uses a
        <code class="calibre21">
         unique_ptr
        </code>
        instead of a raw pointer. The
        <code class="calibre21">
         Simple
        </code>
        object is not explicitly deleted; but when the
        <code class="calibre21">
         unique_ptr
        </code>
        instance goes out of scope (at the end of the function, or because an exception is thrown), it automatically deallocates the
        <code class="calibre21">
         Simple
        </code>
        object in its destructor.
       </p>
       <pre class="calibre26" id="c07-code-0055"><code class="calibre21">void notLeaky()</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto mySimpleSmartPtr { make_unique&lt;Simple&gt;() };</code>
<code class="calibre21">    mySimpleSmartPtr-&gt;go();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c07-para-0169">
        This code uses
        <code class="calibre21">
         make_unique()
        </code>
        , in combination with the
        <code class="calibre21">
         auto
        </code>
        keyword, so that you only have to specify the type of the pointer,
        <code class="calibre21">
         Simple
        </code>
        in this case, once. This is the recommended way to create a
        <code class="calibre21">
         unique_ptr
        </code>
        . If the
        <code class="calibre21">
         Simple
        </code>
        constructor requires parameters, you pass them as arguments to
        <code class="calibre21">
         make_unique()
        </code>
        .
       </p>
       <p class="calibre13" id="c07-para-0170">
        <code class="calibre21">
         make_unique()
        </code>
        uses value initialization. Primitive types, for example, are initialized to zero, and objects are default constructed. If you don't need this value initialization, for instance because you will overwrite the initial value anyway, then you can skip the value initialization and improve performance by using the
        <code class="calibre21">
         make_unique_for_overwrite()
        </code>
        function, which uses default initialization. For primitive types, this means they are not initialized at all and contain whatever is in memory at their location, while objects are still default constructed.
       </p>
       <p class="calibre13">
        You can also create a
        <code class="calibre21">
         unique_ptr
        </code>
        by directly calling its constructor as follows. Note that
        <code class="calibre21">
         Simple
        </code>
        must now be mentioned twice:
       </p>
       <pre class="calibre26" id="c07-code-0056"><code class="calibre21">unique_ptr&lt;Simple&gt; mySimpleSmartPtr { new Simple{} };</code></pre>
       <p class="calibre13" id="c07-para-0172">
        As discussed earlier in this book, class template argument deduction (CTAD) can often be used to let the compiler deduce the template type arguments for class templates based on the arguments passed to a constructor of the class template. For example, it allows you to write
        <code class="calibre21">
         vector v{1,2}
        </code>
        instead of
        <code class="calibre21">
         vector&lt;int&gt; v{1,2}
        </code>
        . CTAD does not work with
        <code class="calibre21">
         unique_ptr
        </code>
        , so you cannot omit the template type argument.
       </p>
       <p class="calibre13">
        <span aria-label="247" class="calibre20" epub:type="pagebreak" id="Page_247" role="doc-pagebreak">
        </span>
        Before C++17, you had to use
        <code class="calibre21">
         make_unique()
        </code>
        not only because it meant specifying the type only once, but also because of safety reasons! Consider the following call to a function called
        <code class="calibre21">
         foo()
        </code>
        :
       </p>
       <pre class="calibre26" id="c07-code-0057"><code class="calibre21">foo(unique_ptr&lt;Simple&gt; { new Simple{} }, unique_ptr&lt;Bar&gt; { new Bar { data() } });</code></pre>
       <p class="calibre13">
        If the constructor of
        <code class="calibre21">
         Simple
        </code>
        or
        <code class="calibre21">
         Bar
        </code>
        , or the
        <code class="calibre21">
         data()
        </code>
        function, throws an exception, depending on your compiler optimizations, it was possible that either a
        <code class="calibre21">
         Simple
        </code>
        or a
        <code class="calibre21">
         Bar
        </code>
        object would be leaked. With
        <code class="calibre21">
         make_unique()
        </code>
        , nothing would leak:
       </p>
       <pre class="calibre26" id="c07-code-0058"><code class="calibre21">foo(make_unique&lt;Simple&gt;(), make_unique&lt;Bar&gt;(data()))</code></pre>
       <p class="calibre13">
        Since C++17, both calls to
        <code class="calibre21">
         foo()
        </code>
        are safe, but I still recommend using
        <code class="calibre21">
         make_unique()
        </code>
        as it results in code that is easier to read.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0176">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Always use
           </i>
           <code class="calibre21">
            make_unique()
           </code>
           <i class="calibre18">
            to create a
           </i>
           <code class="calibre21">
            unique_ptr
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0057">
       </span>
       <h4 class="calibre29" id="head-4-137">
        Using unique_ptrs
       </h4>
       <p class="calibre13">
        One of the greatest characteristics of the standard smart pointers is that they provide enormous benefit without requiring the user to learn a lot of new syntax. Smart pointers can still be dereferenced (using
        <code class="calibre21">
         *
        </code>
        or
        <code class="calibre21">
         -&gt;
        </code>
        ) just like standard pointers. For example, in the earlier example, the
        <code class="calibre21">
         -&gt;
        </code>
        operator is used to call the
        <code class="calibre21">
         go()
        </code>
        member function:
       </p>
       <pre class="calibre26" id="c07-code-0059"><code class="calibre21">mySimpleSmartPtr-&gt;go();</code></pre>
       <p class="calibre13">
        Just as with standard pointers, you can also write this as follows:
       </p>
       <pre class="calibre26" id="c07-code-0060"><code class="calibre21">(*mySimpleSmartPtr).go();</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         get()
        </code>
        member function can be used to get direct access to the underlying pointer. This can be useful to pass the pointer to a function that requires a raw pointer. For example, suppose you have the following function:
       </p>
       <pre class="calibre26" id="c07-code-0061"><code class="calibre21">void processData(Simple* simple) { <span class="color">/* Use the simple pointer… */</span> }</code></pre>
       <p class="calibre13">
        Then you can call it as follows:
       </p>
       <pre class="calibre26" id="c07-code-0062"><code class="calibre21">processData(mySimpleSmartPtr.get());</code></pre>
       <p class="calibre13">
        You can free the underlying pointer of a
        <code class="calibre21">
         unique_ptr
        </code>
        and optionally change it to another pointer using
        <code class="calibre21">
         reset()
        </code>
        . Here's an example:
       </p>
       <pre class="calibre26" id="c07-code-0063"><code class="calibre21"><span class="color">mySimpleSmartPtr.reset();             // Free resource and set to nullptr</span></code>
<code class="calibre21"><span class="color">mySimpleSmartPtr.reset(new Simple{}); // Free resource and set to a new</span></code>
<code class="calibre21">                                      <span class="color">// Simple instance</span></code></pre>
       <p class="calibre13">
        You can disconnect the underlying pointer from a
        <code class="calibre21">
         unique_ptr
        </code>
        with
        <code class="calibre21">
         release()
        </code>
        which returns the underlying pointer to the resource and then sets the smart pointer to
        <code class="calibre21">
         nullptr
        </code>
        . Effectively, the smart pointer loses ownership of the resource, and as such, you become responsible for freeing the resource when you are done with it! Here's an example:
       </p>
       <pre class="calibre26" id="c07-code-0064"><code class="calibre21"><span class="color">Simple* simple { mySimpleSmartPtr.release() }; // Release ownership</span></code>
<code class="calibre21"><span class="color">// Use the simple pointer…</span></code>
<span aria-label="248" class="calibre20" epub:type="pagebreak" id="Page_248" role="doc-pagebreak"></span><code class="calibre21">delete simple;</code>
<code class="calibre21">simple = nullptr;</code></pre>
       <p class="calibre13">
        Because a
        <code class="calibre21">
         unique_ptr
        </code>
        represents unique ownership, it cannot be
        <i class="calibre18">
         copied
        </i>
        ! But, spoiler alert, it is possible to
        <i class="calibre18">
         move
        </i>
        one
        <code class="calibre21">
         unique_ptr
        </code>
        to another one using move semantics, as discussed in detail in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        , “Mastering Classes and Objects.” As a sneak preview, the
        <code class="calibre21">
         std::move()
        </code>
        utility function can be used to explicitly move ownership of a
        <code class="calibre21">
         unique_ptr
        </code>
        , as in the following code snippet. Don't worry about the syntax for now;
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
        makes it all clear.
       </p>
       <pre class="calibre26" id="c07-code-0065"><code class="calibre21">class Foo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Foo(unique_ptr&lt;int&gt; data) : m_data { move(data) } { }</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        unique_ptr&lt;int&gt; m_data;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">auto myIntSmartPtr { make_unique&lt;int&gt;(42) };</code>
<code class="calibre21"><b class="calibre14">Foo f { move(myIntSmartPtr) };</b></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0058">
       </span>
       <h4 class="calibre29" id="head-4-138">
        unique_ptr and C-Style Arrays
       </h4>
       <p class="calibre13">
        A
        <code class="calibre21">
         unique_ptr
        </code>
        can store a dynamically allocated old C-style array. The following example creates a
        <code class="calibre21">
         unique_ptr
        </code>
        that holds a dynamically allocated C-style array of ten integers:
       </p>
       <pre class="calibre26" id="c07-code-0066"><code class="calibre21">auto myVariableSizedArray { make_unique&lt;int[]&gt;(10) };</code></pre>
       <p class="calibre13">
        The type of
        <code class="calibre21">
         myVariableSizedArray
        </code>
        is
        <code class="calibre21">
         unique_ptr&lt;int[]&gt;
        </code>
        and supports access to its elements using array notation. Here's an example:
       </p>
       <pre class="calibre26" id="c07-code-0067"><code class="calibre21">myVariableSizedArray[1] = 123;</code></pre>
       <p class="calibre13" id="c07-para-0186">
        Just as for the non-array case,
        <code class="calibre21">
         make_unique()
        </code>
        uses value initialization for all elements of an array, similarly as
        <code class="calibre21">
         std::vector
        </code>
        does. For primitive types, this means initialization to zero. The
        <code class="calibre21">
         make_unique_for_overwrite()
        </code>
        function can be used instead to create an array with default-initialized values, which means uninitialized for primitive types. Keep in mind, though, that uninitialized data should be avoided as much as possible, so use this judiciously.
       </p>
       <p class="calibre13" id="c07-para-0187">
        Even though it is possible to use a
        <code class="calibre21">
         unique_ptr
        </code>
        to store a dynamically allocated C-style array, it's recommended to use a Standard Library container instead, such as
        <code class="calibre21">
         std::array
        </code>
        or
        <code class="calibre21">
         vector
        </code>
        .
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0059">
       </span>
       <h4 class="calibre29" id="head-4-139">
        Custom Deleters
       </h4>
       <p class="calibre13">
        By default,
        <code class="calibre21">
         unique_ptr
        </code>
        uses the standard
        <code class="calibre21">
         new
        </code>
        and
        <code class="calibre21">
         delete
        </code>
        operators to allocate and deallocate memory. You can change this behavior to use your own allocation and deallocation functions. This can come in handy when you are working with third-party C libraries. For example, suppose you have a C library that requires you to use
        <code class="calibre21">
         my_alloc()
        </code>
        for allocation and
        <code class="calibre21">
         my_free()
        </code>
        for deallocation:
       </p>
       <pre class="calibre26" id="c07-code-0068"><code class="calibre21">int* my_alloc(int value) { return new int { value }; }</code>
<code class="calibre21">void my_free(int* p) { delete p; }</code></pre>
       <p class="calibre13">
        To properly call
        <code class="calibre21">
         my_free()
        </code>
        on an allocated resource at the right time, you can use a
        <code class="calibre21">
         unique_ptr
        </code>
        with a customer deleter:
       </p>
       <pre class="calibre26" id="c07-code-0069"><code class="calibre21">unique_ptr&lt;int<b class="calibre14">, decltype(&amp;my_free)</b>&gt; myIntSmartPtr { my_alloc(42)<b class="calibre14">, my_free</b> };</code></pre>
       <p class="calibre13" id="c07-para-0190">
        <span aria-label="249" class="calibre20" epub:type="pagebreak" id="Page_249" role="doc-pagebreak">
        </span>
        This code allocates memory for an integer with
        <code class="calibre21">
         my_alloc()
        </code>
        , and the
        <code class="calibre21">
         unique_ptr
        </code>
        deallocates the memory by calling the my_f
        <code class="calibre21">
         ree()
        </code>
        function. This feature of
        <code class="calibre21">
         unique_ptr
        </code>
        is also useful to manage other resources instead of just memory. For example, it can be used to automatically close a file or network socket or anything when the
        <code class="calibre21">
         unique_ptr
        </code>
        goes out of scope.
       </p>
       <p class="calibre13" id="c07-para-0191">
        Unfortunately, the syntax for a custom deleter with
        <code class="calibre21">
         unique_ptr
        </code>
        is a bit clumsy. You need to specify the type of your custom deleter as a template type argument, which should be the type of a pointer to a function accepting a single pointer as argument and returning
        <code class="calibre21">
         void
        </code>
        . In this example,
        <code class="calibre21">
         decltype(&amp;my_free)
        </code>
        is used, which returns the type of a pointer to the function
        <code class="calibre21">
         my_free()
        </code>
        . Using a custom deleter with
        <code class="calibre21">
         shared_ptr
        </code>
        is easier. The following section on
        <code class="calibre21">
         shared_ptr
        </code>
        demonstrates how to use a
        <code class="calibre21">
         shared_ptr
        </code>
        to automatically close a file when it goes out of scope.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0060">
      </span>
      <h3 class="calibre27" id="head-3-169">
       shared_ptr
      </h3>
      <p class="calibre13" id="c07-para-0192">
       Sometimes, several objects or pieces of code need copies of the same pointer. A
       <code class="calibre21">
        unique_ptr
       </code>
       cannot be copied and hence cannot be used for such cases. Instead,
       <code class="calibre21">
        std::shared_ptr
       </code>
       is a smart pointer supporting shared ownership that can be copied. But, if there are multiple instances of
       <code class="calibre21">
        shared_ptr
       </code>
       referring to the same resource, how can they know when to actually free the resource? This is solved through reference counting, the topic of an upcoming section: “The Need for Reference Counting.” But first, let's look at how you can construct and use
       <code class="calibre21">
        shared_ptr
       </code>
       s.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0061">
       </span>
       <h4 class="calibre29" id="head-4-140">
        Creating and Using shared_ptrs
       </h4>
       <p class="calibre13">
        You use
        <code class="calibre21">
         shared_ptr
        </code>
        in a similar way as
        <code class="calibre21">
         unique_ptr
        </code>
        . To create one, you use
        <code class="calibre21">
         make_shared()
        </code>
        , which is more efficient than creating a
        <code class="calibre21">
         shared_ptr
        </code>
        directly. Here's an example:
       </p>
       <pre class="calibre26" id="c07-code-0070"><code class="calibre21">auto mySimpleSmartPtr { make_shared&lt;Simple&gt;() };</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0195">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Always use
           </i>
           <code class="calibre21">
            make_shared()
           </code>
           <i class="calibre18">
            to create a
           </i>
           <code class="calibre21">
            shared_ptr
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c07-para-0196">
        Just as with
        <code class="calibre21">
         unique_ptr
        </code>
        , class template argument deduction does not work for
        <code class="calibre21">
         shared_ptr
        </code>
        , so you have to specify the template type.
       </p>
       <p class="calibre13" id="c07-para-0197">
        <code class="calibre21">
         make_shared()
        </code>
        uses value initialization, similar to
        <code class="calibre21">
         make_unique()
        </code>
        . If this is not desired, you can use
        <code class="calibre21">
         make_shared_for_overwrite()
        </code>
        for default initialization, analogous to
        <code class="calibre21">
         make_unique_for_overwrite()
        </code>
        .
       </p>
       <p class="calibre13" id="c07-para-0198">
        A
        <code class="calibre21">
         shared_ptr
        </code>
        can be used to store a pointer to a dynamically allocated C-style array, just as you can do with a
        <code class="calibre21">
         unique_ptr
        </code>
        . You can use
        <code class="calibre21">
         make_shared()
        </code>
        for this, just as you can use
        <code class="calibre21">
         make_unique()
        </code>
        . However, even though it is now possible to store C-style arrays in a
        <code class="calibre21">
         shared_ptr
        </code>
        , I still recommend to use Standard Library containers instead of C-style arrays.
       </p>
       <p class="calibre13" id="c07-para-0199">
        A
        <code class="calibre21">
         shared_ptr
        </code>
        also supports the
        <code class="calibre21">
         get()
        </code>
        and
        <code class="calibre21">
         reset()
        </code>
        member functions, just as a
        <code class="calibre21">
         unique_ptr
        </code>
        . The only difference is that when calling
        <code class="calibre21">
         reset()
        </code>
        , the underlying resource is freed only when the last
        <code class="calibre21">
         shared_ptr
        </code>
        is destroyed or reset. Note that
        <code class="calibre21">
         shared_ptr
        </code>
        does not support
        <code class="calibre21">
         release()
        </code>
        . You can use the
        <code class="calibre21">
         use_count()
        </code>
        member function to retrieve the number of
        <code class="calibre21">
         shared_ptr
        </code>
        instances that are sharing the same resource.
       </p>
       <p class="calibre13">
        <span aria-label="250" class="calibre20" epub:type="pagebreak" id="Page_250" role="doc-pagebreak">
        </span>
        Just like
        <code class="calibre21">
         unique_ptr
        </code>
        ,
        <code class="calibre21">
         shared_ptr
        </code>
        by default uses the standard
        <code class="calibre21">
         new
        </code>
        and
        <code class="calibre21">
         delete
        </code>
        operators to allocate and deallocate memory, or
        <code class="calibre21">
         new[]
        </code>
        and
        <code class="calibre21">
         delete[]
        </code>
        when storing a C-style array. You can change this behavior as follows:
       </p>
       <pre class="calibre26" id="c07-code-0071"><code class="calibre21"><span class="color">// Implementations of my_alloc() and my_free() as before.</span></code>
<code class="calibre21">shared_ptr&lt;int&gt; myIntSmartPtr { my_alloc(42), my_free };</code></pre>
       <p class="calibre13" id="c07-para-0201">
        As you can see, you don't have to specify the type of the custom deleter as a template type argument, so this makes it easier than a custom deleter with
        <code class="calibre21">
         unique_ptr
        </code>
        .
       </p>
       <p class="calibre13">
        The following example uses a
        <code class="calibre21">
         shared_ptr
        </code>
        to store a file pointer. When the
        <code class="calibre21">
         shared_ptr
        </code>
        is destroyed (in this case when it goes out of scope), the file pointer is automatically closed with a call to
        <code class="calibre21">
         close()
        </code>
        . Note that C++ has proper object-oriented classes to work with files (see
        <a class="calibre5" href="c13.xhtml">
         Chapter 13
        </a>
        , “Demystifying C++ I/O”). Those classes already automatically close their files. This example using the old C-style
        <code class="calibre21">
         fopen()
        </code>
        and
        <code class="calibre21">
         fclose()
        </code>
        functions is just to give a demonstration of what
        <code class="calibre21">
         shared_ptr
        </code>
        s can be used for besides pure memory. For example, it comes in handy if you have to use a C-style library, for which there is no C++ alternative, and that has similar functions to open and close resources. You could wrap them in
        <code class="calibre21">
         shared_ptr
        </code>
        s as in this example.
       </p>
       <pre class="calibre26" id="c07-code-0072"><code class="calibre21">void close(FILE* filePtr)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (filePtr == nullptr) { return; }</code>
<code class="calibre21">    fclose(filePtr);</code>
<code class="calibre21">    println("File closed.");</code>
<code class="calibre21">}</code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    FILE* f { fopen("data.txt", "w") };</code>
<code class="calibre21">    shared_ptr&lt;FILE&gt; filePtr { f, close };</code>
<code class="calibre21">    if (filePtr == nullptr) {</code>
<code class="calibre21">        println(cerr, "Error opening file.");</code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        println("File opened.");</code>
<code class="calibre21">        <span class="color">// Use filePtr</span></code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0063">
       </span>
       <h4 class="calibre29" id="head-4-141">
        The Need for Reference Counting
       </h4>
       <p class="calibre13" id="c07-para-0203">
        As briefly mentioned earlier, when a smart pointer with shared ownership, such as
        <code class="calibre21">
         shared_ptr
        </code>
        , goes out of scope or is reset, it should only free the referenced resource if it's the last smart pointer referring to it. How is this accomplished? One solution, used by the
        <code class="calibre21">
         shared_ptr
        </code>
        Standard Library smart pointer, is
        <i class="calibre18">
         reference counting
        </i>
        .
       </p>
       <p class="calibre13" id="c07-para-0204">
        As a general concept,
        <i class="calibre18">
         reference counting
        </i>
        is a technique for keeping track of the number of instances of a class or particular object in use. A reference-counting smart pointer is one that keeps track of how many smart pointers have been constructed to refer to a single real pointer, or single object. Every time such a reference-counted smart pointer is copied, a new instance is created pointing to the same resource, and the reference count is incremented. When such a smart pointer instance goes out of scope or is reset, the reference count is decremented. When the reference count drops to zero, there are no other owners of the resource anymore, so the smart pointer frees the resource.
       </p>
       <p class="calibre13">
        <span aria-label="251" class="calibre20" epub:type="pagebreak" id="Page_251" role="doc-pagebreak">
        </span>
        Reference-counted smart pointers solve a lot of memory management issues, such as double deletion. For example, suppose you have the following two raw pointers pointing to the same memory. The
        <code class="calibre21">
         Simple
        </code>
        class is introduced earlier in this chapter and simply prints out messages when an instance is created and destroyed.
       </p>
       <pre class="calibre26" id="c07-code-0073"><code class="calibre21">Simple* mySimple1 { new Simple{} };</code>
<code class="calibre21"><span class="color">Simple* mySimple2 { mySimple1 };  // Make a copy of the pointer.</span></code></pre>
       <p class="calibre13">
        Deleting both raw pointers will result in a double deletion:
       </p>
       <pre class="calibre26" id="c07-code-0074"><code class="calibre21">delete mySimple2;</code>
<code class="calibre21">delete mySimple1;</code></pre>
       <p class="calibre13" id="c07-para-0207">
        Of course, you'll (ideally) never find code like this, but it can happen when there are several layers of function calls involved, where one function deletes the memory, while another function has already done so.
       </p>
       <p class="calibre13">
        By using the
        <code class="calibre21">
         shared_ptr
        </code>
        reference-counted smart pointer, such double deletions are avoided:
       </p>
       <pre class="calibre26" id="c07-code-0075"><code class="calibre21">auto smartPtr1 { make_shared&lt;Simple&gt;() };</code>
<code class="calibre21"><span class="color">auto smartPtr2 { smartPtr1 };  // Make a copy of the pointer.</span></code></pre>
       <p class="calibre13" id="c07-para-0209">
        In this case, when both smart pointers go out of scope or are reset, only then is the
        <code class="calibre21">
         Simple
        </code>
        instance freed, exactly once.
       </p>
       <p class="calibre13">
        All this works correctly only when there are no raw pointers involved! For example, suppose you allocate some memory using
        <code class="calibre21">
         new
        </code>
        and then create two
        <code class="calibre21">
         shared_ptr
        </code>
        instances referring to the same raw pointer:
       </p>
       <pre class="calibre26" id="c07-code-0076"><code class="calibre21">Simple* mySimple { new Simple{} };</code>
<code class="calibre21">shared_ptr&lt;Simple&gt; smartPtr1 { mySimple };</code>
<code class="calibre21">shared_ptr&lt;Simple&gt; smartPtr2 { mySimple };</code></pre>
       <p class="calibre13">
        Both these smart pointers will attempt to delete the same object when they are destroyed. Depending on your compiler, this piece of code might crash! If you do get output, it could be as follows:
       </p>
       <pre class="calibre26" id="c07-code-0077"><code class="calibre21">Simple constructor called!</code>
<code class="calibre21">Simple destructor called!</code>
<code class="calibre21">Simple destructor called!</code></pre>
       <p class="calibre13" id="c07-para-0212">
        Yikes! One call to the constructor and two calls to the destructor? You get the same problem with
        <code class="calibre21">
         unique_ptr
        </code>
        . You might be surprised that even the reference-counted
        <code class="calibre21">
         shared_ptr
        </code>
        class behaves this way. However, this is correct behavior. The only safe way to have multiple
        <code class="calibre21">
         shared_ptr
        </code>
        instances point to the same memory is to simply
        <i class="calibre18">
         copy
        </i>
        such
        <code class="calibre21">
         shared_ptr
        </code>
        s.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0064">
       </span>
       <h4 class="calibre29" id="head-4-142">
        Casting a shared_ptr
       </h4>
       <p class="calibre13" id="c07-para-0213">
        Just as a raw pointer of a certain type can be cast to a pointer of a different type, a
        <code class="calibre21">
         shared_ptr
        </code>
        storing a certain type can be cast to a
        <code class="calibre21">
         shared_ptr
        </code>
        of another type. Of course, there are restrictions of what type can be cast to what type. Not all casts are valid. The functions that are available to cast
        <code class="calibre21">
         shared_ptr
        </code>
        s are
        <code class="calibre21">
         const_pointer_cast()
        </code>
        ,
        <code class="calibre21">
         dynamic_pointer_cast()
        </code>
        ,
        <code class="calibre21">
         static_pointer_cast()
        </code>
        , and
        <code class="calibre21">
         reinterpret_pointer_cast()
        </code>
        . These behave and work similar to the non-smart pointer casting functions
        <code class="calibre21">
         const_cast()
        </code>
        ,
        <code class="calibre21">
         dynamic_cast()
        </code>
        ,
        <code class="calibre21">
         static_cast()
        </code>
        , and
        <code class="calibre21">
         reinterpret_cast()
        </code>
        , which are discussed in detail with examples in
        <a class="calibre5" href="c10_split_000.xhtml">
         Chapter 10
        </a>
        .
       </p>
       <p class="calibre13" id="c07-para-0214">
        Note that these casts work only with
        <code class="calibre21">
         shared_ptr
        </code>
        and not with
        <code class="calibre21">
         unique_ptr
        </code>
        .
       </p>
      </section>
      <span aria-label="252" class="calibre20" epub:type="pagebreak" id="Page_252" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c07-sec-0065">
       </span>
       <h4 class="calibre29" id="head-4-143">
        Aliasing
       </h4>
       <p class="calibre13">
        A
        <code class="calibre21">
         shared_ptr
        </code>
        supports
        <i class="calibre18">
         aliasing
        </i>
        . This allows a
        <code class="calibre21">
         shared_ptr
        </code>
        to share ownership over a pointer (
        <i class="calibre18">
         owned pointer
        </i>
        ) with another
        <code class="calibre21">
         shared_ptr
        </code>
        , but pointing to a different object (
        <i class="calibre18">
         stored pointer
        </i>
        ). It can, for example, be used to have a
        <code class="calibre21">
         shared_ptr
        </code>
        pointing to a member of an object while owning the object itself. Here's an example:
       </p>
       <pre class="calibre26" id="c07-code-0078"><code class="calibre21">class Foo</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Foo(int value) : m_data { value } { }</code>
<code class="calibre21">        int m_data;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">auto foo { make_shared&lt;Foo&gt;(42) };</code>
<code class="calibre21"><b class="calibre14">auto aliasing { shared_ptr&lt;int&gt; { foo, &amp;foo-&gt;m_data } };</b></code></pre>
       <p class="calibre13" id="c07-para-0216">
        The
        <code class="calibre21">
         Foo
        </code>
        object is only destroyed when both
        <code class="calibre21">
         shared_ptr
        </code>
        s (
        <code class="calibre21">
         foo
        </code>
        and
        <code class="calibre21">
         aliasing
        </code>
        ) are destroyed.
       </p>
       <p class="calibre13">
        The owned pointer is used for reference counting, while the stored pointer is returned when you dereference the pointer or when you call
        <code class="calibre21">
         get()
        </code>
        on it.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c07-para-0218">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            In modern C++ code, raw pointers are allowed only if there is no ownership involved! If there is ownership involved, use
           </i>
           <code class="calibre21">
            unique_ptr
           </code>
           <i class="calibre18">
            by default, and
           </i>
           <code class="calibre21">
            shared_ptr
           </code>
           <i class="calibre18">
            if ownership needs to be shared. Additionally, use
           </i>
           <code class="calibre21">
            make_unique()
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            make_shared()
           </code>
           <i class="calibre18">
            to create these smart pointers. By doing so, there should be almost no need to directly call the
           </i>
           <code class="calibre21">
            new
           </code>
           <i class="calibre18">
            operator, and there should never be a need to call
           </i>
           <code class="calibre21">
            delete
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0067">
      </span>
      <h3 class="calibre27" id="head-3-170">
       weak_ptr
      </h3>
      <p class="calibre13">
       There is one more smart pointer class in C++ that is related to
       <code class="calibre21">
        shared_ptr
       </code>
       , called
       <code class="calibre21">
        weak_ptr
       </code>
       . A
       <code class="calibre21">
        weak_ptr
       </code>
       can contain a reference to a resource managed by a
       <code class="calibre21">
        shared_ptr
       </code>
       . The
       <code class="calibre21">
        weak_ptr
       </code>
       does not own the resource, so the
       <code class="calibre21">
        shared_ptr
       </code>
       is not prevented from deallocating the resource. A
       <code class="calibre21">
        weak_ptr
       </code>
       does not destroy the pointed-to resource when the
       <code class="calibre21">
        weak_ptr
       </code>
       is destroyed (for example when it goes out of scope); however, it can be used to determine whether the resource has been freed by the associated
       <code class="calibre21">
        shared_ptr
       </code>
       or not. The constructor of a
       <code class="calibre21">
        weak_ptr
       </code>
       requires a
       <code class="calibre21">
        shared_ptr
       </code>
       or another
       <code class="calibre21">
        weak_ptr
       </code>
       as argument. To get access to the pointer stored in a
       <code class="calibre21">
        weak_ptr
       </code>
       , you need to convert it to a
       <code class="calibre21">
        shared_ptr
       </code>
       . There are two ways to do this:
      </p>
      <ul class="check" id="c07-list-0004">
       <li class="calibre9" id="c07-li-0011">
        Use the
        <code class="calibre21">
         lock()
        </code>
        member function on a
        <code class="calibre21">
         weak_ptr
        </code>
        instance, which returns a
        <code class="calibre21">
         shared_ptr
        </code>
        . The returned
        <code class="calibre21">
         shared_ptr
        </code>
        is
        <code class="calibre21">
         nullptr
        </code>
        if the
        <code class="calibre21">
         shared_ptr
        </code>
        associated with the
        <code class="calibre21">
         weak_ptr
        </code>
        has been deallocated in the meantime.
       </li>
       <li class="calibre9" id="c07-li-0012">
        Create a new
        <code class="calibre21">
         shared_ptr
        </code>
        instance and give a
        <code class="calibre21">
         weak_ptr
        </code>
        as argument to the
        <code class="calibre21">
         shared_ptr
        </code>
        constructor. This throws an
        <code class="calibre21">
         std::bad_weak_ptr
        </code>
        exception if the
        <code class="calibre21">
         shared_ptr
        </code>
        associated with the
        <code class="calibre21">
         weak_ptr
        </code>
        has been deallocated.
       </li>
      </ul>
      <p class="calibre13">
       <span aria-label="253" class="calibre20" epub:type="pagebreak" id="Page_253" role="doc-pagebreak">
       </span>
       The following example demonstrates the use of
       <code class="calibre21">
        weak_ptr
       </code>
       :
      </p>
      <pre class="calibre26" id="c07-code-0079"><code class="calibre21">void useResource(weak_ptr&lt;Simple&gt;&amp; weakSimple)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto resource { weakSimple.lock() };</code>
<code class="calibre21">    if (resource) { println("Resource still alive."); }</code>
<code class="calibre21">    else          { println("Resource has been freed!"); }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto sharedSimple { make_shared&lt;Simple&gt;() };</code>
<code class="calibre21">    weak_ptr&lt;Simple&gt; weakSimple { sharedSimple };</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Try to use the weak_ptr.</span></code>
<code class="calibre21">    useResource(weakSimple);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Reset the shared_ptr.</span></code>
<code class="calibre21">    <span class="color">// Since there is only 1 shared_ptr to the Simple resource, this will</span></code>
<code class="calibre21">    <span class="color">// free the resource, even though there is still a weak_ptr alive.</span></code>
<code class="calibre21">    sharedSimple.reset();</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Try to use the weak_ptr a second time.</span></code>
<code class="calibre21">    useResource(weakSimple);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output of this code is as follows:
      </p>
      <pre class="calibre26" id="c07-code-0080"><code class="calibre21">Simple constructor called!</code>
<code class="calibre21">Resource still alive.</code>
<code class="calibre21">Simple destructor called!</code>
<code class="calibre21">Resource has been freed!</code></pre>
      <p class="calibre13" id="c07-para-0222">
       <code class="calibre21">
        weak_ptr
       </code>
       also supports C-style arrays, just as
       <code class="calibre21">
        shared_ptr
       </code>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0068">
      </span>
      <h3 class="calibre27" id="head-3-171">
       Passing to Functions
      </h3>
      <p class="calibre13" id="c07-para-0223">
       A function accepting a pointer as one of its parameters should accept a smart pointer only if there is ownership transfer or ownership sharing involved. To share ownership of a
       <code class="calibre21">
        shared_ptr
       </code>
       , simply accept a
       <code class="calibre21">
        shared_ptr
       </code>
       by value as parameter. Similarly, to transfer ownership of a
       <code class="calibre21">
        unique_ptr
       </code>
       , simply accept a
       <code class="calibre21">
        unique_ptr
       </code>
       by value as parameter. The latter requires using move semantics, discussed in detail in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       .
      </p>
      <p class="calibre13" id="c07-para-0224">
       If neither ownership transfer nor ownership sharing is involved, then the function should simply have a reference-to-non-
       <code class="calibre21">
        const
       </code>
       or reference-to-
       <code class="calibre21">
        const
       </code>
       parameter referring to the underlying resource, or a raw pointer to it if
       <code class="calibre21">
        nullptr
       </code>
       is a valid value for the parameter. Having a parameter type such as
       <code class="calibre21">
        const shared_ptr&lt;T&gt;&amp;
       </code>
       or
       <code class="calibre21">
        const unique_ptr&lt;T&gt;&amp;
       </code>
       never makes much sense.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0069">
      </span>
      <h3 class="calibre27" id="head-3-172">
       Returning from Functions
      </h3>
      <p class="calibre13">
       The standard smart pointers,
       <code class="calibre21">
        shared_ptr
       </code>
       ,
       <code class="calibre21">
        unique_ptr
       </code>
       , and
       <code class="calibre21">
        weak_ptr
       </code>
       , can easily and efficiently be returned from functions by value, thanks to mandatory and non-mandatory copy elision, discussed in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       , and move semantics, discussed in
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       . Details of move semantics are not important
       <span aria-label="254" class="calibre20" epub:type="pagebreak" id="Page_254" role="doc-pagebreak">
       </span>
       at this time. What is important is that all this means it is efficient to return a smart pointer from a function. For example, you can write the following
       <code class="calibre21">
        create()
       </code>
       function and use it as demonstrated in
       <code class="calibre21">
        main()
       </code>
       :
      </p>
      <pre class="calibre26" id="c07-code-0081"><code class="calibre21">unique_ptr&lt;Simple&gt; create()</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto ptr { make_unique&lt;Simple&gt;() };</code>
<code class="calibre21">    <span class="color">// Do something with ptr…</span></code>
<code class="calibre21">    return ptr;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    unique_ptr&lt;Simple&gt; mySmartPtr1 { create() };</code>
<code class="calibre21">    auto mySmartPtr2 { create() };</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0070">
      </span>
      <h3 class="calibre27" id="head-3-173">
       enable_shared_from_this
      </h3>
      <p class="calibre13">
       Deriving a class from
       <code class="calibre21">
        std::enable_shared_from_this
       </code>
       allows a member function called on an object to safely return a
       <code class="calibre21">
        shared_ptr
       </code>
       or
       <code class="calibre21">
        weak_ptr
       </code>
       to itself. Without this base class, one way to return a valid
       <code class="calibre21">
        shared_ptr
       </code>
       or
       <code class="calibre21">
        weak_ptr
       </code>
       to
       <code class="calibre21">
        this
       </code>
       is by adding a
       <code class="calibre21">
        weak_ptr
       </code>
       as a member to the class, and to return copies of it or return
       <code class="calibre21">
        shared_ptr
       </code>
       s constructed from it. The
       <code class="calibre21">
        enable_shared_from_this
       </code>
       class adds the following two member functions to a class deriving from it:
      </p>
      <ul class="check" id="c07-list-0005">
       <li class="calibre9" id="c07-li-0013">
        <b class="calibre14">
         <code class="calibre21">
          shared_from_this()
         </code>
         :
        </b>
        Returns a
        <code class="calibre21">
         shared_ptr
        </code>
        that shares ownership of the object
       </li>
       <li class="calibre9" id="c07-li-0014">
        <b class="calibre14">
         <code class="calibre21">
          weak_from_this()
         </code>
         :
        </b>
        Returns a
        <code class="calibre21">
         weak_ptr
        </code>
        that tracks ownership of the object
       </li>
      </ul>
      <p class="calibre13">
       This is an advanced feature not discussed in detail, but the following code briefly demonstrates its use. Both
       <code class="calibre21">
        shared_from_this()
       </code>
       and
       <code class="calibre21">
        weak_from_this()
       </code>
       are
       <code class="calibre21">
        public
       </code>
       member functions. However, maybe you find the
       <code class="calibre21">
        from_this
       </code>
       part confusing in your
       <code class="calibre21">
        public
       </code>
       interface, so just as a demonstration, the following
       <code class="calibre21">
        Foo
       </code>
       class defines its own member function called
       <code class="calibre21">
        getPointer()
       </code>
       :
      </p>
      <pre class="calibre26" id="c07-code-0082"><code class="calibre21">class Foo : public enable_shared_from_this&lt;Foo&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        shared_ptr&lt;Foo&gt; getPointer() {</code>
<code class="calibre21">            return shared_from_this();</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto ptr1 { make_shared&lt;Foo&gt;() };</code>
<code class="calibre21">    auto ptr2 { ptr1-&gt;getPointer() };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c07-para-0228">
       Note that you can use
       <code class="calibre21">
        shared_from_this()
       </code>
       on an object only if its pointer has already been stored in a
       <code class="calibre21">
        shared_ptr
       </code>
       ; otherwise, a
       <code class="calibre21">
        bad_weak_ptr
       </code>
       exception is thrown. In the example,
       <code class="calibre21">
        make_shared()
       </code>
       is used in
       <code class="calibre21">
        main()
       </code>
       to create a
       <code class="calibre21">
        shared_ptr
       </code>
       called
       <code class="calibre21">
        ptr1
       </code>
       , which contains an instance of
       <code class="calibre21">
        Foo
       </code>
       . After this
       <code class="calibre21">
        shared_ptr
       </code>
       creation, it is allowed to call
       <code class="calibre21">
        shared_from_this()
       </code>
       on that
       <code class="calibre21">
        Foo
       </code>
       instance. On the other
       <span aria-label="255" class="calibre20" epub:type="pagebreak" id="Page_255" role="doc-pagebreak">
       </span>
       hand, it is always allowed to call
       <code class="calibre21">
        weak_from_this()
       </code>
       , but it might return an empty
       <code class="calibre21">
        weak_ptr
       </code>
       if it is called on an object for which its pointer has not been stored in a
       <code class="calibre21">
        shared_ptr
       </code>
       yet.
      </p>
      <p class="calibre13">
       The following would be a completely wrong implementation of the
       <code class="calibre21">
        getPointer()
       </code>
       member function:
      </p>
      <pre class="calibre26" id="c07-code-0083"><code class="calibre21"><b class="calibre14">class Foo</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        shared_ptr&lt;Foo&gt; getPointer() {</code>
<code class="calibre21">            <b class="calibre14">return shared_ptr&lt;Foo&gt;(this);</b></code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c07-para-0230">
       If you use the same code for
       <code class="calibre21">
        main()
       </code>
       as shown earlier, this implementation of
       <code class="calibre21">
        Foo
       </code>
       causes a double deletion. You have two completely independent
       <code class="calibre21">
        shared_ptr
       </code>
       s (
       <code class="calibre21">
        ptr1
       </code>
       and
       <code class="calibre21">
        ptr2
       </code>
       ) pointing to the same object, which will both try to delete the object when they go out of scope.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0071">
      </span>
      <h3 class="calibre27" id="head-3-174">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Interoperability of Smart Pointers with C-Style Functions
      </h3>
      <p class="calibre13">
       Often, C-style functions use the return type to indicate whether a function executed correctly or whether there was any error. Since the return type is already used for reporting errors, additional output parameters are used to return other data from the function. For example:
      </p>
      <pre class="calibre26" id="c07-code-0084"><code class="calibre21">using errorcode = int;</code>
<code class="calibre21">errorcode my_alloc(int value, int** data) { *data = new int { value }; return 0; }</code>
<code class="calibre21">errorcode my_free(int* data) { delete data; return 0; }</code></pre>
      <p class="calibre13">
       With this C-style API, the
       <code class="calibre21">
        my_alloc()
       </code>
       function returns an
       <code class="calibre21">
        errorcode
       </code>
       and returns the allocated data in the output parameter called
       <code class="calibre21">
        data
       </code>
       . Before C++23, you could not directly use a smart pointer, such as
       <code class="calibre21">
        unique_ptr
       </code>
       , with
       <code class="calibre21">
        my_alloc()
       </code>
       . Instead, you could do something like this:
      </p>
      <pre class="calibre26" id="c07-code-0085"><code class="calibre21">unique_ptr&lt;int, decltype(&amp;my_free)&gt; myIntSmartPtr(nullptr, my_free);</code>
<code class="calibre21">int* data { nullptr };</code>
<code class="calibre21">my_alloc(42, &amp;data);</code>
<code class="calibre21">myIntSmartPtr.reset(data);</code></pre>
      <p class="calibre13">
       That's rather involved for something relatively easy. C++23 introduces the
       <code class="calibre21">
        std::out_ptr()
       </code>
       and
       <code class="calibre21">
        inout_ptr()
       </code>
       functions to help with this, both defined in
       <code class="calibre21">
        &lt;memory&gt;
       </code>
       . Using these, the code snippet can be written more elegantly as follows:
      </p>
      <pre class="calibre26" id="c07-code-0086"><code class="calibre21">unique_ptr&lt;int, decltype(&amp;my_free)&gt; myIntSmartPtr(nullptr, my_free);</code>
<code class="calibre21"><b class="calibre14">my_alloc(42, inout_ptr(myIntSmartPtr));</b></code></pre>
      <p class="calibre13" id="c07-para-0235">
       If you're sure that the pointer passed to
       <code class="calibre21">
        inout_ptr()
       </code>
       is
       <code class="calibre21">
        nullptr
       </code>
       , then you can use
       <code class="calibre21">
        out_ptr
       </code>
       instead.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c07-sec-0072">
      </span>
      <h3 class="calibre27" id="head-3-175">
       The Old and Removed auto_ptr
      </h3>
      <p class="calibre13">
       The old, pre-C++11 Standard Library included a basic implementation of a smart pointer, called
       <code class="calibre21">
        auto_ptr
       </code>
       . Unfortunately,
       <code class="calibre21">
        auto_ptr
       </code>
       has some serious shortcomings. One of these shortcomings is that it does not work correctly when used inside Standard Library containers such as
       <code class="calibre21">
        vector
       </code>
       s. C++11 officially deprecated
       <code class="calibre21">
        auto_ptr
       </code>
       , and since C++17, it has been removed entirely from the Standard Library. It is replaced with
       <code class="calibre21">
        unique_ptr
       </code>
       and
       <code class="calibre21">
        shared_ptr
       </code>
       .
       <code class="calibre21">
        auto_ptr
       </code>
       is mentioned here to make sure you know about it and to make sure you never use it.
       <span aria-label="256" class="calibre20" epub:type="pagebreak" id="Page_256" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c07-para-0237">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Never use the old
          </i>
          <code class="calibre21">
           auto_ptr
          </code>
          <i class="calibre18">
           smart pointer! Instead, use
          </i>
          <code class="calibre21">
           unique_ptr
          </code>
          <i class="calibre18">
           by default or
          </i>
          <code class="calibre21">
           shared_ptr
          </code>
          <i class="calibre18">
           if you need shared ownership.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-99" class="calibre2">
     <span class="calibre" id="c07-sec-0074">
     </span>
     <h2 class="calibre6" id="head-2-99">
      SUMMARY
     </h2>
     <p class="calibre13" id="c07-para-0238">
      In this chapter, you learned the ins and outs of dynamic memory. Aside from memory-checking tools and careful coding, there are two key takeaways to avoid dynamic memory-related problems.
     </p>
     <p class="calibre13" id="c07-para-0239">
      First, you need to understand how pointers work under the hood. After reading about two different mental models for pointers, you should now know how the compiler doles out memory.
     </p>
     <p class="calibre13" id="c07-para-0240">
      Second, you should avoid raw pointers when ownership is involved, and avoid using old C-style constructs and functions. Instead, use safe C++ alternatives, such as objects that automatically manage their memory, like the C++
      <code class="calibre21">
       string
      </code>
      class, the
      <code class="calibre21">
       vector
      </code>
      container, smart pointers, and so on.
     </p>
    </section>
    <section aria-labelledby="head-2-100" class="calibre2">
     <span class="calibre" id="c07-sec-0075">
     </span>
     <h2 class="calibre6" id="head-2-100">
      EXERCISES
     </h2>
     <p class="calibre13" id="c07-para-0241">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c07-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c07-ex-0001">
        <b class="calibre14">
         Exercise 7-1:
        </b>
        Analyze the following code snippet. Can you list any problems you find with it? You don't need to fix the problems in this exercise; that will be for Exercise 7-2.
        <pre class="calibre26" id="c07-code-0087"><code class="calibre21">const size_t numberOfElements { 10 };</code>
<code class="calibre21">int* values { new int[numberOfElements] };</code>
<code class="calibre21"><span class="color">// Set values to their index value.</span></code>
<code class="calibre21">for (int index { 0 }; index &lt; numberOfElements; ++index) {</code>
<code class="calibre21">    values[index] = index;</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Set last value to 99.</span></code>
<code class="calibre21">values[10] = 99;</code>
<code class="calibre21"><span class="color">// Print all values.</span></code>
<code class="calibre21">for (int index { 0 }; index &lt;= numberOfElements; ++index) {</code>
<code class="calibre21">    print("{} ", values[index]);</code>
<code class="calibre21">}</code></pre>
       </li>
       <li class="calibre9" id="c07-ex-0002">
        <b class="calibre14">
         Exercise 7-2:
        </b>
        Rewrite the code snippet from Exercise 7-1 to use modern and safe C++ constructs.
       </li>
       <li class="calibre9" id="c07-ex-0003">
        <b class="calibre14">
         Exercise 7-3:
        </b>
        Write a basic class to store a 3-D point with x, y, and z coordinates. Include a constructor accepting x, y, and z arguments. Write a function that accepts a 3-D point and prints out its coordinates using
        <code class="calibre21">
         std::print()
        </code>
        . In your
        <code class="calibre21">
         main()
        </code>
        function, dynamically allocate an instance of your class and subsequently call your function.
       </li>
       <li class="calibre9" id="c07-ex-0004">
        <span aria-label="257" class="calibre20" epub:type="pagebreak" id="Page_257" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Exercise 7-4:
        </b>
        Earlier in this chapter, the following function is shown in the context of out-of-bounds memory access. Can you modernize this function using safe C++ alternatives? Test your solution in your
        <code class="calibre21">
         main()
        </code>
        function.
        <pre class="calibre26" id="c07-code-0088"><code class="calibre21">void fillWithM(char* text)</code>
<code class="calibre21">{</code>
<code class="calibre21">    int i { 0 };</code>
<code class="calibre21">    while (text[i] != '\0') {</code>
<code class="calibre21">        text[i] = 'm';</code>
<code class="calibre21">        ++i;</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c07_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c07_2">
     NOTES
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c07-note-0001" id="c07-note-0001" role="doc-backlink">
       1
      </a>
      Guideline ES.20 of the C++ Core Guidelines, see
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , states “Always initialize an object.”
     </li>
     <li class="noteentry">
      <a class="calibre5" href="#R_c07-note-0002" id="c07-note-0002" role="doc-backlink">
       2
      </a>
      The addresses in
      <a class="calibre5" href="#c07-fig-0012">
       Figure 7.12
      </a>
      are just for illustrative purpose. Addresses on a real system are highly dependent on the hardware and operating system.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
