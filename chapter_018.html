<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   22Date and Time Utilities
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_017.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_019.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c22_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c22_1">
      <span aria-label="861" class="calibre17" epub:type="pagebreak" id="Page_861" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c22">
      </span>
      <span class="calibre">
       22
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Date and Time Utilities
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c22-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c22-list-0001">
         <li class="calibre9" id="c22-li-0001">
          How to work with compile-time rational numbers
         </li>
         <li class="calibre9" id="c22-li-0002">
          How to work with time
         </li>
         <li class="calibre9" id="c22-li-0003">
          How to work with dates and calendars
         </li>
         <li class="calibre9" id="c22-li-0004">
          How to convert time points between different time zones
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c22-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-226">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c22-sec-0003">
        </span>
        <p class="calibre25" id="c22-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13">
      This chapter discusses the time-related functionality provided by the C++ Standard Library, known collectively as the
      <i class="calibre18">
       chrono library
      </i>
      . It is a collection of classes and functions to work with time and dates. The library consists of the following components:
     </p>
     <ul class="check" id="c22-list-0002">
      <li class="calibre9" id="c22-li-0005">
       Durations
      </li>
      <li class="calibre9" id="c22-li-0006">
       Clocks
      </li>
      <li class="calibre9" id="c22-li-0007">
       Time points
      </li>
      <li class="calibre9" id="c22-li-0008">
       Dates
      </li>
      <li class="calibre9" id="c22-li-0009">
       Time zones
      </li>
     </ul>
     <p class="calibre13" id="c22-para-0006">
      Everything is defined in
      <code class="calibre21">
       &lt;chrono&gt;
      </code>
      in the
      <code class="calibre21">
       std::chrono
      </code>
      namespace. However, before we can start the discussion of each of these chrono library components, we need a small digression to look at the compile-time rational number support available in C++, as this is heavily used by the chrono library.
     </p>
    </section>
    <span aria-label="862" class="calibre20" epub:type="pagebreak" id="Page_862" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-227" class="calibre2">
     <span class="calibre" id="c22-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-227">
      COMPILE-TIME RATIONAL NUMBERS
     </h2>
     <p class="calibre13">
      The Ratio library allows you to exactly represent any finite rational number that you can use at compile time. Everything is defined in
      <code class="calibre21">
       &lt;ratio&gt;
      </code>
      and is in the
      <code class="calibre21">
       std
      </code>
      namespace. The numerator and denominator of a rational number are represented as compile-time constants of type
      <code class="calibre21">
       std::intmax_t
      </code>
      , which is a signed integer type with the maximum width supported by a compiler. Because of the compile-time nature of these rational numbers, using them might look a bit different than what you are used to. You cannot define a
      <code class="calibre21">
       ratio
      </code>
      object the same way as you define normal objects, and you cannot call member functions on it. Instead,
      <code class="calibre21">
       ratio
      </code>
      is a class template, and a specific instantiation of the
      <code class="calibre21">
       ratio
      </code>
      class template represents one specific rational number. To name such specific instantiations, you can use type aliases. For example, the following defines a compile-time rational number representing the fraction 1/60:
     </p>
     <pre class="calibre26" id="c22-code-0001"><code class="calibre21">using r1 = ratio&lt;1, 60&gt;;</code></pre>
     <p class="calibre13">
      The numerator (
      <code class="calibre21">
       num
      </code>
      ) and denominator (
      <code class="calibre21">
       den
      </code>
      ) of the
      <code class="calibre21">
       r1
      </code>
      rational number are compile-time constants and can be accessed as follows:
     </p>
     <pre class="calibre26" id="c22-code-0002"><code class="calibre21">intmax_t num { r1::num };</code>
<code class="calibre21">intmax_t den { r1::den };</code></pre>
     <p class="calibre13">
      Remember that a
      <code class="calibre21">
       ratio
      </code>
      represents a
      <i class="calibre18">
       compile-time rational number
      </i>
      , which means that the numerator and denominator need to be known at compile time. The following generates a compilation error:
     </p>
     <pre class="calibre26" id="c22-code-0003"><code class="calibre21">intmax_t n { 1 };          <span class="color">// Numerator</span></code>
<code class="calibre21">intmax_t d { 60 };         <span class="color">// Denominator</span></code>
<code class="calibre21">using r1 = ratio&lt;n, d&gt;;    <span class="color">// Error</span></code></pre>
     <p class="calibre13">
      Making
      <code class="calibre21">
       n
      </code>
      and
      <code class="calibre21">
       d
      </code>
      constants works fine:
     </p>
     <pre class="calibre26" id="c22-code-0004"><code class="calibre21">const intmax_t n { 1 };    <span class="color">// Numerator</span></code>
<code class="calibre21">const intmax_t d { 60 };   <span class="color">// Denominator</span></code>
<code class="calibre21">using r1 = ratio&lt;n, d&gt;;    <span class="color">// Ok</span></code></pre>
     <p class="calibre13">
      Rational numbers are always normalized. For a rational number
      <code class="calibre21">
       ratio&lt;n, d&gt;
      </code>
      , the greatest common divisor,
      <code class="calibre21">
       gcd
      </code>
      , is calculated, and the numerator,
      <code class="calibre21">
       num
      </code>
      , and denominator,
      <code class="calibre21">
       den
      </code>
      , are then defined as follows:
     </p>
     <ul class="check" id="c22-list-0003">
      <li class="calibre9" id="c22-li-0010">
       <code class="calibre21">
        num = sign(n)*sign(d)*abs(n)/gcd
       </code>
      </li>
      <li class="calibre9" id="c22-li-0011">
       <code class="calibre21">
        den = abs(d)/gcd
       </code>
      </li>
     </ul>
     <p class="calibre13">
      The library supports adding, subtracting, multiplying, and dividing rational numbers. However, you cannot use the standard arithmetic operators because all these operations are again not happening on objects but on types, i.e., instantiations of the
      <code class="calibre21">
       ratio
      </code>
      class template, at compile time. Instead, you need to use specific arithmetic
      <code class="calibre21">
       ratio
      </code>
      class templates. The following arithmetic class templates are available:
      <code class="calibre21">
       ratio_add
      </code>
      ,
      <code class="calibre21">
       ratio_subtract
      </code>
      ,
      <code class="calibre21">
       ratio_multiply
      </code>
      , and
      <code class="calibre21">
       ratio_divide
      </code>
      , which perform addition, subtraction, multiplication, and division, respectively. These templates calculate the result as a new
      <code class="calibre21">
       ratio
      </code>
      type. This type can be accessed with the embedded type alias called
      <code class="calibre21">
       type
      </code>
      . For example, the following code first defines two
      <code class="calibre21">
       ratio
      </code>
      s, one representing 1/60 and the other representing 1/30. The
      <code class="calibre21">
       ratio_add
      </code>
      template adds those two rational numbers together to produce the
      <code class="calibre21">
       result
      </code>
      rational number, which, after normalization, is 1/20:
     </p>
     <pre class="calibre26" id="c22-code-0005"><code class="calibre21">using r1 = ratio&lt;1, 60&gt;;</code>
<span aria-label="863" class="calibre20" epub:type="pagebreak" id="Page_863" role="doc-pagebreak"></span><code class="calibre21">using r2 = ratio&lt;1, 30&gt;;</code>
<code class="calibre21">using result = ratio_add&lt;r1, r2&gt;::type;</code></pre>
     <p class="calibre13">
      The standard also defines a number of
      <code class="calibre21">
       ratio
      </code>
      comparison class templates:
      <code class="calibre21">
       ratio_equal
      </code>
      ,
      <code class="calibre21">
       ratio_not_equal
      </code>
      ,
      <code class="calibre21">
       ratio_less
      </code>
      ,
      <code class="calibre21">
       ratio_less_equal
      </code>
      ,
      <code class="calibre21">
       ratio_greater
      </code>
      , and
      <code class="calibre21">
       ratio_greater_equal
      </code>
      . Just like the arithmetic
      <code class="calibre21">
       ratio
      </code>
      class templates, the
      <code class="calibre21">
       ratio
      </code>
      comparison class templates are all evaluated at compile time, again not on objects but on
      <code class="calibre21">
       ratio
      </code>
      types. These comparison templates define a new type that is an
      <code class="calibre21">
       std::bool_constant
      </code>
      , representing the result.
      <code class="calibre21">
       bool_constant
      </code>
      is an
      <code class="calibre21">
       std::integral_constant
      </code>
      , a
      <code class="calibre21">
       struct
      </code>
      template that stores a type and a compile-time constant value. For example,
      <code class="calibre21">
       integral_constant&lt;int, 15&gt;
      </code>
      stores an integer with value 15.
      <code class="calibre21">
       bool_constant
      </code>
      is an
      <code class="calibre21">
       integral_constant
      </code>
      with type
      <code class="calibre21">
       bool
      </code>
      . For instance,
      <code class="calibre21">
       bool_constant&lt;true&gt;
      </code>
      is
      <code class="calibre21">
       integral_constant&lt;bool, true&gt;
      </code>
      , which stores a Boolean with value
      <code class="calibre21">
       true
      </code>
      . The result of the
      <code class="calibre21">
       ratio
      </code>
      comparison templates is either
      <code class="calibre21">
       bool_constant&lt;true&gt;
      </code>
      or
      <code class="calibre21">
       bool_constant&lt;false&gt;
      </code>
      . The value associated with a
      <code class="calibre21">
       bool_constant
      </code>
      or an
      <code class="calibre21">
       integral_constant
      </code>
      can be accessed using the
      <code class="calibre21">
       value
      </code>
      data member. The following example demonstrates the use of
      <code class="calibre21">
       ratio_less
      </code>
      :
     </p>
     <pre class="calibre26" id="c22-code-0006"><code class="calibre21">using r1 = ratio&lt;1, 60&gt;;</code>
<code class="calibre21">using r2 = ratio&lt;1, 30&gt;;</code>
<code class="calibre21">using res = ratio_less&lt;r2, r1&gt;;</code>
<code class="calibre21">println("{}", res::value); <span class="color">// false</span></code></pre>
     <p class="calibre13">
      The following code snippet combines everything just covered. Because
      <code class="calibre21">
       ratio
      </code>
      s are not objects but types, you cannot do something like
      <code class="calibre21">
       println("{}", r1)
      </code>
      ; you need to get the numerator and denominator and print them separately.
     </p>
     <pre class="calibre26" id="c22-code-0007"><code class="calibre21"><span class="color">// Define a compile-time rational number.</span></code>
<code class="calibre21">using r1 = ratio&lt;1, 60&gt;;</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Get numerator and denominator.</span></code>
<code class="calibre21">intmax_t num { r1::num };</code>
<code class="calibre21">intmax_t den { r1::den };</code>
<code class="calibre21">println("1) r1 = {}/{}", num, den);</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Add two rational numbers.</span></code>
<code class="calibre21">using r2 = ratio&lt;1, 30&gt;;</code>
<code class="calibre21">println("2) r2 = {}/{}", r2::num, r2::den);</code>
<code class="calibre21">using result = ratio_add&lt;r1, r2&gt;::type;</code>
<code class="calibre21">println("3) sum = {}/{}", result::num, result::den);</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Compare two rational numbers.</span></code>
<code class="calibre21">using res = ratio_less&lt;r2, r1&gt;;</code>
<code class="calibre21">println("4) r2 &lt; r1: {}", res::value);</code></pre>
     <p class="calibre13">
      The output is as follows:
     </p>
     <pre class="calibre26" id="c22-code-0008"><code class="calibre21">1) r1 = 1/60</code>
<code class="calibre21">2) r2 = 1/30</code>
<code class="calibre21">3) sum = 1/20</code>
<code class="calibre21">4) r2 &lt; r1: false</code></pre>
     <p class="calibre13">
      The library provides a number of SI (
      <i class="calibre18">
       Système International
      </i>
      ) type aliases for your convenience. They are as follows:
     </p>
     <pre class="calibre26" id="c22-code-0009"><code class="calibre21">using yocto = ratio&lt;1, 1'000'000'000'000'000'000'000'000&gt;; <span class="color">// *</span></code>
<code class="calibre21">using zepto = ratio&lt;1, 1'000'000'000'000'000'000'000&gt;;     <span class="color">// *</span></code>
<code class="calibre21">using atto  = ratio&lt;1, 1'000'000'000'000'000'000&gt;;</code>
<code class="calibre21">using femto = ratio&lt;1, 1'000'000'000'000'000&gt;;</code>
<span aria-label="864" class="calibre20" epub:type="pagebreak" id="Page_864" role="doc-pagebreak"></span><code class="calibre21">using pico  = ratio&lt;1, 1'000'000'000'000&gt;;</code>
<code class="calibre21">using nano  = ratio&lt;1, 1'000'000'000&gt;;</code>
<code class="calibre21">using micro = ratio&lt;1, 1'000'000&gt;;</code>
<code class="calibre21">using milli = ratio&lt;1, 1'000&gt;;</code>
<code class="calibre21">using centi = ratio&lt;1, 100&gt;;</code>
<code class="calibre21">using deci  = ratio&lt;1, 10&gt;;</code>
<code class="calibre21">using deca  = ratio&lt;10, 1&gt;;</code>
<code class="calibre21">using hecto = ratio&lt;100, 1&gt;;</code>
<code class="calibre21">using kilo  = ratio&lt;1'000, 1&gt;;</code>
<code class="calibre21">using mega  = ratio&lt;1'000'000, 1&gt;;</code>
<code class="calibre21">using giga  = ratio&lt;1'000'000'000, 1&gt;;</code>
<code class="calibre21">using tera  = ratio&lt;1'000'000'000'000, 1&gt;;</code>
<code class="calibre21">using peta  = ratio&lt;1'000'000'000'000'000, 1&gt;;</code>
<code class="calibre21">using exa   = ratio&lt;1'000'000'000'000'000'000, 1&gt;;</code>
<code class="calibre21">using zetta = ratio&lt;1'000'000'000'000'000'000'000, 1&gt;;     <span class="color">// *</span></code>
<code class="calibre21">using yotta = ratio&lt;1'000'000'000'000'000'000'000'000, 1&gt;; <span class="color">// *</span></code></pre>
     <p class="calibre13" id="c22-para-0017">
      The SI units with an asterisk at the end are defined only if your compiler can represent the constant numerator and denominator values for those type aliases as an
      <code class="calibre21">
       intmax_t
      </code>
      . An example of how to use these predefined SI units is given during the discussion of
      <code class="calibre21">
       duration
      </code>
      s in the next section.
     </p>
    </section>
    <section aria-labelledby="head-2-228" class="calibre2">
     <span class="calibre" id="c22-sec-0005">
     </span>
     <h2 class="calibre6" id="head-2-228">
      DURATION
     </h2>
     <p class="calibre13">
      A
      <i class="calibre18">
       duration
      </i>
      is an interval between two points in time. It is represented by the
      <code class="calibre21">
       duration
      </code>
      class template, which stores a number of
      <i class="calibre18">
       ticks
      </i>
      and a
      <i class="calibre18">
       tick period
      </i>
      . The tick period is the time in seconds between two ticks and is represented as a compile-time
      <code class="calibre21">
       ratio
      </code>
      constant, which means it could be a fraction of a second. Ratios are discussed in the previous section. The
      <code class="calibre21">
       duration
      </code>
      template accepts two template type parameters and is defined as follows:
     </p>
     <pre class="calibre26" id="c22-code-0010"><code class="calibre21">template &lt;class Rep, class Period = ratio&lt;1&gt;&gt; class duration {…}</code></pre>
     <p class="calibre13" id="c22-para-0019">
      The first template parameter,
      <code class="calibre21">
       Rep
      </code>
      , is the type of variable storing the number of ticks and should be an arithmetic type, for example
      <code class="calibre21">
       long
      </code>
      ,
      <code class="calibre21">
       double
      </code>
      , and so on. The second template parameter,
      <code class="calibre21">
       Period
      </code>
      , is the rational constant representing the period of a tick. If you don't specify the tick period, the default value
      <code class="calibre21">
       ratio&lt;1&gt;
      </code>
      is used, which represents a tick period of one second.
     </p>
     <p class="calibre13" id="c22-para-0020">
      Three constructors are provided: the default constructor; one that accepts a single value, the number of ticks; and one that accepts another
      <code class="calibre21">
       duration
      </code>
      . The latter constructor can be used to convert from one
      <code class="calibre21">
       duration
      </code>
      to another
      <code class="calibre21">
       duration
      </code>
      , for example, from minutes to seconds. An example is given later in this section.
     </p>
     <p class="calibre13" id="c22-para-0021">
      Durations support arithmetic operations such as
      <code class="calibre21">
       +
      </code>
      ,
      <code class="calibre21">
       -
      </code>
      ,
      <code class="calibre21">
       *
      </code>
      ,
      <code class="calibre21">
       /
      </code>
      ,
      <code class="calibre21">
       %
      </code>
      ,
      <code class="calibre21">
       ++
      </code>
      ,
      <code class="calibre21">
       --
      </code>
      ,
      <code class="calibre21">
       +=
      </code>
      ,
      <code class="calibre21">
       -=
      </code>
      ,
      <code class="calibre21">
       *=
      </code>
      ,
      <code class="calibre21">
       /=
      </code>
      , and
      <code class="calibre21">
       %=
      </code>
      , and they support the comparison operators
      <code class="calibre21">
       ==
      </code>
      and
      <code class="calibre21">
       &lt;=&gt;
      </code>
      . The class also contains the member functions shown in the following table:
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         MEMBER FUNCTION
        </th>
        <th class="left" scope="col">
         DESCRIPTION
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          Rep count() const
         </span>
        </td>
        <td class="bgcolor">
         Returns the
         <span class="calibre21">
          duration
         </span>
         value as the number of ticks. The return type is the type specified as the first template type parameter for the
         <code class="calibre21">
          duration
         </code>
         template.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          static duration zero()
         </span>
        </td>
        <td class="bgcolor">
         Returns a
         <span class="calibre21">
          duration
         </span>
         with a duration value equivalent to zero.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          static duration min()
         </span>
         <code class="calibre21">
          static duration max()
         </code>
        </td>
        <td class="bgcolor">
         Returns a
         <span class="calibre21">
          duration
         </span>
         with the minimum/maximum possible duration value representable by the type specified as the first template type parameter for the
         <code class="calibre21">
          duration
         </code>
         template.
         <span aria-label="865" class="calibre20" epub:type="pagebreak" id="Page_865" role="doc-pagebreak">
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13" id="c22-para-0024">
      The library supports
      <code class="calibre21">
       floor()
      </code>
      ,
      <code class="calibre21">
       ceil()
      </code>
      ,
      <code class="calibre21">
       round()
      </code>
      , and
      <code class="calibre21">
       abs()
      </code>
      operations on
      <code class="calibre21">
       duration
      </code>
      s that behave just as they behave with numerical data.
     </p>
     <p class="calibre13">
      Let's now see how
      <code class="calibre21">
       duration
      </code>
      s can be defined. A
      <code class="calibre21">
       duration
      </code>
      where each tick is one second can be defined as follows:
     </p>
     <pre class="calibre26" id="c22-code-0011"><code class="calibre21">duration&lt;long&gt; d1;</code></pre>
     <p class="calibre13">
      Because
      <code class="calibre21">
       ratio&lt;1&gt;
      </code>
      is the default tick period, this is the same as writing:
     </p>
     <pre class="calibre26" id="c22-code-0012"><code class="calibre21">duration&lt;long, ratio&lt;1&gt;&gt; d1;</code></pre>
     <p class="calibre13">
      The next statement defines a
      <code class="calibre21">
       duration
      </code>
      in minutes (tick period = 60 seconds):
     </p>
     <pre class="calibre26" id="c22-code-0013"><code class="calibre21">duration&lt;long, ratio&lt;60&gt;&gt; d2;</code></pre>
     <p class="calibre13">
      Here is a
      <code class="calibre21">
       duration
      </code>
      where each tick period is a sixtieth of a second:
     </p>
     <pre class="calibre26" id="c22-code-0014"><code class="calibre21">duration&lt;double, ratio&lt;1, 60&gt;&gt; d3;</code></pre>
     <p class="calibre13">
      As you saw earlier in this chapter,
      <code class="calibre21">
       &lt;ratio&gt;
      </code>
      defines a number of SI rational constants. These predefined constants come in handy for defining tick periods. For example, the next statement defines a
      <code class="calibre21">
       duration
      </code>
      where each tick period is one millisecond:
     </p>
     <pre class="calibre26" id="c22-code-0015"><code class="calibre21">duration&lt;long long, milli&gt; d4;</code></pre>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-461">
       Examples and Converting Durations
      </h3>
      <p class="calibre13">
       Let's see
       <code class="calibre21">
        duration
       </code>
       s in action. The following example demonstrates several aspects of
       <code class="calibre21">
        duration
       </code>
       s. It shows you how to define them, how to perform arithmetic operations on them, how to print them to the screen, and how to convert one
       <code class="calibre21">
        duration
       </code>
       to another
       <code class="calibre21">
        duration
       </code>
       with a different tick period:
      </p>
      <pre class="calibre26" id="c22-code-0016"><code class="calibre21"><span class="color">// Specify a duration where each tick is 60 seconds.</span></code>
<code class="calibre21">duration&lt;long, ratio&lt;60&gt;&gt; d1 { 123 };</code>
<code class="calibre21">println("{} ({})", d1, d1.count());</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Specify a duration represented by a double with each tick</span></code>
<code class="calibre21"><span class="color">// equal to 1 second and assign the largest possible duration to it.</span></code>
<code class="calibre21">auto d2 { duration&lt;double&gt;::max() };</code>
<code class="calibre21">println("{}", d2);</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Define 2 durations:</span></code>
<code class="calibre21"><span class="color">// For the first duration, each tick is 1 minute.</span></code>
<code class="calibre21"><span class="color">// For the second duration, each tick is 1 second.</span></code>
<code class="calibre21">duration&lt;long, ratio&lt;60&gt;&gt; d3 { 10 };  <span class="color">// = 10 minutes</span></code>
<code class="calibre21">duration&lt;long, ratio&lt;1&gt;&gt; d4 { 14 };   <span class="color">// = 14 seconds</span></code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Compare both durations.</span></code>
<code class="calibre21">if (d3 &gt; d4) { println("d3 &gt; d4"); }</code>
<code class="calibre21">else { println("d3 &lt;= d4"); }</code>
<code class="calibre21"></code>
<span aria-label="866" class="calibre20" epub:type="pagebreak" id="Page_866" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Increment d4 with 1 resulting in 15 seconds.</span></code>
<code class="calibre21">++d4;</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Multiply d4 by 2 resulting in 30 seconds.</span></code>
<code class="calibre21">d4 *= 2;</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Add both durations and store as minutes.</span></code>
<code class="calibre21">duration&lt;double, ratio&lt;60&gt;&gt; d5 { d3 + d4 };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Add both durations and store as seconds.</span></code>
<code class="calibre21">duration&lt;long, ratio&lt;1&gt;&gt; d6 { d3 + d4 };</code>
<code class="calibre21">println("{} + {} = {} or {}", d3, d4, d5, d6);</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Create a duration of 30 seconds.</span></code>
<code class="calibre21">duration&lt;long&gt; d7 { 30 };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Convert the seconds of d7 to minutes.</span></code>
<code class="calibre21">duration&lt;double, ratio&lt;60&gt;&gt; d8 { d7 };</code>
<code class="calibre21">println("{} = {}", d7, d8);</code>
<code class="calibre21">println("{} seconds = {} minutes", d7.count(), d8.count());</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c22-code-0017"><code class="calibre21">123min (123)</code>
<code class="calibre21">1.79769e+308s</code>
<code class="calibre21">d3 &gt; d4</code>
<code class="calibre21">10min + 30s = 10.5min or 630s</code>
<code class="calibre21">30s = 0.5min</code>
<code class="calibre21">30 seconds = 0.5 minutes</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c22-para-0033">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The second line in the output represents the largest possible
          </i>
          <code class="calibre21">
           duration
          </code>
          <i class="calibre18">
           with type
          </i>
          <code class="calibre21">
           double
          </code>
          <i class="calibre18">
           . The exact value might be different depending on your compiler.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Pay special attention to the following two lines of code:
      </p>
      <pre class="calibre26" id="c22-code-0018"><code class="calibre21">duration&lt;double, ratio&lt;60&gt;&gt; d5 { d3 + d4 };</code>
<code class="calibre21">duration&lt;long, ratio&lt;1&gt;&gt; d6 { d3 + d4 };</code></pre>
      <p class="calibre13" id="c22-para-0035">
       They both calculate
       <code class="calibre21">
        d3+d4
       </code>
       , with
       <code class="calibre21">
        d3
       </code>
       given in minutes and
       <code class="calibre21">
        d4
       </code>
       in seconds, but the first statement stores it as a floating-point value representing minutes, while the second statement stores the result as an integral value representing seconds. Conversion from minutes to seconds, or vice versa, happens automatically.
      </p>
      <p class="calibre13">
       The following two lines from the example demonstrate how to explicitly convert between different units of time:
      </p>
      <pre class="calibre26" id="c22-code-0019"><code class="calibre21">duration&lt;long&gt; d7 { 30 };               <span class="color">// seconds</span></code>
<code class="calibre21">duration&lt;double, ratio&lt;60&gt;&gt; d8 { d7 };  <span class="color">// minutes</span></code></pre>
      <p class="calibre13">
       The first statement defines a
       <code class="calibre21">
        duration
       </code>
       representing 30 seconds. The second statement converts these 30 seconds into minutes, resulting in 0.5 minutes. Converting in this direction can result in a non-integral value and thus requires you to use a
       <code class="calibre21">
        duration
       </code>
       represented by a floating-point type; otherwise, you will get some cryptic compilation errors. The following statements, for example, do not compile because
       <code class="calibre21">
        d8
       </code>
       is using
       <code class="calibre21">
        long
       </code>
       instead of a floating-point type:
      </p>
      <pre class="calibre26" id="c22-code-0020"><code class="calibre21">duration&lt;long&gt; d7 { 30 };               <span class="color">// seconds</span></code>
<code class="calibre21"><b class="calibre14">duration&lt;long, ratio&lt;60&gt;&gt; d8 { d7 };</b>    <span class="color">// minutes   // Error!</span></code></pre>
      <p class="calibre13">
       <span aria-label="867" class="calibre20" epub:type="pagebreak" id="Page_867" role="doc-pagebreak">
       </span>
       You can, however, force this conversion by using
       <code class="calibre21">
        duration_cast()
       </code>
       :
      </p>
      <pre class="calibre26" id="c22-code-0021"><code class="calibre21">duration&lt;long&gt; d7 { 30 };               <span class="color">// seconds</span></code>
<code class="calibre21"><b class="calibre14">auto d8 { duration_cast&lt;duration&lt;long, ratio&lt;60&gt;&gt;&gt;(d7) };</b> <span class="color">// minutes</span></code></pre>
      <p class="calibre13" id="c22-para-0039">
       In this case,
       <code class="calibre21">
        d8
       </code>
       will be 0 minutes, because integer division is used to convert 30 seconds to minutes.
      </p>
      <p class="calibre13">
       Converting in the other direction does not require floating-point types if the source is an integral type, because the result is always an integral value if you started with an integral value. For example, the following statements convert ten minutes into seconds, both represented by the integral type
       <code class="calibre21">
        long
       </code>
       :
      </p>
      <pre class="calibre26" id="c22-code-0022"><code class="calibre21">duration&lt;long, ratio&lt;60&gt;&gt; d9 { 10 };    <span class="color">// minutes</span></code>
<code class="calibre21">duration&lt;long&gt; d10 { d9 };              <span class="color">// seconds</span></code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-462">
       Predefined Durations
      </h3>
      <p class="calibre13">
       The library provides the following standard
       <code class="calibre21">
        duration
       </code>
       types in the
       <code class="calibre21">
        std::chrono
       </code>
       namespace:
      </p>
      <pre class="calibre26" id="c22-code-0023"><code class="calibre21">using nanoseconds  = duration&lt;<i class="calibre18">X 64 bits</i>, nano&gt;;</code>
<code class="calibre21">using microseconds = duration&lt;<i class="calibre18">X 55 bits</i>, micro&gt;;</code>
<code class="calibre21">using milliseconds = duration&lt;<i class="calibre18">X 45 bits</i>, milli&gt;;</code>
<code class="calibre21">using seconds      = duration&lt;<i class="calibre18">X 35 bits</i>&gt;;</code>
<code class="calibre21">using minutes      = duration&lt;<i class="calibre18">X 29 bits</i>, ratio&lt;60&gt;&gt;;</code>
<code class="calibre21">using hours        = duration&lt;<i class="calibre18">X 23 bits</i>, ratio&lt;3'600&gt;&gt;;</code>
<code class="calibre21">using days   = duration&lt;<i class="calibre18">X 25 bits</i>, ratio_multiply&lt;ratio&lt;24&gt;, hours::period&gt;&gt;;</code>
<code class="calibre21">using weeks  = duration&lt;<i class="calibre18">X 22 bits</i>, ratio_multiply&lt;ratio&lt;7&gt;, days::period&gt;&gt;;</code>
<code class="calibre21">using years  = duration&lt;<i class="calibre18">X 17 bits</i>,</code>
<code class="calibre21">               ratio_multiply&lt;ratio&lt;146'097, 400&gt;, days::period&gt;&gt;;</code>
<code class="calibre21">using months = duration&lt;<i class="calibre18">X 20 bits</i>, ratio_divide&lt;years::period, ratio&lt;12&gt;&gt;&gt;;</code></pre>
      <p class="calibre13">
       The exact type of
       <i class="calibre18">
        X
       </i>
       depends on your compiler, but the C++ standard requires it to be a signed integer type of at least the specified size. The preceding type aliases make use of the predefined SI
       <code class="calibre21">
        ratio
       </code>
       type aliases that are described earlier in this chapter. With these predefined types, instead of writing this:
      </p>
      <pre class="calibre26" id="c22-code-0024"><code class="calibre21">duration&lt;long, ratio&lt;60&gt;&gt; d9 { 10 };    <span class="color">// minutes</span></code></pre>
      <p class="calibre13">
       you can simply write this:
      </p>
      <pre class="calibre26" id="c22-code-0025"><code class="calibre21">minutes d9 { 10 };                      <span class="color">// minutes</span></code></pre>
      <p class="calibre13">
       The following code is another example of how to use these predefined durations. The code first defines a variable
       <code class="calibre21">
        t
       </code>
       , which is the result of 1 hour + 23 minutes + 45 seconds. The
       <code class="calibre21">
        auto
       </code>
       keyword is used to let the compiler automatically figure out the exact type of
       <code class="calibre21">
        t
       </code>
       . The second statement uses the constructor of the predefined
       <code class="calibre21">
        seconds
       </code>
       duration to convert the value of
       <code class="calibre21">
        t
       </code>
       to seconds and writes the result to the console:
      </p>
      <pre class="calibre26" id="c22-code-0026"><code class="calibre21">auto t { hours { 1 } + minutes { 23 } + seconds { 45 } };</code>
<code class="calibre21">println("{}", seconds { t });</code></pre>
      <p class="calibre13">
       Because the standard requires that the predefined durations use integer types, there can be compilation errors if a conversion
       <i class="calibre18">
        could
       </i>
       end up with a non-integral value. While integer division normally truncates, in the case of durations, which are implemented with
       <code class="calibre21">
        ratio
       </code>
       types, the compiler declares any computation that
       <i class="calibre18">
        could
       </i>
       result in a non-zero remainder as a compile-time error. For example, the following code does not compile because converting 90 seconds to minutes results in 1.5 minutes:
      </p>
      <pre class="calibre26" id="c22-code-0027"><code class="calibre21">seconds s { 90 };</code>
<code class="calibre21">minutes m { s };</code></pre>
      <p class="calibre13">
       <span aria-label="868" class="calibre20" epub:type="pagebreak" id="Page_868" role="doc-pagebreak">
       </span>
       However, the following code does not compile either, even though 60 seconds is exactly 1 minute. It is flagged as a compile-time error because converting from seconds to minutes
       <i class="calibre18">
        could
       </i>
       result in non-integral values:
      </p>
      <pre class="calibre26" id="c22-code-0028"><code class="calibre21">seconds s { 60 };</code>
<code class="calibre21">minutes m { s };</code></pre>
      <p class="calibre13">
       Converting in the other direction works perfectly fine because the
       <code class="calibre21">
        minutes
       </code>
       duration uses an integral type, and converting it to
       <code class="calibre21">
        seconds
       </code>
       always results in an integral value:
      </p>
      <pre class="calibre26" id="c22-code-0029"><code class="calibre21">minutes m { 2 };</code>
<code class="calibre21">seconds s { m };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-463">
       Standard Literals
      </h3>
      <p class="calibre13">
       You can use the standard literals
       <code class="calibre21">
        h
       </code>
       ,
       <code class="calibre21">
        min
       </code>
       ,
       <code class="calibre21">
        s
       </code>
       ,
       <code class="calibre21">
        ms
       </code>
       ,
       <code class="calibre21">
        us
       </code>
       , and
       <code class="calibre21">
        ns
       </code>
       for creating durations. Technically, these are defined in the
       <code class="calibre21">
        std::literals::chrono_literals
       </code>
       namespace, but just as for the standard string literals discussed in
       <a class="calibre5" href="c02.xhtml">
        Chapter 2
       </a>
       , “Working with Strings and String Views,” the
       <code class="calibre21">
        chrono_literals
       </code>
       namespace is an inline namespace. So, you can make the chrono literals available with any of the following using directives:
      </p>
      <pre class="calibre26" id="c22-code-0030"><code class="calibre21">using namespace std;</code>
<code class="calibre21">using namespace std::literals;</code>
<code class="calibre21">using namespace std::chrono_literals;</code>
<code class="calibre21">using namespace std::literals::chrono_literals;</code></pre>
      <p class="calibre13">
       Additionally, the literals are also made available in the
       <code class="calibre21">
        std::chrono
       </code>
       namespace. Here is an example:
      </p>
      <pre class="calibre26" id="c22-code-0031"><code class="calibre21">using namespace std::chrono;</code>
<code class="calibre21"><span class="color">// …</span></code>
<code class="calibre21">auto myDuration { 42min };    <span class="color">// 42 minutes</span></code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0010">
      </span>
      <h3 class="calibre27" id="head-3-464">
       hh_mm_ss
      </h3>
      <p class="calibre13" id="c22-para-0050">
       The chrono library provides the
       <code class="calibre21">
        hh_mm_ss
       </code>
       class template, which accepts a
       <code class="calibre21">
        Duration
       </code>
       and splits the given duration into hours, minutes, seconds, and subseconds. It has getters
       <code class="calibre21">
        hours()
       </code>
       ,
       <code class="calibre21">
        minutes()
       </code>
       ,
       <code class="calibre21">
        seconds()
       </code>
       , and
       <code class="calibre21">
        subseconds()
       </code>
       to retrieve the data, always returning non-negative values. The
       <code class="calibre21">
        is_negative()
       </code>
       member function returns
       <code class="calibre21">
        true
       </code>
       if the duration is a negative duration,
       <code class="calibre21">
        false
       </code>
       otherwise. You'll use the
       <code class="calibre21">
        hh_mm_ss
       </code>
       class template in one of the exercises at the end of this chapter.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-229" class="calibre2">
     <span class="calibre" id="c22-sec-0011">
     </span>
     <h2 class="calibre6" id="head-2-229">
      CLOCK
     </h2>
     <p class="calibre13" id="c22-para-0051">
      A
      <code class="calibre21">
       clock
      </code>
      is a class consisting of a
      <code class="calibre21">
       time_point
      </code>
      and a
      <code class="calibre21">
       duration
      </code>
      . The
      <code class="calibre21">
       time_point
      </code>
      type is discussed in detail in the next section, but those details are not required to understand how
      <code class="calibre21">
       clock
      </code>
      s work. However,
      <code class="calibre21">
       time_point
      </code>
      s themselves depend on
      <code class="calibre21">
       clock
      </code>
      s, so it's important to know the details of
      <code class="calibre21">
       clock
      </code>
      s first.
     </p>
     <p class="calibre13" id="c22-para-0052">
      The standard defines several
      <code class="calibre21">
       clock
      </code>
      s, which are described in the following table. The
      <i class="calibre18">
       epoch
      </i>
      of a clock is the time at which the clock starts counting.
     </p>
     <p class="calibre13">
      <span aria-label="869" class="calibre20" epub:type="pagebreak" id="Page_869" role="doc-pagebreak">
      </span>
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         CLOCK
        </th>
        <th class="left" scope="col">
         DESCRIPTION
        </th>
        <th class="left" scope="col">
         EPOCH
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          system_clock
         </span>
        </td>
        <td class="bgcolor">
         Represents the UTC wall clock time from the system-wide real-time clock.
        </td>
        <td class="bgcolor">
         1970-01-01 00:00:00
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          steady_clock
         </span>
        </td>
        <td class="bgcolor">
         Guarantees its
         <span class="calibre21">
          time_point
         </span>
         never decreases, which is not guaranteed for
         <code class="calibre21">
          system_clock
         </code>
         because the system clock can be adjusted at any time. In fact, this clock is not required to be related to wall clock time; e.g., it could be the time since the start of the operating system.
        </td>
        <td class="bgcolor">
         Unspecified
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          high_resolution_clock
         </span>
        </td>
        <td class="bgcolor">
         Has the shortest possible tick period. Depending on your compiler, it is possible for this clock to be a synonym for
         <span class="calibre21">
          steady_clock
         </span>
         or
         <code class="calibre21">
          system_clock
         </code>
         .
        </td>
        <td class="bgcolor">
         Unspecified
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          utc_clock
         </span>
        </td>
        <td class="bgcolor">
         Represents the Coordinated Universal Time (UTC) wall clock time.
        </td>
        <td class="bgcolor">
         1970-01-01 00:00:00
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          tai_clock
         </span>
        </td>
        <td class="bgcolor">
         Represents International Atomic Time (TAI), using a weighted average of several atomic clocks.
        </td>
        <td class="bgcolor">
         1958-01-01 00:00:00
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          gps_clock
         </span>
        </td>
        <td class="bgcolor">
         Represents Global Position System (GPS) time, i.e., the time maintained by the atomic clocks of GPS satellites.
        </td>
        <td class="bgcolor">
         1980-01-06 00:00:00
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          file_clock
         </span>
        </td>
        <td class="bgcolor">
         Represents file time. It's an alias for
         <span class="calibre21">
          std::filesystem::file_time_type
         </span>
         .
        </td>
        <td class="bgcolor">
         Unspecified, but typically 1970-01-01 on Unix, and 1601-01-01 on Windows.
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13">
      The
      <code class="calibre21">
       utc_clock
      </code>
      is the only clock that tracks leap seconds, which are seconds that are occasionally added to or subtracted from UTC time to correct for any mismatch between UTC time and true solar time. The other clocks don't track leap seconds, while for
      <code class="calibre21">
       file_clock
      </code>
      it's unspecified.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c22-para-0056">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          The use of the
         </i>
         <code class="calibre21">
          high_resolution_clock
         </code>
         <i class="calibre18">
          is discouraged because its implementation is not consistent between different compilers. For some compilers, it might be an alias for
         </i>
         <code class="calibre21">
          steady_clock
         </code>
         <i class="calibre18">
          , while for others it might be an alias for
         </i>
         <code class="calibre21">
          system_clock
         </code>
         <i class="calibre18">
          . Hence, for some compilers, the
         </i>
         <code class="calibre21">
          high_resolution_clock
         </code>
         <i class="calibre18">
          can go backwards, and for others it doesn't.
         </i>
        </p>
        <p class="calibre25" id="c22-para-0057">
         <i class="calibre18">
          Instead, it's recommended to use
         </i>
         <code class="calibre21">
          system_clock
         </code>
         <i class="calibre18">
          to work with wall clock time and
         </i>
         <code class="calibre21">
          steady_clock
         </code>
         <i class="calibre18">
          to measure durations.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c22-para-0058">
      <span aria-label="870" class="calibre20" epub:type="pagebreak" id="Page_870" role="doc-pagebreak">
      </span>
      Every
      <code class="calibre21">
       clock
      </code>
      has a static
      <code class="calibre21">
       now()
      </code>
      member function to get the current time as a
      <code class="calibre21">
       time_point
      </code>
      , and an
      <code class="calibre21">
       is_steady()
      </code>
      member function returning
      <code class="calibre21">
       true
      </code>
      if the clock is steady, i.e., never goes backwards,
      <code class="calibre21">
       false
      </code>
      otherwise.
     </p>
     <p class="calibre13" id="c22-para-0059">
      The
      <code class="calibre21">
       system_clock
      </code>
      also defines two static helper member functions for converting
      <code class="calibre21">
       time_point
      </code>
      s to and from the
      <code class="calibre21">
       time_t
      </code>
      C-style time representation. The first one is called
      <code class="calibre21">
       to_time_t()
      </code>
      , and it converts a given
      <code class="calibre21">
       time_point
      </code>
      to a
      <code class="calibre21">
       time_t
      </code>
      ; the second one,
      <code class="calibre21">
       from_time_t()
      </code>
      , performs the opposite conversion. The
      <code class="calibre21">
       time_t
      </code>
      type is defined in
      <code class="calibre21">
       &lt;ctime&gt;
      </code>
      .
     </p>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0013">
      </span>
      <h3 class="calibre27" id="head-3-465">
       Printing Current Time
      </h3>
      <p class="calibre13">
       The following example demonstrates how to get the current UTC time and print it to the console in a human-readable format:
      </p>
      <pre class="calibre26" id="c22-code-0032"><code class="calibre21"><span class="color">// Set the global locale to the user's local (see <a class="calibre5" href="c21.xhtml">Chapter 21</a>).</span></code>
<code class="calibre21">locale::global(locale { "" });</code>
<code class="calibre21"><span class="color">// Print the current UTC time.</span></code>
<code class="calibre21">println("UTC: {:L}", system_clock::now());</code>
<code class="calibre21">println("UTC: {:L%c}", system_clock::now());</code></pre>
      <p class="calibre13">
       This code snippet first sets the global
       <code class="calibre21">
        locale
       </code>
       to the user's
       <code class="calibre21">
        locale
       </code>
       ; see
       <a class="calibre5" href="c21.xhtml">
        Chapter 21
       </a>
       , “String Localization and Regular Expressions.” This makes sure everything is printed according to the user's preferences. The
       <code class="calibre21">
        println()
       </code>
       statements use the
       <code class="calibre21">
        L
       </code>
       format specifier to format the date and time according to the configured global
       <code class="calibre21">
        locale
       </code>
       . The effect of the
       <code class="calibre21">
        %c
       </code>
       format specifier is also demonstrated. There are many more format specifiers supported. Consult a Standard Library reference to learn more about them. Here is sample output from the previous code snippet:
      </p>
      <pre class="calibre26" id="c22-code-0033"><code class="calibre21">UTC: 2023-07-19 11:38:44,5521944</code>
<code class="calibre21">UTC: 2023-07-19 11:38:44</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0014">
      </span>
      <h3 class="calibre27" id="head-3-466">
       Execution Timing
      </h3>
      <p class="calibre13">
       To time how long it takes for a piece of code to execute, you want to use a clock that is guaranteed not to go backwards. Hence, you should use a
       <code class="calibre21">
        steady_clock
       </code>
       . The following code snippet gives an example. The actual type of the variables
       <code class="calibre21">
        start
       </code>
       and
       <code class="calibre21">
        end
       </code>
       is
       <code class="calibre21">
        steady_clock::time_point
       </code>
       , and the actual type of
       <code class="calibre21">
        diff
       </code>
       is a
       <code class="calibre21">
        duration
       </code>
       .
      </p>
      <pre class="calibre26" id="c22-code-0034"><code class="calibre21"><span class="color">// Get the start time.</span></code>
<code class="calibre21">auto start { steady_clock::now() };</code>
<code class="calibre21"><span class="color">// Execute code that you want to time.</span></code>
<code class="calibre21">const int numberOfIterations { 10'000'000 };</code>
<code class="calibre21">double d { 0 };</code>
<code class="calibre21">for (int i { 0 }; i &lt; numberOfIterations; ++i) { d += sqrt(abs(sin(i) * cos(i))); }</code>
<code class="calibre21"><span class="color">// Get the end time and calculate the difference.</span></code>
<code class="calibre21">auto end { steady_clock::now() };</code>
<code class="calibre21">auto diff { end - start };</code>
<code class="calibre21"><span class="color">// Use the calculated result, otherwise the compiler might</span></code>
<code class="calibre21"><span class="color">// optimize away the entire loop!</span></code>
<code class="calibre21">println("d = {}", d);</code>
<span aria-label="871" class="calibre20" epub:type="pagebreak" id="Page_871" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Convert the difference into milliseconds and output to the console.</span></code>
<code class="calibre21">println("Total: {}", duration&lt;double, milli&gt; { diff });</code>
<code class="calibre21"><span class="color">// Use duration_cast() if you don't need fractional milliseconds.</span></code>
<code class="calibre21">println("Total: {}", duration_cast&lt;milliseconds&gt;(diff));</code>
<code class="calibre21"><span class="color">// Print the time per iteration in nanoseconds.</span></code>
<code class="calibre21">println("{} per iteration", duration&lt;double, nano&gt; { diff / numberOfIterations });</code></pre>
      <p class="calibre13">
       Here is the output running on my test system:
      </p>
      <pre class="calibre26" id="c22-code-0035"><code class="calibre21">d = 5393526.082683575</code>
<code class="calibre21">Total: 78.7931ms</code>
<code class="calibre21">Total: 78ms</code>
<code class="calibre21">7ns per iteration</code></pre>
      <p class="calibre13" id="c22-para-0064">
       The loop in this example is performing some arithmetic operations with
       <code class="calibre21">
        sqrt()
       </code>
       ,
       <code class="calibre21">
        abs()
       </code>
       ,
       <code class="calibre21">
        sin()
       </code>
       , and
       <code class="calibre21">
        cos()
       </code>
       to make sure the loop doesn't end too fast. If you get really small values for the difference in milliseconds on your system, those values will not be accurate, and you should increase the number of iterations of the loop to make it last longer. Small timings will not be accurate because while timers often have a resolution in milliseconds, on most operating systems, this timer is updated infrequently, for example, every 10 ms or 15 ms. This induces a phenomenon called
       <i class="calibre18">
        gating error
       </i>
       , where any event that occurs in less than one timer tick appears to take place in zero units of time, and any event between one and two timer ticks appears to take place in one timer unit. For example, on a system with a 15 ms timer update, a loop that takes 44 ms will appear to take only 30 ms. When using such timers to time computations, it is important to make sure that the entire computation takes place across a fairly large number of basic timer tick units so that these errors are minimized.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-230" class="calibre2">
     <span class="calibre" id="c22-sec-0015">
     </span>
     <h2 class="calibre6" id="head-2-230">
      TIME POINT
     </h2>
     <p class="calibre13" id="c22-para-0065">
      A point in time is represented by the
      <code class="calibre21">
       time_point
      </code>
      class and stored as a
      <code class="calibre21">
       duration
      </code>
      relative to an
      <i class="calibre18">
       epoch
      </i>
      , representing the beginning of time. A
      <code class="calibre21">
       time_point
      </code>
      is always associated with a certain
      <code class="calibre21">
       clock
      </code>
      , and the epoch is the origin of this associated
      <code class="calibre21">
       clock
      </code>
      . For example, the epoch for the classic Unix/Linux time is January 1, 1970, and durations are measured in seconds. The epoch for Windows is January 1, 1601, and durations are measured in 100-nanosecond units. Other operating systems have different epoch dates and duration units.
     </p>
     <p class="calibre13" id="c22-para-0066">
      The
      <code class="calibre21">
       time_point
      </code>
      class has a function called
      <code class="calibre21">
       time_since:epoch()
      </code>
      , which returns a
      <code class="calibre21">
       duration
      </code>
      representing the time between the epoch of the associated
      <code class="calibre21">
       clock
      </code>
      and the stored point in time.
     </p>
     <p class="calibre13">
      Arithmetic operations of
      <code class="calibre21">
       time_point
      </code>
      s and
      <code class="calibre21">
       duration
      </code>
      s that make sense are supported. The following table lists those operations.
      <code class="calibre21">
       tp
      </code>
      is a
      <code class="calibre21">
       time_point
      </code>
      , and
      <code class="calibre21">
       d
      </code>
      is a
      <code class="calibre21">
       duration
      </code>
      :
     </p>
     <table border="1" class="calibre31">
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          tp + d = tp
         </span>
        </td>
        <td class="bgcolor">
         <span class="calibre21">
          tp – d = tp
         </span>
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          d + tp = tp
         </span>
        </td>
        <td class="bgcolor">
         <span class="calibre21">
          tp – tp = d
         </span>
        </td>
       </tr>
       <tr class="calibre33">
        <td class="bgcolor">
         <span class="calibre21">
          tp += d
         </span>
        </td>
        <td class="bgcolor">
         <span class="calibre21">
          tp -= d
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13" id="c22-para-0069">
      An example of an operation that is not supported is
      <code class="calibre21">
       tp+tp
      </code>
      .
     </p>
     <p class="calibre13" id="c22-para-0070">
      <span aria-label="872" class="calibre20" epub:type="pagebreak" id="Page_872" role="doc-pagebreak">
      </span>
      Comparison operators
      <code class="calibre21">
       ==
      </code>
      and
      <code class="calibre21">
       &lt;=&gt;
      </code>
      to compare two time points are supported. Two static member functions are provided:
      <code class="calibre21">
       min()
      </code>
      and
      <code class="calibre21">
       max()
      </code>
      returning the smallest and largest possible point in time, respectively.
     </p>
     <p class="calibre13">
      The
      <code class="calibre21">
       time_point
      </code>
      class has three constructors:
     </p>
     <ul class="check" id="c22-list-0004">
      <li class="calibre9" id="c22-li-0012">
       <b class="calibre14">
        <code class="calibre21">
         time_point():
        </code>
       </b>
       Constructs a
       <code class="calibre21">
        time_point
       </code>
       initialized with
       <code class="calibre21">
        duration::zero()
       </code>
       . The resulting
       <code class="calibre21">
        time_point
       </code>
       represents the epoch of the associated
       <code class="calibre21">
        clock
       </code>
       .
      </li>
      <li class="calibre9" id="c22-li-0013">
       <code class="calibre21">
        time_point(const duration&amp; d):
       </code>
       Constructs a
       <code class="calibre21">
        time_point
       </code>
       initialized with the given
       <code class="calibre21">
        duration
       </code>
       . The resulting
       <code class="calibre21">
        time_point
       </code>
       represents
       <code class="calibre21">
        epoch + d
       </code>
       .
      </li>
      <li class="calibre9" id="c22-li-0014">
       <code class="calibre21">
        template&lt;class Duration2&gt; time_point(const time_point&lt;clock, Duration2&gt;&amp; t):
       </code>
       Constructs a
       <code class="calibre21">
        time_point
       </code>
       initialized with
       <code class="calibre21">
        t.time_since:epoch()
       </code>
       .
      </li>
     </ul>
     <p class="calibre13">
      Each
      <code class="calibre21">
       time_point
      </code>
      is associated with a
      <code class="calibre21">
       clock
      </code>
      . To create a
      <code class="calibre21">
       time_point
      </code>
      , you specify the
      <code class="calibre21">
       clock
      </code>
      as the template parameter:
     </p>
     <pre class="calibre26" id="c22-code-0036"><code class="calibre21">time_point&lt;steady_clock&gt; tp1;</code></pre>
     <p class="calibre13">
      Each
      <code class="calibre21">
       clock
      </code>
      also knows its
      <code class="calibre21">
       time_point
      </code>
      type, so you can also write it as follows:
     </p>
     <pre class="calibre26" id="c22-code-0037"><code class="calibre21">steady_clock::time_point tp1;</code></pre>
     <p class="calibre13">
      The following code snippet demonstrates some operations with
      <code class="calibre21">
       time_point
      </code>
      s:
     </p>
     <pre class="calibre26" id="c22-code-0038"><code class="calibre21"><span class="color">// Create a time_point representing the epoch of the associated steady clock.</span></code>
<code class="calibre21">time_point&lt;steady_clock&gt; tp1;</code>
<code class="calibre21"><span class="color">// Add 10 minutes to the time_point.</span></code>
<code class="calibre21">tp1 += minutes { 10 };</code>
<code class="calibre21"><span class="color">// Store the duration between epoch and time_point.</span></code>
<code class="calibre21">auto d1 { tp1.time_since:epoch() };</code>
<code class="calibre21"><span class="color">// Convert the duration to seconds and output to the console.</span></code>
<code class="calibre21">duration&lt;double&gt; d2 { d1 };</code>
<code class="calibre21">println("{}", d2);</code></pre>
     <p class="calibre13">
      The output is as follows:
     </p>
     <pre class="calibre26" id="c22-code-0039"><code class="calibre21">600s</code></pre>
     <p class="calibre13">
      Converting
      <code class="calibre21">
       time_point
      </code>
      s can be done implicitly or explicitly, similar to
      <code class="calibre21">
       duration
      </code>
      conversions. Here is an example of an implicit conversion. The output is
      <code class="calibre21">
       42000ms
      </code>
      :
     </p>
     <pre class="calibre26" id="c22-code-0040"><code class="calibre21">time_point&lt;steady_clock, seconds&gt; tpSeconds { 42s };</code>
<code class="calibre21"><span class="color">// Convert seconds to milliseconds implicitly.</span></code>
<code class="calibre21">time_point&lt;steady_clock, milliseconds&gt; tpMilliseconds { tpSeconds };</code>
<code class="calibre21">println("{}", tpMilliseconds.time_since:epoch());</code></pre>
     <p class="calibre13">
      If the implicit conversion can result in a loss of data, then you need an explicit conversion using
      <code class="calibre21">
       time_point_cast()
      </code>
      , similar to using
      <code class="calibre21">
       duration_cast()
      </code>
      for explicit
      <code class="calibre21">
       duration
      </code>
      casts as discussed earlier in this chapter. The following example outputs
      <code class="calibre21">
       42000ms
      </code>
      , even though you start from 42,424ms:
     </p>
     <pre class="calibre26" id="c22-code-0041"><code class="calibre21">time_point&lt;steady_clock, milliseconds&gt; tpMilliseconds { 42'424ms };</code>
<code class="calibre21"><span class="color">// Convert milliseconds to seconds explicitly.</span></code>
<code class="calibre21">time_point&lt;steady_clock, seconds&gt; tpSeconds {</code>
<code class="calibre21">    time_point_cast&lt;seconds&gt;(tpMilliseconds) };</code>
<code class="calibre21"><span class="color">// Or:</span></code>
<code class="calibre21"><span class="color">// auto tpSeconds { time_point_cast&lt;seconds&gt;(tpMilliseconds) };</span></code>
<code class="calibre21"></code>
<span aria-label="873" class="calibre20" epub:type="pagebreak" id="Page_873" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Convert seconds back to milliseconds and output the result.</span></code>
<code class="calibre21">milliseconds ms { tpSeconds.time_since:epoch() };</code>
<code class="calibre21">println("{}", ms);</code></pre>
     <p class="calibre13" id="c22-para-0078">
      The library supports
      <code class="calibre21">
       floor()
      </code>
      ,
      <code class="calibre21">
       ceil()
      </code>
      , and
      <code class="calibre21">
       round()
      </code>
      operations for
      <code class="calibre21">
       time_point
      </code>
      s that behave just as they behave with numerical data.
     </p>
    </section>
    <section aria-labelledby="head-2-231" class="calibre2">
     <span class="calibre" id="c22-sec-0016">
     </span>
     <h2 class="calibre6" id="head-2-231">
      DATE
     </h2>
     <p class="calibre13" id="c22-para-0079">
      The Standard Library supports working with calendar dates. At this moment, only the Gregorian calendar is supported, but if need be, you can always implement your own calendars that can interoperate with the rest of the
      <code class="calibre21">
       &lt;chrono&gt;
      </code>
      functionality, such as Coptic and Julian calendars.
     </p>
     <p class="calibre13" id="c22-para-0080">
      The Standard Library provides quite a few classes and functions to work with dates (and time zones discussed in a later section). This text discusses the most important classes and functions. Consult a Standard Library reference (see
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography”) to get a complete overview of everything that's available.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-467">
       Creating Dates
      </h3>
      <p class="calibre13" id="c22-para-0081">
       The following calendrical classes are available to create dates, all defined in
       <code class="calibre21">
        std::chrono
       </code>
       :
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          CLASS
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           year
          </span>
         </td>
         <td class="bgcolor">
          Represents a year in the range [-32767, 32767]. A
          <span class="calibre">
           year
          </span>
          has a member function called
          <code class="calibre21">
           is_leap()
          </code>
          returning
          <code class="calibre21">
           true
          </code>
          if a given
          <span class="calibre">
           year
          </span>
          is a leap year,
          <code class="calibre21">
           false
          </code>
          otherwise.
          <code class="calibre21">
           min()
          </code>
          and
          <code class="calibre21">
           max()
          </code>
          static member functions return the minimum and maximum year, respectively.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           month
          </span>
         </td>
         <td class="bgcolor">
          Represents a month in the range [1, 12]. Additionally, there are 12 named constants provided for the 12 months, for example:
          <span class="calibre21">
           std::chrono::January
          </span>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           day
          </span>
         </td>
         <td class="bgcolor">
          Represents a day in the range [1, 31].
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           weekday
          </span>
         </td>
         <td class="bgcolor">
          Represents a day of the week in the range [0, 6], where 0 means Sunday. Additionally, there are seven named constants provided for the seven weekdays, for example:
          <span class="calibre21">
           std::chrono::Sunday
          </span>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           weekday_indexed
          </span>
         </td>
         <td class="bgcolor">
          Represents the first, second, third, fourth, or fifth weekday of a month. Can easily be constructed from a
          <span class="calibre21">
           weekday
          </span>
          , for example:
          <code class="calibre21">
           Monday[2]
          </code>
          is the second Monday of a month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           weekday_last
          </span>
         </td>
         <td class="bgcolor">
          Represents the last weekday of some month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           month_day
          </span>
         </td>
         <td class="bgcolor">
          Represents a specific month and day.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           month_day_last
          </span>
         </td>
         <td class="bgcolor">
          Represents the last day of a specific month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           month_weekday
          </span>
         </td>
         <td class="bgcolor">
          Represents the
          <i class="calibre18">
           n
          </i>
          <sup class="calibre22">
           th
          </sup>
          weekday of a specific month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           month_weekday_last
          </span>
         </td>
         <td class="bgcolor">
          Represents the last weekday of a specific month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           year_month
          </span>
         </td>
         <td class="bgcolor">
          Represents a specific year and month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           year_month_day
          </span>
         </td>
         <td class="bgcolor">
          Represents a specific year, month, and day.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           year_month_day_last
          </span>
         </td>
         <td class="bgcolor">
          Represents the last day of a specific year and month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           year_month_weekday
          </span>
         </td>
         <td class="bgcolor">
          Represents the
          <i class="calibre18">
           n
          </i>
          <sup class="calibre22">
           th
          </sup>
          weekday of a specific year and month.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="bgcolor">
          <span class="calibre21">
           year_month_weekday_last
          </span>
         </td>
         <td class="bgcolor">
          Represents the last weekday of a specific year and month.
          <span aria-label="874" class="calibre20" epub:type="pagebreak" id="Page_874" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       All of these classes have a member function called
       <code class="calibre21">
        ok()
       </code>
       that returns
       <code class="calibre21">
        true
       </code>
       if the given object is in a valid range,
       <code class="calibre21">
        false
       </code>
       otherwise. Two additional standard literals are provided in
       <code class="calibre21">
        std::literals::chrono_literals
       </code>
       :
       <code class="calibre21">
        y
       </code>
       to create years, and
       <code class="calibre21">
        d
       </code>
       to create days. Complete dates can be constructed using
       <code class="calibre21">
        operator/
       </code>
       to specify year, month, and day, in three orders: Y/M/D, M/D/Y, D/M/Y. Here are some examples to create dates:
      </p>
      <pre class="calibre26" id="c22-code-0042"><code class="calibre21">year y1 { 2020 };</code>
<code class="calibre21">auto y2 { 2020y };</code>
<code class="calibre21"></code>
<code class="calibre21">month m1 { 6 };</code>
<code class="calibre21">auto m2 { June };</code>
<code class="calibre21"></code>
<code class="calibre21">day d1 { 22 };</code>
<code class="calibre21">auto d2 { 22d };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Create a date for 2020-06-22.</span></code>
<code class="calibre21">year_month_day fulldate1 { 2020y, June, 22d };</code>
<code class="calibre21">auto fulldate2 { 2020y / June / 22d };</code>
<code class="calibre21">auto fulldate3 { 22d / June / 2020y };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Create a date for the 3rd Monday of June 2020.</span></code>
<code class="calibre21">year_month_day fulldate4 { Monday[3] / June / 2020 };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Create a month_day for June 22 of an unspecified year.</span></code>
<code class="calibre21">auto june22 { June / 22d };</code>
<code class="calibre21"><span class="color">// Create a year_month_day for June 22, 2020.</span></code>
<code class="calibre21">auto june22_2020 { 2020y / june22 };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Create a month_day_last for the last day of a June of an unspecified year.</span></code>
<code class="calibre21">auto lastDayOfAJune { June / last };</code>
<code class="calibre21"><span class="color">// Create a year_month_day_last for the last day of June for the year 2020.</span></code>
<code class="calibre21">auto lastDayOfJune2020 { 2020y / lastDayOfAJune };</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Create a year_month_weekday_last for the last Monday of June 2020.</span></code>
<code class="calibre21">auto lastMondayOfJune2020 { 2020y / June / Monday[last] };</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        sys_time
       </code>
       is a type alias for a
       <code class="calibre21">
        time_point
       </code>
       of a
       <code class="calibre21">
        system_clock
       </code>
       with a certain duration. It's defined as follows:
      </p>
      <pre class="calibre26" id="c22-code-0043"><code class="calibre21">template &lt;typename Duration&gt;</code>
<code class="calibre21">using sys_time = std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt;;</code></pre>
      <p class="calibre13">
       <span aria-label="875" class="calibre20" epub:type="pagebreak" id="Page_875" role="doc-pagebreak">
       </span>
       Based on the
       <code class="calibre21">
        sys_time
       </code>
       type alias, two additional type aliases are defined to represent a
       <code class="calibre21">
        sys_time
       </code>
       with a precision of seconds, and one with a precision of days:
      </p>
      <pre class="calibre26" id="c22-code-0044"><code class="calibre21">using sys_seconds = sys_time&lt;std::chrono::seconds&gt;;</code>
<code class="calibre21">using sys_days = sys_time&lt;std::chrono::days&gt;;</code></pre>
      <p class="calibre13" id="c22-para-0087">
       <code class="calibre21">
        sys_days
       </code>
       , for example, represents the number of days since the
       <code class="calibre21">
        system_clock
       </code>
       epoch, and hence, it's a
       <i class="calibre18">
        serial-based type
       </i>
       ; that is, it just contains a single number (days since epoch). On the other hand,
       <code class="calibre21">
        year_month_day
       </code>
       , for example, is a
       <i class="calibre18">
        field-based type
       </i>
       , it stores a year, a month, and a day in separate fields. When doing a lot of arithmetic with dates, a serial-based type will be more performant than a field-based type.
      </p>
      <p class="calibre13" id="c22-para-0088">
       Similar type aliases exist to work with local time:
       <code class="calibre21">
        local_time
       </code>
       ,
       <code class="calibre21">
        local_seconds
       </code>
       , and
       <code class="calibre21">
        local_days
       </code>
       . These are demonstrated in a later section on time zones.
      </p>
      <p class="calibre13">
       You can create a
       <code class="calibre21">
        sys_days
       </code>
       representing today as follows.
       <code class="calibre21">
        floor()
       </code>
       is used to truncate a
       <code class="calibre21">
        time_point
       </code>
       to a precision of days:
      </p>
      <pre class="calibre26" id="c22-code-0045"><code class="calibre21">auto today { floor&lt;days&gt;(system_clock::now()) };</code></pre>
      <p class="calibre13">
       <code class="calibre21">
        sys_days
       </code>
       can be used to convert a
       <code class="calibre21">
        year_month_day
       </code>
       to a
       <code class="calibre21">
        time_point
       </code>
       , for example:
      </p>
      <pre class="calibre26" id="c22-code-0046"><code class="calibre21">system_clock::time_point t1 { sys_days { 2020y / June / 22d } };</code></pre>
      <p class="calibre13">
       The opposite conversion, converting a
       <code class="calibre21">
        time_point
       </code>
       to a
       <code class="calibre21">
        year_month_day
       </code>
       , can be done with a
       <code class="calibre21">
        year_month_day
       </code>
       constructor. The following code snippet gives two examples:
      </p>
      <pre class="calibre26" id="c22-code-0047"><code class="calibre21">year_month_day yearmonthday { floor&lt;days&gt;(t1) };</code>
<code class="calibre21">year_month_day today2 { floor&lt;days&gt;(system_clock::now()) };</code></pre>
      <p class="calibre13">
       A complete date including a time can be build up as well. Here's an example:
      </p>
      <pre class="calibre26" id="c22-code-0048"><code class="calibre21"><span class="color">// Full date with time: 2020-06-22 09:35:10 UTC.</span></code>
<code class="calibre21">auto t2 { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0018">
      </span>
      <h3 class="calibre27" id="head-3-468">
       Printing Dates
      </h3>
      <p class="calibre13">
       Dates can be written to streams using the familiar insertion operator:
      </p>
      <pre class="calibre26" id="c22-code-0049"><code class="calibre21">cout &lt;&lt; yearmonthday &lt;&lt; endl;</code></pre>
      <p class="calibre13">
       Printing and formatting dates are also supported. The
       <code class="calibre21">
        L
       </code>
       format specifier formats the output according to the current global
       <code class="calibre21">
        locale
       </code>
       .
      </p>
      <pre class="calibre26" id="c22-code-0050"><code class="calibre21">println("{:L}", yearmonthday);</code></pre>
      <p class="calibre13">
       Keep in mind that the output might sometimes be unexpected. For example,
       <code class="calibre21">
        lastMondayOfJune2020
       </code>
       is defined earlier as follows:
      </p>
      <pre class="calibre26" id="c22-code-0051"><code class="calibre21"><span class="color">// Create a year_month_weekday_last for the last Monday of June 2020.</span></code>
<code class="calibre21">auto lastMondayOfJune2020 { 2020y / June / Monday[last] };</code></pre>
      <p class="calibre13">
       When you print this, the output is “2020/Jun/Mon[last]”:
      </p>
      <pre class="calibre26" id="c22-code-0052"><code class="calibre21">println("{:L}", lastMondayOfJune2020);     <span class="color">// 2020/Jun/Mon[last]</span></code></pre>
      <p class="calibre13">
       <span aria-label="876" class="calibre20" epub:type="pagebreak" id="Page_876" role="doc-pagebreak">
       </span>
       If you want to output the exact date, “2020-06-29,” then you need to convert the
       <code class="calibre21">
        year_month_weekday_last
       </code>
       to a
       <code class="calibre21">
        year_month_day
       </code>
       and then output the result:
      </p>
      <pre class="calibre26" id="c22-code-0053"><code class="calibre21">year_month_day lastMondayOfJune2020YMD { sys_days { lastMondayOfJune2020 } };</code>
<code class="calibre21">println("{:L}", lastMondayOfJune2020YMD);  <span class="color">// 2020-06-29</span></code></pre>
      <p class="calibre13" id="c22-para-0098">
       If a date is invalid, printing will insert an error. For example, the string “is not a valid date” is appended to an invalid
       <code class="calibre21">
        year_month_day
       </code>
       .
      </p>
      <p class="calibre13">
       Using the
       <code class="calibre21">
        L
       </code>
       format specifier, names of days and months are correctly localized according to the current global
       <code class="calibre21">
        locale
       </code>
       . For example, the following code snippet first sets the global locale to Dutch, nl-NL, and then uses the
       <code class="calibre21">
        L
       </code>
       format specifier to print
       <code class="calibre21">
        Monday
       </code>
       in Dutch. The
       <code class="calibre21">
        %A
       </code>
       format specifier causes the full name to be printed instead of the abbreviated name. Consult your favorite Standard Library reference for a full list of all supported date format specifiers.
      </p>
      <pre class="calibre26" id="c22-code-0054"><code class="calibre21">locale::global(locale { "nl-NL" });</code>
<code class="calibre21">println("Monday in Dutch is {:L%A}", Monday);</code></pre>
      <p class="calibre13">
       The output is:
      </p>
      <pre class="calibre26" id="c22-code-0055"><code class="calibre21">Monday in Dutch is maandag</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c22-sec-0019">
      </span>
      <h3 class="calibre27" id="head-3-469">
       Arithmetic with Dates
      </h3>
      <p class="calibre13">
       You can perform arithmetic with dates. Here's an example:
      </p>
      <pre class="calibre26" id="c22-code-0056"><code class="calibre21"><span class="color">// Full date with time: 2020-06-22 09:35:10 UTC.</span></code>
<code class="calibre21">auto t2 { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code>
<code class="calibre21">auto t3 { t2 + days { 5 } };    <span class="color">// Add 5 days to t2.</span></code>
<code class="calibre21">auto t4 { t3 + years { 1 } };   <span class="color">// Add 1 year to t3.</span></code></pre>
      <p class="calibre13">
       Be careful, though, as the result might not always be as expected. For example:
      </p>
      <pre class="calibre26" id="c22-code-0057"><code class="calibre21">auto t5 { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code>
<code class="calibre21">auto t6 { t5 + years { 1 } };   <span class="color">// Add 1 year to t5</span></code>
<code class="calibre21">println("t5 = {:L}", t5);</code>
<code class="calibre21">println("t6 = {:L}", t6);</code></pre>
      <p class="calibre13">
       The result is as follows:
      </p>
      <pre class="calibre26" id="c22-code-0058"><code class="calibre21">t5 = 2020-06-22 09:35:10</code>
<code class="calibre21">t6 = 2021-06-22 <b class="calibre14">15:24:22</b></code></pre>
      <p class="calibre13" id="c22-para-0104">
       In looking at the results, you can see that the year is updated, but you can also see that the time has changed. The issue here is that we are working with a serial type:
       <code class="calibre21">
        sys_days
       </code>
       is a
       <code class="calibre21">
        time_point
       </code>
       , which is a serial type. Adding 1 year to such a serial type does not add 86,400 * 365 = 31,536,000 seconds. Instead, the standard mandates that adding 1 year must add 1
       <b class="calibre14">
        average year
       </b>
       to keep leap years into account, and hence, it must add 86,400 * ((365 * 400) + 97) / 400 = 31,556,952 seconds.
      </p>
      <p class="calibre13">
       If you need to add exactly 1 year, then it's best to use a field-based type instead, for example:
      </p>
      <pre class="calibre26" id="c22-code-0059"><code class="calibre21"><span class="color">// Split t5 into days and remaining seconds.</span></code>
<code class="calibre21">sys_days t5_days { time_point_cast&lt;days&gt;(t5) };</code>
<code class="calibre21">seconds t5_seconds { t5 - t5_days };</code>
<code class="calibre21"><span class="color">// Convert the t5_days serial type to field-based type.</span></code>
<code class="calibre21">year_month_day t5_ymd { t5_days };</code>
<span aria-label="877" class="calibre20" epub:type="pagebreak" id="Page_877" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Add 1 year.</span></code>
<code class="calibre21">year_month_day t7_ymd { t5_ymd + years { 1 } };</code>
<code class="calibre21"><span class="color">// Convert back to a serial type.</span></code>
<code class="calibre21">auto t7 { sys_days { t7_ymd } + t5_seconds };</code>
<code class="calibre21">println("t7 = {:L}", t7);</code></pre>
      <p class="calibre13">
       This results in:
      </p>
      <pre class="calibre26" id="c22-code-0060"><code class="calibre21">t7 = 2021-06-22 <b class="calibre14">09:35:10</b></code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-232" class="calibre2">
     <span class="calibre" id="c22-sec-0020">
     </span>
     <h2 class="calibre6" id="head-2-232">
      TIME ZONE
     </h2>
     <p class="calibre13" id="c22-para-0107">
      To facilitate working with time zones, the C++ Standard Library contains a copy of the Internet Assigned Numbers Authority (IANA) time zone database (
      <code class="calibre21">
       <a class="calibre5" href="http://www.iana.org/time-zones">
        www.iana.org/time-zones
       </a>
      </code>
      ). You can get access to this database by calling
      <code class="calibre21">
       std::chrono::get_tzdb()
      </code>
      , which returns a reference-to-
      <code class="calibre21">
       const
      </code>
      to a single existing instance of type
      <code class="calibre21">
       std::chrono::tzdb
      </code>
      . This database gives access to all known time zones through a public
      <code class="calibre21">
       vector
      </code>
      called
      <code class="calibre21">
       zones
      </code>
      . Each entry in this
      <code class="calibre21">
       vector
      </code>
      is a
      <code class="calibre21">
       time_zone
      </code>
      , which has a name, accessible with
      <code class="calibre21">
       name()
      </code>
      , and member functions
      <code class="calibre21">
       to_sys()
      </code>
      and
      <code class="calibre21">
       to_local()
      </code>
      to convert a
      <code class="calibre21">
       local_time
      </code>
      to a
      <code class="calibre21">
       sys_time
      </code>
      , and vice versa. Due to daylight saving time, it could be that a conversion from
      <code class="calibre21">
       local_time
      </code>
      to
      <code class="calibre21">
       sys_time
      </code>
      is either ambiguous or nonexistent. In such cases, the conversion throws an exception of type
      <code class="calibre21">
       ambiguous_local_time
      </code>
      or
      <code class="calibre21">
       nonexistent_local_time
      </code>
      , respectively.
     </p>
     <p class="calibre13">
      Here is a code snippet listing all available time zones:
     </p>
     <pre class="calibre26" id="c22-code-0061"><code class="calibre21">const auto&amp; database { get_tzdb() };</code>
<code class="calibre21">for (const auto&amp; timezone : database.zones) {</code>
<code class="calibre21">    println("{}", timezone.name());</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      The
      <code class="calibre21">
       std::chrono::locate_zone()
      </code>
      function can be used to retrieve a
      <code class="calibre21">
       time_zone
      </code>
      based on its name and throws a
      <code class="calibre21">
       runtime_error
      </code>
      exception if the requested time zone cannot be found in the database. The
      <code class="calibre21">
       current_zone()
      </code>
      function can be used to get the current time zone. For example:
     </p>
     <pre class="calibre26" id="c22-code-0062"><code class="calibre21">auto* brussels { locate_zone("Europe/Brussels") };</code>
<code class="calibre21">auto* gmt { locate_zone("GMT") };</code>
<code class="calibre21">auto* current { current_zone() };</code></pre>
     <p class="calibre13">
      <code class="calibre21">
       time_zone
      </code>
      instances can be used to convert times between different zones:
     </p>
     <pre class="calibre26" id="c22-code-0063"><code class="calibre21"><span class="color">// Convert current time (UTC), to time in Brussels, and time in current zone.</span></code>
<code class="calibre21">auto nowUTC { system_clock::now() };                 <span class="color">// In UTC.</span></code>
<code class="calibre21">auto nowInBrussels { brussels-&gt;to_local(nowUTC) };   <span class="color">// In Brussels' time zone.</span></code>
<code class="calibre21">auto nowInCurrentZone { current-&gt;to_local(nowUTC) }; <span class="color">// In current time zone.</span></code>
<code class="calibre21">println("Now UTC:        {:L%c}", nowUTC);</code>
<code class="calibre21">println("Now Brussels:   {:L%c}", nowInBrussels);</code>
<code class="calibre21">println("Now in current: {:L%c}", nowInCurrentZone);</code>
<code class="calibre21"></code>
<code class="calibre21"><span class="color">// Construct a UTC time. (2020-06-22 09:35:10 UTC)</span></code>
<code class="calibre21">auto t { sys_days { 2020y / June / 22d } + 9h + 35min + 10s };</code>
<code class="calibre21"><span class="color">// Convert UTC time to Brussels' local time.</span></code>
<code class="calibre21">auto converted { brussels-&gt;to_local(t) };</code>
<code class="calibre21">println("Converted: {:L}", converted);</code></pre>
     <p class="calibre13">
      The
      <code class="calibre21">
       zoned_time
      </code>
      class is used to represent a
      <code class="calibre21">
       time_point
      </code>
      in a specific
      <code class="calibre21">
       time_zone
      </code>
      . The following snippet constructs a specific time in the Brussels' time zone and then converts it to New York time:
     </p>
     <pre class="calibre26" id="c22-code-0064"><span aria-label="878" class="calibre20" epub:type="pagebreak" id="Page_878" role="doc-pagebreak"></span><code class="calibre21"><span class="color">// Construct a local time in the Brussels' time zone.</span></code>
<code class="calibre21">zoned_time&lt;hours&gt; brusselsTime{ brussels, local_days { 2020y / June / 22d } + 9h };</code>
<code class="calibre21"><span class="color">// Convert to New York time.</span></code>
<code class="calibre21">zoned_time&lt;hours&gt; newYorkTime { "America/New_York", brusselsTime };</code>
<code class="calibre21">println("Brussels: {:L}", brusselsTime.get_local_time());</code>
<code class="calibre21">println("New York: {:L}", newYorkTime.get_local_time());</code></pre>
    </section>
    <section aria-labelledby="head-2-233" class="calibre2">
     <span class="calibre" id="c22-sec-0021">
     </span>
     <h2 class="calibre6" id="head-2-233">
      SUMMARY
     </h2>
     <p class="calibre13" id="c22-para-0112">
      This chapter discussed how to use the
      <code class="calibre21">
       ratio
      </code>
      class template to define and work with compile-time rational numbers. You also learned how to work with durations, clocks, time points, dates, and time zones provided by the C++ Standard Library through the chrono library.
     </p>
     <p class="calibre13" id="c22-para-0113">
      The next chapter focusses on the functionality provided by the Standard Library to generate random numbers.
     </p>
    </section>
    <section aria-labelledby="head-2-234" class="calibre2">
     <span class="calibre" id="c22-sec-0022">
     </span>
     <h2 class="calibre6" id="head-2-234">
      EXERCISES
     </h2>
     <p class="calibre13" id="c22-para-0114">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c22-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c22-ex-0001">
        <b class="calibre14">
         Exercise 22-1:
        </b>
        Let's play a bit with durations. Create a duration,
        <code class="calibre21">
         d1
        </code>
        , with a precision of seconds, initialized to 42 seconds. Create a second duration,
        <code class="calibre21">
         d2
        </code>
        , with a precision of minutes, initialized to 1.5 minutes. Calculate the sum of
        <code class="calibre21">
         d1
        </code>
        and
        <code class="calibre21">
         d2
        </code>
        . Write out the result to the standard output, once expressed in seconds, once expressed in minutes.
       </li>
       <li class="calibre9" id="c22-ex-0002">
        <b class="calibre14">
         Exercise 22-2:
        </b>
        Ask the user to enter a date as yyyy-mm-dd, for example, 2020-06-22. Use a regular expression (see
        <a class="calibre5" href="c21.xhtml">
         Chapter 21
        </a>
        ) to extract the year, month, and day components, and finally, use
        <code class="calibre21">
         year_month_day
        </code>
        to validate the date.
       </li>
       <li class="calibre9" id="c22-ex-0003">
        <b class="calibre14">
         Exercise 22-3:
        </b>
        Write a
        <code class="calibre21">
         getNumberOfDaysBetweenDates()
        </code>
        function that calculates the number of days between two given dates. Test your implementation in your
        <code class="calibre21">
         main()
        </code>
        function.
       </li>
       <li class="calibre9" id="c22-ex-0004">
        <b class="calibre14">
         Exercise 22-4:
        </b>
        Write a program that prints out the day of the week of June 22, 2020.
       </li>
       <li class="calibre9" id="c22-ex-0005">
        <b class="calibre14">
         Exercise 22-5:
        </b>
        Construct a UTC time. Convert this time to the local time in Tokyo, Japan. Further convert the resulting time to New York time. And finally convert the resulting time to GMT. Verify that the original UTC time and the final GMT time are equal. Tip: The time zone identifier for Tokyo is Asia/Tokyo, for New York it is America/New_York, and for GMT it is GMT.
       </li>
       <li class="calibre9" id="c22-ex-0006">
        <b class="calibre14">
         Exercise 22-6:
        </b>
        Write a
        <code class="calibre21">
         getDurationSinceMidnight()
        </code>
        function that returns the duration between midnight and the current local time in seconds. Use your function to print out the number of seconds since midnight to the standard output console. Finally, use the
        <code class="calibre21">
         hh_mm_ss
        </code>
        class to convert the duration returned by your function to hours, minutes, and seconds, and print the result on standard output.
       </li>
      </ol>
     </section>
    </section>
   </section>
  </div>
 </body>
</html>
