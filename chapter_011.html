<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   2: Qualities
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_010.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_012.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="25" epub:type="pagebreak" id="pagebreak_25" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0002" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000143">
      2: Qualities
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         This chapter describes the set of language-neutral qualities that define a good application programming interface (API). This includes providing a good abstraction for the problem being solved, which is illustrated with reference to a simple address book program. A good API must also hide implementation details through a combination of physical and logical hiding techniques. The quality of minimal completeness means that an API should be as small as feasible but no smaller. An API should also be easy to use, which includes facets such as being discoverable, difficult to misuse, consistent, orthogonal, and platform independent, and making appropriate use of smart pointers such as shared pointers, weak pointers, and unique pointers. Being loosely coupled is important for robust API designs. The term coupling is defined, and several strategies to reduce coupling are explained. Finally, a good API should offer a stable interface that's well-documented and includes broad automated test coverage.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Abstraction; Declaration; Definition; Ease of use; Encapsulation; Logical hiding; Loose coupling; Minimal completeness; Object model; Physical hiding; Redundancy
      </div>
     </section>
     <section>
      <p class="textfl" id="p0010">
       This chapter aims to answer the question, what are the basic qualities of a good application programming interface (API)? Most developers would agree that a good API should be elegantly designed but still highly usable. It should be a joy to use but also fade into the background (
       <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib38" id="bib_38">
        Henning, 2009
       </a>
       ). These are fine qualitative statements, but what are the specific design aspects that enable these? Obviously, every API is different. However, there are certain qualities that promote high-quality API design and should be adhered to whenever possible, as well as many that make for poor designs and should be avoided.
      </p>
      <p class="text" id="p0015">
       There are no absolutes in API design: you cannot apply a fixed set of rules to every situation. However, while there may be individual cases where you decide to deviate from certain advice in this chapter, you should do so only after reasoned and considered judgment. The guidance here should form the bedrock of your API design decisions.
      </p>
      <p class="text" id="p0020">
       In this chapter, I will concentrate on generic, language-neutral qualities of an API, such as information hiding, consistency, and loose coupling. I will provide a C++ context for each of these concepts, but overall, the advice in this chapter should be useful to you whether you are working on a C++, Java, C#, or Python project. In later chapters, I will deal with C++ specific issues, such as const correctness, namespaces, and constructor usage.
      </p>
      <p class="text" id="p0025">
       Many of the topics in this chapter also provide a jumping-off point into deeper treatments later in the book. For example, whereas I mention the use of the Pimpl idiom as a solution for hiding internal details in C++, I dedicate more space to this important topic in the following chapter on design patterns.
      </p>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        Model the problem domain
       </h2>
       <p class="textfl" id="p0030">
        An API is written to solve a particular problem or perform a specific task. So, first and foremost, the API should provide a coherent solution for that problem, and it should be formulated in a way that models the actual domain of the problem. For example, it should provide a good abstraction of the problem area and it should model the key objects of that domain. Doing so can make the API easier for your users to employ and understand because it will more closely correlate with their preexisting knowledge and expectations.
       </p>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         Provide a good abstraction
        </h3>
        <p class="textfl" id="p0035">
         An API should provide a logical abstraction for the problem that it solves. That is, it should be formulated in terms of high-level concepts that make sense in the chosen
         <a id="p26">
         </a>
         <span aria-label="26" epub:type="pagebreak" id="pagebreak_26" role="doc-pagebreak">
         </span>
         problem domain, rather than exposing low-level implementation issues. You should be able to give your API documentation to a nonprogrammer, and that person should be able to understand the concepts of the interface and how it's meant to work.
        </p>
        <p class="text" id="p0040">
         Furthermore, it should be apparent to the nontechnical reader that the group of operations provided by the API makes sense and belongs together as a unit. Each class should have a central purpose, and that should be reflected in the name of the class and its methods. In fact, it's good practice to have another person review your API early on to make sure that it presents a logical interface to fresh eyes.
        </p>
        <p class="text" id="p0045">
         Coming up with a good abstraction is no simple task. I dedicate most of
         <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
          Chapter 4
         </a>
         to this complex topic. However, it should be noted that there is no single correct abstraction for any given problem. Most APIs can be modeled in several different ways, each of which may provide a good abstraction and a useful interface. The key point is that there is some consistent and logical underpinning to your API.
        </p>
        <p class="text" id="p0050">
         For example, let's consider an API for a simple address book program. Conceptually, an address book is a container for the details of multiple people. It seems logical, then, that our API should provide an
         <span class="inlinecode">
          AddressBook
         </span>
         object that contains a collection of
         <span class="inlinecode">
          Person
         </span>
         objects, where a
         <span class="inlinecode">
          Person
         </span>
         object describes the name and address of a single contact. Furthermore, you want to be able to perform operations such as adding a person to the address book or removing them. These are operations that update the state of the address book, and so logically they should be part of the
         <span class="inlinecode">
          AddressBook
         </span>
         object. This initial design can be represented visually using a notation called Unified Modeling Language (UML).
        </p>
        <p class="text" id="p0055">
         If you're not familiar with UML,
         <a href="#f0010" id="Bf0010">
          Fig. 2.1
         </a>
         shows an
         <span class="inlinecode">
          AddressBook
         </span>
         object that contains a one-to-many composition of
         <span class="inlinecode">
          Person
         </span>
         objects as well as two operations,
         <span class="inlinecode">
          AddPerson()
         </span>
         and
         <span class="inlinecode">
          DeletePerson()
         </span>
         . The
         <span class="inlinecode">
          Person
         </span>
         object contains a set of public attributes to describe a single person's name and address. I will refine this design in a moment, but for now it serves as an initial logical abstraction of the problem domain.
         <a id="p27">
         </a>
         <span aria-label="27" epub:type="pagebreak" id="pagebreak_27" role="doc-pagebreak">
         </span>
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0010">
          <img alt="image" height="840" src="../../IMAGES/B9780443222191000143/main.assets/f02-01-9780443222191.jpg" width="2333"/>
          <figcaption class="figleg">
           <a id="cap0010">
           </a>
           <a id="fspara0010">
           </a>
           <span class="fignum">
            <a href="#Bf0010">
             Figure 2.1
            </a>
           </span>
           High-level Unified Modeling Language abstraction of an address book application programming interface.
          </figcaption>
         </figure>
        </div>
        <div>
         <aside aria-labelledby="b0010" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0010">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0015">
            <i>
             SIDEBAR: Unified Modeling Language class diagrams
            </i>
           </div>
           <div class="b1textfl" id="bpar0010">
            <i>
             The UML specification defines a collection of visual notations to model object-oriented software systems
            </i>
            (
            <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib13" id="bib_13">
             Booch et al., 2005
            </a>
            )
            <i>
             . In this book, I will often use the UML class diagram to depict class designs, as in
            </i>
            <a href="#f0010">
             Fig. 2.1
            </a>
            <i>
             . In these diagrams, a single class is represented with a box that is segmented into three parts:
            </i>
           </div>
           <div>
            <ul class="ce_list" id="olist0010">
             <li class="b1numlist" id="bpar0015">
              <a id="o0010">
              </a>
              1.
              <i>
               The upper section contains the class name.
              </i>
             </li>
             <li class="b1numlist" id="bpar0020">
              <a id="o0015">
              </a>
              2.
              <i>
               The middle section lists the attributes of the class.
              </i>
             </li>
             <li class="b1numlist" id="bpar0025">
              <a id="o0020">
              </a>
              3.
              <i>
               The lower section enumerates the methods of the class.
              </i>
             </li>
            </ul>
           </div>
           <div class="b1text" id="bpar0030">
            <i>
             Each of the entries in the middle and lower sections of the class box can be prefixed with a symbol to indicate the access level, or visibility, for that attribute or method
            </i>
            :
           </div>
           <div>
            <ul id="ulist0010">
             <li class="b1unnumlist" id="bpar0035">
              <a id="u0010">
              </a>
              <i>
               + indicates a public class member.
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0040">
              <a id="u0015">
              </a>
              <i>
               – indicates a private class member.
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0045">
              <a id="u0020">
              </a>
              <i>
               # indicates a protected class member.
              </i>
             </li>
            </ul>
           </div>
           <div class="b1text" id="bpar0050">
            <i>
             Relationships between classes are illustrated with various styles of connecting lines and arrowheads. Some of the common relationships that are possible in a UML class diagram are:
            </i>
           </div>
           <div>
            <ul id="ulist0015">
             <li class="b1unnumlist" id="bpar0055">
              <a id="u0025">
              </a>
              <b>
               <i>
                Association
               </i>
              </b>
              <i>
               : A simple dependency between two classes in which neither owns the other, shown as a solid line. Association can be directional, indicated with an open arrowhead as &gt;.
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0060">
              <a id="u0030">
              </a>
              <b>
               <i>
                Aggregation
               </i>
              </b>
              <i>
               : A has-a, or whole/part, relationship in which neither class owns the other, shown as a line with a hollow diamond.
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0065">
              <a id="u0035">
              </a>
              <b>
               <i>
                Composition
               </i>
              </b>
              <i>
               : A has-a relationship in which the lifetime of the part is managed by the whole. This is represented as a line with a filled diamond.
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0070">
              <a id="u0040">
              </a>
              <b>
               <i>
                Generalization
               </i>
              </b>
              <i>
               : A subclass relationship between classes, shown as a line with a hollow triangle arrowhead.
              </i>
             </li>
            </ul>
           </div>
           <div class="b1text" id="bpar0075">
            <i>
             Each side of a relationship can also be annotated to define its multiplicity. This lets you specify whether the relationship is one-to-one, one-to-many, or many-to-many. Some common multiplicities include:
            </i>
           </div>
           <div>
            <ul id="ulist0020">
             <li class="b1unnumlist" id="bpar0080">
              <a id="u0045">
              </a>
              <i>
               0..1
               <span title='hsp="0.25"'>
               </span>
               =
               <span title='hsp="0.25"'>
               </span>
               Zero or one instances
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0085">
              <a id="u0050">
              </a>
              <i>
               1
               <span title='hsp="0.25"'>
               </span>
               =
               <span title='hsp="0.25"'>
               </span>
               Exactly one instance
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0090">
              <a id="u0055">
              </a>
              <i>
               0..∗
               <span title='hsp="0.25"'>
               </span>
               =
               <span title='hsp="0.25"'>
               </span>
               Zero or more instances
              </i>
             </li>
             <li class="b1unnumlist" id="bpar0095">
              <a id="u0060">
              </a>
              <i>
               1..∗
               <span title='hsp="0.25"'>
               </span>
               =
               <span title='hsp="0.25"'>
               </span>
               One or more instances
              </i>
             </li>
            </ul>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Model the key objects
        </h3>
        <p class="textfl" id="p0060">
         An API should also model the key objects for the problem domain. This process is often called object-oriented design or object modeling because it aims to describe the hierarchy of objects in the specific problem domain. The goal of object modeling is to identify the collection of major objects, the operations they provide, and how they relate to each other.
         <a id="p28">
         </a>
        </p>
        <div>
         <span aria-label="28" epub:type="pagebreak" id="pagebreak_28" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0065">
         Once again, there is no single correct object model for a given problem domain. Instead, the task of creating an object model should be driven by the specific requirements for the API. Different demands on an API may require a different object model to represent those demands most effectively. For example, continuing our address book example, let's assume that we've received the following requirements for our API:
        </p>
        <div>
         <ul class="ce_list" id="olist0015">
          <li class="numlist" id="p0070">
           <a id="o0025">
           </a>
           1. Each person may have multiple addresses.
          </li>
          <li class="numlist" id="p0075">
           <a id="o0030">
           </a>
           2. Each person may have multiple telephone numbers.
          </li>
          <li class="numlist" id="p0080">
           <a id="o0035">
           </a>
           3. Telephone numbers can be validated and formatted.
          </li>
          <li class="numlist" id="p0085">
           <a id="o0040">
           </a>
           4. An address book may contain multiple people with the same name.
          </li>
          <li class="numlist" id="p0090">
           <a id="o0045">
           </a>
           5. An existing address book entry can be modified.
          </li>
         </ul>
        </div>
        <p class="text" id="p0095">
         These requirements will have a large impact on the object model for the API. Our original design in
         <a href="#f0010">
          Fig. 2.1
         </a>
         supports only a single address per person. To support more than one address, you could add extra fields to the
         <span class="inlinecode">
          Person
         </span>
         object (e.g.,
         <span class="inlinecode">
          HomeAddress1
         </span>
         ,
         <span class="inlinecode">
          WorkAddress1
         </span>
         ), but this would be a brittle and inelegant solution. Instead, you could introduce an object to represent an address (e.g.,
         <span class="inlinecode">
          Address
         </span>
         ) and allow a
         <span class="inlinecode">
          Person
         </span>
         object to contain multiples of these.
        </p>
        <p class="text" id="p0100">
         The same is true of telephone numbers: you can factor these into their own object (e.g.,
         <span class="inlinecode">
          TelephoneNumber
         </span>
         ) and allow the
         <span class="inlinecode">
          Person
         </span>
         object to hold multiple of these. Another reason to create an independent
         <span class="inlinecode">
          TelephoneNumber
         </span>
         object is that we need to support operations such as
         <span class="inlinecode">
          IsValid()
         </span>
         , to validate a number, and
         <span class="inlinecode">
          GetFormattedNumber()
         </span>
         , to return a nicely formatted version of the number. These are operations that naturally operate on a telephone number, not a person, which suggests that telephone numbers should be represented by their own first-class objects.
        </p>
        <p class="text" id="p0105">
         The requirement that multiple
         <span class="inlinecode">
          Person
         </span>
         objects may hold the same name essentially means that a person's name cannot be used to identify a unique instance of the
         <span class="inlinecode">
          Person
         </span>
         object. You therefore need some way to identify a unique
         <span class="inlinecode">
          Person
         </span>
         instance (e.g., so that you can locate and update an existing entry in the address book). One way to satisfy this requirement would simply be to generate a universally unique identifier (UUID) for each person. Putting all this together, you might conclude that the key objects for our address book API are:
        </p>
        <div>
         <ol id="ulist0025">
          <li class="bulllist" id="p0110">
           <a id="u0065">
           </a>
           ▪
           <b>
            Address Book
           </b>
           : Contains zero of more
           <span class="inlinecode">
            Person
           </span>
           objects, with operations such as
           <span class="inlinecode">
            AddPerson()
           </span>
           ,
           <span class="inlinecode">
            DeletePerson()
           </span>
           , and
           <span class="inlinecode">
            UpdatePerson()
           </span>
           .
          </li>
          <li class="bulllist" id="p0115">
           <a id="u0070">
           </a>
           ▪
           <b>
            Person
           </b>
           : Fully describes the details for a single person, including zero or more addresses and telephone numbers. Each person is differentiated by a UUID.
          </li>
          <li class="bulllist" id="p0120">
           <a id="u0075">
           </a>
           ▪
           <b>
            Address
           </b>
           : Describes a single address, including an address type field such as Home or Work.
          </li>
          <li class="bulllist" id="p0125">
           <a id="u0080">
           </a>
           ▪
           <b>
            TelephoneNumber
           </b>
           : Describes a single telephone number, including a phone type field such as Home or Cell. This object supports operations such as
           <span class="inlinecode">
            IsValid()
           </span>
           and
           <span class="inlinecode">
            GetFormattedNumber()
           </span>
           .
          </li>
         </ol>
        </div>
        <p class="text" id="p0130">
         This updated object model can be represented again as a UML diagram, as shown in
         <a href="#f0015" id="Bf0015">
          Fig. 2.2
         </a>
         .
         <a id="p29">
         </a>
        </p>
        <div>
         <span aria-label="29" epub:type="pagebreak" id="pagebreak_29" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0015">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="1002" src="../../IMAGES/B9780443222191000143/main.assets/f02-02-9780443222191.jpg" width="2751"/>
           <figcaption class="figleg">
            <a id="cap0015">
            </a>
            <a id="fspara0015">
            </a>
            <span class="fignum">
             <a href="#Bf0015">
              Figure 2.2
             </a>
            </span>
            Unified Modeling Language diagram of the key objects in our address book application programming interface.
            <a id="fspara0020">
            </a>
            <i>
             UUID
            </i>
            , universally unique identifier.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0135">
         It's important to note that the object model for an API may need to change over time. As new requirements are received, or new functionality is added, the optimal breakdown of classes and methods to meet those needs may change. It's therefore always wise to reevaluate your object model in the light of new requirements, to assess whether your object model would benefit from a redesign, too. For example, you may anticipate the need for international addresses and decide to create a more general
         <span class="inlinecode">
          Address
         </span>
         object to handle this capability. However, don't go over the top and try to create an object model that is more general than you need. Make sure you read the upcoming section on being minimally complete, too!
        </p>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Solve the core problems
        </h3>
        <p class="textfl" id="p0140">
         The main reason to develop an API is to solve some related set of problems. So, it must be clear to your users how they can apply your design to achieve that goal. We just saw how you can model the key objects for your problem domain, but the users of your API also need to know how to create those objects and how to call the methods on those objects to complete their tasks.
        </p>
        <p class="text" id="p0145">
         I introduced the concept of the UML class diagram earlier to show the relationships among different objects. Another UML diagram type is the sequence diagram. This shows the sequential interactions between objects that produce some desired output. In other words, it can show how your design can be used to achieve certain goals. For example, in the address book design described previously, I introduced objects for
         <span class="inlinecode">
          AddressBook
         </span>
         ,
         <span class="inlinecode">
          Person
         </span>
         , and
         <span class="inlinecode">
          TelephoneNumber
         </span>
         . But how would a client use these to change the type of a person's telephone number from a personal to a work number?
         <a href="#f0020" id="Bf0020">
          Fig. 2.3
         </a>
         presents one possible sequence diagram to show how you could do this.
        </p>
        <p class="text" id="p0150">
         A sequence diagram represents the set of objects from left to right across the top of the diagram. The first message typically starts at the top left of the diagram, such as
         <span class="inlinecode">
          AddressBook::GetInstance()
         </span>
         in our example. Each subsequent message appears below the
         <a id="p30">
         </a>
         <span aria-label="30" epub:type="pagebreak" id="pagebreak_30" role="doc-pagebreak">
         </span>
         previous one. An object that sends a message to another object is shown as a solid line and arrowhead (or an open arrowhead for an asynchronous message) and a return result is shown with a dotted line and open arrowhead.
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0020">
          <img alt="image" height="1505" src="../../IMAGES/B9780443222191000143/main.assets/f02-03-9780443222191.jpg" width="2652"/>
          <figcaption class="figleg">
           <a id="cap0020">
           </a>
           <a id="fspara0025">
           </a>
           <span class="fignum">
            <a href="#Bf0020">
             Figure 2.3
            </a>
           </span>
           Unified Modeling Language sequence diagram to change a telephone number type.
          </figcaption>
         </figure>
        </div>
        <p class="text" id="p0155">
         So,
         <a href="#f0020">
          Fig. 2.3
         </a>
         starts with a call to
         <span class="inlinecode">
          AddressBook::GetInstance()
         </span>
         to get an instance of the address book. Then you would call an
         <span class="inlinecode">
          AddressBook::FindPerson()
         </span>
         method to find a specific person. You can then call
         <span class="inlinecode">
          GetTelephoneNumber()
         </span>
         on that
         <span class="inlinecode">
          Person
         </span>
         object to get the personal telephone number (we'll assume there's only one, to keep the example simple). And then you can call a
         <span class="inlinecode">
          SetType()
         </span>
         method on the telephone number to set it to a work phone number type. With this information, we can see that we need to add some new functions to our objects to support this use case. This lets us build out our API to ensure it solves the core tasks for the problem domain.
        </p>
        <p class="text" id="p0160">
         As an aside, there are several tools that let you create these UML class and sequence diagrams. For example, I used the Mermaid charting tool at
         <a href="https://mermaid.js.org/">
          https://mermaid.js.org/
         </a>
         to create the sequence diagram in
         <a href="#f0020">
          Fig. 2.3
         </a>
         using the following Markdown description:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000143/main.assets/u02-01-9780443222191.jpg" width="2080"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p31">
         </a>
        </p>
        <div>
         <span aria-label="31" epub:type="pagebreak" id="pagebreak_31" role="doc-pagebreak">
         </span>
        </div>
       </section>
      </section>
      <section>
       <a id="s0030">
       </a>
       <h2 class="h1hd" id="cesectitle0040">
        Hide implementation details
       </h2>
       <p class="textfl" id="p0165">
        The primary reason for creating an API is to hide any implementation details so that these can be changed later without affecting existing clients. Therefore, the most important quality of an API is that it actually achieves this purpose. That is, any internal details—those parts that are most likely to change—must be kept secret from the client of the API. David L. Parnas referred to this concept as information hiding (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib75" id="bib_75">
         Parnas, 1972
        </a>
        ).
       </p>
       <p class="text" id="p0170">
        There are two main categories of techniques relating to this goal: physical and logical hiding. Physical hiding means that the private source code is simply not made available to users. Logical hiding entails the use of language features to limit access to certain elements of the API.
       </p>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         Physical hiding: Declaration versus definition
        </h3>
        <p class="textfl" id="p0175">
         In C and C++, the words declaration and definition are precise terms with very specific meanings. A declaration simply introduces a name and its type to the compiler without allocating any memory for it. In contrast, a definition provides details of a type's structure, or allocates memory in the case of variables. (The term function prototype, as used by C programmers, is equivalent to the term function declaration.) For example, the following are all declarations:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000143/main.assets/u02-02-9780443222191.jpg" width="796"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0180">
         whereas the following are all definitions:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000143/main.assets/u02-03-9780443222191.jpg" width="1318"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0015" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0015">
           <div class="b1textfl" id="bpar0100">
            <i>
             TIP: A declaration introduces the name and type of a symbol to the compiler. A definition provides the full details for that symbol, be it a function body or a region of memory.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p32">
         </a>
        </p>
        <div>
         <span aria-label="32" epub:type="pagebreak" id="pagebreak_32" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0185">
         In terms of classes and methods, the following code introduces a class definition with a single method declaration:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0060">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000143/main.assets/u02-04-9780443222191.jpg" width="692"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0190">
         The implementation (body) of a method is provided in its definition:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0065">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000143/main.assets/u02-05-9780443222191.jpg" width="1457"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0195">
         Generally speaking, you provide declarations in your
         <span class="inlinecode">
          .h
         </span>
         files and the associated definitions in your
         <span class="inlinecode">
          .cpp
         </span>
         files. However, it's also possible to provide a definition for a method at the point where you declare it in a
         <span class="inlinecode">
          .h
         </span>
         file, e.g.,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0070">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000143/main.assets/u02-06-9780443222191.jpg" width="1596"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0200">
         This technique implicitly requests the compiler to inline the
         <span class="inlinecode">
          MyMethod()
         </span>
         member function at all points where it's called. In terms of API design, this is therefore a bad practice because it exposes the code for how the method has been implemented and directly inlines the code into your clients' programs. You should therefore strive to limit your API headers to provide only declarations. In later chapters, I will discuss exceptions to this rule to support templates and conscious acts of inlining.
        </p>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <div class="b1textfl" id="bpar0105">
            <i>
             TIP: Physical hiding means storing internal details in a separate file (.cpp) from the public interface (.h).
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0205">
         Note that I will sometimes inline function implementations like this in the code examples of this book. However, this is done solely for the purposes of clarity and simplicity and should be avoided for any real-world APIs that you develop.
         <a id="p33">
         </a>
        </p>
        <div>
         <span aria-label="33" epub:type="pagebreak" id="pagebreak_33" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0025">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0025">
           <img alt="image" height="1179" src="../../IMAGES/B9780443222191000143/main.assets/f02-04-9780443222191.jpg" width="2265"/>
           <figcaption class="figleg">
            <a id="cap0025">
            </a>
            <a id="fspara0030">
            </a>
            <span class="fignum">
             <a href="#Bf0025">
              Figure 2.4
             </a>
            </span>
            The three access levels for C++ classes.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0210">
         In the later chapter on C++ Revisions, I will cover the concept of modules, which was introduced in C++20. This feature provides an alternative to the use of header files. However, you can still perform physical hiding with modules by putting your declarations in your module interface unit and definitions in your module implementation unit.
        </p>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         Logical hiding: Encapsulation
        </h3>
        <p class="textfl" id="p0215">
         The object-oriented concept of encapsulation provides a mechanism for limiting the access to members of an object. In C++, this is implemented using the following access control keywords for classes and structs (classes and structs are functionally equivalent, differing only in their default access level). These access levels are illustrated in
         <a href="#f0025" id="Bf0025">
          Fig. 2.4
         </a>
         .
        </p>
        <div>
         <ol id="ulist0030">
          <li class="bulllist" id="p0220">
           <a id="u0085">
           </a>
           •
           <b>
            Public
           </b>
           : Members are accessible outside the class/struct. This is the default access level for structs.
          </li>
          <li class="bulllist" id="p0225">
           <a id="u0090">
           </a>
           •
           <b>
            Private
           </b>
           : Members are accessible only within the specific class in which they are defined. This is the default access level for classes.
          </li>
          <li class="bulllist" id="p0230">
           <a id="u0095">
           </a>
           •
           <b>
            Protected
           </b>
           : Members are accessible only within the specific class and any derived classes.
          </li>
         </ol>
        </div>
        <div>
         <aside aria-labelledby="b0025" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0025">
           <p>
           </p>
           <div class="b1title" epub:type="title" id="title0020">
            <i>
             SIDEBAR: Encapsulation in other languages
            </i>
           </div>
           <div class="b1textfl" id="bpar0110">
            <i>
             Whereas C++ provides the public, private, and protected access controls for your class members, other object-oriented languages provide different levels of granularity. For example, in the Smalltalk language all instance variables are private and all methods are public, whereas the Java language provides public, private, protected, and package-private levels of visibility.
            </i>
           </div>
           <div class="b1text" id="bpar0115">
            <i>
             Package-private in Java means that a member can be accessed only by classes within the same package. This is the default visibility in Java. Package-private is a great way to allow other classes in a JAR (Java Archive) file to access internal members without exposing them globally to your clients. For example, it's particularly useful for unit tests that need to verify the behavior of private methods.
            </i>
           </div>
           <div class="b1text" id="bpar0120">
            <i>
             C++ does not have the concept of package-private visibility. Instead, it uses the more permissive notion of friendship to allow named classes and functions to access protected and private members of a class. Friendship can be used to enhance encapsulation, but if used carelessly it can also overexpose internal details to your clients.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p34">
         </a>
        </p>
        <div>
         <span aria-label="34" epub:type="pagebreak" id="pagebreak_34" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0235">
         Most likely, your users will not care about respecting your public API boundary. If you give them hooks into your internal workings that let them achieve what they want, they will use them to get their job done. Although this may appear to be good for them, because they were able to find a solution to their immediate problem, it may make it more difficult for you to change those implementation details in the future and so stifle your ability to improve and optimize your product.
        </p>
        <div>
         <aside aria-labelledby="b0030" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0030">
           <div class="b1textfl" id="bpar0125">
            <i>
             TIP: Encapsulation is the process of separating the public interface of an API from its underlying implementation.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0240">
         As an example of the lengths to which some users will go, the multiplayer first-person shooter game Counter-Strike has been a popular target for exploitation hacks since it appeared in around 2000. One of the most well-known of these is the wallhack. This is essentially a modified OpenGL driver that renders walls partially or fully transparent. This gives players the clear advantage that they can literally see through walls. Although you may not be creating a game or targeting gamers as your clients, the moral is that users will do whatever they can to get what they want. If some users will modify OpenGL graphics drivers to give them an advantage in a game, there are presumably others who will use your API's exposed internal details so that they can deliver the functionality that their boss has requested.
        </p>
        <p class="text" id="p0245">
         To illustrate this with a more directly applicable example, Roland Faber reports some of the difficulties that occurred at Siemens when one group decided to rely upon the internal details of an API from another group in the same company (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib28" id="bib_28">
          Faber, 2010
         </a>
         ):
        </p>
        <div>
         <div id="disp0010">
          <p class="quote" epub:type="epigraph" id="p1325" role="doc-epigraph">
           A team outside of Europe had to provide a remote control for a user interface implemented in Germany. Because the automation interface was incomplete, they decided to use internal interfaces instead without notifying the architects. The system integration suffered from unexpected problems due to uncoordinated interface changes, and costly refactoring was unavoidable.
          </p>
         </div>
        </div>
        <p class="textfl">
         <a id="p35">
         </a>
        </p>
        <div>
         <span aria-label="35" epub:type="pagebreak" id="pagebreak_35" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0250">
         The following sections will therefore discuss how to use the access control features of your programming language to provide the maximum level of information hiding for your APIs. The later chapter on C++ Usage also points out some cases in which certain C++ language features can affect encapsulation, such as friends and external linkage.
        </p>
        <div>
         <aside aria-labelledby="b0035" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0035">
           <div class="b1textfl" id="bpar0130">
            <i>
             TIP: Logical hiding means using the C++ language features of protected and private to restrict access to internal details.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0045">
        </a>
        <h3 class="h2hd" id="cesectitle0055">
         Hide member variables
        </h3>
        <p class="textfl" id="p0255">
         The term encapsulation is also often used to describe the bundling of data with the methods that operate on those data. This is implemented in C++ by having classes that can contain both variables and methods. However, in terms of good API design, you should never make member variables public. If the data members form part of the logical interface of the API, then you should instead provide getter and/or setter methods that provide indirect access to the member variables. For example, you should avoid writing:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0075">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000143/main.assets/u02-07-9780443222191.jpg" width="658"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0260">
         Instead, you should prefer:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0080">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000143/main.assets/u02-08-9780443222191.jpg" width="900"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0265">
         The latter syntax is obviously more verbose and involves more typing on your part as the programmer, but the extra few minutes spent doing this could save you hours, or even days further down the line should you decide to change the interface. Some of the additional benefits of using getter/setter routines, rather than directly exposing member variables, include:
        </p>
        <div>
         <ol id="ulist0035">
          <li class="bulllist" id="p0270">
           <a id="u0100">
           </a>
           ▪
           <b>
            Validation.
           </b>
           You can perform validation on the values to ensure that the internal state of the class is always valid and consistent. For example, if you have a method
           <a id="p36">
           </a>
           <span aria-label="36" epub:type="pagebreak" id="pagebreak_36" role="doc-pagebreak">
           </span>
           that lets clients set a new RGB color, you could check that each of the supplied red, green, and blue values are within the valid range (e.g., 0 to 255 or 0.0 to 1.0).
          </li>
          <li class="bulllist" id="p0275">
           <a id="u0105">
           </a>
           ▪
           <b>
            Lazy evaluation.
           </b>
           Calculating the value of a variable may incur a significant cost, which you would prefer to avoid until necessary. By using a getter method to access the underlying data value, you can defer the costly calculation until the value is actually requested.
          </li>
          <li class="bulllist" id="p0280">
           <a id="u0110">
           </a>
           ▪
           <b>
            Caching.
           </b>
           A classic optimization technique is to store the value of a frequently requested calculation and then directly return that value for future requests. For example, a machine's total memory size can be found on Linux by parsing the
           <span class="inlinecode">
            /proc/meminfo
           </span>
           file. Rather than performing a file read for every request to find the total memory size, it would be better to cache the result after the first read and then simply return that cached value for future requests.
          </li>
          <li class="bulllist" id="p0285">
           <a id="u0115">
           </a>
           ▪
           <b>
            Extra computation.
           </b>
           If necessary, you can perform additional operations whenever the client tries to access a variable. For example, perhaps you always want to write the current state of a
           <span class="inlinecode">
            UserPreferences
           </span>
           object to a configuration file on disk whenever the user changes the value of a preference setting.
          </li>
          <li class="bulllist" id="p0290">
           <a id="u0120">
           </a>
           ▪
           <b>
            Notifications.
           </b>
           Other modules may wish to know when a value has changed in your class. For example, if you are implementing a data model for a progress bar, the user interface code will want to know when the progress value has been updated so that it can update the GUI. You might therefore wish to issue a change notification as part of a setter method.
          </li>
          <li class="bulllist" id="p0295">
           <a id="u0125">
           </a>
           ▪
           <b>
            Debugging.
           </b>
           You may want to add debugging or logging statements so that you can track when variables are accessed or changed by clients. Or you may wish to add assert statements to enforce assumptions.
          </li>
          <li class="bulllist" id="p0300">
           <a id="u0130">
           </a>
           ▪
           <b>
            Synchronization.
           </b>
           You may release the first version of your API and then later find that you need to make it thread safe. The standard way to do this is to add mutex locking whenever a value is accessed. This would be possible only if you have wrapped the access to the data values in getter and setter methods.
          </li>
          <li class="bulllist" id="p0305">
           <a id="u0135">
           </a>
           ▪
           <b>
            Finer access control.
           </b>
           If you make a member variable public, then clients can read and write that value as they wish. However, by using getter/setter methods, you can provide a finer level of read/write control. For example, you can make the value be read-only by not providing a setter method.
          </li>
          <li class="bulllist" id="p0310">
           <a id="u0140">
           </a>
           ▪
           <b>
            Maintaining invariant relationships.
           </b>
           Some internal data values may depend upon each other. For example, in a car animation system you may calculate the velocity and acceleration of the car based upon the time it takes to travel between key frames. You can calculate velocity based upon the change in position over time, and acceleration based upon the change in velocity over time. However, if a client can access your internal state for this calculation, they could change the acceleration value so that it does not correlate to the car's velocity, thus producing unexpected results.
          </li>
         </ol>
        </div>
        <p class="text" id="p0315">
         On the other hand, if the member variables are not actually part of the logical interface—that is, they represent internal details that are not relevant to the public
         <a id="p37">
         </a>
         <span aria-label="37" epub:type="pagebreak" id="pagebreak_37" role="doc-pagebreak">
         </span>
         interface—then they should simply be hidden from the interface. For example, consider the following definition for a stack of integers:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="723" src="../../IMAGES/B9780443222191000143/main.assets/u02-09-9780443222191.jpg" width="1496"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0320">
         Clearly this is a bad API because it exposes the way that the stack has been (poorly) implemented as a fixed array of integers, and it reveals the internal state of the stack via the
         <span class="inlinecode">
          mCurSize
         </span>
         variable. If at some future date you decided to improve the implementation of this class, for example by using an
         <span class="inlinecode">
          std::vector
         </span>
         or
         <span class="inlinecode">
          std::list
         </span>
         rather than a fixed-size statically allocated array, then you may find this difficult to do. That's because you've exposed the existence of the
         <span class="inlinecode">
          mStack
         </span>
         and
         <span class="inlinecode">
          mCurSize
         </span>
         variables, and so client code could be relying on the ability to access these variables directly. By changing your implementation, you could break your clients' code.
        </p>
        <p class="text" id="p0325">
         Instead, these member variables should be hidden from the start so that client code cannot access them:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000143/main.assets/u02-10-9780443222191.jpg" width="1247"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0330">
         I have stated that member variables should never be public, but can they be declared as protected? If you make a variable protected, then it can be accessed directly by any clients that subclass your class, and then exactly the same arguments apply as for the public case. As such, you should never make your member variables protected, either. As Alan Snyder states, inheritance severely compromises the benefits of encapsulation in object-oriented programming languages (Snyder, 1986).
        </p>
        <div>
         <aside aria-labelledby="b0040" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0040">
           <div class="b1textfl" id="bpar0135">
            <i>
             TIP: Data members of a class should always be declared private, never public or protected.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p38">
         </a>
        </p>
        <div>
         <span aria-label="38" epub:type="pagebreak" id="pagebreak_38" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0335">
         The only semiplausible argument for exposing member variables is for performance reasons. Executing a C++ method call incurs the overhead of pushing the method's parameters and return address onto the call stack, as well as reserving space for any local variables in the routine. Then when the method completes, the call stack must be unwound again. The cost to perform these actions may be noticeable for performance-critical regions of code, such as within a tight loop performing operations on a large number of objects. Code that directly accesses a public member variable may be two to three times faster than code that has to go through getter/setter methods.
        </p>
        <p class="text" id="p0340">
         However, even in these cases, you should never expose member variables. First, the overhead of a method call will very likely be insignificant for practically all of your API calls. Even if you are writing performance-critical APIs, the careful use of inlining combined with a modern optimizing compiler will normally completely eradicate the method call overhead, giving you all of the performance benefits of directly exposing member variables. If you're still concerned, then try timing your API with inlined getter/setters and then with public member variables. The accompanying source code for this book includes a sample program to do just this. See
         <a href="https://APIBook.com/">
          https://APIBook.com/
         </a>
         to download this code and try it out yourself. I'll also discuss this issue further in the chapter on Performance.
        </p>
       </section>
       <section>
        <a id="s0050">
        </a>
        <h3 class="h2hd" id="cesectitle0060">
         Hide implementation methods
        </h3>
        <p class="textfl" id="p0345">
         In addition to hiding all member variables, you should hide all methods that don't need to be public. This is the principle of information hiding: segregating the stable interface for a class from the internal design decisions used to implement it. Early studies of several large programs found that those using information hiding techniques were four times easier to modify than programs that didn't (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib51" id="bib_51">
          Korson and Vaishnavi, 1986
         </a>
         ). Although your own mileage may vary, it should be clear that hiding the internal details of your API will make for more maintainable and evolvable software.
        </p>
        <p class="text" id="p0350">
         The key point to remember is that a class should define what to do, not how it's done. For example, let's consider a class that lets you download a file from a remote http server:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="1470" src="../../IMAGES/B9780443222191000143/main.assets/u02-11-9780443222191.jpg" width="2010"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p39">
         </a>
        </p>
        <div>
         <span aria-label="39" epub:type="pagebreak" id="pagebreak_39" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0355">
         All of the member variables have been correctly declared as private, which is a good start. However, several implementation-specific methods have been exposed, such as routines to open and read data from a socket and a routine to write the resulting in-memory buffer to a file on disk. The client doesn't need to know any of this. All the client wants to do is specify a URL and then magically have a file created on disk with the contents of that remote location.
        </p>
        <p class="text" id="p0360">
         There's also a particularly egregious method in there:
         <span class="inlinecode">
          GetSocket()
         </span>
         . This is a public method that returns access to a private member variable. By calling this method, a client can get the underlying socket handle and could directly manipulate that socket without the knowledge of the
         <span class="inlinecode">
          URLDownloader
         </span>
         class. What's particularly disturbing is that
         <span class="inlinecode">
          GetSocket()
         </span>
         is declared as a const method, meaning that it doesn't modify the state of the class. Whereas this is strictly true, the client could then use the returned integer socket handle to modify the state of the class. The same kind of leaking of internal state can happen if you return a non-const pointer or reference to one of your private member variables. Doing so lets your clients modify the state of your objects without going through your API.
        </p>
        <div>
         <aside aria-labelledby="b0045" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0045">
           <div class="b1textfl" id="bpar0140">
            <i>
             TIP: Never return non-const pointers or references to private data members. This breaks encapsulation.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0365">
         Obviously a better design for our
         <span class="inlinecode">
          URLDownloader
         </span>
         class would be to make every method private, except for the constructor and the
         <span class="inlinecode">
          DownloadToFile()
         </span>
         method. Everything else is implementation detail. You are then free to change the implementation without affecting any clients of the class.
        </p>
        <p class="text" id="p0370">
         There is still something unsatisfying about this situation, though. I have hidden the implementation details from the compiler's point of view, but a person can still look at the header file and see all of the internal details for your class. In fact, this is very likely because you must distribute the header file to allow clients to compile their code against your API. Also, you must
         <span class="inlinecode">
          #include
         </span>
         all header files needed for the private members of your class, even though they're not dependencies of the public interface. For example, the
         <span class="inlinecode">
          URLDownloader
         </span>
         header needs to
         <span class="inlinecode">
          #include
         </span>
         all of the platform-specific socket headers.
        </p>
        <p class="text" id="p0375">
         This is an unfortunate limitation of the C++ language: all public, protected, and private members of a class must appear in the declaration for that class. Ideally, the header for our class would look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000143/main.assets/u02-12-9780443222191.jpg" width="1872"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p40">
         </a>
        </p>
        <div>
         <span aria-label="40" epub:type="pagebreak" id="pagebreak_40" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0380">
         Then all the private members could be declared somewhere else, such as in the
         <span class="inlinecode">
          .cpp
         </span>
         file. However, this is not possible with C++ (this is so that the size of all objects can be known at compile time). Nevertheless, there are still ways to hide private members from your public header files (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib36" id="bib_36">
          Headington, 1995
         </a>
         ). One popular technique is called the Pimpl idiom. This involves isolating all of a class's private data members inside a separate implementation class or struct in the
         <span class="inlinecode">
          .cpp
         </span>
         file. The
         <span class="inlinecode">
          .h
         </span>
         file then needs only to contain an opaque pointer to this implementation class. I'll discuss this extremely valuable technique in more detail in the Patterns chapter, coming up next.
        </p>
        <p class="text" id="p0385">
         I strongly urge you to adopt the Pimpl idiom in your APIs so that all implementation details can be completely hidden from your public header files. However, if you decide against this direction, you should at least attempt to remove private methods from the header when they are not necessary by moving them to the
         <span class="inlinecode">
          .cpp
         </span>
         file and converting them to static functions (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52" id="bib_52">
          Lakos, 1996
         </a>
         ). This can be done when the private method accesses only public members of the class, or if it accesses no members of the class at all (such as a routine that accepts a filename string and returns the extension for that filename). Many engineers feel that just because a class uses a private method, it must be included in the class declaration. However, this simply exposes more implementation details than necessary.
        </p>
        <div>
         <aside aria-labelledby="b0050" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0050">
           <div class="b1textfl" id="bpar0145">
            <i>
             TIP: Prefer declaring private functionality as static functions within the .cpp file rather than exposing them in public headers as private methods. (Using the Pimpl idiom is even better, though).
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0055">
        </a>
        <h3 class="h2hd" id="cesectitle0065">
         Hide implementation classes
        </h3>
        <p class="textfl" id="p0390">
         In addition to hiding the internal methods and variables for your classes, you should endeavor to hide any actual classes that are purely implementation detail. Most programmers are used to hiding methods and variables, although many forget also to consider that not all classes are public. Indeed, some classes are needed only for your implementation and should not be revealed as part of the public interface of your API.
        </p>
        <p class="text" id="p0395">
         For example, consider a simple
         <span class="inlinecode">
          Fireworks
         </span>
         class: an interface that lets you specify the location of a fireworks animation on the screen and lets you control the color, speed, and number of fire particles. Clearly the API will need to keep track of each particle of the firework effect, so that it can update each particle's position per frame. This implies that a
         <span class="inlinecode">
          FireParticle
         </span>
         class should be introduced to contain the state for a single fire particle. However, clients of the API never need to access this class; it's purely required for the API's implementation.
         <a id="p41">
         </a>
        </p>
        <div>
         <span aria-label="41" epub:type="pagebreak" id="pagebreak_41" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0400">
         We could therefore use either physical or logical hiding to remove the class from the public API. In this case, physical hiding would mean putting the implementation of the class in a private header file (i.e., in a header file that's not included with your set of public API headers). Then we forward declare the class in the public header so that the name is known to the compiler, e.g.,
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="2281" src="../../IMAGES/B9780443222191000143/main.assets/u02-13-9780443222191.jpg" width="1559"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0405">
         Alternatively, you can also use logical hiding to declare the class as private, so clients can't access the class from their code. This can be done by nesting it within another class's private section, e.g.,
         <a id="p42">
         </a>
         <span aria-label="42" epub:type="pagebreak" id="pagebreak_42" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="1991" src="../../IMAGES/B9780443222191000143/main.assets/u02-14-9780443222191.jpg" width="1596"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0410">
         Notice that I didn't use getter/setter methods for the
         <span class="inlinecode">
          FireParticle
         </span>
         class. You could certainly do so if you wanted to, but it's not strictly necessary because the class is not accessible from the public interface.
        </p>
        <p class="text" id="p0415">
         Again, you could also hide the entire
         <span class="inlinecode">
          FireParticle
         </span>
         symbol from appearing in the header file so that it’s hidden even from casual inspection of the header file. I will discuss how to do this in the next chapter.
        </p>
       </section>
      </section>
      <section>
       <a id="s0060">
       </a>
       <h2 class="h1hd" id="cesectitle0070">
        Minimally complete
       </h2>
       <p class="textfl" id="p0420">
        A good API should be minimally complete. That is, it should be as small as feasible, but no smaller.
       </p>
       <p class="text" id="p0425">
        It's perhaps obvious that an API should be complete: that it provides clients with all the functionality they need. However, it may be less obvious what that functionality is. To answer this question, you should perform requirements gathering and use case modeling early on so that you understand what the API is expected to do. You can then assert that it delivers on those expectations. I will talk more about requirements and use cases in the chapter on Design.
        <a id="p43">
        </a>
       </p>
       <div>
        <span aria-label="43" epub:type="pagebreak" id="pagebreak_43" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p0430">
        Less obvious is the apparent contradiction for an API to be minimal. However, this is one of the most important qualities for which you can plan, and one that has a massive impact on the long-term maintenance and evolution of your API. In a very real sense, the decisions you make today will constrain what you can do tomorrow. It also has a large impact on the ease of use of the API, because a compact interface is one that can easily fit inside the head of your users (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib10" id="bib_10">
         Blanchette, 2008
        </a>
        ). I will therefore dedicate the following sections to discuss various techniques to keep your API minimal, and why this is a good thing.
       </p>
       <div>
        <aside aria-labelledby="b0055" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0055">
          <div class="b1textfl" id="bpar0150">
           <i>
            TIP: Remember Occam's razor: Pluralitas non est ponenda
           </i>
           sine
           <i>
            necessitate (plurality should not be posited without necessity).
           </i>
          </div>
         </div>
        </aside>
       </div>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         Don't overpromise
        </h3>
        <p class="textfl" id="p0435">
         Every public element in your API is a promise—a promise that you'll support that functionality for the lifetime of the API. You can break that promise, but doing so may frustrate your clients and cause them to rewrite their code. Even worse, they may decide to abandon your API because they have grown weary of continually having to fix their code because you can't keep your API stable. Or they may simply be unable to use your API anymore because you've removed functionality that supported their unique use case.
        </p>
        <p class="text" id="p0440">
         The key point is that once you release an API and have clients using it, adding new functionality is easy but removing functionality is really difficult. The best advice then is: when in doubt, leave it out (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib11" id="bib_11">
          Bloch, 2008
         </a>
         ;
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib99" id="bib_99">
          Tulach, 2008
         </a>
         ).
        </p>
        <p class="text" id="p0445">
         This advice can be counter to the best intentions of the API designer. As an engineer, you want to provide a flexible and general solution to the problem you're solving. There is a temptation to add extra levels of abstraction or generality to an API because you think it might be useful in the future. You should resist this temptation for the following reasons:
        </p>
        <div>
         <ul class="ce_list" id="olist0020">
          <li class="numlist" id="p0450">
           <a id="o0050">
           </a>
           1. The day may never come when you need the extra generality.
          </li>
          <li class="numlist" id="p0455">
           <a id="o0055">
           </a>
           2. If that day does come, you may have more knowledge about the use of your API and a different solution may present itself from the one you originally envisioned.
          </li>
          <li class="numlist" id="p0460">
           <a id="o0060">
           </a>
           3. If you do need to add the extra functionality, it'll be easier to add it to a simple API than a complex one.
          </li>
         </ul>
        </div>
        <p class="text" id="p0465">
         As a result, you should try to keep your APIs as simple as you can: minimize the number of classes you expose and the number of public members in those classes. As a bonus, this will also make your API easier to understand, easier for your users to keep a mental model of the API in their heads, and easier for you to evolve.
         <a id="p44">
         </a>
         <span aria-label="44" epub:type="pagebreak" id="pagebreak_44" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0060" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0060">
           <div class="b1textfl" id="bpar0155">
            <i>
             TIP: When in doubt, leave it out! Minimize the number of public classes and functions in your API.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         Don't repeat yourself
        </h3>
        <p class="textfl" id="p0470">
         The don't repeat yourself (DRY) principle is about reducing the repetition of information in your code. It's typically described as requiring a single, unambiguous, and authoritative representation for any given piece of information in a system (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib42" id="bib_42">
          Hunt and Thomas, 1999
         </a>
         ).
        </p>
        <p class="text" id="p0475">
         This general concept is also expressed by several other similar design principles, such as the single source of truth principle, which aims to define data in only one place, and the single responsibility principle, which states that a class should have only one reason to change and shouldn't be responsible for multiple unrelated tasks.
        </p>
        <p class="text" id="p0480">
         Taken together, these principles are focused on reducing duplication by defining data and behavior in one place. As such, they offer ways to achieve minimal completeness.
        </p>
        <p class="text" id="p0485">
         However, it's also worth noting that these principles can be taken to extremes if they're applied blindly. Trying to remove every piece of code duplication in your project can lead to overly complex code or unnecessary coupling between classes. So as with most rules of thumb, they should be applied thoughtfully, not rigidly. However, they can be used to help you identify places where a better design might be possible.
        </p>
        <p class="text" id="p0490">
         Some common ways to address code duplication are:
        </p>
        <div>
         <ul class="ce_list" id="olist0025">
          <li class="numlist" id="p0495">
           <a id="o0065">
           </a>
           1.
           <b>
            Function Refactoring:
           </b>
           The simplest solution is just to pull out the duplicated code into a single function that can be called from all of the places that need the functionality. If this is part of your implementation code, then this may not even affect your public API.
          </li>
          <li class="numlist" id="p0500">
           <a id="o0070">
           </a>
           2.
           <b>
            Class Abstractions:
           </b>
           This involves creating more general levels of abstractions to represent the concepts in your system so that shared functionality can be pushed further down the inheritance hierarchy. This is particularly relevant to API design if it concerns the set of public classes and inheritance hierarchies that you expose to your clients.
          </li>
          <li class="numlist" id="p0505">
           <a id="o0075">
           </a>
           3.
           <b>
            Dependency Injection:
           </b>
           This is where the functionality is defined in a single object and that object is passed into the method calls where the functionality is needed. This may affect your API if you need to update various public API method calls to pass in the object.
          </li>
          <li class="numlist" id="p0510">
           <a id="o0080">
           </a>
           4.
           <b>
            Automation:
           </b>
           In cases where duplication is unavoidable, you can define a single source of truth for the functionality and write automation tools to generate the other code from that source of truth. This lets you keep all duplicated code sections in sync by running your automation scripts.
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p45">
         </a>
        </p>
        <div>
         <span aria-label="45" epub:type="pagebreak" id="pagebreak_45" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0515">
         We can take the address book example from earlier in this chapter to illustrate this concept. We identified that each person in the address book may have multiple telephone numbers. One solution would be just to add work and home phone numbers directly to the person object. However, if we wanted to offer various functions to access or format each of these phone numbers, or if we wanted to associate phone numbers with other objects such as addresses, we can see that it may make more sense to represent phone numbers as their own objects in the system. That way, all functionality for manipulating phone numbers can be contained in one place.
        </p>
        <p class="text" id="p0520">
         A good way to think about this is to ask yourself: if you needed to make a change to how something works, would you have to update multiple places in your code to make that change? If so, then you may want to consider refactoring your design. Again, though, this shouldn't be taken as a hard and fast rule. You need to consider the impact on the simplicity and usability of your design as well. For example, perhaps you can instead apply an automation solution behind the scenes to keep information in sync without affecting your API design. (We'll talk about intentional redundancy later in this chapter.)
        </p>
        <p class="text" id="p0525">
         Martin Fowler suggested that you try to refactor code only when you repeat something a third time (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib31" id="bib_31">
          Fowler et al., 1999
         </a>
         ). This is encapsulated in the acronym WET, or write everything twice, meaning that it’s okay to duplicate something twice, but no more. There is also another acronym called AHA, avoid hasty abstractions, which represents the tension between refactoring duplicated code and adding more complex abstractions to your interface. There are so many acronyms for duplicated code!
        </p>
        <p class="text" id="p0530">
         As a final note on reducing duplication, it's possible to interpret the DRY and related principles to mean that there should be only one way to do something. However, that's not always a good goal. Consider the Standard Library container classes that let you search for an element using a
         <span class="inlinecode">
          find()
         </span>
         method. This can be used to discover if an element exists in the container by comparing the result to the
         <span class="inlinecode">
          end()
         </span>
         iterator, but the code to do this is verbose and has the potential for you to get the logic of the comparison wrong. As of C++20, there is now the
         <span class="inlinecode">
          contains()
         </span>
         method, which is much simpler to use, although arguably it is not adding anything you couldn't already do. However, if this new function is just implemented in terms of existing API functions, there is still only one place to update if a change to the behavior is needed. We will delve deeper into this idea of convenience API calls in the next section.
        </p>
       </section>
       <section>
        <a id="s0075">
        </a>
        <h3 class="h2hd" id="cesectitle0085">
         Convenience APIs
        </h3>
        <p class="textfl" id="p0535">
         Keeping an API as small as possible can be a difficult task. There's a natural tension between reducing the number of functions in your API and making the API easy to use for a range of clients. This is an issue that most API designers face: whether to keep the API pure and focused or to allow convenience wrappers. (By the term convenience wrappers, I mean utility routines that encapsulate multiple API calls to provide simpler higher-level operations).
        </p>
        <p class="text" id="p0540">
         On the one hand, there's the argument that an API should provide only one way to perform one task. This ensures that the API is minimal, singularly focused, consistent,
         <a id="p46">
         </a>
         <span aria-label="46" epub:type="pagebreak" id="pagebreak_46" role="doc-pagebreak">
         </span>
         and easy to understand. It also reduces the complexity of the implementation, with all the associated benefits of greater stability and easier debugging and maintenance. Grady Booch refers to this as primitiveness, or the quality to which a method needs access to the internal details of a class to be implemented efficiently, as opposed to nonprimitive methods that can be entirely built on top of primitive ones, without access to any internal state (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib12" id="bib_12">
          Booch et al., 2007
         </a>
         ).
        </p>
        <p class="text" id="p0545">
         However, on the other hand, there is also the argument that an API should make simple things easy to do. Clients should not be required to write lots of code to perform basic tasks. Doing so can give rise to blocks of boilerplate code that get copied and pasted to other parts of their source code, and whenever blocks of code are copied there is the potential for code divergence and bugs. Also, you may wish to target your API to a range of clients, from those who want lots of control and flexibility to those who just want to perform a single task as simply as possible.
        </p>
        <p class="text" id="p0550">
         Both goals are useful and desirable. Fortunately, they do not need to be mutually exclusive. There are several ways you can provide higher-level convenience wrappers for your core API's functionality without diluting its primary purpose. The important point is that you don't mix your convenience API in the same classes as your core API. Instead, you can produce supplementary classes that wrap certain public functionality of your core API. These convenience classes should be fully isolated from your core API (e.g., in different source files or even completely separate libraries). This has the additional benefit of ensuring that your convenience API depends only on the public interface of your core API, and not on any internal methods or classes. Let's look at a real-world example of this.
        </p>
        <p class="text" id="p0555">
         The OpenGL API provides platform-independent routines for writing 2D and 3D applications. It operates on the level of simple primitives such as points, lines, and polygons that are transformed, lit, and rasterized into a frame buffer. The OpenGL API is extremely powerful, but it's also aimed at a very low level. For example, creating a sphere in OpenGL would involve explicitly modeling it as a surface of small flat polygons, as demonstrated in the following code snippet:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000143/main.assets/u02-15-9780443222191.jpg" width="1977"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p47">
         </a>
        </p>
        <div>
         <span aria-label="47" epub:type="pagebreak" id="pagebreak_47" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0560">
         However, most OpenGL implementations also include the OpenGL Utility Library (GLU). This is an API built on top of the OpenGL API that provides higher-level functions, such as mip-map generation, coordinate conversions, quadric surfaces, polygon tessellation, and simple camera positioning. These functions are defined in a library completely separate from the OpenGL library, and the functions all begin with the
         <span class="inlinecode">
          glu
         </span>
         prefix to differentiate them from the core OpenGL API. For example, the following code snippet shows how easy it is to create a sphere using GLU:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000143/main.assets/u02-16-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0565">
         This is a great example of how to maintain the minimal design and focus of a core API while providing additional convenience routines that make it easier to use that API. In fact, there are other APIs built on top of OpenGL that provide further utility classes, such as Mark Kilgard's OpenGL Utility Toolkit (GLUT). This API offers routines to create various solid and wireframe geometric primitives (including the famous Utah teapot) as well as simple window management functions and event processing.
         <a href="#f0030" id="Bf0030">
          Fig. 2.5
         </a>
         shows the relationships among GL, GLU, and GLUT.
        </p>
        <p class="text" id="p0570">
         Ken Arnold refers to this concept as progressive disclosure, meaning that your API should present the basic functionality via an easy-to-use interface while reserving advanced functionality for a separate layer (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib4" id="bib_4">
          Arnold, 2005
         </a>
         ). He notes that this concept is often seen in GUI designs in the form of an Advanced or Export button that discloses further complexity. In this way, you can still provide a powerful API while ensuring that the expert use cases don't obfuscate the basic workflows.
         <a id="p48">
         </a>
         <span aria-label="48" epub:type="pagebreak" id="pagebreak_48" role="doc-pagebreak">
         </span>
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0030">
          <img alt="image" height="877" src="../../IMAGES/B9780443222191000143/main.assets/f02-05-9780443222191.jpg" width="1667"/>
          <figcaption class="figleg">
           <a id="cap0030">
           </a>
           <a id="fspara0035">
           </a>
           <span class="fignum">
            <a href="#Bf0030">
             Figure 2.5
            </a>
           </span>
           An example of a core application programming interface (API) (OpenGL) that is separated from the convenience APIs that are layered on top of it (OpenGL Utility Library and OpenGL Utility Toolkit).
          </figcaption>
         </figure>
        </div>
        <div>
         <aside aria-labelledby="b0065" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0065">
           <div class="b1textfl" id="bpar0160">
            <i>
             TIP: Add convenience APIs as separate modules or libraries that sit on top of your minimal core API.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0080">
        </a>
        <h3 class="h2hd" id="cesectitle0090">
         Add virtual functions judiciously
        </h3>
        <p class="textfl" id="p0575">
         One subtle way that you can expose more functionality than you intended is through inheritance: that is, by making certain member functions virtual. Doing so allows your clients to subclass your class and reimplement any virtual methods. Although this can be very powerful, you should be aware of the potential pitfalls:
        </p>
        <div>
         <ol id="ulist0040">
          <li class="bulllist" id="p0580">
           <a id="u0145">
           </a>
           ▪ You can implement seemingly innocuous changes to your base classes that have a detrimental impact on your clients. This can happen because you evolve the base class in isolation, without knowing all of the ways that your clients have built upon your virtual API. This is often referred to as the fragile base class problem (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib10">
            Blanchette, 2008
           </a>
           ).
          </li>
          <li class="bulllist" id="p0585">
           <a id="u0150">
           </a>
           ▪ Your clients may use your API in ways that you never intended or imagined. This can result in the call graph for your API executing code that you do not control and that may produce unexpected behavior. As an extreme example, there is nothing to stop a client calling
           <span class="inlinecode">
            delete this
           </span>
           in an overridden method. This may even be a valid thing to want to do, but if you did not design your implementation to allow this, then your code will very likely crash.
          </li>
          <li class="bulllist" id="p0590">
           <a id="u0155">
           </a>
           ▪ Clients may extend your API in incorrect or error-prone ways. For example, you may have a thread-safe API but, depending upon your design, a client could override a virtual function and provide an implementation without performing the appropriate mutex locking operations, opening the potential for difficult-to-debug race conditions. (There's a design pattern called Thread-Safe Interface that addresses this specific concern, which I describe in the Concurrency chapter).
          </li>
          <li class="bulllist" id="p0595">
           <a id="u0160">
           </a>
           ▪ Overridden functions may break the internal integrity of your class. For example, the default implementation of a virtual method may call other methods in the same class to update its internal state. If an overridden method does not perform these same calls, then the object could be left in an inconsistent state and behave unexpectedly or crash.
          </li>
         </ol>
        </div>
        <p class="text" id="p0600">
         In addition to these API-level behavioral concerns, there are the standard matters about which you should be aware when using virtual functions in C++:
        </p>
        <div>
         <ol id="ulist0045">
          <li class="bulllist" id="p0605">
           <a id="u0165">
           </a>
           ▪ Virtual function calls must be resolved at runtime by performing a vtable lookup, whereas nonvirtual function calls can be resolved at compile time. This can make virtual function calls slower than nonvirtual calls. In reality, this overhead may be negligible, particularly if your function does nontrivial work or if it is not called frequently.
           <a id="p49">
           </a>
          </li>
          <li>
           <span aria-label="49" epub:type="pagebreak" id="pagebreak_49" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p0610">
           <a id="u0170">
           </a>
           ▪ The use of virtual functions increases the size of an object, typically by the size of a pointer to the vtable. This may be an issue if you wish to create a small object that requires a very large number of instances. Again, in practice this will likely be insignificant compared with the amount of memory consumed by your various member variables.
          </li>
          <li class="bulllist" id="p0615">
           <a id="u0175">
           </a>
           ▪ Adding, reordering, or removing a virtual function will break binary compatibility. This is because a virtual function call is typically represented as an integer offset into the vtable for the class. Therefore changing its order, or causing the order of any other virtual functions to change, means that existing code will need to be recompiled to ensure that it still calls the right functions.
          </li>
          <li class="bulllist" id="p0620">
           <a id="u0180">
           </a>
           ▪ Virtual functions cannot always be inlined. You may reasonably think that it does not make sense to declare a virtual as inline at all, because virtual functions are resolved at runtime whereas inlining is a compile-time optimization. However, there are certain constrained situations in which a compiler can inline a virtual function. All the same, these are far fewer than the cases in which a nonvirtual function can be inlined. (Remember that the
           <span class="inlinecode">
            inline
           </span>
           keyword in C++ is merely a hint to the compiler).
          </li>
          <li class="bulllist" id="p0625">
           <a id="u0185">
           </a>
           ▪ Overloading is tricky with virtual functions. A symbol declared in a derived class will hide all symbols with the same name in the base class. Therefore, a set of overloaded virtual functions in a base class will be hidden by a single overriding function in a subclass. There are ways to get around this (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib26" id="bib_26">
            Dewhurst, 2002
           </a>
           ), but it's better simply to avoid overloading virtual functions.
          </li>
         </ol>
        </div>
        <p class="text" id="p0630">
         Ultimately, you should allow overriding only if you explicitly intend for this to be possible. A class with no virtual functions tends to be more robust and requires less maintenance than one with virtual functions. As a rule of thumb, if your API does not internally call a particular method, then that method probably should not be virtual. You should also allow subclassing only in situations where it makes sense: where the potential subclasses form an is-a relationship with the base class.
        </p>
        <p class="text" id="p0635">
         If you still decide that you want to allow subclassing, make sure that you design your API to allow it safely. Remember the following rules:
        </p>
        <div>
         <ul class="ce_list" id="olist0030">
          <li class="numlist" id="p0640">
           <a id="o0085">
           </a>
           1. Always declare your destructor to be virtual if there are any virtual functions in your class. This is so that subclasses can free any extra resources that they may have allocated.
          </li>
          <li class="numlist" id="p0645">
           <a id="o0090">
           </a>
           2. Always document how methods of your class call each other. If clients want to provide an alternative implementation for a virtual function, they will need to know which other methods need to be called within their implementation to preserve the internal integrity of the object. Or use a design pattern such as Thread-Safe Interface that encodes the dependency.
          </li>
          <li class="numlist" id="p0650">
           <a id="o0095">
           </a>
           3. Never call virtual functions from your constructor or destructor. These calls will never be directed to a subclass (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib70" id="bib_70">
            Meyers, 2005
           </a>
           ). This does not affect the appearance of your API, but it's a good rule to know all the same.
          </li>
         </ul>
        </div>
        <p class="textfl">
         <a id="p50">
         </a>
         <span aria-label="50" epub:type="pagebreak" id="pagebreak_50" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0070" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0070">
           <div class="b1textfl" id="bpar0165">
            <i>
             TIP: Avoid declaring functions as overridable (virtual) until you have a valid and compelling need to do so.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
      </section>
      <section>
       <a id="s0085">
       </a>
       <h2 class="h1hd" id="cesectitle0095">
        Easy to use
       </h2>
       <p class="textfl" id="p0655">
        A well-designed API should make simple tasks easy and obvious. For example, it should be possible for a client to look at the method signatures of your API and be able to glean how to use it without any additional documentation. There have been various studies showing that APIs that are more usable can improve the productivity of developers using them (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib16" id="bib_16">
         Clarke, 2004
        </a>
        ).
       </p>
       <p class="text" id="p0660">
        This API usability quality follows closely from the quality of minimalism: if your API is simple, it should be easy to understand. Similarly, it should follow the rule of least surprise, which posits that an interface should behave in a way that most users would expect. This is done by employing existing models and patterns so that the user can focus on the task at hand, rather than being distracted by the novelty or involution of your interface (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib81" id="bib_81">
         Raymond, 2003
        </a>
        ).
       </p>
       <p class="text" id="p0665">
        Of course, this is not an excuse for you to ignore the need for good supporting documentation. In fact, it should make the task of writing documentation easier. As we all know, a good example can go a long way. Providing sample code can greatly aid the ease of use of your API. Good developers should be able to read example code written using your API and understand how to apply it to their own tasks.
       </p>
       <p class="text" id="p0670">
        The following sections will discuss various aspects and techniques to make your API easier to understand and ultimately simpler to use. Before I do so, though, it should be noted that an API may provide additional complex functionality for expert users that is not so easy to use. However, this should not be done at the expense of keeping the simple case easy.
       </p>
       <section>
        <a id="s0090">
        </a>
        <h3 class="h2hd" id="cesectitle0100">
         Discoverable
        </h3>
        <p class="textfl" id="p0675">
         A discoverable API is one in which users can work out how to use the API on their own without any accompanying explanation or documentation. To illustrate this with a counterexample from the field of user interface design, the Start button in Windows XP does not provide a very discoverable interface for locating the option to shut down the computer. Likewise, the Restart option is accessed rather unintuitively by clicking on the Turn Off Computer button.
        </p>
        <p class="text" id="p0680">
         Discoverability does not necessarily lead to ease of use. For example, it's possible for an API to be simple for a first-time user to learn but cumbersome for an expert user to use on a regular basis. However, in general, discoverability should help you produce a more usable interface.
         <a id="p51">
         </a>
        </p>
        <div>
         <span aria-label="51" epub:type="pagebreak" id="pagebreak_51" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0685">
         There are several ways you can promote discoverability when you design your APIs. Devising an intuitive and logical object model is one important way, as is choosing good names for your classes and functions. Indeed, coming up with clear, descriptive, and appropriate names can be one of the most difficult tasks in API design. I will present specific recommendations for class and function names in
         <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
          Chapter 4
         </a>
         when I discuss API design techniques. Avoiding the use of abbreviations can also be a factor in discoverability (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib10">
          Blanchette, 2008
         </a>
         ), so that users don't have to remember if your API employs
         <span class="inlinecode">
          GetCurrentValue()
         </span>
         ,
         <span class="inlinecode">
          GetCurrValue()
         </span>
         ,
         <span class="inlinecode">
          GetCurValue()
         </span>
         , or
         <span class="inlinecode">
          GetCurVal()
         </span>
         .
        </p>
       </section>
       <section>
        <a id="s0095">
        </a>
        <h3 class="h2hd" id="cesectitle0105">
         Difficult to misuse
        </h3>
        <p class="textfl" id="p0690">
         A good API, in addition to being easy to use, should also be difficult to misuse. Scott Meyers suggests that this is the most important general interface design guideline (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib69" id="bib_69">
          Meyers, 2004
         </a>
         ). Some of the most common ways to misuse an API include passing the wrong arguments to a method and passing illegal values to a method. These can happen when you have multiple arguments of the same type and the user forgets the correct order of the arguments, or when you use an
         <span class="inlinecode">
          int
         </span>
         to represent a small range of values instead of a more constrained
         <span class="inlinecode">
          enum
         </span>
         type (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib11">
          Bloch, 2008
         </a>
         ). For example, consider the following method signature:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0125">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000143/main.assets/u02-17-9780443222191.jpg" width="1628"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0695">
         It would be easy for users to forget whether the first
         <span class="inlinecode">
          bool
         </span>
         argument is the search direction or the case sensitivity flag. Passing the flags in the wrong order would result in unexpected behavior and probably cause users to waste a few minutes debugging the problem, until they realized that they had transposed the
         <span class="inlinecode">
          bool
         </span>
         arguments. However, you could design the method so that the compiler catches this kind of error for them, by introducing a new
         <span class="inlinecode">
          enum
         </span>
         type for each option, or preferably an
         <span class="inlinecode">
          enum class
         </span>
         as of C++11. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0130">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000143/main.assets/u02-18-9780443222191.jpg" width="1976"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p52">
         </a>
        </p>
        <div>
         <span aria-label="52" epub:type="pagebreak" id="pagebreak_52" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0700">
         Not only does this mean that users can't mix up the order of the two flags, because it would generate a compilation error, but also the code they would write is now more self-descriptive. Compare:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0135">
           <img alt="image" height="98" src="../../IMAGES/B9780443222191000143/main.assets/u02-19-9780443222191.jpg" width="1247"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0705">
         with
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0140">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000143/main.assets/u02-20-9780443222191.jpg" width="2531"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0710">
         There are also many APIs that use integers to represent a set of options where an enum would be a better choice. For example, the OpenCV API has a C function called
         <span class="inlinecode">
          cvFlip()
         </span>
         that accepts an integer
         <span class="inlinecode">
          flip_mode
         </span>
         parameter. A value of 0 means flip around the X axis, a value of 1 means flip around the Y axis, and a value of
         <span>
          −
         </span>
         1 means flip around both axes. An easier to use solution might have been to introduce an enum with
         <span class="inlinecode">
          XAxis
         </span>
         ,
         <span class="inlinecode">
          YAxis
         </span>
         , and
         <span class="inlinecode">
          BothAxes
         </span>
         values.
        </p>
        <div>
         <aside aria-labelledby="b0075" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0075">
           <div class="b1textfl" id="bpar0170">
            <i>
             TIP: Prefer the use of enums over Booleans and integers to improve code readability.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0715">
         For more complex cases in which an
         <span class="inlinecode">
          enum
         </span>
         is insufficient, you could even introduce new classes to ensure that each argument has a unique type. For example, Scott Meyers illustrates this approach with the use of a
         <span class="inlinecode">
          Date
         </span>
         class that is constructed by specifying three integers (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib69">
          Meyers, 2004
         </a>
         , 2005):
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0145">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000143/main.assets/u02-21-9780443222191.jpg" width="1351"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0720">
         Meyers notes that in this design clients could pass the year, month, and day values in the wrong order, and they could also specify illegal values, such as a month of 13. To get around these problems, he suggests the introduction of specific classes to represent a year, month, and day value, such as:
         <a id="p53">
         </a>
         <span aria-label="53" epub:type="pagebreak" id="pagebreak_53" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0150">
           <img alt="image" height="2679" src="../../IMAGES/B9780443222191000143/main.assets/u02-22-9780443222191.jpg" width="1489"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0725">
         Now, the constructor for the
         <span class="inlinecode">
          Date
         </span>
         class can be expressed in terms of these new
         <span class="inlinecode">
          Year
         </span>
         ,
         <span class="inlinecode">
          Month
         </span>
         , and
         <span class="inlinecode">
          Day
         </span>
         classes:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0155">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000143/main.assets/u02-23-9780443222191.jpg" width="1871"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p54">
         </a>
        </p>
        <div>
         <span aria-label="54" epub:type="pagebreak" id="pagebreak_54" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0730">
         Using this design, clients can create a new
         <span class="inlinecode">
          Date
         </span>
         object with the following unambiguous and easy to understand syntax. Also, any attempts to specify the values in a different order will result in a compile-time error:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0160">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000143/main.assets/u02-24-9780443222191.jpg" width="1698"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0080" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0080">
           <div class="b1textfl" id="bpar0175">
            <i>
             TIP: Avoid functions with multiple parameters of the same type.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0735">
         C++11 introduced the concept of user-defined literals that can also be employed to help your clients not misuse your APIs. Using this feature, you can define custom literal suffixes for different units and provide code to convert between those different units. For example, you can allow your clients to specify a temperature literal value as
         <span class="inlinecode">
          100.0_degC
         </span>
         or
         <span class="inlinecode">
          100.0_degF
         </span>
         and define how to convert these literals into the values your API expects. For more details on this feature, refer to the C++11 section on User Defined Literals in the C++ Revisions chapter.
        </p>
       </section>
       <section>
        <a id="s0100">
        </a>
        <h3 class="h2hd" id="cesectitle0110">
         Consistent
        </h3>
        <p class="textfl" id="p0740">
         A good API should apply a consistent design approach so that its conventions are easy to remember, and therefore easy to adopt (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib10">
          Blanchette, 2008
         </a>
         ). This applies to all aspects of API design such as naming conventions, parameter order, the use of standard patterns, memory model semantics, the use of exceptions, and error handling.
        </p>
        <p class="text" id="p0745">
         In terms of the first of these, consistent naming conventions imply the reuse of the same words for the same concepts across the API. For example, if you have decided to use the verb pairs Begin and End, you should not mingle the terms Start and Finish. As another example, the Qt3 API mixes the use of abbreviations in several of its method names, such as
         <span class="inlinecode">
          prevValue()
         </span>
         and
         <span class="inlinecode">
          previousSibling()
         </span>
         . This is another example of why the use of abbreviations should be avoided wherever possible.
        </p>
        <p class="text" id="p0750">
         The use of consistent method signatures is an equally critical design quality. If you have several methods that accept similar argument lists, you should endeavor to keep a consistent number and order for those arguments. To give a counterexample, I refer you to the following C library functions:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0165">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000143/main.assets/u02-25-9780443222191.jpg" width="2356"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0755">
         Both functions involve copying
         <span class="inlinecode">
          n
         </span>
         bytes of data from one area of memory to another. However, the
         <span class="inlinecode">
          bcopy()
         </span>
         function copies data from
         <span class="inlinecode">
          s1
         </span>
         into
         <span class="inlinecode">
          s2
         </span>
         , whereas
         <span class="inlinecode">
          strncpy()
         </span>
         copies from
         <span class="inlinecode">
          s2
         </span>
         into
         <span class="inlinecode">
          s1
         </span>
         . This can give rise to subtle memory errors if a developer were to decide to switch usage between the two functions without a close reading of the respective man pages. To be fair, there is a clue to the conflicting specifications in the function signatures: note the use of the const pointer in each case. However, this could easily be missed and won't be caught by a compiler if the source pointer is not declared to be const.
        </p>
        <p class="text" id="p0760">
         Also note the inconsistent use of the words copy and cpy.
        </p>
        <p class="text" id="p0765">
         Let's take another example from the C Standard Library. The familiar
         <span class="inlinecode">
          malloc()
         </span>
         function is used to allocate a contiguous block of memory, and the
         <span class="inlinecode">
          calloc()
         </span>
         function performs the same operation with the addition that it initializes the reserved memory with 0
         <span title='hsp="0.25"'>
         </span>
         bytes. However, despite their similar purpose, they have different function signatures:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0170">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000143/main.assets/u02-26-9780443222191.jpg" width="1386"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0770">
         The
         <span class="inlinecode">
          malloc()
         </span>
         function accepts a size in terms of bytes, whereas
         <span class="inlinecode">
          calloc()
         </span>
         allocates (
         <span class="inlinecode">
          count
         </span>
         ∗
         <span class="inlinecode">
          size
         </span>
         ) bytes. In addition to being inconsistent, this violates the principle of least surprise. As a further example, the
         <span class="inlinecode">
          read()
         </span>
         and
         <span class="inlinecode">
          write()
         </span>
         standard C functions accept a file descriptor as their first parameter, whereas the
         <span class="inlinecode">
          fgets()
         </span>
         and
         <span class="inlinecode">
          fputs()
         </span>
         functions require the file descriptor to be specified last (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib38">
          Henning, 2009
         </a>
         ). And as David Hanson so eloquently put it, the C library function
         <span class="inlinecode">
          realloc()
         </span>
         is a marvel of confusion (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib35" id="bib_35">
          Hanson, 1996
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0085" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0085">
           <div class="b1textfl" id="bpar0180">
            <i>
             TIP: Use consistent function naming and parameter ordering.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p55">
         </a>
        </p>
        <div>
         <span aria-label="55" epub:type="pagebreak" id="pagebreak_55" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0775">
         These examples have been focused on a function or method level, but of course consistency is important at a class level, too. Classes that have similar roles should offer a similar interface. The C++ Standard Library is a great example of this. The
         <span class="inlinecode">
          std::vector
         </span>
         ,
         <span class="inlinecode">
          std::set
         </span>
         ,
         <span class="inlinecode">
          std::map
         </span>
         , and even
         <span class="inlinecode">
          std::string
         </span>
         classes all offer a
         <span class="inlinecode">
          size()
         </span>
         method to return the number of elements in the container. They also all support the use of iterators, so that once you know how to iterate through an
         <span class="inlinecode">
          std::set
         </span>
         you can apply the same knowledge to an
         <span class="inlinecode">
          std::map
         </span>
         . This makes it easier to memorize the programming patterns of the API.
        </p>
        <p class="text" id="p0780">
         You get this kind of consistency for free through polymorphism: by placing the shared functionality into a common base class. However, often it doesn't make sense for all of your classes to inherit from a common base class, and you shouldn't introduce a base class purely for this purpose because it increases the complexity and class count for your interface. Indeed, it's noteworthy that the C++ Standard Library container classes do not inherit from a common base class. Instead, you should explicitly design for this by manually identifying the common concepts across your classes and using the same conventions to represent these concepts in each class. This is often referred to as static polymorphism.
        </p>
        <p class="text" id="p0785">
         You can also make use of C++ templates to help you define and apply this kind of consistency. For example, you could create a template for a 2D coordinate class and specialize it for integers, floats, and doubles. In this way you are assured that each type of coordinate offers the same interface. The following code sample provides a simple example of this:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0175">
           <img alt="image" height="1297" src="../../IMAGES/B9780443222191000143/main.assets/u02-27-9780443222191.jpg" width="1836"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0790">
         With this template definition, you can create variables of type
         <span class="inlinecode">
          Coord2D&lt;int&gt;
         </span>
         ,
         <span class="inlinecode">
          Coord2D&lt;float&gt;
         </span>
         , and
         <span class="inlinecode">
          Coord2D&lt;double&gt;
         </span>
         and all of these will have the same interface.
        </p>
        <p class="text" id="p0795">
         A further aspect of consistency is the use of familiar patterns and standard platform idioms. When you buy a new car, you don't have to relearn how to drive. The concept of using brake and accelerator pedals, a steering wheel, and a gear stick (be it manual or
         <a id="p56">
         </a>
         <span aria-label="56" epub:type="pagebreak" id="pagebreak_56" role="doc-pagebreak">
         </span>
         automatic) is universal the world over. If you can drive one car, it's very likely that you can drive a similar one.
        </p>
        <p class="text" id="p0800">
         Likewise, the easiest APIs to use are those that require minimal new learning for your users. For example, most C++ developers are familiar with the Standard Library and its use of container classes and iterators. Therefore, if you decide to write an API with a similar purpose, it would be advantageous to mimic the patterns of the Standard Library because other developers will then find the use of your API to be familiar and easy to adopt.
        </p>
        <p class="text" id="p0805">
         Finally, an important aspect of consistency is to do something in one way, not two ways. After all, API design is about making decisions. However, sometimes there's no clear good way forward or you may feel compelled to incorporate conflicting feedback from multiple sources. But if you end up providing multiple ways to do the same thing, then the end product will be less usable and you'll have to support those multiple designs going forward (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib58" id="bib_58">
          Martelli, 2011
         </a>
         ).
        </p>
       </section>
       <section>
        <a id="s0105">
        </a>
        <h3 class="h2hd" id="cesectitle0115">
         Orthogonal
        </h3>
        <p class="textfl" id="p0810">
         In mathematics, two vectors are said to be orthogonal if they are perpendicular (at 90 degrees) to each other (i.e., their inner product is zero). This makes them linearly independent, meaning that there is no set of scalars that can be applied to the first vector to produce the second vector. To take a geographic analogy, the perpendicular directions east and north are independent of each other: no amount of walking east will take you north. Said in slightly more computer lingo, changes to your east coordinate have no effect on your north coordinate.
        </p>
        <p class="text" id="p0815">
         In terms of API design, orthogonality means that methods do not have side effects. Calling a method that sets a particular property should change only that property and not additionally change other publicly accessible properties. As a result, making a change to the implementation of one part of the API should have no effect on other parts of the API (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib81">
          Raymond, 2003
         </a>
         ). Striving for orthogonality produces APIs with behaviors that are more predictable and comprehensible. Furthermore, code that does not create side effects, or relies upon the side effects of other code, is much easier to develop, test, debug, and change because its effects are more localized and bounded (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib42">
          Hunt and Thomas, 1999
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0090" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0090">
           <div class="b1textfl" id="bpar0185">
            <i>
             TIP: An orthogonal API means that functions do not have side effects.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0820">
         Let's look at a specific example. Perhaps you've stayed in a motel where the controls of the shower are very unintuitive. You want to be able to set the power and the temperature of the water, but instead you have a single control that seems to affect both
         <a id="p57">
         </a>
         <span aria-label="57" epub:type="pagebreak" id="pagebreak_57" role="doc-pagebreak">
         </span>
         properties in a complex and nonobvious way. This could be modeled using the following API:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0180">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000143/main.assets/u02-28-9780443222191.jpg" width="2114"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0825">
         Just to illustrate this further, let's consider the following implementation for the public methods of this class:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0185">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000143/main.assets/u02-29-9780443222191.jpg" width="1735"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0830">
         In this case you can see that setting the power of the water flow also affects the temperature of the water via a nonlinear relationship. As a result, it's not possible to achieve certain combinations of temperature and power, and naturally the preferred combination of hot water and full power is unattainable. Also, if you were to change the implementation of the
         <span class="inlinecode">
          SetPower()
         </span>
         method, it would have the side effect of affecting the result of the
         <span class="inlinecode">
          GetTemperature()
         </span>
         method. In a more complex system, this interdependence may be something that we as programmers forget about, or are simply unaware of, and
         <a id="p58">
         </a>
         <span aria-label="58" epub:type="pagebreak" id="pagebreak_58" role="doc-pagebreak">
         </span>
         so a simple change to one area of code may have a profound impact on the behavior of other parts of the system.
        </p>
        <p class="text" id="p0835">
         Instead, let's consider an ideal, orthogonal interface for a shower, in which the controls for temperature and power are independent:
         <a id="p59">
         </a>
         <span aria-label="59" epub:type="pagebreak" id="pagebreak_59" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0190">
           <img alt="image" height="2202" src="../../IMAGES/B9780443222191000143/main.assets/u02-30-9780443222191.jpg" width="1811"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0840">
         Two important factors to remember for designing orthogonal APIs are:
        </p>
        <div>
         <ul class="ce_list" id="olist0035">
          <li class="numlist" id="p0845">
           <a id="o0100">
           </a>
           1.
           <b>
            Reduce redundancy.
           </b>
           Ensure that the same information is not represented in more than one way. There should be a single authoritative source for each piece of knowledge.
          </li>
          <li class="numlist" id="p0850">
           <a id="o0105">
           </a>
           2.
           <b>
            Increase independence.
           </b>
           Ensure that there is no overlap of meaning in the concepts that are exposed. Any overlapping concepts should be decomposed into their basal components.
          </li>
         </ul>
        </div>
        <p class="text" id="p0855">
         Another popular interpretation of orthogonal design is that different operations can all be applied to each available data type. This is a definition that is commonly used in the fields of programming language and CPU design. In the latter case, an orthogonal
         <a id="p60">
         </a>
         <span aria-label="60" epub:type="pagebreak" id="pagebreak_60" role="doc-pagebreak">
         </span>
         instruction set is one in which instructions can use any CPU register in any addressing mode, as opposed to a nonorthogonal design in which certain instructions can use only certain registers. Again, in terms of API design, the Standard Library provides an excellent example of this. It offers a collection of generic algorithms and iterators that can be used on any container. For example, the Standard Library
         <span class="inlinecode">
          std::count
         </span>
         algorithm can be applied to any of the
         <span class="inlinecode">
          std::vector
         </span>
         ,
         <span class="inlinecode">
          std::set
         </span>
         , or
         <span class="inlinecode">
          std::map
         </span>
         containers. Hence the choice of algorithm is not dependent upon the container class being used.
        </p>
       </section>
       <section>
        <a id="s0110">
        </a>
        <h3 class="h2hd" id="cesectitle0120">
         Robust resource allocation
        </h3>
        <p class="textfl" id="p0860">
         One of the trickiest aspects of programming in C++ is memory management. This is particularly so for developers who are used to memory managed languages such as Java or C#, in which objects are freed automatically by a garbage collector. By contrast, most C++ bugs arise from some kind of misuse of pointers or references, such as:
        </p>
        <div>
         <ol id="ulist0050">
          <li class="bulllist" id="p0865">
           <a id="u0190">
           </a>
           •
           <b>
            Null dereferencing
           </b>
           : trying to use
           <span class="inlinecode">
            -&gt;
           </span>
           <span title='hsp="0.25"'>
           </span>
           or
           <span class="inlinecode">
            ∗
           </span>
           operators on a
           <span class="inlinecode">
            nullptr
           </span>
           .
          </li>
          <li class="bulllist" id="p0870">
           <a id="u0195">
           </a>
           •
           <b>
            Double freeing
           </b>
           : calling
           <span class="inlinecode">
            delete
           </span>
           or
           <span class="inlinecode">
            free()
           </span>
           on a block of memory twice.
          </li>
          <li class="bulllist" id="p0875">
           <a id="u0200">
           </a>
           •
           <b>
            Accessing invalid memory
           </b>
           : trying to use
           <span class="inlinecode">
            -&gt;
           </span>
           <span title='hsp="0.25"'>
           </span>
           or
           <span class="inlinecode">
            ∗
           </span>
           operators on a pointer that has not yet been allocated or that has already been freed.
          </li>
          <li class="bulllist" id="p0880">
           <a id="u0205">
           </a>
           •
           <b>
            Mixing allocators
           </b>
           : using
           <span class="inlinecode">
            delete
           </span>
           to free memory that was allocated with
           <span class="inlinecode">
            malloc()
           </span>
           , or using
           <span class="inlinecode">
            free()
           </span>
           to return memory allocated with
           <span class="inlinecode">
            new
           </span>
           .
          </li>
          <li class="bulllist" id="p0885">
           <a id="u0210">
           </a>
           •
           <b>
            Incorrect array deallocation
           </b>
           : using the
           <span class="inlinecode">
            delete
           </span>
           operator, instead of
           <span class="inlinecode">
            delete []
           </span>
           , to free an array.
          </li>
          <li class="bulllist" id="p0890">
           <a id="u0215">
           </a>
           •
           <b>
            Memory leaks
           </b>
           : not freeing a block of memory when you are finished with it.
          </li>
         </ol>
        </div>
        <p class="text" id="p0895">
         These problems arise because it's not possible to tell whether a plain C++ pointer is referencing valid memory or if it's pointing to unallocated or freed memory. It's therefore reliant upon the programmer to track this state and ensure that the pointer is never dereferenced incorrectly. But as we know, programmers are fallible. However, many of these kinds of problems can be avoided through the use of managed (or smart) pointers, such as:
        </p>
        <div>
         <ul class="ce_list" id="olist0040">
          <li class="numlist" id="p0900">
           <a id="o0110">
           </a>
           1.
           <b>
            Shared pointers.
           </b>
           These are reference counted pointers where the reference count can be incremented by one when a piece of code wants to hold onto the pointer, and decremented by one when it is finished using the pointer. When the reference count reaches zero, the object pointed to by the pointer is automatically freed. This kind of pointer can help to avoid the problems of accessing freed memory by ensuring that the pointer remains valid for the period that you want to use it.
          </li>
          <li class="numlist" id="p0905">
           <a id="o0115">
           </a>
           2.
           <b>
            Weak pointers.
           </b>
           A weak pointer contains a pointer to an object, normally a shared pointer, but does not contribute to the reference count for that object. If you have a shared pointer and a weak pointer referencing the same object, and the shared pointer is destroyed, the weak pointer immediately becomes null. In this way, weak pointers can detect whether the object being pointed to has expired: if the reference count for the object to which it's pointing is zero. This helps to avoid the
           <a id="p61">
           </a>
           <span aria-label="61" epub:type="pagebreak" id="pagebreak_61" role="doc-pagebreak">
           </span>
           dangling pointer problem where you can have a pointer that's referencing freed memory.
          </li>
          <li class="numlist" id="p0910">
           <a id="o0120">
           </a>
           3.
           <b>
            Unique pointers.
           </b>
           These pointers support ownership of single objects and automatically deallocate their objects when the pointer goes out of scope. They are sometimes also called scoped pointers or auto pointers. Unique pointers are defined as owning a single object and as such they cannot be copied or shared but they can be moved to a new owner.
          </li>
         </ul>
        </div>
        <p class="text" id="p0915">
         These smart pointers are not part of the original C++98 specification. However, support for them was added in C++11 with the
         <span class="inlinecode">
          std::shared_ptr
         </span>
         ,
         <span class="inlinecode">
          std::weak_ptr
         </span>
         , and
         <span class="inlinecode">
          std::unique_ptr
         </span>
         templates.
        </p>
        <p class="text" id="p0920">
         Employing these smart pointers can make your API much easier to use and less prone to the kind of memory errors listed earlier. For example, the use of
         <span class="inlinecode">
          std::shared_ptr
         </span>
         can alleviate the need for users to free a dynamically created object explicitly. Instead, the object will automatically be deleted when it's no longer referenced. For example, consider an API that allows you to create instances of an object via a factory method called
         <span class="inlinecode">
          CreateInstance()
         </span>
         :
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0195">
           <img alt="image" height="681" src="../../IMAGES/B9780443222191000143/main.assets/u02-31-9780443222191.jpg" width="1595"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0925">
         where the implementation of the factory method looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0200">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000143/main.assets/u02-32-9780443222191.jpg" width="1388"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0930">
         Given this API, a client could create instances of
         <span class="inlinecode">
          MyObject
         </span>
         as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0205">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000143/main.assets/u02-33-9780443222191.jpg" width="1700"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p62">
         </a>
        </p>
        <div>
         <span aria-label="62" epub:type="pagebreak" id="pagebreak_62" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0935">
         In this example, two instances of
         <span class="inlinecode">
          MyObject
         </span>
         are created, and both instances are destroyed when the
         <span class="inlinecode">
          ptr
         </span>
         variable goes out of scope (at the end of the program in this case). If instead the
         <span class="inlinecode">
          CreateInstance()
         </span>
         method simply returned a
         <span class="inlinecode">
          MyObject ∗
         </span>
         raw pointer type, then the destructor would never get called in the previous example. The use of smart pointers can therefore make memory management simpler and hence make your API easier for clients to use.
        </p>
        <p class="text" id="p0940">
         In general, if you have a function that returns a pointer that your clients should delete, or if you expect the client to need the pointer for longer than the life of your object, then you should return it using a smart pointer, such as an
         <span class="inlinecode">
          std::shared_ptr
         </span>
         . On the other hand, if ownership of the pointer will be retained by your object, then you can return a weak pointer. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0210">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000143/main.assets/u02-34-9780443222191.jpg" width="1734"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0095" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0095">
           <div class="b1textfl" id="bpar0190">
            <i>
             TIP: Return a dynamically allocated object using a smart pointer wherever possible.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0945">
         It's worth noting that these kinds of memory management issues are simply a specific case of the more general category of resource management. For instance, similar types of problems can be encountered with the manipulation of mutex locks or file handles. We can generalize the concepts of smart pointers to the task of resource management with the following observation: resource allocation is object construction, and resource deallocation is object destruction. This is often referred to with the acronym RAII (resource acquisition is initialization).
        </p>
        <p class="text" id="p0950">
         As an example, examine this code, which illustrates a classic synchronization bug:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0215">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000143/main.assets/u02-35-9780443222191.jpg" width="1282"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p63">
         </a>
        </p>
        <div>
         <span aria-label="63" epub:type="pagebreak" id="pagebreak_63" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0955">
         Obviously, this code will fail to unlock the mutex if an empty string is passed into the method. As a result, the program will deadlock on the next attempt to call the method because the mutex will still be locked. However, you could create a class called
         <span class="inlinecode">
          ScopedMutex
         </span>
         , whose constructor locks the mutex and whose destructor unlocks it again. With such a class, you could rewrite this method as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0220">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000143/main.assets/u02-36-9780443222191.jpg" width="1282"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0960">
         Now you can be assured that the lock will be released whenever the method returns, because the mutex will be unlocked whenever the
         <span class="inlinecode">
          ScopedMutex
         </span>
         variable goes out of scope. As a result, you do not need to check every return statement meticulously to ensure that it has explicitly freed the lock. As a bonus, the code is also much more readable. Support for scoped locking was adding in C++11 with the
         <span class="inlinecode">
          std::lock_guard
         </span>
         and
         <span class="inlinecode">
          std::scoped_lock
         </span>
         class templates.
        </p>
        <p class="text" id="p0965">
         The take-home point in terms of API design is that if your API provides access to the allocation and deallocation of some resource, then you should consider providing a class to manage this, where resource allocation happens in the constructor and deallocation happens in the destructor (and perhaps additionally through a public
         <span class="inlinecode">
          Release()
         </span>
         method so that clients have more control over when the resource is freed).
        </p>
        <div>
         <aside aria-labelledby="b0100" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0100">
           <div class="b1textfl" id="bpar0195">
            <i>
             TIP: Think of resource allocation and deallocation as object construction and destruction.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0970">
         One caveat to be aware of with RAII is that C++ constructors and destructors don't have return values, and you should also not trigger an exception in a destructor. So there may be some cases for which RAII is not the best fit (e.g., when you want to detect an error and retry some logic).
        </p>
       </section>
       <section>
        <a id="s0115">
        </a>
        <h3 class="h2hd" id="cesectitle0125">
         Platform independent
        </h3>
        <p class="textfl" id="p0975">
         A well-designed C++ API should always avoid platform-specific
         <span class="inlinecode">
          #if
         </span>
         /
         <span class="inlinecode">
          #ifdef
         </span>
         lines in its public headers that produce different APIs on different platforms or that produce different APIs in debug versus release builds. If your API presents a high-level and logical
         <a id="p64">
         </a>
         <span aria-label="64" epub:type="pagebreak" id="pagebreak_64" role="doc-pagebreak">
         </span>
         model for your problem domain, as it should, there are very few cases when that API should be different for different platforms.
        </p>
        <p class="text" id="p0980">
         For example, let's take the case of an API that encapsulates the functionality offered by a mobile phone. Some mobile phones offer built-in GPS devices that can deliver the geographic location of the phone, but not all devices offer this capability. However, you should never expose this situation directly through your API, such as in this example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0225">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000143/main.assets/u02-37-9780443222191.jpg" width="1732"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0985">
         This poor design creates a different API on different platforms. Doing so forces the clients of your API to introduce the same platform specificity into their own applications. For example, in the previous case, your clients would have to guard any calls to
         <span class="inlinecode">
          GetGPSLocation()
         </span>
         with precisely the same
         <span class="inlinecode">
          #if
         </span>
         conditional statement; otherwise their code may fail to compile with an undefined symbol error on other platforms.
        </p>
        <p class="text" id="p0990">
         Furthermore, if in a later version of the API you also add support for another device class, say Windows Mobile, then you would have to update the
         <span class="inlinecode">
          #if
         </span>
         line in your public header to include
         <span class="inlinecode">
          _WIN32_WCE
         </span>
         . Then, your clients would have to find all instances in their code where they have embedded the
         <span class="inlinecode">
          TARGET_OS_IPHONE
         </span>
         define and extend it to include
         <span class="inlinecode">
          _WIN32_WCE
         </span>
         . This is because you have unwittingly exposed the implementation details of your API.
        </p>
        <p class="text" id="p0995">
         Instead, you should hide the fact that the function works only on certain platforms and provide a method to determine whether the implementation offers the desired capabilities on the current platform. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0230">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000143/main.assets/u02-38-9780443222191.jpg" width="1732"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1000">
         Now your API is consistent over all platforms and doesn't expose the details of which platforms support GPS coordinates. The clients can now write code to check whether the current device supports a GPS device, by calling
         <span class="inlinecode">
          HasGPS()
         </span>
         , and if so they can call
         <a id="p65">
         </a>
         <span aria-label="65" epub:type="pagebreak" id="pagebreak_65" role="doc-pagebreak">
         </span>
         the
         <span class="inlinecode">
          GetGPSLocation()
         </span>
         method to return the actual coordinate. The implementation of the
         <span class="inlinecode">
          HasGPS()
         </span>
         method might look something like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0235">
           <img alt="image" height="487" src="../../IMAGES/B9780443222191000143/main.assets/u02-39-9780443222191.jpg" width="1108"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1005">
         This is far superior to the original design because the platform-specific
         <span class="inlinecode">
          #if
         </span>
         statement is now hidden in the
         <span class="inlinecode">
          .cpp
         </span>
         file rather than being exposed to your clients in the header file.
        </p>
        <div>
         <aside aria-labelledby="b0105" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0105">
           <div class="b1textfl" id="bpar0200">
            <i>
             TIP: Never put platform-specific
            </i>
            <span class="inlinecode">
             <i>
              #if
             </i>
            </span>
            <i>
             or
            </i>
            <span class="inlinecode">
             <i>
              #ifdef
             </i>
            </span>
            <i>
             statements into your public APIs. It exposes implementation details and makes your API behave differently on differently platforms.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p1010">
         One case where maintaining platform independence can be tricky is when you're writing an API to interface with a platform-specific resource, such as a routine that draws in a window and requires the appropriate window handle for the native operating system. One way to deal with this is to return the resource as a
         <span class="inlinecode">
          void ∗
         </span>
         pointer (i.e., a pointer with no type). Although returning an untyped pointer is generally frowned upon, it's better than making your API be platform specific. As an example of this, the OpenCV API returns operating system–dependent handles as
         <span class="inlinecode">
          void ∗
         </span>
         , requiring clients to cast this to the appropriate type in their application code (e.g., an
         <span class="inlinecode">
          HWND
         </span>
         on Win32,
         <span class="inlinecode">
          WindowRef
         </span>
         on macOS, or
         <span class="inlinecode">
          Widget ∗
         </span>
         on X Windows). Here's an example of what that API looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0240">
           <img alt="image" height="139" src="../../IMAGES/B9780443222191000143/main.assets/u02-40-9780443222191.jpg" width="1698"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
      </section>
      <section>
       <a id="s0120">
       </a>
       <h2 class="h1hd" id="cesectitle0130">
        Loosely coupled
       </h2>
       <p class="textfl" id="p1015">
        In 1974, Wayne Stevens, Glenford Myers, and Larry Constantine published their seminal paper on structured software design. This paper introduced the two interrelated concepts of coupling and cohesion (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib91" id="bib_91">
         Stevens et al., 1974
        </a>
        ), which I will define as:
        <a id="p66">
        </a>
        <span aria-label="66" epub:type="pagebreak" id="pagebreak_66" role="doc-pagebreak">
        </span>
       </p>
       <div>
        <ol id="ulist0055">
         <li class="bulllist" id="p1020">
          <a id="u0220">
          </a>
          •
          <b>
           Coupling.
          </b>
          A measure of the strength of interconnection among software components: that is, the degree to which each component depends upon other components in the system.
         </li>
         <li class="bulllist" id="p1025">
          <a id="u0225">
          </a>
          •
          <b>
           Cohesion.
          </b>
          A measure of how coherent or strongly related the various functions of a single software component are.
         </li>
        </ol>
       </div>
       <p class="text" id="p1030">
        Good software designs tend to correlate with low (or loose) coupling and high cohesion: that is, a design that minimizes the functional relatedness and connectedness between different components. Achieving this goal allows components to be used, understood, and maintained independently of each other.
       </p>
       <div>
        <aside aria-labelledby="b0110" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0110">
          <div class="b1textfl" id="bpar0205">
           <i>
            TIP: Good APIs exhibit loose coupling and high cohesion.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <p class="text" id="p1035">
        Steve McConnell presents a particularly effective analogy for loose coupling. Model railroad cars use simple hook or knuckle couplers to connect cars together. These allow easy linking of train cars—normally just by pushing two cars together—with a single point of connection. This is therefore an example of a loosely coupled system. Imagine how much more difficult it would be to connect the cars if you had to employ several types of connections, perhaps involving screws and wires, or if only particular cars could interface with certain other kinds of cars (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib56" id="bib_56">
         McConnell, 2004
        </a>
        ).
       </p>
       <p class="text" id="p1040">
        One way to think of coupling is that given two components, A and B, how much code in B must change if A changes. There are various measures that can be used to evaluate the degree of coupling between components:
       </p>
       <div>
        <ol id="ulist0060">
         <li class="bulllist" id="p1045">
          <a id="u0230">
          </a>
          ▪
          <b>
           Size.
          </b>
          Relates to the number of connections between components, including the number of classes, methods, and arguments per method. For example, a method with fewer parameters is more loosely coupled to components that call it.
         </li>
         <li class="bulllist" id="p1050">
          <a id="u0235">
          </a>
          ▪
          <b>
           Visibility.
          </b>
          Refers to the prominence of the connection between components. For example, changing a global variable to affect the state of another component indirectly is a poor level of visibility.
         </li>
         <li class="bulllist" id="p1055">
          <a id="u0240">
          </a>
          ▪
          <b>
           Intimacy.
          </b>
          Refers to the directness of the connection between components. If A is coupled to B, and B is coupled to C, then A is indirectly coupled to C. Another example is that inheriting from a class is a tighter coupling than including that class as a member variable (composition), because inheritance also provides access to all protected members of the class.
         </li>
         <li class="bulllist" id="p1060">
          <a id="u0245">
          </a>
          ▪
          <b>
           Flexibility.
          </b>
          Relates to the ease of changing the connections between components. For example, if the signature of a method in A needs to change so that B can call it, flexibility describes how easy it is to change that method and all dependent code.
         </li>
        </ol>
       </div>
       <p class="textfl">
        <a id="p67">
        </a>
       </p>
       <div>
        <span aria-label="67" epub:type="pagebreak" id="pagebreak_67" role="doc-pagebreak">
        </span>
       </div>
       <p class="text" id="p1065">
        One particularly abhorrent form of tight coupling that you should always avoid is having two components that directly or indirectly depend upon each other (i.e., a dependency cycle or circular dependency). This makes it difficult or impossible to reuse a component without including all of its circularly dependent components. I discuss this form of tight coupling further in
        <a href="../B9780443222191000088/CH0004_123-178_B9780443222191000088.xhtml">
         Chapter 4
        </a>
        .
       </p>
       <p class="text" id="p1070">
        In the following sections, I will present various techniques to reduce coupling between the classes and methods within your API (inter-API coupling).
       </p>
       <p class="text" id="p1075">
        However, there is also the interesting question of how your API design decisions affect the cohesion and coupling of your clients' applications (intra-API coupling). Your API is designed to solve a specific problem, and that unity of purpose should translate well into your API being a component with high cohesion in your clients' programs. However, in terms of coupling, the larger your API is—the more classes, methods, and arguments you expose—the more ways in which your API can be accessed and coupled to your clients' applications. As such, the quality of being minimally complete can also contribute toward loose coupling. There is also the issue of how much coupling with other components you have designed into your API. For example, the libpng library depends upon the libz library. This coupling is exposed at compile time, via a reference to the
        <span class="inlinecode">
         zlib.h
        </span>
        header in
        <span class="inlinecode">
         png.h
        </span>
        , and also at link time. This requires clients of the libpng to be aware of the libz dependency and ensure that they also build and link against this additional library.
       </p>
       <section>
        <a id="s0125">
        </a>
        <h3 class="h2hd" id="cesectitle0135">
         Coupling by name only
        </h3>
        <p class="textfl" id="p1080">
         If class A only needs to know the name of class B (i.e., it does not need to know the size of class B or call any methods in the class), then class A does not need to depend upon the full declaration of B. In these cases, you can use a forward declaration for class B rather than including the entire interface, and so reduce the coupling between the two classes (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
          Lakos, 1996
         </a>
         ). For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0245">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000143/main.assets/u02-41-9780443222191.jpg" width="2011"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1085">
         In this case,
         <span class="inlinecode">
          MyObjectHolder
         </span>
         only uses a reference to
         <span class="inlinecode">
          MyObject,
         </span>
         and as such it doesn't need to
         <span class="inlinecode">
          #include "MyObject.h"
         </span>
         to get the full declaration of
         <span class="inlinecode">
          MyObject
         </span>
         . The same would be true if a pointer to
         <span class="inlinecode">
          MyObject
         </span>
         was used instead. By using a forward declaration, the
         <span class="inlinecode">
          MyObjectHolder
         </span>
         class can be decoupled from the physical implementation of
         <span class="inlinecode">
          MyObject
         </span>
         .
         <a id="p68">
         </a>
         <span aria-label="68" epub:type="pagebreak" id="pagebreak_68" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0115" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0115">
           <div class="b1textfl" id="bpar0210">
            <i>
             TIP: Use a forward declaration for a class unless you actually need to #include its full definition.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0130">
        </a>
        <h3 class="h2hd" id="cesectitle0140">
         Reducing class coupling
        </h3>
        <p class="textfl" id="p1090">
         Scott Meyers recommends that whenever you have a choice, you should prefer declaring a function as a nonmember nonfriend function rather than as a member function (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib68" id="bib_68">
          Meyers, 2000
         </a>
         ). Doing so improves encapsulation and reduces the degree of coupling of those functions to the class. For example, consider the following class snippet that provides a
         <span class="inlinecode">
          PrintName()
         </span>
         member function to output the value of a member variable to stdout. The function uses a public getter method,
         <span class="inlinecode">
          GetName()
         </span>
         , to retrieve the current value of the member variable:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0250">
           <img alt="image" height="891" src="../../IMAGES/B9780443222191000143/main.assets/u02-42-9780443222191.jpg" width="1108"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1095">
         Following Meyers' advice, you should prefer this representation:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0255">
           <img alt="image" height="951" src="../../IMAGES/B9780443222191000143/main.assets/u02-43-9780443222191.jpg" width="1247"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p69">
         </a>
        </p>
        <div>
         <span aria-label="69" epub:type="pagebreak" id="pagebreak_69" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1100">
         This latter form reduces coupling because the free function
         <span class="inlinecode">
          PrintName()
         </span>
         can access only the public methods of
         <span class="inlinecode">
          MyObject
         </span>
         (and only the const public methods in this particular case), whereas in the form where
         <span class="inlinecode">
          PrintName()
         </span>
         is a member function, it can also access all of the private and protected member functions and data members of
         <span class="inlinecode">
          MyObject
         </span>
         as well as any protected members of any bases classes, if it had any. Preferring the nonmember nonfriend form therefore means that the function is not coupled to the internal details of the class. It is therefore far less likely to break when the internal details of
         <span class="inlinecode">
          MyObject
         </span>
         are changed (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib99">
          Tulach, 2008
         </a>
         ).
        </p>
        <p class="text" id="p1105">
         This technique also contributes to more minimally complete interfaces, in which a class contains only the minimal functionality required to implement it, whereas functionality that's built on top of its public interface is declared outside the class (as in the example of convenience APIs I discussed earlier). It's worth noting that this happens a lot in the C++ Standard Library, where algorithms such as
         <span class="inlinecode">
          std::for_each()
         </span>
         and
         <span class="inlinecode">
          std::unique()
         </span>
         are declared outside each container class.
        </p>
        <p class="text" id="p1110">
         To convey the conceptual relatedness of
         <span class="inlinecode">
          MyObject
         </span>
         and
         <span class="inlinecode">
          PrintName()
         </span>
         better, you could declare both of these within a single namespace. Alternatively, you could declare
         <span class="inlinecode">
          PrintName()
         </span>
         within its own namespace, such as
         <span class="inlinecode">
          MyObjectHelper
         </span>
         , or even as a static function within a new helper class called
         <span class="inlinecode">
          MyObjectHelper
         </span>
         . As I've already covered in the section on convenience APIs, this helper namespace can and should be contained in a separate module. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0260">
           <img alt="image" height="371" src="../../IMAGES/B9780443222191000143/main.assets/u02-44-9780443222191.jpg" width="1247"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0120" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0120">
           <div class="b1textfl" id="bpar0215">
            <i>
             TIP: Prefer using nonmember nonfriend functions instead of member functions to reduce coupling.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0135">
        </a>
        <h3 class="h2hd" id="cesectitle0145">
         Intentional redundancy
        </h3>
        <p class="textfl" id="p1115">
         Normally, good software engineering practice aims to remove redundancy: to ensure that each significant piece of knowledge or behavior is implemented only once (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib78" id="bib_78">
          Pierce, 2002
         </a>
         ). However, reuse of code implies coupling, and sometimes it's worth the cost to add a small degree of duplication to sever an egregious coupling relationship (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib76" id="bib_76">
          Parnas, 1979
         </a>
         ). This intentional duplication may take the form of code or data redundancy.
         <a id="p70">
         </a>
        </p>
        <div>
         <span aria-label="70" epub:type="pagebreak" id="pagebreak_70" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p1120">
         As an example of code redundancy, consider two large components that are dependent upon each other. However, when you investigate the dependency more deeply, it turns out that it resolves to one component relying on a trivial piece of functionality in the other, such as a function to calculate minimum or maximum. Standard practice would be to find a lower-level home for this functionality, so that both components may depend upon that smaller piece of functionality instead of upon each other. However, sometimes this kind of refactoring doesn't make sense (e.g., if the functionality is simply not generic enough to be demoted to a lower level in the system). Therefore, in certain cases it may make sense to duplicate the code to avoid the coupling (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
          Lakos, 1996
         </a>
         ).
        </p>
        <p class="text" id="p1125">
         In terms of adding data redundancy, consider the following API for a text chat system that logs each message sent by a user:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0265">
           <img alt="image" height="1297" src="../../IMAGES/B9780443222191000143/main.assets/u02-45-9780443222191.jpg" width="2289"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1130">
         This design accepts individual text chat events, taking an object that describes users and the message that they typed. This information is augmented with the current timestamp and added to an internal list. The
         <span class="inlinecode">
          GetCount()
         </span>
         method can then be used to find how many text chat events have occurred and the
         <span class="inlinecode">
          GetMessage()
         </span>
         method will return a formatted version of a given chat event, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0270">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000143/main.assets/u02-46-9780443222191.jpg" width="969"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p1135">
         However, the
         <span class="inlinecode">
          TextChatLog
         </span>
         class is clearly coupled with the
         <span class="inlinecode">
          ChatUser
         </span>
         class, which may be a very heavy class that pulls in many other dependencies. You may therefore decide to investigate this situation and find that
         <span class="inlinecode">
          TextChatLog
         </span>
         only ever uses the name of the user.
         <a id="p71">
         </a>
         <span aria-label="71" epub:type="pagebreak" id="pagebreak_71" role="doc-pagebreak">
         </span>
         That is, it keeps the
         <span class="inlinecode">
          ChatUser
         </span>
         object around but only calls the
         <span class="inlinecode">
          ChatUser::GetName()
         </span>
         method. One solution to remove the coupling between the two classes would therefore be simply to pass the name of the user into the
         <span class="inlinecode">
          TextChatLog
         </span>
         class, as in this refactored version:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0275">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000143/main.assets/u02-47-9780443222191.jpg" width="2392"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div id="p1140">
         This creates a redundant version of the user's name (it is now stored in the
         <span class="inlinecode">
          TextChatLog
         </span>
         as well as the
         <span class="inlinecode">
          ChatUser
         </span>
         classes), but it breaks the dependency between the two classes. It may also have the additional benefit of reducing the memory overhead of
         <span class="inlinecode">
          TextChatLog
         </span>
         , if
         <span class="inlinecode">
          sizeof(std::string)
         </span>
         <span title='hsp="0.25"'>
         </span>
         &lt;
         <span title='hsp="0.25"'>
         </span>
         <span class="inlinecode">
          sizeof(ChatUser)
         </span>
         .
        </div>
        <p class="text" id="p1145">
         Nonetheless, even though this is an intentional duplication, it's still duplication and should be undertaken with great care, consideration, and excellent comments. For example, if the chat system were updated to allow users to change their names, and it was decided that when this happens all previous messages from that user should update to show the new name, then you may have to revert to the original tightly coupled version (or risk more coupling by requiring
         <span class="inlinecode">
          ChatUser
         </span>
         to inform
         <span class="inlinecode">
          TextChatLog
         </span>
         whenever a name change occurs).
        </p>
        <div>
         <aside aria-labelledby="b0125" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0125">
           <div class="b1textfl" id="bpar0220">
            <i>
             TIP: Data redundancy can sometimes be justified to reduce coupling between classes.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0140">
        </a>
        <h3 class="h2hd" id="cesectitle0150">
         Manager classes
        </h3>
        <p class="textfl" id="p1150">
         A manager class is one that owns and coordinates several lower-level classes. This can be used to break the dependency of one or more classes upon a collection of low-level
         <a id="p72">
         </a>
         <span aria-label="72" epub:type="pagebreak" id="pagebreak_72" role="doc-pagebreak">
         </span>
         classes. This is often implemented using a Façade design pattern, which I'll cover in the chapter on Patterns, or a Mediator design pattern. The difference between the two is that a Façade exposes only existing functionality in a different way whereas a Mediator adds new functionality.
        </p>
        <p class="text" id="p1155">
         For example, consider a structured drawing program that lets you create 2D objects, select objects, and move them around a canvas. The program supports several kinds of input devices to let users select and move objects, such as a mouse, tablet, and joystick. A naive design would require both the select and move operations to know about each kind of input device, as shown in this UML diagram (
         <a href="#f0035" id="Bf0035">
          Fig. 2.6
         </a>
         ).
        </p>
        <p class="text" id="p1160">
         Alternatively, you could introduce a manager class to coordinate access to each of the specific input device classes. In this way, the
         <span class="inlinecode">
          SelectObject
         </span>
         and
         <span class="inlinecode">
          MoveObject
         </span>
         classes need only to depend upon this single manager class, and then the manager class needs to depend upon only the individual input device classes. This may also require creating some form of abstraction for the underlying classes. For example, notice that
         <span class="inlinecode">
          MouseInput
         </span>
         ,
         <span class="inlinecode">
          TabletInput
         </span>
         , and
         <span class="inlinecode">
          JoystickInput
         </span>
         each have a slightly different interface. Our manager class could therefore put in place a generic input device interface that abstracts away the specifics of a particular device. The improved, more loosely coupled design is shown in
         <a href="#f0040" id="Bf0040">
          Fig. 2.7
         </a>
         .
         <a id="p73">
         </a>
        </p>
        <section>
         <a id="sf0035">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0035">
           <img alt="image" height="1647" src="../../IMAGES/B9780443222191000143/main.assets/f02-06-9780443222191.jpg" width="2423"/>
           <figcaption class="figleg">
            <a id="cap0035">
            </a>
            <a id="fspara0040">
            </a>
            <span class="fignum">
             <a href="#Bf0035">
              Figure 2.6
             </a>
            </span>
            Multiple high-level classes, each of which is coupled to several low-level classes.
           </figcaption>
          </figure>
         </div>
        </section>
        <div>
         <span aria-label="73" epub:type="pagebreak" id="pagebreak_73" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0040">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="1940" src="../../IMAGES/B9780443222191000143/main.assets/f02-07-9780443222191.jpg" width="2057"/>
           <figcaption class="figleg">
            <a id="cap0040">
            </a>
            <a id="fspara0045">
            </a>
            <span class="fignum">
             <a href="#Bf0040">
              Figure 2.7
             </a>
            </span>
            Using a manager class to reduce coupling to lower-level classes.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p1165">
         Note that this design also scales well, too. This is because more input devices can be added to the system without introducing further dependencies for
         <span class="inlinecode">
          SelectObject
         </span>
         or
         <span class="inlinecode">
          MoveObject
         </span>
         . Also, if you decided to add additional manipulation objects, such as
         <span class="inlinecode">
          RotateObject
         </span>
         and
         <span class="inlinecode">
          ScaleObject
         </span>
         , they need only a single dependency on
         <span class="inlinecode">
          InputManager
         </span>
         , rather than each introducing further coupling to the underlying device classes.
        </p>
        <div>
         <aside aria-labelledby="b0130" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0130">
           <div class="b1textfl" id="bpar0225">
            <i>
             TIP: Manager classes can reduce coupling by encapsulating several lower-level classes. They can be implemented using the Façade or Mediator design patterns.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p74">
         </a>
        </p>
        <div>
         <span aria-label="74" epub:type="pagebreak" id="pagebreak_74" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0145">
        </a>
        <h3 class="h2hd" id="cesectitle0155">
         Callbacks, observers, and notifications
        </h3>
        <p class="textfl" id="p1170">
         The final technique that I'll present to reduce coupling within an API relates to the problem of notifying other classes when some event occurs.
        </p>
        <p class="text" id="p1175">
         Imagine an online 3D multiplayer game that allows multiple users to play against each other. Internally, each player may be represented with a UUID such as e5b43bba-fbf2-4f91-ac71-4f2a12d04847. However, users want to see the names of other players, not inscrutable UUID strings. The system therefore implements a player name cache,
         <span class="inlinecode">
          NameCache
         </span>
         , to store the correspondence between the UUID and the human-readable name.
        </p>
        <p class="text" id="p1180">
         Now, let's say the class that manages the pregame lobby,
         <span class="inlinecode">
          PreGameLobby
         </span>
         , wants to display the name of each player. The set of operations may proceed as:
        </p>
        <div>
         <ul class="ce_list" id="olist0045">
          <li class="numlist" id="p1185">
           <a id="o0125">
           </a>
           1. The
           <span class="inlinecode">
            PreGameLobby
           </span>
           class calls
           <span class="inlinecode">
            NameCache::RequestName()
           </span>
           ,
          </li>
          <li class="numlist" id="p1190">
           <a id="o0130">
           </a>
           2. The
           <span class="inlinecode">
            NameCache
           </span>
           sends a request to the game server for the name of the player with this UUID,
          </li>
          <li class="numlist" id="p1195">
           <a id="o0135">
           </a>
           3. The
           <span class="inlinecode">
            NameCache
           </span>
           receives the player name information from the server, and
          </li>
          <li class="numlist" id="p1200">
           <a id="o0140">
           </a>
           4. The
           <span class="inlinecode">
            NameCache
           </span>
           calls
           <span class="inlinecode">
            PreGameLobby::SetPlayerName()
           </span>
           .
          </li>
         </ul>
        </div>
        <p class="text" id="p1205">
         However, in this case
         <span class="inlinecode">
          PreGameLobby
         </span>
         depends upon
         <span class="inlinecode">
          NameCache
         </span>
         to call the
         <span class="inlinecode">
          RequestName()
         </span>
         method, and
         <span class="inlinecode">
          NameCache
         </span>
         depends upon
         <span class="inlinecode">
          PreGameLobby
         </span>
         to call the
         <span class="inlinecode">
          SetPlayerName()
         </span>
         method. This is an overly brittle and tightly coupled design. Consider what would happen if the in-game system also needed to know a player's name to display it above the user. Would you then extend
         <span class="inlinecode">
          NameCache
         </span>
         also to call the
         <span class="inlinecode">
          InGame::SetPlayerName()
         </span>
         method, further tightening the coupling?
        </p>
        <p class="text" id="p1210">
         A better solution would be to have the
         <span class="inlinecode">
          PreGameLobby
         </span>
         and
         <span class="inlinecode">
          InGame
         </span>
         classes register interest in updates from the
         <span class="inlinecode">
          NameCache
         </span>
         . Then the
         <span class="inlinecode">
          NameCache
         </span>
         can notify any interested parties without having a direct dependency upon those modules. There are several ways that this can be done, such as callbacks, observers, and notifications. I will go into the details of each of these in a moment, but first, here are a number of general issues to understand when using any of these schemes:
        </p>
        <div>
         <ol id="ulist0065">
          <li class="bulllist" id="p1215">
           <a id="u0250">
           </a>
           ▪
           <b>
            Reentrancy.
           </b>
           When writing an API that calls out to unknown user code, you have to consider that this code may call back into your API. In fact, the client may not even realize that this is happening. For example, if you are processing a queue of objects and you issue a callback as you process each individual object, it is possible that the callback will attempt to modify the state of the queue by adding or removing objects. At a minimum, your API should guard against this behavior with a coding error. However, a more elegant solution would be to allow this reentrant behavior and implement your code such that it maintains a consistent state.
          </li>
          <li class="bulllist" id="p1220">
           <a id="u0255">
           </a>
           ▪
           <b>
            Lifetime management.
           </b>
           Client code should have a clean way to disconnect from your API (i.e., to declare that they're no longer interested in receiving updates). This is particularly important when the client object is deleted, because further attempts to send messages to it could cause a crash. Similarly, your API may wish to guard against duplicate registrations, to avoid calling the same client code multiple times for the same event.
           <a id="p75">
           </a>
          </li>
          <li>
           <span aria-label="75" epub:type="pagebreak" id="pagebreak_75" role="doc-pagebreak">
           </span>
          </li>
          <li class="bulllist" id="p1225">
           <a id="u0260">
           </a>
           ▪
           <b>
            Event ordering.
           </b>
           The sequence of callbacks or notifications should be clear to the user of your API. For example, the Cocoa API does a good job of making it clear whether a notification is sent before or after an event by using names such as
           <span class="inlinecode">
            willChange
           </span>
           and
           <span class="inlinecode">
            didChange
           </span>
           . On the other hand, the Qt tool kit is less specific about this: a changed signal is sometimes sent before the object in question is actually updated.
          </li>
         </ol>
        </div>
        <p class="text" id="p1230">
         These points highlight the general issue that you should always make it clear to your clients what they can and cannot do—what assumptions they can and cannot make about your API—within their callback code. This can be done through your API documentation, or it can be enforced more explicitly by giving the callback a limited interface that exposes only a safe subset of all potential operations.
        </p>
        <section>
         <a id="s0150">
         </a>
         <h4 class="h3hd" id="cesectitle0160">
          Callback functions
         </h4>
         <p class="textfl" id="p1235">
          In plain C, a callback is simply a pointer to a function within module A that's passed to module B so that B can invoke the function in A at an appropriate time. Module B knows nothing about module A and has no include or link dependencies upon A. This makes callbacks particularly useful to allow low-level code to execute high-level code that it cannot have a link dependency on. As such, callbacks are a popular technique to break cyclic dependencies in large projects.
         </p>
         <p class="text" id="p1240">
          It's also sometimes useful to supply a closure with the callback function. This is a piece of data that module A passes to B, and which module B includes in the function callback to A. This is a way for module A to pass through some state that will be important to receive in the callback function.
         </p>
         <p class="text" id="p1245">
          The following header file shows how you can define a simple callback API in C++11 syntax:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0280">
            <img alt="image" height="1702" src="../../IMAGES/B9780443222191000143/main.assets/u02-48-9780443222191.jpg" width="2186"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="textfl">
          <a id="p76">
          </a>
         </p>
         <div>
          <span aria-label="76" epub:type="pagebreak" id="pagebreak_76" role="doc-pagebreak">
          </span>
         </div>
         <p class="text" id="p1250">
          (A more sophisticated example would support adding multiple callbacks to
          <span class="inlinecode">
           ModuleB
          </span>
          , perhaps storing them in an
          <span class="inlinecode">
           std::vector
          </span>
          , and then invoking each registered callback in turn).
         </p>
         <p class="text" id="p1255">
          There are a few problems with this approach. One is that for object-oriented C++ programs, it's nontrivial to use a nonstatic (instance) method as a callback. This is because the this-pointer of the object also needs to be passed along. C++11 offers a couple of solutions for this. You can use
          <span class="inlinecode">
           std::bind
          </span>
          to wrap up the method call with the object instance. Or you can use
          <span class="inlinecode">
           std::function
          </span>
          to define the callback type and then use a lambda that captures the object. Here's an example of the latter:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0285">
            <img alt="image" height="1916" src="../../IMAGES/B9780443222191000143/main.assets/u02-49-9780443222191.jpg" width="2082"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1260">
          Another problem with this approach is the use of the untyped
          <span class="inlinecode">
           void ∗
          </span>
          parameter to pass data into the callback function. If you need to work with objects, or pass state into a callback, then it would be better to use an object-based solution such as the observer pattern.
          <a id="p77">
          </a>
         </p>
         <div>
          <span aria-label="77" epub:type="pagebreak" id="pagebreak_77" role="doc-pagebreak">
          </span>
         </div>
        </section>
        <section>
         <a id="s0155">
         </a>
         <h4 class="h3hd" id="cesectitle0165">
          Observers
         </h4>
         <p class="textfl" id="p1265">
          Callback functions present a solution that work well in plain C programs, but a more object-oriented solution is to use the concept of observers. This is a software design pattern in which an object maintains a list of its dependent objects (observers) and notifies them by calling one of their methods. This is a very important pattern for minimizing coupling in API design. In fact, I have dedicated an entire section to it in the Patterns chapter. I will defer detailed treatment of observers until then, but I will briefly cover the topic here to offer a comparison with the earlier callback function approach.
         </p>
         <p class="text" id="p1270">
          The general approach to implement the observer pattern is to define a base class, often an abstract base class, which declares the callback method (or methods) that can be called. You can then provide an implementation of this interface with your specific callback functionality. You can also store any state that's specific to your needs in the data members of your observer class. For example:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0290">
            <img alt="image" height="1297" src="../../IMAGES/B9780443222191000143/main.assets/u02-50-9780443222191.jpg" width="2116"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1275">
          Then the module that registers and invokes your observer might look as follows. Note that I store the observer object using a shared pointer so that the code is robust to the life cycle of your observer:
          <a id="p78">
          </a>
          <span aria-label="78" epub:type="pagebreak" id="pagebreak_78" role="doc-pagebreak">
          </span>
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0295">
            <img alt="image" height="1354" src="../../IMAGES/B9780443222191000143/main.assets/u02-51-9780443222191.jpg" width="1802"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1280">
          You can also use a function object, or functor, to define your callback function. This is simply a type that implements
          <span class="inlinecode">
           operator()
          </span>
          . This has the benefit of making the object behave more like a callback function, if that is desired. For example:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0300">
            <img alt="image" height="1586" src="../../IMAGES/B9780443222191000143/main.assets/u02-52-9780443222191.jpg" width="1977"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="textfl">
          <a id="p79">
          </a>
         </p>
         <div>
          <span aria-label="79" epub:type="pagebreak" id="pagebreak_79" role="doc-pagebreak">
          </span>
         </div>
        </section>
        <section>
         <a id="s0160">
         </a>
         <h4 class="h3hd" id="cesectitle0170">
          Notifications
         </h4>
         <p class="textfl" id="p1285">
          Callbacks and observers tend to be created for a particular task, and the mechanism to use them is normally defined within the objects that need to perform the actual callback. An alternative solution is to build a centralized mechanism to send notifications, or events, between unconnected parts of the system. The sender does not need to know about the receiver beforehand, and so this can be used to reduce coupling between the sender and receiver. There are several kinds of notification schemes, but one particularly popular one is signals and slots.
         </p>
         <p class="text" id="p1290">
          The signals and slots concept was introduced by the Qt library as a generic way to allow any event, such as a button click or a timer event, to be sent to any interested method to act upon it. However, there are now several alternative implementations of signals and slots available for use in plain C++ code, including Boost's
          <span class="inlinecode">
           boost::signals
          </span>
          and
          <span class="inlinecode">
           boost::signals2
          </span>
          library.
         </p>
         <p class="text" id="p1295">
          Signals can be thought of simply as callbacks with multiple targets (slots). All slots for a signal are called when that signal is invoked, or emitted. To give a concrete example, the following code snippet uses
          <span class="inlinecode">
           boost::signal
          </span>
          to create a signal that takes no arguments. You then connect a simple object to the signal. Finally, you emit the signal, which causes
          <span class="inlinecode">
           MySlot::operator()
          </span>
          to be called, resulting in a message being printed to stdout:
         </p>
         <div>
          <div class="pageavoid">
           <figure class="fig" id="f0305">
            <img alt="image" height="1181" src="../../IMAGES/B9780443222191000143/main.assets/u02-53-9780443222191.jpg" width="2079"/>
            <figcaption class="figleg">
            </figcaption>
           </figure>
          </div>
         </div>
         <p class="text" id="p1300">
          In practical use, a low-level class could therefore create and own a signal. It then allows any unconnected classes to add themselves as slots to this signal. Then the low-level class can emit its signal at any appropriate time and all connected slots will be called.
          <a id="p80">
          </a>
         </p>
         <div>
          <span aria-label="80" epub:type="pagebreak" id="pagebreak_80" role="doc-pagebreak">
          </span>
         </div>
        </section>
       </section>
      </section>
      <section>
       <a id="s0165">
       </a>
       <h2 class="h1hd" id="cesectitle0175">
        Stable, documented, and tested
       </h2>
       <p class="textfl" id="p1305">
        A well-designed API should be stable and future-proof. In this context, stable does not necessarily mean that the API never changes, but rather that the interface should be versioned and should not change incompatibly from one version to the next. Related to this, the term future-proof means that an API should be designed to be extensible so that it can be evolved elegantly rather than changed chaotically.
       </p>
       <p class="text" id="p1310">
        A good API should also be well-documented so that users have clear information about the capabilities, behavior, best practices, and error conditions for the API. Finally, there should be extensive automated tests written for the implementation of the API, so that new changes can be made with the confidence that existing use cases have not been broken.
       </p>
       <p class="text" id="p1315">
        These topics have been condensed into a single section at the end of the chapter not because they are of minor concern or importance; quite the opposite, in fact. These issues are so fundamentally important to the development of high-quality, robust, and easy-to-use APIs that I have dedicated entire chapters to each topic.
       </p>
       <p class="text" id="p1320">
        I've included this placeholder section here because I feel that a chapter on API qualities should at least reference these important topics. However, for specific details, I refer you to the separate chapters on Versioning, Documentation, and Testing for complete coverage of each respective topic.
       </p>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
