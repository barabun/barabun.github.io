<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   3
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_010.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_012.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div class="calibre2" id="_idContainer057">
    <h1 class="chapter-number" id="_idParaDest-55">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor055">
     </a>
     3
    </h1>
    <h1 class="calibre5" id="_idParaDest-56">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor056">
     </a>
     States and Animations with Qt and QML
    </h1>
    <p class="calibre3">
     Qt provides an easy way to animate widgets or any other objects that inherit the
     <strong class="source-inline">
      QObject
     </strong>
     class through its powerful animation framework. The animation can be used either on its own or together with the
     <strong class="bold">
      state machine framework
     </strong>
     , which allows different animations to be played based on the current active state of the widget. Qt’s animation framework also supports grouped animation, which allows you to move more than one graphics item simultaneously or move them in sequence, one after
     <span>
      the other.
     </span>
    </p>
    <p class="calibre3">
     In this chapter, we’re going to cover the following
     <span>
      main topics:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Property animation
      <span>
       in Qt
      </span>
     </li>
     <li class="calibre14">
      Using easing curves to control
      <span>
       property animation
      </span>
     </li>
     <li class="calibre14">
      Creating an
      <span>
       animation group
      </span>
     </li>
     <li class="calibre14">
      Creating a nested
      <span>
       animation group
      </span>
     </li>
     <li class="calibre14">
      State machines
      <span>
       in Qt
      </span>
     </li>
     <li class="calibre14">
      States, transitions, and animations
      <span>
       in QML
      </span>
     </li>
     <li class="calibre14">
      Animating widget properties
      <span>
       using animators
      </span>
     </li>
     <li class="calibre14">
      <span>
       Sprite animation
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-57">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor057">
     </a>
     Technical requirements
    </h1>
    <p class="calibre3">
     The technical requirements for this chapter include
     <strong class="bold">
      Qt 6.6.1 MinGW 64-bit
     </strong>
     ,
     <strong class="bold">
      Qt Creator 12.0.2
     </strong>
     , and Windows 11. All the code used in this chapter can be downloaded from the following GitHub repository
     <span>
      at
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03">
      <span>
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter03
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-58">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor058">
     </a>
     Property animation in Qt
    </h1>
    <p class="calibre3">
     In this example, we will learn how to animate our
     <strong class="bold">
      Graphical User Interface
     </strong>
     (
     <strong class="bold">
      GUI
     </strong>
     ) elements using Qt’s
     <strong class="source-inline">
      property animation
     </strong>
     class, a
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker174">
     </a>
     part of its powerful animation
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker175">
     </a>
     framework that
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker176">
     </a>
     allows us to create fluid-looking animations with
     <span>
      minimal effort.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-59">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor059">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     In the following example, we will create a new widget project and animate the push button by changing
     <span>
      its properties:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Let’s create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project. After that, open up
      <strong class="source-inline1">
       mainwindow.ui
      </strong>
      with Qt Designer and place a button on the main window, as
      <span>
       shown here:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer049">
      <img alt="Figure 3.1 – Dragging and dropping a push button to the UI canvas" class="calibre4" src="image/B20976_03_001.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.1 – Dragging and dropping a push button to the UI canvas
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and add the following line of code at the beginning of the
      <span>
       source code:
      </span>
      <pre class="source-code">
#include &lt;QPropertyAnimation&gt;</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and add the following code to
      <span>
       the constructor:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(10000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
animation-&gt;start();</pre>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-60">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor060">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     One of the more
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker177">
     </a>
     common methods of animating a GUI element is through the property animation class provided by Qt, known as the
     <strong class="source-inline">
      QPropertyAnimation
     </strong>
     class. This class is part of the animation framework and it makes use of the timer system in Qt to change the properties of a GUI element over a
     <span>
      given duration.
     </span>
    </p>
    <p class="calibre3">
     What we are trying to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker178">
     </a>
     accomplish here is animating the button from one position to another while, at the same time, enlarging the button size along the way. By including the
     <strong class="source-inline">
      QPropertyAnimation
     </strong>
     header in our source code in
     <em class="italic">
      step 2
     </em>
     , we will be able to access the
     <strong class="source-inline">
      QPropertyAnimation
     </strong>
     class provided by Qt and make use of
     <span>
      its functionalities.
     </span>
    </p>
    <p class="calibre3">
     The code in
     <em class="italic">
      step 3
     </em>
     basically creates a new
     <em class="italic">
      property animation
     </em>
     and applies it to the
     <strong class="bold">
      push button
     </strong>
     we just created in Qt Designer. We specifically request that the
     <strong class="source-inline">
      property animation
     </strong>
     class changes the geometry properties of the
     <em class="italic">
      push button
     </em>
     and sets its duration to 3,000 milliseconds (
     <span>
      3 seconds).
     </span>
    </p>
    <p class="calibre3">
     Then, the start value of the animation is set to the initial geometry of the
     <em class="italic">
      push button
     </em>
     because, obviously, we want it to start from where we initially placed the button in Qt Designer. The
     <strong class="source-inline">
      end
     </strong>
     value is then set to what we want it to become; in this case, we will move the button to a new position at
     <strong class="source-inline">
      x: 200
     </strong>
     and
     <strong class="source-inline">
      y: 200
     </strong>
     while changing its size to
     <strong class="source-inline">
      width: 100
     </strong>
     and
     <strong class="source-inline">
      height: 50
     </strong>
     along
     <span>
      the way.
     </span>
    </p>
    <p class="calibre3">
     After that, call
     <strong class="source-inline">
      animation
     </strong>
     |
     <strong class="source-inline">
      start()
     </strong>
     to start the animation. Compile and run the project. You should see the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker179">
     </a>
     button start to move slowly across the main window while expanding in size a bit
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker180">
     </a>
     at a time until it reaches its destination. You can change the animation duration and the target position and scale by altering the values in the preceding code. It is really that simple to animate a GUI element using Qt’s property
     <span>
      animation system!
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-61">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor061">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     Qt provides us with several different sub-systems to create animations for our GUI, including the timer, timeline, animation framework, state machine framework, and graphics
     <span>
      view framework:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <strong class="bold">
       Timer
      </strong>
      : Qt provides us with
      <em class="italic">
       repetitive and single-shot timers
      </em>
      . When the timeout value is
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker181">
      </a>
      reached, an
      <strong class="source-inline1">
       event callback
      </strong>
      function will be triggered through Qt’s
      <em class="italic">
       signal-and-slot
      </em>
      mechanism. You can make use of a timer to change the properties (color, position, scale, and so on) of your GUI element within a given interval to create
      <span>
       an animation.
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Timeline
      </strong>
      : The
      <em class="italic">
       Timeline
      </em>
      calls a slot periodically to animate a GUI element. It is quite similar to a
      <em class="italic">
       repetitive timer
      </em>
      , but instead of doing the same thing all of the time when the slot is triggered, the timeline provides a value to the slot to indicate its current
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker182">
      </a>
      frame index so that you can do different things (such as offset to a different space of the sprite sheet) based on the
      <span>
       given value.
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Animation framework
      </strong>
      : The
      <em class="italic">
       animation framework
      </em>
      makes animating a GUI element easy by allowing
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker183">
      </a>
      its properties to be animated. The animations are controlled by using
      <em class="italic">
       easing curves
      </em>
      . Easing curves describe a function that controls what the speed of the animation should be, resulting in different acceleration and deceleration patterns. The types of easing curves supported by Qt include linear, quadratic, cubic, quartic, sine, exponential, circular,
      <span>
       and elastic.
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       State machine framework
      </strong>
      : Qt provides us with classes for creating and executing state graphs, which
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker184">
      </a>
      allow each GUI element to move from one state to another when triggered by signals. The
      <em class="italic">
       state graph
      </em>
      in the
      <em class="italic">
       state machine framework
      </em>
      is hierarchical, which means every state can also be nested inside of
      <span>
       other states.
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Graphics view framework
      </strong>
      : The
      <em class="italic">
       graphics view framework
      </em>
      is a powerful graphics engine for visualizing
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker185">
      </a>
      and interacting with a large number of
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker186">
      </a>
      custom-made 2D graphical
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker187">
      </a>
      items. You can use the graphics view framework to draw your GUI and have them animated in a totally manual way if you are an
      <span>
       experienced programmer.
      </span>
     </li>
    </ul>
    <p class="calibre3">
     By making use of all of the powerful features we’ve mentioned here, we’re able to create an intuitive and modern GUI with ease. In this chapter, we will look into the practical approaches to animating GUI elements
     <span>
      using Qt.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-62">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor062">
     </a>
     Using easing curves to control property animation
    </h1>
    <p class="calibre3">
     In this example, we will learn how to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker188">
     </a>
     make our animation more interesting by utilizing
     <em class="italic">
      easing curves
     </em>
     . We will still use the previous source code, which
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker189">
     </a>
     uses the property animation to animate a
     <span>
      push button.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-63">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor063">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     In the following example, we will learn how to add an
     <em class="italic">
      easing curve
     </em>
     to
     <span>
      our animation:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Define an easing curve and add it to the property animation before calling the
      <span>
       <strong class="source-inline1">
        start()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</pre>
     </li>
     <li class="calibre14">
      Call the
      <strong class="source-inline1">
       setLoopCount()
      </strong>
      function
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker190">
      </a>
      to set how many
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker191">
      </a>
      loops you want it to
      <span>
       repeat for:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setDuration(3000);
animation-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation-&gt;setEndValue(QRect(200, 200, 100, 50));
QEasingCurve curve;
curve.setType(EasingCurve::OutBounce);
animation-&gt;setEasingCurve(curve);
animation-&gt;setLoopCount(2);
animation-&gt;start();</pre>
     </li>
     <li class="calibre14">
      Call
      <strong class="source-inline1">
       setAmplitude()
      </strong>
      ,
      <strong class="source-inline1">
       setOvershoot()
      </strong>
      , and
      <strong class="source-inline1">
       setPeriod()
      </strong>
      before applying the easing curve to
      <span>
       the animation:
      </span>
      <pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation-&gt;setEasingCurve(curve);
animation-&gt;start();</pre>
     </li>
    </ol>
    <p class="calibre3">
     It’s really that easy to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker192">
     </a>
     animate a widget or any object in Qt 6 using the built-in
     <span>
      easing curves.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-64">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor064">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     To let an easing curve control the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker193">
     </a>
     animation, all you need to do is define an easing curve and add it to the property animation before calling the
     <strong class="source-inline">
      start()
     </strong>
     function. You can also try several other types of easing curves and see which one suits you best. Here is
     <span>
      an example:
     </span>
    </p>
    <pre class="source-code">
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);</pre>
    <p class="calibre3">
     If you want the animation to loop after it has finished playing, you can call the
     <strong class="source-inline">
      setLoopCount()
     </strong>
     function to set how many loops you want it to repeat for or set the value to
     <strong class="source-inline">
      -1
     </strong>
     for an
     <span>
      infinite loop:
     </span>
    </p>
    <pre class="source-code">
animation-&gt;setLoopCount(-1);</pre>
    <p class="calibre3">
     There are several parameters that you can set to refine the easing curve before applying it to the property animation. These parameters include
     <strong class="bold">
      amplitude
     </strong>
     ,
     <strong class="bold">
      overshoot
     </strong>
     ,
     <span>
      and
     </span>
     <span>
      <strong class="bold">
       period
      </strong>
     </span>
     <span>
      :
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <strong class="bold">
       Amplitude
      </strong>
      : The higher the
      <em class="italic">
       amplitude
      </em>
      , the higher the bounce or elastic spring effect that will be applied to
      <span>
       the
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker194">
       </a>
      </span>
      <span>
       animation.
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Overshoot
      </strong>
      : Some curve functions
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker195">
      </a>
      will produce an
      <em class="italic">
       overshoot
      </em>
      (exceeding its final value) curve due to a damping effect. By adjusting the overshoot value, we are able to increase or decrease
      <span>
       this effect.
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Period
      </strong>
      : Setting a small
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker196">
      </a>
      period value will give a high frequency to the curve. A large
      <em class="italic">
       period
      </em>
      will give it a
      <span>
       small frequency.
      </span>
     </li>
    </ul>
    <p class="calibre3">
     These parameters, however, are not applicable to all curve types. Please refer to the Qt documentation to see which parameter is applicable to which
     <span>
      curve type.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-65">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor065">
     </a>
     There’s more...
    </h2>
    <p class="calibre3">
     While the property
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker197">
     </a>
     animation works perfectly fine, sometimes it feels a little boring to look at a GUI element being animated at a constant speed. We can make the animation look more interesting by adding an
     <strong class="bold">
      easing curve
     </strong>
     to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker198">
     </a>
     control the motion. There are many types of  easing curves that you can use in Qt, and here are some
     <span>
      of them:
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer050">
      <img alt="Figure 3.2 – Different types of easing curves supported by Qt 6" class="calibre4" src="image/B20976_03_002.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.2 – Different types of easing curves supported by Qt 6
    </p>
    <p class="calibre3">
     As you can see from the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker199">
     </a>
     preceding diagram, each easing curve produces a different
     <em class="italic">
      ease-in and
     </em>
     <span>
      <em class="italic">
       ease-out
      </em>
     </span>
     <span>
      effect.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     For the full list of easing curves available in Qt, please refer to the Qt documentation
     <span>
      at
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum">
      <span>
       http://doc.qt.io/qt-6/qeasingcurve.html#Type-enum
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-66">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor066">
     </a>
     Creating an animation group
    </h1>
    <p class="calibre3">
     In this example, we will
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker200">
     </a>
     learn how to use an
     <em class="italic">
      animation group
     </em>
     to manage the states of the animations contained in
     <span>
      the group.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-67">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor067">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s create an
     <em class="italic">
      animation group
     </em>
     by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      We will use the previous example but, this time, we will add two more push buttons to the main window, as shown in the
      <span>
       following screenshot:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer051">
      <img alt="Figure 3.3 – Adding three push buttons to the main window" class="calibre4" src="image/B20976_03_003.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.3 – Adding three push buttons to the main window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Define the
      <em class="italic">
       animation
      </em>
      for each of the push buttons in the main
      <span>
       window’s constructor:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 200, 100, 50));</pre>
     </li>
     <li class="calibre14">
      Create an
      <em class="italic">
       easing curve
      </em>
      and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker201">
      </a>
      apply the same curve to all
      <span>
       three animations:
      </span>
      <pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);</pre>
     </li>
     <li class="calibre14">
      Once you have applied the easing curve to all three animations, we will then create an
      <em class="italic">
       animation group
      </em>
      and add all three animations to
      <span>
       the group:
      </span>
      <pre class="source-code">
QParallelAnimationGroup *group = new QParallelAnimationGroup;
group-&gt;addAnimation(animation1);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation3);</pre>
     </li>
     <li class="calibre14">
      Call the
      <strong class="source-inline1">
       start()
      </strong>
      function
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker202">
      </a>
      from the animation group we
      <span>
       just created:
      </span>
      <pre class="source-code">
group-&gt;start();</pre>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-68">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor068">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     Qt allows us to create multiple animations and group them into an animation group. A group is usually responsible for managing the state of its animations (that is, it decides when to start, stop, resume, and pause them). Currently, Qt provides two types of classes for animation groups:
     <strong class="source-inline">
      QParallelAnimationGroup
     </strong>
     <span>
      and
     </span>
     <span>
      <strong class="source-inline">
       QSequentialAnimationGroup
      </strong>
     </span>
     <span>
      :
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <strong class="source-inline1">
       QParallelAnimationGroup
      </strong>
      : As its name implies, a
      <em class="italic">
       parallel animation group
      </em>
      runs all of the animations in its group at the same time. The group is deemed finished when the longest-lasting animation has
      <span>
       finished running.
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       QSequentialAnimationGroup
      </strong>
      : A
      <em class="italic">
       sequential animation group
      </em>
      runs its animations in sequence, meaning it will only run a single animation at a time and only play the next animation when the current one
      <span>
       has finished.
      </span>
     </li>
    </ul>
    <h2 class="calibre7" id="_idParaDest-69">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor069">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     Since we are using an animation group now, we no longer call the
     <strong class="source-inline">
      start()
     </strong>
     function from the individual animation. Instead, we will be calling the
     <strong class="source-inline">
      start()
     </strong>
     function from the  animation group we just created. If you compile and run the example now, you will see all three buttons being played at the same
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker203">
     </a>
     time. This is because we are using the
     <strong class="bold">
      parallel
     </strong>
     <strong class="bold">
      animation group
     </strong>
     . You can replace it with a
     <strong class="bold">
      sequential animation group
     </strong>
     and run
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker204">
     </a>
     the
     <span>
      example again:
     </span>
    </p>
    <pre class="source-code">
QSequentialAnimationGroup *group = new QSequentialAnimationGroup;</pre>
    <p class="calibre3">
     This time, only a single button will play its animation at a time, while the other buttons will wait patiently for their turn to come. The priority is set based on which animation is added to the animation group first. You can change the animation sequence by simply rearranging the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker205">
     </a>
     sequence of an animation that’s being added to the group. For example, if we want button
     <strong class="source-inline">
      3
     </strong>
     to start the animation first, followed by button
     <strong class="source-inline">
      2
     </strong>
     , and then button
     <strong class="source-inline">
      1
     </strong>
     , the code will look
     <span>
      like this:
     </span>
    </p>
    <pre class="source-code">
group-&gt;addAnimation(animation3);
group-&gt;addAnimation(animation2);
group-&gt;addAnimation(animation1);</pre>
    <p class="calibre3">
     Since property animations and animation groups are both inherited from the
     <strong class="source-inline">
      QAbstractAnimator
     </strong>
     class, it means that you can also add an animation group to another animation group to form a more complex, nested
     <span>
      animation group.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-70">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor070">
     </a>
     Creating a nested animation group
    </h1>
    <p class="calibre3">
     One good example of using a
     <strong class="bold">
      nested animation group
     </strong>
     is when you have several
     <strong class="bold">
      parallel
     </strong>
     animation groups and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker206">
     </a>
     you want to play the groups in
     <span>
      sequential order.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-71">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor071">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s follow these steps to create a
     <strong class="bold">
      nested animation group
     </strong>
     to play different animation groups in a
     <span>
      sequential order:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      We will use the UI from the previous example and add a few more buttons to the main window,
      <span>
       like so:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer052">
      <img alt="Figure 3.4 – We need even more buttons this time around" class="calibre4" src="image/B20976_03_004.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.4 – We need even more buttons this time around
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Create all of the animations
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker207">
      </a>
      for the buttons and then create an easing curve and apply it to all of
      <span>
       the animations:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation1 = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation1-&gt;setDuration(3000);
animation1-&gt;setStartValue(ui-&gt;pushButton-&gt;geometry());
animation1-&gt;setEndValue(QRect(50, 50, 100, 50));
QPropertyAnimation *animation2 = new
QPropertyAnimation(ui-&gt;pushButton_2, "geometry");
animation2-&gt;setDuration(3000);
animation2-&gt;setStartValue(ui-&gt;pushButton_2-&gt;geometry());
animation2-&gt;setEndValue(QRect(150, 50, 100, 50));
QPropertyAnimation *animation3 = new
QPropertyAnimation(ui-&gt;pushButton_3, "geometry");
animation3-&gt;setDuration(3000);
animation3-&gt;setStartValue(ui-&gt;pushButton_3-&gt;geometry());
animation3-&gt;setEndValue(QRect(250, 50, 100, 50));</pre>
     </li>
     <li class="calibre14">
      Next, apply the
      <span>
       following
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker208">
       </a>
      </span>
      <span>
       code:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation4 = new
QPropertyAnimation(ui-&gt;pushButton_4, "geometry");
animation4-&gt;setDuration(3000);
animation4-&gt;setStartValue(ui-&gt;pushButton_4-&gt;geometry());
animation4-&gt;setEndValue(QRect(50, 200, 100, 50));
QPropertyAnimation *animation5 = new
QPropertyAnimation(ui-&gt;pushButton_5, "geometry");
animation5-&gt;setDuration(3000);
animation5-&gt;setStartValue(ui-&gt;pushButton_5-&gt;geometry());
animation5-&gt;setEndValue(QRect(150, 200, 100, 50));
QPropertyAnimation *animation6 = new
QPropertyAnimation(ui-&gt;pushButton_6, "geometry");
animation6-&gt;setDuration(3000);
animation6-&gt;setStartValue(ui-&gt;pushButton_6-&gt;geometry());
animation6-&gt;setEndValue(QRect(250, 200, 100, 50));</pre>
     </li>
     <li class="calibre14">
      Then, apply the
      <span>
       following code:
      </span>
      <pre class="source-code">
QEasingCurve curve;
curve.setType(QEasingCurve::OutBounce);
curve.setAmplitude(1.00);
curve.setOvershoot(1.70);
curve.setPeriod(0.30);
animation1-&gt;setEasingCurve(curve);
animation2-&gt;setEasingCurve(curve);
animation3-&gt;setEasingCurve(curve);
animation4-&gt;setEasingCurve(curve);
animation5-&gt;setEasingCurve(curve);
animation6-&gt;setEasingCurve(curve);</pre>
     </li>
     <li class="calibre14">
      Create two
      <strong class="bold">
       animation groups
      </strong>
      , one
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker209">
      </a>
      for the buttons in the upper column and another one for the
      <span>
       lower column:
      </span>
      <pre class="source-code">
QParallelAnimationGroup *group1 = new QParallelAnimationGroup;
group1-&gt;addAnimation(animation1);
group1-&gt;addAnimation(animation2);
group1-&gt;addAnimation(animation3);
QParallelAnimationGroup *group2 = new QParallelAnimationGroup;
group2-&gt;addAnimation(animation4);
group2-&gt;addAnimation(animation5);
group2-&gt;addAnimation(animation6);</pre>
     </li>
     <li class="calibre14">
      We will create yet another
      <strong class="bold">
       animation group
      </strong>
      , which will be used to store the two animation groups we
      <span>
       created previously:
      </span>
      <pre class="source-code">
QSequentialAnimationGroup *groupAll = new
QSequentialAnimationGroup;
groupAll-&gt;addAnimation(group1);
groupAll-&gt;addAnimation(group2);
groupAll-&gt;start();</pre>
     </li>
    </ol>
    <p class="calibre3">
     A Nested animation group allows you to set up a more complex widget animation by combining different types of
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker210">
     </a>
     animations and executing them at your
     <span>
      desired orders.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-72">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor072">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     What we are trying to do here is play the animation of the buttons in the upper column first, followed by the buttons in the lower column. Since both of the animation groups are
     <strong class="bold">
      parallel animation groups
     </strong>
     , the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker211">
     </a>
     buttons belonging to the respective groups will be animated at the same time when the
     <strong class="source-inline">
      start()
     </strong>
     function
     <span>
      is called.
     </span>
    </p>
    <p class="calibre3">
     This time, however, the group is a
     <strong class="bold">
      sequential animation group
     </strong>
     , which means only a single parallel animation group will
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker212">
     </a>
     be played at a time, followed by the other when the first one is finished. Animation groups are a very handy system that allows us to create very complex GUI animations with simple coding. Qt will handle the difficult part for us so that we don’t
     <span>
      have to.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-73">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor073">
     </a>
     State machines in Qt 6
    </h1>
    <p class="calibre3">
     A
     <strong class="bold">
      state machine
     </strong>
     can be used for
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker213">
     </a>
     many purposes but, in this chapter, we will only cover topics
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker214">
     </a>
     related
     <span>
      to animation.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-74">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor074">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     A
     <strong class="bold">
      State machine
     </strong>
     is not that hard to achieve in Qt at all. Let’s get started by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      We will set up a new user interface for our example program, which looks
      <span>
       like this:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer053">
      <img alt="Figure 3.5 – Setting up the GUI for our state machine experiment" class="calibre4" src="image/B20976_03_005.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.5 – Setting up the GUI for our state machine experiment
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      We will include
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker215">
      </a>
      some headers in our
      <span>
       source code:
      </span>
      <pre class="source-code">
#include &lt;QStateMachine&gt;
#include &lt;QPropertyAnimation&gt;
#include &lt;QEventTransition&gt;</pre>
     </li>
     <li class="calibre14">
      In our main window’s constructor, add
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker216">
      </a>
      the following code to create a
      <em class="italic">
       new state machine
      </em>
      and two
      <em class="italic">
       states
      </em>
      , which we will be
      <span>
       using later:
      </span>
      <pre class="source-code">
QStateMachine *machine = new QStateMachine(this);
QState *s1 = new QState();
QState *s2 = new QState();</pre>
     </li>
     <li class="calibre14">
      We will define what we should do
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker217">
      </a>
      within each state, which, in this case, will be to change the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker218">
      </a>
      label’s
      <em class="italic">
       text
      </em>
      and the button’s
      <em class="italic">
       position
      </em>
      <span>
       and
      </span>
      <span>
       <em class="italic">
        size
       </em>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
QState *s1 = new QState();
s1-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 1");
s1-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(50, 200,
100, 50));
QState *s2 = new QState();
s2-&gt;assignProperty(ui-&gt;stateLabel, "text", "Current state: 2");
s2-&gt;assignProperty(ui-&gt;pushButton, "geometry", QRect(200, 50,
140, 100));</pre>
     </li>
     <li class="calibre14">
      Once you are done with that, let’s proceed by adding
      <strong class="source-inline1">
       event transition
      </strong>
      classes to our
      <span>
       source code:
      </span>
      <pre class="source-code">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
s2-&gt;addTransition(t2);</pre>
     </li>
     <li class="calibre14">
      Add all of the states we have just created to the state machine and define state 1 as the
      <strong class="bold">
       initial state
      </strong>
      . Then, call
      <strong class="source-inline1">
       machine-&gt;start()
      </strong>
      to run the
      <span>
       state machine:
      </span>
      <pre class="source-code">
machine-&gt;addState(s1);
machine-&gt;addState(s2);
machine-&gt;setInitialState(s1);
machine-&gt;start();</pre>
     </li>
     <li class="calibre14">
      If you run the example
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker219">
      </a>
      program now, you will notice that everything works fine, except
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker220">
      </a>
      the button is not going through a smooth transition and it simply jumps instantly to the position and size we set previously. This is because we have not used a
      <strong class="bold">
       property animation
      </strong>
      to create a
      <span>
       smooth transition.
      </span>
     </li>
     <li class="calibre14">
      Go back to the event transition step and add the following lines
      <span>
       of code:
      </span>
      <pre class="source-code">
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(new QPropertyAnimation(ui-&gt;pushButton,
"geometry"));
s2-&gt;addTransition(t2);</pre>
     </li>
     <li class="calibre14">
      You can also add an
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker221">
      </a>
      easing curve to the animation to make it look
      <span>
       more interesting:
      </span>
      <pre class="source-code">
QPropertyAnimation *animation = new
QPropertyAnimation(ui-&gt;pushButton, "geometry");
animation-&gt;setEasingCurve(QEasingCurve::OutBounce);
QEventTransition *t1 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t1-&gt;setTargetState(s2);
t1-&gt;addAnimation(animation);
s1-&gt;addTransition(t1);
QEventTransition *t2 = new QEventTransition(ui-&gt;changeState,
QEvent::MouseButtonPress);
t2-&gt;setTargetState(s1);
t2-&gt;addAnimation(animation);
s2-&gt;addTransition(t2);</pre>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-75">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor075">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     There are two push buttons
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker222">
     </a>
     and a label on the main window layout. The button in the top-left corner will trigger the state change when pressed, while the label in the top-right corner will change its text to show which state we are currently in. the button below will animate according to the current state. The
     <strong class="source-inline">
      QEventTransition
     </strong>
     classes define what will trigger the transition between one state
     <span>
      and another.
     </span>
    </p>
    <p class="calibre3">
     In our case, we want the state to change from state 1 to state 2 when the
     <strong class="bold">
      changeState
     </strong>
     button (the one in the upper-left) is clicked. After that, we also want to change from state 2 back to state 1
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker223">
     </a>
     when the same button is pressed again. This can be achieved by creating another
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker224">
     </a>
     event transition class and setting the target state back to state 1. Then, add these transitions to their respective states. Instead of just assigning the properties directly to the widgets, we tell Qt to use the property animation class to smoothly interpolate the properties toward the target values. It is that simple! There is no need to set the start value and end value because we have already called the
     <strong class="source-inline">
      assignProperty()
     </strong>
     function, which has automatically assigned the
     <span>
      end value.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-76">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor076">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     The
     <strong class="bold">
      state machine framework
     </strong>
     in Qt
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker225">
     </a>
     provides classes for creating and executing state graphs. Qt’s event system is used to drive the state machines, where transitions between states can be triggered by using
     <em class="italic">
      signals
     </em>
     , and then the
     <em class="italic">
      slots
     </em>
     on the other end will be invoked by the signals to perform an action, such as playing
     <span>
      an animation.
     </span>
    </p>
    <p class="calibre3">
     Once you understand the basics of state machines, you can use them to do other things as well. The state graph in the state machine framework is hierarchical. Just like the animation group in the previous section, states can also be nested inside of
     <span>
      other states:
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer054">
      <img alt="Figure 3.6 – Nested state machines explained visually" class="calibre4" src="image/B20976_03_006.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.6 – Nested state machines explained visually
    </p>
    <p class="calibre3">
     You can combine nested state machines and animations to create a very sophisticated GUI for
     <span>
      your application.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-77">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor077">
     </a>
     States, transitions, and animations in QML
    </h1>
    <p class="calibre3">
     If you prefer to work with QML instead of C++, Qt also provides similar features in Qt Quick that allow you to easily
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker226">
     </a>
     animate a GUI element with minimal lines of code. In this example, we will learn how to achieve this
     <span>
      with QML.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-78">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor078">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s get started by following these steps to create a window that continuously changes its
     <span>
      background color:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      We will create a new
      <strong class="bold">
       Qt Quick Application
      </strong>
      project and set up our user interface,
      <span>
       like so:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer055">
      <img alt="Figure 3.7 – A joyful application that constantly changes its background color" class="calibre4" src="image/B20976_03_007.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.7 – A joyful application that constantly changes its background color
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Here is what
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker227">
      </a>
      my
      <strong class="source-inline1">
       main.qml
      </strong>
      file
      <span>
       looks like:
      </span>
      <pre class="source-code">
import QtQuick
import QtQuick.Window
Window {
    visible: true
    width: 480;
    height: 320;
    Rectangle {
        id: background;
        anchors.fill: parent;
        color: "blue";
    }
    Text {
        text: qsTr("Hello World");
        anchors.centerIn: parent;
        color: "white";
        font.pointSize: 15;
    }
}</pre>
     </li>
     <li class="calibre14">
      Add the
      <em class="italic">
       color animation
      </em>
      to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker228">
      </a>
      the
      <span>
       <strong class="source-inline1">
        Rectangle
       </strong>
      </span>
      <span>
       object:
      </span>
      <pre class="source-code">
Rectangle {
    id: background;
    anchors.fill: parent;
    color: "blue";
    SequentialAnimation on color {
        ColorAnimation { to: "yellow"; duration: 1000 }
        ColorAnimation { to: "red"; duration: 1000 }
        ColorAnimation { to: "blue"; duration: 1000 }
        loops: Animation.Infinite;
    }
}</pre>
     </li>
     <li class="calibre14">
      Add a
      <em class="italic">
       number animation
      </em>
      to the
      <span>
       <strong class="source-inline1">
        text
       </strong>
      </span>
      <span>
       object:
      </span>
      <pre class="source-code">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
}</pre>
     </li>
     <li class="calibre14">
      Add
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker229">
      </a>
      another
      <em class="italic">
       number animation
      </em>
      <span>
       to it:
      </span>
      <pre class="source-code">
Text {
    text: qsTr("Hello World");
    anchors.centerIn: parent;
    color: "white";
    font.pointSize: 15;
    SequentialAnimation on opacity {
        NumberAnimation { to: 0.0; duration: 200}
        NumberAnimation { to: 1.0; duration: 200}
        loops: Animation.Infinite;
    }
    NumberAnimation on rotation {
        from: 0;
        to: 360;
        duration: 2000;
        loops: Animation.Infinite;
    }
}</pre>
     </li>
     <li class="calibre14">
      Define two
      <em class="italic">
       states
      </em>
      , one called the
      <strong class="source-inline1">
       PRESSED
      </strong>
      state and another called the
      <strong class="source-inline1">
       RELEASED
      </strong>
      state. Then, set
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker230">
      </a>
      the default state
      <span>
       to
      </span>
      <span>
       <strong class="source-inline1">
        RELEASED
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
Rectangle {
    id: background;
    anchors.fill: parent;
    state: "RELEASED";
    states: [
    State {
        name: "PRESSED"
        PropertyChanges { target: background; color: "blue"}
    },
    State {
        name: "RELEASED"
        PropertyChanges { target: background; color: "red"}
    }
    ]
}</pre>
     </li>
     <li class="calibre14">
      After that, create a mouse area within the
      <strong class="source-inline1">
       Rectangle
      </strong>
      object so that we can click
      <span>
       on it:
      </span>
      <pre class="source-code">
MouseArea {
    anchors.fill: parent;
    onPressed: background.state = "PRESSED";
    onReleased: background.state = "RELEASED";
}</pre>
     </li>
     <li class="calibre14">
      Add some transitions to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker231">
      </a>
      the
      <span>
       <strong class="source-inline1">
        Rectangle
       </strong>
      </span>
      <span>
       object:
      </span>
      <pre class="source-code">
transitions: [
    Transition {
        from: "PRESSED"
        to: "RELEASED"
        ColorAnimation { target: background; duration: 200}
    },
    Transition {
        from: "RELEASED"
        to: "PRESSED"
        ColorAnimation { target: background; duration: 200}
}
]</pre>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-79">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor079">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The main window consists of a blue rectangle and static text that says
     <strong class="bold">
      Hello World
     </strong>
     . We want the background color to change from blue to yellow, then to red, and back to blue in a loop. This can be easily achieved by using the
     <em class="italic">
      color animation
     </em>
     type in QML. What we are doing in
     <em class="italic">
      step 3
     </em>
     is basically
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker232">
     </a>
     creating a
     <em class="italic">
      sequential animation group
     </em>
     within the
     <strong class="source-inline">
      Rectangle
     </strong>
     object, then creating three different
     <em class="italic">
      color animations
     </em>
     within the group, which will change the color of the object every 1,000 milliseconds (1 second). We also set the animations to
     <span>
      loop infinitely.
     </span>
    </p>
    <p class="calibre3">
     In
     <em class="italic">
      step 4
     </em>
     , we want to use the
     <em class="italic">
      number animation
     </em>
     to animate the alpha value of the static text. We created another
     <em class="italic">
      sequential animation group
     </em>
     within the
     <strong class="source-inline">
      Text
     </strong>
     object and created two
     <em class="italic">
      number animations
     </em>
     to animate the alpha value from
     <strong class="source-inline">
      0
     </strong>
     to
     <strong class="source-inline">
      1
     </strong>
     and back. Then, we set the animations to
     <span>
      loop infinitely.
     </span>
    </p>
    <p class="calibre3">
     Then, in
     <em class="italic">
      step 5
     </em>
     , we rotate the
     <strong class="source-inline">
      Hello World
     </strong>
     text by adding another
     <strong class="bold">
      number animation
     </strong>
     to it. In
     <em class="italic">
      step 6
     </em>
     , we wanted to make the
     <strong class="source-inline">
      Rectangle
     </strong>
     object change from one color to another when we clicked on it. When the mouse is released, the
     <strong class="source-inline">
      Rectangle
     </strong>
     object will change back to its initial color. To achieve that, we first need to define the two states, one called the
     <strong class="source-inline">
      PRESSED
     </strong>
     state and another called the
     <strong class="source-inline">
      RELEASED
     </strong>
     state. Then, we set the default state
     <span>
      to
     </span>
     <span>
      <strong class="source-inline">
       RELEASED
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     Now, when you compile and run the example, the background will instantly change color to blue when pressed and change back to red when the mouse is released. That works great, and we can further enhance it by giving it a little transition when switching color. This can be easily achieved by adding transitions to the
     <span>
      <strong class="source-inline">
       Rectangle
      </strong>
     </span>
     <span>
      object.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-80">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor080">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     In QML, there are eight different types of property animation you can use, and these are
     <span>
      as follows:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <strong class="bold">
       Anchor animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker233">
      </a>
      changes in
      <span>
       anchor
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker234">
       </a>
      </span>
      <span>
       values
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Color animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker235">
      </a>
      changes
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker236">
      </a>
      in
      <span>
       color values
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Number animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker237">
      </a>
      changes in
      <span>
       qreal-type
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker238">
       </a>
      </span>
      <span>
       values
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Parent animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker239">
      </a>
      changes
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker240">
      </a>
      in
      <span>
       parent values
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Path animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker241">
      </a>
      an item
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker242">
      </a>
      along
      <span>
       a path
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Property animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker243">
      </a>
      changes in
      <span>
       property values
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Rotation animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker244">
      </a>
      changes
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker245">
      </a>
      in
      <span>
       rotation values
      </span>
     </li>
     <li class="calibre14">
      <strong class="bold">
       Vector3d animation
      </strong>
      : Animates
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker246">
      </a>
      changes in
      <span>
       QVector3D
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker247">
       </a>
      </span>
      <span>
       values
      </span>
     </li>
    </ul>
    <p class="calibre3">
     Just like the C++ version, these animations can also be grouped together in an animation group to play the animations in sequence or parallel. You can also control the animations using easing curves and determine when to play these animations using state machines, just like we
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker248">
     </a>
     did in the
     <span>
      previous section.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-81">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor081">
     </a>
     Animating widget properties using animators
    </h1>
    <p class="calibre3">
     In this recipe, we will learn how to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker249">
     </a>
     animate the properties of our GUI
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker250">
     </a>
     widgets using the animator feature that’s provided
     <span>
      by QML.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-82">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor082">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Animating QML objects is really easy if you perform the
     <span>
      following steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a
      <strong class="source-inline1">
       Rectangle
      </strong>
      object and add a
      <em class="italic">
       scale animator
      </em>
      <span>
       to it:
      </span>
      <pre class="source-code">
Rectangle {
    id: myBox;
    width: 50;
    height: 50;
    anchors.horizontalCenter: parent.horizontalCenter;
    anchors.verticalCenter: parent.verticalCenter;
    color: "blue";
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
        running: true;
    }
}</pre>
     </li>
     <li class="calibre14">
      Add a
      <em class="italic">
       rotation animator
      </em>
      and set
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker251">
      </a>
      the
      <strong class="source-inline1">
       running
      </strong>
      value in the parallel animation group, but not in any of
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker252">
      </a>
      the
      <span>
       individual animators:
      </span>
      <pre class="source-code">
ParallelAnimation {
    ScaleAnimator {
        target: myBox;
        from: 5;
        to: 1;
        duration: 2000;
    }
    RotationAnimator {
        target: myBox;
        from: 0;
        to: 360;
        duration: 1000;
    }
    running: true;
}</pre>
     </li>
     <li class="calibre14">
      Add an
      <em class="italic">
       easing curve
      </em>
      to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker253">
      </a>
      the
      <span>
       <em class="italic">
        scale animator
       </em>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
ScaleAnimator {
    target: myBox;
    from: 5;
    to: 1;
    duration: 2000;
    easing.type: Easing.InOutElastic;
    easing.amplitude: 2.0;
    easing.period: 1.5;
    running: true;
}</pre>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-83">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor083">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     The
     <em class="italic">
      animator
     </em>
     type can be used just like any other
     <em class="italic">
      animation
     </em>
     type. We want to scale a rectangle from a size of
     <strong class="source-inline">
      5
     </strong>
     to a size
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker254">
     </a>
     of
     <strong class="source-inline">
      1
     </strong>
     within 2,000 milliseconds (2 seconds). We created a blue
     <strong class="source-inline">
      Rectangle
     </strong>
     object and added a
     <em class="italic">
      scale animator
     </em>
     to it. We set the
     <strong class="source-inline">
      initial
     </strong>
     value to
     <strong class="source-inline">
      5
     </strong>
     and the
     <strong class="source-inline">
      final
     </strong>
     value to
     <strong class="source-inline">
      1
     </strong>
     . Then, we set the animation
     <strong class="source-inline">
      duration
     </strong>
     to
     <strong class="source-inline">
      2000
     </strong>
     and set the
     <strong class="source-inline">
      running
     </strong>
     value to
     <strong class="source-inline">
      true
     </strong>
     so that it will be played when the
     <span>
      program starts.
     </span>
    </p>
    <p class="calibre3">
     Just like the animation types, animators can also be put into
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker255">
     </a>
     groups (that is,
     <strong class="bold">
      parallel
     </strong>
     <strong class="bold">
      animation groups
     </strong>
     or
     <strong class="bold">
      sequential animation groups
     </strong>
     ). An animation group will also be treated as an animator by QtQuick and
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker256">
     </a>
     be run on the scene graph’s rendering thread whenever possible. In step 2, we want to group two different animators into a
     <strong class="bold">
      parallel animation group
     </strong>
     so that they run together at the
     <span>
      same time.
     </span>
    </p>
    <p class="calibre3">
     We will keep the
     <strong class="bold">
      scale animator
     </strong>
     we created previously and add another
     <strong class="bold">
      rotation animator
     </strong>
     to rotate the
     <strong class="bold">
      Rectangle
     </strong>
     object. This time, set the
     <strong class="source-inline">
      running
     </strong>
     value in the parallel animation group, but not in any of the
     <span>
      individual animators.
     </span>
    </p>
    <p class="calibre3">
     Just like the C++ version, QML also supports
     <strong class="bold">
      easing curves
     </strong>
     , and they can be easily applied to any of the animations or
     <span>
      animator types.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-84">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor084">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     There is something called an
     <em class="italic">
      animator
     </em>
     in QML, which
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker257">
     </a>
     is different from the usual
     <em class="italic">
      animation
     </em>
     type, even though there is
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker258">
     </a>
     some similarity between them. Unlike regular animation types, animator types
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker259">
     </a>
     are directly operated on Qt Quick’s
     <strong class="bold">
      scene graph
     </strong>
     , rather than
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker260">
     </a>
     the QML objects and their properties. The value of the QML property will not be changed while the animation is running, as it will only change once the animation is finished. The benefit of using the animator type is that it operates directly
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker261">
     </a>
     on the scene graph’s rendering thread, which means its performance will be slightly better than running on the
     <span>
      <strong class="bold">
       UI thread
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-85">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor085">
     </a>
     Sprite animation
    </h1>
    <p class="calibre3">
     In this example, we will learn how
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker262">
     </a>
     to create a
     <strong class="bold">
      sprite animation
     </strong>
     <span>
      in
     </span>
     <span>
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker263">
      </a>
     </span>
     <span>
      QML.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-86">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor086">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s make a horse run across our application window by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      We will need to add our sprite sheet to Qt’s
      <em class="italic">
       resource system
      </em>
      so that it can be used in the program. Open up
      <strong class="source-inline1">
       qml.qrc
      </strong>
      and click the
      <strong class="bold">
       Add
      </strong>
      |
      <strong class="bold">
       Add Files
      </strong>
      buttons. Select your sprite sheet image and save the resource file by pressing
      <em class="italic">
       Ctrl
      </em>
      +
      <span>
       <em class="italic">
        S
       </em>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      Create a new empty window
      <span>
       in
      </span>
      <span>
       <strong class="source-inline1">
        main.qml
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true
    width: 420
    height: 380
    Rectangle {
        anchors.fill: parent
        color: "white"
    }
}</pre>
     </li>
     <li class="calibre14">
      Once you are done
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker264">
      </a>
      with that, we will start creating
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker265">
      </a>
      an
      <strong class="source-inline1">
       AnimatedSprite
      </strong>
      object
      <span>
       in QML:
      </span>
      <pre class="source-code">
import QtQuick 2.9
import QtQuick.Window 2.3
Window {
    visible: true;
    width: 420;
    height: 380;
    Rectangle {
        anchors.fill: parent;
        color: "white";
     }</pre>
     </li>
     <li class="calibre14">
      Then, set
      <span>
       the following:
      </span>
      <pre class="source-code">
     AnimatedSprite {
         id: sprite;
        width: 128;
        height: 128;
        anchors.centerIn: parent;
         source: "qrc:///horse_1.png";
         frameCount: 11;
         frameWidth: 128;
         frameHeight: 128;
         frameRate: 25;
         loops: Animation.Infinite;
         running: true;
     }
}</pre>
     </li>
     <li class="calibre14">
      Add a
      <em class="italic">
       mouse area
      </em>
      to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker266">
      </a>
      the window and check for the
      <span>
       <strong class="source-inline1">
        onClicked
       </strong>
      </span>
      <span>
       event:
      </span>
      <pre class="source-code">
MouseArea {
    anchors.fill: parent;
    onClicked: {
        if (sprite.paused)
            sprite.resume();
        else
            sprite.pause();
    }
}</pre>
     </li>
     <li class="calibre14">
      If you compile and run
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker267">
      </a>
      the example program now, you will see a little pony running in the middle of the window.
      <span>
       How fun:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer056">
      <img alt="Figure 3.8 – A horse running across the application window" class="calibre4" src="image/B20976_03_008.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 3.8 – A horse running across the application window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="7">
      Next, we want to try and do
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker268">
      </a>
      something cool. We will make the horse run
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker269">
      </a>
      across the window and loop infinitely while playing its running animation! First, we need to remove
      <strong class="source-inline1">
       anchors.centerIn: parent
      </strong>
      from QML and replace it with
      <strong class="source-inline1">
       x
      </strong>
      and
      <span>
       <strong class="source-inline1">
        y
       </strong>
      </span>
      <span>
       values:
      </span>
      <pre class="source-code">
AnimatedSprite {
    id: sprite;
     width: 128;
     height: 128;
     <strong class="bold1">x: -128;</strong>
<strong class="bold1">     y: parent.height / 2;</strong>
     source: "qrc:///horse_1.png";
     frameCount: 11;
     frameWidth: 128;
     frameHeight: 128;
     frameRate: 25;
     loops: Animation.Infinite;
     running: true;
}</pre>
     </li>
     <li class="calibre14">
      Add a
      <em class="italic">
       number animation
      </em>
      to the sprite
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker270">
      </a>
      object and set its properties,
      <span>
       as
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker271">
       </a>
      </span>
      <span>
       follows:
      </span>
      <pre class="source-code">
NumberAnimation {
    target: sprite;
    property: "x";
     from: -128;
     to: 512;
     duration: 3000;
     loops: Animation.Infinite;
     running: true;
}</pre>
     </li>
     <li class="calibre14">
      If you compile and run the example program now, you will see the pony go crazy and start running across
      <span>
       the window!
      </span>
     </li>
    </ol>
    <h2 class="calibre7" id="_idParaDest-87">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor087">
     </a>
     How it works…
    </h2>
    <p class="calibre3">
     In this recipe, we place the animated sprite object in the middle of the window and set its image source to the sprite sheet that we have just added to the project resource. Then, we count how many frames there are in the sprite sheet that belong to the running animation, which in this case is 11 frames. We also inform Qt of the dimensions of each frame of the animation, which in this case are
     <strong class="source-inline">
      128 x 128
     </strong>
     . After that, we set the frame rate to
     <strong class="source-inline">
      25
     </strong>
     to get a decent speed and then set it to loop infinitely. We then set the
     <strong class="source-inline">
      running
     </strong>
     value to
     <strong class="source-inline">
      true
     </strong>
     so that
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker272">
     </a>
     the animation will play by default when the program
     <span>
      starts running.
     </span>
    </p>
    <p class="calibre3">
     Then, in
     <em class="italic">
      step 4
     </em>
     , we want to be
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker273">
     </a>
     able to pause the animation and resume it by clicking on the window. We simply check whether the sprite is currently paused when clicking on the mouse area. If the sprite animation is paused, then the animation resumes; otherwise, the animation
     <span>
      is paused.
     </span>
    </p>
    <p class="calibre3">
     In
     <em class="italic">
      step 6
     </em>
     , we replace
     <strong class="source-inline">
      anchors.centerIn
     </strong>
     with
     <strong class="source-inline">
      x
     </strong>
     and
     <strong class="source-inline">
      y
     </strong>
     values so that the animated sprite object is not anchored to the center of the window, which would make it impossible to move around. Then, we create a
     <em class="italic">
      number animation
     </em>
     within the animated sprite to animate its
     <strong class="source-inline">
      x
     </strong>
     property. We set the
     <strong class="source-inline">
      start
     </strong>
     value to somewhere outside the window on the left side, and we set the
     <strong class="source-inline">
      end
     </strong>
     value to somewhere outside the window on the right side. After that, we set the
     <strong class="source-inline">
      duration
     </strong>
     to 3,000 milliseconds (3 seconds) and make it
     <span>
      loop infinitely.
     </span>
    </p>
    <p class="calibre3">
     Lastly, we also set the
     <strong class="source-inline">
      running
     </strong>
     value to
     <strong class="source-inline">
      true
     </strong>
     so that it plays the animation by default when the program
     <span>
      starts running.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-88">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor088">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     Sprite animation is used extensively, especially in game development. Sprites are used for character animation, particle animation, and even GUI animation. A sprite sheet consists of many images combined into one, which can then be chopped down and displayed on the screen, one at a time. The transitions between different images (or sprites) from the sprite sheet creates the illusion of animation, which we usually refer to as a sprite animation. A Sprite animation can be easily achieved in QML using the
     <span>
      <strong class="source-inline">
       AnimatedSprite
      </strong>
     </span>
     <span>
      type.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     In this example program, I am using a free
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker274">
     </a>
     and open source image that was created by
     <strong class="bold">
      bluecarrot16
     </strong>
     under the
     <em class="italic">
      CC-BY 3.0/GPL 3.0/GPL 2.0/OGA-BY 3.0
     </em>
     license. The image can be obtained legally
     <span>
      at
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="http://opengameart.org/content/lpc-horse">
      <span>
       http://opengameart.org/content/lpc-horse
      </span>
     </a>
     <span>
      .
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
