<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   2Working with Strings and String Views
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_010.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_012.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c02_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c02_1">
      <span aria-label="87" class="calibre17" epub:type="pagebreak" id="Page_87" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c02">
      </span>
      <span class="calibre">
       2
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Working with Strings and String Views
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c02-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c02-list-0001">
         <li class="calibre9" id="c02-li-0001">
          The differences between C-style strings and C++ strings
         </li>
         <li class="calibre9" id="c02-li-0002">
          Details of the C++
          <code class="calibre21">
           std::string
          </code>
          class
         </li>
         <li class="calibre9" id="c02-li-0003">
          Why you should use
          <code class="calibre21">
           std::string_view
          </code>
         </li>
         <li class="calibre9" id="c02-li-0004">
          What raw string literals are
         </li>
         <li class="calibre9" id="c02-li-0005">
          How to produce formatted text
         </li>
         <li class="calibre9" id="c02-li-0006">
          How to format entire ranges of elements to a string
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c02-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-58">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p class="calibre25" id="c02-para-0003">
         Please note all the code examples for this chapter are available as a part of the chapter's code download on this book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c02-para-0004">
      Every program that you write will use strings of some kind. With the old C language, there is not much choice but to use a dumb null-terminated character array to represent a string. Unfortunately, doing so can cause a lot of problems, such as buffer overflows, which can result in security vulnerabilities. The C++ Standard Library includes a safe and easy-to-use
      <code class="calibre21">
       std::string
      </code>
      class that does not have these disadvantages.
     </p>
     <p class="calibre13" id="c02-para-0005">
      Because strings are so important, this chapter, early in the book, discusses them in more detail.
     </p>
    </section>
    <span aria-label="88" class="calibre20" epub:type="pagebreak" id="Page_88" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-59" class="calibre2">
     <span class="calibre" id="c02-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-59">
      DYNAMIC STRINGS
     </h2>
     <p class="calibre13" id="c02-para-0006">
      Strings in languages that have supported them as first-class objects tend to have a number of attractive features, such as being able to expand to any size or to have substrings extracted or replaced. In other languages, such as C, strings were almost an afterthought; there wasn't a really good string data type, just fixed arrays of bytes. The C string library was nothing more than a collection of rather primitive functions without even bounds checking. C++ provides a string type as a first-class data type. Before discussing what C++ provides for strings, let's take a quick look at C-style strings first.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-100">
       C-Style Strings
      </h3>
      <p class="calibre13" id="c02-para-0007">
       In the C language, strings are represented as an array of characters. The last character of a string is a null character (
       <code class="calibre21">
        \0
       </code>
       ) so that code operating on the string can determine where it ends. This null character is officially known as
       <code class="calibre21">
        NUL
       </code>
       , spelled with one L, not two.
       <code class="calibre21">
        NUL
       </code>
       is not the same as the
       <code class="calibre21">
        NULL
       </code>
       pointer. Even though C++ provides a better string abstraction, it is important to understand the C technique for strings because they still arise in C++ programming. One of the most common situations is where a C++ program has to call a C-based interface in some third-party library or as part of interfacing to the operating system.
      </p>
      <p class="calibre13" id="c02-para-0008">
       By far, the most common mistake that programmers make with C strings is that they forget to allocate space for the
       <code class="calibre21">
        \0
       </code>
       character. For example, the string
       <code class="calibre21">
        "hello"
       </code>
       appears to be five characters long, but six characters worth of space are needed in memory to store the value, as shown in
       <a class="calibre5" href="#c02-fig-0001" id="R_c02-fig-0001">
        Figure 2.1
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A table of one row and six columns. The title is my string. The columns include h, e, l, I, o, and forward slash 0." class="center" src="images/c02f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c02-fig-0001" id="c02-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 2.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13">
       C++ contains several functions from the C language that operate on strings. These functions are defined in
       <code class="calibre21">
        &lt;cstring&gt;
       </code>
       . As a general rule of thumb, these functions do not handle memory allocation. For example, the
       <code class="calibre21">
        strcpy()
       </code>
       function takes two strings as parameters. It copies the second string onto the first, whether it fits or not. The following code attempts to build a wrapper around
       <code class="calibre21">
        strcpy()
       </code>
       that allocates the correct amount of memory and returns the result, instead of taking in an already allocated string. This initial attempt will turn out to be wrong! It uses the
       <code class="calibre21">
        strlen()
       </code>
       function to obtain the length of the string. The caller is responsible for freeing the memory allocated by
       <code class="calibre21">
        copyString()
       </code>
       .
      </p>
      <pre class="calibre26" id="c02-code-0001"><code class="calibre21">char* copyString(const char* str)</code>
<code class="calibre21">{</code>
<code class="calibre21">    char* result { new char[strlen(str)] };  // BUG! Off by one!</code>
<code class="calibre21">    strcpy(result, str);</code>
<code class="calibre21">    return result;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        copyString()
       </code>
       function as written is incorrect. The
       <code class="calibre21">
        strlen()
       </code>
       function returns the length of the string, not the amount of memory needed to hold it. For the string
       <code class="calibre21">
        "hello"
       </code>
       ,
       <code class="calibre21">
        strlen()
       </code>
       returns 5, not 6. The proper way to allocate memory for a string is to add 1 to the amount of space needed for the actual characters. It seems a bit unnatural to have +1 all over the place. Unfortunately, that's how it works, so keep this in mind when you work with C-style strings. The correct implementation is as follows:
      </p>
      <pre class="calibre26" id="c02-code-0002"><code class="calibre21">char* copyString(const char* str)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">char* result { new char[strlen(str) + 1] };</b></code>
<span aria-label="89" class="calibre20" epub:type="pagebreak" id="Page_89" role="doc-pagebreak"></span><code class="calibre21">    strcpy(result, str);</code>
<code class="calibre21">    return result;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       One way to remember that
       <code class="calibre21">
        strlen()
       </code>
       returns only the number of actual characters in the string is to consider what would happen if you were allocating space for a string made up of several other strings. For example, if your function took in three strings and returned a string that was the concatenation of all three, how big would it be? To hold exactly enough space, it would be the length of all three strings added together, plus one space for the trailing
       <code class="calibre21">
        \0
       </code>
       character. If
       <code class="calibre21">
        strlen()
       </code>
       included the
       <code class="calibre21">
        \0
       </code>
       in the length of the string, the allocated memory would be too big. The following code uses the
       <code class="calibre21">
        strcpy()
       </code>
       and
       <code class="calibre21">
        strcat()
       </code>
       functions to perform this operation. The
       <code class="calibre21">
        cat
       </code>
       in
       <code class="calibre21">
        strcat()
       </code>
       stands for
       <i class="calibre18">
        concatenate
       </i>
       .
      </p>
      <pre class="calibre26" id="c02-code-0003"><code class="calibre21">char* appendStrings(const char* str1, const char* str2, const char* str3)</code>
<code class="calibre21">{</code>
<code class="calibre21">    char* result { new char[strlen(str1) + strlen(str2) + strlen(str3) + 1] };</code>
<code class="calibre21">    strcpy(result, str1);</code>
<code class="calibre21">    strcat(result, str2);</code>
<code class="calibre21">    strcat(result, str3);</code>
<code class="calibre21">    return result;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        sizeof()
       </code>
       operator in C and C++ can be used to get the size of a certain data type or variable. For example,
       <code class="calibre21">
        sizeof(char)
       </code>
       returns 1 because a
       <code class="calibre21">
        char
       </code>
       has a size of 1 byte. However, in the context of C-style strings,
       <code class="calibre21">
        sizeof()
       </code>
       is not the same as
       <code class="calibre21">
        strlen()
       </code>
       . You should never use
       <code class="calibre21">
        sizeof()
       </code>
       to try to get the size of a string. It returns different sizes depending on how the C-style string is stored. If it is stored as a
       <code class="calibre21">
        char[]
       </code>
       , then
       <code class="calibre21">
        sizeof()
       </code>
       returns the actual memory used by the string, including the
       <code class="calibre21">
        \0
       </code>
       character, as in this example:
      </p>
      <pre class="calibre26" id="c02-code-0004"><code class="calibre21">char text1[] { "abcdef" };</code>
<code class="calibre21">size_t s1 { sizeof(text1) };  <span class="color">// is 7</span></code>
<code class="calibre21">size_t s2 { strlen(text1) };  <span class="color">// is 6</span></code></pre>
      <p class="calibre13">
       However, if the C-style string is stored as a
       <code class="calibre21">
        char*
       </code>
       , then
       <code class="calibre21">
        sizeof()
       </code>
       returns the size of a pointer!
      </p>
      <pre class="calibre26" id="c02-code-0005"><code class="calibre21">const char* text2 { "abcdef" };</code>
<code class="calibre21">size_t s3 { sizeof(text2) };  <span class="color">// is platform-dependent</span></code>
<code class="calibre21">size_t s4 { strlen(text2) };  <span class="color">// is 6</span></code></pre>
      <p class="calibre13" id="c02-para-0014">
       Here,
       <code class="calibre21">
        s3
       </code>
       will be 4 when compiled in 32-bit mode, and 8 when compiled in 64-bit mode because it is returning the size of a
       <code class="calibre21">
        const char*
       </code>
       , which is a pointer.
      </p>
      <p class="calibre13">
       A complete list of functions to operate on C-style strings can be found in the
       <code class="calibre21">
        &lt;cstring&gt;
       </code>
       header file.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c02-para-0016">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           When you use the C-style string functions with Microsoft Visual Studio, the compiler is likely to give you security-related warnings or even errors about these functions being deprecated. You can eliminate these warnings by using other C Standard Library functions, such as
          </i>
          <code class="calibre21">
           strcpy_s()
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           strcat_s()
          </code>
          <i class="calibre18">
           , which are part of the “secure C library” standard (ISO/IEC TR 24731). However, the best solution is to switch to the C++
          </i>
          <code class="calibre21">
           std::string
          </code>
          <i class="calibre18">
           class, discussed in the upcoming “The C++ std::string Class” section, but first a bit more on string literals.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <span aria-label="90" class="calibre20" epub:type="pagebreak" id="Page_90" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0007">
      </span>
      <h3 class="calibre27" id="head-3-101">
       String Literals
      </h3>
      <p class="calibre13">
       You've probably seen strings written in a C++ program with quotes around them. For example, the following code outputs the string
       <code class="calibre21">
        hello
       </code>
       by including the string itself, not a variable that contains it:
      </p>
      <pre class="calibre26" id="c02-code-0006"><code class="calibre21">println("hello");</code></pre>
      <p class="calibre13" id="c02-para-0018">
       In the preceding line,
       <code class="calibre21">
        "hello"
       </code>
       is a
       <i class="calibre18">
        string literal
       </i>
       because it is written as a value, not a variable. String literals are actually stored in a read-only part of memory. This allows the compiler to optimize memory usage by reusing references to equivalent string literals. That is, even if your program uses the string literal
       <code class="calibre21">
        "hello"
       </code>
       500 times, the compiler is allowed to optimize memory by creating just one instance of
       <code class="calibre21">
        hello
       </code>
       in memory. This is called
       <i class="calibre18">
        literal pooling
       </i>
       .
      </p>
      <p class="calibre13">
       String literals can be
       <i class="calibre18">
        assigned
       </i>
       to variables, but because string literals are in a read-only part of memory and because of the possibility of literal pooling, assigning them to variables can be risky. The C++ standard officially says that string literals are of type “array of
       <i class="calibre18">
        n
       </i>
       <code class="calibre21">
        const char
       </code>
       ”; however, for backward compatibility with older non-
       <code class="calibre21">
        const
       </code>
       -aware code, some compilers do not force you to assign a string literal to a variable of type
       <code class="calibre21">
        const char*
       </code>
       . They let you assign a string literal to a
       <code class="calibre21">
        char*
       </code>
       without
       <code class="calibre21">
        const
       </code>
       , and the program will work fine unless you attempt to change the string. Generally, the behavior of modifying string literals is undefined. It could, for example, cause a crash, it could keep working with seemingly inexplicable side effects, the modification could silently be ignored, or it could just work; it all depends on your compiler. For example, the following code exhibits undefined behavior:
      </p>
      <pre class="calibre26" id="c02-code-0007"><code class="calibre21">char* ptr { "hello" };       <span class="color">// Assign the string literal to a variable.</span></code>
<code class="calibre21">ptr[1] = 'a';                <span class="color">// Undefined behavior!</span></code></pre>
      <p class="calibre13">
       A much safer way to code is to use a pointer to
       <code class="calibre21">
        const
       </code>
       characters when referring to string literals. The following code contains the same bug, but because it assigned the literal to a
       <code class="calibre21">
        const char*
       </code>
       , the compiler catches the attempt to write to read-only memory:
      </p>
      <pre class="calibre26" id="c02-code-0008"><code class="calibre21">const char* ptr { "hello" }; <span class="color">// Assign the string literal to a variable.</span></code>
<code class="calibre21">ptr[1] = 'a';                <span class="color">// Error! Attempts to write to read-only memory</span></code></pre>
      <p class="calibre13">
       You can also use a string literal as an initial value for a character array (
       <code class="calibre21">
        char[]
       </code>
       ). In this case, the compiler creates an array that is big enough to hold the string and copies the string to this array. The compiler does not put the literal in read-only memory and does not do any literal pooling.
      </p>
      <pre class="calibre26" id="c02-code-0009"><code class="calibre21">char arr[] { "hello" }; <span class="color">// Compiler takes care of creating appropriate sized</span></code>
<code class="calibre21">                        <span class="color">// character array arr.</span></code>
<code class="calibre21">arr[1] = 'a';           <span class="color">// The contents can be modified.</span></code></pre>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0008">
       </span>
       <h4 class="calibre29" id="head-4-59">
        Raw String Literals
       </h4>
       <p class="calibre13">
        <i class="calibre18">
         Raw string literals
        </i>
        are string literals that can span multiple lines of code, don't require escaping of embedded double quotes, and process escape sequences like
        <code class="calibre21">
         \t
        </code>
        and
        <code class="calibre21">
         \n
        </code>
        as normal text and not as escape sequences. Escape sequences are discussed in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        , “A Crash Course in C++ and the Standard Library.” For example, if you write the following with a normal string literal, you will get a compilation error because the string contains non-escaped double quotes:
       </p>
       <pre class="calibre26" id="c02-code-0010"><code class="calibre21">println("Hello "World"!");    <span class="color">// Error!</span></code></pre>
       <p class="calibre13">
        <span aria-label="91" class="calibre20" epub:type="pagebreak" id="Page_91" role="doc-pagebreak">
        </span>
        Normally you have to escape the double quotes as follows:
       </p>
       <pre class="calibre26" id="c02-code-0011"><code class="calibre21">println("Hello \"World\"!");</code></pre>
       <p class="calibre13">
        With a raw string literal, you can avoid the need to escape the quotes. A raw string literal starts with
        <code class="calibre21">
         R"(
        </code>
        and ends with
        <code class="calibre21">
         )"
        </code>
        :
       </p>
       <pre class="calibre26" id="c02-code-0012"><code class="calibre21">println(R"(Hello "World"!)");</code></pre>
       <p class="calibre13">
        If you need a string consisting of multiple lines, without raw string literals, you need to embed
        <code class="calibre21">
         \n
        </code>
        escape sequences in your string where you want to start a new line. Here's an example:
       </p>
       <pre class="calibre26" id="c02-code-0013"><code class="calibre21">println("Line 1\nLine 2");</code></pre>
       <p class="calibre13">
        The output is as follows:
       </p>
       <pre class="calibre26" id="c02-code-0014"><code class="calibre21">Line 1</code>
<code class="calibre21">Line 2</code></pre>
       <p class="calibre13">
        With a raw string literal, instead of using
        <code class="calibre21">
         \n
        </code>
        escape sequences to start new lines, you can simply press Enter to start real physical new lines in your source code as follows. The output is the same as the previous code snippet using the embedded
        <code class="calibre21">
         \n
        </code>
        .
       </p>
       <pre class="calibre26" id="c02-code-0015"><code class="calibre21">println(R"(Line 1</code>
<code class="calibre21">Line 2)");</code></pre>
       <p class="calibre13">
        Escape sequences are ignored in raw string literals. For example, in the following raw string literal, the
        <code class="calibre21">
         \t
        </code>
        escape sequence is not replaced with a tab character but is kept as the sequence of a backslash followed by the letter
        <code class="calibre21">
         t
        </code>
        :
       </p>
       <pre class="calibre26" id="c02-code-0016"><code class="calibre21">println(R"(Is the following a tab character? \t)");</code></pre>
       <p class="calibre13">
        This outputs the following:
       </p>
       <pre class="calibre26" id="c02-code-0017"><code class="calibre21">Is the following a tab character? \t</code></pre>
       <p class="calibre13">
        Because a raw string literal ends with
        <code class="calibre21">
         )"
        </code>
        , you cannot embed a
        <code class="calibre21">
         )"
        </code>
        in your string using this syntax. For example, the following string is not valid because it contains the
        <code class="calibre21">
         )"
        </code>
        sequence in the middle of the string:
       </p>
       <pre class="calibre26" id="c02-code-0018"><code class="calibre21">println(R"(Embedded )" characters)");    <span class="color">// Error!</span></code></pre>
       <p class="calibre13">
        If you need embedded
        <code class="calibre21">
         )"
        </code>
        characters, you need to use the extended raw string literal syntax, which is as follows:
       </p>
       <pre class="calibre26" id="c02-code-0019"><code class="calibre21">R"d-char-sequence(r-char-sequence)d-char-sequence"</code></pre>
       <p class="calibre13" id="c02-para-0032">
        The
        <code class="calibre21">
         r-char-sequence
        </code>
        is the actual raw string. The
        <code class="calibre21">
         d-char-sequence
        </code>
        is an optional delimiter sequence, which should be the same at the beginning and at the end of the raw string literal. This delimiter sequence can have at most 16 characters. You should choose this delimiter sequence as a sequence that will not appear in the middle of your raw string literal.
       </p>
       <p class="calibre13">
        The previous example can be rewritten using a unique delimiter sequence as follows:
       </p>
       <pre class="calibre26" id="c02-code-0020"><code class="calibre21">println(R"-(Embedded )" characters)-");</code></pre>
       <p class="calibre13" id="c02-para-0034">
        Raw string literals make it easier to work with database querying strings, regular expressions, file paths, and so on. Regular expressions are discussed in
        <a class="calibre5" href="c21.xhtml">
         Chapter 21
        </a>
        , “String Localization and Regular Expressions.”
       </p>
      </section>
     </section>
     <span aria-label="92" class="calibre20" epub:type="pagebreak" id="Page_92" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-102">
       The C++ std::string Class
      </h3>
      <p class="calibre13" id="c02-para-0035">
       C++ provides a much-improved implementation of the concept of a string as part of the Standard Library. In C++,
       <code class="calibre21">
        std::string
       </code>
       is a class (actually an instantiation of the
       <code class="calibre21">
        std::basic_string
       </code>
       class template) that supports many of the same functionalities as the
       <code class="calibre21">
        &lt;cstring&gt;
       </code>
       functions, but that takes care of memory allocations for you. The
       <code class="calibre21">
        string
       </code>
       class is defined in
       <code class="calibre21">
        &lt;string&gt;
       </code>
       and lives in the
       <code class="calibre21">
        std
       </code>
       namespace. It has already been introduced in the previous chapter, but now it's time to take a closer look at it.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0010">
       </span>
       <h4 class="calibre29" id="head-4-60">
        What Is Wrong with C-Style Strings?
       </h4>
       <p class="calibre13">
        To understand the necessity of the C++
        <code class="calibre21">
         string
        </code>
        class, consider the advantages and disadvantages of C-style strings.
       </p>
       <p class="listhead">
        <b class="calibre14">
         Advantages:
        </b>
       </p>
       <ul class="check">
        <li class="calibre9" id="c02-li-0007">
         They are simple, making use of the underlying basic character type and array structure.
        </li>
        <li class="calibre9" id="c02-li-0008">
         They are lightweight, taking up only the memory that they need if used properly.
        </li>
        <li class="calibre9" id="c02-li-0009">
         They are low level, so you can easily manipulate and copy them as raw memory.
        </li>
        <li class="calibre9" id="c02-li-0010">
         If you're a C programmer—why learn something new?
        </li>
       </ul>
       <p class="listhead">
        <b class="calibre14">
         Disadvantages:
        </b>
       </p>
       <ul class="check">
        <li class="calibre9" id="c02-li-0011">
         They require incredible efforts to simulate a first-class string data type.
        </li>
        <li class="calibre9" id="c02-li-0012">
         They are unforgiving and susceptible to difficult-to-find memory bugs.
        </li>
        <li class="calibre9" id="c02-li-0013">
         They don't leverage the object-oriented nature of C++.
        </li>
        <li class="calibre9" id="c02-li-0014">
         They require knowledge of their underlying representation on the part of the programmer.
        </li>
       </ul>
       <p class="calibre13" id="c02-para-0037">
        The preceding lists were carefully constructed to make you think that perhaps there is a better way. As you'll learn, C++
        <code class="calibre21">
         string
        </code>
        s solve all the problems of C-style strings and render most of the arguments about the advantages of C strings over a first-class data type irrelevant.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-61">
        Using the std::string Class
       </h4>
       <p class="calibre13" id="c02-para-0038">
        Even though
        <code class="calibre21">
         string
        </code>
        is a class, you can almost always treat it as if it were a built-in type. In fact, the more you think of it that way, the better off you are. Through the magic of operator overloading, C++
        <code class="calibre21">
         string
        </code>
        s are much easier to use than C-style strings. The next two sections start the discussion by demonstrating how operator overloading makes it easy to concatenate and compare
        <code class="calibre21">
         string
        </code>
        s. Subsequent sections discuss how C++
        <code class="calibre21">
         string
        </code>
        s handle memory, their compatibility with C-style strings, and some of the built-in operations you can perform on
        <code class="calibre21">
         string
        </code>
        s.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0012">
        </span>
        <h5 class="calibre35" id="head-5-17">
         Concatenating Strings
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          +
         </code>
         operator is redefined for
         <code class="calibre21">
          string
         </code>
         s to mean “string concatenation.” The following code produces
         <code class="calibre21">
          1234
         </code>
         :
        </p>
        <pre class="calibre26" id="c02-code-0021"><code class="calibre21">string a { "12" };</code>
<code class="calibre21">string b { "34" };</code>
<code class="calibre21">string c { a + b };    <span class="color">// c is "1234"</span></code></pre>
        <p class="calibre13">
         <span aria-label="93" class="calibre20" epub:type="pagebreak" id="Page_93" role="doc-pagebreak">
         </span>
         The
         <code class="calibre21">
          +=
         </code>
         operator is also overloaded to allow you to easily append a string:
        </p>
        <pre class="calibre26" id="c02-code-0022"><code class="calibre21">a += b;    <span class="color">// a is "1234"</span></code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0013">
        </span>
        <h5 class="calibre35" id="head-5-18">
         Comparing Strings
        </h5>
        <p class="calibre13">
         Another problem with C strings is that you cannot use
         <code class="calibre21">
          ==
         </code>
         to compare them. Suppose you have the following two strings:
        </p>
        <pre class="calibre26" id="c02-code-0023"><code class="calibre21">char* a { "12" };</code>
<code class="calibre21">char b[] { "12" };</code></pre>
        <p class="calibre13">
         Writing a comparison as follows always returns
         <code class="calibre21">
          false
         </code>
         , because it compares the pointer values, not the contents of the strings:
        </p>
        <pre class="calibre26" id="c02-code-0024"><code class="calibre21">if (a == b) { <span class="color">/* … */</span> }</code></pre>
        <p class="calibre13" id="c02-para-0043">
         Note that C arrays and pointers are related. You can think of C arrays, like the
         <code class="calibre21">
          b
         </code>
         array in the example, as pointers to the first element in the array.
         <a class="calibre5" href="c07.xhtml">
          Chapter 7
         </a>
         , “Memory Management,” goes deeper in on the array-pointer duality.
        </p>
        <p class="calibre13">
         To compare C strings, you have to write something like so:
        </p>
        <pre class="calibre26" id="c02-code-0025"><code class="calibre21">if (strcmp(a, b) == 0) { <span class="color">/* … */</span> }</code></pre>
        <p class="calibre13" id="c02-para-0045">
         Furthermore, there is no way to use
         <code class="calibre21">
          &lt;
         </code>
         ,
         <code class="calibre21">
          &lt;=
         </code>
         ,
         <code class="calibre21">
          &gt;=
         </code>
         , or
         <code class="calibre21">
          &gt;
         </code>
         to compare C strings, so
         <code class="calibre21">
          strcmp()
         </code>
         performs a three-way comparison, returning a value less than 0, 0, or a value greater than 0, depending on the lexicographic ordering relationship of the strings. This results in clumsy and hard-to-read code, which is also error-prone.
        </p>
        <p class="calibre13">
         With C++
         <code class="calibre21">
          string
         </code>
         s, comparison operators (
         <code class="calibre21">
          ==
         </code>
         ,
         <code class="calibre21">
          !=
         </code>
         ,
         <code class="calibre21">
          &lt;
         </code>
         , and so on) are all overloaded to work on the actual characters of the
         <code class="calibre21">
          string
         </code>
         . For example:
        </p>
        <pre class="calibre26" id="c02-code-0026"><code class="calibre21">string a { "Hello" };</code>
<code class="calibre21">string b { "World" };</code>
<code class="calibre21">println("'{}' &lt; '{}' = {}", a, b, a &lt; b);  <span class="color">// 'Hello' &lt; 'World' = true</span></code>
<code class="calibre21">println("'{}' &gt; '{}' = {}", a, b, a &gt; b);  <span class="color">// 'Hello' &gt; 'World' = false</span></code></pre>
        <p class="calibre13">
         The C++
         <code class="calibre21">
          string
         </code>
         class additionally provides a
         <code class="calibre21">
          compare()
         </code>
         member function that behaves like
         <code class="calibre21">
          strcmp()
         </code>
         and has a similar return type. Here is an example:
        </p>
        <pre class="calibre26" id="c02-code-0027"><code class="calibre21">string a { "12" };</code>
<code class="calibre21">string b { "34" };</code>
<code class="calibre21"> </code>
<code class="calibre21">auto result { a.compare(b) };</code>
<code class="calibre21">if (result &lt; 0) { println("less"); }</code>
<code class="calibre21">if (result &gt; 0) { println("greater"); }</code>
<code class="calibre21">if (result == 0) { println("equal"); }</code></pre>
        <p class="calibre13">
         Just as with
         <code class="calibre21">
          strcmp()
         </code>
         , this is cumbersome to use. You need to remember the exact meaning of the return value. Furthermore, since the return value is just an integer, it is easy to forget the meaning of this integer and to write the following wrong code to compare for equality:
        </p>
        <pre class="calibre26" id="c02-code-0028"><code class="calibre21">if (a.compare(b)) { println("equal"); }</code></pre>
        <p class="calibre13" id="c02-para-0049">
         <span aria-label="94" class="calibre20" epub:type="pagebreak" id="Page_94" role="doc-pagebreak">
         </span>
         <code class="calibre21">
          compare()
         </code>
         returns 0 for equality, anything else for non-equality. So, this line of code does the opposite of what it was intended to do; that is, it outputs “equal” for non-equal strings! If you just want to check whether two
         <code class="calibre21">
          string
         </code>
         s are equal, do not use
         <code class="calibre21">
          compare()
         </code>
         , but simply
         <code class="calibre21">
          ==
         </code>
         .
        </p>
        <p class="calibre13">
         Since C++20, this is improved with the three-way comparison operator, introduced in
         <a class="calibre5" href="c01_split_000.xhtml">
          Chapter 1
         </a>
         . The
         <code class="calibre21">
          string
         </code>
         class has full support for this operator. Here's an example:
        </p>
        <pre class="calibre26" id="c02-code-0029"><code class="calibre21">auto result { a &lt;=&gt; b };</code>
<code class="calibre21">if (is_gt(result)) { println("greater"); }</code>
<code class="calibre21">if (is_lt(result)) { println("less"); }</code>
<code class="calibre21">if (is_eq(result)) { println("equal"); }</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0014">
        </span>
        <h5 class="calibre35" id="head-5-19">
         Memory Handling
        </h5>
        <p class="calibre13">
         As the following code shows, when
         <code class="calibre21">
          string
         </code>
         operations require extending the
         <code class="calibre21">
          string
         </code>
         , the memory requirements are automatically handled by the
         <code class="calibre21">
          string
         </code>
         class, so memory overruns are a thing of the past. This code snippet also demonstrates that individual characters can be accessed with the square brackets operator,
         <code class="calibre21">
          []
         </code>
         , just as with C-style strings.
        </p>
        <pre class="calibre26" id="c02-code-0030"><code class="calibre21">string myString { "hello" };</code>
<code class="calibre21">myString += ", there";</code>
<code class="calibre21">string myOtherString { myString };</code>
<code class="calibre21">if (myString == myOtherString) {</code>
<code class="calibre21">    myOtherString[0] = 'H';</code>
<code class="calibre21">}</code>
<code class="calibre21">println("{}", myString);</code>
<code class="calibre21">println("{}", myOtherString);</code></pre>
        <p class="calibre13">
         The output of this code is shown here:
        </p>
        <pre class="calibre26" id="c02-code-0031"><code class="calibre21">hello, there</code>
<code class="calibre21">Hello, there</code></pre>
        <p class="calibre13" id="c02-para-0053">
         There are several things to note in this example. One point is that there are no memory leaks even though strings are allocated and resized in a few places. All of these
         <code class="calibre21">
          string
         </code>
         objects are created as stack variables. While the
         <code class="calibre21">
          string
         </code>
         class certainly has a bunch of allocating and resizing to do, the
         <code class="calibre21">
          string
         </code>
         destructors clean up this memory when
         <code class="calibre21">
          string
         </code>
         objects go out of scope. How exactly destructors work is explained in detail in
         <a class="calibre5" href="c08.xhtml">
          Chapter 8
         </a>
         , “Gaining Proficiency with Classes and Objects.”
        </p>
        <p class="calibre13" id="c02-para-0054">
         Another point to note is that the operators work the way you want them to work. For example, the
         <code class="calibre21">
          =
         </code>
         operator copies the strings, which is most likely what you want. If you are used to working with array-based strings, this will be either refreshingly liberating for you or somewhat confusing. Don't worry—once you learn to trust the
         <code class="calibre21">
          string
         </code>
         class to do the right thing, life gets so much easier.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0015">
        </span>
        <h5 class="calibre35" id="head-5-20">
         Compatibility with C-Style Strings
        </h5>
        <p class="calibre13" id="c02-para-0055">
         For compatibility, you can use the
         <code class="calibre21">
          c_str()
         </code>
         member function on a
         <code class="calibre21">
          string
         </code>
         to get a
         <code class="calibre21">
          const char
         </code>
         pointer, representing a C-style string. However, the returned
         <code class="calibre21">
          const
         </code>
         pointer becomes invalid whenever the
         <code class="calibre21">
          string
         </code>
         has to perform any memory reallocation or when the
         <code class="calibre21">
          string
         </code>
         object is destroyed. You should call the member function just before using the result so that it accurately reflects the current contents of the
         <code class="calibre21">
          string
         </code>
         , and you must never return the result of
         <code class="calibre21">
          c_str()
         </code>
         called on a stack-based
         <code class="calibre21">
          string
         </code>
         object from a function.
        </p>
        <p class="calibre13" id="c02-para-0056">
         <span aria-label="95" class="calibre20" epub:type="pagebreak" id="Page_95" role="doc-pagebreak">
         </span>
         There is also a
         <code class="calibre21">
          data()
         </code>
         member function that, up until C++14, always returned a
         <code class="calibre21">
          const char*
         </code>
         just as
         <code class="calibre21">
          c_str()
         </code>
         . Starting with C++17, however,
         <code class="calibre21">
          data()
         </code>
         returns a
         <code class="calibre21">
          char*
         </code>
         when called on a non-
         <code class="calibre21">
          const
         </code>
         string.
        </p>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0016">
        </span>
        <h5 class="calibre35" id="head-5-21">
         Operations on Strings
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          string
         </code>
         class supports quite a few additional operations. The following list highlights a few. Consult a Standard Library Reference (see
         <a class="calibre5" href="b02.xhtml">
          Appendix B
         </a>
         , “Annotated Bibliography”) for a complete list of all supported operations that can be performed on
         <code class="calibre21">
          string
         </code>
         objects.
        </p>
        <ul class="check" id="c02-list-0004">
         <li class="calibre9" id="c02-li-0015">
          <code class="calibre21">
           substr(pos,len)
          </code>
          : Returns the substring that starts at a given position and has a given length
         </li>
         <li class="calibre9" id="c02-li-0016">
          <code class="calibre21">
           find(str)
          </code>
          : Returns the position where a given substring is found, or
          <code class="calibre21">
           string::npos
          </code>
          if not found
         </li>
         <li class="calibre9" id="c02-li-0017">
          <code class="calibre21">
           replace(pos,len,str)
          </code>
          : Replaces part of a string (given by a position and a length) with another string
         </li>
         <li class="calibre9" id="c02-li-0018">
          <code class="calibre21">
           starts_with(str)
          </code>
          /
          <code class="calibre21">
           ends_with(str)
          </code>
          : Returns
          <code class="calibre21">
           true
          </code>
          if a string starts/ends with a given substring
         </li>
         <li class="calibre9" id="c02-li-0019">
          <img alt="C++23" class="calibre15" src="images/icon1.png"/>
          <code class="calibre21">
           contains(str)
          </code>
          /
          <code class="calibre21">
           contains(ch)
          </code>
          : Returns
          <code class="calibre21">
           true
          </code>
          if a
          <code class="calibre21">
           string
          </code>
          contains another
          <code class="calibre21">
           string
          </code>
          or character
         </li>
        </ul>
        <p class="calibre13">
         Here is a small code snippet that shows some of these operations in action:
        </p>
        <pre class="calibre26" id="c02-code-0032"><code class="calibre21">string strHello { "Hello!!" };</code>
<code class="calibre21">string strWorld { "The World…" };</code>
<code class="calibre21">auto position { strHello.find("!!") };</code>
<code class="calibre21">if (position != string::npos) {</code>
<code class="calibre21">    <span class="color">// Found the "!!" substring, now replace it.</span></code>
<code class="calibre21">    strHello.replace(position, 2, strWorld.substr(3, 6));</code>
<code class="calibre21">}</code>
<code class="calibre21">println("{}", strHello);</code>
<code class="calibre21"><span class="color">// Test contains().</span></code>
<code class="calibre21">string toFind { "World" };</code>
<code class="calibre21">println("{}", strWorld.contains(toFind));</code>
<code class="calibre21">println("{}", strWorld.contains('.'));</code>
<code class="calibre21">println("{}", strWorld.contains("Hello"));</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c02-code-0033"><code class="calibre21">Hello World</code>
<code class="calibre21">true</code>
<code class="calibre21">true</code>
<code class="calibre21">false</code></pre>
        <p class="calibre13" id="c02-para-0062">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         Before C++23, it was possible to construct a
         <code class="calibre21">
          string
         </code>
         object by passing
         <code class="calibre21">
          nullptr
         </code>
         to its constructor. This would then result in undefined behavior at run time. Starting with C++23, trying to construct a
         <code class="calibre21">
          string
         </code>
         from
         <code class="calibre21">
          nullptr
         </code>
         results in a compilation error.
        </p>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0017">
       </span>
       <h4 class="calibre29" id="head-4-62">
        std::string Literals
       </h4>
       <p class="calibre13">
        A string literal in source code is usually interpreted as a
        <code class="calibre21">
         const char*
        </code>
        or a
        <code class="calibre21">
         const char[]
        </code>
        . You can use the standard literal
        <code class="calibre21">
         s
        </code>
        to interpret a string literal as an
        <code class="calibre21">
         std::string
        </code>
        instead.
       </p>
       <pre class="calibre26" id="c02-code-0034"><span aria-label="96" class="calibre20" epub:type="pagebreak" id="Page_96" role="doc-pagebreak"></span><code class="calibre21">auto string1 { "Hello World" };    <span class="color">// string1 is a const char*.</span></code>
<code class="calibre21">auto&amp; string2 { "Hello World" };   <span class="color">// string2 is a const char[12].</span></code>
<code class="calibre21">auto string3 { "Hello World"s };   <span class="color">// string3 is an std::string.</span></code></pre>
       <p class="calibre13">
        The standard literal
        <code class="calibre21">
         s
        </code>
        is defined in the
        <code class="calibre21">
         std::literals::string_literals
        </code>
        namespace. However, both the
        <code class="calibre21">
         string_literals
        </code>
        and
        <code class="calibre21">
         literals
        </code>
        namespaces are
        <i class="calibre18">
         inline namespaces
        </i>
        . As such, you have the following options to make those string literals available to your code:
       </p>
       <pre class="calibre26" id="c02-code-0035"><code class="calibre21">using namespace std;</code>
<code class="calibre21">using namespace std::literals;</code>
<code class="calibre21">using namespace std::string_literals;</code>
<code class="calibre21">using namespace std::literals::string_literals;</code></pre>
       <p class="calibre13">
        Basically, everything that is declared in an inline namespace is automatically available in the parent namespace. To define an inline namespace yourself, you use the
        <code class="calibre21">
         inline
        </code>
        keyword. For example, the
        <code class="calibre21">
         string_literals
        </code>
        inline namespace is defined as follows:
       </p>
       <pre class="calibre26" id="c02-code-0036"><code class="calibre21">namespace std {</code>
<code class="calibre21">    inline namespace literals {</code>
<code class="calibre21">        inline namespace string_literals {</code>
<code class="calibre21">            <span class="color">// …</span></code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0018">
       </span>
       <h4 class="calibre29" id="head-4-63">
        CTAD with std::vector and Strings
       </h4>
       <p class="calibre13">
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        explains that
        <code class="calibre21">
         std::vector
        </code>
        supports class template argument deduction (CTAD), allowing the compiler to automatically deduce the type of a
        <code class="calibre21">
         vector
        </code>
        based on an initializer list. You have to be careful when using CTAD for a
        <code class="calibre21">
         vector
        </code>
        of strings. Take the following declaration of a
        <code class="calibre21">
         vector
        </code>
        , for example:
       </p>
       <pre class="calibre26" id="c02-code-0037"><code class="calibre21">vector names { "John", "Sam", "Joe" };</code></pre>
       <p class="calibre13" id="c02-para-0067">
        The deduced type will be
        <code class="calibre21">
         vector&lt;const char*&gt;
        </code>
        , not
        <code class="calibre21">
         vector&lt;string&gt;
        </code>
        ! This is an easy mistake to make and can lead to some strange behavior of your code, or even crashes, depending on what you do with the
        <code class="calibre21">
         vector
        </code>
        afterward.
       </p>
       <p class="calibre13">
        If you want a
        <code class="calibre21">
         vector&lt;string&gt;
        </code>
        , then use
        <code class="calibre21">
         std::string
        </code>
        literals as explained in the previous section. Note the
        <code class="calibre21">
         s
        </code>
        behind each string literal in the following example:
       </p>
       <pre class="calibre26" id="c02-code-0038"><code class="calibre21">vector names { "John"s, "Sam"s, "Joe"s };</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0019">
      </span>
      <h3 class="calibre27" id="head-3-103">
       Numeric Conversions
      </h3>
      <p class="calibre13" id="c02-para-0069">
       The C++ Standard Library provides both high-level and low-level numeric conversion functions, explained in the upcoming sections.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0020">
       </span>
       <h4 class="calibre29" id="head-4-64">
        High-Level Numeric Conversions
       </h4>
       <p class="calibre13" id="c02-para-0070">
        The
        <code class="calibre21">
         std
        </code>
        namespace includes a number of helper functions, defined in
        <code class="calibre21">
         &lt;string&gt;
        </code>
        , that make it easy to convert numerical values into
        <code class="calibre21">
         string
        </code>
        s or
        <code class="calibre21">
         string
        </code>
        s into numerical values.
       </p>
       <span aria-label="97" class="calibre20" epub:type="pagebreak" id="Page_97" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0021">
        </span>
        <h5 class="calibre35" id="head-5-22">
         Converting to Strings
        </h5>
        <p class="calibre13">
         The following functions are available to convert numerical values into
         <code class="calibre21">
          string
         </code>
         s, where
         <i class="calibre18">
          <code class="calibre21">
           T
          </code>
         </i>
         can be (
         <code class="calibre21">
          unsigned
         </code>
         )
         <code class="calibre21">
          int
         </code>
         , (
         <code class="calibre21">
          unsigned
         </code>
         )
         <code class="calibre21">
          long
         </code>
         , (
         <code class="calibre21">
          unsigned
         </code>
         )
         <code class="calibre21">
          long long
         </code>
         ,
         <code class="calibre21">
          float
         </code>
         ,
         <code class="calibre21">
          double
         </code>
         , or
         <code class="calibre21">
          long double
         </code>
         . All of these functions create and return a new
         <code class="calibre21">
          string
         </code>
         object and manage all necessary memory allocations.
        </p>
        <pre class="calibre26" id="c02-code-0039"><code class="calibre21">string to_string(<i class="calibre18">T</i> val);</code></pre>
        <p class="calibre13">
         These functions are straightforward to use. For example, the following code converts a
         <code class="calibre21">
          long double
         </code>
         value into a
         <code class="calibre21">
          string
         </code>
         :
        </p>
        <pre class="calibre26" id="c02-code-0040"><code class="calibre21">long double d { 3.14L };</code>
<code class="calibre21">string s { to_string(d) };  <span class="color">// s contains 3.140000</span></code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0022">
        </span>
        <h5 class="calibre35" id="head-5-23">
         Converting from Strings
        </h5>
        <p class="calibre13">
         Converting in the other direction is done by the following set of functions, also defined in the
         <code class="calibre21">
          std
         </code>
         namespace. In these prototypes,
         <code class="calibre21">
          str
         </code>
         is the
         <code class="calibre21">
          string
         </code>
         that you want to convert,
         <code class="calibre21">
          pos
         </code>
         is a pointer that receives the index of the first unconverted character, and
         <code class="calibre21">
          base
         </code>
         is the mathematical base that should be used during conversion. The
         <code class="calibre21">
          pos
         </code>
         pointer can be
         <code class="calibre21">
          nullptr
         </code>
         , in which case it is ignored. These functions ignore leading whitespace, throw
         <code class="calibre21">
          invalid_argument
         </code>
         if no conversion could be performed, and throw
         <code class="calibre21">
          out_of_range
         </code>
         if the converted value is outside the range of the return type.
        </p>
        <pre class="calibre26" id="c02-code-0041"><code class="calibre21">int stoi(const string&amp; str, size_t *pos = nullptr, int base = 10);</code>
<code class="calibre21">long stol(const string&amp; str, size_t *pos = nullptr, int base = 10);</code>
<code class="calibre21">unsigned long stoul(const string&amp; str, size_t *pos = nullptr, int base = 10);</code>
<code class="calibre21">long long stoll(const string&amp; str, size_t *pos = nullptr, int base = 10);</code>
<code class="calibre21">unsigned long long stoull(const string&amp; str, size_t *pos = nullptr, int base = 10);</code>
<code class="calibre21">float stof(const string&amp; str, size_t *pos = nullptr);</code>
<code class="calibre21">double stod(const string&amp; str, size_t *pos = nullptr);</code>
<code class="calibre21">long double stold(const string&amp; str, size_t *pos = nullptr);</code></pre>
        <p class="calibre13">
         Here is an example:
        </p>
        <pre class="calibre26" id="c02-code-0042"><code class="calibre21">const string toParse { "   123USD" };</code>
<code class="calibre21">size_t index { 0 };</code>
<code class="calibre21">int value { stoi(toParse, &amp;index) };</code>
<code class="calibre21">println("Parsed value: {}", value);</code>
<code class="calibre21">println("First non-parsed character: '{}'", toParse[index]);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c02-code-0043"><code class="calibre21">Parsed value: 123</code>
<code class="calibre21">First non-parsed character: 'U'</code></pre>
        <p class="calibre13">
         <code class="calibre21">
          stoi()
         </code>
         ,
         <code class="calibre21">
          stol()
         </code>
         ,
         <code class="calibre21">
          stoul()
         </code>
         ,
         <code class="calibre21">
          stoll()
         </code>
         , and
         <code class="calibre21">
          stoull()
         </code>
         accept integral values and have a parameter called
         <code class="calibre21">
          base
         </code>
         , which specifies the base in which the given integral value is expressed. A base of 10, the default, assumes the usual decimal numbers, 0–9, while a base of 16 assumes hexadecimal numbers. If the base is set to 0, the function automatically figures out the base of the given number as follows:
        </p>
        <ul class="check" id="c02-list-0006">
         <li class="calibre9" id="c02-li-0020">
          If the number starts with
          <code class="calibre21">
           0x
          </code>
          or
          <code class="calibre21">
           0X
          </code>
          , it is parsed as a hexadecimal number.
         </li>
         <li class="calibre9" id="c02-li-0021">
          If the number starts with
          <code class="calibre21">
           0
          </code>
          , it is parsed as an octal number.
         </li>
         <li class="calibre9" id="c02-li-0022">
          Otherwise, it is parsed as a decimal number.
         </li>
        </ul>
       </section>
      </section>
      <span aria-label="98" class="calibre20" epub:type="pagebreak" id="Page_98" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0023">
       </span>
       <h4 class="calibre29" id="head-4-65">
        Low-Level Numeric Conversions
       </h4>
       <p class="calibre13" id="c02-para-0077">
        The standard also provides a number of lower-level numerical conversion functions, all defined in
        <code class="calibre21">
         &lt;charconv&gt;
        </code>
        . These functions do not perform any memory allocations and do not work directly with
        <code class="calibre21">
         std::string
        </code>
        s, but instead they use raw buffers provided by the caller. Additionally, they are tuned for high performance and are locale-independent (see
        <a class="calibre5" href="c21.xhtml">
         Chapter 21
        </a>
        for details on locales). The end result is that these functions can be orders of magnitude faster than other higher-level numerical conversion functions. These functions are also designed for
        <i class="calibre18">
         perfect round-tripping
        </i>
        , which means that serializing a numerical value to a string representation followed by deserializing the resulting string back to a numerical value results in the exact same value as the original one.
       </p>
       <p class="calibre13" id="c02-para-0078">
        You should use these functions if you want highly performant, perfect round-tripping, locale-independent conversions, for example to serialize/deserialize numerical data to/from human-readable formats such as JSON, XML, and so on.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0024">
        </span>
        <h5 class="calibre35" id="head-5-24">
         Converting to Strings
        </h5>
        <p class="calibre13">
         For converting integers to characters, the following set of functions is available:
        </p>
        <pre class="calibre26" id="c02-code-0044"><code class="calibre21">to_chars_result to_chars(char* first, char* last, <i class="calibre18">IntegerT</i> value, int base = 10);</code></pre>
        <p class="calibre13">
         Here,
         <i class="calibre18">
          <code class="calibre21">
           IntegerT
          </code>
         </i>
         can be any signed or unsigned integer type or
         <code class="calibre21">
          char
         </code>
         . The result is of type
         <code class="calibre21">
          to_chars_result
         </code>
         , a type defined as follows:
        </p>
        <pre class="calibre26" id="c02-code-0045"><code class="calibre21">struct to_chars_result {</code>
<code class="calibre21">    char* ptr;</code>
<code class="calibre21">    errc ec;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c02-para-0081">
         The
         <code class="calibre21">
          ptr
         </code>
         member is either equal to the one-past-the-end pointer of the written characters if the conversion was successful or equal to
         <code class="calibre21">
          last
         </code>
         if the conversion failed (in which case
         <code class="calibre21">
          ec == errc::value_too_large
         </code>
         ). If
         <code class="calibre21">
          ec
         </code>
         is equal to a default constructed
         <code class="calibre21">
          errc
         </code>
         , then the conversion was successful.
        </p>
        <p class="calibre13">
         Here is an example of its use:
        </p>
        <pre class="calibre26" id="c02-code-0046"><code class="calibre21">const size_t BufferSize { 50 };</code>
<code class="calibre21">string out(BufferSize, ' '); <span class="color">// A string of BufferSize space characters.</span></code>
<code class="calibre21">auto result { to_chars(out.data(), out.data() + out.size(), 12345) };</code>
<code class="calibre21">if (result.ec == errc{}) { println("{}", out); <span class="color">/* Conversion successful. */</span> }</code></pre>
        <p class="calibre13">
         Using structured bindings introduced in
         <a class="calibre5" href="c01_split_000.xhtml">
          Chapter 1
         </a>
         , you can write it as follows:
        </p>
        <pre class="calibre26" id="c02-code-0047"><code class="calibre21">string out(BufferSize, ' '); <span class="color">// A string of BufferSize space characters.</span></code>
<code class="calibre21">auto [ptr, error] { to_chars(out.data(), out.data() + out.size(), 12345) };</code>
<code class="calibre21">if (error == errc{}) { println("{}", out); <span class="color">/* Conversion successful. */</span> }</code></pre>
        <p class="calibre13">
         Similarly, the following set of conversion functions is available for floating-point types:
        </p>
        <pre class="calibre26" id="c02-code-0048"><code class="calibre21">to_chars_result to_chars(char* first, char* last, <i class="calibre18">FloatT</i> value);</code>
<code class="calibre21">to_chars_result to_chars(char* first, char* last, <i class="calibre18">FloatT</i> value,</code>
<code class="calibre21">                         chars_format format);</code>
<code class="calibre21">to_chars_result to_chars(char* first, char* last, <i class="calibre18">FloatT</i> value,</code>
<code class="calibre21">                         chars_format format, int precision);</code></pre>
        <p class="calibre13">
         <span aria-label="99" class="calibre20" epub:type="pagebreak" id="Page_99" role="doc-pagebreak">
         </span>
         Here,
         <i class="calibre18">
          <code class="calibre21">
           FloatT
          </code>
         </i>
         can be any floating-point type, e.g.,
         <code class="calibre21">
          float
         </code>
         ,
         <code class="calibre21">
          double
         </code>
         , or
         <code class="calibre21">
          long double
         </code>
         . Formatting can be specified with a combination of
         <code class="calibre21">
          chars_format
         </code>
         flags.
        </p>
        <pre class="calibre26" id="c02-code-0049"><code class="calibre21">enum class chars_format {</code>
<code class="calibre21">    scientific,                  <span class="color">// Style: (-)d.ddde±dd</span></code>
<code class="calibre21">    fixed,                       <span class="color">// Style: (-)ddd.ddd</span></code>
<code class="calibre21">    hex,                         <span class="color">// Style: (-)h.hhhp±d (Note: no 0x!)</span></code>
<code class="calibre21">    general = fixed | scientific <span class="color">// See next paragraph.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         The default format is
         <code class="calibre21">
          chars_format::general
         </code>
         , which causes
         <code class="calibre21">
          to_chars()
         </code>
         to convert the floating-point value to a decimal notation in the style of
         <i class="calibre18">
          (-)ddd.ddd
         </i>
         or to a decimal exponent notation in the style of
         <i class="calibre18">
          (-)d.ddde±dd
         </i>
         , whichever results in the shortest representation with at least one digit before the decimal point (if present). If a format but no precision is specified, the precision is automatically determined to result in the shortest possible representation for the given format, with a maximum precision of six digits. Here is an example:
        </p>
        <pre class="calibre26" id="c02-code-0050"><code class="calibre21">double value { 0.314 };</code>
<code class="calibre21">string out(BufferSize, ' '); <span class="color">// A string of BufferSize space characters.</span></code>
<code class="calibre21">auto [ptr, error] { to_chars(out.data(), out.data() + out.size(), value) };</code>
<code class="calibre21">if (error == errc{}) { println("{}", out); <span class="color">/* Conversion successful. */</span> }</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c02-sec-0025">
        </span>
        <h5 class="calibre35" id="head-5-25">
         Converting from Strings
        </h5>
        <p class="calibre13">
         For the opposite conversion—that is, converting character sequences into numerical values—the following set of functions is available
         <a aria-describedby="c02-note-0001" class="calibre5" epub:type="noteref" href="#c02-note-0001" id="R_c02-note-0001" role="doc-noteref">
          <sup class="calibre22">
           1
          </sup>
         </a>
         :
        </p>
        <pre class="calibre26" id="c02-code-0051"><code class="calibre21">from_chars_result from_chars(const char* first, const char* last, <i class="calibre18">IntegerT</i>&amp; value,</code>
<code class="calibre21">                             int base = 10);</code>
<code class="calibre21">from_chars_result from_chars(const char* first, const char* last, <i class="calibre18">FloatT</i>&amp; value,</code>
<code class="calibre21">                             chars_format format = chars_format::general);</code></pre>
        <p class="calibre13">
         Here,
         <code class="calibre21">
          from_chars_result
         </code>
         is a type defined as follows:
        </p>
        <pre class="calibre26" id="c02-code-0052"><code class="calibre21">struct from_chars_result {</code>
<code class="calibre21">    const char* ptr;</code>
<code class="calibre21">    errc ec;</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c02-para-0089">
         The
         <code class="calibre21">
          ptr
         </code>
         member of the result type is a pointer to the first character that was not converted, or it equals
         <code class="calibre21">
          last
         </code>
         if all characters were successfully converted. If none of the characters could be converted,
         <code class="calibre21">
          ptr
         </code>
         equals
         <code class="calibre21">
          first
         </code>
         , and the value of the error code will be
         <code class="calibre21">
          errc::invalid_argument
         </code>
         . If the parsed value is too large to be representable by the given type, the value of the error code will be
         <code class="calibre21">
          errc::result_out_of_range
         </code>
         . Note that
         <code class="calibre21">
          from_chars()
         </code>
         does not skip any leading whitespace.
        </p>
        <p class="calibre13">
         The perfect round-tripping feature of
         <code class="calibre21">
          to_chars()
         </code>
         and
         <code class="calibre21">
          from_chars()
         </code>
         can be demonstrated as follows:
        </p>
        <pre class="calibre26" id="c02-code-0053"><code class="calibre21">double value1 { 0.314 };</code>
<code class="calibre21">string out(BufferSize, ' '); <span class="color">// A string of BufferSize space characters.</span></code>
<code class="calibre21">auto [ptr1, error1] { to_chars(out.data(), out.data() + out.size(), value1) };</code>
<code class="calibre21">if (error1 == errc{}) { println("{}", out); <span class="color">/* Conversion successful. */</span> }</code>
<code class="calibre21"> </code>
<span aria-label="100" class="calibre20" epub:type="pagebreak" id="Page_100" role="doc-pagebreak"></span><code class="calibre21">double value2;</code>
<code class="calibre21">auto [ptr2, error2] { from_chars(out.data(), out.data() + out.size(), value2) };</code>
<code class="calibre21">if (error2 == errc{}) {</code>
<code class="calibre21">    if (value1 == value2) {</code>
<code class="calibre21">        println("Perfect roundtrip");</code>
<code class="calibre21">    } else {</code>
<code class="calibre21">        println("No perfect roundtrip?!?");</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0026">
      </span>
      <h3 class="calibre27" id="head-3-104">
       The std::string_view Class
      </h3>
      <p class="calibre13" id="c02-para-0091">
       Before C++17, there was always a dilemma of choosing the parameter type for a function that accepted a read-only string. Should it be a
       <code class="calibre21">
        const char*
       </code>
       ? In that case, if a client had an
       <code class="calibre21">
        std::string
       </code>
       available, they had to call
       <code class="calibre21">
        c_str()
       </code>
       or
       <code class="calibre21">
        data()
       </code>
       on it to get a
       <code class="calibre21">
        const char*
       </code>
       . Even worse, the function would lose the nice object-oriented aspects of
       <code class="calibre21">
        string
       </code>
       and all its nice helper member functions. Maybe the parameter could instead be a
       <code class="calibre21">
        const string&amp;
       </code>
       ? In that case, you always needed a
       <code class="calibre21">
        string
       </code>
       . If you passed a string literal, for example, the compiler silently created a temporary
       <code class="calibre21">
        string
       </code>
       object that contained a copy of your string literal and passed a reference to that object to your function, so there was a bit of overhead. Sometimes people would write multiple overloads of the same function—one that accepted a
       <code class="calibre21">
        const char*
       </code>
       and another that accepted a
       <code class="calibre21">
        const string&amp;
       </code>
       —but that was obviously a less-than-elegant solution.
      </p>
      <p class="calibre13" id="c02-para-0092">
       Since C++17, all those problems are solved with the introduction of the
       <code class="calibre21">
        std::string_view
       </code>
       class, which is an instantiation of the
       <code class="calibre21">
        std::basic_string_view
       </code>
       class template, and defined in
       <code class="calibre21">
        &lt;string_view&gt;
       </code>
       . A
       <code class="calibre21">
        string_view
       </code>
       is basically a drop-in replacement for
       <code class="calibre21">
        const string&amp;
       </code>
       but without the overhead. It never copies strings! A
       <code class="calibre21">
        string_view
       </code>
       provides a read-only view of a string and supports an interface similar to
       <code class="calibre21">
        string
       </code>
       , including the
       <code class="calibre21">
        contains()
       </code>
       member function introduced in C++23. One exception is the absence of
       <code class="calibre21">
        c_str()
       </code>
       , but
       <code class="calibre21">
        data()
       </code>
       is available. On the other hand,
       <code class="calibre21">
        string_view
       </code>
       does add the member functions
       <code class="calibre21">
        remove_prefix(size_t)
       </code>
       and
       <code class="calibre21">
        remove_suffix(size_t)
       </code>
       , which shrink a string by advancing the starting pointer by a given offset or by moving the end pointer backward by a given offset. Just like for
       <code class="calibre21">
        string
       </code>
       , starting with C++23, constructing a
       <code class="calibre21">
        string_view
       </code>
       from
       <code class="calibre21">
        nullptr
       </code>
       results in a compilation error.
      </p>
      <p class="calibre13">
       If you know how to use
       <code class="calibre21">
        std::string
       </code>
       , then using a
       <code class="calibre21">
        string_view
       </code>
       is straightforward, as the following example code demonstrates. The
       <code class="calibre21">
        extractExtension()
       </code>
       function extracts and returns from a given filename the extension including the dot character. Note that
       <code class="calibre21">
        string_view
       </code>
       s are usually passed by value because they are extremely cheap to copy. They just contain a pointer to, and the length of, a string. The
       <code class="calibre21">
        rfind()
       </code>
       member function searches a string for another given string or character starting from the back. The
       <code class="calibre21">
        substr()
       </code>
       member function called on a
       <code class="calibre21">
        string_view
       </code>
       returns a
       <code class="calibre21">
        string_view
       </code>
       , which is passed to a
       <code class="calibre21">
        string
       </code>
       constructor to convert it to a
       <code class="calibre21">
        string
       </code>
       and then returned from the function.
      </p>
      <pre class="calibre26" id="c02-code-0054"><code class="calibre21">string extractExtension(string_view filename)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Return a copy of the extension.</span></code>
<code class="calibre21">    return string { filename.substr(filename.rfind('.')) };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <span aria-label="101" class="calibre20" epub:type="pagebreak" id="Page_101" role="doc-pagebreak">
       </span>
       This function can be used with all kinds of different strings:
      </p>
      <pre class="calibre26" id="c02-code-0055"><code class="calibre21">string filename { R"(c:\temp\my file.ext)" };</code>
<code class="calibre21">println("C++ string: {}", extractExtension(filename));</code>
<code class="calibre21"> </code>
<code class="calibre21">const char* cString { R"(c:\temp\my file.ext)" };</code>
<code class="calibre21">println("C string: {}", extractExtension(cString));</code>
<code class="calibre21"> </code>
<code class="calibre21">println("Literal: {}", extractExtension(R"(c:\temp\my file.ext)"));</code></pre>
      <p class="calibre13" id="c02-para-0095">
       There is not a single copy of the argument being made in all these calls to
       <code class="calibre21">
        extractExtension()
       </code>
       . The
       <code class="calibre21">
        filename
       </code>
       parameter of the
       <code class="calibre21">
        extractExtension()
       </code>
       function is just a pointer and a length. This is all very efficient.
      </p>
      <p class="calibre13">
       There is also a
       <code class="calibre21">
        string_view
       </code>
       constructor that accepts any raw buffer and a length. This can be used to construct a
       <code class="calibre21">
        string_view
       </code>
       out of a string buffer that is not
       <code class="calibre21">
        NUL
       </code>
       (
       <code class="calibre21">
        \0
       </code>
       ) terminated. It is also useful when you do have a
       <code class="calibre21">
        NUL
       </code>
       -terminated string buffer, but you already know the length of the string, so the
       <code class="calibre21">
        string_view
       </code>
       constructor does not need to count the number of characters again. Here is an example:
      </p>
      <pre class="calibre26" id="c02-code-0056"><code class="calibre21">const char* raw { <span class="color">/* … */</span> };</code>
<code class="calibre21">size_t length { <span class="color">/* … */</span> };</code>
<code class="calibre21">println("Raw: {}", extractExtension(<b class="calibre14">{ raw, length }</b>));</code></pre>
      <p class="calibre13">
       The last line can also be written more explicitly as follows:
      </p>
      <pre class="calibre26" id="c02-code-0057"><code class="calibre21">println("Raw: {}", extractExtension(<b class="calibre14">string_view { raw, length }</b>));</code></pre>
      <p class="calibre13">
       Finally, you can also construct a
       <code class="calibre21">
        string_view
       </code>
       from a common range, which is a range based on iterators and, since C++23, from a modern range. Iterators, common ranges, and modern ranges are discussed in
       <a class="calibre5" href="c17.xhtml">
        Chapter 17
       </a>
       , “Understanding Iterators and the Ranges Library.”
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c02-para-0099">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Use an
          </i>
          <code class="calibre21">
           std::string_view
          </code>
          <i class="calibre18">
           instead of
          </i>
          <code class="calibre21">
           const string&amp;
          </code>
          <i class="calibre18">
           or
          </i>
          <code class="calibre21">
           const char*
          </code>
          <i class="calibre18">
           whenever a function requires a read-only string as one of its parameters.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       You cannot implicitly construct a
       <code class="calibre21">
        string
       </code>
       from a
       <code class="calibre21">
        string_view
       </code>
       . This is prohibited to prevent accidentally copying the string in a
       <code class="calibre21">
        string_view
       </code>
       , as constructing a
       <code class="calibre21">
        string
       </code>
       from a
       <code class="calibre21">
        string_view
       </code>
       always involves copying the data. To convert a
       <code class="calibre21">
        string_view
       </code>
       to a
       <code class="calibre21">
        string
       </code>
       , use an explicit
       <code class="calibre21">
        string
       </code>
       constructor. That is exactly what the
       <code class="calibre21">
        return
       </code>
       statement in
       <code class="calibre21">
        extractExtension()
       </code>
       does:
      </p>
      <pre class="calibre26" id="c02-code-0058"><code class="calibre21">return <b class="calibre14">string</b> { filename.substr(filename.rfind('.')) };</code></pre>
      <p class="calibre13">
       For the same reason, you cannot concatenate a
       <code class="calibre21">
        string
       </code>
       and a
       <code class="calibre21">
        string_view
       </code>
       . The following code does not compile:
      </p>
      <pre class="calibre26" id="c02-code-0059"><code class="calibre21">string str { "Hello" };</code>
<code class="calibre21">string_view sv { " world" };</code>
<code class="calibre21">auto result { str + sv };  <span class="color">// Error, does not compile!</span></code></pre>
      <p class="calibre13">
       <span aria-label="102" class="calibre20" epub:type="pagebreak" id="Page_102" role="doc-pagebreak">
       </span>
       Instead, convert the
       <code class="calibre21">
        string_view
       </code>
       to a
       <code class="calibre21">
        string
       </code>
       using a
       <code class="calibre21">
        string
       </code>
       constructor:
      </p>
      <pre class="calibre26" id="c02-code-0060"><code class="calibre21">auto result1 { str + <b class="calibre14">string</b> { sv } };</code></pre>
      <p class="calibre13">
       Or, use
       <code class="calibre21">
        append()
       </code>
       :
      </p>
      <pre class="calibre26" id="c02-code-0061"><code class="calibre21">string result2 { str };</code>
<code class="calibre21">result2.append(sv.data(), sv.size());</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c02-para-0105">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Functions returning a string should return a
          </i>
          <code class="calibre21">
           const string&amp;
          </code>
          <i class="calibre18">
           or a
          </i>
          <code class="calibre21">
           string
          </code>
          <i class="calibre18">
           , but not a
          </i>
          <code class="calibre21">
           string_view
          </code>
          <i class="calibre18">
           . Returning a
          </i>
          <code class="calibre21">
           string_view
          </code>
          <i class="calibre18">
           would introduce the risk of invalidating the returned
          </i>
          <code class="calibre21">
           string_view
          </code>
          <i class="calibre18">
           if, for example, the string to which it refers needs to reallocate.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c02-para-0106">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Storing a
          </i>
          <code class="calibre21">
           const string&amp;
          </code>
          <i class="calibre18">
           or a
          </i>
          <code class="calibre21">
           string_view
          </code>
          <i class="calibre18">
           as a data member of a class requires you to make sure the string to which they refer stays alive for the duration of the object's lifetime. It's strongly recommended to store an
          </i>
          <code class="calibre21">
           std::string
          </code>
          <i class="calibre18">
           instead.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-66">
        std::string_view and Temporary Strings
       </h4>
       <p class="calibre13">
        A
        <code class="calibre21">
         string_view
        </code>
        should not be used to store a view of a temporary string. Take the following example:
       </p>
       <pre class="calibre26" id="c02-code-0062"><code class="calibre21">string s { "Hello" };</code>
<code class="calibre21">string_view sv { s + " World!" };</code>
<code class="calibre21">println("{}", sv);</code></pre>
       <p class="calibre13">
        This code snippet has undefined behavior, i.e., what happens when running this code depends on your compiler and compiler settings. It might crash, it might print “ello World!” (without the letter
        <i class="calibre18">
         H
        </i>
        ), and so on. Why is this undefined behavior? The initializer expression for the
        <code class="calibre21">
         sv string_
        </code>
        view results in a temporary string with the “Hello World!” contents. The
        <code class="calibre21">
         string_view
        </code>
        then stores a pointer to this temporary string. At the end of the second line of code, this temporary string is destroyed, leaving the
        <code class="calibre21">
         string_view
        </code>
        with a dangling pointer.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c02-para-0109">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Never use
           </i>
           <code class="calibre21">
            std::string_view
           </code>
           <i class="calibre18">
            to store a view of temporary strings.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0032">
       </span>
       <h4 class="calibre29" id="head-4-67">
        std::string_view Literals
       </h4>
       <p class="calibre13">
        You can use the standard literal
        <code class="calibre21">
         sv
        </code>
        to interpret a string literal as an
        <code class="calibre21">
         std::string_view
        </code>
        . Here's an example:
       </p>
       <pre class="calibre26" id="c02-code-0063"><code class="calibre21">auto sv { "My string_view"sv };</code></pre>
       <p class="calibre13">
        <span aria-label="103" class="calibre20" epub:type="pagebreak" id="Page_103" role="doc-pagebreak">
        </span>
        The standard literal
        <code class="calibre21">
         sv
        </code>
        requires one of the following
        <code class="calibre21">
         using
        </code>
        directives:
       </p>
       <pre class="calibre26" id="c02-code-0064"><code class="calibre21">using namespace std::literals::string_view_literals;</code>
<code class="calibre21">using namespace std::string_view_literals;</code>
<code class="calibre21">using namespace std::literals;</code>
<code class="calibre21">using namespace std;</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0033">
      </span>
      <h3 class="calibre27" id="head-3-105">
       Nonstandard Strings
      </h3>
      <p class="calibre13" id="c02-para-0112">
       There are several reasons why many C++ programmers don't use C++-style strings. Some programmers simply aren't aware of the
       <code class="calibre21">
        string
       </code>
       type because it was not always part of the C++ specification. Others have discovered over the years that the C++
       <code class="calibre21">
        string
       </code>
       doesn't provide the behavior they need or dislike the fact that
       <code class="calibre21">
        std::string
       </code>
       is totally agnostic about the character encoding and so have developed their own string type.
       <a class="calibre5" href="c21.xhtml">
        Chapter 21
       </a>
       returns to the topic of character encodings.
      </p>
      <p class="calibre13">
       Perhaps the most common reason is that development frameworks and operating systems tend to have their own way of representing strings, such as the
       <code class="calibre21">
        CString
       </code>
       class in the Microsoft MFC framework. Often, this is for backward compatibility or to address legacy issues. When starting a project in C++, it is important to decide ahead of time how your group will represent strings. Some things are for sure:
      </p>
      <ul class="check" id="c02-list-0007">
       <li class="calibre9" id="c02-li-0023">
        You should never pick the C-style string representation.
       </li>
       <li class="calibre9" id="c02-li-0024">
        You can standardize on the string functionality available in the framework you are using, such as the built-in string features of MFC, Qt, and so on.
       </li>
       <li class="calibre9" id="c02-li-0025">
        If you use
        <code class="calibre21">
         std::string
        </code>
        for your strings, then use
        <code class="calibre21">
         std::string_view
        </code>
        to pass read-only strings to functions; otherwise, see if your framework has support for something similar like
        <code class="calibre21">
         string_view
        </code>
        s.
       </li>
      </ul>
     </section>
    </section>
    <section aria-labelledby="head-2-60" class="calibre2">
     <span class="calibre" id="c02-sec-0034">
     </span>
     <h2 class="calibre6" id="head-2-60">
      FORMATTING AND PRINTING STRINGS
     </h2>
     <p class="calibre13">
      Up until C++20, formatting of strings was usually done with C-style functions like
      <code class="calibre21">
       printf()
      </code>
      or with C++ I/O streams such as
      <code class="calibre21">
       std::cout
      </code>
      :
     </p>
     <ul class="check" id="c02-list-0008">
      <li class="calibre9" id="c02-li-0026">
       C-style functions:
       <ul class="check3" id="c02-list-0009">
        <li class="calibre9" id="c02-li-0027">
         Not recommended because they are not type safe and are not extensible to support your own custom types
        </li>
        <li class="calibre9" id="c02-li-0028">
         Easy to read because of separation of format string and arguments, and hence easy to translate to different languages
        </li>
        <li class="calibre9" id="c02-li-0029">
         For example:
        </li>
       </ul>
      </li>
     </ul>
     <pre class="calibre26" id="c02-code-0065"><code class="calibre21">printf("x has value %d and y has value %d.\n", x, y);</code></pre>
     <ul class="check" id="c02-list-0010">
      <li class="calibre9" id="c02-li-0030">
       C++ I/O streams:
       <ul class="check3" id="c02-list-0011">
        <li class="calibre9" id="c02-li-0031">
         Recommended (before C++20) because they are type safe and extensible
        </li>
        <li class="calibre9" id="c02-li-0032">
         <span aria-label="104" class="calibre20" epub:type="pagebreak" id="Page_104" role="doc-pagebreak">
         </span>
         Harder to read because the strings and arguments are intertwined, and hence harder to translate
        </li>
        <li class="calibre9" id="c02-li-0033">
         For example:
        </li>
       </ul>
      </li>
     </ul>
     <pre class="calibre26" id="c02-code-0066"><code class="calibre21">cout &lt;&lt; "x has value " &lt;&lt; x &lt;&lt; " and y has value " &lt;&lt; y &lt;&lt; '.' &lt;&lt; endl;</code></pre>
     <p class="calibre13">
      C++20 introduced
      <code class="calibre21">
       std::format()
      </code>
      , defined in
      <code class="calibre21">
       &lt;format&gt;
      </code>
      , to format strings. It basically combines all advantages of the C-style functions and the C++ I/O streams. It's a type-safe and extensible formatting mechanism. For example:
     </p>
     <pre class="calibre26" id="c02-code-0067"><code class="calibre21">cout &lt;&lt; format("x has value {} and y has value {}.", x, y) &lt;&lt; endl;</code></pre>
     <p class="calibre13">
      C++23 makes it even easier with the introduction of
      <code class="calibre21">
       std::print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      . For example:
     </p>
     <pre class="calibre26" id="c02-code-0068"><code class="calibre21">println("x has value {} and y has value {}.", x, y);</code></pre>
     <p class="calibre13">
      Additionally,
      <code class="calibre21">
       std::print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      have better support for writing UTF-8 Unicode text to Unicode-compliant consoles. Unicode is discussed in
      <a class="calibre5" href="c21.xhtml">
       Chapter 21
      </a>
      , but here's a quick example:
     </p>
     <pre class="calibre26" id="c02-code-0069"><code class="calibre21">println("こんにちは世界");</code></pre>
     <p class="calibre13">
      This correctly prints the string “こんにちは世界”, which is Japanese for “Hello World,” to the console.
      <a aria-describedby="c02-note-0002" class="calibre5" epub:type="noteref" href="#c02-note-0002" id="R_c02-note-0002" role="doc-noteref">
       <sup class="calibre22">
        2
       </sup>
      </a>
      If you try to print this string using C++ I/O streams as follows, depending on your console settings, the output can be something garbled such as “πüôπéôπü½πüíπü»Σ╕ûτòî”:
     </p>
     <pre class="calibre26" id="c02-code-0070"><code class="calibre21">cout &lt;&lt; "こんにちは世界" &lt;&lt; endl;</code></pre>
     <p class="calibre13">
      Thanks to the Unicode support, you can even print emojis. The following prints a smiley if your output console properly supports Unicode. Using
      <code class="calibre21">
       cout
      </code>
      for this would likely result in garbled output.
     </p>
     <pre class="calibre26" id="c02-code-0071"><code class="calibre21">println("😀");</code></pre>
     <p class="calibre13" id="c02-para-0123">
      <code class="calibre21">
       std::print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      are now the recommended ways to write text to the console; thus, they're used throughout all the examples in this book. They are type safe, are extensible to support user types, are easy to read, support Unicode output, support localization to different languages, and so on. On top of all those benefits, the performance of
      <code class="calibre21">
       print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      is also much better compared to doing the same using C++ I/O streams directly, even though, underneath,
      <code class="calibre21">
       print()
      </code>
      and
      <code class="calibre21">
       println()
      </code>
      are still using such streams.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0035">
      </span>
      <h3 class="calibre27" id="head-3-106">
       Format Strings
      </h3>
      <p class="calibre13" id="c02-para-0124">
       <code class="calibre21">
        std::format()
       </code>
       ,
       <code class="calibre21">
        print()
       </code>
       , and
       <code class="calibre21">
        println()
       </code>
       use a
       <i class="calibre18">
        format string
       </i>
       , a string specifying how the given arguments must be formatted in the output string. Its basic form is introduced in the previous chapter and already used throughout examples. Now it's time to look at how powerful these format strings really are.
      </p>
      <p class="calibre13" id="c02-para-0125">
       The format string is usually the first argument to
       <code class="calibre21">
        format()
       </code>
       ,
       <code class="calibre21">
        print()
       </code>
       , and
       <code class="calibre21">
        println()
       </code>
       . A format string can contain a set of curly brackets,
       <code class="calibre21">
        {}
       </code>
       , which represent a
       <i class="calibre18">
        replacement field
       </i>
       . You can have as many replacement fields as you need. Subsequent arguments to
       <code class="calibre21">
        format()
       </code>
       ,
       <code class="calibre21">
        print()
       </code>
       , and
       <code class="calibre21">
        println()
       </code>
       <span aria-label="105" class="calibre20" epub:type="pagebreak" id="Page_105" role="doc-pagebreak">
       </span>
       are values that are used to fill in those replacement fields. If you need the
       <code class="calibre21">
        {
       </code>
       and
       <code class="calibre21">
        }
       </code>
       characters in the output, then you need to escape them as
       <code class="calibre21">
        {{
       </code>
       or
       <code class="calibre21">
        }}
       </code>
       .
      </p>
      <p class="calibre13">
       Up to now, replacement fields have always been empty sets of curly brackets,
       <code class="calibre21">
        {}
       </code>
       , but that is just the start. Inside those curly brackets can be a string in the format
       <code class="calibre21">
        [index][:specifier]
       </code>
       :
      </p>
      <ul class="check" id="c02-list-0012">
       <li class="calibre9" id="c02-li-0034">
        The optional
        <code class="calibre21">
         index
        </code>
        is an
        <i class="calibre18">
         argument index
        </i>
        , discussed in the next section.
       </li>
       <li class="calibre9" id="c02-li-0035">
        The optional
        <code class="calibre21">
         specifier
        </code>
        is a
        <i class="calibre18">
         format specifier
        </i>
        to stipulate how a value must be formatted in the output and explained in detail in the “Format Specifiers” section.
       </li>
      </ul>
      <p class="calibre13">
       Passing a format string to
       <code class="calibre21">
        format()
       </code>
       ,
       <code class="calibre21">
        print()
       </code>
       , and
       <code class="calibre21">
        println()
       </code>
       is mandatory. For example, you cannot directly print a value as follows:
      </p>
      <pre class="calibre26" id="c02-code-0072"><code class="calibre21">int x { 42 };</code>
<code class="calibre21">println(x);</code></pre>
      <p class="calibre13">
       Instead, you can write the following:
      </p>
      <pre class="calibre26" id="c02-code-0073"><code class="calibre21">println("{}", x);</code></pre>
      <p class="calibre13">
       You also cannot print a single newline by just writing the following:
      </p>
      <pre class="calibre26" id="c02-code-0074"><code class="calibre21">println();</code></pre>
      <p class="calibre13">
       Instead, use this:
      </p>
      <pre class="calibre26" id="c02-code-0075"><code class="calibre21">println("");</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0036">
      </span>
      <h3 class="calibre27" id="head-3-107">
       Argument Indices
      </h3>
      <p class="calibre13" id="c02-para-0131">
       You can either omit the
       <code class="calibre21">
        index
       </code>
       from all replacement fields or specify, for all replacement fields, the zero-based index of one of the values passed to
       <code class="calibre21">
        format()
       </code>
       ,
       <code class="calibre21">
        print()
       </code>
       , or
       <code class="calibre21">
        println()
       </code>
       as second and subsequent arguments that should be used for a replacement field. You are allowed to use a certain
       <code class="calibre21">
        index
       </code>
       multiple times if you want to output that value multiple times. If
       <code class="calibre21">
        index
       </code>
       is omitted, the values passed as second and subsequent arguments are used in their given order for all replacement fields.
      </p>
      <p class="calibre13">
       The following call to
       <code class="calibre21">
        println()
       </code>
       omits explicit indices in the replacement fields:
      </p>
      <pre class="calibre26" id="c02-code-0076"><code class="calibre21">int n { 42 };</code>
<code class="calibre21">println("Read {} bytes from {}", n, "file1.txt");</code></pre>
      <p class="calibre13">
       You can specify manual indices as follows:
      </p>
      <pre class="calibre26" id="c02-code-0077"><code class="calibre21">println("Read <b class="calibre14">{0}</b> bytes from <b class="calibre14">{1}</b>", n, "file1.txt");</code></pre>
      <p class="calibre13">
       Mixing manual indices and automatic indices is not allowed. The following uses an invalid format string:
      </p>
      <pre class="calibre26" id="c02-code-0078"><code class="calibre21">println("Read <b class="calibre14">{0}</b> bytes from <b class="calibre14">{}</b>", n, "file1.txt");</code></pre>
      <p class="calibre13">
       The order of the formatted values in the output string can be changed without having to change the actual order of the arguments
       <code class="calibre21">
       </code>
       . This is a useful feature if you want to translate strings in your software. Certain languages have different ordering within their sentences. For example, the previous format string can be translated to Chinese as follows. In Chinese, the order of the replacement fields
       <span aria-label="106" class="calibre20" epub:type="pagebreak" id="Page_106" role="doc-pagebreak">
       </span>
       in the sentence is reversed, but thanks to the use of
       <i class="calibre18">
        argument indices
       </i>
       in the format string, the order of the arguments to
       <code class="calibre21">
        println()
       </code>
       remains unchanged.
      </p>
      <pre class="calibre26" id="c02-code-0079"><code class="calibre21">println("从<b class="calibre14">{1}</b>中读取<b class="calibre14">{0}</b>个字节。", <b class="calibre14">n, "file1.txt"</b>);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0037">
      </span>
      <h3 class="calibre27" id="head-3-108">
       Printing to Different Destinations
      </h3>
      <p class="calibre13">
       Up to now, every call to
       <code class="calibre21">
        print()
       </code>
       and
       <code class="calibre21">
        println()
       </code>
       had a format string as the first argument, followed by a number of additional arguments. For example:
      </p>
      <pre class="calibre26" id="c02-code-0080"><code class="calibre21">println("x has value {} and y has value {}.", x, y);</code></pre>
      <p class="calibre13" id="c02-para-0137">
       This prints the string to the standard output stream, the same stream as
       <code class="calibre21">
        std::cout
       </code>
       .
      </p>
      <p class="calibre13">
       As
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       explains, there's also
       <code class="calibre21">
        std::cerr
       </code>
       , which streams to the standard error console. You can use
       <code class="calibre21">
        print()
       </code>
       and
       <code class="calibre21">
        println()
       </code>
       to print to the error console as follows:
      </p>
      <pre class="calibre26" id="c02-code-0081"><code class="calibre21">println(<b class="calibre14">cerr,</b> "x has value {} and y has value {}.", x, y);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0038">
      </span>
      <h3 class="calibre27" id="head-3-109">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Compile-Time Verification of Format Strings
      </h3>
      <p class="calibre13">
       As of C++23, the format string for
       <code class="calibre21">
        format()
       </code>
       ,
       <a aria-describedby="c02-note-0003" class="calibre5" epub:type="noteref" href="#c02-note-0003" id="R_c02-note-0003" role="doc-noteref">
        <sup class="calibre22">
         3
        </sup>
       </a>
       <code class="calibre21">
        print()
       </code>
       , and
       <code class="calibre21">
        println()
       </code>
       must be a compile-time constant so that the compiler can check at compile time whether there are any syntax errors in the format string. That means the following does not compile:
      </p>
      <pre class="calibre26" id="c02-code-0082"><code class="calibre21">string s { "Hello World!" };</code>
<code class="calibre21"><b class="calibre14">println(s);</b>   <span class="color">// Error! Does not compile.</span></code></pre>
      <p class="calibre13">
       The error produced is compiler dependent and unfortunately, at the time of this writing, rather cryptic and not always immediately helpful in pinpointing the exact cause of the error. For example, here is the error from the Microsoft Visual C++ 2022 compiler:
      </p>
      <pre class="calibre26" id="c02-code-0083"><code class="calibre21">error C7595: 'std::basic_format_string&lt;char&gt;::basic_format_string': call to immediate function is not a constant expression</code></pre>
      <p class="calibre13">
       The correct use is as follows:
      </p>
      <pre class="calibre26" id="c02-code-0084"><code class="calibre21">string s { "Hello World!" };</code>
<code class="calibre21"><b class="calibre14">println("{}", s);</b></code></pre>
      <p class="calibre13">
       <code class="calibre21">
        constexpr
       </code>
       format strings are naturally also allowed as those are compile-time constants.
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” discusses the
       <code class="calibre21">
        constexpr
       </code>
       keyword in detail.
      </p>
      <pre class="calibre26" id="c02-code-0085"><code class="calibre21">constexpr auto formatString { "Value: {}" };</code>
<code class="calibre21">println(formatString, 11);  <span class="color">// Value: 11</span></code></pre>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0039">
       </span>
       <h4 class="calibre29" id="head-4-68">
        Non-Compile-Time Constant Format Strings
       </h4>
       <p class="calibre13">
        The fact that format strings must be compile-time constants can be a bit cumbersome when you need to localize/translate format strings for different languages. In such a scenario, you can use
        <code class="calibre21">
         std::vprint_unicode()
        </code>
        or
        <code class="calibre21">
         std::vprint_nonunicode()
        </code>
        instead of
        <code class="calibre21">
         std::print()
        </code>
        . It's a little bit harder to use, though. You cannot just pass the arguments as you do with
        <code class="calibre21">
         print()
        </code>
        , but you need to
        <span aria-label="107" class="calibre20" epub:type="pagebreak" id="Page_107" role="doc-pagebreak">
        </span>
        use
        <code class="calibre21">
         std::make_format_args()
        </code>
        to do so. Here's an example:
       </p>
       <pre class="calibre26" id="c02-code-0086"><code class="calibre21">enum class Language { English, Dutch };</code>
<code class="calibre21"> </code>
<code class="calibre21">string_view GetLocalizedFormat(Language language)</code>
<code class="calibre21">{</code>
<code class="calibre21">    switch (language) {</code>
<code class="calibre21">        case Language::English: return "Numbers: {0} and {1}.";</code>
<code class="calibre21">        case Language::Dutch:   return "Getallen: {0} en {1}.";</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Language language { Language::English };</code>
<code class="calibre21">    vprint_unicode(GetLocalizedFormat(language), make_format_args(1, 2));</code>
<code class="calibre21">    println("");</code>
<code class="calibre21">    language = Language::Dutch;</code>
<code class="calibre21">    vprint_unicode(GetLocalizedFormat(language), make_format_args(1, 2));</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The output is:
       </p>
       <pre class="calibre26" id="c02-code-0087"><code class="calibre21">Numbers: 1 and 2.</code>
<code class="calibre21">Getallen: 1 en 2.</code></pre>
       <p class="calibre13">
        The following call using
        <code class="calibre21">
         print()
        </code>
        does not compile as it requires a compile-time constant format string:
       </p>
       <pre class="calibre26" id="c02-code-0088"><code class="calibre21">print(GetLocalizedFormat(language), 1, 2);</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0040">
       </span>
       <h4 class="calibre29" id="head-4-69">
        Handling Errors in Non-Compile-Time Constant Format Strings
       </h4>
       <p class="calibre13">
        When format strings are verified at run time, instead of at compile time,
        <code class="calibre21">
         std::format_error
        </code>
        exceptions are thrown for any format string error. As explained earlier, functions such as
        <code class="calibre21">
         std::format()
        </code>
        ,
        <code class="calibre21">
         print()
        </code>
        , and
        <code class="calibre21">
         println()
        </code>
        never throw such exceptions as the format strings are all verified at compile time. However, functions such as
        <code class="calibre21">
         std::vformat()
        </code>
        and
        <code class="calibre21">
         vprint_unicode()
        </code>
        (see the previous section) don't require the format string to be constant and hence don't verify them at compile time but at run time. These functions might throw
        <code class="calibre21">
         format_error
        </code>
        exceptions. Here is an example:
       </p>
       <pre class="calibre26" id="c02-code-0089"><code class="calibre21">try {</code>
<code class="calibre21">    vprint_unicode("An integer: {5}", make_format_args(42));</code>
<code class="calibre21">} catch (const format_error&amp; caught_exception) {</code>
<code class="calibre21">    println("{}", caught_exception.what()); <span class="color">// "Argument not found."</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c02-para-0148">
        Now, let's investigate how powerful format specifiers really are.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-110">
       Format Specifiers
      </h3>
      <p class="calibre13" id="c02-para-0149">
       As mentioned earlier, a format string can contain replacement fields delimited by curly brackets. Inside those curly brackets can be a string in the format
       <code class="calibre21">
        [index][:specifier]
       </code>
       . This section discusses the format specifier part of the replacement field.
       <code class="calibre21">
        index
       </code>
       is discussed earlier.
      </p>
      <p class="calibre13">
       <span aria-label="108" class="calibre20" epub:type="pagebreak" id="Page_108" role="doc-pagebreak">
       </span>
       A
       <i class="calibre18">
        format specifier
       </i>
       is used to manipulate how a value is formatted in the output. A format specifier is prefixed with a colon,
       <code class="calibre21">
        :
       </code>
       . The general form of a format specifier is as follows:
      </p>
      <pre class="calibre26" id="c02-code-0090"><code class="calibre21">[[fill]align][sign][#][0][width][.precision][L][type]</code></pre>
      <p class="calibre13" id="c02-para-0151">
       All parts between square brackets are optional. The individual specifier parts are discussed in the next subsections.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0042">
       </span>
       <h4 class="calibre29" id="head-4-70">
        width
       </h4>
       <p class="calibre13" id="c02-para-0152">
        The
        <code class="calibre21">
         width
        </code>
        specifies the minimum width of the field into which the given value should be formatted. This can also be another set of curly brackets, in which case it's called a
        <i class="calibre18">
         dynamic width
        </i>
        . If an index is specified in the curly brackets, for example
        <code class="calibre21">
         {3}
        </code>
        , the value for the dynamic width is taken from the argument with the given index. Otherwise, if no index is specified, for example
        <code class="calibre21">
         {}
        </code>
        , the width is taken from the next argument in the list of arguments.
       </p>
       <p class="calibre13">
        Here are some examples:
       </p>
       <pre class="calibre26" id="c02-code-0091"><code class="calibre21">int i { 42 };</code>
<code class="calibre21">println("|{:5}|", i);       <span class="color">// |   42|</span></code>
<code class="calibre21">println("|{:{}}|", i, 7);   <span class="color">// |     42|</span></code>
<code class="calibre21">println("|{1:{0}}|", 7, i); <span class="color">// |     42|</span></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0043">
       </span>
       <h4 class="calibre29" id="head-4-71">
        [fill]align
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         [fill]align
        </code>
        part optionally says what character to use as a fill character, followed by how a value should be aligned in its field:
       </p>
       <ul class="check" id="c02-list-0013">
        <li class="calibre9" id="c02-li-0036">
         <code class="calibre21">
          &lt;
         </code>
         means left alignment (default for non-integers and non-floating-point numbers).
        </li>
        <li class="calibre9" id="c02-li-0037">
         <code class="calibre21">
          &gt;
         </code>
         means right alignment (default for integers and floating-point numbers).
        </li>
        <li class="calibre9" id="c02-li-0038">
         <code class="calibre21">
          ^
         </code>
         means center alignment.
        </li>
       </ul>
       <p class="calibre13" id="c02-para-0155">
        The fill character is inserted into the output to make sure the field in the output reaches the desired minimum width specified by the
        <code class="calibre21">
         [width]
        </code>
        part of the specifier. If no
        <code class="calibre21">
         [width]
        </code>
        is specified, then
        <code class="calibre21">
         [fill]align
        </code>
        has no effect.
       </p>
       <p class="calibre13" id="c02-para-0156">
        When using center alignment, the same number of fill characters is on the left and on the right of the formatted value. If the total number of fill characters is odd, then the extra fill character is added on the right.
       </p>
       <p class="calibre13">
        Here are some examples:
       </p>
       <pre class="calibre26" id="c02-code-0092"><code class="calibre21">int i { 42 };</code>
<code class="calibre21">println("|{:7}|", i);     <span class="color">// |     42|</span></code>
<code class="calibre21">println("|{:&lt;7}|", i);    <span class="color">// |42     |</span></code>
<code class="calibre21">println("|{:_&gt;7}|", i);   <span class="color">// |_____42|</span></code>
<code class="calibre21">println("|{:_^7}|", i);   <span class="color">// |__42___|</span></code></pre>
       <p class="calibre13">
        The following is an interesting trick to output a character a specific number of times. Instead of typing a string literal yourself containing the correct number of characters, you specify the number of characters you need explicitly in the format specifier:
       </p>
       <pre class="calibre26" id="c02-code-0093"><code class="calibre21">println("|{:=&gt;16}|", ""); <span class="color">// |================|</span></code></pre>
      </section>
      <span aria-label="109" class="calibre20" epub:type="pagebreak" id="Page_109" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0044">
       </span>
       <h4 class="calibre29" id="head-4-72">
        sign
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         sign
        </code>
        part can be one of the following:
       </p>
       <ul class="check" id="c02-list-0014">
        <li class="calibre9" id="c02-li-0039">
         <code class="calibre21">
          -
         </code>
         means to only display the sign for negative numbers (default).
        </li>
        <li class="calibre9" id="c02-li-0040">
         <code class="calibre21">
          +
         </code>
         means to display the sign for negative and positive numbers.
        </li>
        <li class="calibre9" id="c02-li-0041">
         <code class="calibre21">
          space
         </code>
         means that a minus sign should be used for negative numbers, and a space for positive numbers.
        </li>
       </ul>
       <p class="calibre13">
        Here are some examples:
       </p>
       <pre class="calibre26" id="c02-code-0094"><code class="calibre21">int i { 42 };</code>
<code class="calibre21">println("|{:&lt;5}|", i);   <span class="color">// |42   |</span></code>
<code class="calibre21">println("|{:&lt;+5}|", i);  <span class="color">// |+42  |</span></code>
<code class="calibre21">println("|{:&lt; 5}|", i);  <span class="color">// | 42  |</span></code>
<code class="calibre21">println("|{:&lt; 5}|", -i); <span class="color">// |-42  |</span></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0045">
       </span>
       <h4 class="calibre29" id="head-4-73">
        #
       </h4>
       <p class="calibre13" id="c02-para-0161">
        The
        <code class="calibre21">
         #
        </code>
        part enables the
        <i class="calibre18">
         alternate formatting
        </i>
        rules. If enabled for integral types, and hexadecimal, binary, or octal number formatting is specified as well, then the alternate format inserts a 0x, 0X, 0b, 0B, or 0 in front of the formatted number. If enabled for floating-point types, the alternate format will always output a decimal separator, even if no digits follow it.
       </p>
       <p class="calibre13" id="c02-para-0162">
        The following two sections give examples with alternate formatting.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0046">
       </span>
       <h4 class="calibre29" id="head-4-74">
        type
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         type
        </code>
        specifies the type a given value must be formatted in. There are several options:
       </p>
       <ul class="check" id="c02-list-0015">
        <li class="calibre9" id="c02-li-0042">
         <b class="calibre14">
          Integer types:
         </b>
         <code class="calibre21">
          b
         </code>
         (binary),
         <code class="calibre21">
          B
         </code>
         (binary, but with
         <code class="calibre21">
          0B
         </code>
         instead of
         <code class="calibre21">
          0b
         </code>
         if
         <code class="calibre21">
          #
         </code>
         is specified),
         <code class="calibre21">
          d
         </code>
         (decimal),
         <code class="calibre21">
          o
         </code>
         (octal),
         <code class="calibre21">
          x
         </code>
         (hexadecimal with lowercase
         <code class="calibre21">
          a
         </code>
         ,
         <code class="calibre21">
          b
         </code>
         ,
         <code class="calibre21">
          c
         </code>
         ,
         <code class="calibre21">
          d
         </code>
         ,
         <code class="calibre21">
          e
         </code>
         ,
         <code class="calibre21">
          f
         </code>
         ),
         <code class="calibre21">
          X
         </code>
         (hexadecimal with uppercase
         <code class="calibre21">
          A
         </code>
         ,
         <code class="calibre21">
          B
         </code>
         ,
         <code class="calibre21">
          C
         </code>
         ,
         <code class="calibre21">
          D
         </code>
         ,
         <code class="calibre21">
          E
         </code>
         ,
         <code class="calibre21">
          F
         </code>
         , and if
         <code class="calibre21">
          #
         </code>
         is specified, with
         <code class="calibre21">
          0X
         </code>
         instead of
         <code class="calibre21">
          0x
         </code>
         ). If
         <code class="calibre21">
          type
         </code>
         is unspecified,
         <code class="calibre21">
          d
         </code>
         is used for integer types.
        </li>
        <li class="calibre9" id="c02-li-0043">
         <b class="calibre14">
          Floating-point types:
         </b>
         The following floating-point formats are supported. The result of scientific, fixed, general, and hexadecimal formatting is the same as discussed earlier in this chapter for
         <code class="calibre21">
          std::chars_format::scientific
         </code>
         ,
         <code class="calibre21">
          fixed
         </code>
         ,
         <code class="calibre21">
          general
         </code>
         , and
         <code class="calibre21">
          hex
         </code>
         .
         <ul class="check3" id="c02-list-0016">
          <li class="calibre9" id="c02-li-0044">
           <code class="calibre21">
            e
           </code>
           ,
           <code class="calibre21">
            E
           </code>
           : Scientific notation with either small
           <code class="calibre21">
            e
           </code>
           or capital
           <code class="calibre21">
            E
           </code>
           as the representation of the exponent, formatted with either a given precision or 6 if no precision is specified.
          </li>
          <li class="calibre9" id="c02-li-0045">
           <code class="calibre21">
            f
           </code>
           ,
           <code class="calibre21">
            F
           </code>
           : Fixed notation formatted with either a given precision or 6 if no precision is specified.
          </li>
          <li class="calibre9" id="c02-li-0046">
           <code class="calibre21">
            g
           </code>
           ,
           <code class="calibre21">
            G
           </code>
           : General notation automatically chooses a representation without an exponent (fixed format) or with an exponent (small
           <code class="calibre21">
            e
           </code>
           or capital
           <code class="calibre21">
            E
           </code>
           ), formatted with either a given precision or 6 if no precision is specified.
          </li>
          <li class="calibre9" id="c02-li-0047">
           <code class="calibre21">
            a
           </code>
           ,
           <code class="calibre21">
            A
           </code>
           : Hexadecimal notation with either lowercase letters (
           <code class="calibre21">
            a
           </code>
           ) or uppercase letters (
           <code class="calibre21">
            A
           </code>
           )
          </li>
          <li class="calibre9" id="c02-li-0048">
           If
           <code class="calibre21">
            type
           </code>
           is unspecified,
           <code class="calibre21">
            g
           </code>
           is used for floating-point types.
          </li>
         </ul>
        </li>
        <li class="calibre9" id="c02-li-0049">
         <span aria-label="110" class="calibre20" epub:type="pagebreak" id="Page_110" role="doc-pagebreak">
         </span>
         <b class="calibre14">
          Booleans:
         </b>
         <code class="calibre21">
          s
         </code>
         (outputs
         <code class="calibre21">
          true
         </code>
         or
         <code class="calibre21">
          false
         </code>
         in textual form),
         <code class="calibre21">
          b
         </code>
         ,
         <code class="calibre21">
          B
         </code>
         ,
         <code class="calibre21">
          c
         </code>
         ,
         <code class="calibre21">
          d
         </code>
         ,
         <code class="calibre21">
          o
         </code>
         ,
         <code class="calibre21">
          x
         </code>
         ,
         <code class="calibre21">
          X
         </code>
         (outputs
         <code class="calibre21">
          1
         </code>
         or
         <code class="calibre21">
          0
         </code>
         in integer form). If
         <code class="calibre21">
          type
         </code>
         is unspecified,
         <code class="calibre21">
          s
         </code>
         is used for Boolean types.
        </li>
        <li class="calibre9" id="c02-li-0050">
         <b class="calibre14">
          Characters:
         </b>
         <code class="calibre21">
          c
         </code>
         (character is copied to output),
         <code class="calibre21">
          ?
         </code>
         (escaped character is copied to output; see section “
         <a class="calibre5" href="#c02-sec-0050">
          Formatting Escaped Characters and Strings
         </a>
         ”),
         <code class="calibre21">
          b
         </code>
         ,
         <code class="calibre21">
          B
         </code>
         ,
         <code class="calibre21">
          d
         </code>
         ,
         <code class="calibre21">
          o
         </code>
         ,
         <code class="calibre21">
          x
         </code>
         ,
         <code class="calibre21">
          X
         </code>
         (integer representation). If
         <code class="calibre21">
          type
         </code>
         is unspecified,
         <code class="calibre21">
          c
         </code>
         is used for character types.
        </li>
        <li class="calibre9" id="c02-li-0051">
         <b class="calibre14">
          String:
         </b>
         <code class="calibre21">
          s
         </code>
         (string is copied to output),
         <code class="calibre21">
          ?
         </code>
         (escaped string is copied to output; see section “
         <a class="calibre5" href="#c02-sec-0050">
          Formatting Escaped Characters and Strings
         </a>
         ”). If
         <code class="calibre21">
          type
         </code>
         is unspecified,
         <code class="calibre21">
          s
         </code>
         is used for string types.
        </li>
        <li class="calibre9" id="c02-li-0052">
         <b class="calibre14">
          Pointers:
         </b>
         <code class="calibre21">
          p
         </code>
         (hexadecimal notation of the pointer prefixed with
         <code class="calibre21">
          0x
         </code>
         ). If
         <code class="calibre21">
          type
         </code>
         is unspecified,
         <code class="calibre21">
          p
         </code>
         is used for pointer types. Only pointers of type
         <code class="calibre21">
          void*
         </code>
         can be formatted. Other pointer types must first be converted to type
         <code class="calibre21">
          void*
         </code>
         , for example using
         <code class="calibre21">
          static_cast&lt;void*&gt;(myPointer)
         </code>
         .
        </li>
       </ul>
       <p class="calibre13">
        Here are some examples with an integral type:
       </p>
       <pre class="calibre26" id="c02-code-0095"><code class="calibre21">int i { 42 };</code>
<code class="calibre21">println("|{:10d}|", i);   <span class="color">// |        42|</span></code>
<code class="calibre21">println("|{:10b}|", i);   <span class="color">// |    101010|</span></code>
<code class="calibre21">println("|{:#10b}|", i);  <span class="color">// |  0b101010|</span></code>
<code class="calibre21">println("|{:10X}|", i);   <span class="color">// |        2A|</span></code>
<code class="calibre21">println("|{:#10X}|", i);  <span class="color">// |      0X2A|</span></code></pre>
       <p class="calibre13">
        Here is an example with a string type:
       </p>
       <pre class="calibre26" id="c02-code-0096"><code class="calibre21">string s { "ProCpp" };</code>
<code class="calibre21">println("|{:_^10}|", s); <span class="color">// |__ProCpp__|</span></code></pre>
       <p class="calibre13" id="c02-para-0167">
        Examples with floating-point types are given in the next section on precision.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0047">
       </span>
       <h4 class="calibre29" id="head-4-75">
        precision
       </h4>
       <p class="calibre13" id="c02-para-0168">
        The
        <code class="calibre21">
         precision
        </code>
        can be used only for floating-point and string types. It is specified as a dot followed by the number of decimal digits to output for floating-point types, or the number of characters to output for strings. The number of digits for floating-point types includes all digits, including the ones before the decimal separator, unless fixed floating-point notation (
        <code class="calibre21">
         f
        </code>
        or
        <code class="calibre21">
         F
        </code>
        ) is used, in which case
        <code class="calibre21">
         precision
        </code>
        is the number of digits after the decimal point.
       </p>
       <p class="calibre13" id="c02-para-0169">
        Just as with
        <code class="calibre21">
         width
        </code>
        ,
        <code class="calibre21">
         precision
        </code>
        can also be another set of curly brackets, in which case it's called a
        <i class="calibre18">
         dynamic precision
        </i>
        . The precision is then taken either from the next argument in the list of arguments or from the argument with given index.
       </p>
       <p class="calibre13">
        Here are some examples using a floating-point type:
       </p>
       <pre class="calibre26" id="c02-code-0097"><code class="calibre21">double d { 3.1415 / 2.3 };</code>
<code class="calibre21">println("|{:12g}|", d);                         <span class="color">// |     1.36587|</span></code>
<code class="calibre21">println("|{:12.2}|", d);                        <span class="color">// |         1.4|</span></code>
<code class="calibre21">println("|{:12e}|", d);                         <span class="color">// |1.365870e+00|</span></code>
<code class="calibre21"> </code>
<code class="calibre21">int width { 12 };</code>
<code class="calibre21">int precision { 3 };</code>
<code class="calibre21">println("|{2:{0}.{1}f}|", width, precision, d); <span class="color">// |       1.366|</span></code>
<code class="calibre21">println("|{2:{0}.{1}}|", width, precision, d);  <span class="color">// |        1.37|</span></code></pre>
      </section>
      <span aria-label="111" class="calibre20" epub:type="pagebreak" id="Page_111" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0048">
       </span>
       <h4 class="calibre29" id="head-4-76">
        0
       </h4>
       <p class="calibre13" id="c02-para-0171">
        The
        <code class="calibre21">
         0
        </code>
        part of the specifier means that, for numeric values, zeros are inserted into the formatted value to reach the desired minimum width specified by the
        <code class="calibre21">
         [width]
        </code>
        part of the specifier (see earlier). These zeros are inserted at the front of the numeric value, but after any sign, and after any 0x, 0X, 0b, or 0B prefix. The
        <code class="calibre21">
         0
        </code>
        specifier is ignored if an alignment is specified.
       </p>
       <p class="calibre13">
        Here are some examples:
       </p>
       <pre class="calibre26" id="c02-code-0098"><code class="calibre21">int i { 42 };</code>
<code class="calibre21">println("|{:06d}|", i);   <span class="color">// |000042|</span></code>
<code class="calibre21">println("|{:+06d}|", i);  <span class="color">// |+00042|</span></code>
<code class="calibre21">println("|{:06X}|", i);   <span class="color">// |00002A|</span></code>
<code class="calibre21">println("|{:#06X}|", i);  <span class="color">// |0X002A|</span></code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c02-sec-0049">
       </span>
       <h4 class="calibre29" id="head-4-77">
        L
       </h4>
       <p class="calibre13" id="c02-para-0173">
        The optional
        <code class="calibre21">
         L
        </code>
        specifier enables locale-specific formatting. This option is valid only for arithmetic types, such as integers, floating-point types, and Booleans. When used with integers, the
        <code class="calibre21">
         L
        </code>
        option specifies that the locale-specific digit group separator character must be used. For floating-point types, it means to use the locale-specific digit group and decimal separator characters. For Boolean types output in textual form, it means to use the locale-specific representation of
        <code class="calibre21">
         true
        </code>
        and
        <code class="calibre21">
         false
        </code>
        .
       </p>
       <p class="calibre13">
        When using the
        <code class="calibre21">
         L
        </code>
        specifier, you have to pass an
        <code class="calibre21">
         std::locale
        </code>
        instance as the first parameter to
        <code class="calibre21">
         std::format()
        </code>
        . This works only with
        <code class="calibre21">
         format()
        </code>
        , not with
        <code class="calibre21">
         print()
        </code>
        and
        <code class="calibre21">
         println()
        </code>
        . Here is an example that formats a floating-point number using the
        <code class="calibre21">
         nl
        </code>
        locale:
       </p>
       <pre class="calibre26" id="c02-code-0099"><code class="calibre21">float f { 1.2f };</code>
<code class="calibre21">cout &lt;&lt; format(std::locale{ "nl" }, "|{:Lg}|\n", f);  <span class="color">// |1,2|</span></code></pre>
       <p class="calibre13" id="c02-para-0175">
        Locales are discussed in
        <a class="calibre5" href="c21.xhtml">
         Chapter 21
        </a>
        .
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0050">
      </span>
      <h3 class="calibre27" id="head-3-111">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Formatting Escaped Characters and Strings
      </h3>
      <p class="calibre13" id="c02-para-0177">
       C++23 allows you to format escaped strings and characters by using the
       <code class="calibre21">
        ?
       </code>
       type specifier. This use case does not occur often, but it can be helpful for logging and debugging purposes. The output resembles how you write string and character literals in your code: they start and end with double or single quotes, and they use escaped character sequences. The following table shows what the output is of certain characters when using escaped formatting:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          CHARACTER
         </th>
         <th class="left" scope="col">
          ESCAPED OUTPUT
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          Horizontal tab
         </td>
         <td class="left1">
          <code class="calibre21">
           \t
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          New line
         </td>
         <td class="left1">
          <code class="calibre21">
           \n
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Carriage return
         </td>
         <td class="left1">
          <code class="calibre21">
           \r
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Backslash
         </td>
         <td class="left1">
          <code class="calibre21">
           \\
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Double quote
         </td>
         <td class="left1">
          <code class="calibre21">
           \"
          </code>
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          Single quote
         </td>
         <td class="left1">
          <code class="calibre21">
           \'
          </code>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c02-para-0179">
       <span aria-label="112" class="calibre20" epub:type="pagebreak" id="Page_112" role="doc-pagebreak">
       </span>
       The escaping of double quotes happens only when the output is a double-quoted string, while the escaping of single quotes happens only when the output is a single-quoted character. The escaped output of unprintable characters is
       <code class="calibre21">
        \u{hex-code-point}
       </code>
       .
      </p>
      <p class="calibre13">
       Here are some examples:
      </p>
      <pre class="calibre26" id="c02-code-0100"><code class="calibre21">println("|{:?}|", "Hello\tWorld!\n");  <span class="color">// |Hello\tWorld!\n|</span></code>
<code class="calibre21">println("|{:?}|", "\"");               <span class="color">// |"\""|</span></code>
<code class="calibre21">println("|{:?}|", '\'');               <span class="color">// |'\''|</span></code>
<code class="calibre21">println("|{:?}|", '"');                <span class="color">// |'"'|</span></code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0051">
      </span>
      <h3 class="calibre27" id="head-3-112">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Formatting Ranges
      </h3>
      <p class="calibre13" id="c02-para-0182">
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       introduces the
       <code class="calibre21">
        std::vector
       </code>
       ,
       <code class="calibre21">
        array
       </code>
       , and
       <code class="calibre21">
        pair
       </code>
       containers to store multiple elements of data.
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       , “Standard Library Containers,” introduces quite a few additional containers provided by the Standard Library. Starting with C++23, it's possible to directly format such ranges of elements. For ranges such as
       <code class="calibre21">
        vector
       </code>
       s and
       <code class="calibre21">
        array
       </code>
       s, the output, by default, is surrounded by square brackets and individual elements are separated by commas. If the elements of the range are strings, their output is escaped by default.
      </p>
      <p class="calibre13">
       The formatting of ranges can be controlled using nested format specifiers. The general form is as follows:
      </p>
      <pre class="calibre26" id="c02-code-0101"><code class="calibre21">[[fill]align][width][n][range-type][:range-underlying-spec]</code></pre>
      <p class="calibre13" id="c02-para-0184">
       Everything between square brackets is optional. As with other format specifiers,
       <code class="calibre21">
        fill
       </code>
       specifies a fill character,
       <code class="calibre21">
        align
       </code>
       specifies the alignment of the output, and
       <code class="calibre21">
        width
       </code>
       specifies the width of the output field. If
       <code class="calibre21">
        n
       </code>
       is specified, the output will not contain the opening and closing brackets of the range. The
       <code class="calibre21">
        range-type
       </code>
       can be one of the following:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          RANGE-TYPE
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           m
          </code>
         </td>
         <td class="left1">
          Available only for
          <code class="calibre21">
           pair
          </code>
          s and
          <code class="calibre21">
           tuple
          </code>
          s with two elements. By default, these are surrounded by parentheses and separated by commas. If
          <code class="calibre21">
           m
          </code>
          is specified, they are not surrounded by any type of brackets, and the two elements are separated by
          <code class="calibre21">
           ": "
          </code>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           s
          </code>
         </td>
         <td class="left1">
          Formats the range as a string (cannot be combined with
          <code class="calibre21">
           n
          </code>
          or a
          <code class="calibre21">
           range-underlying-spec
          </code>
          ).
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           ?s
          </code>
         </td>
         <td class="left1">
          Formats the range as an escaped string (cannot be combined with
          <code class="calibre21">
           n
          </code>
          or a
          <code class="calibre21">
           range-underlying-spec
          </code>
          ).
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c02-para-0186">
       The
       <code class="calibre21">
        range-underlying-spec
       </code>
       is an optional format specifier for the individual elements of the range. Range specifiers can be nested multiple levels deep. If the elements are again ranges (e.g., a
       <code class="calibre21">
        vector
       </code>
       of
       <code class="calibre21">
        vector
       </code>
       s), then the
       <code class="calibre21">
        range-underlying-spec
       </code>
       is another range format specifier, and so on.
      </p>
      <p class="calibre13">
       Let's look at some examples. First, let's format a
       <code class="calibre21">
        vector
       </code>
       of numbers:
      </p>
      <pre class="calibre26" id="c02-code-0102"><code class="calibre21">vector values { 11, 22, 33 };</code>
<span aria-label="113" class="calibre20" epub:type="pagebreak" id="Page_113" role="doc-pagebreak"></span><code class="calibre21">println("{}", values);         <span class="color">// [11, 22, 33]</span></code>
<code class="calibre21">println("{:n}", values);       <span class="color">// 11, 22, 33</span></code></pre>
      <p class="calibre13">
       If you want to replace the starting and ending square brackets, you can combine the
       <code class="calibre21">
        n
       </code>
       specifier with surrounding the format specifier with your own starting and ending characters. For example, the following surrounds the output with curly brackets instead. Curly brackets that you want to appear in the output need to be escaped as
       <code class="calibre21">
        {{
       </code>
       and
       <code class="calibre21">
        }}
       </code>
       .
      </p>
      <pre class="calibre26" id="c02-code-0103"><code class="calibre21">println("{{{:n}}}", values);   <span class="color">// {11, 22, 33}</span></code></pre>
      <p class="calibre13">
       The following provides a format specifier for the entire range. For both, the range is output in the center of a field that is 16 characters wide with
       <code class="calibre21">
        *
       </code>
       as a fill character. For the second, the
       <code class="calibre21">
        n
       </code>
       specifies that the opening and closing brackets should be omitted:
      </p>
      <pre class="calibre26" id="c02-code-0104"><code class="calibre21">println("{:*^16}", values);    <span class="color">// **[11, 22, 33]**</span></code>
<code class="calibre21">println("{:*^16n}", values);   <span class="color">// ***11, 22, 33***</span></code></pre>
      <p class="calibre13">
       The following does not provide an explicit specifier for the entire range, but it does specify how individual elements are to be formatted. In this case, the individual elements are output in the center of a field that's six characters wide with
       <code class="calibre21">
        *
       </code>
       as a fill character:
      </p>
      <pre class="calibre26" id="c02-code-0105"><code class="calibre21">println("{::*^6}", values);    <span class="color">// [**11**, **22**, **33**]</span></code></pre>
      <p class="calibre13">
       This can again be combined with the
       <code class="calibre21">
        n
       </code>
       specifier:
      </p>
      <pre class="calibre26" id="c02-code-0106"><code class="calibre21">println("{:n:*^6}", values);   <span class="color">// **11**, **22**, **33**</span></code></pre>
      <p class="calibre13">
       Here are some examples formatting a
       <code class="calibre21">
        vector
       </code>
       of
       <code class="calibre21">
        string
       </code>
       s:
      </p>
      <pre class="calibre26" id="c02-code-0107"><code class="calibre21">vector strings { "Hello"s, "World!\t2023"s };</code>
<code class="calibre21">println("{}", strings);        <span class="color">// ["Hello", "World!\t2023"]</span></code>
<code class="calibre21">println("{:}", strings);       <span class="color">// ["Hello", "World!\t2023"]</span></code>
<code class="calibre21">println("{::}", strings);      <span class="color">// [Hello, World!    2023]</span></code>
<code class="calibre21">println("{:n:}", strings);     <span class="color">// Hello, World!    2023</span></code></pre>
      <p class="calibre13">
       If you have a
       <code class="calibre21">
        vector
       </code>
       of characters, you can format them as individual characters, or you can consider the entire
       <code class="calibre21">
        vector
       </code>
       as a string using the
       <code class="calibre21">
        s
       </code>
       or
       <code class="calibre21">
        ?s
       </code>
       range type:
      </p>
      <pre class="calibre26" id="c02-code-0108"><code class="calibre21">vector chars { 'W', 'o', 'r', 'l', 'd', '\t', '!' };</code>
<code class="calibre21">println("{}", chars);          <span class="color">// ['W', 'o', 'r', 'l', 'd', '\t', '!']</span></code>
<code class="calibre21">println("{::#x}", chars);      <span class="color">// [0x57, 0x6f, 0x72, 0x6c, 0x64, 0x9, 0x21]</span></code>
<code class="calibre21">println("{:s}", chars);        <span class="color">// World    !</span></code>
<code class="calibre21">println("{:?s}", chars);       <span class="color">// "World\t!"</span></code></pre>
      <p class="calibre13">
       Here are some examples of outputting a
       <code class="calibre21">
        pair
       </code>
       . By default, a
       <code class="calibre21">
        pair
       </code>
       is surrounded by parentheses instead of square brackets, and the two elements are separated by a comma. Using the
       <code class="calibre21">
        n
       </code>
       specifier removes the opening and closing parentheses. The
       <code class="calibre21">
        m
       </code>
       specifier also removes the parentheses and separates the elements with
       <code class="calibre21">
        ": "
       </code>
       .
      </p>
      <pre class="calibre26" id="c02-code-0109"><code class="calibre21">pair p { 11, 22 };</code>
<code class="calibre21">println("{}", p);              <span class="color">// (11, 22)</span></code>
<code class="calibre21">println("{:n}", p);            <span class="color">// 11, 22</span></code>
<code class="calibre21">println("{:m}", p);            <span class="color">// 11: 22</span></code></pre>
      <p class="calibre13">
       Finally, here are some examples of outputting a
       <code class="calibre21">
        vector
       </code>
       of
       <code class="calibre21">
        vector
       </code>
       s:
      </p>
      <pre class="calibre26" id="c02-code-0110"><code class="calibre21">vector&lt;vector&lt;int&gt;&gt; vv { {11, 22}, {33, 44, 55} };</code>
<span aria-label="114" class="calibre20" epub:type="pagebreak" id="Page_114" role="doc-pagebreak"></span><code class="calibre21">println("{}", vv);             <span class="color">// [[11, 22], [33, 44, 55]]</span></code>
<code class="calibre21">println("{:n}", vv);           <span class="color">// [11, 22], [33, 44, 55]</span></code>
<code class="calibre21">println("{:n:n}", vv);         <span class="color">// 11, 22, 33, 44, 55</span></code>
<code class="calibre21">println("{:n:n:*^4}", vv);     <span class="color">// *11*, *22*, *33*, *44*, *55*</span></code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c02-sec-0052">
      </span>
      <h3 class="calibre27" id="head-3-113">
       Support for Custom Types
      </h3>
      <p class="calibre13">
       The formatting library can be extended to add support for custom types. This involves writing a specialization of the
       <code class="calibre21">
        std::formatter
       </code>
       class template containing two member function templates:
       <code class="calibre21">
        parse()
       </code>
       and
       <code class="calibre21">
        format()
       </code>
       . I know, at this point in the book, you will not understand all the syntax in this example yet, as it uses all of the following techniques:
      </p>
      <ul class="check" id="c02-list-0017">
       <li class="calibre9" id="c02-li-0053">
        <code class="calibre21">
         constexpr
        </code>
        functions, discussed in
        <a class="calibre5" href="c09.xhtml">
         Chapter 9
        </a>
       </li>
       <li class="calibre9" id="c02-li-0054">
        Template specialization, member function templates, and abbreviated function template syntax, explained in
        <a class="calibre5" href="c12.xhtml">
         Chapter 12
        </a>
        “Writing Generic Code with Templates”
       </li>
       <li class="calibre9" id="c02-li-0055">
        Exceptions, discussed in
        <a class="calibre5" href="c14.xhtml">
         Chapter 14
        </a>
        , “Handling Errors”
       </li>
       <li class="calibre9" id="c02-li-0056">
        Iterators, discussed in
        <a class="calibre5" href="c17.xhtml">
         Chapter 17
        </a>
        , “Understanding Iterators and the Ranges Library”
       </li>
      </ul>
      <p class="calibre13" id="c02-para-0197">
       Still, for completeness and to give you a taste of what is possible, let's see how you will be able to implement a custom
       <code class="calibre21">
        formatter
       </code>
       once you advance further in the book, at which point you can come back to this example.
      </p>
      <p class="calibre13">
       Suppose you have the following class to store a key-value pair:
      </p>
      <pre class="calibre26" id="c02-code-0111"><code class="calibre21">class KeyValue</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        KeyValue(string_view key, int value) : m_key { key }, m_value { value } {}</code>
<code class="calibre21"> </code>
<code class="calibre21">        const string&amp; getKey() const { return m_key; }</code>
<code class="calibre21">        int getValue() const { return m_value; }</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_key;</code>
<code class="calibre21">        int m_value { 0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       A custom
       <code class="calibre21">
        formatter
       </code>
       for
       <code class="calibre21">
        KeyValue
       </code>
       objects can be implemented by writing the following class template specialization. This
       <code class="calibre21">
        KeyValue
       </code>
       formatter supports:
      </p>
      <ul class="check" id="c02-list-0018">
       <li class="calibre9" id="c02-li-0057">
        Custom format specifiers:
        <code class="calibre21">
         {:k}
        </code>
        outputs only the key,
        <code class="calibre21">
         {:v}
        </code>
        outputs only the value, and
        <code class="calibre21">
         {:b}
        </code>
        and
        <code class="calibre21">
         {}
        </code>
        output both key and value.
       </li>
       <li class="calibre9" id="c02-li-0058">
        Nested format specifiers: These specify optional formats for the key and or the value. The syntax is as follows:
        <code class="calibre21">
         {:b:
         <i class="calibre18">
          KeyFormat
         </i>
         :
         <i class="calibre18">
          ValueFormat
         </i>
         }
        </code>
        .
       </li>
      </ul>
      <pre class="calibre26" id="c02-code-0112"><code class="calibre21">template &lt;&gt;</code>
<code class="calibre21">class std::formatter&lt;KeyValue&gt;</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        constexpr auto parse(auto&amp; context)</code>
<code class="calibre21">        {</code>
<span aria-label="115" class="calibre20" epub:type="pagebreak" id="Page_115" role="doc-pagebreak"></span><code class="calibre21">            string keyFormat, valueFormat;</code>
<code class="calibre21">            size_t numberOfParsedColons { 0 };</code>
<code class="calibre21">            auto iter { begin(context) };</code>
<code class="calibre21">            for (; iter != end(context); ++iter) {</code>
<code class="calibre21">                if (*iter == '}') { break; }</code>
<code class="calibre21"> </code>
<code class="calibre21">                if (numberOfParsedColons == 0) { <span class="color">// Parsing output type</span></code>
<code class="calibre21">                    switch (*iter) {</code>
<code class="calibre21">                        case 'k': case 'K':      <span class="color">// {:k format specifier</span></code>
<code class="calibre21">                            m_outputType = OutputType::KeyOnly;       break;</code>
<code class="calibre21">                        case 'v': case 'V':      <span class="color">// {:v format specifier</span></code>
<code class="calibre21">                            m_outputType = OutputType::ValueOnly;     break;</code>
<code class="calibre21">                        case 'b': case 'B':      <span class="color">// {:b format specifier</span></code>
<code class="calibre21">                            m_outputType = OutputType::KeyAndValue;   break;</code>
<code class="calibre21">                        case ':':</code>
<code class="calibre21">                            ++numberOfParsedColons;   break;</code>
<code class="calibre21">                        default:</code>
<code class="calibre21">                            throw format_error { "Invalid KeyValue format." };</code>
<code class="calibre21">                    }</code>
<code class="calibre21">                } else if (numberOfParsedColons == 1) { <span class="color">// Parsing key format</span></code>
<code class="calibre21">                    if (*iter == ':') { ++numberOfParsedColons; }</code>
<code class="calibre21">                    else { keyFormat += *iter; }</code>
<code class="calibre21">                } else if (numberOfParsedColons == 2) { <span class="color">// Parsing value format</span></code>
<code class="calibre21">                    valueFormat += *iter;</code>
<code class="calibre21">                }</code>
<code class="calibre21">            }</code>
<code class="calibre21">            <span class="color">// Validate key format specifier.</span></code>
<code class="calibre21">            if (!keyFormat.empty()) {</code>
<code class="calibre21">                format_parse_context keyFormatterContext { keyFormat };</code>
<code class="calibre21">                m_keyFormatter.parse(keyFormatterContext);</code>
<code class="calibre21">            }</code>
<code class="calibre21">            <span class="color">// Validate value format specifier.</span></code>
<code class="calibre21">            if (!valueFormat.empty()) {</code>
<code class="calibre21">                format_parse_context valueFormatterContext { valueFormat };</code>
<code class="calibre21">                m_valueFormatter.parse(valueFormatterContext);</code>
<code class="calibre21">            }</code>
<code class="calibre21">            if (iter != end(context) &amp;&amp; *iter != '}') {</code>
<code class="calibre21">                throw format_error { "Invalid KeyValue format." };</code>
<code class="calibre21">            }</code>
<code class="calibre21">            return iter;</code>
<code class="calibre21">        }</code>
<code class="calibre21"> </code>
<code class="calibre21">        auto format(const KeyValue&amp; kv, auto&amp; ctx) const</code>
<code class="calibre21">        {</code>
<code class="calibre21">            switch (m_outputType) {</code>
<code class="calibre21">                using enum OutputType;</code>
<code class="calibre21">                case KeyOnly:</code>
<code class="calibre21">                    ctx.advance:to(m_keyFormatter.format(kv.getKey(), ctx));</code>
<code class="calibre21">                    break;</code>
<code class="calibre21">                case ValueOnly:</code>
<code class="calibre21">                    ctx.advance:to(m_valueFormatter.format(kv.getValue(), ctx));</code>
<code class="calibre21">                    break;</code>
<code class="calibre21">                default:</code>
<code class="calibre21">                    ctx.advance:to(m_keyFormatter.format(kv.getKey(), ctx));</code>
<code class="calibre21">                    ctx.advance:to(format_to(ctx.out(), " - "));</code>
<span aria-label="116" class="calibre20" epub:type="pagebreak" id="Page_116" role="doc-pagebreak"></span><code class="calibre21">                    ctx.advance:to(m_valueFormatter.format(kv.getValue(), ctx));</code>
<code class="calibre21">                    break;</code>
<code class="calibre21">            }</code>
<code class="calibre21">            return ctx.out();</code>
<code class="calibre21">        }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        enum class OutputType { KeyOnly, ValueOnly, KeyAndValue };</code>
<code class="calibre21">        OutputType m_outputType { OutputType::KeyAndValue };</code>
<code class="calibre21">        formatter&lt;string&gt; m_keyFormatter;</code>
<code class="calibre21">        formatter&lt;int&gt; m_valueFormatter;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c02-para-0200">
       The
       <code class="calibre21">
        parse()
       </code>
       member function is responsible for parsing the format specifier given as a character range [
       <code class="calibre21">
        begin(context)
       </code>
       ,
       <code class="calibre21">
        end(context)
       </code>
       ). It stores the result of the parsing in data members of the
       <code class="calibre21">
        formatter
       </code>
       class and returns an iterator pointing to the character after the end of the parsed format specifier string. Two of the data members are
       <code class="calibre21">
        m_keyFormatter
       </code>
       of type
       <code class="calibre21">
        formatter&lt;string&gt;
       </code>
       and
       <code class="calibre21">
        m_valueFormatter
       </code>
       of type
       <code class="calibre21">
        formatter&lt;int&gt;
       </code>
       to handle parsing the
       <i class="calibre18">
        <code class="calibre21">
         KeyFormat
        </code>
       </i>
       and
       <i class="calibre18">
        <code class="calibre21">
         ValueFormat
        </code>
       </i>
       parts, respectively, of the format specifier.
      </p>
      <p class="calibre13" id="c02-para-0201">
       The
       <code class="calibre21">
        format()
       </code>
       member function formats the value given as first argument according to the format specification parsed by
       <code class="calibre21">
        parse()
       </code>
       , writes the result to
       <code class="calibre21">
        ctx.out()
       </code>
       , and returns an iterator to the end of the output. The function uses
       <code class="calibre21">
        std::format_to()
       </code>
       , which is similar to
       <code class="calibre21">
        std::format()
       </code>
       , except that it accepts an output iterator indicating where the output should be written to.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        KeyValue
       </code>
       formatter can be tested as follows:
      </p>
      <pre class="calibre26" id="c02-code-0113"><code class="calibre21">const size_t len { 34 }; <span class="color">// Label field length</span></code>
<code class="calibre21">KeyValue kv { "Key 1", 255 };</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{}</b>",   "Default:", len, kv);</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{:k}</b>", "Key only:", len, kv);</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{:v}</b>", "Value only:", len, kv);</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{:b}</b>", "Key and value with default format:", len, kv);</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{:k:*^11}</b>",     "Key only with special format:", len, kv);</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{:v::#06X}</b>",    "Value only with special format:", len, kv);</code>
<code class="calibre21">println("{:&gt;{}} <b class="calibre14">{::*^11:#06X}</b>", "Key and value with special format:", len, kv);</code>
<code class="calibre21">try {</code>
<code class="calibre21">    auto formatted { vformat("{:cd}", make_format_args(kv)) };</code>
<code class="calibre21">    println("{}", formatted);</code>
<code class="calibre21">} catch (const format_error&amp; caught_exception) {</code>
<code class="calibre21">    println("{}", caught_exception.what());</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c02-code-0114"><code class="calibre21">                          Default: Key 1 - 255</code>
<code class="calibre21">                         Key only: Key 1</code>
<code class="calibre21">                       Value only: 255</code>
<code class="calibre21">Key and value with default format: Key 1 - 255</code>
<code class="calibre21">     Key only with special format: ***Key 1***</code>
<code class="calibre21">   Value only with special format: 0X00FF</code>
<code class="calibre21">Key and value with special format: ***Key 1*** - 0X00FF</code>
<code class="calibre21">Invalid KeyValue format.</code></pre>
      <p class="calibre13" id="c02-para-0204">
       <span aria-label="117" class="calibre20" epub:type="pagebreak" id="Page_117" role="doc-pagebreak">
       </span>
       As an exercise, you could add support for a different separator symbol between the key and the value. With custom formatters, the possibilities are endless, and everything is type safe!
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-61" class="calibre2">
     <span class="calibre" id="c02-sec-0053">
     </span>
     <h2 class="calibre6" id="head-2-61">
      SUMMARY
     </h2>
     <p class="calibre13" id="c02-para-0205">
      This chapter discussed the C++
      <code class="calibre21">
       string
      </code>
      and
      <code class="calibre21">
       string_view
      </code>
      classes and what their benefits are compared to plain old C-style character arrays. It also explained how a number of helper functions make it easier to convert numerical values into
      <code class="calibre21">
       string
      </code>
      s and vice versa, and it introduced the concept of raw string literals.
     </p>
     <p class="calibre13" id="c02-para-0206">
      The chapter finished with a discussion of the string formatting library, used throughout examples in this book. It is a powerful mechanism to format strings with fine-grained control over how the formatted output should look.
     </p>
     <p class="calibre13" id="c02-para-0207">
      The next chapter discusses guidelines for good coding style, including code documentation, decomposition, naming, code formatting, and other tips.
     </p>
    </section>
    <section aria-labelledby="head-2-62" class="calibre2">
     <span class="calibre" id="c02-sec-0054">
     </span>
     <h2 class="calibre6" id="head-2-62">
      EXERCISES
     </h2>
     <p class="calibre13" id="c02-para-0208">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c02-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c02-ex-0001">
        <b class="calibre14">
         Exercise 2-1:
        </b>
        Write a program that asks the user for two strings and then prints them out in alphabetical order, using the three-way comparison operator. To ask the user for a string, you can use the
        <code class="calibre21">
         std::cin
        </code>
        stream, briefly introduced in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        .
        <a class="calibre5" href="c13.xhtml">
         Chapter 13
        </a>
        , “Demystifying C++ I/O,” explains input and output in detail, but for now, here is how to read in a string from the console. To terminate the line, just press Enter.
        <pre class="calibre26" id="c02-code-0115"><code class="calibre21">std::string s;</code>
<code class="calibre21">getline(cin, s1);</code></pre>
       </li>
       <li class="calibre9" id="c02-ex-0002">
        <b class="calibre14">
         Exercise 2-2:
        </b>
        Write a program that asks the user for a source string (= haystack), a string to find in the source string (= needle), and a replacement string. Write a function with three parameters—the haystack, needle, and replacement string—that returns a copy of the haystack with all needles replaced with the replacement string. Use only
        <code class="calibre21">
         std::string
        </code>
        , no
        <code class="calibre21">
         string_view
        </code>
        . What kind of parameter types will you use and why? Call this function from
        <code class="calibre21">
         main()
        </code>
        and print out all the strings for verification.
       </li>
       <li class="calibre9" id="c02-ex-0003">
        <b class="calibre14">
         Exercise 2-3:
        </b>
        Modify the program from Exercise 2-2 and use
        <code class="calibre21">
         std::string_view
        </code>
        on as many places as reasonable.
       </li>
       <li class="calibre9" id="c02-ex-0004">
        <b class="calibre14">
         Exercise 2-4:
        </b>
        Write a program that asks the user to enter an unknown number of floating-point numbers and stores all numbers in a
        <code class="calibre21">
         vector
        </code>
        . Each number should be entered followed by a new line. Stop asking for more numbers when the user inputs the number 0. To read a floating-point number from the console, use
        <code class="calibre21">
         cin
        </code>
        in the same way it was used in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        <span aria-label="118" class="calibre20" epub:type="pagebreak" id="Page_118" role="doc-pagebreak">
        </span>
        to input integer values. Format all numbers in a table with a couple of columns where each column outputs the number in a different format. Each row in the table corresponds to one of the inputted numbers.
       </li>
       <li class="calibre9" id="c02-ex-0005">
        <b class="calibre14">
         Exercise 2-5:
        </b>
        Write a program that asks the user to enter an unknown number of words. Stop the input when the user enters
        <code class="calibre21">
         *
        </code>
        . Store all the individual words in a
        <code class="calibre21">
         vector
        </code>
        . You can input individual words using the following:
        <pre class="calibre26" id="c02-code-0116"><code class="calibre21">std::string word;</code>
<code class="calibre21">cin&gt;&gt; word;</code></pre>
        <p class="listpara" id="c02-para-0216">
         When the input is finished, calculate the length of the longest word. Finally, output all the words in columns, five on a row. The width of the columns is based on the longest word. Output the words centered within their column, and separate the columns with the
         <code class="calibre21">
          |
         </code>
         character.
        </p>
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c02_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c02_2">
     NOTES
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c02-note-0001" id="c02-note-0001" role="doc-backlink">
       1
      </a>
      Starting with C++23, the integer overloads of
      <code class="calibre21">
       to_chars()
      </code>
      and
      <code class="calibre21">
       from_chars()
      </code>
      are marked as
      <code class="calibre21">
       constexpr
      </code>
      . This means that they can be evaluated at compile time in other
      <code class="calibre21">
       constexpr
      </code>
      functions and classes. See
      <a class="calibre5" href="c09.xhtml">
       Chapter 9
      </a>
      , “Mastering Classes and Objects,” for a discussion of
      <code class="calibre21">
       constexpr
      </code>
      .
     </li>
     <li class="noteentry">
      <a class="calibre5" href="#R_c02-note-0002" id="c02-note-0002" role="doc-backlink">
       2
      </a>
      To compile source code containing Unicode characters, you might need to pass a compiler switch. For Visual C++, you must pass the
      <code class="calibre21">
       /utf-8
      </code>
      compiler switch. For GCC, use the command line option -finput-charset=UTF-8. Clang assumes all files are UTF-8 by default. Check your compiler documentation.
     </li>
     <li class="noteentry">
      <a class="calibre5" href="#R_c02-note-0003" id="c02-note-0003" role="doc-backlink">
       3
      </a>
      This is a breaking change for std::format(). Prior to C++23, the format string for format() was not enforced to be a compile-time constant.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
