<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   7
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_010.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_012.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="_idContainer120">
    <h1 class="chapter-number" id="_idParaDest-158">
     <a id="_idTextAnchor158">
     </a>
     7
    </h1>
    <h1 id="_idParaDest-159">
     <a id="_idTextAnchor159">
     </a>
     Using Network and Managing Large Documents
    </h1>
    <p>
     In this chapter, we will learn how to create a networking server program and a client program using Qt 6’s networking module. We will also learn how to create a program that uses
     <strong class="bold">
      File Transfer Protocol
     </strong>
     (
     <strong class="bold">
      FTP
     </strong>
     ) to upload and download files from the server. Lastly, we will learn how to send HTTP requests to a specific web service using Qt 6 and
     <span class="No-Break">
      C++ language.
     </span>
    </p>
    <p>
     In this chapter, we’re going to cover the following
     <span class="No-Break">
      main topics:
     </span>
    </p>
    <ul>
     <li>
      Creating a
      <span class="No-Break">
       TCP server
      </span>
     </li>
     <li>
      Creating a
      <span class="No-Break">
       TCP client
      </span>
     </li>
     <li>
      Uploading and downloading files
      <span class="No-Break">
       using FTP
      </span>
     </li>
    </ul>
    <h1 id="_idParaDest-160">
     <a id="_idTextAnchor160">
     </a>
     Technical requirements
    </h1>
    <p>
     The technical requirements for this chapter are Qt 6.6.1, Qt Creator 12.0.2, and FileZilla. All the code used in this chapter can be downloaded from the following GitHub
     <span class="No-Break">
      repository:
     </span>
     <a href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07">
      <span class="No-Break">
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter07
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <h1 id="_idParaDest-161">
     <a id="_idTextAnchor161">
     </a>
     Creating a TCP server
    </h1>
    <p>
     In this recipe, we
     <a id="_idIndexMarker462">
     </a>
     will learn how to create a
     <strong class="bold">
      Transmission Control Protocol
     </strong>
     (
     <strong class="bold">
      TCP
     </strong>
     ) server in Qt 6. Before we’re able to
     <a id="_idIndexMarker463">
     </a>
     create a server that lets us upload and download files, let’s scale it down a bit and learn how to create a networking server that receives and
     <span class="No-Break">
      delivers texts.
     </span>
    </p>
    <h2 id="_idParaDest-162">
     <a id="_idTextAnchor162">
     </a>
     How to do it…
    </h2>
    <p>
     Follow these steps to create a
     <span class="No-Break">
      TCP server:
     </span>
    </p>
    <ol>
     <li>
      First, let’s create a
      <strong class="bold">
       Qt Console Application
      </strong>
      project from
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      , as shown in the
      <a id="_idIndexMarker464">
      </a>
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer104">
      <img alt="Figure 7.1 – Creating a new Qt Console Application project" src="../images\image/B20976_07_001.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.1 – Creating a new Qt Console Application project
    </p>
    <ol>
     <li value="2">
      After that, go to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      again but this time, select
      <strong class="bold">
       C++ Class
      </strong>
      under the
      <strong class="bold">
       C/C++
      </strong>
      category, as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer105">
      <img alt="Figure 7.2 – Creating a new C++ class" src="../images\image/B20976_07_002.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.2 – Creating a new C++ class
    </p>
    <ol>
     <li value="3">
      Then, name your class
      <strong class="source-inline">
       server
      </strong>
      . Set its base class to
      <strong class="bold">
       QObject
      </strong>
      and make sure the
      <strong class="bold">
       Include QObject
      </strong>
      option is
      <a id="_idIndexMarker465">
      </a>
      checked before clicking the
      <strong class="bold">
       Next
      </strong>
      button. Once the class has been created, two files will be created for you—
      <strong class="source-inline">
       server.h
      </strong>
      and
      <strong class="source-inline">
       server.cpp
      </strong>
      , as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer106">
      <img alt="Figure 7.3 – Defining the server class" src="../images\image/B20976_07_003.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.3 – Defining the server class
    </p>
    <ol>
     <li value="4">
      After that, open up your project file (
      <strong class="source-inline">
       .pro
      </strong>
      ) and add the
      <strong class="source-inline">
       network
      </strong>
      module, as shown in the
      <a id="_idIndexMarker466">
      </a>
      following code. Then, run
      <strong class="source-inline">
       qmake
      </strong>
      again to reload
      <span class="No-Break">
       the modules:
      </span>
      <pre class="source-code">
QT += core <strong class="bold">network</strong></pre>
     </li>
     <li>
      Once you’re done, open up
      <strong class="source-inline">
       server.h
      </strong>
      and add the following headers
      <span class="No-Break">
       to it:
      </span>
      <pre class="source-code">
#include &lt;QTcpServer&gt;
#include &lt;QTcpSocket&gt;
#include &lt;QVector&gt;
#include &lt;QDebug&gt;</pre>
     </li>
     <li>
      Right after that, declare the
      <strong class="source-inline">
       startServer()
      </strong>
      and
      <strong class="source-inline">
       sendMessageToClients()
      </strong>
      functions, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
public:
      server(QObject *parent = nullptr);
      <strong class="bold">void startServer();</strong>
<strong class="bold">      void sendMessageToClients(QString message);</strong></pre>
     </li>
     <li>
      Then, declare the
      <a id="_idIndexMarker467">
      </a>
      following slot functions for the
      <span class="No-Break">
       <strong class="source-inline">
        server
       </strong>
      </span>
      <span class="No-Break">
       class:
      </span>
      <pre class="source-code">
public slots:
     void newClientConnection();
     void socketDisconnected();
     void socketReadReady();
     void socketStateChanged(QAbstractSocket::SocketState state);</pre>
     </li>
     <li>
      Finally, declare two private variables, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
private:
     QTcpServer* chatServer;
     QVector&lt;QTcpSocket*&gt;* allClients;</pre>
     </li>
     <li>
      Once you’re done with the preceding step, open up
      <strong class="source-inline">
       server.cpp
      </strong>
      and define the
      <strong class="source-inline">
       startServer()
      </strong>
      function. Here, we create a
      <strong class="source-inline">
       QVector
      </strong>
      container to store all the clients that are connected to the server and use it to send out messages in later steps. This is shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void server::startServer() {
     allClients = new QVector&lt;QTcpSocket*&gt;;
     chatServer = new QTcpServer();
     chatServer-&gt;setMaxPendingConnections(10);
     connect(chatServer, &amp;QTcpServer::newConnection,      this, &amp;server::newClientConnection);
if (chatServer-&gt;listen(QHostAddress::Any, 8001))
     qDebug() &lt;&lt; "Server has started. Listening to port     8001.";
else
     qDebug() &lt;&lt; "Server failed to start. Error: " +   chatServer-&gt;errorString();
}</pre>
     </li>
     <li>
      Next, we implement
      <a id="_idIndexMarker468">
      </a>
      the
      <strong class="source-inline">
       sendMessageToClients()
      </strong>
      function, where we iterate through the
      <strong class="source-inline">
       allClients
      </strong>
      container we just created in the previous step, and send the message to each client, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void server::sendMessageToClients(QString message) {
if (allClients-&gt;size() &gt; 0) {
     for (int i = 0; i &lt; allClients-&gt;size(); i++) {
     if (allClients-&gt;at(i)-&gt;isOpen() &amp;&amp; allClients-   &gt;at(i)-&gt;isWritable()) {
     allClients-&gt;at(i)-&gt;write(message.toUtf8());
}
}}}</pre>
     </li>
     <li>
      After that, we will start implementing the slot functions. Let’s start with the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void server::newClientConnection() {
     QTcpSocket* client = chatServer-&gt;nextPendingConnection();
     QString ipAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     connect(client, &amp;QTcpSocket::disconnected, this, &amp;server::socketDisconnected);
     connect(client, &amp;QTcpSocket::readyRead,this, &amp;server::socketReadReady);
     connect(client, &amp;QTcpSocket::stateChanged, this, &amp;server::socketStateChanged);
     allClients-&gt;push_back(client);
     qDebug() &lt;&lt; "Socket connected from " + ipAddress + ":" + QString::number(port);
}</pre>
     </li>
     <li>
      Then, we’ll
      <a id="_idIndexMarker469">
      </a>
      proceed with the
      <strong class="source-inline">
       socketDisconnected()
      </strong>
      function. This slot function will be called when a client has been disconnected from the server, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void server::socketDisconnected() {
     QTcpSocket* client = qobject_cast&lt;QTcpSocket*&gt;(QObject::sender());
     QString socketIpAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     qDebug() &lt;&lt; "Socket disconnected from " + socketIpAddress + ":" + QString::number(port);
}</pre>
     </li>
     <li>
      Next, we’ll define the
      <strong class="source-inline">
       socketReadReady()
      </strong>
      function, which will be triggered when a client sends a text message to the server, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void server::socketReadReady() {
     QTcpSocket* client = qobject_cast&lt;QTcpSocket*&gt;(QObject::sender());
     QString socketIpAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     QString data = QString(client-&gt;readAll());
     qDebug() &lt;&lt; "Message: " + data + " (" + socketIpAddress + ":" + QString::number(port) + ")";
     sendMessageToClients(data);
}</pre>
     </li>
     <li>
      After that, let’s
      <a id="_idIndexMarker470">
      </a>
      implement the
      <strong class="source-inline">
       socketStateChanged()
      </strong>
      function, which will be called when the networking state of a client has changed, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void server::socketStateChanged(QAbstractSocket::SocketState state) {
     QTcpSocket* client = qobject_cast&lt;QTcpSocket*&gt;(QObject::sender());
     QString socketIpAddress = client-&gt;peerAddress().toString();
     int port = client-&gt;peerPort();
     qDebug() &lt;&lt; "Socket state changed (" + socketIpAddress + ":" + QString::number(port) + "): " + desc;
}</pre>
     </li>
     <li>
      We also need to add the following code into
      <strong class="source-inline">
       socketStateChanged()
      </strong>
      to print out the status of
      <span class="No-Break">
       the client:
      </span>
      <pre class="source-code">
     QString desc;
     if (state == QAbstractSocket::UnconnectedState)
           desc = "The socket is not connected.";
     else if (state == QAbstractSocket::HostLookupState)
           desc = "The socket is performing a host name lookup.";
     else if (state == QAbstractSocket::ConnectingState)
           desc = "The socket has started establishing a connection.";
     else if (state == QAbstractSocket::ConnectedState)
           desc = "A connection is established.";
     else if (state == QAbstractSocket::BoundState)
           desc = "The socket is bound to an address and port.";
     else if (state == QAbstractSocket::ClosingState)
           desc = "The socket is about to close (data may still be waiting to be written).";
     else if (state == QAbstractSocket::ListeningState)
           desc = "For internal use only.";</pre>
     </li>
     <li>
      Lastly, let’s open up
      <strong class="source-inline">
       main.cpp
      </strong>
      and add the highlighted code in the following example in order to
      <a id="_idIndexMarker471">
      </a>
      initiate
      <span class="No-Break">
       the server:
      </span>
      <pre class="source-code">
#include &lt;QCoreApplication&gt;
#include "server.h"
     int main(int argc, char *argv[]) {
     QCoreApplication a(argc, argv);
     <strong class="bold">server* myServer = new server();</strong>
     <strong class="bold">myServer-&gt;startServer();</strong>
     return a.exec();
}</pre>
     </li>
     <li>
      You can try and run the server program now but you won’t be able to test it as we have not created the client program yet, as the following
      <span class="No-Break">
       screenshot shows:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer107">
      <img alt="Figure 7.4 – Server is now listening to port 8001" src="../images\image/B20976_07_004.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.4 – Server is now listening to port 8001
    </p>
    <ol>
     <li value="18">
      Let’s proceed to the next example project and learn how to create the client program. We will
      <a id="_idIndexMarker472">
      </a>
      come back to test this program again
      <span class="No-Break">
       later on.
      </span>
     </li>
    </ol>
    <h2 id="_idParaDest-163">
     <a id="_idTextAnchor163">
     </a>
     How it works…
    </h2>
    <p>
     There are mainly two types of network connections—the TCP connection and the
     <strong class="bold">
      User Datagram Protocol
     </strong>
     (
     <strong class="bold">
      UDP
     </strong>
     ) connection. TCP is
     <a id="_idIndexMarker473">
     </a>
     a reliable networking connection, while UDP
     <span class="No-Break">
      is unreliable.
     </span>
    </p>
    <p>
     These two connections are designed for very
     <span class="No-Break">
      different purposes:
     </span>
    </p>
    <ul>
     <li>
      TCP networking is usually for programs that require every single piece of data to be sent and received in order. It also makes sure that the client receives the data and that the server gets notified of that. Programs such as messaging software, web servers, and databases use
      <span class="No-Break">
       TCP networking.
      </span>
     </li>
     <li>
      UDP networking, on the other hand, does not require constant handholding between the server and client. Since the connection is unreliable, there is also no feedback on whether the data has been successfully received. The dropping of packets is tolerated, and data may not even come in the same order as it was sent. UDP connections are usually used by applications that stream huge amounts of data to their clients without strict requirements on its packet delivery, such as video games, video conferencing software, and domain
      <span class="No-Break">
       name systems.
      </span>
     </li>
    </ul>
    <p>
     Creating networking software using Qt 6 is a lot easier through its signals and slots mechanism. All we need to do is connect the signals emitted by the
     <strong class="source-inline">
      QTcpServer
     </strong>
     class and
     <strong class="source-inline">
      QTcpSocket
     </strong>
     class to our slot functions. We will then implement these slot functions and define what to do within
     <span class="No-Break">
      those functions.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     We used a
     <strong class="source-inline">
      QVector
     </strong>
     container to store the pointers to all the clients that have connected to the server so that we can use it to deliver the messages
     <span class="No-Break">
      later on.
     </span>
    </p>
    <p>
     To keep this example
     <a id="_idIndexMarker474">
     </a>
     project simple, we simply send text messages to all the clients, sort of like a group chat. You are free to explore other possibilities and make your own changes to improve
     <span class="No-Break">
      the program.
     </span>
    </p>
    <h1 id="_idParaDest-164">
     <a id="_idTextAnchor164">
     </a>
     Creating a TCP client
    </h1>
    <p>
     Since we created a TCP server in the previous recipe, we now need a client program to complete the project. Therefore, in this
     <a id="_idIndexMarker475">
     </a>
     recipe, we will learn how to create a TCP client program using Qt 6 and its
     <span class="No-Break">
      network module.
     </span>
    </p>
    <h2 id="_idParaDest-165">
     <a id="_idTextAnchor165">
     </a>
     How to do it…
    </h2>
    <p>
     To create a TCP client in Qt 6, let’s do
     <span class="No-Break">
      the following:
     </span>
    </p>
    <ol>
     <li>
      First off, let’s create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project from
      <strong class="bold">
       Files
      </strong>
      |
      <strong class="bold">
       New File
      </strong>
      <span class="No-Break">
       <strong class="bold">
        or Project
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      Once the project has been created, let’s open up
      <strong class="source-inline">
       mainwindow.ui
      </strong>
      and set up the GUI as shown in the following diagram. Please note that the layout direction of the central widget has to
      <span class="No-Break">
       be vertical:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer108">
      <img alt="Figure 7.5 – The layout of our client program" src="../images\image/B20976_07_005.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.5 – The layout of our client program
    </p>
    <ol>
     <li value="3">
      Then, right-click on the push button that says
      <strong class="bold">
       Connect
      </strong>
      and create a
      <strong class="source-inline">
       clicked()
      </strong>
      slot function
      <a id="_idIndexMarker476">
      </a>
      from the menu. Then, repeat the same step on the
      <strong class="bold">
       Send
      </strong>
      button as well. As a result, two slot functions will be created for you in the source code, which may or may not look like what we see in the following code, depending on your
      <span class="No-Break">
       widget’s name:
      </span>
      <pre class="source-code">
void on_connectButton_clicked();
void on_sendButton_clicked();</pre>
     </li>
     <li>
      Next, open up
      <strong class="source-inline">
       mainwindow.h
      </strong>
      and add the
      <span class="No-Break">
       following headers:
      </span>
      <pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QTcpSocket&gt;</pre>
     </li>
     <li>
      Then, declare the
      <strong class="source-inline">
       printMessage()
      </strong>
      function and three slot functions:
      <strong class="source-inline">
       socketConnected()
      </strong>
      ,
      <strong class="source-inline">
       socketDisconnected()
      </strong>
      , and
      <strong class="source-inline">
       socketReadyRead()
      </strong>
      , as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
public:
     explicit MainWindow(QWidget *parent = 0);
     ~MainWindow();
     <strong class="bold">void printMessage(QString message);</strong>
private slots:
     void on_connectButton_clicked();
     void on_sendButton_clicked();
     <strong class="bold">void socketConnected();</strong>
     <strong class="bold">void socketDisconnected();</strong>
     <strong class="bold">void socketReadyRead();</strong></pre>
     </li>
     <li>
      After that, declare the following
      <a id="_idIndexMarker477">
      </a>
      variables
      <span class="No-Break">
       as well:
      </span>
      <pre class="source-code">
private:
     Ui::MainWindow *ui;
     <strong class="bold">bool connectedToHost;</strong>
     <strong class="bold">QTcpSocket* socket;</strong></pre>
     </li>
     <li>
      Once you’re done with that, you can proceed to
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      and define the
      <strong class="source-inline">
       printMessage()
      </strong>
      function, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void MainWindow::printMessage(QString message) {
     ui-&gt;chatDisplay-&gt;append(message);
}</pre>
     </li>
     <li>
      Then, we’ll implement the
      <strong class="source-inline">
       on_connectButton_clicked()
      </strong>
      function, which will be triggered when the
      <strong class="bold">
       Connect
      </strong>
      button is clicked, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::on_connectButton_clicked() {
     if (!connectedToHost) {
           socket = new QTcpSocket();
           connect(socket, &amp;QTcpSocket::connected, this, &amp;MainWindow::socketConnected);
           connect(socket, &amp;QTcpSocket::disconnected, this, &amp;MainWindow::socketDisconnected);
           connect(socket, &amp;QTcpSocket::readyRead, this, &amp;MainWindow::socketReadyRead);
           socket-&gt;connectToHost("127.0.0.1", 8001);
     }
     else {
           QString name = ui-&gt;nameInput-&gt;text();
           socket-&gt;write("&lt;font color=\"Orange\"&gt;" + name.toUtf8() + " has left the chat room.&lt;/font&gt;");
           socket-&gt;disconnectFromHost();
     }
}</pre>
     </li>
     <li>
      We also define the
      <strong class="source-inline">
       on_sendButton_clicked()
      </strong>
      function, which will be called when the
      <strong class="bold">
       Send
      </strong>
      button is
      <a id="_idIndexMarker478">
      </a>
      clicked, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void MainWindow::on_sendButton_clicked() {
     QString name = ui-&gt;nameInput-&gt;text();
     QString message = ui-&gt;messageInput-&gt;text();
     socket-&gt;write("&lt;font color=\"Blue\"&gt;" + name.toUtf8() + "&lt;/font&gt;: " + message.toUtf8());
     ui-&gt;messageInput-&gt;clear();
}</pre>
     </li>
     <li>
      Right after that, we implement the
      <strong class="source-inline">
       socketConnected()
      </strong>
      function, which will be called when the client program has been successfully connected to the server, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::socketConnected() {
     qDebug() &lt;&lt; "Connected to server.";
     printMessage("&lt;font color=\"Green\"&gt;Connected to server.&lt;/font&gt;");
     QString name = ui-&gt;nameInput-&gt;text();
     socket-&gt;write("&lt;font color=\"Purple\"&gt;" + name.toUtf8() + " has joined the chat room.&lt;/font&gt;");
     ui-&gt;connectButton-&gt;setText("Disconnect");
     connectedToHost = true;
}</pre>
     </li>
     <li>
      We are not yet done at this point. We also need to implement the
      <strong class="source-inline">
       socketDisconnected()
      </strong>
      function, which will be triggered whenever the client has been disconnected from
      <a id="_idIndexMarker479">
      </a>
      the server, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::socketDisconnected() {
     qDebug() &lt;&lt; "Disconnected from server.";
     printMessage("&lt;font color=\"Red\"&gt;Disconnected from server.&lt;/font&gt;");
     ui-&gt;connectButton-&gt;setText("Connect");
     connectedToHost = false;
}</pre>
     </li>
     <li>
      Lastly, we also need to define the
      <strong class="source-inline">
       socketReadyRead()
      </strong>
      function, which prints out the message sent from the server, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void MainWindow::socketReadyRead() {
     printMessage(socket-&gt;readAll());
}</pre>
     </li>
     <li>
      Before we run the client program, we must first turn on the server program that we created in the previous recipe. Then, build and run the client program. Once the program has been opened, go and click the
      <strong class="bold">
       Connect
      </strong>
      button. After you have successfully connected to the server, type something in the line edit widget located at the bottom and press the
      <strong class="bold">
       Send
      </strong>
      button. You should see something similar to the
      <a id="_idIndexMarker480">
      </a>
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer109">
      <img alt="Figure 7.6 – Our chat program is now working" src="../images\image/B20976_07_006.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.6 – Our chat program is now working
    </p>
    <ol>
     <li value="14">
      Let’s go to the server program, shown in the following screenshot, and see whether there is anything printed on the
      <span class="No-Break">
       terminal window:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer110">
      <img alt="Figure 7.7 – Client activities are also shown on the server output" src="../images\image/B20976_07_007.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.7 – Client activities are also shown on the server output
    </p>
    <ol>
     <li value="15">
      Congratulations, you have successfully
      <a id="_idIndexMarker481">
      </a>
      created a program that looks a bit
      <a id="_idIndexMarker482">
      </a>
      like an
      <strong class="bold">
       Internet Relay Chat
      </strong>
      (
      <strong class="bold">
       IRC
      </strong>
      )
      <span class="No-Break">
       chat room!
      </span>
     </li>
    </ol>
    <h2 id="_idParaDest-166">
     <a id="_idTextAnchor166">
     </a>
     How it works…
    </h2>
    <p>
     In order for this to work, we need two programs: a server program that connects all the clients and delivers their messages, and a client program used by the users to send and receive messages from
     <span class="No-Break">
      other users.
     </span>
    </p>
    <p>
     Since the server program just sits behind the scenes and works out everything in silence, it doesn’t need any user interface, and thus we only need it as a Qt
     <span class="No-Break">
      Console application.
     </span>
    </p>
    <p>
     The client program, however, requires a visually pleasant yet easy-to-use GUI for the users to read and write their messages. Therefore, we created the client program as a Qt Widgets
     <span class="No-Break">
      application instead.
     </span>
    </p>
    <p>
     The client program is relatively simple when compared to the server program. All it does is connect to the server, send out the message input by the user, and print out everything the server sends
     <span class="No-Break">
      to it.
     </span>
    </p>
    <h1 id="_idParaDest-167">
     <a id="_idTextAnchor167">
     </a>
     Uploading and downloading files using FTP
    </h1>
    <p>
     We have learned how to create simple
     <a id="_idIndexMarker483">
     </a>
     chat software
     <a id="_idIndexMarker484">
     </a>
     that distributes text messages among the users. Next, we will learn how to create a program that uploads and downloads files
     <span class="No-Break">
      using FTP.
     </span>
    </p>
    <h2 id="_idParaDest-168">
     <a id="_idTextAnchor168">
     </a>
     How to do it…
    </h2>
    <p>
     Let’s get started by observing the
     <span class="No-Break">
      following steps:
     </span>
    </p>
    <ol>
     <li>
      For this project, we need to
      <a id="_idIndexMarker485">
      </a>
      install software called
      <strong class="bold">
       FileZilla Server
      </strong>
      , which we will use as the FTP server. FileZilla Server
      <a id="_idIndexMarker486">
      </a>
      can be downloaded from
      <a href="https://filezilla-project.org">
       https://filezilla-project.org
      </a>
      by clicking on the
      <strong class="bold">
       Download FileZilla Server
      </strong>
      button, as shown in the
      <span class="No-Break">
       following
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker487">
       </a>
      </span>
      <span class="No-Break">
       screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer111">
      <img alt="Figure 7.8 – Downloading FileZilla Server from the official website" src="../images\image/B20976_07_008.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.8 – Downloading FileZilla Server from the official website
    </p>
    <ol>
     <li value="2">
      Once you have downloaded the installer, run it and install
      <strong class="bold">
       FileZilla Server
      </strong>
      by agreeing to all the default options, as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer112">
      <img alt="Figure 7.9 – Default installation options will do" src="../images\image/B20976_07_009.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.9 – Default installation options will do
    </p>
    <ol>
     <li value="3">
      When it has
      <a id="_idIndexMarker488">
      </a>
      completed, open
      <a id="_idIndexMarker489">
      </a>
      up
      <strong class="bold">
       FileZilla Server
      </strong>
      and press the
      <strong class="bold">
       Connect to Server…
      </strong>
      button, and the
      <strong class="bold">
       Connection
      </strong>
      window will pop up, as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer113">
      <img alt="Figure 7.10 – Setting the host, port, and password in the Connection window" src="../images\image/B20976_07_010.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.10 – Setting the host, port, and password in the Connection window
    </p>
    <ol>
     <li value="4">
      After the server has been
      <a id="_idIndexMarker490">
      </a>
      started, go to
      <strong class="bold">
       Server
      </strong>
      |
      <strong class="bold">
       Configure…
      </strong>
      from the top menu, as highlighted
      <a id="_idIndexMarker491">
      </a>
      in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer114">
      <img alt="Figure 7.11 – Opening up the Settings window from the top menu" src="../images\image/B20976_07_011.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.11 – Opening up the Settings window from the top menu
    </p>
    <ol>
     <li value="5">
      Once the
      <strong class="bold">
       Settings
      </strong>
      window has been opened, click on the
      <strong class="bold">
       Add
      </strong>
      button located under the
      <strong class="bold">
       Available users
      </strong>
      list to add a new user. Then, add a shared folder under the
      <strong class="bold">
       Shared
      </strong>
      folders list, where your
      <a id="_idIndexMarker492">
      </a>
      users will be uploading and downloading files to and from, as
      <a id="_idIndexMarker493">
      </a>
      shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer115">
      <img alt="Figure 7.12 – Clicking the Add button to add a new user" src="../images\image/B20976_07_012.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.12 – Clicking the Add button to add a new user
    </p>
    <ol>
     <li value="6">
      We have now finished setting up FileZilla Server. Let’s move on to Qt Creator and create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project. Then, open up
      <strong class="source-inline">
       mainwindow.ui
      </strong>
      and set up the GUI, as shown in the
      <span class="No-Break">
       following diagram:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer116">
      <img alt="Figure 7.13 – Layout of our FPT program" src="../images\image/B20976_07_013.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.13 – Layout of our FPT program
    </p>
    <ol>
     <li value="7">
      Next, right-click on
      <a id="_idIndexMarker494">
      </a>
      the
      <strong class="bold">
       Open
      </strong>
      ,
      <strong class="bold">
       Upload
      </strong>
      , and
      <strong class="bold">
       Set Folder
      </strong>
      buttons and create their respective
      <strong class="source-inline">
       clicked()
      </strong>
      slot functions, as
      <a id="_idIndexMarker495">
      </a>
      shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
private slots:
     <strong class="bold">void on_openButton_clicked();</strong>
     <strong class="bold">void on_uploadButton_clicked();</strong>
     <strong class="bold">void on_setFolderButton_clicked();</strong></pre>
     </li>
     <li>
      After that, double-click on the list widget and select
      <strong class="bold">
       Go to slot...
      </strong>
      . Then, select the
      <strong class="source-inline">
       itemDoubleClicked(QListWidgetItem*)
      </strong>
      option and click
      <strong class="bold">
       OK
      </strong>
      , as shown in the
      <span class="No-Break">
       following
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker496">
       </a>
      </span>
      <span class="No-Break">
       screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer117">
      <img alt="Figure 7.14 – Selecting the itemDoubleClicked option" src="../images\image/B20976_07_014.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.14 – Selecting the itemDoubleClicked option
    </p>
    <ol>
     <li value="9">
      Then, declare additional slot
      <a id="_idIndexMarker497">
      </a>
      functions such as
      <strong class="source-inline">
       serverConnected()
      </strong>
      ,
      <strong class="source-inline">
       serverReply()
      </strong>
      , and
      <strong class="source-inline">
       dataReceived()
      </strong>
      , which we will implement later in
      <span class="No-Break">
       this chapter:
      </span>
      <pre class="source-code">
private slots:
     void on_openButton_clicked();
     void on_uploadButton_clicked();
     void on_setFolderButton_clicked();
     void on_fileList_itemDoubleClicked(QListWidgetItem *item);
     <strong class="bold">void serverConnected(const QHostAddress &amp;address, int port);</strong>
     <strong class="bold">void serverReply(int code, const QString &amp;parameters);</strong>
     <strong class="bold">void dataReceived(const QByteArray &amp;data);</strong></pre>
     </li>
     <li>
      Once you have created the
      <a id="_idIndexMarker498">
      </a>
      slot functions, go to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File…
      </strong>
      and create a new C++ class
      <a id="_idIndexMarker499">
      </a>
      <span class="No-Break">
       called
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        FtpDataChannel
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      Then, open up
      <strong class="source-inline">
       ftpdatachannel.h
      </strong>
      and add the following code
      <span class="No-Break">
       to it:
      </span>
      <pre class="source-code">
#ifndef FTPDATACHANNEL_H
#define FTPDATACHANNEL_H
#include &lt;QtCore/qobject.h&gt;
#include &lt;QtNetwork/qtcpserver.h&gt;
#include &lt;QtNetwork/qtcpsocket.h&gt;
#include &lt;memory&gt;
class FtpDataChannel : public QObject{
    Q_OBJECT
public:
    explicit FtpDataChannel(QObject *parent = nullptr);
    void listen(const QHostAddress &amp;address = QHostAddress::Any);
    void sendData(const QByteArray &amp;data);
    void close();
    QString portspec() const;
    QTcpServer m_server;
    std::unique_ptr&lt;QTcpSocket&gt; m_socket;
signals:
    void dataReceived(const QByteArray &amp;data);
};
#endif</pre>
     </li>
     <li>
      Right after that, open
      <a id="_idIndexMarker500">
      </a>
      the
      <strong class="source-inline">
       ftpdatachannel.cpp
      </strong>
      source file
      <a id="_idIndexMarker501">
      </a>
      and write the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
#include "ftpdatachannel.h"
FtpDataChannel::FtpDataChannel(QObject *parent) : QObject(parent){
    connect(&amp;m_server, &amp;QTcpServer::newConnection, this, [this](){
        m_socket.reset(m_server.nextPendingConnection());
        connect(m_socket.get(), &amp;QTcpSocket::readyRead, this, [this](){
            emit dataReceived(m_socket-&gt;readAll());
        });
        connect(m_socket.get(), &amp;QTcpSocket::bytesWritten, this, [this](qint64 bytes){
            qDebug() &lt;&lt; bytes;
            close();
        });
    });
}</pre>
     </li>
     <li>
      Then, we continue to
      <a id="_idIndexMarker502">
      </a>
      implement functions for the
      <strong class="source-inline">
       FtpDataChannel
      </strong>
      class, such as
      <strong class="source-inline">
       listen()
      </strong>
      ,
      <strong class="source-inline">
       sendData()
      </strong>
      ,
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        close()
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
void FtpDataChannel::listen(const QHostAddress &amp;address){
    m_server.listen(address);
}
void FtpDataChannel::sendData(const QByteArray &amp;data){
    if (m_socket)
        m_socket-&gt;write(QByteArray(data).replace("\n", "\r\n"));
}
void FtpDataChannel::close(){
    if (m_socket)
        m_socket-&gt;disconnectFromHost();
}</pre>
     </li>
     <li>
      Lastly, we implement the
      <strong class="source-inline">
       postspec()
      </strong>
      function, which composes the FTP server’s information
      <a id="_idIndexMarker503">
      </a>
      in a special format that can be sent back to the FTP server for
      <span class="No-Break">
       verification purposes:
      </span>
      <pre class="source-code">
QString FtpDataChannel::portspec() const{
    QString portSpec;
    quint32 ipv4 = m_server.serverAddress().toIPv4Address();
    quint16 port = m_server.serverPort();
    portSpec += QString::number((ipv4 &amp; 0xff000000) &gt;&gt; 24);
    portSpec += ',' + QString::number((ipv4 &amp; 0x00ff0000) &gt;&gt; 16);
    portSpec += ',' + QString::number((ipv4 &amp; 0x0000ff00) &gt;&gt; 8);
    portSpec += ',' + QString::number(ipv4 &amp; 0x000000ff);
    portSpec += ',' + QString::number((port &amp; 0xff00) &gt;&gt; 8);
    portSpec += ',' + QString::number(port &amp;0x00ff);
    return portSpec;
}</pre>
     </li>
     <li>
      Once we’re done with the
      <strong class="source-inline">
       FtpDataChannel
      </strong>
      class, go to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File…
      </strong>
      again and create another
      <a id="_idIndexMarker504">
      </a>
      new C++ class
      <span class="No-Break">
       called
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        FtpControlChannel
       </strong>
      </span>
      <span class="No-Break">
       .
      </span>
     </li>
     <li>
      Open up the newly
      <a id="_idIndexMarker505">
      </a>
      created
      <strong class="source-inline">
       ftpcontrolchannel.h
      </strong>
      and add the following code to the
      <span class="No-Break">
       header file:
      </span>
      <pre class="source-code">
#ifndef FTPCONTROLCHANNEL_H
#define FTPCONTROLCHANNEL_H
#include &lt;QtNetwork/qhostaddress.h&gt;
#include &lt;QtNetwork/qtcpsocket.h&gt;
#include &lt;QtCore/qobject.h&gt;
class FtpControlChannel : public QObject{
    Q_OBJECT
public:
    explicit FtpControlChannel(QObject *parent = nullptr);
    void connectToServer(const QString &amp;server);
    void command(const QByteArray &amp;command, const QByteArray &amp;params);
public slots:
    void error(QAbstractSocket::SocketError);
signals:
    void opened(const QHostAddress &amp;localAddress, int localPort);
    void closed();
    void info(const QByteArray &amp;info);
    void reply(int code, const QByteArray &amp;parameters);
    void invalidReply(const QByteArray &amp;reply);
private:
    void onReadyRead();
    QTcpSocket m_socket;
    QByteArray m_buffer;
};
#endif // FTPCONTROLCHANNEL_H</pre>
     </li>
     <li>
      Then, let’s
      <a id="_idIndexMarker506">
      </a>
      open up
      <strong class="source-inline">
       ftpcontrolchannel.cpp
      </strong>
      and write the
      <span class="No-Break">
       following
      </span>
      <span class="No-Break">
       <a id="_idIndexMarker507">
       </a>
      </span>
      <span class="No-Break">
       code:
      </span>
      <pre class="source-code">
#include "ftpcontrolchannel.h"
#include &lt;QtCore/qcoreapplication.h&gt;
FtpControlChannel::FtpControlChannel(QObject *parent) : QObject(parent){
    connect(&amp;m_socket, &amp;QIODevice::readyRead,
            this, &amp;FtpControlChannel::onReadyRead);
    connect(&amp;m_socket, &amp;QAbstractSocket::disconnected,
            this, &amp;FtpControlChannel::closed);
    connect(&amp;m_socket, &amp;QAbstractSocket::connected, this, [this]() {
        emit opened(m_socket.localAddress(), m_socket.localPort());
    });
    connect(&amp;m_socket, &amp;QAbstractSocket::errorOccurred,
            this, &amp;FtpControlChannel::error);
}</pre>
     </li>
     <li>
      Then, we continue to
      <a id="_idIndexMarker508">
      </a>
      implement other
      <a id="_idIndexMarker509">
      </a>
      functions of the class, such as
      <strong class="source-inline">
       connectToServer()
      </strong>
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        command()
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
void FtpControlChannel::connectToServer(const QString &amp;server){
    m_socket.connectToHost(server, 21);
}
void FtpControlChannel::command(const QByteArray &amp;command, const QByteArray &amp;params){
    QByteArray sendData = command;
    if (!params.isEmpty())
        sendData += " " + params;
    m_socket.write(sendData + "\r\n");
}</pre>
     </li>
     <li>
      Right after that, we continue
      <a id="_idIndexMarker510">
      </a>
      to write the code for
      <a id="_idIndexMarker511">
      </a>
      its slot functions—namely,
      <strong class="source-inline">
       onReadyRead()
      </strong>
      <span class="No-Break">
       and
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        error()
       </strong>
      </span>
      <span class="No-Break">
       :
      </span>
      <pre class="source-code">
void FtpControlChannel::onReadyRead(){
    m_buffer.append(m_socket.readAll());
    int rn = -1;
    while ((rn = m_buffer.indexOf("\r\n")) != -1) {
        QByteArray received = m_buffer.mid(0, rn);
        m_buffer = m_buffer.mid(rn + 2);
        int space = received.indexOf(' ');
        if (space != -1) {
            int code = received.mid(0, space).toInt();
            if (code == 0) {
                qDebug() &lt;&lt; "Info received: " &lt;&lt; received.mid(space + 1);
                emit info(received.mid(space + 1));
            } else {
                qDebug() &lt;&lt; "Reply received: " &lt;&lt; received.mid(space + 1);
                emit reply(code, received.mid(space + 1));
            }
        } else {
            emit invalidReply(received);
        }
    }
}
void FtpControlChannel::error(QAbstractSocket::SocketError error){
    qWarning() &lt;&lt; "Socket error:" &lt;&lt; error;
    QCoreApplication::exit();
}</pre>
     </li>
     <li>
      After that, open
      <a id="_idIndexMarker512">
      </a>
      up
      <strong class="source-inline">
       mainwindow.h
      </strong>
      and add the
      <a id="_idIndexMarker513">
      </a>
      <span class="No-Break">
       following headers:
      </span>
      <pre class="source-code">
#include &lt;QDebug&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QFile&gt;
#include &lt;QFileInfo&gt;
#include &lt;QFileDialog&gt;
#include &lt;QListWidgetItem&gt;
#include &lt;QMessageBox&gt;
#include &lt;QThread&gt;
#include "ftpcontrolchannel.h"
#include "ftpdatachannel.h"</pre>
     </li>
     <li>
      Then, declare the
      <strong class="source-inline">
       getFileList()
      </strong>
      function,
      <span class="No-Break">
       as follows:
      </span>
      <pre class="source-code">
public:
     explicit MainWindow(QWidget *parent = 0);
     ~MainWindow();
     void getFileList();</pre>
     </li>
     <li>
      Right after that, declare the
      <a id="_idIndexMarker514">
      </a>
      <span class="No-Break">
       following variables:
      </span>
      <pre class="source-code">
private:
     Ui::MainWindow *ui;
     FtpDataChannel* dataChannel;
     FtpControlChannel* controlChannel;
     QString ftpAddress;
     QString username;
     QString password;
     QStringList fileList;
     QString uploadFileName;
     QString downloadFileName;</pre>
     </li>
     <li>
      Then, open up
      <strong class="source-inline">
       mainwindow.cpp
      </strong>
      and add
      <a id="_idIndexMarker515">
      </a>
      the following code to the
      <span class="No-Break">
       class constructor:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) {
     ui-&gt;setupUi(this);
     dataChannel = new FtpDataChannel(this);
     connect(dataChannel, &amp;FtpDataChannel::dataReceived, this, &amp;MainWindow::dataReceived);
     connect(controlChannel, &amp;FtpControlChannel::reply, this, &amp;MainWindow::serverReply);
     connect(controlChannel, &amp;FtpControlChannel::opened, this, &amp;MainWindow::serverConnected);
     controlChannel = new FtpControlChannel(this);
     ftpAddress = "127.0.0.1/";
     username = "myuser";
     password = "123456";
     controlChannel-&gt;connectToServer(ftpAddress);
}</pre>
     </li>
     <li>
      After that, implement
      <a id="_idIndexMarker516">
      </a>
      the
      <strong class="source-inline">
       getFileList()
      </strong>
      function, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::getFileList() {
controlChannel-&gt;command("PORT", dataChannel-&gt;portspec().toUtf8());
    controlChannel-&gt;command("MLSD", "");}</pre>
     </li>
     <li>
      Then, define the
      <strong class="source-inline">
       on_openButton_clicked()
      </strong>
      slot function, which gets triggered when the
      <strong class="bold">
       Open
      </strong>
      button is
      <a id="_idIndexMarker517">
      </a>
      clicked, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::on_openButton_clicked() {
     QString fileName = QFileDialog::getOpenFileName(this, "Select File", qApp-&gt;applicationDirPath());
     ui-&gt;uploadFileInput-&gt;setText(fileName);
}</pre>
     </li>
     <li>
      Once you’re done with that, implement the slot function that gets called when the
      <strong class="bold">
       Upload
      </strong>
      button is clicked, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void MainWindow::on_uploadButton_clicked() {
     QFile* file = new QFile(ui-&gt;uploadFileInput-&gt;text());
     QFileInfo fileInfo(*file);
     uploadFileName = fileInfo.fileName();
     controlChannel-&gt;command("PORT", dataChannel-&gt;portspec().toUtf8());
     controlChannel-&gt;command("STOR", uploadFileName.toUtf8());
}</pre>
     </li>
     <li>
      The following code shows
      <a id="_idIndexMarker518">
      </a>
      what the
      <strong class="source-inline">
       on_setFolderButton_clicked()
      </strong>
      slot function
      <span class="No-Break">
       looks like:
      </span>
      <pre class="source-code">
void MainWindow::on_setFolderButton_clicked() {
     QString folder = QFileDialog::getExistingDirectory(this, tr("Open Directory"), qApp-&gt;applicationDirPath(), QFileDialog::ShowDirsOnly);
     ui-&gt;downloadPath-&gt;setText(folder);
}</pre>
     </li>
     <li>
      Next, define the slot function that
      <a id="_idIndexMarker519">
      </a>
      will be triggered when one of the list widget’s items gets double-clicked, as shown in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::on_fileList_itemDoubleClicked(QListWidgetItem *item) {
     downloadFileName = item-&gt;text();
     QString folder = ui-&gt;downloadPath-&gt;text();
     if (folder != "" &amp;&amp; QDir(folder).exists()) {
           controlChannel-&gt;command("PORT", dataChannel-&gt;portspec().toUtf8());
                       controlChannel-&gt;command("RETR", downloadFileName.toUtf8());
     }
     else {
           QMessageBox::warning(this, "Invalid Path", "Please set the download path before download.");
}}</pre>
     </li>
     <li>
      We’re not quite done yet. Next, we will implement the
      <strong class="source-inline">
       serverConnected()
      </strong>
      function, which will be called automatically
      <a id="_idIndexMarker520">
      </a>
      when the program has successfully connected to the FTP server, as shown
      <a id="_idIndexMarker521">
      </a>
      in the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::serverConnected(const QHostAddress &amp;address, int port){
    qDebug() &lt;&lt; "Listening to:" &lt;&lt; address &lt;&lt; port;
    dataChannel-&gt;listen(address);
    controlChannel-&gt;command("USER", username.toUtf8());
    controlChannel-&gt;command("PASS", password.toUtf8());
    getFileList();
}</pre>
     </li>
     <li>
      We also need to implement the function that will be called when the FTP server replies to our request, as shown in the
      <span class="No-Break">
       following example:
      </span>
      <pre class="source-code">
void MainWindow::serverReply(int code, const QString &amp;parameters){
    if (code == 150 &amp;&amp; uploadFileName != ""){
        QFile* file = new QFile(ui-&gt;uploadFileInput-&gt;text());
        QFileInfo fileInfo(*file);
        uploadFileName = fileInfo.fileName();
        if (file-&gt;open(QIODevice::ReadOnly)){
            QThread::msleep(1000);
            QByteArray data = file-&gt;readAll();
            dataChannel-&gt;sendData(data + "\n\r");
            qDebug() &lt;&lt; data;
        } else {
            QMessageBox::warning(this, "Invalid File", "Failed to open file for upload.");
        }
    }
    if (code == 226 &amp;&amp; uploadFileName != ""){
        uploadFileName = "";
        QMessageBox::warning(this, "Upload Success", "File successfully uploaded.");
    }
}</pre>
     </li>
     <li>
      The
      <strong class="source-inline">
       dataReceived()
      </strong>
      function is
      <a id="_idIndexMarker522">
      </a>
      used to obtain
      <a id="_idIndexMarker523">
      </a>
      the data received from the FTP server, and it looks something like the
      <span class="No-Break">
       following code:
      </span>
      <pre class="source-code">
void MainWindow::dataReceived(const QByteArray &amp;data){
    if (data.startsWith("type=file")){
        ui-&gt;fileList-&gt;clear();
        QStringList fileList = QString(data).split("\r\n");
        if (fileList.length() &gt; 0){
            for (int i = 0; i &lt; fileList.length(); ++i){
                if (fileList.at(i) != ""){
                    QStringList fileInfo = fileList.at(i).split(";");
                    QString fileName = fileInfo.at(4).simplified();
                    ui-&gt;fileList-&gt;addItem(fileName);
                }
             }
        }
    } else {
        QString folder = ui-&gt;downloadPath-&gt;text();
        QFile file(folder + "/" + downloadFileName);
        file.open(QIODevice::WriteOnly);
        file.write((data));
        file.close();
        QMessageBox::information(this, "Success", "File successfully downloaded.");
    }
}</pre>
     </li>
     <li>
      Lastly, build and run
      <a id="_idIndexMarker524">
      </a>
      the program. Try and upload some files to the FTP server. If it works, the file list should be updated
      <a id="_idIndexMarker525">
      </a>
      and displayed on the
      <strong class="bold">
       List
      </strong>
      widget. Then, try and double-click on the filename on the list widget and download the file to your computer, as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer118">
      <img alt="Figure 7.15 – Downloading a file from the FTP server by double-clicking on it" src="../images\image/B20976_07_015.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.15 – Downloading a file from the FTP server by double-clicking on it
    </p>
    <ol>
     <li value="33">
      You can also try to upload
      <a id="_idIndexMarker526">
      </a>
      a file by clicking on the
      <strong class="bold">
       Open
      </strong>
      button, selecting the
      <a id="_idIndexMarker527">
      </a>
      desired file, and pressing the
      <strong class="bold">
       Upload
      </strong>
      button, as shown in the
      <span class="No-Break">
       following screenshot:
      </span>
     </li>
    </ol>
    <div>
     <div class="IMG---Figure" id="_idContainer119">
      <img alt="Figure 7.16 – Uploading a file to the FTP server" src="../images\image/B20976_07_016.jpg"/>
     </div>
    </div>
    <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
     Figure 7.16 – Uploading a file to the FTP server
    </p>
    <ol>
     <li value="34">
      Congratulations, you have
      <a id="_idIndexMarker528">
      </a>
      now successfully created a
      <a id="_idIndexMarker529">
      </a>
      working
      <span class="No-Break">
       FTP program!
      </span>
     </li>
    </ol>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     Do note that this example program is only meant to show you the most basic implementation of an FTP program and is not a fully featured program. It’s not guaranteed to work if you try to upload/download files that are not in text format. It may also not upload correctly if a file already exists on the FTP server. You must implement these features by yourself if you wish to expand on top of
     <span class="No-Break">
      this project.
     </span>
    </p>
    <h2 id="_idParaDest-169">
     <a id="_idTextAnchor169">
     </a>
     How it works…
    </h2>
    <p>
     Although this project is much larger and with longer code, it is actually pretty similar to the TCP networking projects we have
     <a id="_idIndexMarker530">
     </a>
     done in previous recipes. We have also made use of the signals and slots
     <a id="_idIndexMarker531">
     </a>
     mechanism provided by Qt 6 to make our
     <span class="No-Break">
      lives easier.
     </span>
    </p>
    <p>
     In the past, Qt used to support FTP in the
     <strong class="source-inline">
      QNetworkAccessManager
     </strong>
     class. However, FTP has since been deprecated in Qt 6 so we have to implement it on
     <span class="No-Break">
      our own.
     </span>
    </p>
    <p>
     We must understand some of the most common FTP commands and utilize them in our program. For more information, check
     <span class="No-Break">
      out
     </span>
     <a href="https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command">
      <span class="No-Break">
       https://www.serv-u.com/resources/tutorial/appe-stor-stou-retr-list-mlsd-mlst-ftp-command
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
    <p>
     The
     <strong class="source-inline">
      FtpControlChannel
     </strong>
     and
     <strong class="source-inline">
      FtpDataChannel
     </strong>
     classes were taken from Qt’s official Git repository with some tiny
     <span class="No-Break">
      modifications:
     </span>
     <a href="https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient">
      <span class="No-Break">
       https://code.qt.io/cgit/qt/qtscxml.git/tree/examples/scxml/ftpclient
      </span>
     </a>
     <span class="No-Break">
      .
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
