<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   9Mastering Classes and Objects
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_019.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_021.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c09_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c09_1">
      <span aria-label="295" class="calibre17" epub:type="pagebreak" id="Page_295" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c09">
      </span>
      <span class="calibre">
       9
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Mastering Classes and Objects
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c09-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c09-list-0001">
         <li class="calibre9" id="c09-li-0001">
          How to make classes friends of other classes
         </li>
         <li class="calibre9" id="c09-li-0002">
          How to use dynamic memory allocation in objects
         </li>
         <li class="calibre9" id="c09-li-0003">
          What the copy-and-swap idiom is
         </li>
         <li class="calibre9" id="c09-li-0004">
          What rvalues and rvalue references are
         </li>
         <li class="calibre9" id="c09-li-0005">
          How move semantics can improve performance
         </li>
         <li class="calibre9" id="c09-li-0006">
          What the rule of zero means
         </li>
         <li class="calibre9" id="c09-li-0007">
          How to use the
          <code class="calibre21">
           constexpr
          </code>
          and
          <code class="calibre21">
           consteval
          </code>
          keywords to perform computations at compile time
         </li>
         <li class="calibre9" id="c09-li-0008">
          The different kinds of data members you can have (
          <code class="calibre21">
           static
          </code>
          ,
          <code class="calibre21">
           const
          </code>
          ,
          <code class="calibre21">
           constexpr
          </code>
          , reference)
         </li>
         <li class="calibre9" id="c09-li-0009">
          The different kinds of member functions you can implement (
          <code class="calibre21">
           static
          </code>
          ,
          <code class="calibre21">
           const
          </code>
          ,
          <code class="calibre21">
           inline
          </code>
          )
         </li>
         <li class="calibre9" id="c09-li-0010">
          The details of member function overloading
         </li>
         <li class="calibre9" id="c09-li-0011">
          How to work with default arguments
         </li>
         <li class="calibre9" id="c09-li-0012">
          How to use nested classes
         </li>
         <li class="calibre9" id="c09-li-0013">
          What operator overloading is
         </li>
         <li class="calibre9" id="c09-li-0014">
          How to write separate interface and implementation classes
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c09-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-108">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <p class="calibre25" id="c09-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c09-para-0005">
      <span aria-label="296" class="calibre20" epub:type="pagebreak" id="Page_296" role="doc-pagebreak">
      </span>
      <a class="calibre5" href="c08.xhtml">
       Chapter 8
      </a>
      , “Gaining Proficiency with Classes and Objects,” started the discussion on classes and objects. Now it's time to master their subtleties so you can use them to their full potential. By reading this chapter, you will learn how to manipulate and exploit some of the most powerful aspects of the C++ language to write safe, effective, and useful classes.
     </p>
     <p class="calibre13" id="c09-para-0006">
      Many of the concepts in this chapter arise in advanced C++ programming, especially in the C++ Standard Library. Let's start the discussion with the concept of friends in the C++ world.
     </p>
    </section>
    <section aria-labelledby="head-2-109" class="calibre2">
     <span class="calibre" id="c09-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-109">
      FRIENDS
     </h2>
     <p class="calibre13">
      C++ allows classes to declare that other classes, member functions of other classes, or non-member functions are
      <i class="calibre18">
       friends
      </i>
      , and can access
      <code class="calibre21">
       protected
      </code>
      and
      <code class="calibre21">
       private
      </code>
      data members and member functions. For example, suppose you have two classes called
      <code class="calibre21">
       Foo
      </code>
      and
      <code class="calibre21">
       Bar
      </code>
      . You can specify that the
      <code class="calibre21">
       Bar
      </code>
      class is a friend of
      <code class="calibre21">
       Foo
      </code>
      as follows:
     </p>
     <pre class="calibre26" id="c09-code-0001"><code class="calibre21">class Foo</code>
<code class="calibre21">{</code>
<code class="calibre21">    friend class Bar;</code>
<code class="calibre21">    <span class="color">// …</span></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13" id="c09-para-0008">
      Now all the member functions of
      <code class="calibre21">
       Bar
      </code>
      can access the
      <code class="calibre21">
       private
      </code>
      and
      <code class="calibre21">
       protected
      </code>
      data members and member functions of
      <code class="calibre21">
       Foo
      </code>
      .
     </p>
     <p class="calibre13">
      If you only want to make a specific member function of
      <code class="calibre21">
       Bar
      </code>
      a friend, you can do that as well. Suppose the
      <code class="calibre21">
       Bar
      </code>
      class has a member function
      <code class="calibre21">
       processFoo(const Foo&amp;)
      </code>
      . The following syntax is used to make this member function a friend of
      <code class="calibre21">
       Foo
      </code>
      :
     </p>
     <pre class="calibre26" id="c09-code-0002"><code class="calibre21">class Foo</code>
<code class="calibre21">{</code>
<code class="calibre21">    friend void Bar::processFoo(const Foo&amp;);</code>
<code class="calibre21">    <span class="color">// …</span></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13">
      Stand-alone functions can also be friends of classes. You might, for example, want to write a function that prints all data of a
      <code class="calibre21">
       Foo
      </code>
      object to the console. You might want this function to be outside the
      <code class="calibre21">
       Foo
      </code>
      class because printing is not core functionality of
      <code class="calibre21">
       Foo
      </code>
      , but the function should be able to access the internal data members of the object to print them all. Here is the
      <code class="calibre21">
       Foo
      </code>
      class definition with
      <code class="calibre21">
       printFoo()
      </code>
      as a friend:
     </p>
     <pre class="calibre26" id="c09-code-0003"><code class="calibre21">class Foo</code>
<code class="calibre21">{</code>
<code class="calibre21">    friend void printFoo(const Foo&amp;);</code>
<code class="calibre21">    <span class="color">// …</span></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13" id="c09-para-0011">
      The
      <code class="calibre21">
       friend
      </code>
      declaration in the class serves as the function's prototype. There's no need to write the prototype elsewhere (although it's harmless to do so).
     </p>
     <p class="calibre13">
      Here is the function definition:
     </p>
     <pre class="calibre26" id="c09-code-0004"><code class="calibre21">void printFoo(const Foo&amp; foo)</code>
<code class="calibre21">{</code>
<span aria-label="297" class="calibre20" epub:type="pagebreak" id="Page_297" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// Print all data of foo to the console, including</span></code>
<code class="calibre21">    <span class="color">// private and protected data members.</span></code>
<code class="calibre21">}</code></pre>
     <p class="calibre13" id="c09-para-0013">
      You write this function outside the class definition just like any other function, except that you can directly access
      <code class="calibre21">
       private
      </code>
      and
      <code class="calibre21">
       protected
      </code>
      members of
      <code class="calibre21">
       Foo
      </code>
      . You don't repeat the
      <code class="calibre21">
       friend
      </code>
      keyword in the function definition.
     </p>
     <p class="calibre13" id="c09-para-0014">
      Note that a class needs to know which other classes, member functions, or functions want to be its friends; a class, member function, or function cannot declare itself to be a friend of some other class to gain access to non-
      <code class="calibre21">
       public
      </code>
      members of that class.
     </p>
     <p class="calibre13" id="c09-para-0015">
      <code class="calibre21">
       friend
      </code>
      classes and functions are easy to abuse; they allow you to violate the principle of encapsulation by exposing internals of your class to other classes or functions. Thus, you should use them only in limited circumstances. Some use cases are shown throughout this chapter.
     </p>
    </section>
    <section aria-labelledby="head-2-110" class="calibre2">
     <span class="calibre" id="c09-sec-0005">
     </span>
     <h2 class="calibre6" id="head-2-110">
      DYNAMIC MEMORY ALLOCATION IN OBJECTS
     </h2>
     <p class="calibre13" id="c09-para-0016">
      Sometimes you don't know how much memory you will need before your program actually runs. As you read in
      <a class="calibre5" href="c07.xhtml">
       Chapter 7
      </a>
      , “Memory Management,” the solution is to dynamically allocate as much space as you need during program execution. Classes are no exception. Sometimes you don't know how much memory an object will need when you write the class. In that case, the object should dynamically allocate memory. Dynamically allocated memory in objects provides several challenges, including freeing the memory, handling object copying, and handling object assignment.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-186">
       The Spreadsheet Class
      </h3>
      <p class="calibre13" id="c09-para-0017">
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       introduces the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class. This chapter moves on to write the
       <code class="calibre21">
        Spreadsheet
       </code>
       class. As with the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class, the
       <code class="calibre21">
        Spreadsheet
       </code>
       class evolves throughout this chapter. Thus, the various attempts do not always illustrate the best way to do every aspect of class writing.
      </p>
      <p class="calibre13" id="c09-para-0018">
       To start, a
       <code class="calibre21">
        Spreadsheet
       </code>
       is simply a two-dimensional array of
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s, with member functions to set and retrieve cells at specific locations in the
       <code class="calibre21">
        Spreadsheet
       </code>
       . Although most spreadsheet applications use letters in one direction and numbers in the other to refer to cells, this
       <code class="calibre21">
        Spreadsheet
       </code>
       uses numbers in both directions.
      </p>
      <p class="calibre13">
       The first line of the
       <code class="calibre21">
        Spreadsheet.cppm
       </code>
       module interface file defines the name of the module:
      </p>
      <pre class="calibre26" id="c09-code-0005"><code class="calibre21">export module spreadsheet;</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        Spreadsheet
       </code>
       class needs access to the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class, so it needs to import the
       <code class="calibre21">
        spreadsheet_cell
       </code>
       module. Additionally, to make the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class visible to users of the
       <code class="calibre21">
        spreadsheet
       </code>
       module, the
       <code class="calibre21">
        spreadsheet_cell
       </code>
       module is imported and exported with the following funny-looking syntax:
      </p>
      <pre class="calibre26" id="c09-code-0006"><code class="calibre21">export import spreadsheet_cell;</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        Spreadsheet
       </code>
       class uses the
       <code class="calibre21">
        std::size_t
       </code>
       type, which is defined in the C header called
       <code class="calibre21">
        &lt;cstddef&gt;
       </code>
       . You can get access to it with the following import:
      </p>
      <pre class="calibre26" id="c09-code-0007"><code class="calibre21">import std;</code></pre>
      <p class="calibre13">
       <span aria-label="298" class="calibre20" epub:type="pagebreak" id="Page_298" role="doc-pagebreak">
       </span>
       Finally, here is a first attempt at a definition of the
       <code class="calibre21">
        Spreadsheet
       </code>
       class:
      </p>
      <pre class="calibre26" id="c09-code-0008"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Spreadsheet(std::size_t width, std::size_t height);</code>
<code class="calibre21">        void setCellAt(std::size_t x, std::size_t y, const SpreadsheetCell&amp; cell);</code>
<code class="calibre21">        SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y);</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        bool inRange(std::size_t value, std::size_t upper) const;</code>
<code class="calibre21">        std::size_t m_width { 0 };</code>
<code class="calibre21">        std::size_t m_height { 0 };</code>
<code class="calibre21">        SpreadsheetCell** m_cells { nullptr };</code>
<code class="calibre21">};</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0024">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The
          </i>
          <code class="calibre21">
           Spreadsheet
          </code>
          <i class="calibre18">
           class uses normal pointers for the
          </i>
          <code class="calibre21">
           m_cells
          </code>
          <i class="calibre18">
           array. This is done throughout this chapter to show the consequences and to explain how to handle resources, such as dynamic memory, in classes. In production code, you should use one of the standard C++ containers, like
          </i>
          <code class="calibre21">
           std::vector
          </code>
          <i class="calibre18">
           , which greatly simplifies the implementation of
          </i>
          <code class="calibre21">
           Spreadsheet
          </code>
          <i class="calibre18">
           , but then you wouldn't learn how to correctly handle dynamic memory using raw pointers. In modern C++, you should never use raw pointers with ownership semantics, but you might come across them in existing code, in which case you need to know how to work with them.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c09-para-0025">
       Note that the
       <code class="calibre21">
        Spreadsheet
       </code>
       class does not contain a standard two-dimensional array of
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s. Instead, it contains a
       <code class="calibre21">
        SpreadsheetCell**
       </code>
       data member, which is a pointer to a pointer representing an array of arrays. This is because each
       <code class="calibre21">
        Spreadsheet
       </code>
       object might have different dimensions, so the constructor of the class must dynamically allocate the two-dimensional array based on the client-specified height and width.
      </p>
      <p class="calibre13">
       To dynamically allocate a two-dimensional array, you need to write the following code. Note that in C++, unlike in Java, it's not possible to simply write
       <code class="calibre21">
        new SpreadsheetCell[m_width][m_height]
       </code>
       .
      </p>
      <pre class="calibre26" id="c09-code-0009"><code class="calibre21">Spreadsheet::Spreadsheet(size_t width, size_t height)</code>
<code class="calibre21">    : m_width { width }, m_height { height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_cells = new SpreadsheetCell*[m_width];</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        m_cells[i] = new SpreadsheetCell[m_height];</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0027">
       <a class="calibre5" href="#c09-fig-0001" id="R_c09-fig-0001">
        Figure 9.1
       </a>
       shows the resulting memory layout for a
       <code class="calibre21">
        Spreadsheet
       </code>
       called
       <code class="calibre21">
        s1
       </code>
       on the stack with width 4 and height 3.
      </p>
      <p class="calibre13">
       The implementations of the
       <code class="calibre21">
        inRange()
       </code>
       and the set and retrieval member functions are straightforward:
      </p>
      <pre class="calibre26" id="c09-code-0010"><span aria-label="299" class="calibre20" epub:type="pagebreak" id="Page_299" role="doc-pagebreak"></span><code class="calibre21">bool Spreadsheet::inRange(size_t value, size_t upper) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return value &lt; upper;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void Spreadsheet::setCellAt(size_t x, size_t y, const SpreadsheetCell&amp; cell)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (!inRange(x, m_width)) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("x ({}) must be less than width ({}).", x, m_width) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    if (!inRange(y, m_height)) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("y ({}) must be less than height ({}).", y, m_height) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    m_cells[x][y] = cell;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (!inRange(x, m_width)) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("x ({}) must be less than width ({}).", x, m_width) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    if (!inRange(y, m_height)) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("y ({}) must be less than height ({}).", y, m_height) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code></pre>
      <figure class="calibre36">
       <img alt="A set of two illustrations. The first set reads stack. The second set reads free store. The stack of width of 4 and a height of 3. Each element is an unnamed spreadsheet cell." class="center" src="images/c09f001.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c09-fig-0001" id="c09-fig-0001" role="doc-backlink">
           <b class="calibre14">
            FIGURE 9.1
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c09-para-0029">
       <code class="calibre21">
        setCellAt()
       </code>
       and
       <code class="calibre21">
        getCellAt()
       </code>
       both use a helper function called
       <code class="calibre21">
        inRange()
       </code>
       to check that
       <code class="calibre21">
        x
       </code>
       and
       <code class="calibre21">
        y
       </code>
       represent valid coordinates in the spreadsheet. Attempting to access an array element at an out-of-range index will cause the program to malfunction. This example uses exceptions, which are introduced in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       , “A Crash Course in C++ and the Standard Library,” and described in detail in
       <a class="calibre5" href="c14.xhtml">
        Chapter 14
       </a>
       , “Handling Errors.”
      </p>
      <p class="calibre13">
       If you look at the
       <code class="calibre21">
        setCellAt()
       </code>
       and
       <code class="calibre21">
        getCellAt()
       </code>
       implementations, you see there is some clear code duplication.
       <a class="calibre5" href="c06.xhtml">
        Chapter 6
       </a>
       , “Designing for Reuse,” explains that code duplication should be avoided at
       <span aria-label="300" class="calibre20" epub:type="pagebreak" id="Page_300" role="doc-pagebreak">
       </span>
       all costs. So, let's follow that guideline. Instead of a helper function called
       <code class="calibre21">
        inRange()
       </code>
       , let's define the following
       <code class="calibre21">
        verifyCoordinate()
       </code>
       member function:
      </p>
      <pre class="calibre26" id="c09-code-0011"><code class="calibre21">void verifyCoordinate(std::size_t x, std::size_t y) const;</code></pre>
      <p class="calibre13">
       The implementation checks the given coordinate and throws an exception if the coordinate is invalid:
      </p>
      <pre class="calibre26" id="c09-code-0012"><code class="calibre21">void Spreadsheet::verifyCoordinate(size_t x, size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (x&gt;= m_width) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("x ({}) must be less than width ({}).", x, m_width) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    if (y&gt;= m_height) {</code>
<code class="calibre21">        throw out_of_range {</code>
<code class="calibre21">            format("y ({}) must be less than height ({}).", y, m_height) };</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        setCellAt()
       </code>
       and
       <code class="calibre21">
        getCellAt()
       </code>
       implementations can now be simplified:
      </p>
      <pre class="calibre26" id="c09-code-0013"><code class="calibre21">void Spreadsheet::setCellAt(size_t x, size_t y, const SpreadsheetCell&amp; cell)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">verifyCoordinate(x, y);</b></code>
<code class="calibre21">    m_cells[x][y] = cell;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">verifyCoordinate(x, y);</b></code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-187">
       Freeing Memory with Destructors
      </h3>
      <p class="calibre13">
       Whenever you are finished with dynamically allocated memory, you should free it. If you dynamically allocate memory in an object, the place to free that memory is in the
       <i class="calibre18">
        destructor
       </i>
       . The compiler guarantees that the destructor is called when the object is destroyed. The following is the destructor added to the
       <code class="calibre21">
        Spreadsheet
       </code>
       class definition:
      </p>
      <pre class="calibre26" id="c09-code-0014"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Spreadsheet(std::size_t width, std::size_t height);</code>
<code class="calibre21">        <b class="calibre14">~Spreadsheet();</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c09-para-0034">
       The destructor has the same name as the name of the class (and of the constructors), preceded by a tilde (
       <code class="calibre21">
        ~
       </code>
       ). The destructor takes no arguments, and there can be only one of them. Destructors should never throw any exceptions for reasons explained in detail in
       <a class="calibre5" href="c14.xhtml">
        Chapter 14
       </a>
       .
      </p>
      <p class="calibre13">
       Here is the implementation of the
       <code class="calibre21">
        Spreadsheet
       </code>
       class destructor:
      </p>
      <pre class="calibre26" id="c09-code-0015"><span aria-label="301" class="calibre20" epub:type="pagebreak" id="Page_301" role="doc-pagebreak"></span><code class="calibre21">Spreadsheet::˜Spreadsheet()</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        delete[] m_cells[i];</code>
<code class="calibre21">    }</code>
<code class="calibre21">    delete[] m_cells;</code>
<code class="calibre21">    m_cells = nullptr;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0036">
       This destructor frees the memory that was allocated in the constructor. However, no rule requires you to free memory in the destructor. You can write whatever code you want in the destructor, but it is generally a good idea to use it only for freeing memory or disposing of other resources.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0009">
      </span>
      <h3 class="calibre27" id="head-3-188">
       Handling Copying and Assignment
      </h3>
      <p class="calibre13">
       Recall from
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       that if you don't write a copy constructor and a copy assignment operator yourself, C++ writes them for you. These compiler-generated member functions recursively call the copy constructor or copy assignment operator on object data members. However, for primitives, such as
       <code class="calibre21">
        int
       </code>
       ,
       <code class="calibre21">
        double
       </code>
       , and pointers, they provide
       <i class="calibre18">
        shallow
       </i>
       or
       <i class="calibre18">
        bitwise
       </i>
       copying or assignment: they just copy or assign the data members from the source object directly to the destination object. That presents problems when you dynamically allocate memory in your object. For example, the following code copies the spreadsheet
       <code class="calibre21">
        s1
       </code>
       to initialize
       <code class="calibre21">
        s
       </code>
       when
       <code class="calibre21">
        s1
       </code>
       is passed to the
       <code class="calibre21">
        printSpreadsheet()
       </code>
       function:
      </p>
      <pre class="calibre26" id="c09-code-0016"><code class="calibre21">import spreadsheet;</code>
<code class="calibre21"> </code>
<code class="calibre21">void printSpreadsheet(Spreadsheet s) { <span class="color">/* Code omitted for brevity. */</span> }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    Spreadsheet s1 { 4, 3 };</code>
<code class="calibre21">    printSpreadsheet(s1);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0038">
       The
       <code class="calibre21">
        Spreadsheet
       </code>
       contains one pointer variable:
       <code class="calibre21">
        m_cells
       </code>
       . A shallow copy of a Spreadsheet gives the destination object a copy of the
       <code class="calibre21">
        m_cells
       </code>
       pointer, but not a copy of the underlying data. Thus, you end up with a situation where both
       <code class="calibre21">
        s
       </code>
       and
       <code class="calibre21">
        s1
       </code>
       have a pointer to the same data, as shown in
       <a class="calibre5" href="#c09-fig-0002" id="R_c09-fig-0002">
        Figure 9.2
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A set of two illustrations. The first set reads stack. 1. Spreadsheet s 1. 2. Spreadsheet s 2. The second set reads free store. The stack of width of 4 and a height of 3." class="center" src="images/c09f002.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c09-fig-0002" id="c09-fig-0002" role="doc-backlink">
           <b class="calibre14">
            FIGURE 9.2
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c09-para-0039">
       If
       <code class="calibre21">
        s
       </code>
       changes something to which
       <code class="calibre21">
        m_cells
       </code>
       points, that change shows up in
       <code class="calibre21">
        s1
       </code>
       as well. Even worse, when the
       <code class="calibre21">
        printSpreadsheet()
       </code>
       function exits,
       <code class="calibre21">
        s
       </code>
       's destructor is called, which frees the memory pointed to by
       <code class="calibre21">
        m_cells
       </code>
       . That leaves the situation where
       <code class="calibre21">
        m_cells
       </code>
       in
       <code class="calibre21">
        s1
       </code>
       no longer points to valid memory, as shown in
       <a class="calibre5" href="#c09-fig-0003" id="R_c09-fig-0003">
        Figure 9.3
       </a>
       . This is called a
       <i class="calibre18">
        dangling pointer
       </i>
       .
      </p>
      <span aria-label="302" class="calibre20" epub:type="pagebreak" id="Page_302" role="doc-pagebreak">
      </span>
      <figure class="calibre36">
       <img alt="A set of two illustrations. The first set reads stack. 1. Spreadsheet s 1. The second set reads free store. The stack of width of 4 and a height of 3." class="center" src="images/c09f003.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c09-fig-0003" id="c09-fig-0003" role="doc-backlink">
           <b class="calibre14">
            FIGURE 9.3
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13">
       Unbelievably, the problem is even worse with assignment. Suppose that you have the following code:
      </p>
      <pre class="calibre26" id="c09-code-0017"><code class="calibre21">Spreadsheet s1 { 2, 2 }, s2 { 4, 3 };</code>
<code class="calibre21">s1 = s2;</code></pre>
      <p class="calibre13" id="c09-para-0041">
       After the first line, when both the
       <code class="calibre21">
        s1
       </code>
       and
       <code class="calibre21">
        s2 Spreadsheet
       </code>
       objects are constructed, you have the memory layout shown in
       <a class="calibre5" href="#c09-fig-0004" id="R_c09-fig-0004">
        Figure 9.4
       </a>
       .
      </p>
      <figure class="calibre36">
       <img alt="A set of two illustrations. The first set reads stack. 1. Spreadsheet s 1. 2. Spreadsheet s 2. The second set reads free store. The stack of width of 4, 2, and height of 3, 2." class="center" src="images/c09f004.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c09-fig-0004" id="c09-fig-0004" role="doc-backlink">
           <b class="calibre14">
            FIGURE 9.4
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <p class="calibre13" id="c09-para-0042">
       After the assignment statement, you have the layout shown in
       <a class="calibre5" href="#c09-fig-0005" id="R_c09-fig-0005">
        Figure 9.5
       </a>
       .
      </p>
      <p class="calibre13" id="c09-para-0043">
       Now, not only do the
       <code class="calibre21">
        m_cells
       </code>
       pointers in
       <code class="calibre21">
        s1
       </code>
       and
       <code class="calibre21">
        s2
       </code>
       point to the same memory, but you have also
       <i class="calibre18">
        orphaned
       </i>
       the memory to which
       <code class="calibre21">
        m_cells
       </code>
       in
       <code class="calibre21">
        s1
       </code>
       previously pointed to. This is called a
       <i class="calibre18">
        memory leak
       </i>
       .
      </p>
      <p class="calibre13" id="c09-para-0044">
       It should be clear by now that copy constructors and copy assignment operators must do a
       <i class="calibre18">
        deep copy
       </i>
       ; that is, they must not just copy pointer data members, but must copy the actual data to which such pointers point to.
      </p>
      <p class="calibre13">
       As you can see, relying on C++'s default copy constructor and default copy assignment operator is not always a good idea.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0046">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Whenever you have dynamically allocated resources in a class, you should write your own copy constructor and copy assignment operator to provide a deep copy of the memory
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <span aria-label="303" class="calibre20" epub:type="pagebreak" id="Page_303" role="doc-pagebreak">
      </span>
      <figure class="calibre36">
       <img alt="A set of two illustrations. The first set reads stack. 1. Spreadsheet s 1. 2. Spreadsheet s 2. The second set reads free store. 1. Orphaned memory. The stack of width of 4 and a height of 3." class="center" src="images/c09f005.png"/>
       <figcaption class="calibre37">
        <p class="calibre13">
         <span class="figurelabel">
          <a class="calibre5" href="#R_c09-fig-0005" id="c09-fig-0005" role="doc-backlink">
           <b class="calibre14">
            FIGURE 9.5
           </b>
          </a>
         </span>
        </p>
       </figcaption>
      </figure>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0011">
       </span>
       <h4 class="calibre29" id="head-4-167">
        The Spreadsheet Copy Constructor
       </h4>
       <p class="calibre13">
        Here is a declaration for a copy constructor in the
        <code class="calibre21">
         Spreadsheet
        </code>
        class:
       </p>
       <pre class="calibre26" id="c09-code-0018"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet(const Spreadsheet&amp; src);</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        The definition is as follows:
       </p>
       <pre class="calibre26" id="c09-code-0019"><code class="calibre21">Spreadsheet::Spreadsheet(const Spreadsheet&amp; src)</code>
<code class="calibre21">    : Spreadsheet { src.m_width, src.m_height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        for (size_t j { 0 }; j &lt; m_height; ++j) {</code>
<code class="calibre21">            m_cells[i][j] = src.m_cells[i][j];</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0049">
        Note the use of a delegating constructor. The ctor-initializer of this copy constructor delegates first to the non-copy constructor to allocate the proper amount of memory. The body of the copy constructor then copies the actual values. Together, this process implements a deep copy of the
        <code class="calibre21">
         m_cells
        </code>
        dynamically-allocated two-dimensional array.
       </p>
       <p class="calibre13" id="c09-para-0050">
        There is no need to delete any existing
        <code class="calibre21">
         m_cells
        </code>
        because this is a copy constructor, and therefore there is no existing
        <code class="calibre21">
         m_cells
        </code>
        yet in
        <code class="calibre21">
         this
        </code>
        object.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0012">
       </span>
       <h4 class="calibre29" id="head-4-168">
        The Spreadsheet Assignment Operator
       </h4>
       <p class="calibre13">
        The following shows the
        <code class="calibre21">
         Spreadsheet
        </code>
        class definition with an assignment operator:
       </p>
       <pre class="calibre26" id="c09-code-0020"><span aria-label="304" class="calibre20" epub:type="pagebreak" id="Page_304" role="doc-pagebreak"></span><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet&amp; operator=(const Spreadsheet&amp; rhs);</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        A naïve implementation could be as follows:
       </p>
       <pre class="calibre26" id="c09-code-0021"><code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(const Spreadsheet&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Check for self-assignment</span></code>
<code class="calibre21">    if (this == &amp;rhs) {</code>
<code class="calibre21">        return *this;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Free the old memory</span></code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        delete[] m_cells[i];</code>
<code class="calibre21">    }</code>
<code class="calibre21">    delete[] m_cells;</code>
<code class="calibre21">    m_cells = nullptr;</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Allocate new memory</span></code>
<code class="calibre21">    m_width = rhs.m_width;</code>
<code class="calibre21">    m_height = rhs.m_height;</code>
<code class="calibre21"> </code>
<code class="calibre21">    m_cells = new SpreadsheetCell*[m_width];</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        m_cells[i] = new SpreadsheetCell[m_height];</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Copy the data</span></code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        for (size_t j { 0 }; j &lt; m_height; ++j) {</code>
<code class="calibre21">            m_cells[i][j] = rhs.m_cells[i][j];</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0053">
        The code first checks for self-assignment, then frees the current memory of the
        <code class="calibre21">
         this
        </code>
        object, allocates new memory, and finally copies the individual elements. There is a lot going on in this function, and a lot can go wrong! It is possible that the
        <code class="calibre21">
         this
        </code>
        object gets into an invalid state.
       </p>
       <p class="calibre13" id="c09-para-0054">
        For example, suppose that the memory is successfully freed, that
        <code class="calibre21">
         m_width
        </code>
        and
        <code class="calibre21">
         m_height
        </code>
        are properly set, but that an exception is thrown in the loop that is allocating the memory. When that happens, execution of the remainder of the function is skipped, and the function is exited. Now the
        <code class="calibre21">
         Spreadsheet
        </code>
        instance is corrupt; its
        <code class="calibre21">
         m_width
        </code>
        and
        <code class="calibre21">
         m_height
        </code>
        data members state a certain size, but the
        <code class="calibre21">
         m_cells
        </code>
        data member does not point to the right amount of memory. Basically, this code is not exception-safe!
       </p>
       <p class="calibre13">
        What we need is an all-or-nothing mechanism; either everything succeeds or the
        <code class="calibre21">
         this
        </code>
        object remains untouched. To implement such an exception-safe assignment operator, the
        <i class="calibre18">
         copy-and-swap
        </i>
        idiom is used. For this, a
        <code class="calibre21">
         swap()
        </code>
        member function is added to the
        <code class="calibre21">
         Spreadsheet
        </code>
        class. Additionally, it's
        <span aria-label="305" class="calibre20" epub:type="pagebreak" id="Page_305" role="doc-pagebreak">
        </span>
        recommended to provide a non-member
        <code class="calibre21">
         swap()
        </code>
        function so that it can also be used by various Standard Library algorithms. Here is the definition of the
        <code class="calibre21">
         Spreadsheet
        </code>
        class with an assignment operator, and the
        <code class="calibre21">
         swap()
        </code>
        member function and non-member function:
       </p>
       <pre class="calibre26" id="c09-code-0022"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet&amp; operator=(const Spreadsheet&amp; rhs);</b></code>
<code class="calibre21">        <b class="calibre14">void swap(Spreadsheet&amp; other) noexcept;</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity</span></code>
<code class="calibre21">};</code>
<code class="calibre21"><b class="calibre14">export void swap(Spreadsheet&amp; first, Spreadsheet&amp; second) noexcept;</b></code></pre>
       <p class="calibre13">
        A requirement for implementing the exception-safe copy-and-swap idiom is that
        <code class="calibre21">
         swap()
        </code>
        never throws any exceptions, so it is marked as
        <code class="calibre21">
         noexcept
        </code>
        .
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            A function can be marked with the
           </i>
           <code class="calibre21">
            noexcept
           </code>
           <i class="calibre18">
            keyword to specify that it won't throw any exceptions. The
           </i>
           <code class="calibre21">
            noexcept
           </code>
           <i class="calibre18">
            specifier must appear after any
           </i>
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            keyword. Here's an example:
           </i>
          </p>
          <pre class="calibre26" id="c09-code-0023"><code class="calibre21">void myNonThrowingConstFunction() const noexcept { /* … */ }</code></pre>
          <p class="calibre25" id="c09-para-0059">
           <i class="calibre18">
            If a
           </i>
           <code class="calibre21">
            noexcept
           </code>
           <i class="calibre18">
            function does throw an exception, the program is terminated. More details about
           </i>
           <code class="calibre21">
            noexcept
           </code>
           <i class="calibre18">
            are discussed in
            <a class="calibre5" href="c14.xhtml">
             Chapter 14
            </a>
            , but those details are not important for the remainder of the current chapter.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        The implementation of the
        <code class="calibre21">
         swap()
        </code>
        member function swaps each data member using the
        <code class="calibre21">
         std::swap()
        </code>
        utility function provided by the Standard Library in
        <code class="calibre21">
         &lt;utility&gt;
        </code>
        , which efficiently swaps two values:
       </p>
       <pre class="calibre26" id="c09-code-7023"><code class="calibre21">void Spreadsheet::swap(Spreadsheet&amp; other) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::swap(m_width, other.m_width);</code>
<code class="calibre21">    std::swap(m_height, other.m_height);</code>
<code class="calibre21">    std::swap(m_cells, other.m_cells);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The non-member
        <code class="calibre21">
         swap()
        </code>
        function simply forwards to the
        <code class="calibre21">
         swap()
        </code>
        member function:
       </p>
       <pre class="calibre26" id="c09-code-0024"><code class="calibre21">void swap(Spreadsheet&amp; first, Spreadsheet&amp; second) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    first.swap(second);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Now that we have an exception-safe
        <code class="calibre21">
         swap()
        </code>
        , it can be used to implement the assignment operator:
       </p>
       <pre class="calibre26" id="c09-code-0025"><code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(const Spreadsheet&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    Spreadsheet temp { rhs }; <span class="color">// Do all the work in a temporary instance</span></code>
<code class="calibre21">    swap(temp);               <span class="color">// Commit the work with only non-throwing operations</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        <span aria-label="306" class="calibre20" epub:type="pagebreak" id="Page_306" role="doc-pagebreak">
        </span>
        The implementation uses the copy-and-swap idiom. First, a
        <i class="calibre18">
         copy
        </i>
        of the right-hand side is made, called
        <code class="calibre21">
         temp
        </code>
        . Then the current object is swapped with this copy. This pattern is the recommended way of implementing assignment operators because it guarantees
        <i class="calibre18">
         strong exception safety
        </i>
        , meaning that if any exception occurs, then the state of the current
        <code class="calibre21">
         Spreadsheet
        </code>
        object remains unchanged. The idiom is implemented in three phases:
       </p>
       <ul class="check" id="c09-list-0002">
        <li class="calibre9" id="c09-li-0015">
         The first phase makes a temporary copy. This does not modify the state of the current
         <code class="calibre21">
          Spreadsheet
         </code>
         object, and so there is no problem if an exception is thrown during this phase.
        </li>
        <li class="calibre9" id="c09-li-0016">
         The second phase uses the
         <code class="calibre21">
          swap()
         </code>
         function to swap the created temporary copy with the current object. The
         <code class="calibre21">
          swap()
         </code>
         function shall never throw exceptions.
        </li>
        <li class="calibre9" id="c09-li-0017">
         The third phase is the destruction of the temporary object, which now contains the original object (because of the swap), to clean up any memory.
        </li>
       </ul>
       <p class="calibre13">
        When you do not use the copy-and-swap idiom for implementing an assignment operator, then for efficiency and sometimes also for correctness, the first line of code in an assignment operator usually checks for self-assignment. Here's an example:
       </p>
       <pre class="calibre26" id="c09-code-0026"><code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(const Spreadsheet&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Check for self-assignment</span></code>
<code class="calibre21">    if (this == &amp;rhs) { return *this; }</code>
<code class="calibre21">    <span class="color">// …</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        With the copy-and-swap idiom, such a self-assignment test is not needed.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0066">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            When implementing an assignment operator, use the copy-and-swap idiom to avoid code duplication and to guarantee strong exception safety
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0067">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            The copy-and-swap idiom can be used for more than just assignment operators. It can be used for any operation that takes multiple steps and that you want to turn into an all-or-nothing operation: first, make a copy; then, do all the modifications on the copy; and finally, if there are no errors, perform a non-throwing swap operation
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0016">
       </span>
       <h4 class="calibre29" id="head-4-169">
        Disallowing Assignment and Pass-by-Value
       </h4>
       <p class="calibre13">
        Sometimes when you dynamically allocate memory in your class, it's easiest just to prevent anyone from copying or assigning to your objects. You can do this by explicitly deleting your
        <code class="calibre21">
         operator=
        </code>
        and copy constructor. That way, if anyone tries to pass the object by value, return it from a function, or assign to it, the compiler will complain. Here is a
        <code class="calibre21">
         Spreadsheet
        </code>
        class definition that prevents assignment and pass-by-value:
       </p>
       <pre class="calibre26" id="c09-code-0027"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<span aria-label="307" class="calibre20" epub:type="pagebreak" id="Page_307" role="doc-pagebreak"></span><code class="calibre21">    public:</code>
<code class="calibre21">        Spreadsheet(std::size_t width, std::size_t height);</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet(const Spreadsheet&amp; src) = delete;</b></code>
<code class="calibre21">        ˜Spreadsheet();</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet&amp; operator=(const Spreadsheet&amp; rhs) = delete;</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        You don't provide implementations for deleted member functions. The linker will never look for them because the compiler won't allow code to call them. When you now write code to copy or assign to a
        <code class="calibre21">
         Spreadsheet
        </code>
        object, the compiler will complain with a message like this:
       </p>
       <pre class="calibre26" id="c09-code-0028"><code class="calibre21">'Spreadsheet &amp;Spreadsheet::operator =(const Spreadsheet &amp;)': attempting to reference a deleted function</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-189">
       Handling Moving with Move Semantics
      </h3>
      <p class="calibre13" id="c09-para-0070">
       <i class="calibre18">
        Move semantics
       </i>
       for classes requires a
       <i class="calibre18">
        move constructor
       </i>
       and a
       <i class="calibre18">
        move assignment operator
       </i>
       . These can be used by the compiler when the source object is a temporary object that will be destroyed after the operation is finished or, as you will see, explicitly when using
       <code class="calibre21">
        std::move()
       </code>
       . Moving
       <i class="calibre18">
        moves ownership
       </i>
       of memory and other resources from one object to another object. It basically does a
       <i class="calibre18">
        shallow
       </i>
       copy of data members
       <i class="calibre18">
        combined with
       </i>
       switching ownership of allocated memory and other resources to prevent dangling pointers or resources and to prevent memory leaks.
      </p>
      <p class="calibre13" id="c09-para-0071">
       Both the move constructor and the move assignment operator move the data members from a source object to a new object, leaving the source object in some valid but otherwise indeterminate state. Often, data members of the source object are reset to “null” values, but this is not a strict requirement. I do recommend, however, that you make sure your source objects are in a clearly defined empty state after a move operation. To be safe, never use any objects that have been moved from, as this could trigger undefined behavior. Some notable exceptions from the Standard Library are
       <code class="calibre21">
        std::unique_ptr
       </code>
       and
       <code class="calibre21">
        shared_ptr
       </code>
       . The Standard Library explicitly states that these smart pointers must reset their internal pointer to
       <code class="calibre21">
        nullptr
       </code>
       when moving from them, which makes it safe to reuse such smart pointers after a move operation.
      </p>
      <p class="calibre13" id="c09-para-0072">
       Before you can implement move semantics, you need to learn about rvalues and rvalue references.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0018">
       </span>
       <h4 class="calibre29" id="head-4-170">
        Rvalue References
       </h4>
       <p class="calibre13">
        In C++, an
        <i class="calibre18">
         lvalue
        </i>
        is something of which you can take an address, for example, a named variable. The name comes from the fact that lvalues can appear on the left-hand side of an assignment. An
        <i class="calibre18">
         rvalue
        </i>
        , on the other hand, is anything that is not an lvalue, such as a literal, or a temporary object or value.
        <a aria-describedby="c09-note-0001" class="calibre5" epub:type="noteref" href="#c09-note-0001" id="R_c09-note-0001" role="doc-noteref">
         <sup class="calibre22">
          1
         </sup>
        </a>
        Typically, an rvalue is on the right-hand side of an assignment operator. For example, take the following statement:
       </p>
       <pre class="calibre26" id="c09-code-0029"><code class="calibre21">int a { 4 * 2 };                                          </code></pre>
       <p class="calibre13" id="c09-para-0074">
        In this statement,
        <code class="calibre21">
         a
        </code>
        is an lvalue, it has a name, and you can take the address of it with
        <code class="calibre21">
         &amp;a
        </code>
        . The result of the expression
        <code class="calibre21">
         4*2
        </code>
        , on the other hand, is an rvalue. It is a temporary value that is destroyed when
        <span aria-label="308" class="calibre20" epub:type="pagebreak" id="Page_308" role="doc-pagebreak">
        </span>
        the statement finishes execution. In this example, a copy of this temporary value is stored in the variable with name
        <code class="calibre21">
         a
        </code>
        .
       </p>
       <p class="calibre13" id="c09-para-0075">
        If a function returns something by value, the result of calling that function is an rvalue, a temporary. If the function returns a reference-to-non-
        <code class="calibre21">
         const
        </code>
        , then the result of calling the function is an lvalue, as you will be able to use the result on the left-hand side of an assignment.
       </p>
       <p class="calibre13" id="c09-para-0076">
        An
        <i class="calibre18">
         rvalue reference
        </i>
        is a reference to an rvalue. In particular, it is a concept that is applied when the rvalue is a temporary object or an object that is explicitly moved using
        <code class="calibre21">
         std::move()
        </code>
        , explained later in this section. The purpose of an rvalue reference is to make it possible for a particular function overload to be chosen when an rvalue is involved. This allows certain operations that normally involve copying large values to instead copy pointers to those values.
       </p>
       <p class="calibre13">
        A function can specify an rvalue reference parameter by using
        <code class="calibre21">
         &amp;&amp;
        </code>
        as part of the parameter specification, for example,
        <code class="calibre21">
         type&amp;&amp; name
        </code>
        . Normally, a temporary object will be seen as a
        <code class="calibre21">
         const type&amp;
        </code>
        , but when there is a function overload that uses an rvalue reference, a temporary object can be resolved to that overload. The following example demonstrates this. The code first defines two
        <code class="calibre21">
         handleMessage()
        </code>
        functions, one accepting an lvalue reference and one accepting an rvalue reference:
       </p>
       <pre class="calibre26" id="c09-code-0030"><code class="calibre21">void handleMessage(string&amp; message) <span class="color">// lvalue reference parameter</span></code>
<code class="calibre21">{</code>
<code class="calibre21">    println("handleMessage with lvalue reference: {}", message);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void handleMessage(string&amp;&amp; message) <span class="color">// rvalue reference parameter</span></code>
<code class="calibre21">{</code>
<code class="calibre21">    println("handleMessage with rvalue reference: {}", message);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        You can call
        <code class="calibre21">
         handleMessage()
        </code>
        with a named variable as an argument:
       </p>
       <pre class="calibre26" id="c09-code-0031"><code class="calibre21">string a { "Hello " };</code>
<code class="calibre21">handleMessage(a);             <span class="color">// Calls handleMessage(string&amp; value)</span></code></pre>
       <p class="calibre13" id="c09-para-0079">
        Because
        <code class="calibre21">
         a
        </code>
        is a named variable, the
        <code class="calibre21">
         handleMessage()
        </code>
        function accepting an lvalue reference is called. Any changes
        <code class="calibre21">
         handleMessage()
        </code>
        does through its reference parameter will change the value of
        <code class="calibre21">
         a
        </code>
        .
       </p>
       <p class="calibre13">
        You can also call
        <code class="calibre21">
         handleMessage()
        </code>
        with an expression as an argument:
       </p>
       <pre class="calibre26" id="c09-code-0032"><code class="calibre21">string b { "World" };</code>
<code class="calibre21">handleMessage(a + b);         <span class="color">// Calls handleMessage(string&amp;&amp; value)</span></code></pre>
       <p class="calibre13" id="c09-para-0081">
        The
        <code class="calibre21">
         handleMessage()
        </code>
        function accepting an lvalue reference cannot be used, because the expression
        <code class="calibre21">
         a + b
        </code>
        results in a temporary, which is not an lvalue. In this case, the rvalue reference overload is called. Because the argument is a temporary, any changes
        <code class="calibre21">
         handleMessage()
        </code>
        does through its reference parameter will be lost after the call returns.
       </p>
       <p class="calibre13">
        A literal can also be used as argument to
        <code class="calibre21">
         handleMessage()
        </code>
        . This also triggers a call to the rvalue reference overload because a literal cannot be an lvalue (though a literal can be passed as argument to a reference-to-
        <code class="calibre21">
         const
        </code>
        parameter):
       </p>
       <pre class="calibre26" id="c09-code-0033"><code class="calibre21">handleMessage("Hello World"); <span class="color">// Calls handleMessage(string&amp;&amp; value)</span></code></pre>
       <p class="calibre13">
        <span aria-label="309" class="calibre20" epub:type="pagebreak" id="Page_309" role="doc-pagebreak">
        </span>
        If you remove the
        <code class="calibre21">
         handleMessage()
        </code>
        function accepting an lvalue reference, calling
        <code class="calibre21">
         handleMessage()
        </code>
        with a named variable like
        <code class="calibre21">
         handleMessage(b)
        </code>
        will result in a compilation error because an rvalue reference parameter (
        <code class="calibre21">
         string&amp;&amp;
        </code>
        ) will never be bound to an lvalue (
        <code class="calibre21">
         b
        </code>
        ). You can force the compiler to call the rvalue reference overload of
        <code class="calibre21">
         handleMessage()
        </code>
        by using
        <code class="calibre21">
         std::move()
        </code>
        . The only thing
        <code class="calibre21">
         move()
        </code>
        does is cast an lvalue to an rvalue reference; that is, it does not do any actual moving. However, by returning an rvalue reference, it allows the compiler to find an overload of
        <code class="calibre21">
         handleMessage()
        </code>
        accepting an rvalue reference, which can then perform the moving. Here is an example of using
        <code class="calibre21">
         move()
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0034"><code class="calibre21">handleMessage(std::move(b));  <span class="color">// Calls handleMessage(string&amp;&amp; value)</span></code></pre>
       <p class="calibre13">
        As I said before, but it's worth repeating,
        <i class="calibre18">
         a named variable is an lvalue
        </i>
        . So, inside the
        <code class="calibre21">
         handleMessage(string&amp;&amp; message)
        </code>
        function, the
        <code class="calibre21">
         message
        </code>
        rvalue reference parameter itself is an lvalue because it has a name! If you want to forward this rvalue reference parameter to another function as an rvalue, then you need to use
        <code class="calibre21">
         std::move()
        </code>
        to cast the lvalue to an rvalue reference. For example, suppose you add the following function with an rvalue reference parameter:
       </p>
       <pre class="calibre26" id="c09-code-0035"><code class="calibre21">void helper(string&amp;&amp; message) { }</code></pre>
       <p class="calibre13">
        Calling it as follows does not compile:
       </p>
       <pre class="calibre26" id="c09-code-0036"><code class="calibre21">void handleMessage(string&amp;&amp; message) { <b class="calibre14">helper(message);</b> }</code></pre>
       <p class="calibre13">
        The
        <code class="calibre21">
         helper()
        </code>
        function needs an rvalue reference, while
        <code class="calibre21">
         handleMessage()
        </code>
        passes
        <code class="calibre21">
         message
        </code>
        , which has a name, so it's an lvalue, causing a compilation error. Here is the correct way using
        <code class="calibre21">
         std::move()
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0037"><code class="calibre21">void handleMessage(string&amp;&amp; message) { <b class="calibre14">helper(std::move(message));</b> }</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0088">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            A named rvalue reference, such as an rvalue reference parameter, itself is an lvalue because it has a name!
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Rvalue references are not limited to parameters of functions. You can declare a variable of an rvalue reference type and assign to it, although this usage is uncommon. Consider the following code, which is illegal in C++:
       </p>
       <pre class="calibre26" id="c09-code-0038"><code class="calibre21">int&amp; i { 2 };       <span class="color">// Invalid: reference to a constant</span></code>
<code class="calibre21">int a { 2 }, b { 3 };</code>
<code class="calibre21">int&amp; j { a + b };   <span class="color">// Invalid: reference to a temporary</span></code></pre>
       <p class="calibre13">
        Using rvalue references, the following is perfectly legal:
       </p>
       <pre class="calibre26" id="c09-code-0039"><code class="calibre21">int&amp;&amp; i { 2 };</code>
<code class="calibre21">int a { 2 }, b { 3 };</code>
<code class="calibre21">int&amp;&amp; j { a + b };</code></pre>
       <p class="calibre13">
        However, such stand-alone rvalue references are rarely used in this way.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0092">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            If a temporary is assigned to an rvalue reference, the lifetime of the temporary is extended for as long as the rvalue reference is in scope
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <span aria-label="310" class="calibre20" epub:type="pagebreak" id="Page_310" role="doc-pagebreak">
       </span>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0021">
       </span>
       <h4 class="calibre29" id="head-4-171">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        Decay Copy
       </h4>
       <p class="calibre13" id="c09-para-0094">
        If you have an object
        <code class="calibre21">
         x
        </code>
        , writing “
        <code class="calibre21">
         auto y{x}
        </code>
        ” creates a copy of
        <code class="calibre21">
         x
        </code>
        and gives it a name
        <code class="calibre21">
         y
        </code>
        ; thus, it is an lvalue.
       </p>
       <p class="calibre13" id="c09-para-0095">
        C++23 introduces the
        <code class="calibre21">
         auto(x)
        </code>
        or
        <code class="calibre21">
         auto{x}
        </code>
        syntax to create a copy of an object
        <code class="calibre21">
         x
        </code>
        as an rvalue, not an lvalue.
       </p>
       <p class="calibre13">
        As an example, assume you have only the rvalue reference
        <code class="calibre21">
         handleMessage(string&amp;&amp;)
        </code>
        function from the previous section, not the lvalue reference overload. You know that the following won't work in that case:
       </p>
       <pre class="calibre26" id="c09-code-0040"><code class="calibre21">string value { "Hello " };</code>
<code class="calibre21">handleMessage(value);  <span class="color">// Error</span></code></pre>
       <p class="calibre13">
        You could use
        <code class="calibre21">
         std::move()
        </code>
        , as in:
       </p>
       <pre class="calibre26" id="c09-code-0041"><code class="calibre21">handleMessage(<b class="calibre14">std::move(value)</b>);</code></pre>
       <p class="calibre13" id="c09-para-0098">
        But, after this operation, you should not use the
        <code class="calibre21">
         value
        </code>
        object any longer, as it might have been moved.
       </p>
       <p class="calibre13">
        Using C++23 decay-copy syntax, you can write:
       </p>
       <pre class="calibre26" id="c09-code-0042"><code class="calibre21">handleMessage(<b class="calibre14">auto { value }</b>);</code></pre>
       <p class="calibre13" id="c09-para-0100">
        This makes a temporary copy of object
        <code class="calibre21">
         value
        </code>
        as an rvalue and passes that rvalue to
        <code class="calibre21">
         handleMessage()
        </code>
        . If
        <code class="calibre21">
         handleMessage()
        </code>
        moves from the copy, the original object,
        <code class="calibre21">
         value
        </code>
        , is retained and not impacted
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0022">
       </span>
       <h4 class="calibre29" id="head-4-172">
        Implementing Move Semantics
       </h4>
       <p class="calibre13" id="c09-para-0101">
        Move semantics is implemented using rvalue references. To add move semantics to a class, you need to implement a
        <i class="calibre18">
         move constructor
        </i>
        and a
        <i class="calibre18">
         move assignment operator
        </i>
        . Move constructors and move assignment operators should be marked with the
        <code class="calibre21">
         noexcept
        </code>
        specifier to tell the compiler that they don't throw any exceptions. This is particularly important for compatibility with the Standard Library, as fully compliant implementations of, for example, the Standard Library containers will only move stored objects if, having move semantics implemented, they also guarantee not to throw. This is done to be able to provide strong exception safety.
       </p>
       <p class="calibre13">
        The following is the
        <code class="calibre21">
         Spreadsheet
        </code>
        class definition with a move constructor and move assignment operator. Two helper member functions are introduced as well:
        <code class="calibre21">
         cleanup()
        </code>
        , which is used from the destructor and the move assignment operator, and
        <code class="calibre21">
         moveFrom()
        </code>
        , which moves the data members from a source to a destination and then resets the source object.
       </p>
       <pre class="calibre26" id="c09-code-0043"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet(Spreadsheet&amp;&amp; src) noexcept;</b> <span class="color">// Move constructor</span></code>
<code class="calibre21">        <b class="calibre14">Spreadsheet&amp; operator=(Spreadsheet&amp;&amp; rhs) noexcept;</b> <span class="color">// Move assignment</span></code>
<code class="calibre21">        <span class="color">// Remaining code omitted for brevity</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">void cleanup() noexcept;</b></code>
<code class="calibre21">        <b class="calibre14">void moveFrom(Spreadsheet&amp; src) noexcept;</b></code>
<code class="calibre21">        <span class="color">// Remaining code omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="311" class="calibre20" epub:type="pagebreak" id="Page_311" role="doc-pagebreak">
        </span>
        The implementations are as follows:
       </p>
       <pre class="calibre26" id="c09-code-0044"><code class="calibre21">void Spreadsheet::cleanup() noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        delete[] m_cells[i];</code>
<code class="calibre21">    }</code>
<code class="calibre21">    delete[] m_cells;</code>
<code class="calibre21">    m_cells = nullptr;</code>
<code class="calibre21">    m_width = m_height = 0;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">void Spreadsheet::moveFrom(Spreadsheet&amp; src) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Shallow copy of data</span></code>
<code class="calibre21">    m_width = src.m_width;</code>
<code class="calibre21">    m_height = src.m_height;</code>
<code class="calibre21">    m_cells = src.m_cells;</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Reset the source object, because ownership has been moved!</span></code>
<code class="calibre21">    src.m_width = 0;</code>
<code class="calibre21">    src.m_height = 0;</code>
<code class="calibre21">    src.m_cells = nullptr;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Move constructor</span></code>
<code class="calibre21">Spreadsheet::Spreadsheet(Spreadsheet&amp;&amp; src) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    moveFrom(src);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Move assignment operator</span></code>
<code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(Spreadsheet&amp;&amp; rhs) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Check for self-assignment</span></code>
<code class="calibre21">    if (this == &amp;rhs) {</code>
<code class="calibre21">        return *this;</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Free the old memory and move ownership</span></code>
<code class="calibre21">    cleanup();</code>
<code class="calibre21">    moveFrom(rhs);</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0104">
        Both the move constructor and the move assignment operator are moving ownership of the memory for
        <code class="calibre21">
         m_cells
        </code>
        from a source object to a new object. They reset the
        <code class="calibre21">
         m_cells
        </code>
        pointer of the source object to a null pointer and set
        <code class="calibre21">
         m_width
        </code>
        and
        <code class="calibre21">
         m_height
        </code>
        of the source object to zero to prevent the source object's destructor from deallocating any memory because the new object is now the owner of it.
       </p>
       <p class="calibre13" id="c09-para-0105">
        Obviously, move semantics is useful only when you know that the source object is not needed anymore.
       </p>
       <p class="calibre13">
        <span aria-label="312" class="calibre20" epub:type="pagebreak" id="Page_312" role="doc-pagebreak">
        </span>
        Note that this implementation includes a self-assignment test in the move assignment operator. Depending on your class and depending on how you are moving one instance of your class to another instance, this self-assignment test might not always be necessary. However, you should always include it, just as the C++ Core Guidelines recommend,
        <a aria-describedby="c09-note-0002" class="calibre5" epub:type="noteref" href="#c09-note-0002" id="R_c09-note-0002" role="doc-noteref">
         <sup class="calibre22">
          2
         </sup>
        </a>
        to make sure that code as follows never causes a crash at run time:
       </p>
       <pre class="calibre26" id="c09-code-0045"><code class="calibre21">sheet1 = std::move(sheet1);</code></pre>
       <p class="calibre13" id="c09-para-0107">
        Move constructors and move assignment operators can be explicitly deleted or defaulted, just like copy constructors and copy assignment operators, as explained in
        <a class="calibre5" href="c08.xhtml">
         Chapter 8
        </a>
        .
       </p>
       <p class="calibre13">
        The compiler automatically generates a default move constructor for a class if and only if the class has no user-declared copy constructor, copy assignment operator, move assignment operator, or destructor. A default move assignment operator is generated for a class if and only if the class has no user-declared copy constructor, move constructor, copy assignment operator, or destructor.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0109">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            When you declare one or more of the special member functions (destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator), then it’s recommended to declare all of them. This is called the rule of five. You either provide explicit implementations for them or explicitly default (
           </i>
           <code class="calibre21">
            =default
           </code>
           <i class="calibre18">
            ) or delete (
           </i>
           <code class="calibre21">
            =delete
           </code>
           <i class="calibre18">
            ) them.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0024">
        </span>
        <h5 class="calibre35" id="head-5-67">
         Using std::exchange
        </h5>
        <p class="calibre13">
         You can use
         <code class="calibre21">
          std::exchange()
         </code>
         , defined in
         <code class="calibre21">
          &lt;utility&gt;
         </code>
         , to replace a value with a new value and return the old value, as in this example:
        </p>
        <pre class="calibre26" id="c09-code-0046"><code class="calibre21">int a { 11 };</code>
<code class="calibre21">int b { 22 };</code>
<code class="calibre21">println("Before exchange(): a = {}, b = {}", a, b);</code>
<code class="calibre21"><b class="calibre14">int returnedValue { exchange(a, b) };</b></code>
<code class="calibre21">println("After exchange():  a = {}, b = {}", a, b);</code>
<code class="calibre21">println("exchange() returned: {}", returnedValue);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c09-code-0047"><code class="calibre21">Before exchange(): a = 11, b = 22</code>
<code class="calibre21">After exchange():  a = 22, b = 22</code>
<code class="calibre21">exchange() returned: 11</code></pre>
        <p class="calibre13">
         The
         <code class="calibre21">
          exchange()
         </code>
         function is useful in implementing move assignment operators. A move assignment operator needs to move the data from a source object to a destination object, after which the data in the source object is usually nullified. In the previous section, this is done as follows:
        </p>
        <pre class="calibre26" id="c09-code-0048"><code class="calibre21">void Spreadsheet::moveFrom(Spreadsheet&amp; src) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Shallow copy of data</span></code>
<code class="calibre21">    m_width = src.m_width;</code>
<span aria-label="313" class="calibre20" epub:type="pagebreak" id="Page_313" role="doc-pagebreak"></span><code class="calibre21">    m_height = src.m_height;</code>
<code class="calibre21">    m_cells = src.m_cells;</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Reset the source object, because ownership has been moved!</span></code>
<code class="calibre21">    src.m_width = 0;</code>
<code class="calibre21">    src.m_height = 0;</code>
<code class="calibre21">    src.m_cells = nullptr;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         This member function copies the
         <code class="calibre21">
          m_width
         </code>
         ,
         <code class="calibre21">
          m_height
         </code>
         , and
         <code class="calibre21">
          m_cells
         </code>
         data members from the source object and then sets them to either
         <code class="calibre21">
          0
         </code>
         or
         <code class="calibre21">
          nullptr
         </code>
         , because ownership has been moved. With
         <code class="calibre21">
          exchange()
         </code>
         this can be written more compactly as follows:
        </p>
        <pre class="calibre26" id="c09-code-0049"><code class="calibre21">void Spreadsheet::moveFrom(Spreadsheet&amp; src) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_width = exchange(src.m_width, 0);</code>
<code class="calibre21">    m_height = exchange(src.m_height, 0);</code>
<code class="calibre21">    m_cells = exchange(src.m_cells, nullptr);</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0025">
        </span>
        <h5 class="calibre35" id="head-5-68">
         Moving Object Data Members
        </h5>
        <p class="calibre13">
         The
         <code class="calibre21">
          moveFrom()
         </code>
         member function uses direct assignments of the three data members because they are primitive types. If your object contains other objects as data members, then you should move these objects using
         <code class="calibre21">
          std::move()
         </code>
         . Suppose the
         <code class="calibre21">
          Spreadsheet
         </code>
         class has an
         <code class="calibre21">
          std::string
         </code>
         data member called
         <code class="calibre21">
          m_name
         </code>
         . The
         <code class="calibre21">
          moveFrom()
         </code>
         member function should then be implemented as follows:
        </p>
        <pre class="calibre26" id="c09-code-0050"><code class="calibre21">void Spreadsheet::moveFrom(Spreadsheet&amp; src) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Move object data members</span></code>
<code class="calibre21">    <b class="calibre14">m_name = std::move(src.m_name);</b></code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Move primitives:</span></code>
<code class="calibre21">    m_width = exchange(src.m_width, 0);</code>
<code class="calibre21">    m_height = exchange(src.m_height, 0);</code>
<code class="calibre21">    m_cells = exchange(src.m_cells, nullptr);</code>
<code class="calibre21">}</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0026">
        </span>
        <h5 class="calibre35" id="head-5-69">
         Move Constructor and Move Assignment Operator in Terms of Swap
        </h5>
        <p class="calibre13" id="c09-para-0115">
         The previous implementation of the move constructor and the move assignment operator both use the
         <code class="calibre21">
          moveFrom()
         </code>
         helper function, which moves all data members by performing shallow copies. With this implementation, if you add a new data member to the
         <code class="calibre21">
          Spreadsheet
         </code>
         class, you have to modify both the
         <code class="calibre21">
          swap()
         </code>
         function and the
         <code class="calibre21">
          moveFrom()
         </code>
         function. If you forget to update one of them, you introduce a bug. To avoid such bugs, you can write the move constructor and the move assignment operator in terms of the
         <code class="calibre21">
          swap()
         </code>
         function.
        </p>
        <p class="calibre13">
         First, the
         <code class="calibre21">
          cleanup()
         </code>
         and
         <code class="calibre21">
          moveFrom()
         </code>
         helper functions can be removed. The code from the
         <code class="calibre21">
          cleanup()
         </code>
         function is moved to the destructor. The move constructor and move assignment operator can then be implemented as follows:
        </p>
        <pre class="calibre26" id="c09-code-0051"><code class="calibre21">Spreadsheet::Spreadsheet(Spreadsheet&amp;&amp; src) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    swap(src);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="314" class="calibre20" epub:type="pagebreak" id="Page_314" role="doc-pagebreak"></span><code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(Spreadsheet&amp;&amp; rhs) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto moved { std::move(rhs) }; <span class="color">// Move rhs into moved (noexcept)</span></code>
<code class="calibre21">    swap(moved); <span class="color">// Commit the work with only non-throwing operations</span></code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The move constructor simply swaps the default constructed
         <code class="calibre21">
          *this
         </code>
         with the given source object. The move assignment operator uses the
         <i class="calibre18">
          move-and-swap
         </i>
         idiom, which is similar to the copy-and-swap idiom discussed before.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c09-para-0118">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Implementing a move constructor and move assignment operator in terms of
            </i>
            <code class="calibre21">
             swap
             <i class="calibre18">
              ()
             </i>
            </code>
            <i class="calibre18">
             requires less code. It is also less likely bugs are introduced when data members are added, because you only have to update your
            </i>
            <code class="calibre21">
             swap()
            </code>
            <i class="calibre18">
             implementation to include those new data members.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
        <p class="calibre13">
         The
         <code class="calibre21">
          Spreadsheet
         </code>
         move assignment operator could also be implemented as follows:
        </p>
        <pre class="calibre26" id="c09-code-0052"><code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(Spreadsheet&amp;&amp; rhs) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    swap(rhs);</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c09-para-0120">
         However, doing so does not guarantee that the contents of
         <code class="calibre21">
          this
         </code>
         is immediately cleaned up. Instead, the contents of
         <code class="calibre21">
          this
         </code>
         escapes through
         <code class="calibre21">
          rhs
         </code>
         to the caller of the move assignment operator and thus might stay alive longer than expected.
        </p>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0028">
       </span>
       <h4 class="calibre29" id="head-4-173">
        Testing the Spreadsheet Move Operations
       </h4>
       <p class="calibre13">
        The
        <code class="calibre21">
         Spreadsheet
        </code>
        move constructor and move assignment operator can be tested with the following code:
       </p>
       <pre class="calibre26" id="c09-code-0053"><code class="calibre21">Spreadsheet createObject()</code>
<code class="calibre21">{</code>
<code class="calibre21">    return Spreadsheet { 3, 2 };</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector&lt;Spreadsheet&gt; vec;</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; 2; ++i) {</code>
<code class="calibre21">        println("Iteration {}", i);</code>
<code class="calibre21">        vec.push_back(Spreadsheet { 100, 100 });</code>
<code class="calibre21">        println("");</code>
<code class="calibre21">    }</code>
<code class="calibre21"> </code>
<code class="calibre21">    Spreadsheet s { 2, 3 };</code>
<span aria-label="315" class="calibre20" epub:type="pagebreak" id="Page_315" role="doc-pagebreak"></span><code class="calibre21">    s = createObject();</code>
<code class="calibre21"> </code>
<code class="calibre21">    println("");</code>
<code class="calibre21"> </code>
<code class="calibre21">    Spreadsheet s2 { 5, 6 };</code>
<code class="calibre21">    s2 = s;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0122">
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        introduces the
        <code class="calibre21">
         vector
        </code>
        . A
        <code class="calibre21">
         vector
        </code>
        grows dynamically in size to accommodate new objects. This is done by allocating a bigger chunk of memory and then copying or moving the objects from the old
        <code class="calibre21">
         vector
        </code>
        to the new and bigger
        <code class="calibre21">
         vector
        </code>
        . If the compiler finds a
        <code class="calibre21">
         noexcept
        </code>
        move constructor, the objects are moved instead of copied. Because they are moved, there is no need for any deep copying, making it much more efficient.
       </p>
       <p class="calibre13">
        After adding print statements to all constructors and assignment operators of the
        <code class="calibre21">
         Spreadsheet
        </code>
        class, the output of the preceding test program can be as follows. The numbers to the right of each line are not part of the actual output but added in this text to make it easier to refer to specific lines in the discussion that follows. This output and the following discussion are based on the version of the
        <code class="calibre21">
         Spreadsheet
        </code>
        class using the move-and-swap idiom to implement its move operations, and on the Microsoft Visual C++ 2022 compiler for a release build of the code. The C++ standard does not specify the initial capacity of a
        <code class="calibre21">
         vector
        </code>
        nor its growth strategy, so the output can be different on different compilers.
       </p>
       <pre class="calibre26" id="c09-code-0054"><code class="calibre21">Iteration 0</code>
<code class="calibre21">Normal constructor         (1)</code>
<code class="calibre21">Move constructor           (2)</code>
<code class="calibre21"> </code>
<code class="calibre21">Iteration 1</code>
<code class="calibre21">Normal constructor         (3)</code>
<code class="calibre21">Move constructor           (4)</code>
<code class="calibre21">Move constructor           (5)</code>
<code class="calibre21"> </code>
<code class="calibre21">Normal constructor         (6)</code>
<code class="calibre21">Normal constructor         (7)</code>
<code class="calibre21">Move assignment operator   (8)</code>
<code class="calibre21">Move constructor           (9)   </code>
<code class="calibre21"> </code>
<code class="calibre21">Normal constructor        (10)</code>
<code class="calibre21">Copy assignment operator  (11)</code>
<code class="calibre21">Normal constructor        (12)</code>
<code class="calibre21">Copy constructor          (13)</code></pre>
       <p class="calibre13">
        On the first iteration of the loop, the
        <code class="calibre21">
         vector
        </code>
        is still empty. Take the following line of code from the loop:
       </p>
       <pre class="calibre26" id="c09-code-0055"><code class="calibre21">vec.push_back(Spreadsheet { 100, 100 });</code></pre>
       <p class="calibre13" id="c09-para-0125">
        With this line, a new
        <code class="calibre21">
         Spreadsheet
        </code>
        object is created, invoking the normal constructor (1). The
        <code class="calibre21">
         vector
        </code>
        resizes itself to make space for the new object being pushed in. The created
        <code class="calibre21">
         Spreadsheet
        </code>
        object is then moved into the
        <code class="calibre21">
         vector
        </code>
        , invoking the move constructor (2).
       </p>
       <p class="calibre13" id="c09-para-0126">
        On the second iteration of the loop, a second
        <code class="calibre21">
         Spreadsheet
        </code>
        object is created with the normal constructor (3). At this point, the
        <code class="calibre21">
         vector
        </code>
        can hold one element, so it's again resized to make space for
        <span aria-label="316" class="calibre20" epub:type="pagebreak" id="Page_316" role="doc-pagebreak">
        </span>
        a second object. Because the
        <code class="calibre21">
         vector
        </code>
        is resized, the previously added elements need to be moved from the old
        <code class="calibre21">
         vector
        </code>
        to the new and bigger
        <code class="calibre21">
         vector
        </code>
        . This triggers a call to the move constructor for each previously added element. There is one element in the
        <code class="calibre21">
         vector
        </code>
        , so the move constructor is called one time (4). Finally, the new
        <code class="calibre21">
         Spreadsheet
        </code>
        object is moved into the
        <code class="calibre21">
         vector
        </code>
        with its move constructor (5).
       </p>
       <p class="calibre13" id="c09-para-0127">
        Next, a
        <code class="calibre21">
         Spreadsheet
        </code>
        object
        <code class="calibre21">
         s
        </code>
        is created using the normal constructor (6). The
        <code class="calibre21">
         createObject()
        </code>
        function creates a temporary
        <code class="calibre21">
         Spreadsheet
        </code>
        object with its normal constructor (7), which is then returned from the function and assigned to the variable
        <code class="calibre21">
         s
        </code>
        . Because the temporary object returned from
        <code class="calibre21">
         createObject()
        </code>
        ceases to exist after the assignment, the compiler invokes the move assignment operator (8) instead of the copy assignment operator. The move assignment operator uses the move-and-swap idiom, so it delegates work to the move constructor (9).
       </p>
       <p class="calibre13" id="c09-para-0128">
        Another
        <code class="calibre21">
         Spreadsheet
        </code>
        object is created,
        <code class="calibre21">
         s2
        </code>
        , using the normal constructor (10). The assignment
        <code class="calibre21">
         s2 = s
        </code>
        invokes the copy assignment operator (11) because the right-hand side object is not a temporary object, but a named object. This copy assignment operator uses the copy-and-swap idiom, which creates a temporary copy, triggering a call to the copy constructor, which first delegates to the normal constructor (12 and 13).
       </p>
       <p class="calibre13" id="c09-para-0129">
        If the
        <code class="calibre21">
         Spreadsheet
        </code>
        class did not implement move semantics, all the calls to the move constructor and move assignment operator would be replaced with calls to the copy constructor and copy assignment operator. In the previous example, the
        <code class="calibre21">
         Spreadsheet
        </code>
        objects in the loop have 10,000 (100 × 100) elements. The implementations of the
        <code class="calibre21">
         Spreadsheet
        </code>
        move constructor and move assignment operator don't require any memory allocation, while the copy constructor and copy assignment operator require 101 allocations each. So, using move semantics can increase performance a lot in certain situations.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0029">
       </span>
       <h4 class="calibre29" id="head-4-174">
        Implementing a Swap Function with Move Semantics
       </h4>
       <p class="calibre13">
        As another example where move semantics increases performance, take a
        <code class="calibre21">
         swap()
        </code>
        function that swaps two
        <code class="calibre21">
         Object
        </code>
        s. The following
        <code class="calibre21">
         swapCopy()
        </code>
        implementation does not use move semantics:
       </p>
       <pre class="calibre26" id="c09-code-0056"><code class="calibre21">void swapCopy(Object&amp; a, Object&amp; b)</code>
<code class="calibre21">{</code>
<code class="calibre21">    Object temp { a };</code>
<code class="calibre21">    a = b;</code>
<code class="calibre21">    b = temp;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        First,
        <code class="calibre21">
         a
        </code>
        is copied to
        <code class="calibre21">
         temp
        </code>
        , then
        <code class="calibre21">
         b
        </code>
        is copied to
        <code class="calibre21">
         a
        </code>
        , and finally
        <code class="calibre21">
         temp
        </code>
        is copied to
        <code class="calibre21">
         b
        </code>
        . This implementation will hurt performance if
        <code class="calibre21">
         Object
        </code>
        is expensive to copy. With move semantics, the implementation can avoid all copying:
       </p>
       <pre class="calibre26" id="c09-code-0057"><code class="calibre21">void swapMove(Object&amp; a, Object&amp; b)</code>
<code class="calibre21">{</code>
<code class="calibre21">    Object temp { std::move(a) };</code>
<code class="calibre21">    a = std::move(b);</code>
<code class="calibre21">    b = std::move(temp);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0132">
        This is how
        <code class="calibre21">
         std::swap()
        </code>
        from the Standard Library is implemented.
       </p>
      </section>
      <span aria-label="317" class="calibre20" epub:type="pagebreak" id="Page_317" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0030">
       </span>
       <h4 class="calibre29" id="head-4-175">
        Using std::move() in Return Statements
       </h4>
       <p class="calibre13">
        As
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        states, since C++17, a compiler is not allowed to perform any copying or moving of objects for statements of the form
        <code class="calibre21">
         return object;
        </code>
        where
        <code class="calibre21">
         object
        </code>
        is a nameless temporary. This is called
        <i class="calibre18">
         mandatory elision of copy/move operations
        </i>
        and means that there's no performance penalty at all by returning
        <code class="calibre21">
         object
        </code>
        by value. If
        <code class="calibre21">
         object
        </code>
        is a local variable that is not a function parameter,
        <i class="calibre18">
         non-mandatory elision of copy/move operations
        </i>
        is allowed, an optimization also known as
        <i class="calibre18">
         named return value optimization
        </i>
        (NRVO). This optimization is not guaranteed by the standard. Some compilers perform this optimization only for release builds but not for debug builds. With mandatory and non-mandatory elision, compilers can avoid any copying of objects that are returned from functions. This results in
        <i class="calibre18">
         zero-copy pass-by-value
        </i>
        semantics.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0134">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            Note that for NRVO, even though the copy/move constructors won't be called, they still need to be accessible; otherwise, the program is ill-formed according to the standard
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Now, what happens when using
        <code class="calibre21">
         std::move()
        </code>
        to return an object? Consider you write the following:
       </p>
       <pre class="calibre26" id="c09-code-0058"><code class="calibre21">return std::move(object);</code></pre>
       <p class="calibre13" id="c09-para-0136">
        With this code, compilers cannot apply mandatory nor non-mandatory (NRVO) elision of copy/move operations anymore, as that works only for statements of the form
        <code class="calibre21">
         return object;
        </code>
        . Since copy/move elision cannot be applied anymore, the next option for the compiler is to use move semantics if the object supports it, and if not, fall back to copy semantics.
       </p>
       <p class="calibre13">
        Compared to NRVO, falling back to move semantics has a small performance impact, but falling back to copy semantics can have a big performance impact! So, keep the following warning in mind:
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0138">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            When returning a local variable or nameless temporary from a function, simply write
           </i>
           <code class="calibre21">
            return object;
           </code>
           <i class="calibre18">
            and do not use
           </i>
           <code class="calibre21">
            std::move()
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13" id="c09-para-0139">
        Note that if you want to return a data member of a class from one of its member functions, then you need to use
        <code class="calibre21">
         std::move()
        </code>
        if you want to move it out instead of returning a copy.
       </p>
       <p class="calibre13">
        Additionally, be careful with expressions such as the following:
       </p>
       <pre class="calibre26" id="c09-code-0059"><code class="calibre21">return condition ? obj1 : obj2;</code></pre>
       <p class="calibre13">
        This is not of the form
        <code class="calibre21">
         return object;
        </code>
        , so the compiler cannot apply copy/move elision. Even worse, an expression of the form
        <code class="calibre21">
         condition ? obj1 : obj2
        </code>
        is an lvalue, so the compiler uses a copy constructor instead to return one of the objects. To at least trigger move semantics, you can rewrite the
        <code class="calibre21">
         return
        </code>
        statement as follows:
       </p>
       <pre class="calibre26" id="c09-code-0060"><code class="calibre21">return condition ? std::move(obj1) : std::move(obj2);</code></pre>
       <p class="calibre13">
        <span aria-label="318" class="calibre20" epub:type="pagebreak" id="Page_318" role="doc-pagebreak">
        </span>
        or
       </p>
       <pre class="calibre26" id="c09-code-0061"><code class="calibre21">return std::move(condition ? obj1 : obj2);</code></pre>
       <p class="calibre13">
        However, it's clearer to rewrite the
        <code class="calibre21">
         return
        </code>
        statement as follows for which a compiler can automatically use move semantics without explicitly using
        <code class="calibre21">
         std::move()
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0062"><code class="calibre21">if (condition) {</code>
<code class="calibre21">    return obj1;</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    return obj2;</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0033">
       </span>
       <h4 class="calibre29" id="head-4-176">
        Optimal Way to Pass Arguments to Functions
       </h4>
       <p class="calibre13">
        Up to now, the advice has been to use reference-to-
        <code class="calibre21">
         const
        </code>
        parameters for non-primitive function parameters to avoid unnecessary expensive copying of an argument passed to a function. However, with rvalues in the mix, things change slightly. Imagine a function that anyways copies an argument passed as one of its parameters. This situation often pops up with class member functions. Here is a simple example:
       </p>
       <pre class="calibre26" id="c09-code-0063"><code class="calibre21">class DataHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setData(const vector&lt;int&gt;&amp; data) { m_data = data; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        vector&lt;int&gt; m_data;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <code class="calibre21">
         setData()
        </code>
        makes a copy of the data passed in. Now that you are fluent with rvalues and rvalue references, you might want to add an overload to optimize
        <code class="calibre21">
         setData()
        </code>
        to avoid any copying in case of rvalues. Here's an example:
       </p>
       <pre class="calibre26" id="c09-code-0064"><code class="calibre21">class DataHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setData(const vector&lt;int&gt;&amp; data) { m_data = data; }</code>
<code class="calibre21">        <b class="calibre14">void setData(vector&lt;int&gt;&amp;&amp; data) { m_data = move(data); }</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        vector&lt;int&gt; m_data;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c09-para-0146">
        When
        <code class="calibre21">
         setData()
        </code>
        is called with a temporary, no copies are made; the data is moved instead.
       </p>
       <p class="calibre13">
        The code in the following code snippet triggers a call to the reference-to-
        <code class="calibre21">
         const
        </code>
        overload of
        <code class="calibre21">
         setData()
        </code>
        , and hence a copy of the data is made:
       </p>
       <pre class="calibre26" id="c09-code-0065"><code class="calibre21">DataHolder wrapper;</code>
<code class="calibre21">vector myData { 11, 22, 33 };</code>
<code class="calibre21">wrapper.setData(myData);</code></pre>
       <p class="calibre13">
        On the other hand, the following code snippet calls
        <code class="calibre21">
         setData()
        </code>
        with a temporary, which triggers a call to the rvalue reference overload of
        <code class="calibre21">
         setData()
        </code>
        . The data is subsequently moved instead of copied.
       </p>
       <pre class="calibre26" id="c09-code-0066"><code class="calibre21">wrapper.setData({ 22, 33, 44 });</code></pre>
       <p class="calibre13">
        <span aria-label="319" class="calibre20" epub:type="pagebreak" id="Page_319" role="doc-pagebreak">
        </span>
        Unfortunately, this way to optimize
        <code class="calibre21">
         setData()
        </code>
        for both lvalues and rvalues requires an implementation of two overloads. Luckily, there is a better way that involves a single member function using pass-by-value. Yes, pass-by-value! Up to now, it has been advised to always pass objects using reference-to-
        <code class="calibre21">
         const
        </code>
        parameters to avoid any unnecessary copying, but now we advise to use pass-by-value. Let's clarify. For parameters that are not copied, passing by reference-to-
        <code class="calibre21">
         const
        </code>
        is still the way to go. The pass-by-value advice
        <i class="calibre18">
         is suitable only
        </i>
        for parameters that the function would copy anyway. In that case, by using pass-by-value semantics, the code is optimal for both lvalues and rvalues. If an lvalue is passed in, it's copied exactly one time, just as with a reference-to-
        <code class="calibre21">
         const
        </code>
        parameter. And, if an rvalue is passed in, no copy is made, just as with an rvalue reference parameter. Let's look at some code:
       </p>
       <pre class="calibre26" id="c09-code-0067"><code class="calibre21">class DataHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">void setData(vector&lt;int&gt; data) { m_data = move(data); }</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        vector&lt;int&gt; m_data;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        If an lvalue is passed to
        <code class="calibre21">
         setData()
        </code>
        , it is copied into the
        <code class="calibre21">
         data
        </code>
        parameter and subsequently moved to
        <code class="calibre21">
         m_data
        </code>
        . If an rvalue is passed to
        <code class="calibre21">
         setData()
        </code>
        , it is moved into the
        <code class="calibre21">
         data
        </code>
        parameter, and moved again to
        <code class="calibre21">
         m_data
        </code>
        .
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0151">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            Prefer pass-by-value for parameters that a function inherently would copy, but only if the parameter is of a type that supports move semantics and only if you don't need polymorphic behavior on the parameter. Otherwise, use reference-to
           </i>
           -
           <code class="calibre21">
            const
           </code>
           <i class="calibre18">
            parameters. Passing polymorphic types by value can result in slicing. This is explained in
            <a class="calibre5" href="c10_split_000.xhtml">
             Chapter 10
            </a>
            , “Discovering Inheritance Techniques.”
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0035">
      </span>
      <h3 class="calibre27" id="head-3-190">
       Rule of Zero
      </h3>
      <p class="calibre13" id="c09-para-0152">
       Earlier in this chapter, the rule of five was introduced. It states that once you declare one of the five special member functions (destructor, copy constructor, move constructor, copy assignment operator, and move assignment operator), then you should declare all of them by either implementing, defaulting, or deleting them. The reason is that there are complicated rules that compilers follow to decide whether to automatically provide a compiler-generated version of those special member functions. By declaring all of them yourself, you don't leave anything for the compiler to decide, making your intent much clearer.
      </p>
      <p class="calibre13" id="c09-para-0153">
       All the discussions so far have been to explain how to write those five special member functions. However, in modern C++, you should adopt the
       <i class="calibre18">
        rule of zero
       </i>
       .
      </p>
      <p class="calibre13">
       The rule of zero states that you should design your classes in such a way that they do not require any of those five special member functions. How do you do that? You can do that for non-polymorphic types in which you avoid using old-style dynamically allocated memory or other resources. Instead, use modern constructs such as Standard Library containers and smart pointers. For example, you can
       <span aria-label="320" class="calibre20" epub:type="pagebreak" id="Page_320" role="doc-pagebreak">
       </span>
       use a
       <code class="calibre21">
        vector&lt;vector&lt;SpreadsheetCell&gt;&gt;
       </code>
       instead of the
       <code class="calibre21">
        SpreadsheetCell**
       </code>
       data member in the
       <code class="calibre21">
        Spreadsheet
       </code>
       class. Or even better, use a
       <code class="calibre21">
        vector&lt;SpreadsheetCell&gt;
       </code>
       storing a linearized representation of a spreadsheet. The
       <code class="calibre21">
        vector
       </code>
       handles memory automatically, so there is no need for any of those five special member functions.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0155">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           In modern C++, adopt the rule of zero!
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c09-para-0156">
       The rule of five should be limited to custom resource acquisition is initialization (RAII) classes. An RAII class takes ownership of a resource and handles its deallocation at the right time. It's a design technique used, for example, by
       <code class="calibre21">
        vector
       </code>
       and
       <code class="calibre21">
        unique_ptr
       </code>
       and discussed further in
       <a class="calibre5" href="c32.xhtml">
        Chapter 32
       </a>
       , “Incorporating Design Techniques and Frameworks.” Additionally,
       <a class="calibre5" href="c10_split_000.xhtml">
        Chapter 10
       </a>
       explains that polymorphic types require you to follow the rule of five as well.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-111" class="calibre2">
     <span class="calibre" id="c09-sec-0037">
     </span>
     <h2 class="calibre6" id="head-2-111">
      MORE ABOUT MEMBER FUNCTIONS
     </h2>
     <p class="calibre13" id="c09-para-0157">
      C++ provides myriad choices for member functions. This section explains all the tricky details.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0038">
      </span>
      <h3 class="calibre27" id="head-3-191">
       static Member Functions
      </h3>
      <p class="calibre13">
       Member functions, like data members, sometimes apply to the class as a whole, not to each object. You can write
       <code class="calibre21">
        static
       </code>
       member functions as well as data members. As an example, consider the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class from
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       . It has two helper member functions:
       <code class="calibre21">
        stringToDouble()
       </code>
       and
       <code class="calibre21">
        doubleToString()
       </code>
       . These member functions don't access information about specific objects, so they could be
       <code class="calibre21">
        static
       </code>
       . Here is the class definition with these member functions
       <code class="calibre21">
        static
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0068"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">static std::string doubleToString(double value);</b></code>
<code class="calibre21">        <b class="calibre14">static double stringToDouble(std::string_view value);</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c09-para-0159">
       The implementations of these two member functions are identical to the previous implementations. You don't repeat the
       <code class="calibre21">
        static
       </code>
       keyword in front of the member function definitions. Note that
       <code class="calibre21">
        static
       </code>
       member functions are not called on a specific object, so they do not have a
       <code class="calibre21">
        this
       </code>
       pointer and are not executing for a specific object with access to its non-
       <code class="calibre21">
        static
       </code>
       members. In fact, a
       <code class="calibre21">
        static
       </code>
       member function is just like a regular function. The only difference is that it can access
       <code class="calibre21">
        private static
       </code>
       and
       <code class="calibre21">
        protected static
       </code>
       members of the class. Additionally, it can also access
       <code class="calibre21">
        private
       </code>
       and
       <code class="calibre21">
        protected
       </code>
       non-
       <code class="calibre21">
        static
       </code>
       members on objects of the same type, if those objects are made available to the
       <code class="calibre21">
        static
       </code>
       member function, for example, by passing in a reference or pointer to such an object as a parameter.
      </p>
      <p class="calibre13" id="c09-para-0160">
       You call a
       <code class="calibre21">
        static
       </code>
       member function just like a regular member function from within any member function of the class. Thus, the implementation of all the member functions in
       <code class="calibre21">
        SpreadsheetCell
       </code>
       can stay the same.
      </p>
      <p class="calibre13">
       <span aria-label="321" class="calibre20" epub:type="pagebreak" id="Page_321" role="doc-pagebreak">
       </span>
       Outside of the class, you need to qualify the
       <code class="calibre21">
        static
       </code>
       member function name with the class name using the scope resolution operator. Access control applies as usual. For example, if you have a class
       <code class="calibre21">
        Foo
       </code>
       with a
       <code class="calibre21">
        public static
       </code>
       member function called
       <code class="calibre21">
        bar()
       </code>
       , then you can call
       <code class="calibre21">
        bar()
       </code>
       from anywhere in the code as follows:
      </p>
      <pre class="calibre26" id="c09-code-0069"><code class="calibre21">Foo::bar();</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0163">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The example defining
          </i>
          <code class="calibre21">
           doubleToString()
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           stringToDouble()
          </code>
          <i class="calibre18">
           as
          </i>
          <code class="calibre21">
           private static
          </code>
          <i class="calibre18">
           member functions is just to demonstrate how you define and use
          </i>
          <code class="calibre21">
           static
          </code>
          <i class="calibre18">
           member functions. For this specific case, neither member function accesses any data from specific
          </i>
          <code class="calibre21">
           SpreadsheetCell
          </code>
          <i class="calibre18">
           instances. Thus, you can also define these helper functions outside of the
          </i>
          <code class="calibre21">
           SpreadsheetCell
          </code>
          <i class="calibre18">
           class in an unnamed namespace (see
           <a class="calibre5" href="c11.xhtml">
            Chapter 11
           </a>
           , “Modules, Header Files, and Miscellaneous Topics”) in the
          </i>
          <code class="calibre21">
           spreadsheet_cell
          </code>
          <i class="calibre18">
           module implementation file. See the downloadable source code for such an implementation.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0040">
      </span>
      <h3 class="calibre27" id="head-3-192">
       const Member Functions
      </h3>
      <p class="calibre13">
       A
       <code class="calibre21">
        const
       </code>
       object is an object whose value cannot be changed. If you have a
       <code class="calibre21">
        const
       </code>
       , reference to
       <code class="calibre21">
        const
       </code>
       , or pointer to a
       <code class="calibre21">
        const
       </code>
       object, the compiler does not let you call any member functions on that object unless those member functions guarantee that they won't change any data members. The way you guarantee that a member function won't change data members is to mark the member function itself with the
       <code class="calibre21">
        const
       </code>
       keyword. This is already done throughout
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       during the development of the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class. As a reminder, here is part of the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class with the member functions that don't change any data members marked as
       <code class="calibre21">
        const
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0070"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">double getValue() const;</b></code>
<code class="calibre21">        <b class="calibre14">std::string getString() const;</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        const
       </code>
       specification is part of the member function prototype and must accompany its definition as well:
      </p>
      <pre class="calibre26" id="c09-code-0071"><code class="calibre21"><b class="calibre14">double SpreadsheetCell::getValue() const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_value;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">string SpreadsheetCell::getString() const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return doubleToString(m_value);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0166">
       Marking a member function as
       <code class="calibre21">
        const
       </code>
       signs a contract with client code guaranteeing that you will not change the internal values of the object from within that member function. If you try to declare
       <span aria-label="322" class="calibre20" epub:type="pagebreak" id="Page_322" role="doc-pagebreak">
       </span>
       a member function
       <code class="calibre21">
        const
       </code>
       that actually modifies a data member, the compiler will complain.
       <code class="calibre21">
        const
       </code>
       member functions work by making it appear inside the member function that you have a reference-to-
       <code class="calibre21">
        const
       </code>
       to each data member. Thus, if you try to change a data member, the compiler will flag an error.
      </p>
      <p class="calibre13" id="c09-para-0167">
       You cannot declare a
       <code class="calibre21">
        static
       </code>
       member function
       <code class="calibre21">
        const
       </code>
       , because it is redundant. Static member functions do not work on a specific instance of the class, so it would be impossible for them to change internal values.
      </p>
      <p class="calibre13">
       You can call
       <code class="calibre21">
        const
       </code>
       and non-
       <code class="calibre21">
        const
       </code>
       member functions on a non-
       <code class="calibre21">
        const
       </code>
       object. However, you can only call
       <code class="calibre21">
        const
       </code>
       member functions on a
       <code class="calibre21">
        const
       </code>
       object. Here are some examples:
      </p>
      <pre class="calibre26" id="c09-code-0072"><code class="calibre21">SpreadsheetCell myCell { 5 };</code>
<code class="calibre21">println("{}", myCell.getValue());       <span class="color">// OK</span></code>
<code class="calibre21">myCell.setString("6");                  <span class="color">// OK</span></code>
<code class="calibre21"> </code>
<code class="calibre21">const SpreadsheetCell&amp; myCellConstRef { myCell };</code>
<code class="calibre21">println("{}", myCellConstRef.getValue()); <span class="color">// OK</span></code>
<code class="calibre21">myCellConstRef.setString("6");             <span class="color">// Compilation Error!</span></code></pre>
      <p class="calibre13" id="c09-para-0169">
       You should get into the habit of declaring
       <code class="calibre21">
        const
       </code>
       all member functions that don't modify the object so that you can use references to
       <code class="calibre21">
        const
       </code>
       objects in your program.
      </p>
      <p class="calibre13" id="c09-para-0170">
       Note that
       <code class="calibre21">
        const
       </code>
       objects can still be destroyed, and their destructor can be called. Nevertheless, destructors are not allowed to be declared
       <code class="calibre21">
        const
       </code>
       .
      </p>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0041">
       </span>
       <h4 class="calibre29" id="head-4-177">
        mutable Data Members
       </h4>
       <p class="calibre13">
        Sometimes you write a member function that is “logically”
        <code class="calibre21">
         const
        </code>
        but happens to change a data member of the object. This modification has no effect on any user-visible data, but is technically a change, so the compiler won't let you declare the member function
        <code class="calibre21">
         const
        </code>
        . For example, suppose that you want to profile your spreadsheet application to obtain information about how often data is being read. A crude way to do this would be to add a counter to the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class that counts each call to
        <code class="calibre21">
         getValue()
        </code>
        or
        <code class="calibre21">
         getString()
        </code>
        . Unfortunately, that makes those member functions non-
        <code class="calibre21">
         const
        </code>
        in the compiler's eyes, which is not what you intended. The solution is to make your new counter variable
        <code class="calibre21">
         mutable
        </code>
        , which tells the compiler that it's OK to change it in a
        <code class="calibre21">
         const
        </code>
        member function. Here is the new
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class definition:
       </p>
       <pre class="calibre26" id="c09-code-0073"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        double m_value { 0 };</code>
<code class="calibre21">        <b class="calibre14">mutable unsigned m_numAccesses { 0 };</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Here are the definitions for
        <code class="calibre21">
         getValue()
        </code>
        and
        <code class="calibre21">
         getString()
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0074"><code class="calibre21">double SpreadsheetCell::getValue() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">++m_numAccesses;</b></code>
<code class="calibre21">    return m_value;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="323" class="calibre20" epub:type="pagebreak" id="Page_323" role="doc-pagebreak"></span><code class="calibre21">string SpreadsheetCell::getString() const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">++m_numAccesses;</b></code>
<code class="calibre21">    return doubleToString(m_value);</code>
<code class="calibre21">}</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0042">
      </span>
      <h3 class="calibre27" id="head-3-193">
       Member Function Overloading
      </h3>
      <p class="calibre13">
       You've already noticed that you can write multiple constructors in a class, all of which have the same name. These constructors differ only in the number and/or types of their parameters. You can do the same thing for any member function or function in C++. Specifically, you can
       <i class="calibre18">
        overload
       </i>
       a function or member function name by using it for multiple functions, as long as the number and/or types of the parameters differ. For example, in the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class you can rename both
       <code class="calibre21">
        setString()
       </code>
       and
       <code class="calibre21">
        setValue()
       </code>
       to
       <code class="calibre21">
        set()
       </code>
       . The class definition now looks like this:
      </p>
      <pre class="calibre26" id="c09-code-0075"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">void set(double value);</b></code>
<code class="calibre21">        <b class="calibre14">void set(std::string_view value);</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c09-para-0174">
       The implementations of the
       <code class="calibre21">
        set()
       </code>
       member functions stay the same. When you write code to call
       <code class="calibre21">
        set()
       </code>
       , the compiler determines which instance to call based on the argument you pass: if you pass a
       <code class="calibre21">
        string_view
       </code>
       , the compiler calls the
       <code class="calibre21">
        string_view
       </code>
       instance; if you pass a
       <code class="calibre21">
        double
       </code>
       , the compiler calls the
       <code class="calibre21">
        double
       </code>
       instance. This is called
       <i class="calibre18">
        overload resolution
       </i>
       .
      </p>
      <p class="calibre13" id="c09-para-0175">
       You might be tempted to do the same thing for
       <code class="calibre21">
        getValue()
       </code>
       and
       <code class="calibre21">
        getString()
       </code>
       : rename each of them to
       <code class="calibre21">
        get()
       </code>
       . However, that does not work. C++ does not allow you to overload a member function name based only on the return type because in many cases it would be impossible for the compiler to determine which instance of the member function to call. For example, if the return value of the member function is not captured anywhere, the compiler has no way to tell which instance of the member function you are trying to call.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0043">
       </span>
       <h4 class="calibre29" id="head-4-178">
        Overloading Based on const
       </h4>
       <p class="calibre13" id="c09-para-0176">
        You can overload a member function based on
        <code class="calibre21">
         const
        </code>
        . That is, you can write two member functions with the same name and same parameters, one of which is declared
        <code class="calibre21">
         const
        </code>
        and one of which is not. The compiler calls the
        <code class="calibre21">
         const
        </code>
        member function if you have a
        <code class="calibre21">
         const
        </code>
        object and calls the non-
        <code class="calibre21">
         const
        </code>
        overload if you have a non-
        <code class="calibre21">
         const
        </code>
        object. Writing these two overloaded member functions could introduce code duplication, because, often, the implementations of the
        <code class="calibre21">
         const
        </code>
        and non-
        <code class="calibre21">
         const
        </code>
        overloads are identical. As you know, code duplication should be avoided as much as possible, even if it's just a few lines of code. Doing so follows the DRY (Don't Repeat Yourself) principle discussed in
        <a class="calibre5" href="c06.xhtml">
         Chapter 6
        </a>
        and makes future maintenance of the code easier. For example, imagine that in a few months or years you need to make a small change to duplicated code. When doing so, you need to remember to make the same change to all the places where the code has been duplicated.
       </p>
       <p class="calibre13" id="c09-para-0177">
        The next sections provide two solutions to avoid code duplication when writing such overloaded member functions.
       </p>
       <span aria-label="324" class="calibre20" epub:type="pagebreak" id="Page_324" role="doc-pagebreak">
       </span>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0044">
        </span>
        <h5 class="calibre35" id="head-5-70">
         Scott Meyers’ const_cast Pattern
        </h5>
        <p class="calibre13">
         To prevent code duplication, you can use the Scott Meyers's
         <code class="calibre21">
          const_cast()
         </code>
         pattern. For example, the
         <code class="calibre21">
          Spreadsheet
         </code>
         class has a member function called
         <code class="calibre21">
          getCellAt()
         </code>
         returning a reference-to-non-
         <code class="calibre21">
          const
         </code>
         to a
         <code class="calibre21">
          SpreadsheetCell
         </code>
         . You can add a
         <code class="calibre21">
          const
         </code>
         overload that returns a reference-to-
         <code class="calibre21">
          const
         </code>
         to a
         <code class="calibre21">
          SpreadsheetCell
         </code>
         as follows:
        </p>
        <pre class="calibre26" id="c09-code-0076"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y);</code>
<code class="calibre21">        <b class="calibre14">const SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y) const;</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         Scott Meyers’
         <code class="calibre21">
          const_cast()
         </code>
         pattern implements the
         <code class="calibre21">
          const
         </code>
         overload as you normally would and implements the non-
         <code class="calibre21">
          const
         </code>
         overload by forwarding the call to the
         <code class="calibre21">
          const
         </code>
         overload with the appropriate casts, as follows:
        </p>
        <pre class="calibre26" id="c09-code-0077"><code class="calibre21"><b class="calibre14">const SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y)</b></code>
<code class="calibre21"><b class="calibre14">{</b></code>
<code class="calibre21">    <b class="calibre14">return const_cast&lt;SpreadsheetCell&amp;&gt;(as_const(*this).getCellAt(x, y));</b></code>
<code class="calibre21"><b class="calibre14">}</b></code></pre>
        <p class="calibre13" id="c09-para-0180">
         The pattern first casts
         <code class="calibre21">
          *this
         </code>
         (a
         <code class="calibre21">
          Spreadsheet&amp;
         </code>
         ) to a
         <code class="calibre21">
          const Spreadsheet&amp;
         </code>
         using
         <code class="calibre21">
          std::as_const()
         </code>
         (defined in
         <code class="calibre21">
          &lt;utility&gt;
         </code>
         ). Next, you call the
         <code class="calibre21">
          const
         </code>
         overload of
         <code class="calibre21">
          getCellAt()
         </code>
         , which returns a
         <code class="calibre21">
          const SpreadsheetCell&amp;
         </code>
         . You then cast this to a non-
         <code class="calibre21">
          const SpreadsheetCell&amp;
         </code>
         with a
         <code class="calibre21">
          const_cast()
         </code>
         .
        </p>
        <p class="calibre13">
         With these two
         <code class="calibre21">
          getCellAt()
         </code>
         overloads, you can now call
         <code class="calibre21">
          getCellAt()
         </code>
         on
         <code class="calibre21">
          const
         </code>
         and non-
         <code class="calibre21">
          const Spreadsheet
         </code>
         objects:
        </p>
        <pre class="calibre26" id="c09-code-0078"><code class="calibre21">Spreadsheet sheet1 { 5, 6 };</code>
<code class="calibre21">SpreadsheetCell&amp; cell1 { sheet1.getCellAt(1, 1) };</code>
<code class="calibre21"> </code>
<code class="calibre21">const Spreadsheet sheet2 { 5, 6 };</code>
<code class="calibre21">const SpreadsheetCell&amp; cell2 { sheet2.getCellAt(1, 1) };</code></pre>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0045">
        </span>
        <h5 class="calibre35" id="head-5-71">
         Private Helper Member Function
        </h5>
        <p class="calibre13">
         Another option to avoid code duplication when implementing both
         <code class="calibre21">
          const
         </code>
         and non-
         <code class="calibre21">
          const
         </code>
         overloads is to have a
         <code class="calibre21">
          private const
         </code>
         helper member function with a non-
         <code class="calibre21">
          const
         </code>
         return type. The
         <code class="calibre21">
          const
         </code>
         and non-
         <code class="calibre21">
          const
         </code>
         overloaded member functions then both call this helper function. For example, for the
         <code class="calibre21">
          getCellAt()
         </code>
         overloads from the previous section, a
         <code class="calibre21">
          getCellAtHelper()
         </code>
         can be added as follows:
        </p>
        <pre class="calibre26" id="c09-code-0079"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y);</code>
<code class="calibre21">        const SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y) const;</code>
<span aria-label="325" class="calibre20" epub:type="pagebreak" id="Page_325" role="doc-pagebreak"></span><code class="calibre21">        <span class="color">// Code omitted for brevity.</span></code>
<code class="calibre21">    <b class="calibre14">private:</b></code>
<code class="calibre21">        <b class="calibre14">SpreadsheetCell&amp; getCellAtHelper(std::size_t x, std::size_t y) const;</b></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         And here are the implementations:
        </p>
        <pre class="calibre26" id="c09-code-0080"><code class="calibre21">SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">return getCellAtHelper(x, y);</b></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">const SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">return getCellAtHelper(x, y);</b></code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">SpreadsheetCell&amp; Spreadsheet::getCellAtHelper(size_t x, size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0046">
       </span>
       <h4 class="calibre29" id="head-4-179">
        Explicitly Deleting Overloads
       </h4>
       <p class="calibre13">
        Overloaded member functions can be explicitly deleted, which enables you to forbid calling a member function with particular arguments. For example, the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class has a member function
        <code class="calibre21">
         setValue(double)
        </code>
        that can be called as follows:
       </p>
       <pre class="calibre26" id="c09-code-0081"><code class="calibre21">SpreadsheetCell cell;</code>
<code class="calibre21">cell.setValue(1.23);</code>
<code class="calibre21">cell.setValue(123);</code></pre>
       <p class="calibre13">
        For the third line, the compiler converts the integer value (123) to a
        <code class="calibre21">
         double
        </code>
        and then calls
        <code class="calibre21">
         setValue(double)
        </code>
        . If, for some reason, you do not want
        <code class="calibre21">
         setValue()
        </code>
        to be called with integers, you can explicitly delete an integer overload of
        <code class="calibre21">
         setValue()
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0082"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void setValue(double value);</code>
<code class="calibre21">        <b class="calibre14">void setValue(int) = delete;</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c09-para-0186">
        With this change, an attempt to call
        <code class="calibre21">
         setValue()
        </code>
        with an integer will be flagged as an error by the compiler.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0047">
       </span>
       <h4 class="calibre29" id="head-4-180">
        Ref-Qualified Member Functions
       </h4>
       <p class="calibre13">
        Ordinary class member functions can be called on both non-temporary and temporary instances of a class. Suppose you have the following class that simply remembers the
        <code class="calibre21">
         string
        </code>
        passed as argument to the constructor:
       </p>
       <pre class="calibre26" id="c09-code-0083"><code class="calibre21">class TextHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<span aria-label="326" class="calibre20" epub:type="pagebreak" id="Page_326" role="doc-pagebreak"></span><code class="calibre21">        explicit TextHolder(string text) : m_text { move(text) } {}</code>
<code class="calibre21">        const string&amp; getText() const { return m_text; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_text;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Of course, there is no doubt that you can call the
        <code class="calibre21">
         getText()
        </code>
        member function on non-temporary instances of
        <code class="calibre21">
         TextHolder
        </code>
        . Here's an example:
       </p>
       <pre class="calibre26" id="c09-code-0084"><code class="calibre21">TextHolder textHolder { "Hello world!" };</code>
<code class="calibre21">println("{}", textHolder.getText());</code></pre>
       <p class="calibre13">
        However,
        <code class="calibre21">
         getText()
        </code>
        can also be called on temporary instances:
       </p>
       <pre class="calibre26" id="c09-code-0085"><code class="calibre21">println("{}", TextHolder{ "Hello world!" }.getText());</code></pre>
       <p class="calibre13" id="c09-para-0190">
        It is possible to explicitly specify on what kind of instances a certain member function can be called, be it temporary or non-temporary instances. This is done by adding a
        <i class="calibre18">
         ref-qualifier
        </i>
        to the member function. If a member function can only be called on non-temporary instances, a
        <code class="calibre21">
         &amp;
        </code>
        qualifier is added after the member function header. Similarly, if a member function can only be called on temporary instances, a
        <code class="calibre21">
         &amp;&amp;
        </code>
        qualifier is added.
       </p>
       <p class="calibre13">
        The following modified
        <code class="calibre21">
         TextHolder
        </code>
        class implements the
        <code class="calibre21">
         &amp;
        </code>
        qualified
        <code class="calibre21">
         getText()
        </code>
        by returning a reference-to-
        <code class="calibre21">
         const
        </code>
        to
        <code class="calibre21">
         m_text
        </code>
        . The
        <code class="calibre21">
         &amp;&amp;
        </code>
        qualified
        <code class="calibre21">
         getText()
        </code>
        , on the other hand, returns an rvalue reference to
        <code class="calibre21">
         m_text
        </code>
        so that
        <code class="calibre21">
         m_text
        </code>
        can be moved out of a
        <code class="calibre21">
         TextHolder
        </code>
        . This can be more efficient if you, for example, want to retrieve the text from a temporary
        <code class="calibre21">
         TextHolder
        </code>
        instance.
       </p>
       <pre class="calibre26" id="c09-code-0086"><code class="calibre21">class TextHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit TextHolder(string text) : m_text { move(text) } {}</code>
<code class="calibre21">        <b class="calibre14">const string&amp; getText() const &amp; { return m_text; }</b></code>
<code class="calibre21">        <b class="calibre14">string&amp;&amp; getText() &amp;&amp; { return move(m_text); }</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_text;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Suppose you have the following invocations:
       </p>
       <pre class="calibre26" id="c09-code-0087"><code class="calibre21">TextHolder textHolder { "Hello world!" };</code>
<code class="calibre21">println("{}", textHolder.getText());</code>
<code class="calibre21">println("{}", TextHolder{ "Hello world!" }.getText());</code></pre>
       <p class="calibre13" id="c09-para-0193">
        Then the first call to
        <code class="calibre21">
         getText()
        </code>
        calls the
        <code class="calibre21">
         &amp;
        </code>
        qualified overload, while the second invocation calls the
        <code class="calibre21">
         &amp;&amp;
        </code>
        qualified overload.
       </p>
       <p class="calibre13">
        A second example of using ref-qualifiers is to prevent a user from assigning a value to a temporary instance of a class. For instance, you can add an assignment operator to
        <code class="calibre21">
         TextHolder
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0088"><code class="calibre21">class TextHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">TextHolder&amp; operator=(const string&amp; rhs) { m_text = rhs; return *this; }</b></code>
<code class="calibre21">    <span class="color">// Remainder of the class definition omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="327" class="calibre20" epub:type="pagebreak" id="Page_327" role="doc-pagebreak">
        </span>
        Once such an assignment operator is added to
        <code class="calibre21">
         TextHolder
        </code>
        , assigning a new value to a temporary instance of
        <code class="calibre21">
         TextHolder
        </code>
        , as shown in the next code snippet, does not make much sense, as the object will cease to exist soon:
       </p>
       <pre class="calibre26" id="c09-code-0089"><code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">TextHolder makeTextHolder() { return TextHolder { "Hello World!" }; }</b></code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">makeTextHolder() = "Pointless!";</b> <span class="color">// Pointless, object is a temporary.</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Such pointless operations can be prevented by ref-qualifying the assignment operator to only work on lvalues:
       </p>
       <pre class="calibre26" id="c09-code-0090"><code class="calibre21">TextHolder&amp; operator=(const string&amp; rhs) <b class="calibre14">&amp;</b> { m_text = rhs; return *this; }</code></pre>
       <p class="calibre13">
        With this assignment operator, the earlier "Pointless!" statement in
        <code class="calibre21">
         main()
        </code>
        fails to compile. You can now only assign values to lvalues:
       </p>
       <pre class="calibre26" id="c09-code-0091"><code class="calibre21">auto text { makeTextHolder() };</code>
<code class="calibre21">text = "Ok";</code></pre>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0048">
        </span>
        <h5 class="calibre35" id="head-5-72">
         <img alt="C++23" class="calibre15" src="images/icon1.png"/>
         Ref-Qualification Using Explicit Object Parameters
        </h5>
        <p class="calibre13">
         As
         <a class="calibre5" href="c08.xhtml">
          Chapter 8
         </a>
         explains, C++23 introduces the concept of explicit object parameters. This allows you to rewrite the ref-qualified member functions from the previous
         <code class="calibre21">
          TextHolder
         </code>
         class using a slightly different syntax:
        </p>
        <pre class="calibre26" id="c09-code-0092"><code class="calibre21">class TextHolder</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        const string&amp; getText(<b class="calibre14">this const TextHolder&amp; self</b>) { return <b class="calibre14">self.</b>m_text; }</code>
<code class="calibre21">        string&amp;&amp; getText(<b class="calibre14">this TextHolder&amp;&amp; self</b>) { return move(<b class="calibre14">self.</b>m_text); }</code>
<code class="calibre21"> </code>
<code class="calibre21">        TextHolder&amp; operator=(<b class="calibre14">this TextHolder&amp; self</b>, const string&amp; rhs)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            <b class="calibre14">self.</b>m_text = rhs;</code>
<code class="calibre21">            return <b class="calibre14">self</b>;</code>
<code class="calibre21">        }</code>
<code class="calibre21">    <span class="color">// Remainder of the class definition omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
        <p class="calibre13" id="c09-para-0200">
         This is certainly more verbose than the syntax used in the previous section, but it makes the ref-qualification more obvious. In the previous section, there's just an
         <code class="calibre21">
          &amp;
         </code>
         or
         <code class="calibre21">
          &amp;&amp;
         </code>
         at the end of the member function signature, but this is easily overlooked, e.g., when a colleague reviews your code.
        </p>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0049">
      </span>
      <h3 class="calibre27" id="head-3-194">
       Inline Member Functions
      </h3>
      <p class="calibre13" id="c09-para-0201">
       C++ gives you the ability to recommend to the compiler that a call to a function should not be implemented in the generated code as a call to a separate block of code. Instead, the compiler should insert the function's body directly into the code where the function is called. This process is called
       <i class="calibre18">
        inlining
       </i>
       , and functions that want this behavior are called
       <i class="calibre18">
        inline functions
       </i>
       .
      </p>
      <p class="calibre13">
       <span aria-label="328" class="calibre20" epub:type="pagebreak" id="Page_328" role="doc-pagebreak">
       </span>
       You can specify an inline member function by placing the
       <code class="calibre21">
        inline
       </code>
       keyword in front of its name in the member function definition. For example, you might want to make the accessor member functions of the
       <code class="calibre21">
        SpreadsheetCell
       </code>
       class
       <code class="calibre21">
        inline
       </code>
       , in which case you would define them like this:
      </p>
      <pre class="calibre26" id="c09-code-0093"><code class="calibre21"><b class="calibre14">inline double SpreadsheetCell::getValue() const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    ++m_numAccesses;</code>
<code class="calibre21">    return m_value;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">inline std::string SpreadsheetCell::getString() const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    ++m_numAccesses;</code>
<code class="calibre21">    return doubleToString(m_value);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0203">
       This gives a hint to the compiler to replace calls to
       <code class="calibre21">
        getValue()
       </code>
       and
       <code class="calibre21">
        getString()
       </code>
       with the actual member function's body instead of generating code to make a function call. Note that the
       <code class="calibre21">
        inline
       </code>
       keyword is just a hint for the compiler. The compiler can ignore it if it thinks it would hurt performance.
      </p>
      <p class="calibre13">
       There is one caveat: definitions of
       <code class="calibre21">
        inline
       </code>
       functions should be available in every source file in which they are called. That makes sense if you think about it: how can the compiler substitute the function's body if it can't see the function definition? Thus, if you write
       <code class="calibre21">
        inline
       </code>
       member functions, you should place the definitions of such member functions in the same file as the definition of the class to which the member functions belong.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0205">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Advanced C++ compilers do not require you to put definitions of
          </i>
          <code class="calibre21">
           inline
          </code>
          <i class="calibre18">
           member functions in the same file as the class definition. For example, Microsoft Visual C++ supports Link-Time Code Generation (LTCG), which automatically inlines small function bodies, even if they are not declared as
          </i>
          <code class="calibre21">
           inline
          </code>
          <i class="calibre18">
           and even if they are not defined in the same file as the class definition. GCC and Clang have similar features.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Outside of C++ modules, if the definition of a member function is placed directly in the class definition, that member function implicitly is marked as inline, even without using the
       <code class="calibre21">
        inline
       </code>
       keyword. With classes exported from modules, this is not the case. If you want such member functions to be inline, you need to mark them with the
       <code class="calibre21">
        inline
       </code>
       keyword. Here's an example:
      </p>
      <pre class="calibre26" id="c09-code-0094"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">inline double getValue() const { ++m_numAccesses; return m_value; }</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        <b class="calibre14">inline std::string getString() const</b></code>
<code class="calibre21">        <b class="calibre14">{</b></code>
<code class="calibre21">            <b class="calibre14">++m_numAccesses;</b></code>
<span aria-label="329" class="calibre20" epub:type="pagebreak" id="Page_329" role="doc-pagebreak"></span><code class="calibre21">            <b class="calibre14">return doubleToString(m_value);</b></code>
<code class="calibre21">        <b class="calibre14">}</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0208">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           If you single-step with a debugger on a function call that is inlined, some advanced C++ debuggers will jump to the actual source code of the inline function, giving you the illusion of a function call while in reality, the code is inlined
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c09-para-0209">
       Many C++ programmers discover the
       <code class="calibre21">
        inline
       </code>
       function syntax and employ it without understanding the ramifications. Marking a function as
       <code class="calibre21">
        inline
       </code>
       only gives a hint to the compiler. Compilers will only inline the simplest functions. If you define an
       <code class="calibre21">
        inline
       </code>
       function that the compiler doesn't want to inline, it will silently ignore the hint. Modern compilers will take metrics such as code bloat into account before deciding to inline a function, and they will not inline anything that is not cost-effective.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0052">
      </span>
      <h3 class="calibre27" id="head-3-195">
       Default Arguments
      </h3>
      <p class="calibre13">
       A feature similar to function overloading in C++ is
       <i class="calibre18">
        default arguments
       </i>
       . You can specify defaults for function parameters in the prototype. If the user provides arguments for those parameters, the default values are ignored. If the user omits those arguments, the default values are used. There is a limitation, though: you can only provide defaults for a continuous list of parameters starting from the
       <i class="calibre18">
        rightmost parameter
       </i>
       . Otherwise, the compiler will not be able to match missing arguments to default arguments. Default arguments can be used in functions, member functions, and constructors. For example, you can assign default values for the width and height in the
       <code class="calibre21">
        Spreadsheet
       </code>
       constructor as follows:
      </p>
      <pre class="calibre26" id="c09-code-0095"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">explicit Spreadsheet(std::size_t width = 100, std::size_t height = 100);</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c09-para-0211">
       The implementation of the
       <code class="calibre21">
        Spreadsheet
       </code>
       constructor stays the same. Note that you specify the default arguments only in the function declaration, but not in the definition.
      </p>
      <p class="calibre13">
       Now you can call the
       <code class="calibre21">
        Spreadsheet
       </code>
       constructor with zero, one, or two arguments even though there is only one non-copy constructor:
      </p>
      <pre class="calibre26" id="c09-code-0096"><code class="calibre21">Spreadsheet s1;</code>
<code class="calibre21">Spreadsheet s2 { 5 };</code>
<code class="calibre21">Spreadsheet s3 { 5, 6 };</code></pre>
      <p class="calibre13">
       A constructor with defaults for all its parameters can function as a default constructor. That is, you can construct an object of that class without specifying any arguments. If you try to declare both a default constructor and a multi-argument constructor with defaults for all its parameters, the
       <span aria-label="330" class="calibre20" epub:type="pagebreak" id="Page_330" role="doc-pagebreak">
       </span>
       compiler will complain because it won't know which constructor to call if you don't specify any arguments.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0214">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Anything you can do with default arguments, you can do with function overloading. You could write three different constructors, each of which takes a different number of arguments. However, default arguments allow you to write just one constructor that can take three different number of arguments. You should use the mechanism with which you are most comfortable
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-112" class="calibre2">
     <span class="calibre" id="c09-sec-0054">
     </span>
     <h2 class="calibre6" id="head-2-112">
      CONSTEXPR AND CONSTEVAL
     </h2>
     <p class="calibre13" id="c09-para-0215">
      In modern C++, it's possible to easily perform computations at compile time instead of at run time. This improves the run-time performance of your code. Two important keywords are used to accomplish this:
      <code class="calibre21">
       constexpr
      </code>
      and
      <code class="calibre21">
       consteval
      </code>
      .
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0055">
      </span>
      <h3 class="calibre27" id="head-3-196">
       The constexpr Keyword
      </h3>
      <p class="calibre13">
       C++ always had the notion of
       <i class="calibre18">
        constant expressions
       </i>
       , which are expressions evaluated at compile time. In some circumstances, constant expressions are a requirement. For example, when defining an array, the size of the array needs to be a constant expression. Because of this restriction, the following piece of code is not valid in C++:
      </p>
      <pre class="calibre26" id="c09-code-0097"><code class="calibre21">const int getArraySize() { return 32; }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    int myArray[getArraySize()];    <span class="color">// ERROR: Invalid in C++</span></code>
<code class="calibre21">    println("Size of array = {}", size(myArray));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Using the
       <code class="calibre21">
        constexpr
       </code>
       keyword,
       <code class="calibre21">
        getArraySize()
       </code>
       can be redefined to allow it to be called from within a constant expression:
      </p>
      <pre class="calibre26" id="c09-code-0098"><code class="calibre21"><b class="calibre14">constexpr int getArraySize() { return 32; }</b></code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    int myArray[getArraySize()];    <span class="color">// OK</span></code>
<code class="calibre21">    println("Size of array = {}", size(myArray));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       You can even do something like this:
      </p>
      <pre class="calibre26" id="c09-code-0099"><code class="calibre21">int myArray[getArraySize() + 1];    <span class="color">// OK</span></code></pre>
      <p class="calibre13" id="c09-para-0219">
       Constant expressions can only use
       <code class="calibre21">
        constexpr
       </code>
       entities and integer, Boolean, character, and enumeration constants.
      </p>
      <p class="calibre13">
       <span aria-label="331" class="calibre20" epub:type="pagebreak" id="Page_331" role="doc-pagebreak">
       </span>
       Declaring a function as
       <code class="calibre21">
        constexpr
       </code>
       imposes restrictions on what the function can do because the compiler has to be able to evaluate the function at compile time. For example, a
       <code class="calibre21">
        constexpr
       </code>
       function is not allowed to have any side effects, nor can it let any exceptions escape the function. Throwing exceptions and catching them in
       <code class="calibre21">
        try
       </code>
       blocks inside the function is allowed. A
       <code class="calibre21">
        constexpr
       </code>
       function is allowed to unconditionally call other
       <code class="calibre21">
        constexpr
       </code>
       functions. It is also allowed to call non-
       <code class="calibre21">
        constexpr
       </code>
       functions, but only if those calls are triggered during evaluation at run time, and not during constant evaluation. For example:
      </p>
      <pre class="calibre26" id="c09-code-0100"><code class="calibre21">void log(string_view message) { print("{}", message); }</code>
<code class="calibre21"> </code>
<code class="calibre21">constexpr int computeSomething(bool someFlag)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (someFlag) {</code>
<code class="calibre21">        log("someFlag is true");</code>
<code class="calibre21">        return 42;</code>
<code class="calibre21">    }</code>
<code class="calibre21">    else { return 84; }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        computeSomething()
       </code>
       function is
       <code class="calibre21">
        constexpr
       </code>
       and includes a call to
       <code class="calibre21">
        log()
       </code>
       , which is non-
       <code class="calibre21">
        constexpr
       </code>
       , but that call is executed only when
       <code class="calibre21">
        someFlag
       </code>
       is
       <code class="calibre21">
        true
       </code>
       . As long as
       <code class="calibre21">
        computeSomething()
       </code>
       is called with
       <code class="calibre21">
        someFlag
       </code>
       set to
       <code class="calibre21">
        false
       </code>
       , it can be called within a constant expression, for example:
      </p>
      <pre class="calibre26" id="c09-code-0101"><code class="calibre21">constexpr auto value1 { computeSomething(false) };</code></pre>
      <p class="calibre13">
       Calling the function with
       <code class="calibre21">
        someFlag
       </code>
       set to
       <code class="calibre21">
        true
       </code>
       cannot be done in a constant expression. The following does not compile:
      </p>
      <pre class="calibre26" id="c09-code-0102"><code class="calibre21">constexpr auto value2 { computeSomething(true) };</code></pre>
      <p class="calibre13">
       The following works fine, as the evaluation now happens at run time instead of at compile time:
      </p>
      <pre class="calibre26" id="c09-code-0103"><code class="calibre21">const auto value3 { computeSomething(true) };</code></pre>
      <p class="calibre13" id="c09-para-0224">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       C++23 relaxes the restrictions for
       <code class="calibre21">
        constexpr
       </code>
       functions a bit:
       <code class="calibre21">
        goto
       </code>
       statements, labels (besides
       <code class="calibre21">
        case
       </code>
       labels), and
       <code class="calibre21">
        static
       </code>
       and
       <code class="calibre21">
        static constexpr
       </code>
       variables are now allowed in
       <code class="calibre21">
        constexpr
       </code>
       functions, but were not allowed before.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0056">
      </span>
      <h3 class="calibre27" id="head-3-197">
       The consteval Keyword
      </h3>
      <p class="calibre13">
       The
       <code class="calibre21">
        constexpr
       </code>
       keyword specifies that a function
       <i class="calibre18">
        could
       </i>
       be executed at compile time, but it
       <i class="calibre18">
        does not guarantee
       </i>
       compile-time execution. Take the following
       <code class="calibre21">
        constexpr
       </code>
       function:
      </p>
      <pre class="calibre26" id="c09-code-0104"><code class="calibre21">constexpr double inchToMm(double inch) { return inch * 25.4; }</code></pre>
      <p class="calibre13">
       If called as follows, the function is evaluated at compile time as desired:
      </p>
      <pre class="calibre26" id="c09-code-0105"><code class="calibre21">constexpr double const_inch { 6.0 };</code>
<code class="calibre21">constexpr double mm1 { inchToMm(const_inch) };    <span class="color">// at compile time</span></code></pre>
      <p class="calibre13">
       However, if called as follows, the function is not evaluated at compile time, but at run time!
      </p>
      <pre class="calibre26" id="c09-code-0106"><code class="calibre21">double dynamic_inch { 8.0 };</code>
<code class="calibre21">double mm2 { inchToMm(dynamic_inch) };  <span class="color">// at run time</span></code></pre>
      <p class="calibre13">
       <span aria-label="332" class="calibre20" epub:type="pagebreak" id="Page_332" role="doc-pagebreak">
       </span>
       If you really want the guarantee that a function is always evaluated at compile time, you need to use the
       <code class="calibre21">
        consteval
       </code>
       keyword to turn a function into an
       <i class="calibre18">
        immediate function
       </i>
       . The
       <code class="calibre21">
        inchToMm()
       </code>
       function can be changed as follows:
      </p>
      <pre class="calibre26" id="c09-code-0107"><code class="calibre21"><b class="calibre14">consteval</b> double inchToMm(double inch) { return inch * 25.4; }</code></pre>
      <p class="calibre13" id="c09-para-0229">
       Now, the call to
       <code class="calibre21">
        inchToMm()
       </code>
       in the definition of
       <code class="calibre21">
        mm1
       </code>
       earlier still compiles fine and results in compile-time evaluation. However, the call in the definition of
       <code class="calibre21">
        mm2
       </code>
       now results in a compilation error because it cannot be evaluated at compile time.
      </p>
      <p class="calibre13">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       An immediate function can be called only during constant evaluation. For example, suppose you have the following immediate function:
      </p>
      <pre class="calibre26" id="c09-code-0108"><code class="calibre21">consteval int f(int i) { return i; }</code></pre>
      <p class="calibre13">
       This immediate function can be called from a
       <code class="calibre21">
        constexpr
       </code>
       function, but only when the
       <code class="calibre21">
        constexpr
       </code>
       function is being executed during constant evaluation. For example, the following function uses an
       <code class="calibre21">
        if consteval
       </code>
       statement to check if constant evaluation is happening in which case it can call
       <code class="calibre21">
        f()
       </code>
       . In the
       <code class="calibre21">
        else
       </code>
       branch,
       <code class="calibre21">
        f()
       </code>
       cannot be called.
      </p>
      <pre class="calibre26" id="c09-code-0109"><code class="calibre21">constexpr int g(int i)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if consteval { return f(i); }</code>
<code class="calibre21">    else         { return 42; }</code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0057">
      </span>
      <h3 class="calibre27" id="head-3-198">
       constexpr and consteval Classes
      </h3>
      <p class="calibre13" id="c09-para-0233">
       By defining a
       <code class="calibre21">
        constexpr
       </code>
       or
       <code class="calibre21">
        consteval
       </code>
       constructor, you can create constant-expression variables of user-defined types. Just as
       <code class="calibre21">
        constexpr
       </code>
       functions,
       <code class="calibre21">
        constexpr
       </code>
       classes may or may not be evaluated at compile time, while
       <code class="calibre21">
        consteval
       </code>
       classes are guaranteed to be evaluated at compile time.
      </p>
      <p class="calibre13">
       The following
       <code class="calibre21">
        Matrix
       </code>
       class defines a
       <code class="calibre21">
        constexpr
       </code>
       constructor. It also defines a
       <code class="calibre21">
        constexpr getSize()
       </code>
       member function that is performing some calculation.
      </p>
      <pre class="calibre26" id="c09-code-0110"><code class="calibre21">class Matrix</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Matrix() = default; <span class="color">// Implicitly constexpr</span></code>
<code class="calibre21"> </code>
<code class="calibre21">        constexpr explicit Matrix(unsigned rows, unsigned columns)</code>
<code class="calibre21">            : m_rows { rows }, m_columns { columns } { }</code>
<code class="calibre21"> </code>
<code class="calibre21">        constexpr unsigned getSize() const { return m_rows * m_columns; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        unsigned m_rows { 0 }, m_columns { 0 };</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       Using this class to declare
       <code class="calibre21">
        constexpr
       </code>
       objects is straightforward:
      </p>
      <pre class="calibre26" id="c09-code-0111"><code class="calibre21">constexpr Matrix matrix { 8, 2 };</code>
<code class="calibre21">constexpr Matrix matrixDefault;</code></pre>
      <p class="calibre13">
       <span aria-label="333" class="calibre20" epub:type="pagebreak" id="Page_333" role="doc-pagebreak">
       </span>
       Such a
       <code class="calibre21">
        constexpr
       </code>
       object can now be used, e.g., to create an array big enough to store the matrix in linear form:
      </p>
      <pre class="calibre26" id="c09-code-0112"><code class="calibre21">int linearizedMatrix[<b class="calibre14">matrix.getSize()</b>];    <span class="color">// OK</span></code></pre>
      <p class="calibre13" id="c09-para-0237">
       Compiler-generated (either implicitly or explicitly using
       <code class="calibre21">
        =default
       </code>
       ) member functions, such as default constructors, destructors, assignment operators, and so on, are automatically
       <code class="calibre21">
        constexpr
       </code>
       unless the class contains data members where those member functions are not
       <code class="calibre21">
        constexpr
       </code>
       .
      </p>
      <p class="calibre13">
       The definition of
       <code class="calibre21">
        constexpr
       </code>
       and
       <code class="calibre21">
        consteval
       </code>
       member functions must be available for the compiler so they can be evaluated at compile time. This means that if the class is defined in a module, such member functions must be defined in the module interface file, not in a module implementation file.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0239">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Several classes from the Standard Library are
          </i>
          <code class="calibre21">
           constexpr
          </code>
          <i class="calibre18">
           and so can be used within other
          </i>
          <code class="calibre21">
           constexpr
          </code>
          <i class="calibre18">
           functions and classes. Examples are
          </i>
          <code class="calibre21">
           std::vector
          </code>
          <i class="calibre18">
           (
           <a class="calibre5" href="c01_split_000.xhtml">
            Chapter 1
           </a>
           ),
          </i>
          <code class="calibre21">
           optional
          </code>
          <i class="calibre18">
           (
           <a class="calibre5" href="c01_split_000.xhtml">
            Chapter 1
           </a>
           ),
          </i>
          <code class="calibre21">
           string
          </code>
          <i class="calibre18">
           (
           <a class="calibre5" href="c02.xhtml">
            Chapter 2
           </a>
           , “Working with Strings and String Views”),
          </i>
          <code class="calibre21">
           unique_ptr
          </code>
          <i class="calibre18">
           (
           <a class="calibre5" href="c07.xhtml">
            Chapter 7
           </a>
           , since C++23),
          </i>
          <code class="calibre21">
           bitset
          </code>
          <i class="calibre18">
           (
           <a class="calibre5" href="c18_split_000.xhtml">
            Chapter 18
           </a>
           , “Standard Library Containers”), and
          </i>
          <code class="calibre21">
           variant
          </code>
          <i class="calibre18">
           (
           <a class="calibre5" href="c24.xhtml">
            Chapter 24
           </a>
           , “Additional Vocabulary Types”).
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-113" class="calibre2">
     <span class="calibre" id="c09-sec-0059">
     </span>
     <h2 class="calibre6" id="head-2-113">
      DIFFERENT KINDS OF DATA MEMBERS
     </h2>
     <p class="calibre13" id="c09-para-0240">
      C++ gives you many choices for data members. In addition to declaring simple data members in your classes, you can create
      <code class="calibre21">
       static
      </code>
      data members that all objects of the class share,
      <code class="calibre21">
       const
      </code>
      members, reference members, reference-to-
      <code class="calibre21">
       const
      </code>
      members, and more. This section explains the intricacies of these different kinds of data members.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0060">
      </span>
      <h3 class="calibre27" id="head-3-199">
       static Data Members
      </h3>
      <p class="calibre13">
       Sometimes giving each object of a class a copy of a variable is overkill or won't work. The data member might be specific to the class, but not appropriate for each object to have its own copy. For example, you might want to give each spreadsheet a unique numerical identifier. You would need a counter that starts at 0 from which each new object could obtain its ID. This spreadsheet counter really belongs to the
       <code class="calibre21">
        Spreadsheet
       </code>
       class, but it doesn't make sense for each
       <code class="calibre21">
        Spreadsheet
       </code>
       object to have a copy of it, because you would have to keep all the counters synchronized somehow. C++ provides a solution with
       <i class="calibre18">
        static data members
       </i>
       . A
       <code class="calibre21">
        static
       </code>
       data member is a data member associated with a class instead of an object. You can think of
       <code class="calibre21">
        static
       </code>
       data members as global variables specific to a class. Here is the
       <code class="calibre21">
        Spreadsheet
       </code>
       class definition, including the new
       <code class="calibre21">
        static
       </code>
       counter data member:
      </p>
      <pre class="calibre26" id="c09-code-0113"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">static std::size_t ms_counter;</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       In addition to listing
       <code class="calibre21">
        static
       </code>
       class members in the class definition, you will have to allocate space for them in a source file, usually the source file in which you place your class member function
       <span aria-label="334" class="calibre20" epub:type="pagebreak" id="Page_334" role="doc-pagebreak">
       </span>
       definitions. You can initialize them at the same time, but note that unlike normal variables and data members, they are initialized to 0 by default. Static pointers are initialized to
       <code class="calibre21">
        nullptr
       </code>
       . Here is the code to allocate space for, and zero-initialize,
       <code class="calibre21">
        ms_counter
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0114"><code class="calibre21">size_t Spreadsheet::ms_counter;</code></pre>
      <p class="calibre13">
       Static data members are zero-initialized by default, but if you want, you can explicitly initialize them to 0 as follows:
      </p>
      <pre class="calibre26" id="c09-code-0115"><code class="calibre21">size_t Spreadsheet::ms_counter { 0 };</code></pre>
      <p class="calibre13" id="c09-para-0244">
       This code appears outside of any function or member function bodies. It's almost like declaring a global variable, except that the
       <code class="calibre21">
        Spreadsheet::
       </code>
       scope resolution specifies that it's part of the
       <code class="calibre21">
        Spreadsheet
       </code>
       class.
      </p>
      <p class="calibre13" id="c09-para-0245">
       Just as for normal data members, access control specifiers apply to
       <code class="calibre21">
        static
       </code>
       data members as well. You could make the
       <code class="calibre21">
        ms_counter
       </code>
       data member
       <code class="calibre21">
        public
       </code>
       , but, as you already know, it's not recommended to have
       <code class="calibre21">
        public
       </code>
       data members (
       <code class="calibre21">
        const static
       </code>
       data members discussed in an upcoming section are an exception). You should grant access to data members through
       <code class="calibre21">
        public
       </code>
       getters and setters. If you want to grant access to
       <code class="calibre21">
        static
       </code>
       data members, you can provide
       <code class="calibre21">
        public static
       </code>
       get/set member functions.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0061">
       </span>
       <h4 class="calibre29" id="head-4-181">
        Inline Variables
       </h4>
       <p class="calibre13">
        You can declare your static data members as
        <i class="calibre18">
         inline
        </i>
        . The benefit of this is that you do not have to allocate space for them in a source file. Here's an example:
       </p>
       <pre class="calibre26" id="c09-code-0116"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">static inline std::size_t ms_counter { 0 };</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        Note the
        <code class="calibre21">
         inline
        </code>
        keyword. With this class definition, the following line can be removed from the source file:
       </p>
       <pre class="calibre26" id="c09-code-0117"><code class="calibre21">size_t Spreadsheet::ms_counter;</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0062">
       </span>
       <h4 class="calibre29" id="head-4-182">
        Accessing static Data Members from within Class Member Functions
       </h4>
       <p class="calibre13">
        You can use
        <code class="calibre21">
         static
        </code>
        data members as if they were regular data members from within class member functions. For example, you might want to create an
        <code class="calibre21">
         m_id
        </code>
        data member for the
        <code class="calibre21">
         Spreadsheet
        </code>
        class and initialize it from
        <code class="calibre21">
         ms_counter
        </code>
        in the
        <code class="calibre21">
         Spreadsheet
        </code>
        constructor. Here is the
        <code class="calibre21">
         Spreadsheet
        </code>
        class definition with an
        <code class="calibre21">
         m_id
        </code>
        member:
       </p>
       <pre class="calibre26" id="c09-code-0118"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">std::size_t getId() const;</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        static inline std::size_t ms_counter { 0 };</code>
<code class="calibre21">        <b class="calibre14">std::size_t m_id { 0 };</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="335" class="calibre20" epub:type="pagebreak" id="Page_335" role="doc-pagebreak">
        </span>
        Here is an implementation of the
        <code class="calibre21">
         Spreadsheet
        </code>
        constructor that assigns the initial ID:
       </p>
       <pre class="calibre26" id="c09-code-0119"><code class="calibre21">Spreadsheet::Spreadsheet(size_t width, size_t height)</code>
<code class="calibre21">    <b class="calibre14">: m_id { ms_counter++ }</b>, m_width { width }, m_height { height }</code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0250">
        As you can see, the constructor can access
        <code class="calibre21">
         ms_counter
        </code>
        as if it were a normal member. The copy constructor should also assign a new ID. This is handled automatically because the
        <code class="calibre21">
         Spreadsheet
        </code>
        copy constructor delegates to the non-copy constructor, which creates the new ID.
       </p>
       <p class="calibre13">
        For this example, assume that once an ID is assigned to an object, it never changes. So, you should not copy the ID in the copy assignment operator. Thus, it's recommended to make
        <code class="calibre21">
         m_id
        </code>
        a
        <code class="calibre21">
         const
        </code>
        data member:
       </p>
       <pre class="calibre26" id="c09-code-0120"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">const std::size_t m_id { 0 };</b></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c09-para-0252">
        Since
        <code class="calibre21">
         const
        </code>
        data members cannot be changed once created, it's, for example, not possible to initialize them inside the body of a constructor. Such data members must be initialized either directly inside the class definition or in the ctor-initializer of a constructor. This also means you cannot assign new values to such data members in an assignment operator. This is not a problem for
        <code class="calibre21">
         m_id
        </code>
        , because once a
        <code class="calibre21">
         Spreadsheet
        </code>
        has an ID, it'll never change. However, depending on your use case, if this makes your class unassignable, the assignment operator is typically explicitly deleted.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0063">
      </span>
      <h3 class="calibre27" id="head-3-200">
       constexpr static Data Members
      </h3>
      <p class="calibre13">
       Data members in your class can be declared
       <code class="calibre21">
        const
       </code>
       or
       <code class="calibre21">
        constexpr
       </code>
       , meaning they can't be changed after they are created and initialized. You should use
       <code class="calibre21">
        static constexpr
       </code>
       (or
       <code class="calibre21">
        constexpr static
       </code>
       ) data members in place of global constants when the constants apply only to the class, also called
       <i class="calibre18">
        class constants
       </i>
       .
       <code class="calibre21">
        static constexpr
       </code>
       data members of integral types and enumerations can be defined and initialized inside the class definition even without making them inline variables. For example, you might want to specify a maximum height and width for spreadsheets. If the user tries to construct a spreadsheet with a greater height or width than the maximum, the maximum is used instead. You can make the maximum height and width
       <code class="calibre21">
        static constexpr
       </code>
       members of the
       <code class="calibre21">
        Spreadsheet
       </code>
       class:
      </p>
      <pre class="calibre26" id="c09-code-0121"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">static constexpr std::size_t MaxHeight { 100 };</b></code>
<code class="calibre21">        <b class="calibre14">static constexpr std::size_t MaxWidth { 100 };</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       You can use these new constants in your constructor as follows:
      </p>
      <pre class="calibre26" id="c09-code-0122"><code class="calibre21">Spreadsheet::Spreadsheet(size_t width, size_t height)</code>
<code class="calibre21">    : m_id { ms_counter++ }</code>
<span aria-label="336" class="calibre20" epub:type="pagebreak" id="Page_336" role="doc-pagebreak"></span><code class="calibre21">    <b class="calibre14">, m_width { std::min(width, MaxWidth) }</b> <span class="color">// std::min() defined in &lt;algorithm&gt;</span></code>
<code class="calibre21">    <b class="calibre14">, m_height { std::min(height, MaxHeight) }</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">}</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0256">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Instead of automatically clamping the width and height to their maximum, you could also decide to throw an exception when the width or height exceed their maximum. However, the destructor will not be called when you throw an exception from a constructor, so you need to be careful with this. This is further explained in
          </i>
          <a class="calibre5" href="c14.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           14
          </a>
          <i class="calibre18">
           , which discusses error handling in detail
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       Such constants can also be used as default values for parameters. Remember that you can only give default values for a continuous set of parameters starting with the rightmost parameter. Here is an example:
      </p>
      <pre class="calibre26" id="c09-code-0123"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Spreadsheet(</code>
<code class="calibre21">            std::size_t width = MaxWidth, std::size_t height = MaxHeight);</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0065">
       </span>
       <h4 class="calibre29" id="head-4-183">
        Accessing static Data Members from Outside Class Member Functions
       </h4>
       <p class="calibre13">
        As mentioned earlier, access control specifiers apply to
        <code class="calibre21">
         static
        </code>
        data members:
        <code class="calibre21">
         MaxWidth
        </code>
        and
        <code class="calibre21">
         MaxHeight
        </code>
        are
        <code class="calibre21">
         public
        </code>
        , so they can be accessed from outside class member functions by specifying that the variable is part of the
        <code class="calibre21">
         Spreadsheet
        </code>
        class using the
        <code class="calibre21">
         ::
        </code>
        scope resolution operator. For example:
       </p>
       <pre class="calibre26" id="c09-code-0124"><code class="calibre21">println("Maximum height is: {}", <b class="calibre14">Spreadsheet::MaxHeight</b>);</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0066">
      </span>
      <h3 class="calibre27" id="head-3-201">
       Reference Data Members
      </h3>
      <p class="calibre13">
       <code class="calibre21">
        Spreadsheet
       </code>
       s and
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s are great, but they don't make a useful application by themselves. You need code to control the entire spreadsheet program, which you could package into a
       <code class="calibre21">
        SpreadsheetApplication
       </code>
       class. Suppose further that we want each
       <code class="calibre21">
        Spreadsheet
       </code>
       to store a reference to the application object. The exact definition of the
       <code class="calibre21">
        SpreadsheetApplication
       </code>
       class is not important at this moment, so the following code simply defines it as an empty class. The
       <code class="calibre21">
        Spreadsheet
       </code>
       class is modified to include a new reference data member called
       <code class="calibre21">
        m_theApp
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0125"><code class="calibre21"><b class="calibre14">export class SpreadsheetApplication { };</b></code>
<code class="calibre21"> </code>
<code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">Spreadsheet(std::size_t width, std::size_t height,</b></code>
<code class="calibre21">            <b class="calibre14">SpreadsheetApplication&amp; theApp);</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity.</span></code>
<span aria-label="337" class="calibre20" epub:type="pagebreak" id="Page_337" role="doc-pagebreak"></span><code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Code omitted for brevity.</span></code>
<code class="calibre21">        <b class="calibre14">SpreadsheetApplication&amp; m_theApp;</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c09-para-0260">
       This definition adds a
       <code class="calibre21">
        SpreadsheetApplication
       </code>
       reference as a data member. It's recommended to use a reference in this case instead of a pointer because a
       <code class="calibre21">
        Spreadsheet
       </code>
       should always refer to a
       <code class="calibre21">
        SpreadsheetApplication
       </code>
       . This would not be guaranteed with a pointer.
      </p>
      <p class="calibre13" id="c09-para-0261">
       Note that storing a reference to the application is done only to demonstrate the use of references as data members. It's not recommended to couple the
       <code class="calibre21">
        Spreadsheet
       </code>
       and
       <code class="calibre21">
        SpreadsheetApplication
       </code>
       classes together in this way, but instead to use a paradigm such as Model-View-Controller (MVC), introduced in
       <a class="calibre5" href="c04.xhtml">
        Chapter 4
       </a>
       , “Designing Professional C++ Programs.”
      </p>
      <p class="calibre13">
       The application reference is given to each
       <code class="calibre21">
        Spreadsheet
       </code>
       in its constructor. A reference cannot exist without referring to something, so
       <code class="calibre21">
        m_theApp
       </code>
       must be given a value in the ctor-initializer of the constructor.
      </p>
      <pre class="calibre26" id="c09-code-0126"><code class="calibre21">Spreadsheet::Spreadsheet(size_t width, size_t height,</code>
<code class="calibre21">    <b class="calibre14">SpreadsheetApplication&amp; theApp)</b></code>
<code class="calibre21">    : m_id { ms_counter++ }</code>
<code class="calibre21">    , m_width { std::min(width, MaxWidth) }</code>
<code class="calibre21">    , m_height { std::min(height, MaxHeight) }</code>
<code class="calibre21">    <b class="calibre14">, m_theApp { theApp }</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    <span class="color">// Code omitted for brevity.</span></code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0263">
       You must also initialize the reference member in the copy constructor. This is handled automatically because the
       <code class="calibre21">
        Spreadsheet
       </code>
       copy constructor delegates to the non-copy constructor, which initializes the reference data member.
      </p>
      <p class="calibre13" id="c09-para-0264">
       Remember that after you have initialized a reference, you cannot change the object to which it refers. It's not possible to assign to references in the assignment operator. Depending on your use case, this might mean that an assignment operator cannot be provided for your class with reference data members. If that's the case, the assignment operator is typically marked as deleted.
      </p>
      <p class="calibre13">
       Finally, a reference data member can also be marked as
       <code class="calibre21">
        const
       </code>
       . For example, you might decide that
       <code class="calibre21">
        Spreadsheet
       </code>
       s should only have a reference-to-
       <code class="calibre21">
        const
       </code>
       to the application object. You can simply change the class definition to declare
       <code class="calibre21">
        m_theApp
       </code>
       as a reference-to-
       <code class="calibre21">
        const
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0127"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Spreadsheet(std::size_t width, std::size_t height,</code>
<code class="calibre21">            <b class="calibre14">const SpreadsheetApplication&amp; theApp);</b></code>
<code class="calibre21">        <span class="color">// Code omitted for brevity.</span></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Code omitted for brevity.</span></code>
<code class="calibre21">        <b class="calibre14">const SpreadsheetApplication&amp; m_theApp;</b></code>
<code class="calibre21">};</code></pre>
     </section>
    </section>
    <span aria-label="338" class="calibre20" epub:type="pagebreak" id="Page_338" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-114" class="calibre2">
     <span class="calibre" id="c09-sec-0067">
     </span>
     <h2 class="calibre6" id="head-2-114">
      NESTED CLASSES
     </h2>
     <p class="calibre13" id="c09-para-0266">
      Class definitions can contain more than just member functions and data members. They can also contain nested classes and
      <code class="calibre21">
       struct
      </code>
      s, type aliases, and enumerations. Anything declared inside a class is in the scope of that class. If it is
      <code class="calibre21">
       public
      </code>
      , you can access it outside the class by scoping it with the
      <i class="calibre18">
       <code class="calibre21">
        ClassName::
       </code>
      </i>
      scope resolution syntax.
     </p>
     <p class="calibre13">
      You can provide a class definition inside another class definition. For example, you might decide that the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      class is really part of the
      <code class="calibre21">
       Spreadsheet
      </code>
      class. And since it becomes part of the
      <code class="calibre21">
       Spreadsheet
      </code>
      class, you might as well rename it to
      <code class="calibre21">
       Cell
      </code>
      . You could define both of them like this:
     </p>
     <pre class="calibre26" id="c09-code-0128"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">class Cell</b></code>
<code class="calibre21">        <b class="calibre14">{</b></code>
<code class="calibre21">            <b class="calibre14">public:</b></code>
<code class="calibre21">                <b class="calibre14">Cell() = default;</b></code>
<code class="calibre21">                <b class="calibre14">Cell(double initialValue);</b></code>
<code class="calibre21">                <span class="color">// Remainder omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">};</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        Spreadsheet(std::size_t width, std::size_t height,</code>
<code class="calibre21">            const SpreadsheetApplication&amp; theApp);</code>
<code class="calibre21">        <span class="color">// Remainder of Spreadsheet declarations omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13">
      Now, the
      <code class="calibre21">
       Cell
      </code>
      class is defined inside the
      <code class="calibre21">
       Spreadsheet
      </code>
      class, so anywhere you refer to a
      <code class="calibre21">
       Cell
      </code>
      outside of the
      <code class="calibre21">
       Spreadsheet
      </code>
      class, you must qualify the name with the
      <code class="calibre21">
       Spreadsheet::
      </code>
      scope. This applies even to the member function definitions. For example, the
      <code class="calibre21">
       double
      </code>
      constructor of
      <code class="calibre21">
       Cell
      </code>
      now looks like this:
     </p>
     <pre class="calibre26" id="c09-code-0129"><code class="calibre21">Spreadsheet::Cell::Cell(double initialValue)</code>
<code class="calibre21">    : m_value { initialValue }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      You must even use the syntax for return types (but not parameters) of member functions in the
      <code class="calibre21">
       Spreadsheet
      </code>
      class itself:
     </p>
     <pre class="calibre26" id="c09-code-0130"><code class="calibre21"><b class="calibre14">const Spreadsheet::Cell&amp; Spreadsheet::getCellAt(size_t x, size_t y) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    verifyCoordinate(x, y);</code>
<code class="calibre21">    return m_cells[x][y];</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      Fully defining the nested
      <code class="calibre21">
       Cell
      </code>
      class directly inside the
      <code class="calibre21">
       Spreadsheet
      </code>
      class makes the definition of the
      <code class="calibre21">
       Spreadsheet
      </code>
      class a bit bloated. You can alleviate this by only including a forward declaration for
      <code class="calibre21">
       Cell
      </code>
      in the
      <code class="calibre21">
       Spreadsheet
      </code>
      class and then defining the
      <code class="calibre21">
       Cell
      </code>
      class separately, as follows:
     </p>
     <pre class="calibre26" id="c09-code-0131"><code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">class Cell;</b></code>
<code class="calibre21"> </code>
<span aria-label="339" class="calibre20" epub:type="pagebreak" id="Page_339" role="doc-pagebreak"></span><code class="calibre21">        Spreadsheet(std::size_t width, std::size_t height,</code>
<code class="calibre21">            const SpreadsheetApplication&amp; theApp);</code>
<code class="calibre21">        <span class="color">// Remainder of Spreadsheet declarations omitted for brevity</span></code>
<code class="calibre21">};</code>
<code class="calibre21"><b class="calibre14">class Spreadsheet::Cell</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Cell() = default;</code>
<code class="calibre21">        Cell(double initialValue);</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13" id="c09-para-0271">
      Normal access control applies to nested class definitions. If you declare a
      <code class="calibre21">
       private
      </code>
      or
      <code class="calibre21">
       protected
      </code>
      nested class, you can only use it from inside the outer class. A nested class has access to all
      <code class="calibre21">
       protected
      </code>
      and
      <code class="calibre21">
       private
      </code>
      members of the outer class. The outer class on the other hand can only access
      <code class="calibre21">
       public
      </code>
      members of the nested class.
     </p>
    </section>
    <section aria-labelledby="head-2-115" class="calibre2">
     <span class="calibre" id="c09-sec-0068">
     </span>
     <h2 class="calibre6" id="head-2-115">
      ENUMERATIONS INSIDE CLASSES
     </h2>
     <p class="calibre13">
      Enumerations can also be data members of a class. For example, you can add support for cell coloring to the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      class as follows:
     </p>
     <pre class="calibre26" id="c09-code-0132"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">enum class Color { Red = 1, Green, Blue, Yellow };</b></code>
<code class="calibre21">        <b class="calibre14">void setColor(Color color);</b></code>
<code class="calibre21">        <b class="calibre14">Color getColor() const;</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        <b class="calibre14">Color m_color { Color::Red };</b></code>
<code class="calibre21">};</code></pre>
     <p class="calibre13">
      The implementations of the
      <code class="calibre21">
       setColor()
      </code>
      and
      <code class="calibre21">
       getColor()
      </code>
      member functions are straightforward:
     </p>
     <pre class="calibre26" id="c09-code-0133"><code class="calibre21">void SpreadsheetCell::setColor(Color color) { m_color = color; }</code>
<code class="calibre21">SpreadsheetCell::Color SpreadsheetCell::getColor() const { return m_color; }</code></pre>
     <p class="calibre13">
      The new member functions can be used as follows:
     </p>
     <pre class="calibre26" id="c09-code-0134"><code class="calibre21">SpreadsheetCell myCell { 5 };</code>
<code class="calibre21">myCell.setColor(SpreadsheetCell::Color::Blue);</code>
<code class="calibre21">auto color { myCell.getColor() };</code></pre>
    </section>
    <section aria-labelledby="head-2-116" class="calibre2">
     <span class="calibre" id="c09-sec-0069">
     </span>
     <h2 class="calibre6" id="head-2-116">
      OPERATOR OVERLOADING
     </h2>
     <p class="calibre13" id="c09-para-0275">
      You often want to perform operations on objects, such as adding them, comparing them, or streaming them to or from files. For example, spreadsheets are useful only when you can perform arithmetic actions on them, such as summing an entire row of cells. All this can be accomplished by overloading operators.
     </p>
     <p class="calibre13">
      <span aria-label="340" class="calibre20" epub:type="pagebreak" id="Page_340" role="doc-pagebreak">
      </span>
      Many people find the syntax of operator overloading tricky and confusing, at least at first. The irony is that it's supposed to make things simpler. As you will discover in this section, that doesn't mean simpler for the person writing the class, but simpler for the person using the class. The point is to make your new classes as similar as possible to built-in types such as
      <code class="calibre21">
       int
      </code>
      and
      <code class="calibre21">
       double
      </code>
      : it's easier to add objects using
      <code class="calibre21">
       +
      </code>
      than to remember whether the member function name you should call is
      <code class="calibre21">
       add()
      </code>
      or
      <code class="calibre21">
       sum()
      </code>
      .
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c09-para-0277">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Provide operator overloading as a service to clients of your class
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c09-para-0278">
      At this point, you might be wondering exactly which operators you can overload. The answer is almost all of them—even some you've never heard of. This chapter just scratches the surface: the assignment operator is explained earlier in this chapter, while this section introduces the basic arithmetic operators, the shorthand arithmetic operators, and the comparison operators. Overloading the stream insertion and extraction operators is also useful. In addition, there are some tricky, but interesting, things you can do with operator overloading that you might not anticipate at first. The Standard Library uses operator overloading extensively.
      <a class="calibre5" href="c15.xhtml">
       Chapter 15
      </a>
      explains how and when to overload the rest of the operators.
      <a class="calibre5" href="c16.xhtml">
       Chapters 16
      </a>
      to
      <a class="calibre5" href="c24.xhtml">
       24
      </a>
      cover the Standard Library.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0071">
      </span>
      <h3 class="calibre27" id="head-3-202">
       Example: Implementing Addition for SpreadsheetCells
      </h3>
      <p class="calibre13" id="c09-para-0279">
       In true object-oriented fashion,
       <code class="calibre21">
        SpreadsheetCell
       </code>
       objects should be able to add themselves to other
       <code class="calibre21">
        SpreadsheetCell
       </code>
       objects. Adding one cell to another cell produces a third cell with the result. It doesn't change either of the original cells. The meaning of addition for
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s is the addition of the values of the cells.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0072">
       </span>
       <h4 class="calibre29" id="head-4-184">
        First Attempt: The add Member Function
       </h4>
       <p class="calibre13">
        You can declare and define an
        <code class="calibre21">
         add()
        </code>
        member function for your
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class like this:
       </p>
       <pre class="calibre26" id="c09-code-0135"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">         <b class="calibre14">SpreadsheetCell add(const SpreadsheetCell&amp; cell) const;</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        This member function adds two cells together, returning a new third cell whose value is the sum of the first two. It is declared
        <code class="calibre21">
         const
        </code>
        and takes a reference to a
        <code class="calibre21">
         const SpreadsheetCell
        </code>
        because
        <code class="calibre21">
         add()
        </code>
        does not change either of the source cells. Here is the implementation:
       </p>
       <pre class="calibre26" id="c09-code-0136"><code class="calibre21">SpreadsheetCell SpreadsheetCell::add(const SpreadsheetCell&amp; cell) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return SpreadsheetCell { getValue() + cell.getValue() };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        You can use the
        <code class="calibre21">
         add()
        </code>
        member function like this:
       </p>
       <pre class="calibre26" id="c09-code-0137"><code class="calibre21">SpreadsheetCell myCell { 4 }, anotherCell { 5 };</code>
<span aria-label="341" class="calibre20" epub:type="pagebreak" id="Page_341" role="doc-pagebreak"></span><code class="calibre21">SpreadsheetCell aThirdCell { myCell.add(anotherCell) };</code>
<code class="calibre21">auto aFourthCell { aThirdCell.add(anotherCell) };</code></pre>
       <p class="calibre13" id="c09-para-0283">
        That works, but it's a bit clumsy. We can do better.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0073">
       </span>
       <h4 class="calibre29" id="head-4-185">
        Second Attempt: Overloaded operator+ as a Member Function
       </h4>
       <p class="calibre13">
        It would be convenient to be able to add two cells with the plus sign the way that you add two
        <code class="calibre21">
         int
        </code>
        s or two
        <code class="calibre21">
         double
        </code>
        s—something like this:
       </p>
       <pre class="calibre26" id="c09-code-0138"><code class="calibre21">SpreadsheetCell myCell { 4 }, anotherCell { 5 };</code>
<code class="calibre21">SpreadsheetCell aThirdCell { <b class="calibre14">myCell + anotherCell</b> };</code>
<code class="calibre21">auto aFourthCell { <b class="calibre14">aThirdCell + anotherCell</b> };</code></pre>
       <p class="calibre13">
        C++ allows you to write your own version of the plus sign, called the
        <i class="calibre18">
         addition operator
        </i>
        , to work correctly for your classes. To do that, you write a member function with the name
        <code class="calibre21">
         operator+
        </code>
        that looks like this:
       </p>
       <pre class="calibre26" id="c09-code-0139"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">         <b class="calibre14">SpreadsheetCell operator+(const SpreadsheetCell&amp; cell) const;</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0287">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            You are allowed to insert spaces between
           </i>
           <code class="calibre21">
            operator
           </code>
           <i class="calibre18">
            and the plus sign. For example, instead of writing
           </i>
           <code class="calibre21">
            operator+
           </code>
           <i class="calibre18">
            , you can write
           </i>
           <code class="calibre21">
            operator +
           </code>
           <i class="calibre18">
            . This book adopts the style without spaces.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        The definition of the overloaded
        <code class="calibre21">
         operator+
        </code>
        member function is identical to the implementation of the
        <code class="calibre21">
         add()
        </code>
        member function:
       </p>
       <pre class="calibre26" id="c09-code-0140"><code class="calibre21"><b class="calibre14">SpreadsheetCell SpreadsheetCell::operator+(const SpreadsheetCell&amp; cell) const</b></code>
<code class="calibre21">{</code>
<code class="calibre21">    return SpreadsheetCell { getValue() + cell.getValue() };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0289">
        Now you can add two cells together using the plus operator as shown earlier.
       </p>
       <p class="calibre13">
        This syntax takes a bit of getting used to. Try not to worry too much about the strange member function name
        <code class="calibre21">
         operator+
        </code>
        —it's just a name like
        <code class="calibre21">
         foo
        </code>
        or
        <code class="calibre21">
         add
        </code>
        . To understand the rest of the syntax, it helps to understand what's really going on. When your C++ compiler parses a program and encounters an operator, such as
        <code class="calibre21">
         +
        </code>
        ,
        <code class="calibre21">
         -
        </code>
        ,
        <code class="calibre21">
         =
        </code>
        , or
        <code class="calibre21">
         &lt;&lt;
        </code>
        , it tries to find a function or member function with the name
        <code class="calibre21">
         operator+
        </code>
        ,
        <code class="calibre21">
         operator-
        </code>
        ,
        <code class="calibre21">
         operator=
        </code>
        , or
        <code class="calibre21">
         operator&lt;&lt;
        </code>
        , respectively, that takes the appropriate parameters. For example, when the compiler sees the following line, it tries to find a member function in the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class named
        <code class="calibre21">
         operator+
        </code>
        that accepts another
        <code class="calibre21">
         SpreadsheetCell
        </code>
        as argument (or, as discussed later in this chapter, a global function named
        <code class="calibre21">
         operator+
        </code>
        that accepts two
        <code class="calibre21">
         SpreadsheetCell
        </code>
        arguments):
       </p>
       <pre class="calibre26" id="c09-code-0141"><code class="calibre21">SpreadsheetCell aThirdCell { myCell + anotherCell };</code></pre>
       <p class="calibre13">
        <span aria-label="342" class="calibre20" epub:type="pagebreak" id="Page_342" role="doc-pagebreak">
        </span>
        If the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class contains such an
        <code class="calibre21">
         operator+
        </code>
        member function, then the previous line is translated to this:
       </p>
       <pre class="calibre26" id="c09-code-0142"><code class="calibre21">SpreadsheetCell aThirdCell { myCell.operator+(anotherCell) };</code></pre>
       <p class="calibre13" id="c09-para-0292">
        Note that there's no requirement that
        <code class="calibre21">
         operator+
        </code>
        takes as a parameter an object of the same type as the class for which it's written. You could write an
        <code class="calibre21">
         operator+
        </code>
        for
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s that takes a
        <code class="calibre21">
         Spreadsheet
        </code>
        to add to the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        . That wouldn't make sense to the programmer, but the compiler would allow it. The next section gives an example of an
        <code class="calibre21">
         operator+
        </code>
        for
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s accepting a
        <code class="calibre21">
         double
        </code>
        value.
       </p>
       <p class="calibre13" id="c09-para-0293">
        Note also that you can give
        <code class="calibre21">
         operator+
        </code>
        any return type you want. However, you should follow the principle of least astonishment; that is, the return type of your
        <code class="calibre21">
         operator+
        </code>
        should generally be what users would expect.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c09-sec-0075">
        </span>
        <h5 class="calibre35" id="head-5-73">
         Implicit Conversions
        </h5>
        <p class="calibre13">
         Surprisingly, once you've written the
         <code class="calibre21">
          operator+
         </code>
         shown earlier, not only can you add two cells together, but you can also add a cell to a
         <code class="calibre21">
          string_view
         </code>
         , a
         <code class="calibre21">
          double
         </code>
         , or an
         <code class="calibre21">
          int
         </code>
         ! Here are some examples:
        </p>
        <pre class="calibre26" id="c09-code-0143"><code class="calibre21">SpreadsheetCell myCell { 4 }, aThirdCell;</code>
<code class="calibre21">string str { "hello" };</code>
<code class="calibre21">aThirdCell = myCell + string_view{ str };</code>
<code class="calibre21">aThirdCell = myCell + 5.6;</code>
<code class="calibre21">aThirdCell = myCell + 4;</code></pre>
        <p class="calibre13" id="c09-para-0295">
         The reason this code works is that the compiler does more to try to find an appropriate
         <code class="calibre21">
          operator+
         </code>
         than just look for one with the exact types specified. The compiler also tries to find an appropriate conversion for the types so that an
         <code class="calibre21">
          operator+
         </code>
         can be found. The
         <code class="calibre21">
          SpreadsheetCell
         </code>
         class has converting constructors (discussed in
         <a class="calibre5" href="c08.xhtml">
          Chapter 8
         </a>
         ) to convert a
         <code class="calibre21">
          double
         </code>
         or a
         <code class="calibre21">
          string_view
         </code>
         into a
         <code class="calibre21">
          SpreadsheetCell
         </code>
         . In the preceding example, when the compiler sees a
         <code class="calibre21">
          SpreadsheetCell
         </code>
         trying to add itself to a
         <code class="calibre21">
          double
         </code>
         , it finds the
         <code class="calibre21">
          SpreadsheetCell
         </code>
         constructor that takes a
         <code class="calibre21">
          double
         </code>
         and constructs a temporary
         <code class="calibre21">
          SpreadsheetCell
         </code>
         object to pass to
         <code class="calibre21">
          operator+
         </code>
         . Similarly, when the compiler sees the line trying to add a
         <code class="calibre21">
          SpreadsheetCell
         </code>
         to a
         <code class="calibre21">
          string_view
         </code>
         , it calls the
         <code class="calibre21">
          string_view SpreadsheetCell
         </code>
         constructor to create a temporary
         <code class="calibre21">
          SpreadsheetCell
         </code>
         to pass to
         <code class="calibre21">
          operator+
         </code>
         .
        </p>
        <p class="calibre13">
         Keep in mind, though, that the use of an implicit converting constructor might be inefficient, because temporary objects must be created. In this example, to avoid implicit construction for adding a
         <code class="calibre21">
          double
         </code>
         , you could write a second
         <code class="calibre21">
          operator+
         </code>
         as follows:
        </p>
        <pre class="calibre26" id="c09-code-0144"><code class="calibre21">SpreadsheetCell SpreadsheetCell::operator+(double rhs) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return SpreadsheetCell { getValue() + rhs };</code>
<code class="calibre21">}</code></pre>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0076">
       </span>
       <h4 class="calibre29" id="head-4-186">
        Third Attempt: Global operator+
       </h4>
       <p class="calibre13">
        Implicit conversions allow you to use an
        <code class="calibre21">
         operator+
        </code>
        member function to add your
        <code class="calibre21">
         SpreadsheetCell
        </code>
        objects to
        <code class="calibre21">
         int
        </code>
        s and
        <code class="calibre21">
         double
        </code>
        s. However, the operator is not commutative, as shown in the following code:
       </p>
       <pre class="calibre26" id="c09-code-0145"><code class="calibre21">aThirdCell = myCell + 5.6; <span class="color">// Works fine.</span></code>
<code class="calibre21">aThirdCell = myCell + 4;   <span class="color">// Works fine.</span></code>
<span aria-label="343" class="calibre20" epub:type="pagebreak" id="Page_343" role="doc-pagebreak"></span><code class="calibre21">aThirdCell = 5.6 + myCell; <span class="color">// FAILS TO COMPILE!</span></code>
<code class="calibre21">aThirdCell = 4 + myCell;   <span class="color">// FAILS TO COMPILE!</span></code></pre>
       <p class="calibre13" id="c09-para-0298">
        The implicit conversion works fine when the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object is on the left of the operator, but it doesn't work when it's on the right. Addition is supposed to be commutative, so something is wrong here. The problem is that the
        <code class="calibre21">
         operator+
        </code>
        member function must be called on a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object, and that object must be on the left-hand side of the
        <code class="calibre21">
         operator+
        </code>
        . That's just the way the C++ language is defined. So, there's no way you can get this code to work with an
        <code class="calibre21">
         operator+
        </code>
        member function.
       </p>
       <p class="calibre13">
        However, you can get it to work if you replace the in-class
        <code class="calibre21">
         operator+
        </code>
        member function with a global
        <code class="calibre21">
         operator+
        </code>
        function that is not tied to any particular object. The function looks like this:
       </p>
       <pre class="calibre26" id="c09-code-0146"><code class="calibre21">SpreadsheetCell operator+(const SpreadsheetCell&amp; lhs,</code>
<code class="calibre21">    const SpreadsheetCell&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return SpreadsheetCell { lhs.getValue() + rhs.getValue() };</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        You need to declare this operator in the module interface file and export it:
       </p>
       <pre class="calibre26" id="c09-code-0147"><code class="calibre21">export class SpreadsheetCell { <span class="color">/* Omitted for brevity */</span> };</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">export SpreadsheetCell operator+(const SpreadsheetCell&amp; lhs,</b></code>
<code class="calibre21">    <b class="calibre14">const SpreadsheetCell&amp; rhs);</b></code></pre>
       <p class="calibre13">
        Now all four of the earlier additions work as you expect.
       </p>
       <pre class="calibre26" id="c09-code-0148"><code class="calibre21">aThirdCell = myCell + 5.6; <span class="color">// Works fine.</span></code>
<code class="calibre21">aThirdCell = myCell + 4;   <span class="color">// Works fine.</span></code>
<code class="calibre21">aThirdCell = 5.6 + myCell; <span class="color">// Works fine.</span></code>
<code class="calibre21">aThirdCell = 4 + myCell;   <span class="color">// Works fine.</span></code></pre>
       <p class="calibre13">
        You might be wondering what happens if you write the following code:
       </p>
       <pre class="calibre26" id="c09-code-0149"><code class="calibre21">aThirdCell = 4.5 + 5.5;</code></pre>
       <p class="calibre13">
        It compiles and runs, but it's not calling the
        <code class="calibre21">
         operator+
        </code>
        you wrote. It does normal
        <code class="calibre21">
         double
        </code>
        addition of 4.5 and 5.5, which results in the following intermediate statement:
       </p>
       <pre class="calibre26" id="c09-code-0150"><code class="calibre21">aThirdCell = 10;</code></pre>
       <p class="calibre13" id="c09-para-0304">
        To make this assignment work, there should be a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object on the right-hand side. The compiler will discover a non-explicit user-defined constructor that takes a
        <code class="calibre21">
         double
        </code>
        , will use this constructor to implicitly convert the
        <code class="calibre21">
         double
        </code>
        value into a temporary
        <code class="calibre21">
         SpreadsheetCell
        </code>
        object, and will then call the assignment operator.
       </p>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0077">
      </span>
      <h3 class="calibre27" id="head-3-203">
       Overloading Arithmetic Operators
      </h3>
      <p class="calibre13">
       Now that you understand how to write
       <code class="calibre21">
        operator+
       </code>
       , the rest of the basic arithmetic operators are straightforward. Here are the declarations of
       <code class="calibre21">
        +
       </code>
       ,
       <code class="calibre21">
        -
       </code>
       ,
       <code class="calibre21">
        *
       </code>
       , and
       <code class="calibre21">
        /
       </code>
       , where you have to replace
       <i class="calibre18">
        &lt;op&gt;
       </i>
       with
       <code class="calibre21">
        +
       </code>
       ,
       <code class="calibre21">
        -
       </code>
       ,
       <code class="calibre21">
        *
       </code>
       , and
       <code class="calibre21">
        /
       </code>
       , resulting in four functions. You can also overload
       <code class="calibre21">
        %
       </code>
       , but it doesn't make sense for the
       <code class="calibre21">
        double
       </code>
       values stored in
       <code class="calibre21">
        SpreadsheetCell
       </code>
       s.
      </p>
      <pre class="calibre26" id="c09-code-0151"><span aria-label="344" class="calibre20" epub:type="pagebreak" id="Page_344" role="doc-pagebreak"></span><code class="calibre21">export class SpreadsheetCell { <span class="color">/* Omitted for brevity */</span> };</code>
<code class="calibre21"> </code>
<code class="calibre21">export SpreadsheetCell operator<b class="calibre14"><i class="calibre18">&lt;op&gt;</i></b>(const SpreadsheetCell&amp; lhs,</code>
<code class="calibre21">    const SpreadsheetCell&amp; rhs);</code></pre>
      <p class="calibre13">
       The implementations of
       <code class="calibre21">
        operator-
       </code>
       and
       <code class="calibre21">
        operator*
       </code>
       are similar to the implementation of
       <code class="calibre21">
        operator+
       </code>
       , so these are not shown. For
       <code class="calibre21">
        operator/
       </code>
       , the only tricky aspect is remembering to check for division by zero. This implementation throws an exception if division by zero is detected:
      </p>
      <pre class="calibre26" id="c09-code-0152"><code class="calibre21">SpreadsheetCell operator/(const SpreadsheetCell&amp; lhs,</code>
<code class="calibre21">    const SpreadsheetCell&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    if (rhs.getValue() == 0) {</code>
<code class="calibre21">        throw invalid_argument { "Divide by zero." };</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return SpreadsheetCell { lhs.getValue() / rhs.getValue() };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       C++ does not require you to actually implement multiplication in
       <code class="calibre21">
        operator*
       </code>
       , division in
       <code class="calibre21">
        operator/
       </code>
       , and so on. You could implement multiplication in
       <code class="calibre21">
        operator/
       </code>
       , division in
       <code class="calibre21">
        operator+
       </code>
       , and so forth. However, that would be extremely confusing, and there is no good reason to do so. Whenever possible, stick to the commonly used operator meanings in your implementations.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0308">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           In C++, you cannot change the precedence of operators. For example,
          </i>
          <code class="calibre21">
           *
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           /
          </code>
          <i class="calibre18">
           are always evaluated before
          </i>
          <code class="calibre21">
           +
          </code>
          <i class="calibre18">
           and
          </i>
          <code class="calibre21">
           -
          </code>
          <i class="calibre18">
           . The only thing user-defined operators can do is specify the implementation once the precedence of operations has been determined. C++ also does not allow you to invent new operator symbols or to change the number of arguments for operators. Operator overloading is discussed in more detail in
          </i>
          <a class="calibre5" href="c15.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           15
          </a>
          <i class="calibre18">
           , “Overloading C++ Operators.”
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0079">
       </span>
       <h4 class="calibre29" id="head-4-187">
        Overloading the Arithmetic Shorthand Operators
       </h4>
       <p class="calibre13" id="c09-para-0309">
        In addition to the basic arithmetic operators, C++ provides shorthand operators such as
        <code class="calibre21">
         +=
        </code>
        and
        <code class="calibre21">
         -=
        </code>
        . You might assume that writing
        <code class="calibre21">
         operator+
        </code>
        for your class also provides
        <code class="calibre21">
         operator+=
        </code>
        . No such luck. You have to overload the shorthand arithmetic operators explicitly. These operators differ from the basic arithmetic operators in that they change the object on the left-hand side of the operator instead of creating a new object. A second, subtler difference is that, like the assignment operator, they generate a result that is a reference to the modified object.
       </p>
       <p class="calibre13">
        The arithmetic shorthand operators always require an object of your class on the left-hand side, so you should write them as member functions, not as global functions. Here are the declarations for the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class:
       </p>
       <pre class="calibre26" id="c09-code-0153"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">SpreadsheetCell&amp; operator+=(const SpreadsheetCell&amp; rhs);</b></code>
<code class="calibre21">        <b class="calibre14">SpreadsheetCell&amp; operator-=(const SpreadsheetCell&amp; rhs);</b></code>
<code class="calibre21">        <b class="calibre14">SpreadsheetCell&amp; operator*=(const SpreadsheetCell&amp; rhs);</b></code>
<code class="calibre21">        <b class="calibre14">SpreadsheetCell&amp; operator/=(const SpreadsheetCell&amp; rhs);</b></code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        <span aria-label="345" class="calibre20" epub:type="pagebreak" id="Page_345" role="doc-pagebreak">
        </span>
        Here is the implementation for
        <code class="calibre21">
         operator+=
        </code>
        . The others are similar.
       </p>
       <pre class="calibre26" id="c09-code-0154"><code class="calibre21">SpreadsheetCell&amp; SpreadsheetCell::operator+=(const SpreadsheetCell&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    set(getValue() + rhs.getValue());</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        The shorthand arithmetic operators are combinations of the basic arithmetic and assignment operators. With the previous definitions, you can now write code like this:
       </p>
       <pre class="calibre26" id="c09-code-0155"><code class="calibre21">SpreadsheetCell myCell { 4 }, aThirdCell { 2 };</code>
<code class="calibre21">aThirdCell -= myCell;</code>
<code class="calibre21">aThirdCell += 5.4;</code></pre>
       <p class="calibre13">
        You cannot, however, write code like this (which is a good thing!):
       </p>
       <pre class="calibre26" id="c09-code-0156"><code class="calibre21">5.4 += aThirdCell;</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0315">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            When you have both a normal and a shorthand version of a certain operator, it's recommended to implement the normal one in terms of the shorthand version to avoid code duplication
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        Here's an example:
       </p>
       <pre class="calibre26" id="c09-code-0157"><code class="calibre21">SpreadsheetCell operator+(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto result { lhs };  <span class="color">// Local copy</span></code>
<code class="calibre21">    result += rhs;        <span class="color">// Forward to +=()</span></code>
<code class="calibre21">    return result;</code>
<code class="calibre21">}</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0081">
      </span>
      <h3 class="calibre27" id="head-3-204">
       Overloading Comparison Operators
      </h3>
      <p class="calibre13" id="c09-para-0317">
       The comparison operators,
       <code class="calibre21">
        &gt;
       </code>
       ,
       <code class="calibre21">
        &lt;
       </code>
       ,
       <code class="calibre21">
        &lt;=
       </code>
       ,
       <code class="calibre21">
        &gt;=
       </code>
       ,
       <code class="calibre21">
        ==
       </code>
       , and
       <code class="calibre21">
        !=
       </code>
       , are another useful set of operators to define for your classes. The C++20 standard has brought quite a few changes for these operators and has added the three-way comparison operator, also known as the spaceship operator,
       <code class="calibre21">
        &lt;=&gt;
       </code>
       , introduced in
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       . To make you appreciate more what has changed since C++20, let's first start by looking at what you had to do before C++20 and what you still need to do as long as your compiler does not support the three-way comparison operator yet.
      </p>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0082">
       </span>
       <h4 class="calibre29" id="head-4-188">
        Overloading Comparison Operators Before C++20
       </h4>
       <p class="calibre13" id="c09-para-0318">
        Like the basic arithmetic operators, the six pre-C++20 comparison operators should be global functions so that you can use implicit conversion on both the left- and the right-hand side argument of the operator. The comparison operators all return a
        <code class="calibre21">
         bool
        </code>
        . Of course, you can change the return type, but that's not recommended.
       </p>
       <p class="calibre13">
        <span aria-label="346" class="calibre20" epub:type="pagebreak" id="Page_346" role="doc-pagebreak">
        </span>
        Here are the declarations, where you have to replace
        <i class="calibre18">
         &lt;op&gt;
        </i>
        with
        <code class="calibre21">
         ==
        </code>
        ,
        <code class="calibre21">
         &lt;
        </code>
        ,
        <code class="calibre21">
         &gt;
        </code>
        ,
        <code class="calibre21">
         !=
        </code>
        ,
        <code class="calibre21">
         &lt;=
        </code>
        , and
        <code class="calibre21">
         &gt;=
        </code>
        , resulting in six functions:
       </p>
       <pre class="calibre26" id="c09-code-0158"><code class="calibre21">class SpreadsheetCell { <span class="color">/* Omitted for brevity */</span> };</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">bool operator<i class="calibre18">&lt;op&gt;</i>(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs);</b></code></pre>
       <p class="calibre13">
        Here is the definition of
        <code class="calibre21">
         operator==.
        </code>
        The others are similar.
       </p>
       <pre class="calibre26" id="c09-code-0159"><code class="calibre21">bool operator==(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return (lhs.getValue() == rhs.getValue());</code>
<code class="calibre21">}</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0322">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            These overloaded comparison operators are comparing
           </i>
           <code class="calibre21">
            double
           </code>
           <i class="calibre18">
            values. Most of the time, performing equality or inequality tests on floating-point values is not a good idea. You should use an epsilon test, but that falls outside the scope of this book.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        In classes with more data members, it might be painful to compare each data member. However, once you've implemented
        <code class="calibre21">
         ==
        </code>
        and &lt;, you can write the rest of the comparison operators in terms of those two. For example, here is a definition of
        <code class="calibre21">
         operator&gt;=
        </code>
        that uses
        <code class="calibre21">
         operator&lt;
        </code>
        :
       </p>
       <pre class="calibre26" id="c09-code-0160"><code class="calibre21">bool operator&gt;=(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return !(lhs &lt; rhs);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        You can use these operators to compare
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s to other
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s, and also to
        <code class="calibre21">
         double
        </code>
        s and
        <code class="calibre21">
         int
        </code>
        s:
       </p>
       <pre class="calibre26" id="c09-code-0161"><code class="calibre21">if (myCell&gt; aThirdCell || myCell &lt; 10) {</code>
<code class="calibre21">    cout &lt;&lt; myCell.getValue() &lt;&lt; endl;</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        As you can see, you need to write six separate functions to support the six comparison operators, and that's only to compare two
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s with each other. With the current six implemented comparison functions, it's possible to compare a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        with a
        <code class="calibre21">
         double
        </code>
        because a
        <code class="calibre21">
         double
        </code>
        argument is implicitly converted to a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        . As discussed earlier, such implicit conversions might be inefficient, because temporary objects must be created. Just as with
        <code class="calibre21">
         operator+
        </code>
        earlier, you can avoid this by implementing explicit functions to compare with
        <code class="calibre21">
         double
        </code>
        s. For each operator
        <i class="calibre18">
         &lt;op&gt;
        </i>
        , you would then need the following three overloads:
       </p>
       <pre class="calibre26" id="c09-code-0162"><code class="calibre21">bool operator<i class="calibre18">&lt;op&gt;</i>(const SpreadsheetCell&amp; lhs, const SpreadsheetCell&amp; rhs);</code>
<code class="calibre21">bool operator<i class="calibre18">&lt;op&gt;</i>(double lhs, const SpreadsheetCell&amp; rhs);</code>
<code class="calibre21">bool operator<i class="calibre18">&lt;op&gt;</i>(const SpreadsheetCell&amp; lhs, double rhs);</code></pre>
       <p class="calibre13" id="c09-para-0326">
        If you want to support all comparison operators, that's a lot of repetitive code to write!
       </p>
      </section>
      <span aria-label="347" class="calibre20" epub:type="pagebreak" id="Page_347" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0084">
       </span>
       <h4 class="calibre29" id="head-4-189">
        Overloading Comparison Operators Since C++20
       </h4>
       <p class="calibre13">
        Let's now switch gears and see what C++20 and later versions bring to the table. Starting with C++20, adding support for comparison operators to your classes is simplified a lot. First, it is now actually recommended to implement
        <code class="calibre21">
         operator==
        </code>
        as a member function of the class instead of a global function. Note also that it's a good idea to add the
        <code class="calibre21">
         [[nodiscard]]
        </code>
        attribute so the result of the operator cannot be ignored. Here's an example:
       </p>
       <pre class="calibre26" id="c09-code-0163"><code class="calibre21">[[nodiscard]] bool operator==(const SpreadsheetCell&amp; rhs) const;</code></pre>
       <p class="calibre13">
        Since C++20, this single
        <code class="calibre21">
         operator==
        </code>
        overload makes the following comparisons work:
       </p>
       <pre class="calibre26" id="c09-code-0164"><code class="calibre21">if (myCell == 10) { println("myCell == 10"); }</code>
<code class="calibre21">if (10 == myCell) { println("10 == myCell"); }</code></pre>
       <p class="calibre13" id="c09-para-0329">
        An expression such as
        <code class="calibre21">
         10 == myCell
        </code>
        is now rewritten by the compiler as
        <code class="calibre21">
         myCell == 10
        </code>
        for which the
        <code class="calibre21">
         operator==
        </code>
        member function can be called. Additionally, by implementing
        <code class="calibre21">
         operator==
        </code>
        , the compiler automatically adds support for
        <code class="calibre21">
         !=
        </code>
        as well; expressions using
        <code class="calibre21">
         !=
        </code>
        are rewritten to use
        <code class="calibre21">
         ==
        </code>
        .
       </p>
       <p class="calibre13">
        Next, to implement support for the full suite of comparison operators, you just need to implement one additional overloaded operator,
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        . Once your class has an overload for
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        , the compiler automatically provides support for all six comparison operators! For the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class,
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        looks as follows:
       </p>
       <pre class="calibre26" id="c09-code-0165"><code class="calibre21">[[nodiscard]] std::partial_ordering operator&lt;=&gt;(const SpreadsheetCell&amp; rhs) const;</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c09-para-0332">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            A compiler will not rewrite
           </i>
           <code class="calibre21">
            ==
           </code>
           <i class="calibre18">
            or
           </i>
           <code class="calibre21">
            !=
           </code>
           <i class="calibre18">
            comparisons in terms of
           </i>
           <code class="calibre21">
            &lt;=&gt;
           </code>
           <i class="calibre18">
            . This is done to avoid performance issues, as an explicit implementation of
           </i>
           <code class="calibre21">
            operator==
           </code>
           <i class="calibre18">
            is typically more efficient than using
           </i>
           <code class="calibre21">
            &lt;=&gt;
           </code>
           <i class="calibre18">
            . For example, take
           </i>
           <code class="calibre21">
            std::string
           </code>
           <i class="calibre18">
            . Its implementation of
           </i>
           <code class="calibre21">
            operator==
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            !=
           </code>
           <i class="calibre18">
            can first check the lengths of both
           </i>
           <code class="calibre21">
            string
           </code>
           <i class="calibre18">
            s to compare. If the lengths are different,
           </i>
           <code class="calibre21">
            operator==
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            !=
           </code>
           <i class="calibre18">
            can immediately return
           </i>
           <code class="calibre21">
            false
           </code>
           <i class="calibre18">
            , respectively
           </i>
           <code class="calibre21">
            true
           </code>
           <i class="calibre18">
            , without having to check individual characters. However,
           </i>
           <code class="calibre21">
            operator&lt;=&gt;
           </code>
           <i class="calibre18">
            always has to compare individual characters until it finds two characters that don't match.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <p class="calibre13">
        The value stored in a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        is a
        <code class="calibre21">
         double
        </code>
        . Remember from
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        that floating-point types only have a partial order, so that's why the overload returns
        <code class="calibre21">
         std::partial_ordering
        </code>
        . The implementation is straightforward:
       </p>
       <pre class="calibre26" id="c09-code-0166"><code class="calibre21">partial_ordering SpreadsheetCell::operator&lt;=&gt;(const SpreadsheetCell&amp; rhs) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return getValue() &lt;=&gt; rhs.getValue();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c09-para-0334">
        By implementing
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , the compiler automatically provides support for
        <code class="calibre21">
         &gt;
        </code>
        ,
        <code class="calibre21">
         &lt;
        </code>
        ,
        <code class="calibre21">
         &lt;=
        </code>
        , and
        <code class="calibre21">
         &gt;=
        </code>
        , by rewriting expressions using those operators to use &lt;=&gt; instead. For example, an expression such as
        <code class="calibre21">
         myCell &lt; aThirdCell
        </code>
        is automatically rewritten to something equivalent to
        <code class="calibre21">
         std::is_lt(myCell &lt;=&gt; aThirdCell)
        </code>
        , where
        <code class="calibre21">
         is_lt()
        </code>
        is a named comparison function; see
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        .
       </p>
       <p class="calibre13">
        <span aria-label="348" class="calibre20" epub:type="pagebreak" id="Page_348" role="doc-pagebreak">
        </span>
        So, by just implementing
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        class supports the full set of comparison operators:
       </p>
       <pre class="calibre26" id="c09-code-0167"><code class="calibre21">if (myCell &lt; aThirdCell) { println("myCell &lt; aThirdCell"); }</code>
<code class="calibre21">if (aThirdCell &lt; myCell) { println("aThirdCell &lt; myCell"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">if (myCell &lt;= aThirdCell) { println("myCell &lt;= aThirdCell"); }</code>
<code class="calibre21">if (aThirdCell &lt;= myCell) { println("aThirdCell &lt;= myCell"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">if (myCell&gt; aThirdCell) { println("myCell&gt; aThirdCell"); }</code>
<code class="calibre21">if (aThirdCell&gt; myCell) { println("aThirdCell&gt; myCell"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">if (myCell&gt;= aThirdCell) { println("myCell&gt;= aThirdCell"); }</code>
<code class="calibre21">if (aThirdCell&gt;= myCell) { println("aThirdCell&gt;= myCell"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">if (myCell == aThirdCell) { println("myCell == aThirdCell"); }</code>
<code class="calibre21">if (aThirdCell == myCell) { println("aThirdCell == myCell"); }</code>
<code class="calibre21"> </code>
<code class="calibre21">if (myCell != aThirdCell) { println("myCell != aThirdCell"); }</code>
<code class="calibre21">if (aThirdCell != myCell) { println("aThirdCell != myCell"); }</code></pre>
       <p class="calibre13">
        Since the
        <code class="calibre21">
         SpreadsheetCell class
        </code>
        supports implicit conversion from
        <code class="calibre21">
         double
        </code>
        to a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        , comparisons such as the following are supported as well:
       </p>
       <pre class="calibre26" id="c09-code-0168"><code class="calibre21">if (myCell &lt; 10) { println("myCell &lt; 10"); }</code>
<code class="calibre21">if (10 &lt; myCell) { println("10 &lt; myCell"); }</code>
<code class="calibre21">if (10 != myCell) { println("10 != myCell"); }</code></pre>
       <p class="calibre13" id="c09-para-0337">
        As with comparing two
        <code class="calibre21">
         SpreadsheetCell
        </code>
        objects, the compiler rewrites such expressions in terms of
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        , and optionally swaps the order of the arguments. For example,
        <code class="calibre21">
         10 &lt; myCell
        </code>
        is rewritten first to something equivalent to
        <code class="calibre21">
         is_lt(10 &lt;=&gt; myCell)
        </code>
        , which won't work because we only have an overload for
        <code class="calibre21">
         &lt;=&gt;
        </code>
        as a member, meaning that the left-hand side argument must be a
        <code class="calibre21">
         SpreadsheetCell
        </code>
        . Noticing this, the compiler then tries to rewrite the expression to something equivalent to
        <code class="calibre21">
         is_gt(myCell &lt;=&gt; 10)
        </code>
        , which works out fine.
       </p>
       <p class="calibre13">
        As before, if you want to avoid the slight performance impact of implicit conversions, you can provide specific overloads for
        <code class="calibre21">
         double
        </code>
        s. And since C++20, this is not even a lot of work. You only need to provide the following two additional overloaded operators as member functions:
       </p>
       <pre class="calibre26" id="c09-code-0169"><code class="calibre21">[[nodiscard]] bool operator==(double rhs) const;</code>
<code class="calibre21">[[nodiscard]] std::partial_ordering operator&lt;=&gt;(double rhs) const;</code></pre>
       <p class="calibre13">
        These are implemented as follows:
       </p>
       <pre class="calibre26" id="c09-code-0170"><code class="calibre21">bool SpreadsheetCell::operator==(double rhs) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return getValue() == rhs;</code>
<code class="calibre21">}</code>
<code class="calibre21">partial_ordering SpreadsheetCell::operator&lt;=&gt;(double rhs) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return getValue() &lt;=&gt; rhs;</code>
<code class="calibre21">}</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c09-sec-0086">
       </span>
       <h4 class="calibre29" id="head-4-190">
        Compiler-Generated Comparison Operators
       </h4>
       <p class="calibre13" id="c09-para-0340">
        Looking at the implementation of
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        for
        <code class="calibre21">
         SpreadsheetCell
        </code>
        , they simply compare all data members. In such a case, you can reduce the number of lines of code needed even further, as
        <span aria-label="349" class="calibre20" epub:type="pagebreak" id="Page_349" role="doc-pagebreak">
        </span>
        C++20 (and later) can write those for you. Just as, for example, a copy constructor can be explicitly defaulted,
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        can also be defaulted in which case the compiler writes them for you and implements them by comparing each data member in turn in the order they are declared in the class definition, also known as a
        <i class="calibre18">
         member-wise lexicographical comparison
        </i>
        .
       </p>
       <p class="calibre13">
        Additionally, if you just explicitly default
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , the compiler automatically includes a defaulted
        <code class="calibre21">
         operator==
        </code>
        as well. So, for the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        version without the explicit
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        for
        <code class="calibre21">
         double
        </code>
        s (I'll come back to this later in this section), you can simply write the following
        <i class="calibre18">
         single line
        </i>
        of code to add full support for all six comparison operators to compare two
        <code class="calibre21">
         SpreadsheetCell
        </code>
        s:
       </p>
       <pre class="calibre26" id="c09-code-0171"><code class="calibre21">[[nodiscard]] std::partial_ordering operator&lt;=&gt;(</code>
<code class="calibre21">    const SpreadsheetCell&amp;) const = default;</code></pre>
       <p class="calibre13">
        Furthermore, you can use
        <code class="calibre21">
         auto
        </code>
        as the return type for
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , in which case the compiler deduces the return type based on the return types of the
        <code class="calibre21">
         &lt;=&gt;
        </code>
        operator for the data members:
       </p>
       <pre class="calibre26" id="c09-code-0172"><code class="calibre21">[[nodiscard]] auto operator&lt;=&gt;(const SpreadsheetCell&amp;) const = default;</code></pre>
       <p class="calibre13" id="c09-para-0343">
        If not all data members of the class have an accessible
        <code class="calibre21">
         operator==
        </code>
        , then a defaulted
        <code class="calibre21">
         operator==
        </code>
        for the class is implicitly deleted.
       </p>
       <p class="calibre13" id="c09-para-0344">
        If the class has data members that do not support
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , a defaulted
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        falls back to using
        <code class="calibre21">
         operator&lt;
        </code>
        and
        <code class="calibre21">
         ==
        </code>
        for those data members. In that case, return type deduction won't work and you need to explicitly specify the return type to be either
        <code class="calibre21">
         strong_ordering
        </code>
        ,
        <code class="calibre21">
         partial_ordering
        </code>
        , or
        <code class="calibre21">
         weak_ordering
        </code>
        . If the data members don't even have an accessible
        <code class="calibre21">
         operator&lt;
        </code>
        and
        <code class="calibre21">
         ==
        </code>
        , then the defaulted
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        is implicitly deleted.
       </p>
       <p class="calibre13" id="c09-para-0345">
        To summarize, for the compiler to be able to write a defaulted &lt;=&gt; operator, all data members of the class need to either support
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , in which case the return type can be
        <code class="calibre21">
         auto
        </code>
        , or
        <code class="calibre21">
         operator&lt;
        </code>
        and
        <code class="calibre21">
         ==
        </code>
        , in which case the return type cannot be
        <code class="calibre21">
         auto
        </code>
        . Since
        <code class="calibre21">
         SpreadsheetCell
        </code>
        has a single
        <code class="calibre21">
         double
        </code>
        as data member, the compiler deduces the return type to be
        <code class="calibre21">
         partial_ordering
        </code>
        .
       </p>
       <p class="calibre13">
        In the beginning of this section, I mentioned that this single explicitly defaulted
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        works for the
        <code class="calibre21">
         SpreadsheetCell
        </code>
        version without the explicit
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        for
        <code class="calibre21">
         double
        </code>
        s. If you do add those explicit
        <code class="calibre21">
         double
        </code>
        versions, you are adding a user-declared
        <code class="calibre21">
         operator==(double)
        </code>
        . Because of this, the compiler will no longer automatically generate an
        <code class="calibre21">
         operator==(const SpreadsheetCell&amp;)
        </code>
        , so you have to explicitly default one yourself as follows:
       </p>
       <pre class="calibre26" id="c09-code-0173"><code class="calibre21">export class SpreadsheetCell</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">        [[nodiscard]] auto operator&lt;=&gt;(const SpreadsheetCell&amp;) const = default;</code>
<code class="calibre21">        <b class="calibre14">[[nodiscard]] bool operator==(const SpreadsheetCell&amp;) const = default;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">        [[nodiscard]] bool operator==(double rhs) const;</code>
<code class="calibre21">        [[nodiscard]] std::partial_ordering operator&lt;=&gt;(double rhs) const;</code>
<code class="calibre21">        <span class="color">// Omitted for brevity</span></code>
<code class="calibre21">};</code></pre>
       <p class="calibre13" id="c09-para-0347">
        If you can explicitly default
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        for your class, I recommend doing so instead of implementing it yourself. By letting the compiler write it for you, it will stay up-to-date with newly added or modified data members. If you implement the operator yourself, then whenever you add data
        <span aria-label="350" class="calibre20" epub:type="pagebreak" id="Page_350" role="doc-pagebreak">
        </span>
        members or change existing data members, you need to remember to update your implementation of
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        . The same holds for
        <code class="calibre21">
         operator==
        </code>
        in case it's not automatically generated by the compiler.
       </p>
       <p class="calibre13">
        It is only possible to explicitly default
        <code class="calibre21">
         operator==
        </code>
        and
        <code class="calibre21">
         &lt;=&gt;
        </code>
        when they have as parameter a reference-to-
        <code class="calibre21">
         const
        </code>
        to the class type for which the operators are defined. For example, the following does not work:
       </p>
       <pre class="calibre26" id="c09-code-0174"><code class="calibre21">[[nodiscard]] auto operator&lt;=&gt;(<b class="calibre14">double</b>) const = default;  <span class="color">// Does not work!</span></code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            To add support for all six comparison operators to a class in C++20 or later:
           </i>
          </p>
          <ul class="check4" id="c09-list-0003">
           <li class="calibre9" id="c09-li-0018">
            <i class="calibre18">
             If a defaulted
            </i>
            <code class="calibre21">
             operator&lt;=&gt;
            </code>
            <i class="calibre18">
             works for your class, then a single line of code to explicitly default
            </i>
            <code class="calibre21">
             operator&lt;=&gt;
            </code>
            <i class="calibre18">
             as a member function is all you need to do. In certain cases, you might need to explicitly default
            </i>
            <code class="calibre21">
             operator==
            </code>
            <i class="calibre18">
             as well
            </i>
            .
           </li>
           <li class="calibre9" id="c09-li-0019">
            <i class="calibre18">
             Otherwise, just overload and implement
            </i>
            <code class="calibre21">
             operator==
            </code>
            <i class="calibre18">
             and
            </i>
            <code class="calibre21">
             &lt;=&gt;
            </code>
            <i class="calibre18">
             as member functions
            </i>
            .
           </li>
          </ul>
          <p class="calibre25" id="c09-para-0351">
           <i class="calibre18">
            There is no need to manually implement the other comparison operators
           </i>
           .
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-117" class="calibre2">
     <span class="calibre" id="c09-sec-0088">
     </span>
     <h2 class="calibre6" id="head-2-117">
      BUILDING STABLE INTERFACES
     </h2>
     <p class="calibre13" id="c09-para-0352">
      Now that you understand all the syntax of writing classes in C++, it helps to revisit the design principles from
      <a class="calibre5" href="c05.xhtml">
       Chapter 5
      </a>
      , “Designing with Classes,” and
      <a class="calibre5" href="c06.xhtml">
       Chapter 6
      </a>
      , “Designing for Reuse.” Classes are the main unit of abstraction in C++. You should apply the principles of abstraction to your classes to separate the interface from the implementation as much as possible. Specifically, you should make all data members
      <code class="calibre21">
       private
      </code>
      and optionally provide getter and setter member functions. This is how the
      <code class="calibre21">
       SpreadsheetCell
      </code>
      class is implemented:
      <code class="calibre21">
       m_value
      </code>
      is
      <code class="calibre21">
       private
      </code>
      , while the
      <code class="calibre21">
       public set()
      </code>
      member function sets the value, and the
      <code class="calibre21">
       public getValue()
      </code>
      and
      <code class="calibre21">
       getString()
      </code>
      retrieve the value.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-sec-0089">
      </span>
      <h3 class="calibre27" id="head-3-205">
       Using Interface and Implementation Classes
      </h3>
      <p class="calibre13" id="c09-para-0353">
       Even with the preceding measures and the best design principles, the C++ language is fundamentally unfriendly to the principle of abstraction. The syntax requires you to combine your
       <code class="calibre21">
        public
       </code>
       interfaces and
       <code class="calibre21">
        private
       </code>
       (or
       <code class="calibre21">
        protected
       </code>
       ) data members and member functions together in one class definition, thereby exposing some of the internal implementation details of the class to its clients. The downside of this is that if you have to add new non-
       <code class="calibre21">
        public
       </code>
       member functions or data members to your class, all the clients of the class have to be recompiled. This can become a burden in bigger projects.
      </p>
      <p class="calibre13" id="c09-para-0354">
       The good news is that you can make your interfaces a lot cleaner and hide all implementation details, resulting in stable interfaces. The bad news is that it takes a bit of coding. The basic principle is to define two classes for every class you want to write: the
       <i class="calibre18">
        interface class
       </i>
       and the
       <i class="calibre18">
        implementation class
       </i>
       . The implementation class is identical to the class you would have written if you were not taking this
       <span aria-label="351" class="calibre20" epub:type="pagebreak" id="Page_351" role="doc-pagebreak">
       </span>
       approach. The interface class presents
       <code class="calibre21">
        public
       </code>
       member functions identical to those of the implementation class, but it has only one data member: a pointer to an implementation class object. This is called the
       <i class="calibre18">
        pimpl idiom
       </i>
       ,
       <i class="calibre18">
        private implementation idiom
       </i>
       , or
       <i class="calibre18">
        bridge pattern
       </i>
       . The interface class member function implementations simply call the equivalent member functions on the implementation class object. The result of this is that no matter how the implementation changes, it has no impact on the
       <code class="calibre21">
        public
       </code>
       interface class. This reduces the need for recompilation. None of the clients that use the interface class need to be recompiled if the implementation (and only the implementation) changes. Note that this idiom works only if the single data member is a pointer to the implementation class. If it were a by-value data member, clients would have to recompile when the definition of the implementation class changes.
      </p>
      <p class="calibre13">
       To use this approach with the
       <code class="calibre21">
        Spreadsheet
       </code>
       class, define the following public interface class, called
       <code class="calibre21">
        Spreadsheet
       </code>
       . The important parts are highlighted.
      </p>
      <pre class="calibre26" id="c09-code-0175"><code class="calibre21">export module spreadsheet;</code>
<code class="calibre21"> </code>
<code class="calibre21">export import spreadsheet_cell;</code>
<code class="calibre21"><b class="calibre14">import std;</b></code>
<code class="calibre21"> </code>
<code class="calibre21">export class Spreadsheet</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Spreadsheet(</code>
<code class="calibre21">            std::size_t width = MaxWidth, std::size_t height = MaxHeight);</code>
<code class="calibre21">        Spreadsheet(const Spreadsheet&amp; src);</code>
<code class="calibre21">        Spreadsheet(Spreadsheet&amp;&amp;) noexcept;</code>
<code class="calibre21">        ˜Spreadsheet();</code>
<code class="calibre21"> </code>
<code class="calibre21">        Spreadsheet&amp; operator=(const Spreadsheet&amp; rhs);</code>
<code class="calibre21">        Spreadsheet&amp; operator=(Spreadsheet&amp;&amp;) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">        void setCellAt(std::size_t x, std::size_t y, const SpreadsheetCell&amp; cell);</code>
<code class="calibre21">        SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y);</code>
<code class="calibre21">        const SpreadsheetCell&amp; getCellAt(std::size_t x, std::size_t y) const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        std::size_t getId() const;</code>
<code class="calibre21"> </code>
<code class="calibre21">        static constexpr std::size_t MaxHeight { 100 };</code>
<code class="calibre21">        static constexpr std::size_t MaxWidth { 100 };</code>
<code class="calibre21"> </code>
<code class="calibre21">        void swap(Spreadsheet&amp; other) noexcept;</code>
<code class="calibre21"> </code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">class Impl;</b></code>
<code class="calibre21">        <b class="calibre14">std::unique_ptr&lt;Impl&gt; m_impl;</b></code>
<code class="calibre21">};</code>
<code class="calibre21">export void swap(Spreadsheet&amp; first, Spreadsheet&amp; second) noexcept;</code></pre>
      <p class="calibre13" id="c09-para-0356">
       The implementation class,
       <code class="calibre21">
        Impl
       </code>
       , is a
       <code class="calibre21">
        private
       </code>
       nested class, because no one else besides the
       <code class="calibre21">
        Spreadsheet
       </code>
       class needs to know about this implementation class. The
       <code class="calibre21">
        Spreadsheet
       </code>
       class now contains only one data member: a pointer to an
       <code class="calibre21">
        Impl
       </code>
       instance. The
       <code class="calibre21">
        public
       </code>
       member functions are identical to the old
       <code class="calibre21">
        Spreadsheet
       </code>
       .
      </p>
      <p class="calibre13">
       <span aria-label="352" class="calibre20" epub:type="pagebreak" id="Page_352" role="doc-pagebreak">
       </span>
       The nested
       <code class="calibre21">
        Spreadsheet::Impl
       </code>
       class is defined in a
       <code class="calibre21">
        spreadsheet
       </code>
       module implementation file. It should be hidden from clients, so the
       <code class="calibre21">
        Impl
       </code>
       class is not exported. The
       <code class="calibre21">
        Spreadsheet.cpp
       </code>
       module implementation file starts as follows:
      </p>
      <pre class="calibre26" id="c09-code-0176"><code class="calibre21">module spreadsheet;</code>
<code class="calibre21">import std;</code>
<code class="calibre21">using namespace std;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Spreadsheet::Impl class definition.</span></code>
<code class="calibre21">class Spreadsheet::Impl</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        Impl(size_t width, size_t height);</code>
<code class="calibre21">        <span class="color">// Remainder omitted for brevity.</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       This
       <code class="calibre21">
        Impl
       </code>
       class has almost the same interface as the original
       <code class="calibre21">
        Spreadsheet
       </code>
       class. You can find the full definition in the downloadable source code archive. For the member function implementations, you need to remember that
       <code class="calibre21">
        Impl
       </code>
       is a nested class; hence, you need to specify the scope as
       <code class="calibre21">
        Spreadsheet::Impl
       </code>
       . So, for the constructor, it becomes
       <code class="calibre21">
        Spreadsheet::Impl::Impl(…)
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0177"><code class="calibre21"><span class="color">// Spreadsheet::Impl member function definitions.</span></code>
<code class="calibre21">Spreadsheet::Impl::Impl(size_t width, size_t height)</code>
<code class="calibre21">    : m_id { ms_counter++ }</code>
<code class="calibre21">    , m_width { min(width, Spreadsheet::MaxWidth) }</code>
<code class="calibre21">    , m_height { min(height, Spreadsheet::MaxHeight) }</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_cells = new SpreadsheetCell*[m_width];</code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; m_width; ++i) {</code>
<code class="calibre21">        m_cells[i] = new SpreadsheetCell[m_height];</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code>
<code class="calibre21"><span class="color">// Other member function definitions omitted for brevity.</span></code></pre>
      <p class="calibre13">
       Now that the
       <code class="calibre21">
        Spreadsheet
       </code>
       class has a
       <code class="calibre21">
        unique_ptr
       </code>
       to an
       <code class="calibre21">
        Impl
       </code>
       instance, the
       <code class="calibre21">
        Spreadsheet
       </code>
       class needs to have a user-declared destructor. Since we don't need to do anything in this destructor, it can be defaulted in the implementation file as follows:
      </p>
      <pre class="calibre26" id="c09-code-0178"><code class="calibre21">Spreadsheet::˜Spreadsheet() = default;</code></pre>
      <p class="calibre13" id="c09-para-0360">
       In fact, it must be defaulted in the implementation file and not directly in the class definition. The reason is that the
       <code class="calibre21">
        Impl
       </code>
       class is only forward declared in the
       <code class="calibre21">
        Spreadsheet
       </code>
       class definition; that is, the compiler knows there will be a
       <code class="calibre21">
        Spreadsheet::Impl
       </code>
       class somewhere, but at this time it does not know the definition yet. As such, you cannot default the destructor in the class definition, because then the compiler would try to use the destructor of the as of yet undefined
       <code class="calibre21">
        Impl
       </code>
       class. The same is true when defaulting other member functions in this case, such as the move constructor and move assignment operator.
      </p>
      <p class="calibre13">
       The implementations of the
       <code class="calibre21">
        Spreadsheet
       </code>
       member functions, such as
       <code class="calibre21">
        setCellAt()
       </code>
       and
       <code class="calibre21">
        getCellAt()
       </code>
       , just pass the request on to the underlying
       <code class="calibre21">
        Impl
       </code>
       object:
      </p>
      <pre class="calibre26" id="c09-code-0179"><code class="calibre21">void Spreadsheet::setCellAt(size_t x, size_t y, const SpreadsheetCell&amp; cell)</code>
<code class="calibre21">{</code>
<code class="calibre21">    m_impl-&gt;setCellAt(x, y, cell);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="353" class="calibre20" epub:type="pagebreak" id="Page_353" role="doc-pagebreak"></span><code class="calibre21">const SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y) const</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_impl-&gt;getCellAt(x, y);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">SpreadsheetCell&amp; Spreadsheet::getCellAt(size_t x, size_t y)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return m_impl-&gt;getCellAt(x, y);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The constructors for the
       <code class="calibre21">
        Spreadsheet
       </code>
       must construct a new
       <code class="calibre21">
        Impl
       </code>
       to do its work:
      </p>
      <pre class="calibre26" id="c09-code-0180"><code class="calibre21">Spreadsheet::Spreadsheet(size_t width, size_t height)</code>
<code class="calibre21">{</code>
<code class="calibre21">    : m_impl { make_unique&lt;Impl&gt;(width, height) }</code>
<code class="calibre21">}}</code>
<code class="calibre21"> </code>
<code class="calibre21">Spreadsheet::Spreadsheet(const Spreadsheet&amp; src)</code>
<code class="calibre21">    : m_impl { make_unique&lt;Impl&gt;(*src.m_impl) }</code>
<code class="calibre21">{</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0363">
       The copy constructor looks a bit strange because it needs to copy the underlying
       <code class="calibre21">
        Impl
       </code>
       from the source
       <code class="calibre21">
        Spreadsheet
       </code>
       . The copy constructor takes a reference to an
       <code class="calibre21">
        Impl
       </code>
       , not a pointer, so you must dereference the
       <code class="calibre21">
        m_impl
       </code>
       pointer to get to the object itself.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        Spreadsheet
       </code>
       assignment operator must similarly pass on the assignment to the underlying
       <code class="calibre21">
        Impl
       </code>
       :
      </p>
      <pre class="calibre26" id="c09-code-0181"><code class="calibre21">Spreadsheet&amp; Spreadsheet::operator=(const Spreadsheet&amp; rhs)</code>
<code class="calibre21">{</code>
<code class="calibre21">    *m_impl = *rhs.m_impl;</code>
<code class="calibre21">    return *this;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c09-para-0365">
       The first line in the assignment operator looks a little odd. The
       <code class="calibre21">
        Spreadsheet
       </code>
       assignment operator needs to forward the call to the
       <code class="calibre21">
        Impl
       </code>
       assignment operator, which runs only when you copy direct objects. By dereferencing the
       <code class="calibre21">
        m_impl
       </code>
       pointers, you force direct object assignment, which causes the assignment operator of
       <code class="calibre21">
        Impl
       </code>
       to be called.
      </p>
      <p class="calibre13">
       The
       <code class="calibre21">
        swap()
       </code>
       member function simply swaps the single data member:
      </p>
      <pre class="calibre26" id="c09-code-0182"><code class="calibre21">void Spreadsheet::swap(Spreadsheet&amp; other) noexcept</code>
<code class="calibre21">{</code>
<code class="calibre21">    std::swap(m_impl, other.m_impl);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This technique to truly separate the interface from the implementation is powerful. Although it is a bit clumsy at first, once you get used to it, you will find it natural to work with. However, it's not common practice in most workplace environments, so you might find some resistance to trying it from your coworkers. The most compelling argument in favor of it is not the aesthetic one of splitting out the interface, but the speedup in build time if the implementation of the class changes. When a class is not using the pimpl idiom, a change to its implementation details might trigger a long rebuild. For example, adding a new data member to a class definition triggers a rebuild of all other source files that use this class definition. With the pimpl idiom, you can modify the implementation class
       <span aria-label="354" class="calibre20" epub:type="pagebreak" id="Page_354" role="doc-pagebreak">
       </span>
       definition as much as you like, and as long as the public interface class remains untouched, it won't trigger a long rebuild.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c09-para-0368">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           With stable interface classes, build times can be reduced
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c09-para-0369">
       An alternative to separating the implementation from the interface is to use an abstract interface—that is, an interface with only pure virtual member functions—and then have an implementation class that implements that interface. That's a topic for the next chapter.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-118" class="calibre2">
     <span class="calibre" id="c09-sec-0091">
     </span>
     <h2 class="calibre6" id="head-2-118">
      SUMMARY
     </h2>
     <p class="calibre13" id="c09-para-0370">
      This chapter, along with
      <a class="calibre5" href="c08.xhtml">
       Chapter 8
      </a>
      , provided all the tools you need to write solid, well-designed classes, and to use objects effectively.
     </p>
     <p class="calibre13" id="c09-para-0371">
      You discovered that dynamic memory allocation in objects presents new challenges: you need to implement a destructor, copy constructor, copy assignment operator, move constructor, and move assignment operator, which properly copy, move, and free your memory. You learned how to prevent pass-by-value and assignment by explicitly deleting the copy constructor and assignment operator. You discovered the copy-and-swap idiom to implement copy assignment operators and the move-and-swap idiom to implement move assignment operators, as well as learned about the rule of zero.
     </p>
     <p class="calibre13" id="c09-para-0372">
      You read more about different kinds of data members, including
      <code class="calibre21">
       static
      </code>
      ,
      <code class="calibre21">
       const
      </code>
      , reference-to-
      <code class="calibre21">
       const
      </code>
      , and
      <code class="calibre21">
       mutable
      </code>
      members. You also learned about
      <code class="calibre21">
       static
      </code>
      ,
      <code class="calibre21">
       inline
      </code>
      , and
      <code class="calibre21">
       const
      </code>
      member functions, member function overloading, and default arguments. This chapter also described nested class definitions, and
      <code class="calibre21">
       friend
      </code>
      classes, functions, and member functions.
     </p>
     <p class="calibre13" id="c09-para-0373">
      You encountered operator overloading and learned how to overload the arithmetic and comparison operators, both as global functions and as class member functions. You also discovered how the three-way comparison operator makes adding comparison support to your classes so much easier.
     </p>
     <p class="calibre13" id="c09-para-0374">
      Finally, you learned how to take abstraction to the extreme by providing separate interface and implementation classes.
     </p>
     <p class="calibre13" id="c09-para-0375">
      Now that you're fluent in the language of object-oriented programming, it's time to tackle inheritance, which is covered next in
      <a class="calibre5" href="c10_split_000.xhtml">
       Chapter 10
      </a>
      , “Discovering Inheritance Techniques.”
     </p>
    </section>
    <section aria-labelledby="head-2-119" class="calibre2">
     <span class="calibre" id="c09-sec-0092">
     </span>
     <h2 class="calibre6" id="head-2-119">
      EXERCISES
     </h2>
     <p class="calibre13" id="c09-para-0376">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c09-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c09-ex-0001">
        <b class="calibre14">
         Exercise 9-1:
        </b>
        Take your implementation of the
        <code class="calibre21">
         Person
        </code>
        class from Exercise 8-3 and adapt it to pass strings in the most optimal way you can think of. Additionally, add a move constructor
        <span aria-label="355" class="calibre20" epub:type="pagebreak" id="Page_355" role="doc-pagebreak">
        </span>
        and move assignment operator to it. In both member functions, write a message to the console so you can track when they get called. Implement any additional member functions you need for implementing the move member functions and for improving the implementation of other member functions from Exercise 8-3 to avoid code duplication. Modify
        <code class="calibre21">
         main()
        </code>
        to test your member functions.
       </li>
       <li class="calibre9" id="c09-ex-0002">
        <b class="calibre14">
         Exercise 9-2:
        </b>
        Take the Person class from Exercise 8-4. Just as for Exercise 9-1, make changes to pass strings in the most optimal way. Then add full support for all six comparison operators to compare two Person objects. Try to implement this support in the least amount of code. Test your implementation by performing all kinds of comparisons in
        <code class="calibre21">
         main()
        </code>
        . How are
        <code class="calibre21">
         Person
        </code>
        s ordered? Is the ordering happening based on the first name, based on the last name, or based on a combination?
       </li>
       <li class="calibre9" id="c09-ex-0003">
        <b class="calibre14">
         Exercise 9-3:
        </b>
        Before C++20, adding support for all six comparison operators required a bit more lines of code. Start from the
        <code class="calibre21">
         Person
        </code>
        class from Exercise 9-2, remove the
        <code class="calibre21">
         operator&lt;=&gt;
        </code>
        , and add the necessary code to add all comparison operators to compare two
        <code class="calibre21">
         Person
        </code>
        objects without using
        <code class="calibre21">
         &lt;=&gt;
        </code>
        . Perform the same set of tests as you've implemented for Exercise 9-2.
       </li>
       <li class="calibre9" id="c09-ex-0004">
        <b class="calibre14">
         Exercise 9-4:
        </b>
        In this exercise, you'll practice writing stable interfaces. Take your
        <code class="calibre21">
         Person
        </code>
        class from Exercise 8-4 and split it into a stable public interface class and a separate implementation class.
       </li>
       <li class="calibre9" id="c09-ex-0005">
        <b class="calibre14">
         Exercise 9-5:
        </b>
        Start from your solution for Exercise 9-2, and optimize the
        <code class="calibre21">
         getFirstName()
        </code>
        ,
        <code class="calibre21">
         getLastName()
        </code>
        , and
        <code class="calibre21">
         getInitials()
        </code>
        member functions for when these are called on rvalues.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c09_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c09_2">
     NOTES
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c09-note-0001" id="c09-note-0001" role="doc-backlink">
       1
      </a>
      Technically, the C++ standard defines three more categories (xvalues, prvalues, and glvalues), but those details are not important for the current discussion.
     </li>
     <li class="noteentry">
      <a class="calibre5" href="#R_c09-note-0002" id="c09-note-0002" role="doc-backlink">
       2
      </a>
      Guideline C.65 of the C++ Core Guidelines (see
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography”) states, “Make move assignment safe for self-assignment.”
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
