<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   4
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_011.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_013.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div class="calibre2" id="_idContainer079">
    <h1 class="chapter-number" id="_idParaDest-89">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor089">
     </a>
     4
    </h1>
    <h1 class="calibre5" id="_idParaDest-90">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor090">
     </a>
     QPainter and 2D Graphics
    </h1>
    <p class="calibre3">
     In this chapter, we will learn how to render 2D graphics on screen with Qt. Internally, Qt uses a low-level class called
     <strong class="source-inline">
      QPainter
     </strong>
     to render its widgets on the main window. Qt allows us to access and use the
     <strong class="source-inline">
      QPainter
     </strong>
     class for drawing vector graphics, text, 2D images, and even
     <span>
      3D graphics.
     </span>
    </p>
    <p class="calibre3">
     You can make use of the
     <strong class="source-inline">
      QPainter
     </strong>
     class to create your own custom widgets or to create programs that rely heavily on rendering computer graphics such as video games, photo editors, and 3D
     <span>
      modeling tools.
     </span>
    </p>
    <p class="calibre3">
     In this chapter, we’re going to cover the following
     <span>
      main topics:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      Drawing basic shapes on
      <span>
       the screen
      </span>
     </li>
     <li class="calibre14">
      Exporting shapes to
      <strong class="bold">
       Scalable Vector Graphics
      </strong>
      (
      <span>
       <strong class="bold">
        SVG
       </strong>
      </span>
      <span>
       ) files
      </span>
     </li>
     <li class="calibre14">
      <span>
       <strong class="bold">
        Coordinate transformation
       </strong>
      </span>
     </li>
     <li class="calibre14">
      Displaying images
      <span>
       on screen
      </span>
     </li>
     <li class="calibre14">
      Applying image effects
      <span>
       to graphics
      </span>
     </li>
     <li class="calibre14">
      Creating a basic
      <span>
       paint program
      </span>
     </li>
     <li class="calibre14">
      Rendering a 2D canvas
      <span>
       in QML
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-91">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor091">
     </a>
     Technical requirements
    </h1>
    <p class="calibre3">
     The technical requirements for this chapter include
     <strong class="bold">
      Qt 6.6.1 MinGW 64-bit
     </strong>
     and
     <strong class="bold">
      Qt Creator 12.0.2
     </strong>
     . All the code used in this chapter can be downloaded from the following GitHub
     <span>
      repository:
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04">
      <span>
       https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter04
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-92">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor092">
     </a>
     Drawing basic shapes on the screen
    </h1>
    <p class="calibre3">
     In this section, we will learn how to draw
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker275">
     </a>
     simple vector shapes (a line, a rectangle, a circle, and so on) and display text on the main window using the
     <strong class="source-inline">
      QPainter
     </strong>
     class. We will also learn how to change the drawing style of these vector shapes using the
     <span>
      <strong class="source-inline">
       QPen
      </strong>
     </span>
     <span>
      class.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-93">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor093">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s follow the steps listed here to display basic shapes in our
     <span>
      Qt window:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      First, let’s create a new
      <strong class="bold">
       Qt Widgets
      </strong>
      <span>
       <strong class="bold">
        Application
       </strong>
      </span>
      <span>
       project.
      </span>
     </li>
     <li class="calibre14">
      Open up
      <strong class="source-inline1">
       mainwindow.ui
      </strong>
      and remove the
      <strong class="source-inline1">
       menuBar
      </strong>
      ,
      <strong class="source-inline1">
       mainToolBar
      </strong>
      , and
      <strong class="source-inline1">
       statusBar
      </strong>
      objects so that we get a clean, empty main window. Right-click on the bar widgets and select
      <strong class="bold">
       Remove Menu Bar
      </strong>
      from the
      <span>
       pop-up menu:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer058">
      <img alt="Figure 4.1 – Removing the menu bar from the main window" class="calibre4" src="image/B20976_04_001.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.1 – Removing the menu bar from the main window
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Then, open up the
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      file and add the following code to include the
      <strong class="source-inline1">
       QPainter
      </strong>
      <span>
       header file:
      </span>
      <pre class="source-code">
#include &lt;QMainWindow&gt;
#include &lt;QPainter&gt;</pre>
     </li>
     <li class="calibre14">
      Then, declare the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      event handler below the
      <span>
       class destructor:
      </span>
      <pre class="source-code">
public:
explicit MainWindow(QWidget *parent = 0);
~MainWindow();
<strong class="bold1">virtual void paintEvent(QPaintEvent *event);</strong></pre>
     </li>
     <li class="calibre14">
      Next, open up the
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      file and define the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      <span>
       event handler:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {}</pre>
     </li>
     <li class="calibre14">
      After that, we will add
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker276">
      </a>
      text to the screen using the
      <strong class="source-inline1">
       QPainter
      </strong>
      class inside the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      event handler. We set the text font settings before drawing it on the screen at the position of
      <strong class="source-inline1">
       (
      </strong>
      <span>
       <strong class="source-inline1">
        20, 30)
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
QPainter textPainter;
textPainter.begin(this);
<strong class="bold1">textPainter.setFont(QFont("Times", 14, QFont::Bold));</strong>
<strong class="bold1">textPainter.drawText(QPoint(20, 30), "Testing");</strong>
textPainter.end();</pre>
     </li>
     <li class="calibre14">
      Then, we will draw a straight line that starts from
      <strong class="source-inline1">
       (50, 60)
      </strong>
      and ends at
      <strong class="source-inline1">
       (
      </strong>
      <span>
       <strong class="source-inline1">
        100, 100)
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
QPainter linePainter;
linePainter.begin(this);
<strong class="bold1">linePainter.drawLine(QPoint(50, 60), QPoint(100, 100));</strong>
linePainter.end();</pre>
     </li>
     <li class="calibre14">
      We can also easily draw a rectangle by calling the
      <strong class="source-inline1">
       drawRect()
      </strong>
      function using a
      <strong class="source-inline1">
       QPainter
      </strong>
      class. This time, however, we also apply a background pattern to the shape before
      <span>
       drawing it:
      </span>
      <pre class="source-code">
QPainter rectPainter;
rectPainter.begin(this);
<strong class="bold1">rectPainter.setBrush(Qt::BDiagPattern);</strong>
<strong class="bold1">rectPainter.drawRect(QRect(40, 120, 80, 30));</strong>
rectPainter.end();</pre>
     </li>
     <li class="calibre14">
      Next, declare a
      <strong class="source-inline1">
       QPen
      </strong>
      class, set its color to
      <strong class="source-inline1">
       red
      </strong>
      , and set its drawing style to
      <strong class="source-inline1">
       Qt::DashDotLine
      </strong>
      . Then, apply
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker277">
      </a>
      the
      <strong class="source-inline1">
       QPen
      </strong>
      class to
      <strong class="source-inline1">
       QPainter
      </strong>
      and draw an ellipse shape at
      <strong class="source-inline1">
       (80, 200)
      </strong>
      with a horizontal radius of
      <strong class="source-inline1">
       50
      </strong>
      and a vertical radius
      <span>
       of
      </span>
      <span>
       <strong class="source-inline1">
        20
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
QPen ellipsePen;
ellipsePen.setColor(Qt::red);
ellipsePen.setStyle(Qt::DashDotLine);
QPainter ellipsePainter;
ellipsePainter.begin(this);
ellipsePainter.setPen(ellipsePen);
ellipsePainter.drawEllipse(QPoint(80, 200), 50, 20);
ellipsePainter.end();</pre>
     </li>
     <li class="calibre14">
      We can also use the
      <strong class="source-inline1">
       QPainterPath
      </strong>
      class to define a shape before passing it over to the
      <strong class="source-inline1">
       QPainter
      </strong>
      class
      <span>
       for rendering:
      </span>
      <pre class="source-code">
QPainterPath rectPath;
rectPath.addRect(QRect(150, 20, 100, 50));
QPainter pathPainter;
pathPainter.begin(this);
pathPainter.setPen(QPen(Qt::red, 1, Qt::DashDotLine,
Qt::FlatCap, Qt::MiterJoin));
pathPainter.setBrush(Qt::yellow);
pathPainter.drawPath(rectPath);
pathPainter.end();</pre>
     </li>
     <li class="calibre14">
      You can also draw any
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker278">
      </a>
      other shapes by using
      <strong class="source-inline1">
       QPainterPath
      </strong>
      , such as
      <span>
       an ellipse:
      </span>
      <pre class="source-code">
QPainterPath ellipsePath;
ellipsePath.addEllipse(QPoint(200, 120), 50, 20);
QPainter ellipsePathPainter;
ellipsePathPainter.begin(this);
ellipsePathPainter.setPen(QPen(QColor(79, 106, 25), 5,
Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin));
ellipsePathPainter.setBrush(QColor(122, 163, 39));
ellipsePathPainter.drawPath(ellipsePath);
ellipsePathPainter.end();</pre>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       QPainter
      </strong>
      can also be used to draw an image file onto the screen. In the following example, we load an image file called
      <strong class="source-inline1">
       tux.png
      </strong>
      and draw it on the screen at the
      <strong class="source-inline1">
       (100,
      </strong>
      <span>
       <strong class="source-inline1">
        150)
       </strong>
      </span>
      <span>
       position:
      </span>
      <pre class="source-code">
QImage image;
image.load("tux.png");
QPainter imagePainter(this);
imagePainter.begin(this);
imagePainter.drawImage(QPoint(100, 150), image);
imagePainter.end();</pre>
     </li>
     <li class="calibre14">
      The final result should look something
      <span>
       like this:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer059">
      <img alt="Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines" class="calibre4" src="image/B20976_04_002.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.2 – Tux the penguin is overwhelmed by the shapes and lines
    </p>
    <h2 class="calibre7" id="_idParaDest-94">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor094">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     If you want to draw something on screen using
     <strong class="source-inline">
      QPainter
     </strong>
     , all you need to do is tell it what type of graphics it should be drawing (as in text, a vector shape, an image, a polygon) with the desired position and size. The
     <strong class="source-inline">
      QPen
     </strong>
     class determines what the outline of the graphic should
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker279">
     </a>
     look like, such as its color, line width, line style (solid, dashed, or dotted), cap style, join style, and so on. On the other hand,
     <strong class="source-inline">
      QBrush
     </strong>
     sets the style of the background of the graphics, such as the background color, pattern (solid color, gradient, dense brush, and crossing diagonal lines),
     <span>
      and pixmap.
     </span>
    </p>
    <p class="calibre3">
     The options for the graphics should be set before calling a
     <strong class="source-inline">
      draw
     </strong>
     function (such as
     <strong class="source-inline">
      drawLine()
     </strong>
     ,
     <strong class="source-inline">
      drawRect()
     </strong>
     , or
     <strong class="source-inline">
      drawEllipse()
     </strong>
     ). If your graphics do not appear on the screen and you see warnings such as
     <strong class="source-inline">
      QPainter::setPen: Painter not active
     </strong>
     and
     <strong class="source-inline">
      QPainter::setBrush: Painter not active
     </strong>
     appearing on the application output window in Qt Creator, it means that the
     <strong class="source-inline">
      QPainter
     </strong>
     class is not currently active and your program will not trigger its paint event. To solve this problem, set the main window as the parent of the
     <strong class="source-inline">
      QPainter
     </strong>
     class. Usually, if you’re writing code in the
     <strong class="source-inline">
      mainwindow.cpp
     </strong>
     file, all you need to do is to put
     <strong class="source-inline">
      this
     </strong>
     in the brackets when initializing
     <strong class="source-inline">
      QPainter
     </strong>
     . For example, note
     <span>
      the following:
     </span>
    </p>
    <pre class="source-code">
QPainter linePainter(this);</pre>
    <p class="calibre3">
     <strong class="source-inline">
      QImage
     </strong>
     can load images from both the computer directories and from the
     <span>
      program resources.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-95">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor095">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     Think of
     <strong class="source-inline">
      QPainter
     </strong>
     as a robot
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker280">
     </a>
     with a pen and an empty canvas. You just have to tell the
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker281">
     </a>
     robot what type of shape it should be drawing and its location on the canvas, then the robot will do its job based on
     <span>
      your description.
     </span>
    </p>
    <p class="calibre3">
     To make your life easier, the
     <strong class="source-inline">
      QPainter
     </strong>
     class also provides numerous functions, such as
     <strong class="source-inline">
      drawArc()
     </strong>
     ,
     <strong class="source-inline">
      drawEllipse()
     </strong>
     ,
     <strong class="source-inline">
      drawLine()
     </strong>
     ,
     <strong class="source-inline">
      drawRect()
     </strong>
     , and
     <strong class="source-inline">
      drawPie()
     </strong>
     , which allow you to easily render a predefined shape. In Qt, all the widget classes (including the main window) have an event handler called
     <strong class="source-inline">
      QWidget::paintEvent()
     </strong>
     . This event handler will be triggered whenever the operating system thinks that the main window should re-draw its widgets. Many things can lead to that decision, such as the main window being scaled, a widget changing its state (that is, a button being pressed), or functions such as
     <strong class="source-inline">
      repaint()
     </strong>
     or
     <strong class="source-inline">
      update()
     </strong>
     being invoked manually in the code. Different operating systems may behave differently when it comes to deciding whether or not to trigger the update event on the same set of conditions. If you’re making a program that requires continuous and consistent graphical updates, call
     <strong class="source-inline">
      repaint()
     </strong>
     or
     <strong class="source-inline">
      update()
     </strong>
     manually with
     <span>
      a timer.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-96">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor096">
     </a>
     Exporting shapes to SVG files
    </h1>
    <p class="calibre3">
     SVG is an XML-based language for
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker282">
     </a>
     describing 2D vector graphics. Qt provides classes for
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker283">
     </a>
     saving vector shapes as SVG files. This feature can be used to create a simple vector graphics editor similar to Adobe Illustrator and Inkscape. In the next example, we will continue using the same project file from the
     <span>
      previous example.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-97">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor097">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s learn how to create a simple program that displays SVG graphics
     <span>
      on screen:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      First of all, let’s create a
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker284">
      </a>
      menu bar by right-clicking the main window widget on the hierarchy window
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker285">
      </a>
      and selecting the
      <strong class="bold">
       Create Menu Bar
      </strong>
      option from the pop-up menu. After that, add a
      <strong class="bold">
       File
      </strong>
      option to the menu bar and a
      <strong class="bold">
       Save as SVG
      </strong>
      action
      <span>
       underneath it:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer060">
      <img alt="Figure 4.3 – Create a Save as SVG option on the menu bar" class="calibre4" src="image/B20976_04_003.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.3 – Create a Save as SVG option on the menu bar
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      After that, you will see an item called
      <strong class="bold">
       actionSave_as_SVG
      </strong>
      in the
      <strong class="bold">
       Action Editor
      </strong>
      window at the bottom of the Qt Creator window. Right-click on the item and choose
      <strong class="bold">
       Go to slot…
      </strong>
      from the pop-up menu. A window will now appear, which carries a list of slots available for the particular action. Choose the default signal, which is called
      <strong class="source-inline1">
       triggered()
      </strong>
      , and click the
      <span>
       <strong class="bold">
        OK
       </strong>
      </span>
      <span>
       button:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer061">
      <img alt="Figure 4.4 – Creating a slot function for the triggered() signal" class="calibre4" src="image/B20976_04_004.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.4 – Creating a slot function for the triggered() signal
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Once you have clicked
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker286">
      </a>
      the
      <strong class="bold">
       OK
      </strong>
      button, Qt Creator will switch over to the script editor. You will realize
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker287">
      </a>
      that a slot called
      <strong class="source-inline1">
       on_actionSave_as_SVG_triggered()
      </strong>
      has been automatically added to your main window class. At the bottom of your
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      file, you will see something
      <span>
       like this:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {}</pre>
     </li>
     <li class="calibre14">
      The preceding function is called when you click on the
      <strong class="bold">
       Save as SVG
      </strong>
      option from the menu bar. We will write our code within this function to save all the vector graphics into an SVG file. To do that, first of all, we need to include a class header called
      <strong class="source-inline1">
       QSvgGenerator
      </strong>
      at the top of our source file. This header is very important as it’s required for generating SVG files. Then, we also need to include another class header called
      <strong class="source-inline1">
       QFileDialog
      </strong>
      , which will be used to open the
      <span>
       save dialog:
      </span>
      <pre class="source-code">
#include &lt;QtSvg/QSvgGenerator&gt;
#include &lt;QFileDialog&gt;</pre>
     </li>
     <li class="calibre14">
      We also need to add the
      <strong class="source-inline1">
       svg
      </strong>
      module to our project file,
      <span>
       like so:
      </span>
      <pre class="source-code">
QT += core gui <strong class="bold1">svg</strong></pre>
     </li>
     <li class="calibre14">
      Then, create a new function called
      <strong class="source-inline1">
       paintAll()
      </strong>
      within the
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      file, as shown in the
      <span>
       following code:
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    virtual void paintEvent(QPaintEvent *event);
<strong class="bold1">    void paintAll(QSvgGenerator *generator = 0);</strong></pre>
     </li>
     <li class="calibre14">
      After that, in the
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      file, move all the code from
      <strong class="source-inline1">
       paintEvent()
      </strong>
      to the
      <strong class="source-inline1">
       paintAll()
      </strong>
      function. Then, replace all the individual
      <strong class="source-inline1">
       QPainter
      </strong>
      objects
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker288">
      </a>
      with a single, unified
      <strong class="source-inline1">
       QPainter
      </strong>
      for drawing all the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker289">
      </a>
      graphics. Also, call the
      <strong class="source-inline1">
       begin()
      </strong>
      function before drawing anything and call the
      <strong class="source-inline1">
       end()
      </strong>
      function after finishing drawing. The code should look
      <span>
       like this:
      </span>
      <pre class="source-code">
void MainWindow::paintAll(QSvgGenerator *generator) {
    <strong class="bold1">QPainter painter;</strong>
<strong class="bold1">     if (engine)</strong>
<strong class="bold1">         painter.begin(engine);</strong>
<strong class="bold1">     else</strong>
<strong class="bold1">         painter.begin(this);</strong>
<strong class="bold1">     painter.setFont(QFont("Times", 14, QFont::Bold));</strong>
<strong class="bold1">     painter.drawText(QPoint(20, 30), "Testing");</strong>
<strong class="bold1">     painter.drawLine(QPoint(50, 60), QPoint(100, 100));</strong>
<strong class="bold1">     painter.setBrush(Qt::BDiagPattern);</strong>
<strong class="bold1">     painter.drawRect(QRect(40, 120, 80, 30));</strong></pre>
     </li>
     <li class="calibre14">
      We go on to create
      <strong class="bold">
       ellipsePen
      </strong>
      <span>
       and
      </span>
      <span>
       <strong class="bold">
        rectPath
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    QPen ellipsePen;
    ellipsePen.setColor(Qt::red);
ellipsePen.setStyle(Qt::DashDotLine);
    painter.setPen(ellipsePen);
    painter.drawEllipse(QPoint(80, 200), 50, 20);
    QPainterPath rectPath;
    rectPath.addRect(QRect(150, 20, 100, 50));
    painter.setPen(QPen(Qt::red, 1, Qt::DashDotLine, Qt::FlatCap, Qt::MiterJoin));
    painter.setBrush(Qt::yellow);
    painter.drawPath(rectPath);</pre>
     </li>
     <li class="calibre14">
      Then, we go
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker290">
      </a>
      on to create
      <strong class="source-inline1">
       ellipsePath
      </strong>
      <span>
       and
      </span>
      <span>
       <strong class="source-inline1">
        image
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
    QPainterPath ellipsePath;
    ellipsePath.addEllipse(QPoint(200, 120), 50, 20);
    painter.setPen(QPen(QColor(79, 106, 25), 5, Qt::SolidLine, Qt::FlatCap, Qt::MiterJoin));
    painter.setBrush(QColor(122, 163, 39));
    painter.drawPath(ellipsePath);
    QImage image;
    image.load("tux.png");
    painter.drawImage(QPoint(100, 150), image);
    painter.end();
}</pre>
     </li>
     <li class="calibre14">
      Since we have
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker291">
      </a>
      moved all the code from
      <strong class="source-inline1">
       paintEvent()
      </strong>
      to
      <strong class="source-inline1">
       paintAll()
      </strong>
      , we shall now call the
      <strong class="source-inline1">
       paintAll()
      </strong>
      function inside
      <strong class="source-inline1">
       paintEvent()
      </strong>
      ,
      <span>
       like so:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold1">paintAll();</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, we will write the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker292">
      </a>
      code for exporting the graphics as an SVG file. The
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker293">
      </a>
      code will be written inside the slot function called
      <strong class="source-inline1">
       on_actionSave_as_SVG_triggered()
      </strong>
      , which was generated by Qt. We start by calling the save file dialog and obtain the directory path with the desired filename from
      <span>
       the user:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {
    <strong class="bold1">QString filePath = QFileDialog::getSaveFileName(this, «Save SVG», «», «SVG files (*.svg)»);</strong>
<strong class="bold1">    if (filePath == "")</strong>
<strong class="bold1">        return;</strong>
}</pre>
     </li>
     <li class="calibre14">
      After that, create a
      <strong class="source-inline1">
       QSvgGenerator
      </strong>
      object and save the graphics to an SVG file by passing the
      <strong class="source-inline1">
       QSvgGenerator
      </strong>
      object to the
      <span>
       <strong class="source-inline1">
        paintAll()
       </strong>
      </span>
      <span>
       function:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_as_SVG_triggered() {
    QString filePath = QFileDialog::getSaveFileName(this, "Save
SVG", "", "SVG files (*.svg)");
    if (filePath == "")
        return;
    <strong class="bold1">QSvgGenerator generator;</strong>
<strong class="bold1">    generator.setFileName(filePath);</strong>
<strong class="bold1">    generator.setSize(QSize(this-&gt;width(), this-&gt;height()));</strong>
<strong class="bold1">    generator.setViewBox(QRect(0, 0, this-&gt;width(), this-&gt;height()));</strong>
<strong class="bold1">    generator.setTitle("SVG Example");</strong>
<strong class="bold1">    generator.setDescription("This SVG file is generated by Qt.");</strong>
<strong class="bold1">    paintAll(&amp;generator);</strong>
}</pre>
     </li>
     <li class="calibre14">
      Now, compile and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker294">
      </a>
      run the program and you should be able to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker295">
      </a>
      export the graphics by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       Save
      </strong>
      <span>
       <strong class="bold">
        as SVG
       </strong>
      </span>
      <span>
       :
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer062">
      <img alt="Figure 4.5 – Comparing the results between our program and the SVG file on a web browser" class="calibre4" src="image/B20976_04_005.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.5 – Comparing the results between our program and the SVG file on a web browser
    </p>
    <h2 class="calibre7" id="_idParaDest-98">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor098">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     By default,
     <strong class="source-inline">
      QPainter
     </strong>
     will use the paint engine from its parent object to draw the graphics assigned to it. If you don’t assign any parent to
     <strong class="source-inline">
      QPainter
     </strong>
     , you can manually assign a paint engine to it, which is what we have done in
     <span>
      this example.
     </span>
    </p>
    <p class="calibre3">
     The reason why we placed the code into
     <strong class="source-inline">
      paintAll()
     </strong>
     is that we want to reuse the same code for two different purposes: for displaying the graphics on the window and exporting the graphics to an SVG
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker296">
     </a>
     file. You can see that the default value of the generator variable in the
     <strong class="source-inline">
      paintAll()
     </strong>
     function is set to
     <strong class="source-inline">
      0
     </strong>
     , which means no
     <strong class="source-inline">
      QSvgGenerator
     </strong>
     object is required to run
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker297">
     </a>
     the function unless specified. Later on, in the
     <strong class="source-inline">
      paintAll()
     </strong>
     function, we check whether the generator object exists. If it does exist, use it as the paint engine for the painter, as shown in the
     <span>
      following code:
     </span>
    </p>
    <pre class="source-code">
if (engine)
    painter.begin(engine);
else
    painter.begin(this);</pre>
    <p class="calibre3">
     Otherwise, pass the main window to the
     <strong class="source-inline">
      begin()
     </strong>
     function (since we’re writing the code in the
     <strong class="source-inline">
      mainwindow.cpp
     </strong>
     file, we can directly use this to refer to the main window’s pointer) so that it will use the paint engine of the main window itself, which means the graphics will be drawn onto the surface of the main window. In this example, it’s required to use a single
     <strong class="source-inline">
      QPainter
     </strong>
     object to save the graphics into the SVG file. If you use multiple
     <strong class="source-inline">
      QPainter
     </strong>
     objects, the resulting SVG file will contain multiple XML header definitions, and thus the file will be deemed to be invalid by any graphics editor software
     <span>
      out there.
     </span>
    </p>
    <p class="calibre3">
     <strong class="source-inline">
      QFileDialog::getSaveFileName()
     </strong>
     will open up the native save file dialog for the user to choose the save directory and set a desired filename. Once the user is done with that, the full path will be returned as a string, and we will be able to pass that information to the
     <strong class="source-inline">
      QSvgGenerator
     </strong>
     object to export
     <span>
      the graphics.
     </span>
    </p>
    <p class="calibre3">
     Notice that in the previous screenshot, the penguin in the SVG file has been cropped. This is because the canvas size of the SVG was set to follow the size of the main window. To help the poor penguin get its body back, scale the window bigger before exporting the
     <span>
      SVG file.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-99">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor099">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     SVG defines the graphics in XML format. Since it is a form of vector graphics, SVG files do not lose any quality if they are
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker298">
     </a>
     zoomed in on or resized. The SVG format not only allows you to store vector graphics in
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker299">
     </a>
     the working file, but it also allows you to store raster graphics and text, which is more or less similar to Adobe Illustrator’s format. The SVG also allows you to group, style, transform, and composite graphical objects into previously
     <span>
      rendered objects.
     </span>
    </p>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     You can check out the full specification of SVG graphics
     <span>
      at
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://www.w3.org/TR/SVG">
      <span>
       https://www.w3.org/TR/SVG
      </span>
     </a>
     <span>
      <span>
       .
      </span>
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-100">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor100">
     </a>
     Coordinate transformation
    </h1>
    <p class="calibre3">
     In this example, we will learn
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker300">
     </a>
     how to use coordinate transformation and a timer to create a real-time
     <span>
      clock display.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-101">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor101">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     To create our first graphical clock display, let’s follow
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      First, create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project. Then, open up
      <strong class="source-inline1">
       mainwindow.ui
      </strong>
      and remove the
      <strong class="source-inline1">
       menuBar
      </strong>
      ,
      <strong class="source-inline1">
       mainToolBar
      </strong>
      , and
      <strong class="source-inline1">
       statusBar
      </strong>
      as we
      <span>
       did before.
      </span>
     </li>
     <li class="calibre14">
      After that, open up the
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      file and include the
      <span>
       following headers:
      </span>
      <pre class="source-code">
#include &lt;QTime&gt;
#include &lt;QTimer&gt;
#include &lt;QPainter&gt;</pre>
     </li>
     <li class="calibre14">
      Then, declare the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      function,
      <span>
       like so:
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold1">virtual void paintEvent(QPaintEvent *event);</strong></pre>
     </li>
     <li class="calibre14">
      In the
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      file, create three arrays to store the shapes of the hour hand, minute hand, and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker301">
      </a>
      second hand, where each of the arrays contains three sets
      <span>
       of coordinates:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold1">static const QPoint hourHand[3] = {</strong>
<strong class="bold1">        QPoint(4, 4),</strong>
<strong class="bold1">        QPoint(-4, 4),</strong>
<strong class="bold1">        QPoint(0, -40)</strong>
<strong class="bold1">    </strong><strong class="bold1">};</strong>
<strong class="bold1">    static const QPoint minuteHand[3] = {</strong>
<strong class="bold1">        QPoint(4, 4),</strong>
<strong class="bold1">        QPoint(-4, 4),</strong>
<strong class="bold1">        QPoint(0, -70)</strong>
<strong class="bold1">    };</strong>
<strong class="bold1">    static const QPoint secondHand[3] = {</strong>
<strong class="bold1">        QPoint(2, 2),</strong>
<strong class="bold1">        QPoint(-2, 2),</strong>
<strong class="bold1">        QPoint(0, -90)</strong>
<strong class="bold1">    </strong><strong class="bold1">};</strong>
}</pre>
     </li>
     <li class="calibre14">
      After that, add the following code below the arrays to create the painter and move it to the center of the main window. Also, we adjust the size of the painter so that it fits nicely in the main window, even when the window is
      <span>
       being resized:
      </span>
      <pre class="source-code">
int side = qMin(width(), height());
QPainter painter(this);
painter.setRenderHint(QPainter::Antialiasing);
painter.translate(width() / 2, height() / 2);
painter.scale(side / 250.0, side / 250.0);</pre>
     </li>
     <li class="calibre14">
      Once you are done with that, we will start drawing the dials by using a for loop. Each dial is rotated by
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker302">
      </a>
      an increment of 6 degrees, so 60 dials would complete a full circle. Also, the dial will look slightly longer at every
      <span>
       five minutes:
      </span>
      <pre class="source-code">
for (int i = 0; i &lt; 60; ++i) {
    if ((i % 5) != 0)
        painter.drawLine(92, 0, 96, 0);
    else
        painter.drawLine(86, 0, 96, 0);
    painter.rotate(6.0);
}</pre>
     </li>
     <li class="calibre14">
      Then, we proceed with drawing the hands of the clock. Each hand’s rotation is calculated according to the current time and its respective equivalent location over
      <span>
       360 degrees:
      </span>
      <pre class="source-code">
QTime time = QTime::currentTime();
// Draw hour hand
painter.save();
painter.rotate((time.hour() * 360) / 12);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(hourHand, 3);
painter.restore();</pre>
     </li>
     <li class="calibre14">
      Let’s draw the minute hand of
      <span>
       the clock:
      </span>
      <pre class="source-code">
// Draw minute hand
painter.save();
painter.rotate((time.minute() * 360) / 60);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(minuteHand, 3);
painter.restore();</pre>
     </li>
     <li class="calibre14">
      Then, we also draw the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker303">
      </a>
      hand
      <span>
       for seconds:
      </span>
      <pre class="source-code">
// Draw second hand
painter.save();
painter.rotate((time.second() * 360) / 60);
painter.setPen(Qt::NoPen);
painter.setBrush(Qt::black);
painter.drawConvexPolygon(secondHand, 3);
painter.restore();</pre>
     </li>
     <li class="calibre14">
      Last, but not least, create a timer to refresh the graphics every second so that the program will work like a
      <span>
       real clock:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold1">QTimer* timer = new QTimer(this);</strong>
<strong class="bold1">    timer-&gt;start(1000);</strong>
    connect(timer, QTimer::timeout, this, MainWindow::update);
}</pre>
     </li>
     <li class="calibre14">
      Compile and run the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker304">
      </a>
      program now, and you should see something
      <span>
       like this:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer063">
      <img alt="Figure 4.6 – A real-time analog clock displayed on the Qt application" class="calibre4" src="image/B20976_04_006.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.6 – A real-time analog clock displayed on the Qt application
    </p>
    <h2 class="calibre7" id="_idParaDest-102">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor102">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     Each of the arrays contains three
     <strong class="source-inline">
      QPoint
     </strong>
     data instances, which form the shape of an elongated triangle. The arrays are then passed to the painter and rendered as a convex polygon using the
     <strong class="source-inline">
      drawConvexPolygon()
     </strong>
     function. Before drawing each of the clock hands, we use
     <strong class="source-inline">
      painter.save()
     </strong>
     to save the state of the
     <strong class="source-inline">
      QPainter
     </strong>
     object and then proceed with drawing the hand using
     <span>
      coordinate transformation.
     </span>
    </p>
    <p class="calibre3">
     Once we’re done with the drawing, we restore the painter to its previous state by calling
     <strong class="source-inline">
      painter.restore()
     </strong>
     . This function will undo all the transformations before
     <strong class="source-inline">
      painter. restore()
     </strong>
     so that the next clock hand will not inherit the transformations of the previous one. Without using
     <strong class="source-inline">
      painter.save()
     </strong>
     and
     <strong class="source-inline">
      painter.restore()
     </strong>
     , we will have to manually change the position, rotation, and scale before drawing the
     <span>
      next hand.
     </span>
    </p>
    <p class="calibre3">
     A good example of not using
     <strong class="source-inline">
      painter.save()
     </strong>
     and
     <strong class="source-inline">
      painter.restore()
     </strong>
     is when drawing the dials. Since each dial’s rotation is an increment of six degrees from the previous one, we don’t need to save the painter’s state at all. We just have to call
     <strong class="source-inline">
      painter.rotate(6.0)
     </strong>
     in a loop and each dial will inherit the previous dial’s rotation. We also use a modulus operator (
     <strong class="source-inline">
      %
     </strong>
     ) to check whether the unit represented by the dial can be divided by five. If it can, then we draw it
     <span>
      slightly longer.
     </span>
    </p>
    <p class="calibre3">
     Without using a timer to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker305">
     </a>
     constantly call the
     <strong class="source-inline">
      update()
     </strong>
     slot, the clock will not function properly. This is because
     <strong class="source-inline">
      paintEvent()
     </strong>
     will not be called by Qt when there is no change to the state of the parent widget, which in this case is the main window. Therefore, we need to manually tell Qt that we need to refresh the graphics by calling
     <strong class="source-inline">
      update()
     </strong>
     <span>
      every second.
     </span>
    </p>
    <p class="calibre3">
     We used the
     <strong class="source-inline">
      painter.setRenderHint(QPainter::Antialiasing)
     </strong>
     function to enable anti-aliasing when rendering the clock. Without anti-aliasing, the graphics will look very jagged
     <span>
      and pixelated:
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer064">
      <img alt="Figure 4.7 – Anti-aliasing produces a smoother result" class="calibre4" src="image/B20976_04_007.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.7 – Anti-aliasing produces a smoother result
    </p>
    <h2 class="calibre7" id="_idParaDest-103">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor103">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     The
     <strong class="source-inline">
      QPainter
     </strong>
     class uses the coordinate system to determine the position and size of the graphics before rendering them on screen. This information can be altered to make the graphics appear at a different position, rotation, and size. This process of altering the coordinate information of a graphic is what we call coordinate transformation. There are
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker306">
     </a>
     several types
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker307">
     </a>
     of transformation: among
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker308">
     </a>
     them
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker309">
     </a>
     are
     <strong class="bold">
      translation
     </strong>
     ,
     <strong class="bold">
      rotation
     </strong>
     ,
     <strong class="bold">
      scaling
     </strong>
     ,
     <span>
      and
     </span>
     <span>
      <strong class="bold">
       shearing
      </strong>
     </span>
     <span>
      :
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer065">
      <img alt="Figure 4.8 – Different types of transformations" class="calibre4" src="image/B20976_04_008.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.8 – Different types of transformations
    </p>
    <p class="calibre3">
     Qt uses a coordinate system that has its origin at the top-left corner, meaning the
     <em class="italic">
      x
     </em>
     values increase to the right and the
     <em class="italic">
      y
     </em>
     values increase downward. This coordinate system might be different from the coordinate system used by the physical device, such as a computer screen. Qt handles
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker310">
     </a>
     this automatically by using the
     <strong class="source-inline">
      QPaintDevice
     </strong>
     class, which maps Qt’s logical coordinates to the
     <span>
      physical coordinates.
     </span>
    </p>
    <p class="calibre3">
     <strong class="source-inline">
      QPainter
     </strong>
     provides four transform operations to perform different types
     <span>
      of transformation:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <strong class="source-inline1">
       QPainter::translate()
      </strong>
      : This offsets the graphic’s position by a given set
      <span>
       of units
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       QPainter::rotate()
      </strong>
      : This rotates the graphics around the origin in a
      <span>
       clockwise direction
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       QPainter::scale()
      </strong>
      : This offsets the graphic’s size by a
      <span>
       given factor
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       QPainter::shear()
      </strong>
      : This twists the graphic’s coordinate system around
      <span>
       the origin
      </span>
     </li>
    </ul>
    <h1 class="calibre5" id="_idParaDest-104">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor104">
     </a>
     Displaying images on screen
    </h1>
    <p class="calibre3">
     Qt not only allows us to draw shapes and images on screen, but it also allows us to overlay multiple images on top of
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker311">
     </a>
     each other and combine the pixel information from all the layers using different types of algorithms to create very interesting results. In this example, we will learn how to overlay images on top of each other and apply different composition effects
     <span>
      to them.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-105">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor105">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s create a simple demo that shows the effect of different image compositions by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      First, set up a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and remove the
      <strong class="source-inline1">
       menuBar
      </strong>
      ,
      <strong class="source-inline1">
       mainToolBar
      </strong>
      , and
      <strong class="source-inline1">
       statusBar
      </strong>
      , as we did in the
      <span>
       first recipe.
      </span>
     </li>
     <li class="calibre14">
      Next, add the
      <strong class="source-inline1">
       QPainter
      </strong>
      class header to the
      <span>
       <strong class="source-inline1">
        mainwindow.h
       </strong>
      </span>
      <span>
       file:
      </span>
      <pre class="source-code">
#include &lt;QPainter&gt;</pre>
     </li>
     <li class="calibre14">
      After that, declare the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      virtual function,
      <span>
       like so:
      </span>
      <pre class="source-code">
virtual void paintEvent(QPaintEvent* event);</pre>
     </li>
     <li class="calibre14">
      In
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      , we will first load several image files using the
      <span>
       <strong class="source-inline1">
        QImage
       </strong>
      </span>
      <span>
       class:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent* event) {
    <strong class="bold1">QImage image;</strong>
<strong class="bold1">    image.load("checker.png");</strong>
<strong class="bold1">    QImage image2;</strong>
<strong class="bold1">    image2.load("tux.png");</strong>
<strong class="bold1">    QImage image3;</strong>
<strong class="bold1">    image3.load("butterfly.png");</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, create a
      <strong class="source-inline1">
       QPainter
      </strong>
      object and use it to draw two pairs of images, where one image is on top of
      <span>
       the other:
      </span>
      <pre class="source-code">
QPainter painter(this);
painter.drawImage(QPoint(10, 10), image);
painter.drawImage(QPoint(10, 10), image2);
painter.drawImage(QPoint(300, 10), image);
painter.drawImage(QPoint(300, 40), image3);</pre>
     </li>
     <li class="calibre14">
      Now, compile and run
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker312">
      </a>
      the program and you should see something
      <span>
       like this:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer066">
      <img alt="Figure 4.9 – Displaying images normally" class="calibre4" src="image/B20976_04_009.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.9 – Displaying images normally
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="7">
      Next, we will set the composition mode before drawing each image
      <span>
       on screen:
      </span>
      <pre class="source-code">
QPainter painter(this);
painter.setCompositionMode(QPainter::CompositionMode_Difference);
painter.drawImage(QPoint(10, 10), image);
painter.setCompositionMode(QPainter::CompositionMode_Multiply);
painter.drawImage(QPoint(10, 10), image2);
painter.setCompositionMode(QPainter::CompositionMode_Xor);
painter.drawImage(QPoint(300, 10), image);
painter.setCompositionMode(QPainter::CompositionMode_SoftLight);
painter.drawImage(QPoint(300, 40), image3);</pre>
     </li>
     <li class="calibre14">
      Compile and run the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker313">
      </a>
      program again and you will now see something
      <span>
       like this:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer067">
      <img alt="Figure 4.10 – Applying different composition modes to the images" class="calibre4" src="image/B20976_04_010.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.10 – Applying different composition modes to the images
    </p>
    <h2 class="calibre7" id="_idParaDest-106">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor106">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     When drawing images with Qt, the sequence of calling the
     <strong class="source-inline">
      drawImage()
     </strong>
     function will determine which image is being rendered first and which one is rendered later. This will affect the depth order of the images and yield
     <span>
      different outcomes.
     </span>
    </p>
    <p class="calibre3">
     In the previous example, we called the
     <strong class="source-inline">
      drawImage()
     </strong>
     function four times to draw four different images on screen. The first
     <strong class="source-inline">
      drawImage()
     </strong>
     function renders
     <strong class="source-inline">
      checker.png
     </strong>
     , and the second
     <strong class="source-inline">
      drawImage()
     </strong>
     function renders
     <strong class="source-inline">
      tux.png
     </strong>
     (the penguin). The image that gets rendered later will always appear in front of the others, which is why the penguin is showing in front of the checkered pattern. The same goes for the butterfly and the checkered pattern on the right. The reason why you can still see the checkered pattern even though the butterfly is rendered in front of it is because the butterfly image is not
     <span>
      fully opaque.
     </span>
    </p>
    <p class="calibre3">
     Now, let’s invert the render
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker314">
     </a>
     sequence and see what happens. We will try to render the penguin first, followed by the checkered box. The same goes for the other pair of images on the right: the butterfly gets rendered first, followed by the
     <span>
      checkered box:
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer068">
      <img alt="Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes" class="calibre4" src="image/B20976_04_011.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.11 – Both the penguin and butterfly are covered by the checkered boxes
    </p>
    <p class="calibre3">
     To apply a composition effect to the image, we’ll have to set the painter’s composition mode before drawing the image, by calling the
     <strong class="source-inline">
      painter.setCompositionMode()
     </strong>
     function. You can pick a desired composition mode from the auto-complete menu by
     <span>
      typing
     </span>
     <span>
      <strong class="source-inline">
       QPainter::CompositionMode
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     In the previous example, we applied
     <strong class="source-inline">
      QPainter::CompositionMode_Difference
     </strong>
     to the checkered box on the left, which inverted its color. Next, we applied
     <strong class="source-inline">
      QPainter::CompositionMode_Overlay
     </strong>
     to the penguin, which makes it blend with the checkered pattern, and were able to see both images overlaying each other. On the right-hand side, we applied
     <strong class="source-inline">
      QPainter::CompositionMode_Xor
     </strong>
     to the checkered box, where, if differences exist between the source and destination, colors are shown; otherwise, it will be
     <span>
      rendered black.
     </span>
    </p>
    <p class="calibre3">
     Since it’s comparing differences with the white background, the non-transparent part of the checkered box becomes completely black. We also applied
     <strong class="source-inline">
      QPainter::CompositionMode_SoftLight
     </strong>
     to the butterfly image. This blends the pixels with the background with reduced contrast. If you want to disable the composition mode that
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker315">
     </a>
     you’ve just set for the previous rendering before proceeding to the next, simply set it back to the default mode, which
     <span>
      is
     </span>
     <span>
      <strong class="source-inline">
       QPainter::CompositionMode_SourceOver
      </strong>
     </span>
     <span>
      .
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-107">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor107">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     For example, we can overlay multiple images on top of each other and use Qt’s
     <strong class="bold">
      Image Composition
     </strong>
     feature to merge
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker316">
     </a>
     them together and calculate the resulting pixels on screen, based on the composition mode we used. This is often used in image editing software such as Photoshop and GIMP to composite
     <span>
      image layers.
     </span>
    </p>
    <p class="calibre3">
     There are more than 30 types of composition
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker317">
     </a>
     modes available in Qt. Some of the most commonly used modes are
     <span>
      as follows:
     </span>
    </p>
    <ul class="calibre15">
     <li class="calibre14">
      <strong class="source-inline1">
       Clear
      </strong>
      : The pixels in the destination are set to fully transparent, independent of
      <span>
       the source.
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Source
      </strong>
      : The output is the source pixel. This mode is the inverse
      <span>
       of
      </span>
      <span>
       <strong class="source-inline1">
        CompositionMode_Destination
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Destination
      </strong>
      : The output is the destination pixel. This means that the blending has no effect. This mode is the inverse
      <span>
       of
      </span>
      <span>
       <strong class="source-inline1">
        CompositionMode_Source
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Source Over
      </strong>
      : This is often referred to as
      <strong class="bold">
       alpha blending
      </strong>
      . The alpha of the source is used to blend the pixel on
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker318">
      </a>
      top of the destination. This is the default mode used
      <span>
       by
      </span>
      <span>
       <strong class="source-inline1">
        QPainter
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Destination Over
      </strong>
      : The output is the blend between the alpha of the destination on top of the source pixels. The opposite of this mode
      <span>
       is
      </span>
      <span>
       <strong class="source-inline1">
        CompositionMode_SourceOver
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Source In
      </strong>
      : The output is the source, where the alpha is reduced by that of
      <span>
       the destination.
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Destination In
      </strong>
      : The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse
      <span>
       of
      </span>
      <span>
       <strong class="source-inline1">
        CompositionMode_SourceIn
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Source Out
      </strong>
      : The output is the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker319">
      </a>
      source, where the alpha is reduced by the inverse of
      <span>
       the destination.
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Destination Out
      </strong>
      : The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse
      <span>
       of
      </span>
      <span>
       <strong class="source-inline1">
        CompositionMode_SourceOut
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Source Atop
      </strong>
      : The source pixel is blended on top of the destination, with the alpha of the source pixel reduced by the alpha of the
      <span>
       destination pixel.
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Destination Atop
      </strong>
      : The destination pixel is blended on top of the source, with the alpha of the source pixel reduced by the alpha of the destination pixel. This mode is the inverse
      <span>
       of
      </span>
      <span>
       <strong class="source-inline1">
        CompositionMode_SourceAtop
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      <strong class="source-inline1">
       Xor
      </strong>
      : This is short for
      <strong class="source-inline1">
       Exclusive OR
      </strong>
      , which is an advanced blending mode that is primarily used for image analysis. Using this is much more complicated with this composition mode. First, the alpha of the source is reduced by the inverse of the destination alpha. Then, the alpha of the destination is reduced by the inverse of the source alpha. Finally, both the source and destination are then merged to produce
      <span>
       the output.
      </span>
     </li>
    </ul>
    <p class="callout-heading">
     Note
    </p>
    <p class="callout">
     For more information, you can visit this
     <span>
      link:
     </span>
     <a class="pcalibre pcalibre1 calibre6" href="https://pyside.github.io">
      <span>
       https://pyside.github.io
      </span>
     </a>
     <span>
      .
     </span>
    </p>
    <p class="calibre3">
     The following figure shows the outcome of overlaying two images with different
     <span>
      composition modes:
     </span>
    </p>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer069">
      <img alt="Figure 4.12 – Different types of composition modes" class="calibre4" src="image/B20976_04_012.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.12 – Different types of composition modes
    </p>
    <h1 class="calibre5" id="_idParaDest-108">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor108">
     </a>
     Applying image effects to graphics
    </h1>
    <p class="calibre3">
     Qt provides an easy way to
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker320">
     </a>
     add image effects to any graphics drawn using the
     <strong class="source-inline">
      QPainter
     </strong>
     class. In this example, we will learn how to apply different image effects, such as
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker321">
     </a>
     drop shadow, blur, colorize, and opacity effects, to a graphic before displaying it
     <span>
      on screen.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-109">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor109">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s learn how to apply image effects to text and graphics by following
     <span>
      these steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Create a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and remove the
      <strong class="source-inline1">
       menuBar
      </strong>
      ,
      <strong class="source-inline1">
       mainToolBar
      </strong>
      ,
      <span>
       and
      </span>
      <span>
       <strong class="source-inline1">
        StatusBar
       </strong>
      </span>
      <span>
       .
      </span>
     </li>
     <li class="calibre14">
      Create a new resource file by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      and add all the images required by
      <span>
       the project:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer070">
      <img alt="Figure 4.13 – Creating a new Qt resource file" class="calibre4" src="image/B20976_04_013.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.13 – Creating a new Qt resource file
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      Next, open up
      <strong class="source-inline1">
       mainwindow.ui
      </strong>
      and
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker322">
      </a>
      add four labels to the window. Two of
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker323">
      </a>
      the labels will be text, and the two others we will load with the images we have just added to the
      <span>
       resource file:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer071">
      <img alt="Figure 4.14 – Application filled with text and images" class="calibre4" src="image/B20976_04_014.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.14 – Application filled with text and images
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="4">
      You may already notice that
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker324">
      </a>
      the font sizes are way bigger than the default size. That can be achieved
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker325">
      </a>
      by adding a style sheet to the label widget, for example,
      <span>
       as follows:
      </span>
      <pre class="source-code">
font: 26pt "MS Gothic";</pre>
     </li>
     <li class="calibre14">
      After that, open up
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      and include the following headers at the top of the
      <span>
       source code:
      </span>
      <pre class="source-code">
#include &lt;QGraphicsBlurEffect&gt;
#include &lt;QGraphicsDropShadowEffect&gt;
#include &lt;QGraphicsColorizeEffect&gt;
#include &lt;QGraphicsOpacityEffect&gt;</pre>
     </li>
     <li class="calibre14">
      Then, within the constructor of the
      <strong class="source-inline1">
       MainWindow
      </strong>
      class, add the following code to create a
      <strong class="source-inline1">
       DropShadowEffect
      </strong>
      , and apply it to one of
      <span>
       the labels:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
ui-&gt;setupUi(this);
<strong class="bold1">QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect();</strong>
<strong class="bold1">shadow-&gt;setXOffset(4);</strong>
<strong class="bold1">shadow-&gt;setYOffset(4);</strong>
<strong class="bold1">ui-&gt;label-&gt;setGraphicsEffect(shadow);</strong>
}</pre>
     </li>
     <li class="calibre14">
      Next, we will create
      <strong class="source-inline1">
       ColorizedEffect
      </strong>
      and apply it to one of the images, in this case, the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker326">
      </a>
      butterfly. We also set the effect color
      <span>
       to
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker327">
       </a>
      </span>
      <span>
       red:
      </span>
      <pre class="source-code">
QGraphicsColorizeEffect* colorize = new
QGraphicsColorizeEffect();
colorize-&gt;setColor(QColor(255, 0, 0));
ui-&gt;butterfly-&gt;setGraphicsEffect(colorize);</pre>
     </li>
     <li class="calibre14">
      Once we’re done with that, create
      <strong class="source-inline1">
       BlurEffect
      </strong>
      and set its radius to
      <strong class="source-inline1">
       12
      </strong>
      . Then, apply the graphics effect to the
      <span>
       other label:
      </span>
      <pre class="source-code">
QGraphicsBlurEffect* blur = new QGraphicsBlurEffect();
blur-&gt;setBlurRadius(12);
ui-&gt;label2-&gt;setGraphicsEffect(blur);</pre>
     </li>
     <li class="calibre14">
      Lastly, create an alpha effect and apply it to the penguin image. We set the opacity value to
      <strong class="source-inline1">
       0.2
      </strong>
      , which means
      <span>
       20% opacity:
      </span>
      <pre class="source-code">
QGraphicsOpacityEffect* alpha = new QGraphicsOpacityEffect();
alpha-&gt;setOpacity(0.2);
ui-&gt;penguin-&gt;setGraphicsEffect(alpha);</pre>
     </li>
     <li class="calibre14">
      Now, compile and run the program and you should be able to see something
      <span>
       like this:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer072">
      <img alt="Figure 4.15 – Different types of graphics effects being applied to the texts and images" class="calibre4" src="image/B20976_04_015.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.15 – Different types of graphics effects being applied to the texts and images
    </p>
    <h2 class="calibre7" id="_idParaDest-110">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor110">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     Each of the graphic effects is a class of its
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker328">
     </a>
     own that inherits the
     <strong class="source-inline">
      QGraphicsEffect
     </strong>
     parent class. You can create
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker329">
     </a>
     your own custom effect by creating a new class that inherits
     <strong class="source-inline">
      QGraphicsEffect
     </strong>
     and re-implementing some of the functions
     <span>
      in it.
     </span>
    </p>
    <p class="calibre3">
     Each effect has its own set of variables that are specifically created for it. For example, you can set the color of the colorized effect, but there is no such variable in the blur effect. This is because each effect is vastly different from the others, which is also why it needs to be a class of its own rather than using the same class for all the
     <span>
      different effects.
     </span>
    </p>
    <p class="calibre3">
     It’s only possible to add a single graphics effect to a widget at a time. If you add more than one effect, only the last one will be applied to the widget, as it replaces the previous one. Other than that, be aware that if you create a graphics effect, for example, the drop shadow effect, you can’t assign it to two different widgets, as it will only get assigned to the last widget you applied it to. If you need to apply the same type of effect to several different widgets, create a few graphics effects of the same type and apply each of them to their
     <span>
      respective widgets.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-111">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor111">
     </a>
     There’s more…
    </h2>
    <p class="calibre3">
     Currently, Qt supports blur, drop shadow, colorize, and opacity effects. These effects can be used by calling the following classes:
     <strong class="source-inline">
      QGraphicsBlurEffect
     </strong>
     ,
     <strong class="source-inline">
      QGraphicsDropShadowEffect
     </strong>
     ,
     <strong class="source-inline">
      QGraphicsColorizeEffect
     </strong>
     , and
     <strong class="source-inline">
      QGraphicsOpacityEffect
     </strong>
     . All these classes are inherited from the
     <strong class="source-inline">
      QGraphicsEffect
     </strong>
     class. You can also create
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker330">
     </a>
     your own custom image effect by creating a subclass of
     <strong class="source-inline">
      QGrapicsEffect
     </strong>
     (or any other existing effects) and re-implementing the
     <span>
      <strong class="source-inline">
       draw()
      </strong>
     </span>
     <span>
      function.
     </span>
    </p>
    <p class="calibre3">
     The graphics effect changes only
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker331">
     </a>
     the bounding rectangle of the source. If you want to increase the margin of the bounding rectangle, re-implement the virtual
     <strong class="source-inline">
      boundingRectFor()
     </strong>
     function, and call
     <strong class="source-inline">
      updateBoundingRect()
     </strong>
     to notify the framework whenever this
     <span>
      rectangle changes.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-112">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor112">
     </a>
     Creating a basic paint program
    </h1>
    <p class="calibre3">
     Since we have learned so much about the
     <strong class="source-inline">
      QPainter
     </strong>
     class and how to use it to display graphics on screen, I guess
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker332">
     </a>
     it’s time for us to do something fun where we can put our knowledge
     <span>
      into practice.
     </span>
    </p>
    <p class="calibre3">
     In this recipe, we will learn how to make a basic paint program that allows us to draw lines on a canvas with different brush sizes and colors. We will also learn how to use the
     <strong class="source-inline">
      QImage
     </strong>
     class and mouse events in order to construct the
     <span>
      paint program.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-113">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor113">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     Let’s start our fun project with the
     <span>
      following steps:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      Again, we start by creating a new
      <strong class="bold">
       Qt Widgets Application
      </strong>
      project and removing the toolbar and status bar. We will keep the menu bar
      <span>
       this time.
      </span>
     </li>
     <li class="calibre14">
      After that, set up the menu bar
      <span>
       like so:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer073">
      <img alt="Figure 4.16 – Setting up the menu bar" class="calibre4" src="image/B20976_04_016.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.16 – Setting up the menu bar
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="3">
      We will leave the menu bar as it is for the moment, so let’s proceed to the
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      file. First, include
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker333">
      </a>
      the following header files, as they are required for
      <span>
       the project:
      </span>
      <pre class="source-code">
#include &lt;QPainter&gt;
#include &lt;QMouseEvent&gt;
#include &lt;QFileDialog&gt;</pre>
     </li>
     <li class="calibre14">
      Next, declare the variables that we’ll be using for this project,
      <span>
       like so:
      </span>
      <pre class="source-code">
private:
    Ui::MainWindow *ui;
    <strong class="bold1">QImage image;</strong>
<strong class="bold1">    bool drawing;</strong>
<strong class="bold1">    QPoint lastPoint;</strong>
<strong class="bold1">    int brushSize;</strong>
<strong class="bold1">    QColor brushColor;</strong></pre>
     </li>
     <li class="calibre14">
      Then, declare the event callback functions, which are inherited from the
      <strong class="source-inline1">
       QWidget
      </strong>
      class. These functions will be triggered by Qt when the respective event happens. We will override these functions and tell Qt what to do when these events
      <span>
       get called:
      </span>
      <pre class="source-code">
public:
    explicit MainWindow(QWidget *parent = 0);
    ~MainWindow();
    <strong class="bold1">virtual void mousePressEvent(QMouseEvent *event);</strong>
<strong class="bold1">    virtual void mouseMoveEvent(QMouseEvent *event);</strong>
<strong class="bold1">    virtual void mouseReleaseEvent(QMouseEvent *event);</strong>
<strong class="bold1">    virtual void paintEvent(QPaintEvent *event);</strong>
<strong class="bold1">    virtual void resizeEvent(QResizeEvent *event);</strong></pre>
     </li>
     <li class="calibre14">
      After that, go to the
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      file and add the following code to the class constructor to set up some
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker334">
      </a>
      of
      <span>
       the variables:
      </span>
      <pre class="source-code">
MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent),
ui(new Ui::MainWindow) {
    ui-&gt;setupUi(this);
    <strong class="bold1">image = QImage(this-&gt;size(), QImage::Format_RGB32);</strong>
<strong class="bold1">    </strong><strong class="bold1">image.fill(Qt::white);</strong>
<strong class="bold1">    drawing = false;</strong>
<strong class="bold1">    brushColor = Qt::black;</strong>
<strong class="bold1">    brushSize = 2;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Next, we will construct the
      <strong class="source-inline1">
       mousePressEvent()
      </strong>
      event and tell Qt what to do when the left mouse button
      <span>
       is pressed:
      </span>
      <pre class="source-code">
void MainWindow::mousePressEvent(QMouseEvent *event) {
    <strong class="bold1">if (event-&gt;button() == Qt::LeftButton) {</strong>
<strong class="bold1">        drawing = true;</strong>
<strong class="bold1">        lastPoint = event-&gt;pos();</strong>
<strong class="bold1">    }</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, we will construct the
      <strong class="source-inline1">
       mouseMoveEvent()
      </strong>
      event and tell Qt what to do when the mouse is moving. In this case, we want to draw the lines on the canvas if the left mouse button is
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker335">
      </a>
      <span>
       being held:
      </span>
      <pre class="source-code">
void MainWindow::mouseMoveEvent(QMouseEvent *event) {
    <strong class="bold1">if ((event-&gt;buttons() &amp; Qt::LeftButton) &amp;&amp; drawing) {</strong>
<strong class="bold1">        QPainter painter(&amp;image);</strong>
<strong class="bold1">        painter.setPen(QPen(brushColor, brushSize, Qt::SolidLine, Qt::RoundCap, Qt::RoundJoin));</strong>
<strong class="bold1">        painter.drawLine(lastPoint, event-&gt;pos());</strong>
<strong class="bold1">lastPoint = event-&gt;pos();</strong>
<strong class="bold1">         this-&gt;update();</strong>
<strong class="bold1">    }</strong>
}</pre>
     </li>
     <li class="calibre14">
      After that, we will also construct the
      <strong class="source-inline1">
       mouseReleaseEvent()
      </strong>
      event, which will be triggered when the mouse button
      <span>
       is released:
      </span>
      <pre class="source-code">
void MainWindow::mouseReleaseEvent(QMouseEvent *event) {
    <strong class="bold1">if (event-&gt;button() == Qt::LeftButton) {</strong>
<strong class="bold1">        drawing = false;</strong>
<strong class="bold1">    }</strong>
}</pre>
     </li>
     <li class="calibre14">
      Once you’re done with that, we will proceed to the
      <strong class="source-inline1">
       paintEvent()
      </strong>
      event, which is surprisingly simple compared to the other examples we have seen in
      <span>
       previous sections:
      </span>
      <pre class="source-code">
void MainWindow::paintEvent(QPaintEvent *event) {
    <strong class="bold1">QPainter canvasPainter(this);</strong>
<strong class="bold1">    canvasPainter.drawImage(this-&gt;rect(), image, image.rect());</strong>
}</pre>
     </li>
     <li class="calibre14">
      Remember how we have a
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker336">
      </a>
      menu bar sitting around doing nothing? Let’s right-click on each of the actions below the GUI editor and select
      <strong class="bold">
       Go to slot…
      </strong>
      in the pop-up menu. We want to tell Qt what to do when each of these options on the menu bar
      <span>
       is selected:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer074">
      <img alt="Figure 4.17 – Creating slot function for each of the menu actions" class="calibre4" src="image/B20976_04_017.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.17 – Creating slot function for each of the menu actions
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="12">
      Then, select the default slot called
      <strong class="source-inline1">
       triggered()
      </strong>
      and press the
      <strong class="bold">
       OK
      </strong>
      button. Qt will automatically generate a new slot function in both your
      <strong class="source-inline1">
       mainwindow.h
      </strong>
      and
      <strong class="source-inline1">
       mainwindow.cpp
      </strong>
      files. Once you are done with all the actions, you should see something like this in your
      <span>
       <strong class="source-inline1">
        mainwindow.h
       </strong>
      </span>
      <span>
       file:
      </span>
      <pre class="source-code">
private slots:
    void on_actionSave_triggered();
    void on_actionClear_triggered();
    void on_action2px_triggered();
    void on_action5px_triggered();
    void on_action10px_triggered();
    void on_actionBlack_triggered();
    void on_actionWhite_triggered();
    void on_actionRed_triggered();
    void on_actionGreen_triggered();
    void on_actionBlue_triggered();</pre>
     </li>
     <li class="calibre14">
      Next, we will tell Qt what
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker337">
      </a>
      to do when each of these slots
      <span>
       is triggered:
      </span>
      <pre class="source-code">
void MainWindow::on_actionSave_triggered() {
    <strong class="bold1">QString filePath = QFileDialog::getSaveFileName(this, «Save Image», «», «PNG (*.png);;JPEG (*.jpg *.jpeg);;All files</strong>
<strong class="bold1">(*.*)»);</strong>
<strong class="bold1">    if (filePath == "")</strong>
<strong class="bold1">        </strong><strong class="bold1">return;</strong>
<strong class="bold1">    image.save(filePath);</strong>
}
void MainWindow::on_actionClear_triggered() {
    <strong class="bold1">image.fill(Qt::white);</strong>
<strong class="bold1">    this-&gt;update();</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, we continue to
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker338">
      </a>
      implement the
      <span>
       other slots:
      </span>
      <pre class="source-code">
void MainWindow::on_action2px_triggered() {
    <strong class="bold1">brushSize = 2;</strong>
}
void MainWindow::on_action5px_triggered() {
    <strong class="bold1">brushSize = 5;</strong>
}
void MainWindow::on_action10px_triggered() {
    <strong class="bold1">brushSize = 10;</strong>
}
void MainWindow::on_actionBlack_triggered() {
    <strong class="bold1">brushColor = Qt::black;</strong>
}</pre>
     </li>
     <li class="calibre14">
      Finally, we implement the rest of the
      <span>
       slot functions:
      </span>
      <pre class="source-code">
void MainWindow::on_actionWhite_triggered() {
    <strong class="bold1">brushColor = Qt::white;</strong>
}
void MainWindow::on_actionRed_triggered() {
    <strong class="bold1">brushColor = Qt::red;</strong>
}
void MainWindow::on_actionGreen_triggered() {
    <strong class="bold1">brushColor = Qt::green;</strong>
}
void MainWindow::on_actionBlue_triggered() {
    <strong class="bold1">brushColor = Qt::blue;</strong>
}</pre>
     </li>
     <li class="calibre14">
      If we compile and run the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker339">
      </a>
      program now, we will get a simple but usable
      <span>
       paint program:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer075">
      <img alt="Figure 4.18 – Our lovely paint program in action!" class="calibre4" src="image/B20976_04_018.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.18 – Our lovely paint program in action!
    </p>
    <h2 class="calibre7" id="_idParaDest-114">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor114">
     </a>
     How it works...
    </h2>
    <p class="calibre3">
     In this example, we created a
     <strong class="source-inline">
      QImage
     </strong>
     widget when the program started. This widget acts as the canvas and will follow the size of the window whenever the window gets resized. In order to draw something on the canvas, we will need to use the mouse events provided by Qt. These events will tell us the position of the cursor, and we will be able to use this information to change the pixels on
     <span>
      the canvas.
     </span>
    </p>
    <p class="calibre3">
     We use a Boolean variable called
     <strong class="source-inline">
      drawing
     </strong>
     to let the program know whether it should start drawing when a mouse button is pressed. In this case, when the left mouse button is pressed, the
     <strong class="source-inline">
      drawing
     </strong>
     variable will be set to
     <strong class="source-inline">
      true
     </strong>
     . We also save the current cursor position to the
     <strong class="source-inline">
      lastPoint
     </strong>
     variable when the left mouse button is pressed, so that Qt will know where it should start drawing. When the mouse moves, the
     <strong class="source-inline">
      mouseMoveEvent()
     </strong>
     event will be triggered by Qt. This is where we need to check whether the drawing variable is set to
     <strong class="source-inline">
      true
     </strong>
     . If it is, then
     <strong class="source-inline">
      QPainter
     </strong>
     can start drawing the lines onto the
     <strong class="source-inline">
      QImage
     </strong>
     widget based on the brush settings that we provide. The brush settings consist of
     <strong class="source-inline">
      brushColor
     </strong>
     and
     <strong class="source-inline">
      brushSize
     </strong>
     . These settings are saved as variables and can be altered by selecting a different setting from the
     <span>
      menu bar.
     </span>
    </p>
    <p class="calibre3">
     Please remember to call the
     <strong class="source-inline">
      update()
     </strong>
     function when the user is drawing on the canvas. Otherwise, the canvas will remain empty even though we have changed the pixel information of the canvas. We also have to call the
     <strong class="source-inline">
      update()
     </strong>
     function when we select
     <strong class="bold">
      File
     </strong>
     |
     <strong class="bold">
      Clear
     </strong>
     from the menu bar to reset
     <span>
      our canvas.
     </span>
    </p>
    <p class="calibre3">
     In this example, we use
     <strong class="source-inline">
      QImage::save()
     </strong>
     to save the image file, which is very straightforward. We use the file dialog
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker340">
     </a>
     to let the user decide where to save the image and its desired filename. Then, we pass the information to
     <strong class="source-inline">
      QImage
     </strong>
     , and it will do the rest by itself. If we don’t specify the file format to the
     <strong class="source-inline">
      QImage::save()
     </strong>
     function,
     <strong class="source-inline">
      QImage
     </strong>
     will try to figure it out by looking at the extension of the
     <span>
      desired filename.
     </span>
    </p>
    <h1 class="calibre5" id="_idParaDest-115">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor115">
     </a>
     Rendering a 2D canvas in QML
    </h1>
    <p class="calibre3">
     In all the previous examples
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker341">
     </a>
     of this chapter, we have discussed the methods and techniques
     <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker342">
     </a>
     used to render 2D graphics with Qt’s C++ API. However, we have yet to learn how to achieve similar results using the powerful
     <span>
      QML script.
     </span>
    </p>
    <h2 class="calibre7" id="_idParaDest-116">
     <a class="pcalibre pcalibre1 calibre6" id="_idTextAnchor116">
     </a>
     How to do it…
    </h2>
    <p class="calibre3">
     In this project, we’ll be doing something
     <span>
      quite different:
     </span>
    </p>
    <ol class="calibre13">
     <li class="calibre14">
      As usual, the first step is to create a new project by going to
      <strong class="bold">
       File
      </strong>
      |
      <strong class="bold">
       New File or Project
      </strong>
      and selecting
      <strong class="bold">
       Qt Quick Application
      </strong>
      as the
      <span>
       project template:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer076">
      <img alt="Figure 4.19 – Creating a new Qt Quick Application project" class="calibre4" src="image/B20976_04_019.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.19 – Creating a new Qt Quick Application project
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="2">
      Once you are done creating
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker343">
      </a>
      the new project, open up
      <strong class="source-inline1">
       main.qml
      </strong>
      , which is
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker344">
      </a>
      listed under
      <strong class="source-inline1">
       qml.qrc
      </strong>
      in the project pane. After that, set an ID for the window and adjust its
      <strong class="source-inline1">
       width
      </strong>
      and
      <strong class="source-inline1">
       height
      </strong>
      values to larger values,
      <span>
       like so:
      </span>
      <pre class="source-code">
import QtQuick
import QtQuick.Window
Window {
    <strong class="bold1">id: myWindow</strong>
<strong class="bold1">    visible: true</strong>
<strong class="bold1">    width: 640</strong>
<strong class="bold1">    height: 480</strong>
<strong class="bold1">    title: qsTr("Hello World")</strong>
}</pre>
     </li>
     <li class="calibre14">
      Then, add a
      <strong class="source-inline1">
       Canvas
      </strong>
      object under
      <strong class="source-inline1">
       myWindow
      </strong>
      and call it
      <strong class="source-inline1">
       myCanvas
      </strong>
      . After that, we make its
      <strong class="source-inline1">
       width
      </strong>
      and
      <strong class="source-inline1">
       height
      </strong>
      values the same
      <span>
       as
      </span>
      <span>
       <strong class="source-inline1">
        myWindow
       </strong>
      </span>
      <span>
       :
      </span>
      <pre class="source-code">
Window {
    id: myWindow
    visible: true
    width: 640
    height: 480
    <strong class="bold1">Canvas {</strong>
<strong class="bold1">        id: myCanvas</strong>
<strong class="bold1">        width: myWindow.width</strong>
<strong class="bold1">        height: myWindow.height</strong>
<strong class="bold1">    }</strong>
}</pre>
     </li>
     <li class="calibre14">
      Next, we define what
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker345">
      </a>
      will happen when the
      <strong class="source-inline1">
       onPaint
      </strong>
      event is triggered; in this
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker346">
      </a>
      case, we will draw a cross on
      <span>
       the window:
      </span>
      <pre class="source-code">
Canvas {
    id: myCanvas
    width: myWindow.width
    height: myWindow.height
    <strong class="bold1">onPaint: {</strong>
<strong class="bold1">        var context = getContext('2d')</strong>
<strong class="bold1">        </strong><strong class="bold1">context.fillStyle = 'white'</strong>
<strong class="bold1">        context.fillRect(0, 0, width, height)</strong>
<strong class="bold1">        context.lineWidth = 2</strong>
<strong class="bold1">        context.strokeStyle = 'black'</strong></pre>
     </li>
     <li class="calibre14">
      Let’s continue to write
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker347">
      </a>
      the code,
      <span>
       like so:
      </span>
      <pre class="source-code">
// Draw cross
context.beginPath()
context.moveTo(50, 50)
context.lineTo(100, 100)
context.closePath()
context.stroke()
context.beginPath()
context.moveTo(100, 50)
context.lineTo(50, 100)
context.closePath()
context.stroke()
}
}</pre>
     </li>
     <li class="calibre14">
      After that, we add the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker348">
      </a>
      following code to draw a tick beside
      <span>
       the cross:
      </span>
      <pre class="source-code">
// Draw tick
context.beginPath()
context.moveTo(150, 90)
context.lineTo(158, 100)
context.closePath()
context.stroke()
context.beginPath()
context.moveTo(180, 100)
context.lineTo(210, 50)
context.closePath()
context.stroke()</pre>
     </li>
     <li class="calibre14">
      Then, draw a triangle shape
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker349">
      </a>
      by adding the
      <span>
       following code:
      </span>
      <pre class="source-code">
// Draw triangle
context.lineWidth = 4
context.strokeStyle = "red"
context.fillStyle = "salmon"
context.beginPath()
context.moveTo(50,150)
context.lineTo(150,150)
context.lineTo(50,250)
context.closePath()
context.fill()
context.stroke()</pre>
     </li>
     <li class="calibre14">
      After that, draw a half
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker350">
      </a>
      circle and a full circle with the
      <span>
       following code:
      </span>
      <pre class="source-code">
// Draw circle
context.lineWidth = 4
context.strokeStyle = "blue"
context.fillStyle = "steelblue"
var pi = 3.141592653589793
context.beginPath()
context.arc(220, 200, 60, 0, pi, true)
context.closePath()
context.fill()
context.stroke()</pre>
     </li>
     <li class="calibre14">
      Then, we draw
      <span>
       an
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker351">
       </a>
      </span>
      <span>
       arc:
      </span>
      <pre class="source-code">
context.beginPath()
context.arc(220, 280, 60, 0, 2 * pi, true)
context.closePath()
context.fill()
context.stroke()</pre>
     </li>
     <li class="calibre14">
      Finally, we draw a 2D
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker352">
      </a>
      image from
      <span>
       a file:
      </span>
      <pre class="source-code">
// Draw image
context.drawImage("tux.png", 280, 10, 150, 174)</pre>
     </li>
     <li class="calibre14">
      However, the preceding code alone will not successfully render an image on screen because you must also load the image file beforehand. Add the following code within the
      <strong class="source-inline1">
       Canvas
      </strong>
      object to ask QML to load the image file when the program is started, then call the
      <strong class="source-inline1">
       requestPaint()
      </strong>
      signal when the image is loaded so that the
      <strong class="source-inline1">
       onPaint()
      </strong>
      event slot will
      <span>
       be triggered:
      </span>
      <pre class="source-code">
onImageLoaded: requestPaint();
onPaint: {
    // The code we added previously
}</pre>
     </li>
     <li class="calibre14">
      Then, open up
      <strong class="source-inline1">
       qml.qrc
      </strong>
      by right-clicking it in the project panel and select
      <strong class="bold">
       Open in Editor
      </strong>
      . After that, add the
      <strong class="source-inline1">
       tux.png
      </strong>
      image file to our
      <span>
       project resource:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer077">
      <img alt="Figure 4.20 – The tux.png image file is now listed under qml.qrc" class="calibre4" src="image/B20976_04_020.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.20 – The tux.png image file is now listed under qml.qrc
    </p>
    <ol class="calibre13">
     <li class="calibre14" value="13">
      Now, build and run the
      <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker353">
      </a>
      program and you should get
      <span>
       the
      </span>
      <span>
       <a class="pcalibre pcalibre1 calibre6" id="_idIndexMarker354">
       </a>
      </span>
      <span>
       following:
      </span>
     </li>
    </ol>
    <div class="calibre2">
     <div class="img---figure" id="_idContainer078">
      <img alt="Figure 4.21 – Tux the penguin is amused by the geometrical shapes" class="calibre4" src="image/B20976_04_021.jpg"/>
     </div>
    </div>
    <p class="img---caption" lang="en-US" xml:lang="en-US">
     Figure 4.21 – Tux the penguin is amused by the geometrical shapes
    </p>
    <p class="calibre3">
     In the preceding example, we learned how to draw simple vector shapes on our screen using the
     <strong class="source-inline">
      Canvas
     </strong>
     element. Qt’s built-in modules make the complex rendering process more straightforward
     <span>
      for programmers.
     </span>
    </p>
   </div>
  </div>
 </body>
</html>
