<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   3: Patterns
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_011.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_013.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <div id="sbo-rt-content">
    <span aria-label="81" epub:type="pagebreak" id="pagebreak_81" role="doc-pagebreak">
    </span>
    <section epub:type="chapter" id="CH0003" role="doc-chapter" xmlns:epub="http://www.idpf.org/2007/ops">
     <h1 class="chaptitle" epub:type="title" id="B9780443222191000192">
      3: Patterns
     </h1>
     <section epub:type="preamble">
      <a id="abs0010">
      </a>
      <div class="abstract">
       <h2 class="h1hd" id="cesectitle0010">
        Abstract
       </h2>
       <div id="abssec0010">
        <p class="abspara" id="abspara0010">
         Design patterns offer general solutions to common software design problems. This chapter provides details for various design patterns and C++ idioms that are particularly relevant to application programming interface (API) design. This includes the pimpl idiom, which provides a way to hide all internal details from your public header files. The Singleton pattern provides access to global state. Its implementation in C++ can be tricky, so singleton best practices and thread safety are covered. The Factory Method patterns make up for several limitations of C++ constructors and can be used to hide implementation details for derived classes. Various patterns for wrapping a new API on top of an incompatible or legacy interface are covered. These include the Proxy, Adapter, and Façade patterns. Finally, the Observer pattern is introduced as a solution to reduce coupling between otherwise unrelated classes.
        </p>
       </div>
      </div>
     </section>
     <section>
      <h3 class="h2hd" id="cesectitle0015">
       Keywords
      </h3>
      <div class="keywords">
       Adapter; Dependency injection; Design pattern; Façade; Factory; Monostate; Observer; Pimpl; Proxy; Singleton
      </div>
     </section>
     <section>
      <p class="textfl" id="p0010">
       In the previous chapter, I discussed the qualities that differentiate a good application programming interface (API) from a bad one. In the next couple of chapters, I'll focus on the techniques and principles of building high-quality APIs. In this chapter, I will cover several useful design patterns and idioms that relate to C++ API design.
      </p>
      <p class="text" id="p0015">
       A design pattern is a general solution to a common software design problem. The term was made popular by the book
       <i>
        Design Patterns: Elements of Reusable Object-Oriented Software
       </i>
       , also known as the
       <i>
        Gang of Four
       </i>
       book (
       <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib33" id="bib_33">
        Gamma et al., 1994
       </a>
       ). That book introduced a collection of 23 generic design patterns organized into three main categories, which are enumerated in
       <a href="#t0010" id="Bt0010">
        Table 3.1
       </a>
       .
      </p>
      <p class="text" id="p0020">
       Since the initial publication of the design pattern book in 1994, several more design patterns have been added to this list, including an entire new categorization of Concurrency design patterns. The original authors have also suggested an improved categorization of Core, Creational, Periphery, and Other (
       <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib34" id="bib_34">
        Gamma et al., 2009
       </a>
       ).
      </p>
      <p class="text" id="p0025">
       However, it's not the intent of this API book to cover all of these design patterns. There are plenty of other books on the market that focus solely on that topic. Instead, I will concentrate on those design patterns that are of particular importance to the design of high-quality APIs, and discuss their practical implementation in C++. I will also cover C++ idioms that may not be considered true generic design patterns, but which are nevertheless important techniques for C++ API design. Specifically, I will go into details for these techniques:
      </p>
      <div>
       <ol id="ulist0010">
        <li class="bulllist" id="p0030">
         <a id="u0010">
         </a>
         ▪
         <b>
          Pimpl idiom.
         </b>
         This technique lets you completely hide internal details from your public header files. Essentially, it lets you move private member data and functions to the
         <span class="inlinecode">
          .cpp
         </span>
         file. It is therefore an indispensable tool for creating well-insulated APIs.
        </li>
        <li class="bulllist" id="p0035">
         <a id="u0015">
         </a>
         ▪
         <b>
          Singleton and Factory Methods.
         </b>
         These are two very common creational design patterns that are good to understand deeply. Singleton is useful when you want to enforce that only one instance of an object is ever created. It has some rather tricky implementation aspects in C++ that I'll explore. The Factory Method pattern provides a generalized way to create instances of an object and can be a great way to hide implementation details for a derived class.
        </li>
        <li class="bulllist" id="p0040">
         <a id="u0020">
         </a>
         ▪
         <b>
          Proxy, Adapter, and Façade.
         </b>
         These structural patterns describe various solutions for wrapping an API on top of an existing incompatible or legacy interface. This is often the entire goal of writing an API: to improve the interface of some poorly designed ball of code. The Proxy and Adapter patterns provide a one-to-one
         <a id="p82">
         </a>
         <span aria-label="82" epub:type="pagebreak" id="pagebreak_82" role="doc-pagebreak">
         </span>
         mapping of new classes to preexisting classes, whereas the Façade provides a simplified interface to a larger collection of classes.
        </li>
        <li>
         <div class="pageavoid">
          <p class="tnum">
           <a href="#Bt0010">
            Table 3.1
           </a>
          </p>
          <div class="big_device">
           <table class="tbody" id="t0010">
            <caption class="ttitle">
             The 23 design patterns introduced by
             <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib33">
              Gamma et al. (1994)
             </a>
             .
            </caption>
            <tbody>
             <tr>
              <td class="tb" colspan="2">
               Creational patterns
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Abstract Factory
              </th>
              <td class="tb">
               Encapsulates a group of related factories.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Builder
              </th>
              <td class="tb">
               Separates a complex object's construction from its representation.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Factory Method
              </th>
              <td class="tb">
               Lets a class defer instantiation to subclasses.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Prototype
              </th>
              <td class="tb">
               Specifies a prototypical instance of a class that can be cloned to produce new objects.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Singleton
              </th>
              <td class="tb">
               Ensures a class has only one instance.
              </td>
             </tr>
             <tr>
              <td class="tb" colspan="2">
               Structural patterns
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Adapter
              </th>
              <td class="tb">
               Converts the interface of one class into another interface.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Bridge
              </th>
              <td class="tb">
               Decouples an abstraction from its implementation so that both can be changed independently.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Composite
              </th>
              <td class="tb">
               Composes objects into tree structures to represent part–whole hierarchies.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Decorator
              </th>
              <td class="tb">
               Adds additional behavior to an existing object in a dynamic fashion.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Façade
              </th>
              <td class="tb">
               Provides a unified higher-level interface to a set of interfaces in a subsystem.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Flyweight
              </th>
              <td class="tb">
               Uses sharing to support large numbers of fine-grained objects efficiently.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Proxy
              </th>
              <td class="tb">
               Provides a surrogate or placeholder for another object to control access to it.
              </td>
             </tr>
             <tr>
              <td class="tb" colspan="2">
               Behavioral patterns
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Chain of Responsibility
              </th>
              <td class="tb">
               Gives more than one receiver object a chance to handle a request from a sender object.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Command
              </th>
              <td class="tb">
               Encapsulates a request or operation as an object, with support for undoable operations.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Interpreter
              </th>
              <td class="tb">
               Specifies how to represent and evaluate sentences in a language.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Iterator
              </th>
              <td class="tb">
               Provides a way to access the elements of an aggregate object sequentially.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Mediator
              </th>
              <td class="tb">
               Defines an object that encapsulates how a set of objects interact.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Memento
              </th>
              <td class="tb">
               Captures an object's internal state so that it can be restored to the same state later.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Observer
              </th>
              <td class="tb">
               Allows a one-to-many notification of state changes between objects.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               State
              </th>
              <td class="tb">
               Allows an object to appear to change its type when its internal state changes.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Strategy
              </th>
              <td class="tb">
               Defines a family of algorithms, encapsulates each one, and makes them interchangeable at run time.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Template Method
              </th>
              <td class="tb">
               Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses.
              </td>
             </tr>
             <tr>
              <th class="tb" scope="row">
               Visitor
              </th>
              <td class="tb">
               Represents an operation to be performed on the elements of an object structure.
              </td>
             </tr>
            </tbody>
           </table>
          </div>
         </div>
        </li>
        <li class="bulllist" id="p0045">
         <a id="u0025">
         </a>
         ▪
         <b>
          Observer.
         </b>
         This behavioral pattern can be used to reduce direct dependencies between classes. It allows conceptually unrelated classes to communicate by allowing one class (the observer) to register for notifications from another class (the subject). As such, this pattern is an important aspect of designing loosely coupled APIs.
        </li>
       </ol>
      </div>
      <p class="text" id="p0050">
       In addition to covering these patterns and idioms in this chapter, I will discuss the Thread-Safe Interface pattern in
       <a href="../B9780443222191000076/CH0009_367-381_B9780443222191000076.xhtml">
        Chapter 9
       </a>
       (Concurrency) and the Visitor behavioral pattern in
       <a href="../B9780443222191000040/CH0015_533-564_B9780443222191000040.xhtml">
        Chapter 15
       </a>
       (Extensibility).
       <a id="p83">
       </a>
      </p>
      <div>
       <span aria-label="83" epub:type="pagebreak" id="pagebreak_83" role="doc-pagebreak">
       </span>
      </div>
      <section>
       <a id="s0010">
       </a>
       <h2 class="h1hd" id="cesectitle0020">
        Pimpl idiom
       </h2>
       <p class="textfl" id="p0055">
        The term pimpl was first introduced by Jeff Sumner as shorthand for pointer to implementation (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib97" id="bib_97">
         Sutter, 1999
        </a>
        ). This technique can be used to avoid exposing private details in your header files (
        <a href="#f0010" id="Bf0010">
         Fig. 3.1
        </a>
        ). It's therefore an important mechanism to help you maintain a strong separation between your API's interface and implementation (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib98" id="bib_98">
         Sutter and Alexandrescu, 2004
        </a>
        ). Although pimpl is not strictly a design pattern (it's a work-around to C++ specific limitations), it is an idiom that can be considered a special case of the Bridge design pattern.
       </p>
       <p class="text" id="p0060">
        If you change one programming habit after reading this book, I hope you'll choose to pimpl more API code.
       </p>
       <div>
        <aside aria-labelledby="b0010" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0010">
          <div class="b1textfl" id="bpar0010">
           <i>
            TIP: Use the pimpl idiom to keep implementation details out of your public header files.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <section>
        <a id="s0015">
        </a>
        <h3 class="h2hd" id="cesectitle0025">
         Using pimpl
        </h3>
        <p class="textfl" id="p0065">
         Pimpl relies on the fact that it's possible to define a data member of a C++ class that is a pointer to a forward declared type: that is, where the type has been introduced only by name and has not yet been fully defined, thus allowing us to hide the definition of that type within the
         <span class="inlinecode">
          .cpp
         </span>
         file. This is often called an opaque pointer because the user cannot see the details for the object being pointed to. In essence, pimpl is a way to employ both logical and physical hiding of your private data members and functions.
         <a id="p84">
         </a>
        </p>
        <section>
         <a id="sf0010">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0010">
           <img alt="image" height="1241" src="../../IMAGES/B9780443222191000192/main.assets/f03-01-9780443222191.jpg" width="1668"/>
           <figcaption class="figleg">
            <a id="cap0010">
            </a>
            <a id="fspara0010">
            </a>
            <span class="fignum">
             <a href="#Bf0010">
              Figure 3.1
             </a>
            </span>
            The pimpl idiom, in which a public class has a private pointer to a hidden implementation class.
           </figcaption>
          </figure>
         </div>
        </section>
        <div>
         <span aria-label="84" epub:type="pagebreak" id="pagebreak_84" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0070">
         Let's look at an example to illustrate this. Consider the following API for an autotimer, a named object that prints out how long it was alive when it's destroyed:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0045">
           <img alt="image" height="1644" src="../../IMAGES/B9780443222191000192/main.assets/u03-01-9780443222191.jpg" width="2183"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0075">
         This API violates a number of the important qualities I presented in the previous chapter. For example, it includes platform-specific defines and it makes the underlying implementation details of how the timer is stored on different platforms visible to anyone looking at the header file. To be fair, the API does a good job of exposing only the necessary methods as public (i.e., the constructor and destructor) and marking the remaining methods and data members as private. However, C++ requires you to declare these private members in the public header file, and this is why you have to include the platform-specific
         <span class="inlinecode">
          #if
         </span>
         directives.
        </p>
        <p class="text" id="p0080">
         What you really want to do is to hide all of the private members in the
         <span class="inlinecode">
          .cpp
         </span>
         file. Then you wouldn't need to include any of those bothersome platform specifics. The pimpl idiom lets you do this by placing all of the private members into a class (or struct) that is forward declared in the header but defined in the
         <span class="inlinecode">
          .cpp
         </span>
         file. For example, you could recast the previous header using pimpl as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0050">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000192/main.assets/u03-02-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p85">
         </a>
        </p>
        <section>
         <a id="sf0050">
         </a>
        </section>
        <div>
         <span aria-label="85" epub:type="pagebreak" id="pagebreak_85" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0085">
         Now the API is much cleaner! There are no platform-specific preprocessor directives, and the reader cannot see any of the class's private members by looking at the header file.
        </p>
        <p class="text" id="p0090">
         The implication, however, is that our
         <span class="inlinecode">
          AutoTimer
         </span>
         constructor must now allocate an object of type
         <span class="inlinecode">
          AutoTimer::Impl
         </span>
         and then destroy it in its destructor. Also, all private members must be accessed via the
         <span class="inlinecode">
          mImpl
         </span>
         pointer. However, for most practical cases, the benefit of presenting a clean implementation-free API far outweighs these costs.
        </p>
        <p class="text" id="p0095">
         To be complete, let's see what the underlying implementation looks like to work with this pimpled class. The resulting
         <span class="inlinecode">
          .cpp
         </span>
         file looks a little bit messy owing to the platform-specific
         <span class="inlinecode">
          #ifdef
         </span>
         lines, but the important thing is that this messiness is completely contained in the
         <span class="inlinecode">
          .cpp
         </span>
         file now:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0055">
           <img alt="image" height="2272" src="../../IMAGES/B9780443222191000192/main.assets/u03-03-9780443222191.jpg" width="1756"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p86">
         </a>
        </p>
        <section>
         <a id="sf0055">
         </a>
        </section>
        <div>
         <span aria-label="86" epub:type="pagebreak" id="pagebreak_86" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0100">
         Here you see the definition of the
         <span class="inlinecode">
          AutoTimer::Impl
         </span>
         class, containing all of the private methods and variables that were originally exposed in the header. Note also that the
         <span class="inlinecode">
          AutoTimer
         </span>
         constructor allocates a new
         <span class="inlinecode">
          AutoTimer::Impl
         </span>
         object and initializes its members, and the destructor deallocates this object.
        </p>
        <p class="text" id="p0105">
         In the previous design, I declared the
         <span class="inlinecode">
          Impl
         </span>
         class as a private nested class within the
         <span class="inlinecode">
          AutoTimer
         </span>
         class. Declaring it as a nested class avoids polluting the global namespace with this implementation-specific symbol, and declaring it as private means that it does not pollute the public API of your class. However, declaring it to be private imposes the limitation that only the methods of
         <span class="inlinecode">
          AutoTimer
         </span>
         can access the members of the
         <span class="inlinecode">
          Impl
         </span>
         . Other classes or free functions in the
         <span class="inlinecode">
          .cpp
         </span>
         file will not be able to access
         <span class="inlinecode">
          Impl
         </span>
         . As an alternative, if this poses too much of a limitation, you could instead declare the
         <span class="inlinecode">
          Impl
         </span>
         class to be a public nested class, as in this example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0060">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000192/main.assets/u03-04-9780443222191.jpg" width="2253"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div id="p0110">
        </div>
        <div>
         <aside aria-labelledby="b0015" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0015">
           <div class="b1textfl" id="bpar0015">
            <i>
             TIP: When using the pimpl idiom, prefer to use a private nested implementation class. Only use a public nested Impl class (or a public nonnested class) if other classes or free functions in the .cpp must access Impl members.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         Another design question worth considering is how much logic to locate in the
         <span class="inlinecode">
          Impl
         </span>
         class. Some options include:
        </p>
        <div>
         <ul class="ce_list" id="olist0010">
          <li class="numlist" id="p0115">
           <a id="o0010">
           </a>
           1. Only private member variables,
          </li>
          <li class="numlist" id="p0120">
           <a id="o0015">
           </a>
           2. Private member variables and methods, or
          </li>
          <li class="numlist" id="p0125">
           <a id="o0020">
           </a>
           3. All methods of the public class, such that the public methods are simply thin wrappers on top of equivalent methods in the
           <span class="inlinecode">
            Impl
           </span>
           class.
          </li>
         </ul>
        </div>
        <p class="text" id="p0130">
         Each of these options may be appropriate under different circumstances. However, in general, I recommend option 2: putting all private member variables and private
         <a id="p87">
         </a>
         <span aria-label="87" epub:type="pagebreak" id="pagebreak_87" role="doc-pagebreak">
         </span>
         methods in the
         <span class="inlinecode">
          Impl
         </span>
         class. This lets you maintain the encapsulation of data and methods that act upon those data and lets you avoid declaring private methods in the public header file. Note that I adopted this design approach in our previous example by putting the
         <span class="inlinecode">
          GetElapsed()
         </span>
         method inside the
         <span class="inlinecode">
          Impl
         </span>
         class. Herb Sutter notes a couple of caveats with this approach (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib97">
          Sutter, 1999
         </a>
         ):
        </p>
        <div>
         <ul class="ce_list" id="olist0015">
          <li class="numlist" id="p0135">
           <a id="o0025">
           </a>
           1. You can't hide private virtual methods in the implementation class. These must appear in the public class so that any derived classes are able to override them.
          </li>
          <li class="numlist" id="p0140">
           <a id="o0030">
           </a>
           2. You may need to add a pointer in the implementation class back to the public class so that the
           <span class="inlinecode">
            Impl
           </span>
           class can call public methods.
          </li>
         </ul>
        </div>
       </section>
       <section>
        <a id="s0020">
        </a>
        <h3 class="h2hd" id="cesectitle0030">
         Copy semantics
        </h3>
        <p class="textfl" id="p0145">
         A C++ compiler will create a copy constructor and assignment operator for your class if you don't explicitly define them. However, these default constructors will perform only a shallow copy of your object. This is bad for pimpled classes because it means that if a client copies your object, then both objects will point to the same implementation object,
         <span class="inlinecode">
          Impl
         </span>
         . However, both objects will attempt to delete this same
         <span class="inlinecode">
          Impl
         </span>
         object in their destructors, which will most likely lead to a crash. There are two main options for dealing with this:
        </p>
        <div>
         <ul class="ce_list" id="olist0020">
          <li class="numlist" id="p0150">
           <a id="o0035">
           </a>
           1.
           <b>
            Make your class uncopyable.
           </b>
           If you don't intend for your users to create copies of an object, then you can declare the object to be noncopyable. As of C++11, you can easily do this by deleting the default compiler-generated copy constructor and assignment operator functions using the
           <span title='hsp="0.25"'>
           </span>
           =
           <span title='hsp="0.25"'>
           </span>
           <span class="inlinecode">
            delete
           </span>
           syntax. Alternatively, if you need a C++98 solution, you can declare a copy constructor and assignment operator with no implementation to prevent the compiler from generating its own versions. Additionally, you can declare these functions as private, so that attempts to copy the object will generate a compile error rather than a link error.
          </li>
          <li class="numlist" id="p0155">
           <a id="o0040">
           </a>
           2.
           <b>
            Explicitly define the copy semantics.
           </b>
           If you do want your users to be able to copy your pimpled objects, then you can define your own copy constructor and assignment operator. These can then perform a deep copy of your object (i.e., create a copy of the
           <span class="inlinecode">
            Impl
           </span>
           object instead of just copying the pointer). I cover how to write your own constructors and operators in the C++ Usage chapter later in this book. However, an even better solution is simply to use a smart pointer for your
           <span class="inlinecode">
            Impl
           </span>
           pointer because these already have well-defined copy semantics.
          </li>
         </ul>
        </div>
        <p class="text" id="p0160">
         The next code example provides an updated version of our
         <span class="inlinecode">
          AutoTimer
         </span>
         API, where I've made the object noncopyable by deleting the copy constructor and assignment operator. The associated
         <span class="inlinecode">
          .cpp
         </span>
         file doesn't need to change:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0065">
           <img alt="image" height="950" src="../../IMAGES/B9780443222191000192/main.assets/u03-05-9780443222191.jpg" width="1836"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p88">
         </a>
        </p>
        <div>
         <span aria-label="88" epub:type="pagebreak" id="pagebreak_88" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0065">
         </a>
        </section>
        <p class="text" id="p0165">
         In the next section, I'll show how you can use a smart pointer to define the copy semantics of your pimpled object explicitly and also make the memory management of the
         <span class="inlinecode">
          Impl
         </span>
         object more robust.
        </p>
       </section>
       <section>
        <a id="s0025">
        </a>
        <h3 class="h2hd" id="cesectitle0035">
         Pimpl and smart pointers
        </h3>
        <p class="textfl" id="p0170">
         One of the inconvenient and error-prone aspects of pimpl is the need to allocate and deallocate the implementation object. Every now and then you may forget to the delete the object in your destructor, or you may introduce bugs by accessing the
         <span class="inlinecode">
          Impl
         </span>
         object before you've allocated it or after you've destroyed it. As a convention, you should therefore ensure that the very first thing your constructor does is to allocate the
         <span class="inlinecode">
          Impl
         </span>
         object (preferably via its initialization list), and the very last thing your destructor does is to delete it.
        </p>
        <p class="text" id="p0175">
         Alternatively, you could rely upon smart pointers to make this more robust. That is, you could use a shared pointer or a unique pointer to hold the implementation object pointer. An
         <span class="inlinecode">
          std::shared_ptr
         </span>
         would allow the object to be copied without incurring the double delete issues I identified earlier. Using a shared pointer would, of course, mean that any copy would point to the same
         <span class="inlinecode">
          Impl
         </span>
         object in memory. If you need the copied object to have a copy of the
         <span class="inlinecode">
          Impl
         </span>
         object, then you will still need to write your own copy constructor and assignment operators (or use a copy-on-write pointer, as described in the Performance chapter). Here's an example of using the pimpl idiom with a shared pointer:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0070">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000192/main.assets/u03-06-9780443222191.jpg" width="1663"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p89">
         </a>
        </p>
        <section>
         <a id="sf0070">
         </a>
        </section>
        <div>
         <span aria-label="89" epub:type="pagebreak" id="pagebreak_89" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0180">
         Alternatively, you could use an
         <span class="inlinecode">
          std::unique_ptr
         </span>
         instead of an
         <span class="inlinecode">
          std::shared_ptr
         </span>
         as another way to make the object noncopyable, because a unique pointer is noncopyable by definition.
        </p>
        <div>
         <aside aria-labelledby="b0020" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0020">
           <div class="b1textfl" id="bpar0020">
            <i>
             TIP: Think about the copy semantics of your pimpl classes, and favor the use of a shared or unique pointer to manage initialization and destruction of the implementation pointer.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0185">
         Using either a shared or unique pointer means that the
         <span class="inlinecode">
          Impl
         </span>
         object will be automatically freed when the
         <span class="inlinecode">
          AutoTimer
         </span>
         object is destroyed: you no longer need to delete it explicitly in the destructor. So the destructor of our
         <span class="inlinecode">
          autotimer.cpp
         </span>
         file can now be reduced simply to:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0075">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000192/main.assets/u03-07-9780443222191.jpg" width="2255"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0030">
        </a>
        <h3 class="h2hd" id="cesectitle0040">
         Advantages of pimpl
        </h3>
        <p class="textfl" id="p0190">
         There are many advantages to employing the pimpl idiom in your classes. These include:
        </p>
        <div>
         <ol id="ulist0015">
          <li class="bulllist" id="p0195">
           <a id="u0030">
           </a>
           •
           <b>
            Information hiding.
           </b>
           Private members are now completely hidden from your public interface. This allows you to keep your implementation details hidden (and proprietary in the case of closed-source APIs). It also means that your public header files are cleaner and more clearly express the true public interface. As a result, they can be more easily read and digested by your users. One further benefit of information hiding is that your users cannot as easily use dirty tactics to gain access to your private members, such as doing the following, which is actually legal in C++ (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52" id="bib_52">
            Lakos, 1996
           </a>
           ):
          </li>
         </ol>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0080">
           <img alt="image" height="197" src="../../IMAGES/B9780443222191000192/main.assets/u03-08-9780443222191.jpg" width="2150"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <ol id="ulist0020">
          <li class="bulllist" id="p0200">
           <a id="u0035">
           </a>
           •
           <b>
            Reduced coupling.
           </b>
           As I showed in the
           <span class="inlinecode">
            AutoTimer
           </span>
           example earlier, without pimpl, your public header files must include header files for all your private member variables. In our example, this meant having to include
           <span class="inlinecode">
            windows.h
           </span>
           or
           <span class="inlinecode">
            sys/time.h
           </span>
           . This increases the compile-time coupling of your API on other parts of the system.
           <a id="p90">
           </a>
           <span aria-label="90" epub:type="pagebreak" id="pagebreak_90" role="doc-pagebreak">
           </span>
           Using pimpl, you can move those dependencies into the
           <span class="inlinecode">
            .cpp
           </span>
           file and remove those elements of coupling.
          </li>
          <li class="bulllist" id="p0205">
           <a id="u0040">
           </a>
           •
           <b>
            Faster compiles.
           </b>
           Another implication of moving implementation-specific includes to the
           <span class="inlinecode">
            .cpp
           </span>
           file is that the include hierarchy of your API is reduced. This can have a very direct effect on compile times (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
            Lakos, 1996
           </a>
           ). I will detail the benefits of minimizing include dependencies in the Performance chapter.
          </li>
          <li class="bulllist" id="p0210">
           <a id="u0045">
           </a>
           •
           <b>
            Greater binary compatibility.
           </b>
           The size of a pimpled object never changes because your object is always the size of a single pointer. Any changes you make to private member variables (recall that member variables should always be private) will affect only the size of implementation class that is hidden inside of the
           <span class="inlinecode">
            .cpp
           </span>
           file. This makes it possible to make major implementation changes without changing the binary representation of your object.
          </li>
         </ol>
        </div>
       </section>
       <section>
        <a id="s0035">
        </a>
        <h3 class="h2hd" id="cesectitle0045">
         Disadvantages of pimpl
        </h3>
        <p class="textfl" id="p0215">
         The primary disadvantage of the pimpl idiom is that you must now allocate and free an additional implementation object for every object that's created. This increases the size of your object by the size of a pointer and may introduce a performance hit for the extra level of pointer indirection required to access all member variables, as well as the cost for additional calls to
         <span class="inlinecode">
          new
         </span>
         and
         <span class="inlinecode">
          delete
         </span>
         . If you're concerned with the memory allocator performance, then you may consider using the Fast Pimpl idiom (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib97">
          Sutter, 1999
         </a>
         ) in which you overload the
         <span class="inlinecode">
          new
         </span>
         and
         <span class="inlinecode">
          delete
         </span>
         operators for your
         <span class="inlinecode">
          Impl
         </span>
         class to use a more efficient small-memory fixed-size allocator.
        </p>
        <p class="text" id="p0220">
         There is also the extra developer inconvenience of prefixing all private member accesses with something like
         <span class="inlinecode">
          mImpl-&gt;
         </span>
         . This can make the implementation code harder to read and debug owing to the additional layer of abstraction. This becomes even more complicated when the
         <span class="inlinecode">
          Impl
         </span>
         class has a pointer back to the public class. However, these inconveniences are not exposed to users of your API and are therefore not a concern from the point of view of your API's design. They are a burden that you, the developer, must shoulder for all of your users to receive a cleaner and more efficient API. To quote a certain science officer and his captain: “The needs of the many outweigh the needs of the few.” “Or the one.”
        </p>
        <p class="text" id="p0225">
         One final issue to be aware of is that the compiler will no longer catch changes to member variables within const methods. This is because member variables now live in a separate object. Your compiler will check only that you don't change the value of the
         <span class="inlinecode">
          mImpl
         </span>
         pointer in a const method, but not whether you change any members pointed to by
         <span class="inlinecode">
          mImpl
         </span>
         . In effect, every member function of a pimpled class could be defined as const (except, of course, the constructor or destructor). This is demonstrated by the following const method that legally changes a variable in the
         <span class="inlinecode">
          Impl
         </span>
         object:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0085">
           <img alt="image" height="255" src="../../IMAGES/B9780443222191000192/main.assets/u03-09-9780443222191.jpg" width="1871"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p91">
         </a>
        </p>
        <section>
         <a id="sf0085">
         </a>
        </section>
        <div>
         <span aria-label="91" epub:type="pagebreak" id="pagebreak_91" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0230">
         This can be addressed by introducing two private functions to access the
         <span class="inlinecode">
          Impl
         </span>
         pointer: one const and one nonconst. That way, the compiler will enforce that you use the const version in a const method. If the const function also returns a
         <span class="inlinecode">
          const Impl
         </span>
         pointer, then you also get compiler const checking for your
         <span class="inlinecode">
          Impl
         </span>
         methods. For example:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0090">
           <img alt="image" height="1861" src="../../IMAGES/B9780443222191000192/main.assets/u03-10-9780443222191.jpg" width="2144"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0040">
        </a>
        <h3 class="h2hd" id="cesectitle0050">
         Opaque pointers in C
        </h3>
        <p class="textfl" id="p0235">
         Although I have focused on C++ so far, you can create opaque pointers in plain C, too. The concept is the same: you create a pointer to a struct that is only defined in a
         <span class="inlinecode">
          .c
         </span>
         file. The next header files demonstrate what this might look like in C:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0095">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000192/main.assets/u03-11-9780443222191.jpg" width="2117"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p92">
         </a>
        </p>
        <section>
         <a id="sf0095">
         </a>
        </section>
        <div>
         <span aria-label="92" epub:type="pagebreak" id="pagebreak_92" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0240">
         The associated .
         <span class="inlinecode">
          c
         </span>
         file might then look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0100">
           <img alt="image" height="2406" src="../../IMAGES/B9780443222191000192/main.assets/u03-12-9780443222191.jpg" width="1658"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p93">
         </a>
        </p>
        <section>
         <a id="sf0100">
         </a>
        </section>
        <div>
         <span aria-label="93" epub:type="pagebreak" id="pagebreak_93" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0015">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0015">
           <img alt="image" height="689" src="../../IMAGES/B9780443222191000192/main.assets/f03-02-9780443222191.jpg" width="1001"/>
           <figcaption class="figleg">
            <a id="cap0015">
            </a>
            <a id="fspara0015">
            </a>
            <span class="fignum">
             <a href="#Bf0015">
              Figure 3.2
             </a>
            </span>
            Unified Modeling Language (UML) diagram of the Singleton design pattern.
           </figcaption>
          </figure>
         </div>
        </section>
       </section>
      </section>
      <section>
       <a id="s0045">
       </a>
       <h2 class="h1hd" id="cesectitle0055">
        Singleton
       </h2>
       <p class="textfl" id="p0245">
        The Singleton design pattern (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib33">
         Gamma et al., 1994
        </a>
        ) is used to ensure that a class only ever has one instance. The pattern also provides a global point of access to that single instance (
        <a href="#f0015" id="Bf0015">
         Fig. 3.2
        </a>
        ). You can think of a singleton as a more elegant global variable. However, it offers several advantages over the use of global variables because it:
       </p>
       <div>
        <ul class="ce_list" id="olist0025">
         <li class="numlist" id="p0250">
          <a id="o0045">
          </a>
          1. Enforces that only one instance of the class can be created.
         </li>
         <li class="numlist" id="p0255">
          <a id="o0050">
          </a>
          2. Provides control over the allocation and destruction of the object.
         </li>
         <li class="numlist" id="p0260">
          <a id="o0055">
          </a>
          3. Allows support for thread-safe access to the object's global state.
         </li>
         <li class="numlist" id="p0265">
          <a id="o0060">
          </a>
          4. Avoids polluting the global namespace.
         </li>
         <li class="numlist" id="p0270">
          <a id="o0065">
          </a>
          5. Avoids the nondeterministic initialization problem of nonlocal static constructors.
         </li>
        </ul>
       </div>
       <p class="text" id="p0275">
        The Singleton pattern is useful for modeling resources that are inherently singular in nature, such as a class to access the system clock, the global clipboard, or the keyboard. It's also useful for creating manager classes that provide a single point of access to multiple resources, such as a thread manager or an event manager. On the other hand, the singleton is still essentially a way to add global variables to your system, albeit in a more manageable fashion. It can therefore introduce global state and dependencies into your API that are difficult to refactor later, as well as making it difficult to write unit tests that exercise isolated parts of your code.
       </p>
       <p class="text" id="p0280">
        I have decided to cover the concept of singletons here partly because they offer a useful and common API design technique. However, another reason is that they are intricate to implement robustly in C++, and so it's worth discussing some of the implementation details. Also, many programmers tend to overuse the Singleton pattern, so I wanted to highlight some of the disadvantages of singletons as well as provide alternative techniques.
       </p>
       <div>
        <aside aria-labelledby="b0025" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0025">
          <div class="b1textfl" id="bpar0025">
           <i>
            TIP: A Singleton is a more elegant way to maintain global state, but you should always question whether you need global state.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <p class="textfl">
        <a id="p94">
        </a>
       </p>
       <div>
        <span aria-label="94" epub:type="pagebreak" id="pagebreak_94" role="doc-pagebreak">
        </span>
       </div>
       <section>
        <a id="s0050">
        </a>
        <h3 class="h2hd" id="cesectitle0060">
         Implementing singletons in C++
        </h3>
        <p class="textfl" id="p0285">
         The Singleton pattern involves creating a class with a static method that returns the same instance of the class every time it's called. This static method is often called
         <span class="inlinecode">
          GetInstance()
         </span>
         , or similar. There are several C++ language features to consider when designing a singleton class:
        </p>
        <div>
         <ol id="ulist0025">
          <li class="bulllist" id="p0290">
           <a id="u0050">
           </a>
           • You don't want clients to be able to create new instances. This can be done by declaring the default constructor to be private, thus preventing the compiler from automatically creating it as public.
          </li>
          <li class="bulllist" id="p0295">
           <a id="u0055">
           </a>
           • You want the singleton to be noncopyable, to enforce that a second instance cannot be created. As you've seen earlier, this can be done by declaring a private copy constructor and a private assignment operator, or by using the
           <span class="inlinecode">
            delete
           </span>
           specifier as of C++11.
          </li>
          <li class="bulllist" id="p0300">
           <a id="u0060">
           </a>
           • You want to prevent clients from being able to delete the singleton instance. This can be done by declaring the destructor to be private. (Note, however, that some compilers, such as Borland 5.5 and Visual Studio 6, incorrectly produce an error if you try to declare a destructor as private).
          </li>
          <li class="bulllist" id="p0305">
           <a id="u0065">
           </a>
           • The
           <span class="inlinecode">
            GetInstance()
           </span>
           method could return either a pointer or a reference to the singleton class. However, if you return a pointer, clients could potentially delete the object. You should therefore prefer returning a reference.
          </li>
         </ol>
        </div>
        <p class="text" id="p0310">
         The general form of a singleton as of C++11 can therefore be given as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0105">
           <img alt="image" height="815" src="../../IMAGES/B9780443222191000192/main.assets/u03-13-9780443222191.jpg" width="1838"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0315">
         Then user code can request a reference to the singleton instance as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0110">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000192/main.assets/u03-14-9780443222191.jpg" width="1455"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0320">
         Note that making the constructor and destructor private also means that clients cannot create subclasses of the singleton. However, if you wish to allow this, you can, of course, simply declare them to be protected instead.
         <a id="p95">
         </a>
         <span aria-label="95" epub:type="pagebreak" id="pagebreak_95" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0030" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0030">
           <div class="b1textfl" id="bpar0030">
            <i>
             TIP: Declare the constructor, destructor, copy constructor, and assignment operator to be private (or protected) to enforce the Singleton property. Or delete the copy constructor and assignment operator with the
            </i>
            <span class="inlinecode">
             <i>
              delete
             </i>
            </span>
            <i>
             specifier.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0325">
         In terms of implementation, one of the areas to be very careful about is how the singleton instance is allocated. The important C++ initialization issue to recognize is explained by Scott Meyers as:
        </p>
        <div>
         <div id="disp0010">
          <p class="quote" epub:type="epigraph" id="p0860" role="doc-epigraph">
           The relative order of initialization of non-local static objects in different translation units is undefined.
          </p>
          <p class="dispquotesrc">
           (
           <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib70" id="bib_70">
            Meyers, 2005
           </a>
           ).
          </p>
         </div>
        </div>
        <p class="text" id="p0330">
         This means that it would be dangerous to initialize our singleton using a nonlocal static variable. A nonlocal object is one that is declared outside a function or method. Static objects include global objects, objects declared as static inside a class or function, and objects defined at file or namespace scope. As a result, one way to initialize our singleton would be to create a static variable inside a method of our class, as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0115">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000192/main.assets/u03-15-9780443222191.jpg" width="1212"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0335">
         One nice property of this approach is that the instance will be allocated only when the
         <span class="inlinecode">
          GetInstance()
         </span>
         method is first called. This means that if the singleton is never requested, the object is never allocated. However, on the downside, Andrei Alexandrescu notes that this technique relies on the standard last in first out deallocation behavior of static variables, which can result in singletons being deallocated before they should in situations where singletons call other singletons in their destructors. As an example of this problem, consider two singletons:
         <span class="inlinecode">
          Clipboard
         </span>
         and
         <span class="inlinecode">
          LogFile
         </span>
         . When
         <span class="inlinecode">
          Clipboard
         </span>
         is instantiated, it also instantiates
         <span class="inlinecode">
          LogFile
         </span>
         to output some diagnostic information. At program exit,
         <span class="inlinecode">
          LogFile
         </span>
         is destroyed first because it was created last, then
         <span class="inlinecode">
          Clipboard
         </span>
         is destroyed. However, the
         <span class="inlinecode">
          Clipboard
         </span>
         destructor tries to call
         <span class="inlinecode">
          LogFile
         </span>
         to log the fact that it is being destroyed, but
         <span class="inlinecode">
          LogFile
         </span>
         has already been freed. This will most likely result in a crash on program exit.
        </p>
        <p class="text" id="p0340">
         In his
         <i>
          Modern C++ Design
         </i>
         book, Alexandrescu presents several solutions to this destruction order problem, including resurrecting the singleton if it is needed after it has been destroyed, increasing the longevity of a singleton so that it can outlive other singletons, and simply not deallocating the singleton (i.e., relying on the operating system to free all allocated memory and close any file handles). If you find yourself needing to implement one of these solutions, I refer you to this book for the details (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib3" id="bib_3">
          Alexandrescu, 2001
         </a>
         ).
         <a id="p96">
         </a>
        </p>
        <div>
         <span aria-label="96" epub:type="pagebreak" id="pagebreak_96" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0345">
         Another issue to be aware of when working with singletons is that processes have their own address space, so each process that loads a given library will have its own instances of any static variables. Also, static variables defined within plugins that are opened at run time with
         <span class="inlinecode">
          dlopen
         </span>
         may not share the same memory address as other plugins or even the main program, so the use of singletons in plugins can be unsafe.
        </p>
       </section>
       <section>
        <a id="s0055">
        </a>
        <h3 class="h2hd" id="cesectitle0065">
         Singletons and thread safety
        </h3>
        <p class="textfl" id="p0350">
         The C++98 and C++03 standards did not specify how code should behave in a multithreaded environment. In particular, the initialization of static variables was not thread-safe. Under these early versions of the standard, if two threads happened to call our
         <span class="inlinecode">
          GetInstance()
         </span>
         method at the same time, then the instance could be constructed twice, or it could be used by one thread before it had been fully initialized by the other thread.
        </p>
        <p class="text" id="p0355">
         This issue was addressed in the C++11 standard, which states that only one thread can enter the initialization of a static and that the compiler must not introduce any deadlocks around its initialization. So the previous implementation of
         <span class="inlinecode">
          GetInstance()
         </span>
         is thread-safe as of C++11.
        </p>
        <p class="text" id="p0360">
         In the first edition of this book, I spent several pages describing thread-safe solutions for Singletons in C++03 by introducing mutex locking and considering optimizations such as the Double Check Locking Pattern. However, at this point, C++11 is well-established, and if you want to write thread-safe code in general, you should be using at least C++11. In this edition of the book, I will therefore simply state that if you want to have thread-safe Singletons, you should use a C++11 (or later) compiler.
        </p>
        <div>
         <aside aria-labelledby="b0035" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0035">
           <div class="b1textfl" id="bpar0035">
            <i>
             TIP: If you use Singletons, you should use a C++11 (or later) compiler for thread safety.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0060">
        </a>
        <h3 class="h2hd" id="cesectitle0070">
         Singleton versus dependency injection
        </h3>
        <p class="textfl" id="p0365">
         Dependency injection is a technique in which an object is passed into a class (injected), rather than having the class create and store the object itself. Martin Fowler coined the term in 2004 as a more specific form of the Inversion of Control concept. As a simple example, consider this class that depends upon a database object:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0120">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000192/main.assets/u03-16-9780443222191.jpg" width="2357"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p97">
         </a>
        </p>
        <section>
         <a id="sf0120">
         </a>
        </section>
        <div>
         <span aria-label="97" epub:type="pagebreak" id="pagebreak_97" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0370">
         The problem with this approach is that if the
         <span class="inlinecode">
          Database
         </span>
         constructor is changed, or if someone changes the password for the account called user in the live database, then you will have to change
         <span class="inlinecode">
          MyClass
         </span>
         to fix the problem. Also, it's difficult to unit test this object because the database implementation is embedded within it. And from an efficiency point of view, every instance of
         <span class="inlinecode">
          MyClass
         </span>
         will create a new
         <span class="inlinecode">
          Database
         </span>
         instance. As an alternative, you can use dependency injection to pass a preconfigured
         <span class="inlinecode">
          Database
         </span>
         object into
         <span class="inlinecode">
          MyClass
         </span>
         , as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0125">
           <img alt="image" height="602" src="../../IMAGES/B9780443222191000192/main.assets/u03-17-9780443222191.jpg" width="1492"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0375">
         In this way,
         <span class="inlinecode">
          MyClass
         </span>
         no longer needs to know how to create a
         <span class="inlinecode">
          Database
         </span>
         instance. Instead, it gets passed an already constructed and configured
         <span class="inlinecode">
          Database
         </span>
         object for it to use. I've changed the raw pointer to a shared pointer so that the dependency can be based on an abstract interface instead of a concrete object, and because
         <span class="inlinecode">
          MyClass
         </span>
         no longer controls the lifetime of the database object. For example, if we have a
         <span class="inlinecode">
          MyDatabase
         </span>
         concrete subclass of the abstract
         <span class="inlinecode">
          Database
         </span>
         type, then the
         <span class="inlinecode">
          MyClass
         </span>
         object can be created as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0130">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000192/main.assets/u03-18-9780443222191.jpg" width="1388"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0380">
         Or, even better, you can use a Factory Method (which I'll discuss later in this chapter) to create the instance, such as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0135">
           <img alt="image" height="81" src="../../IMAGES/B9780443222191000192/main.assets/u03-19-9780443222191.jpg" width="1213"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0385">
         This example demonstrates constructor injection (i.e., passing the dependent object via the constructor), but you could just as easily pass in dependencies via a setter member function.
        </p>
        <p class="text" id="p0390">
         Dependency injection can be viewed as a way to avoid the proliferation of singletons by encouraging interfaces that accept the single instance as an input rather than requesting it internally via a
         <span class="inlinecode">
          GetInstance()
         </span>
         method. This also enables better unit testing because the dependencies of an object can be substituted with stub or mock versions for the purposes of testing (e.g., by passing in a
         <span class="inlinecode">
          TestDatabase
         </span>
         instance within your test code). I'll discuss this further in the Testing chapter.
         <a id="p98">
         </a>
         <span aria-label="98" epub:type="pagebreak" id="pagebreak_98" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0040" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0040">
           <div class="b1textfl" id="bpar0040">
            <i>
             TIP: Dependency injection reduces coupling between objects and makes it easier to support unit testing.
            </i>
           </div>
          </div>
         </aside>
        </div>
       </section>
       <section>
        <a id="s0065">
        </a>
        <h3 class="h2hd" id="cesectitle0075">
         Singleton versus Monostate
        </h3>
        <p class="textfl" id="p0395">
         Most of the problems that are associated with the Singleton pattern derive from the fact that it’s designed to hold and control access to global state. However, if you don't need to control when the state is initialized, or if you don't need to store state in the singleton object itself, then there are other techniques you can use, such as the Monostate design pattern.
        </p>
        <p class="text" id="p0400">
         The Monostate pattern allows multiple instances of a class to be created in which all of those instances use the same static data. For instance, here's a simple case of the Monostate pattern:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0140">
           <img alt="image" height="718" src="../../IMAGES/B9780443222191000192/main.assets/u03-20-9780443222191.jpg" width="1664"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0405">
         In this example, you can create multiple instances of the
         <span class="inlinecode">
          Monostate
         </span>
         class, but all calls to the
         <span class="inlinecode">
          GetTheAnswer()
         </span>
         method will return the same result, because all instances share the same static variable
         <span class="inlinecode">
          sAnswer
         </span>
         . You could also hide the declaration of the static variable from the header completely just by declaring it as a file-scope static variable in
         <span class="inlinecode">
          monostate.cpp
         </span>
         instead of a private class static variable. Static members do not contribute to the per instance size of a class, so doing this will have no physical impact on the API other than to hide implementation details from the header.
        </p>
        <p class="text" id="p0410">
         Some benefits of the Monostate pattern are that it:
        </p>
        <div>
         <ol id="ulist0030">
          <li class="bulllist" id="p0415">
           <a id="u0070">
           </a>
           ▪ Allows multiple instances to be created.
          </li>
          <li class="bulllist" id="p0420">
           <a id="u0075">
           </a>
           ▪ Offers transparent usage, because no special
           <span class="inlinecode">
            GetInstance()
           </span>
           method is needed.
          </li>
          <li class="bulllist" id="p0425">
           <a id="u0080">
           </a>
           ▪ Exhibits well-defined creation and destruction semantics, by using static variables.
          </li>
         </ol>
        </div>
        <p class="text" id="p0430">
         As Robert C. Martin notes, Singleton enforces the structure of singularity by allowing only one instance to be created, whereas Monostate enforces the behavior of singularity by sharing the same data for all instances (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib60" id="bib_60">
          Martin, 2002
         </a>
         ).
         <a id="p99">
         </a>
         <span aria-label="99" epub:type="pagebreak" id="pagebreak_99" role="doc-pagebreak">
         </span>
        </p>
        <div>
         <aside aria-labelledby="b0045" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0045">
           <div class="b1textfl" id="bpar0045">
            <i>
             TIP: Consider using Monostate instead of Singleton if you don't need lazy initialization of global data or if you want the singular nature of the class to be transparent.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="text" id="p0435">
         As a further real-world example, the Second Life source code uses the Monostate pattern for its
         <span class="inlinecode">
          LLWeb
         </span>
         class. This example uses a version of Monostate in which all member functions are declared static:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0145">
           <img alt="image" height="1008" src="../../IMAGES/B9780443222191000192/main.assets/u03-21-9780443222191.jpg" width="2287"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0440">
         In this case,
         <span class="inlinecode">
          LLWeb
         </span>
         is simply a manager class that provides a single access point to the functionality for opening Web pages. The actual Web browser functionality itself is implemented in other classes. The
         <span class="inlinecode">
          LLWeb
         </span>
         class does not hold any state itself, although, of course, internally any of the static methods could access static variables. Note that another way to implement this would be to create an
         <span class="inlinecode">
          LLWeb
         </span>
         namespace with free functions within that namespace.
        </p>
        <p class="text" id="p0445">
         One of the drawbacks with this static method version of Monostate is that you cannot subclass any of the static methods, because static member functions cannot be virtual. Also, because you no longer instantiate the class, you cannot write a constructor or destructor to perform any initialization or cleanup. This is necessary in this case because
         <span class="inlinecode">
          LLWeb
         </span>
         accesses dynamically allocated global state instead of relying on static variables that are initialized by the compiler. The creator of
         <span class="inlinecode">
          LLWeb
         </span>
         got around this limitation by introducing an
         <span class="inlinecode">
          initClass()
         </span>
         static method that requires a client program to initialize the class explicitly. A better design may have been to hide this call within the
         <span class="inlinecode">
          .cpp
         </span>
         file and invoke it lazily from each of the public static methods. However, in that case, the same thread safety concerns I raised earlier would be applicable.
         <a id="p100">
         </a>
        </p>
        <div>
         <span aria-label="100" epub:type="pagebreak" id="pagebreak_100" role="doc-pagebreak">
         </span>
        </div>
       </section>
       <section>
        <a id="s0070">
        </a>
        <h3 class="h2hd" id="cesectitle0080">
         Singleton versus session state
        </h3>
        <p class="textfl" id="p0450">
         In a recent retrospective interview, the authors of the original design patterns book stated that the only pattern they would consider removing from the original list is Singleton. This is because it's essentially a way to store global data and tends to be an indicator of poor design (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib34">
          Gamma et al., 2009
         </a>
         ).
        </p>
        <p class="text" id="p0455">
         Therefore, as a final note on the topic of singletons, I urge you to really think about whether a singleton is the correct pattern for your needs. It's often easy to think that you will only ever need a single instance of a given class. However, requirements change and code evolves, and in the future you may find that you need to support multiple instances of the class.
        </p>
        <p class="text" id="p0460">
         For example, consider that you're writing a simple text editor. You use a singleton to hold the current text style (e.g., bold, italics, underlined), because the user can only ever have one style active at one time. However, this restriction is valid only because of the initial assumption that the program can edit only one document at a time. In a later version of the program, you are asked to add support for multiple documents, each with their own current text style. Now you have to refactor your code to remove the singleton. Ultimately, singletons should be used only to model objects that are truly singular in their nature. For example, there is only one system clipboard, so it may still be reasonable to model the clipboard for the text editor as a singleton.
        </p>
        <p class="text" id="p0465">
         Often, it's useful to think about introducing a session or execution context object into your system early on. This is a single instance that holds all of the state for your code, rather than representing that state with multiple singletons. For example, in the text editor example, you might introduce a
         <span class="inlinecode">
          Document
         </span>
         object. This will have accessors for things such as the current text style, but those objects do not have to be enforced as singletons. They are just plain classes that can be accessed from the
         <span class="inlinecode">
          Document
         </span>
         class as
         <span class="inlinecode">
          document-&gt;GetTextStyle()
         </span>
         . You can start off with a single
         <span class="inlinecode">
          Document
         </span>
         instance, accessible by a call such as
         <span class="inlinecode">
          Document::GetCurrent(),
         </span>
         for instance. You might even implement
         <span class="inlinecode">
          Document
         </span>
         as a singleton to begin with. However, if you later need to add support for multiple contexts (i.e., multiple documents), then your code is in a much healthier state to support this because you have only one singleton to refactor instead of dozens. J.B. Rainsberger refers to this as a Toolbox Singleton, in which the application becomes the singleton, not the individual classes (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib80" id="bib_80">
          Rainsberger, 2001
         </a>
         ).
        </p>
        <div>
         <aside aria-labelledby="b0050" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0050">
           <div class="b1textfl" id="bpar0050">
            <i>
             TIP: There are several alternatives to the Singleton pattern, including dependency injection, the Monostate pattern, and the use of a session context.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p101">
         </a>
        </p>
        <div>
         <span aria-label="101" epub:type="pagebreak" id="pagebreak_101" role="doc-pagebreak">
         </span>
        </div>
       </section>
      </section>
      <section>
       <a id="s0075">
       </a>
       <h2 class="h1hd" id="cesectitle0085">
        Factory Methods
       </h2>
       <p class="textfl" id="p0470">
        A Factory Method is a creational design pattern that allows you to create objects without having to specify the specific C++ type of the object to create. In essence, a Factory Method is a generalization of a constructor. Constructors in C++ have several limitations, such as:
       </p>
       <div>
        <ul class="ce_list" id="olist0030">
         <li class="numlist" id="p0475">
          <a id="o0070">
          </a>
          1.
          <b>
           No return result.
          </b>
          You cannot return a result from a constructor. This means that you can't signal an error during the initialization of an object by returning a
          <span class="inlinecode">
           nullptr
          </span>
          , for instance (although you can signal an error by throwing an exception within a constructor).
         </li>
         <li class="numlist" id="p0480">
          <a id="o0075">
          </a>
          2.
          <b>
           Constrained naming.
          </b>
          A constructor is easily distinguished because it is constrained to have the same name as the class in which it lives. However, this also limits its flexibility. For example, you cannot have two constructors that both take a single integer argument.
         </li>
         <li class="numlist" id="p0485">
          <a id="o0080">
          </a>
          3.
          <b>
           Statically bound creation.
          </b>
          When constructing an object, you must specify the name of a concrete class that's known at compile time (e.g., you might write:
          <span class="inlinecode">
           Foo ∗f = new Foo;
          </span>
          where
          <span class="inlinecode">
           Foo
          </span>
          is a specific type that must be known by the compiler). There's no concept of dynamic binding at run time for constructors in C++.
         </li>
         <li class="numlist" id="p0490">
          <a id="o0085">
          </a>
          4.
          <b>
           No virtual constructors.
          </b>
          You can't declare a virtual constructor in C++. As I have just noted, you must specify the exact type of the object to be constructed at compile time. The compiler therefore allocates the memory for that specific type and then calls the default constructor for any base classes (unless you explicitly specify a nondefault constructor in the initialization list). It then calls the constructor for the specific type itself. This is also why you can't call virtual methods from the constructor and expect them to call the derived override (because the derived class hasn't been initialized yet).
         </li>
        </ul>
       </div>
       <p class="text" id="p0495">
        In contrast, Factory Methods circumvent all these limitations. At a basic level, a Factory Method is simply a normal method call that can return an instance of a class. However, they are often used in combination with inheritance, in which a derived class can override the Factory Method and return an instance of that derived class. It's also very common to implement factories using abstract base classes (ABCs) (DeLoura, 2001). So before I dive deeper into using Factory Methods, let's recap what ABCs are, as well as the related concept of interfaces.
       </p>
       <section>
        <a id="s0080">
        </a>
        <h3 class="h2hd" id="cesectitle0090">
         Abstract base classes and interfaces
        </h3>
        <p class="textfl" id="p0500">
         An ABC is a class that contains one or more pure virtual member functions. Such a class is not concrete and therefore cannot be instantiated using the
         <span class="inlinecode">
          new
         </span>
         operator. Instead, it's used as a base class, in which derived classes can provide an implementation for each of the pure virtual methods.
         <a id="p102">
         </a>
        </p>
        <div>
         <span aria-label="102" epub:type="pagebreak" id="pagebreak_102" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0505">
         There is also a related term called interface. Languages such as Java have an actual keyword called interface, but the term is less well-defined in the context of C++. Some C++ developers consider it to be a synonym for ABC. However, I believe it's generally accepted that an interface is a more specific version of an abstract class that only contains pure virtual functions (i.e., it has no implementation code or state), whereas the term ABC refers more generally to a class that can have one or more pure virtual functions but also nonpure virtual functions, implementation code, or data members. For example, consider the code:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0150">
           <img alt="image" height="776" src="../../IMAGES/B9780443222191000192/main.assets/u03-22-9780443222191.jpg" width="2218"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0510">
         This defines an interface to describe an extremely simple 3D graphics renderer. I've named the class with an I prefix to indicate that it's an interface. An alternative naming convention might be to use a suffix such as -able, -ible, or -ing (e.g.,
         <span class="inlinecode">
          Renderable)
         </span>
         . The
         <span class="inlinecode">
          = 0
         </span>
         suffix on the methods declares them to be pure virtual methods, meaning that they must be overridden in a derived class for that class to be concrete. The
         <span class="inlinecode">
          IRenderer
         </span>
         class is therefore an interface because it contains only pure virtual functions, other than the defaulted virtual destructor.
        </p>
        <p class="text" id="p0515">
         Note that it’s not strictly true to say that pure virtual methods provide no implementation. You can provide a default implementation for pure virtual methods in your
         <span class="inlinecode">
          .cpp
         </span>
         file. For example, you could provide an implementation for
         <span class="inlinecode">
          SetViewportSize()
         </span>
         in
         <span class="inlinecode">
          renderer.cpp,
         </span>
         and then a derived class would be able to call
         <span class="inlinecode">
          IRenderer::SetViewportSize()
         </span>
         , although it would still have to override the method explicitly as well. By our previous definition, we would then prefer to call this an ABC class rather than an interface because it provides an implementation for one or more of the virtual functions.
        </p>
        <p class="text" id="p0520">
         An ABC or interface is useful to describe abstract units of behaviors that can be shared by multiple classes. They specify a contract to which all concrete derived classes must conform. You might use an interface if you wanted to define only a set of rules for an object to follow without defining any specific behavior. Alternatively, you would use an ABC if you also wanted to provide a default implementation for those rules.
         <a id="p103">
         </a>
        </p>
        <div>
         <span aria-label="103" epub:type="pagebreak" id="pagebreak_103" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0525">
         As with any class that has one or more virtual methods, you should always declare the destructor of an ABC or interface to be virtual. This code illustrates why this is important:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0155">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000192/main.assets/u03-23-9780443222191.jpg" width="2359"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
       <section>
        <a id="s0085">
        </a>
        <h3 class="h2hd" id="cesectitle0095">
         Simple factory example
        </h3>
        <p class="textfl" id="p0530">
         Now that I've reviewed the concepts of ABCs and interfaces, let's use them to provide a simple Factory Method. I'll continue with the previous
         <span class="inlinecode">
          renderer.h
         </span>
         example and start by declaring the factory for objects of type
         <span class="inlinecode">
          IRenderer
         </span>
         :
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0160">
           <img alt="image" height="544" src="../../IMAGES/B9780443222191000192/main.assets/u03-24-9780443222191.jpg" width="1906"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0535">
         That's all there is to declaring a Factory Method: it's just a normal method that can return an instance of an object. Note that this method cannot return an instance of the specific type
         <span class="inlinecode">
          IRenderer
         </span>
         because that's an abstract class and cannot be instantiated. However, it can return instances of derived classes. Also, you can use the string argument to
         <span class="inlinecode">
          CreateRenderer()
         </span>
         to specify which derived type you want to create.
        </p>
        <p class="text" id="p0540">
         Let's assume that you've implemented three concrete derived classes of
         <span class="inlinecode">
          IRenderer
         </span>
         :
         <span class="inlinecode">
          OpenGLRenderer
         </span>
         ,
         <span class="inlinecode">
          DirectXRenderer
         </span>
         , and
         <span class="inlinecode">
          MesaRenderer
         </span>
         . Let's further specify that you don't
         <a id="p104">
         </a>
         <span aria-label="104" epub:type="pagebreak" id="pagebreak_104" role="doc-pagebreak">
         </span>
         want users of your API to have any knowledge of the existence of these types: they must be completely hidden behind the API. Based on these conditions, you can provide an implementation of our Factory Method as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0165">
           <img alt="image" height="1297" src="../../IMAGES/B9780443222191000192/main.assets/u03-25-9780443222191.jpg" width="2322"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0545">
         This Factory Method can therefore return any of the three derived classes of
         <span class="inlinecode">
          IRenderer
         </span>
         , depending upon the type string that the client passes in. This lets users decide which derived class to create at run time, not compile time, as a normal constructor requires you to do. This is an enormous advantage because it means that you can create different classes based upon user input, or upon the contents of a configuration file that's read at run time.
        </p>
        <p class="text" id="p0550">
         Also, note that the header files for the various concrete derived classes are included only in the factory's
         <span class="inlinecode">
          .cpp
         </span>
         file. They do not appear in the
         <span class="inlinecode">
          rendererfactory.h
         </span>
         public header. In effect, these are private header files and do not need to be distributed with your API. As such, users can never see the private details of your different renderers, and they can't ever see the specific types used to implement these different renderers. Users only ever specify a renderer via a string value, or an enum if you expect the set of renderers to be statically defined at compile time.
        </p>
        <div>
         <aside aria-labelledby="b0055" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0055">
           <div class="b1textfl" id="bpar0055">
            <i>
             TIP: Use Factory Methods to provide more powerful class construction semantics and to hide subclass details.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p105">
         </a>
        </p>
        <div>
         <span aria-label="105" epub:type="pagebreak" id="pagebreak_105" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0555">
         This example demonstrates a perfectly acceptable Factory Method. However, one potential drawback is that it contains hardcoded knowledge of the available derived classes. If you add a new renderer to the system, you must edit
         <span class="inlinecode">
          rendererfactory.cpp
         </span>
         . This is not terribly burdensome, and most important, it will not affect the public API. However, it does mean that you can't add support for new derived classes at run time. More specifically, it means that your users can't add new renderers to the system. I will address these concerns by presenting an extensible object factory.
        </p>
       </section>
       <section>
        <a id="s0090">
        </a>
        <h3 class="h2hd" id="cesectitle0100">
         Extensible factory example
        </h3>
        <p class="textfl" id="p0560">
         To decouple the concrete derived classes from the Factory Method and allow new derived classes to be added at run time, you can update the factory class to maintain a map that associates type names to object creation callbacks (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib3">
          Alexandrescu, 2001
         </a>
         ). You can then allow new derived classes to be registered and unregistered using a couple of new method calls. The ability to register new classes at run time allows this form of the Factory Method pattern to be used to create extensible plugin interfaces for your API, as I will detail in
         <a href="../B9780443222191000210/CH0012_443-485_B9780443222191000210.xhtml">
          Chapter 12
         </a>
         .
        </p>
        <p class="text" id="p0565">
         One further issue to note is that the factory object must now hold state. As such, it would be best to enforce that only one factory object is ever created. This is why most factory objects are also singletons. In the interests of simplicity, however, I will use static methods and variables in our example here. Putting all of these points together, here's what our new object factory might look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0170">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000192/main.assets/u03-26-9780443222191.jpg" width="2152"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p106">
         </a>
        </p>
        <section>
         <a id="sf0170">
         </a>
        </section>
        <div>
         <span aria-label="106" epub:type="pagebreak" id="pagebreak_106" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0570">
         For completeness, the associated
         <span class="inlinecode">
          .cpp
         </span>
         file might look like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0175">
           <img alt="image" height="1586" src="../../IMAGES/B9780443222191000192/main.assets/u03-27-9780443222191.jpg" width="2357"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0575">
         A user of your API can now register (and unregister) new renderers in your system. The compiler will ensure that the user's new renderer conforms to your
         <span class="inlinecode">
          IRenderer
         </span>
         interface (i.e., that it provides an implementation for all of the pure virtual methods in
         <span class="inlinecode">
          IRenderer)
         </span>
         . To illustrate this, the subsequent code shows how users could define their own renderer, register it with the object factory, then ask the factory to create an instance of it:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0180">
           <img alt="image" height="1413" src="../../IMAGES/B9780443222191000192/main.assets/u03-28-9780443222191.jpg" width="2357"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p107">
         </a>
        </p>
        <section>
         <a id="sf0180">
         </a>
        </section>
        <div>
         <span aria-label="107" epub:type="pagebreak" id="pagebreak_107" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0580">
         One point worth noting here is that I added a
         <span class="inlinecode">
          Create()
         </span>
         function to the
         <span class="inlinecode">
          UserRenderer
         </span>
         class. This is because the register method of the factory needs to take a callback that returns an object. This callback doesn't have to be part of the
         <span class="inlinecode">
          IRenderer
         </span>
         class (it could be a free function, for example). However, adding it to the
         <span class="inlinecode">
          IRenderer
         </span>
         class is a good idea to keep all of the related functionality in the same place.
        </p>
        <p class="text" id="p0585">
         Note that in the previous extensible factory example, a renderer callback has to be visible to the
         <span class="inlinecode">
          RegisterRenderer()
         </span>
         function at run time. However, this doesn't mean that you have to expose the built-in renderers of your API. These can still be hidden either by registering them within your API initialization routine or by using a hybrid of the simple factory and the extensible factory, in which the Factory Method first checks the type string against a few built-in names, and if none of those match it, then it checks for any names that have been registered by the user. This hybrid approach has the potentially desirable behavior that users cannot override your built-in classes.
        </p>
        <p class="text" id="p0590">
         I'll conclude the discussion of the Factory Method pattern by looking at a real-world example in a large C++ API. The Visualization ToolKit (VTK) is an open source package for manipulating and displaying scientific data (see
         <a href="https://vtk.org/">
          https://vtk.org/
         </a>
         ). The base
         <span class="inlinecode">
          vtkObject
         </span>
         has a protected constructor, so it cannot be created
         <span class="inlinecode">
          new
         </span>
         or on the stack. The library then provides a
         <span class="inlinecode">
          vtkObjectFactory
         </span>
         to create VTK objects. This contains a static method called
         <span class="inlinecode">
          CreateInstance()
         </span>
         that creates an object from a list of registered
         <span class="inlinecode">
          vtkObjectFactory
         </span>
         subclasses. Those subclasses override a
         <span class="inlinecode">
          CreateObject()
         </span>
         protected method to implement the logic to create the object instance. The first time
         <span class="inlinecode">
          CreateInstance()
         </span>
         is called, all shared libraries are loaded into the current process. The key functions of the
         <span class="inlinecode">
          vtkObjectFactory
         </span>
         class are:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0185">
           <img alt="image" height="949" src="../../IMAGES/B9780443222191000192/main.assets/u03-29-9780443222191.jpg" width="2357"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
       </section>
      </section>
      <section>
       <a id="s0095">
       </a>
       <h2 class="h1hd" id="cesectitle0105">
        API wrapping patterns
       </h2>
       <p class="textfl" id="p0595">
        Writing a wrapper interface that sits on top of another set of classes is a relatively common API design task. For example, perhaps you're working with a large legacy code
        <a id="p108">
        </a>
        <span aria-label="108" epub:type="pagebreak" id="pagebreak_108" role="doc-pagebreak">
        </span>
        base, and rather than rearchitecting all of that code you decide to design a new cleaner API that hides the underlying legacy code (
        <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib29" id="bib_29">
         Feathers, 2004
        </a>
        ). Or perhaps you have written a C++ API and need to expose a plain C interface for certain clients. Or perhaps you have a third-party library dependency that you want your clients to be able to access, but you don't want to expose that library directly to them.
       </p>
       <p class="text" id="p0600">
        The downside of creating a wrapper API is the potential performance hit you may experience owing to the extra level of indirection, and the overhead of any extra state that needs to be stored at the wrapper level. However, this is often worth the cost to expose a higher-quality or more focused API, such as in the cases mentioned earlier.
       </p>
       <p class="text" id="p0605">
        There are several structural design patterns that deal with the task of wrapping one interface on top of another. I will describe three of these patterns in the following sections. These are, in increasing deviation between the wrapper layer and the original interface: Proxy, Adapter, and Façade.
       </p>
       <section>
        <a id="s0100">
        </a>
        <h3 class="h2hd" id="cesectitle0110">
         The Proxy pattern
        </h3>
        <p class="textfl" id="p0610">
         The Proxy design pattern provides a one-to-one forwarding interface to another class. Calling
         <span class="inlinecode">
          FunctionA()
         </span>
         in the proxy class will cause it to call
         <span class="inlinecode">
          FunctionA()
         </span>
         in the original class (
         <a href="#f0020" id="Bf0020">
          Fig. 3.3
         </a>
         ). That is, the proxy class and the original class have the same interface. This can be thought of as a single-component wrapper, to use the terminology of
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
          Lakos (1996)
         </a>
         : that is, a single class in the proxy API maps to a single class in the original API.
        </p>
        <p class="text" id="p0615">
         This pattern is often implemented by making the proxy class store a copy of, or more likely a pointer to, the original class. Then the methods of the proxy class simply redirect to the method with the same name in the original object. A downside of this technique is the need to reexpose functions in the original object, a process that essentially equates to code duplication. This approach therefore requires diligence to maintain the integrity of the proxy interface when making changes to the original object. The following code provides a simple example of this technique:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0190">
           <img alt="image" height="1181" src="../../IMAGES/B9780443222191000192/main.assets/u03-30-9780443222191.jpg" width="1421"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p109">
         </a>
        </p>
        <section>
         <a id="sf0190">
         </a>
        </section>
        <div>
         <span aria-label="109" epub:type="pagebreak" id="pagebreak_109" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0020">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0020">
           <img alt="image" height="392" src="../../IMAGES/B9780443222191000192/main.assets/f03-03-9780443222191.jpg" width="2752"/>
           <figcaption class="figleg">
            <a id="cap0020">
            </a>
            <a id="fspara0020">
            </a>
            <span class="fignum">
             <a href="#Bf0020">
              Figure 3.3
             </a>
            </span>
            UML diagram of the Proxy design pattern.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0620">
         An alternative solution is to augment this approach by using an abstract interface that's shared by both the proxy and original APIs. This allows the proxy object to be interchangeable with the original one, which can often be desirable. However, this approach requires you to be able to modify the original API if it doesn't already derive from an abstract interface. The code shown here demonstrates this approach:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0195">
           <img alt="image" height="1876" src="../../IMAGES/B9780443222191000192/main.assets/u03-31-9780443222191.jpg" width="1524"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <div>
         <aside aria-labelledby="b0060" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0060">
           <div class="b1textfl" id="bpar0060">
            <i>
             TIP: A Proxy provides an interface that forwards function calls to another interface of the same form.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p110">
         </a>
        </p>
        <div>
         <span aria-label="110" epub:type="pagebreak" id="pagebreak_110" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0625">
         A Proxy pattern is useful to modify the behavior of the
         <span class="inlinecode">
          Original
         </span>
         class while still preserving its interface. This is particularly useful if the
         <span class="inlinecode">
          Original
         </span>
         class is in a third-party library and hence not easily modifiable directly. Some use cases for the Proxy pattern include:
        </p>
        <div>
         <ul class="ce_list" id="olist0035">
          <li class="numlist" id="p0630">
           <a id="o0090">
           </a>
           1.
           <b>
            Implement lazy instantiation of the Original object.
           </b>
           In this case, the
           <span class="inlinecode">
            Original
           </span>
           object is not actually instantiated until a method call is invoked. This can be useful if instantiating the
           <span class="inlinecode">
            Original
           </span>
           object is a heavyweight operation that you wish to defer until absolutely necessary.
          </li>
          <li class="numlist" id="p0635">
           <a id="o0095">
           </a>
           2.
           <b>
            Implement access control to the Original object.
           </b>
           For example, you may wish to insert a permissions layer between the
           <span class="inlinecode">
            Proxy
           </span>
           and the
           <span class="inlinecode">
            Original
           </span>
           objects to ensure that users can call only certain methods on the
           <span class="inlinecode">
            Original
           </span>
           object if they have the appropriate permission.
          </li>
          <li class="numlist" id="p0640">
           <a id="o0100">
           </a>
           3.
           <b>
            Support debug or dry run modes.
           </b>
           This lets you insert debugging statements into the
           <span class="inlinecode">
            Proxy
           </span>
           methods to log all calls to the
           <span class="inlinecode">
            Original
           </span>
           object. Or you can stop the forwarding to certain
           <span class="inlinecode">
            Original
           </span>
           methods with a flag to let you call the
           <span class="inlinecode">
            Proxy
           </span>
           in a dry run mode, such as to turn off writing the object's state to disk.
          </li>
          <li class="numlist" id="p0645">
           <a id="o0105">
           </a>
           4.
           <b>
            Make the Original class be thread-safe.
           </b>
           This can be done by adding mutex locking to the relevant methods that are not thread-safe. Although this may not be the most efficient way to make the underlying class thread-safe, it's a useful stopgap if you cannot modify
           <span class="inlinecode">
            Original
           </span>
           .
          </li>
          <li class="numlist" id="p0650">
           <a id="o0110">
           </a>
           5.
           <b>
            Support resource sharing.
           </b>
           You could have multiple
           <span class="inlinecode">
            Proxy
           </span>
           objects share the same underlying
           <span class="inlinecode">
            Original
           </span>
           class. For example, this could be used to implement reference counting or copy-on-write semantics. This case is actually another design pattern, called the Flyweight pattern, in which multiple objects share the same underlying data to minimize memory footprint.
          </li>
          <li class="numlist" id="p0655">
           <a id="o0115">
           </a>
           6.
           <b>
            Protect against future changes in the Original class.
           </b>
           In this case, you anticipate that a dependent library will change in the future, so you create a Proxy wrapper around that API that directly mimics the current behavior. When the library changes in the future, you can preserve the old interface via your Proxy object and simply change its underlying implementation to use the new library methods. At that point, you will no longer have a Proxy object, but an Adapter, which is a nice segue to our next pattern.
          </li>
         </ul>
        </div>
       </section>
       <section>
        <a id="s0105">
        </a>
        <h3 class="h2hd" id="cesectitle0115">
         The Adapter pattern
        </h3>
        <p class="textfl" id="p0660">
         The Adapter design pattern translates the interface for one class into a compatible but different interface (
         <a href="#f0025" id="Bf0025">
          Fig. 3.4
         </a>
         ). This is therefore similar to the Proxy pattern in that it's a single-component wrapper. However, the interface for the Adapter class and the Original class may be different.
        </p>
        <p class="text" id="p0665">
         This pattern is useful to be able to expose a different interface for an existing API to allow it to work better with other code. As in the case for the Proxy pattern, the two interfaces in question could come from different libraries. For example, consider a
         <a id="p111">
         </a>
         <span aria-label="111" epub:type="pagebreak" id="pagebreak_111" role="doc-pagebreak">
         </span>
         geometry package that lets you define a series of primitive shapes. The parameters for certain methods may be in a different order from those that you use in your API, or they may be specified in a different coordinate system, or using a different convention such as (center, size) versus (bottom-left, top-right), or the method names may not follow your API's naming convention. You could therefore use an Adapter class to convert this interface into a compatible form for your API. For example,
        </p>
        <div class="pageavoid">
         <figure class="fig" id="f0025">
          <img alt="image" height="392" src="../../IMAGES/B9780443222191000192/main.assets/f03-04-9780443222191.jpg" width="2751"/>
          <figcaption class="figleg">
           <a id="cap0025">
           </a>
           <a id="fspara0025">
           </a>
           <span class="fignum">
            <a href="#Bf0025">
             Figure 3.4
            </a>
           </span>
           UML diagram of the Adapter design pattern.
          </figcaption>
         </figure>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0200">
           <img alt="image" height="1413" src="../../IMAGES/B9780443222191000192/main.assets/u03-32-9780443222191.jpg" width="1802"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0670">
         In this example, the
         <span class="inlinecode">
          RectangleAdapter
         </span>
         uses a different method name and calling conventions to set the dimensions of the rectangle compared with the underlying
         <span class="inlinecode">
          Rectangle
         </span>
         class. The functionality is the same in both cases. You're just exposing a different interface to allow you to work with the class more easily.
        </p>
        <div>
         <aside aria-labelledby="b0065" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0065">
           <div class="b1textfl" id="bpar0065">
            <i>
             TIP: An Adapter translates one interface into a compatible but different interface.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p112">
         </a>
        </p>
        <div>
         <span aria-label="112" epub:type="pagebreak" id="pagebreak_112" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0675">
         It should be noted that Adapters can be implemented using composition (as in the previous example) or inheritance. These two flavors are often referred to as object adapters or class adapters, respectively. In the inheritance case,
         <span class="inlinecode">
          RectangleAdapter
         </span>
         would derive from the
         <span class="inlinecode">
          Rectangle
         </span>
         base class. This could be done using public inheritance if you wanted to also expose the interface of
         <span class="inlinecode">
          Rectangle
         </span>
         in your adapter API, although more likely you would use private inheritance so that only your new interface is made public.
        </p>
        <p class="text" id="p0680">
         Some benefits of the Adapter pattern for API design include:
        </p>
        <div>
         <ul class="ce_list" id="olist0040">
          <li class="numlist" id="p0685">
           <a id="o0120">
           </a>
           1.
           <b>
            Enforce consistency across your API.
           </b>
           As I discussed in the previous chapter, consistency is an important quality of good APIs. Using an Adapter pattern, you can collate multiple disparate classes, all of which have different interface styles, and provide a consistent interface to all of these. The result is that your API is more uniform and therefore easier to use.
          </li>
          <li class="numlist" id="p0690">
           <a id="o0125">
           </a>
           2.
           <b>
            Wrap a dependent library of your API.
           </b>
           For example, your API may provide the ability to load a PNG image. You want to use the libpng library to implement this functionality, but you don't want to expose the libpng calls directly to the users of your API. This could be because you want to present a consistent and uniform API or because you want to protect against potential future API changes in libpng.
          </li>
          <li class="numlist" id="p0695">
           <a id="o0130">
           </a>
           3.
           <b>
            Transform data types.
           </b>
           For example, consider that you have an API,
           <span class="inlinecode">
            MapPlot
           </span>
           , that lets you plot geographic coordinates on a 2D map.
           <span class="inlinecode">
            MapPlot
           </span>
           accepts only latitude and longitude pairs (using the WGS84 datum), specified as two double parameters. However, your API has a
           <span class="inlinecode">
            GeoCoordinate
           </span>
           type that can represent coordinates in several coordinate systems, such as Universal Transverse Mercator or Lambert Conformal Conic. You could write an adapter that accepts your
           <span class="inlinecode">
            GeoCoordinate
           </span>
           object as a parameter, converts this to geodetic coordinates (latitude, longitude) if necessary, and passes the two doubles to the
           <span class="inlinecode">
            MapPlot
           </span>
           API.
          </li>
          <li class="numlist" id="p0700">
           <a id="o0135">
           </a>
           4.
           <b>
            Provide interoperability between different languages.
           </b>
           For example, perhaps you've written an Objective-C API and you want to map the Objective-C classes and methods to C++ versions. Or perhaps you've written a plain C API and you want to create Adapter classes that wrap the C calls into C++ classes. It's open to debate whether this latter case can be strictly considered an Adapter pattern because design patterns are primarily concerned with object-oriented systems, but if you allow some flexibility in your interpretation of the term then you'll see that the concept is the same. The following code gives an example of a C++ adapter for a plain C API. (I'll discuss the differences between C and C++ APIs in more detail in the next chapter on Styles.)
          </li>
         </ul>
        </div>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0205">
           <img alt="image" height="1239" src="../../IMAGES/B9780443222191000192/main.assets/u03-33-9780443222191.jpg" width="1525"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p113">
         </a>
        </p>
        <div>
         <span aria-label="113" epub:type="pagebreak" id="pagebreak_113" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0205">
         </a>
        </section>
       </section>
       <section>
        <a id="s0110">
        </a>
        <h3 class="h2hd" id="cesectitle0120">
         The Façade pattern
        </h3>
        <p class="textfl" id="p0705">
         The Façade design pattern presents a simplified interface for a larger collection of classes. In effect, it defines a higher-level interface that makes the underlying subsystem easier to use (
         <a href="#f0030" id="Bf0030">
          Fig. 3.5
         </a>
         ). To use Lakos' categorization, the Façade pattern is an example of a multicomponent wrapper (
         <a href="../B9780443222191160015/References_583-587_B9780443222191160015.xhtml#bib52">
          Lakos, 1996
         </a>
         ). Façade is therefore different from Adapter because Façade simplifies a class structure whereas Adapter maintains the same class structure.
        </p>
        <p class="text" id="p0710">
         As your API grows, so can the complexity of using that interface. The Façade pattern is a way to structure your API into subsystems to reduce this complexity and in turn make the API easier to use for most of your clients. A Façade might provide an improved interface while allowing access to the underlying subsystems. This is the same as the concept of convenience APIs that I described in the previous chapter, in which additional classes are added to provide aggregated functionality that make simple tasks easy. Alternatively, a Façade might completely decouple the underlying subsystems from the public interface so that these are no longer accessible. This is often called an encapsulating façade.
        </p>
        <div>
         <aside aria-labelledby="b0070" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0070">
           <div class="b1textfl" id="bpar0070">
            <i>
             TIP: A Façade provides a simplified interface to a collection of other classes. In an encapsulating façade, the underlying classes are not accessible.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p114">
         </a>
        </p>
        <div>
         <span aria-label="114" epub:type="pagebreak" id="pagebreak_114" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0030">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0030">
           <img alt="image" height="1562" src="../../IMAGES/B9780443222191000192/main.assets/f03-05-9780443222191.jpg" width="2334"/>
           <figcaption class="figleg">
            <a id="cap0030">
            </a>
            <a id="fspara0030">
            </a>
            <span class="fignum">
             <a href="#Bf0030">
              Figure 3.5
             </a>
            </span>
            UML diagram of the Façade design pattern.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0715">
         Let's look at an example to illustrate this pattern. Let's assume that you're on holiday and have checked into a hotel. You decide that you want to have dinner and then go to watch a show. To do so, you'll have to call a restaurant to make a dinner reservation, call the theater to book seats, and perhaps also arrange a taxi to pick you up from your hotel. You could express this in C++ as three separate objects with which you have to interact:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0210">
           <img alt="image" height="1065" src="../../IMAGES/B9780443222191000192/main.assets/u03-34-9780443222191.jpg" width="1941"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0720">
         However, let's assume that you're staying in a high-end hotel and they have a helpful concierge who can assist you with all of this. In fact, the concierge will be able to find out the time of the show and then, using his local knowledge of the city, work out an
         <a id="p115">
         </a>
         <span aria-label="115" epub:type="pagebreak" id="pagebreak_115" role="doc-pagebreak">
         </span>
         appropriate time for your dinner and the best time to order your taxi. Translating this into terms of our C++ design, you now need only to interact with a single object with a far simpler interface:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0215">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000192/main.assets/u03-35-9780443222191.jpg" width="2323"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0725">
         There are various useful applications of the Façade pattern in terms of API design:
        </p>
        <div>
         <ul class="ce_list" id="olist0045">
          <li class="numlist" id="p0730">
           <a id="o0140">
           </a>
           1.
           <b>
            Hide legacy code.
           </b>
           Often you have to deal with old, decayed, legacy systems that are brittle to work with and no longer offer a coherent object model. In these cases, it can be easier to create a new set of well-designed APIs that sit on top of the old code. Then all new code can use these new APIs. Once all existing clients have been updated to the new APIs, the legacy code can be completely hidden behind the new façade (making it an encapsulating façade).
          </li>
          <li class="numlist" id="p0735">
           <a id="o0145">
           </a>
           2.
           <b>
            Create convenience APIs.
           </b>
           As I discussed in the previous chapter, there is often a tension between providing general, flexible routines that provide more power versus simple easy-to-use routines that make the common use cases easy. A Façade is a way to address this tension by allowing both to coexist. In essence, a convenience API is a Façade. I used the example earlier of the OpenGL library, which provides low-level base routines, and the GLU library, which provides higher-level and easier-to-use routines that are built on top of the GL library.
          </li>
          <li class="numlist" id="p0740">
           <a id="o0150">
           </a>
           3.
           <b>
            Support reduced- or alternate-functionality APIs.
           </b>
           By abstracting away the access to the underlying subsystems, it becomes possible to replace certain subsystems without affecting your client's code. This could be used to swap in stub subsystems to support demonstration or test versions of your API. It could also allow swapping in different functionality, such as using a different 3D rendering engine for a game or using a different image reading library. As a real-world example, the Second Life viewer can be built against the proprietary KDU JPEG-2000 decoder library. However, the open source version of the viewer is built against the slower OpenJPEG library.
          </li>
         </ul>
        </div>
       </section>
      </section>
      <section>
       <a id="s0115">
       </a>
       <h2 class="h1hd" id="cesectitle0125">
        Observer pattern
       </h2>
       <p class="textfl" id="p0745">
        It's very common for objects to call methods in other objects. After all, achieving any nontrivial task normally requires several objects collaborating. However, to do this, an object A must know about the existence and interface of an object B to call methods on it. The simplest approach to doing this is for
        <span class="inlinecode">
         A.cpp
        </span>
        to include
        <span class="inlinecode">
         B.h
        </span>
        and then to call methods on that class directly. However, this introduces a compile-time dependency between A and B, forcing the classes to become tightly coupled. As a result, the generality of class A is reduced because it cannot be reused by another system without also pulling in class B. Furthermore, if class A also calls classes C and D, then changes to class A could
        <a id="p116">
        </a>
        <span aria-label="116" epub:type="pagebreak" id="pagebreak_116" role="doc-pagebreak">
        </span>
        affect all three of these tightly coupled classes. Additionally, this compile-time coupling means that users can't dynamically add new dependencies to the system at run time.
       </p>
       <div>
        <aside aria-labelledby="b0075" epub:type="sidebar">
         <div class="box_top_space">
         </div>
         <div class="boxg1" id="b0075">
          <div class="b1textfl" id="bpar0075">
           <i>
            TIP: An Observer lets you decouple components and avoid cyclic dependencies.
           </i>
          </div>
         </div>
        </aside>
       </div>
       <p class="text" id="p0750">
        I will illustrate these problems, and how the Observer pattern helps, with reference to the popular Model–View–Controller (MVC) architecture.
       </p>
       <section>
        <a id="s0120">
        </a>
        <h3 class="h2hd" id="cesectitle0130">
         Model–View–Controller
        </h3>
        <p class="textfl" id="p0755">
         The MVC architectural pattern requires the isolation of business logic (the Model) from the user interface (the View), with the Controller receiving user input and coordinating the other two. MVC separation supports the modularization of an application's function and offers several benefits:
        </p>
        <div>
         <ul class="ce_list" id="olist0050">
          <li class="numlist" id="p0760">
           <a id="o0155">
           </a>
           1. Segregation of Model and View components makes it possible to implement several user interfaces that reuse the common business logic core.
          </li>
          <li class="numlist" id="p0765">
           <a id="o0160">
           </a>
           2. Duplication of low-level Model code is eliminated across multiple UI implementations.
          </li>
          <li class="numlist" id="p0770">
           <a id="o0165">
           </a>
           3. Decoupling of Model and View code results in an improved ability to write unit tests for the core business logic code.
          </li>
          <li class="numlist" id="p0775">
           <a id="o0170">
           </a>
           4. Modularity of components allows core logic developers and GUI developers to work simultaneously without affecting the other.
          </li>
         </ul>
        </div>
        <p class="text" id="p0780">
         The MVC model was first described in 1987 by Steve Burbeck and Trygve Reenskaug at Xerox PARC and it remains a popular architectural pattern in applications and tool kits today. For example, modern UI tool kits such as Qt from The Qt Company, Apple's Cocoa, Java Swing, and Microsoft's Foundation Class library were all inspired by MVC. Taking the example of a single checkbox button, the current on/off state of the button is stored in the Model, the View draws the current state of the button on the screen, and the Controller updates the Model state and View display when the user clicks on the button.
        </p>
        <div>
         <aside aria-labelledby="b0080" epub:type="sidebar">
          <div class="box_top_space">
          </div>
          <div class="boxg1" id="b0080">
           <div class="b1textfl" id="bpar0080">
            <i>
             TIP: The MVC architectural pattern promotes the separation of core business logic, or the Model, from the user interface, or View. It also isolates the Controller logic that effects changes in the Model and updates the View.
            </i>
           </div>
          </div>
         </aside>
        </div>
        <p class="textfl">
         <a id="p117">
         </a>
        </p>
        <div>
         <span aria-label="117" epub:type="pagebreak" id="pagebreak_117" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0785">
         The implication of MVC separation on code dependency means that View code can call Model code (to discover the latest state and update the UI), but the opposite is not true: Model code should have no compile-time knowledge of View code (because it ties the Model to a single View).
         <a href="#f0035" id="Bf0035">
          Fig. 3.6
         </a>
         illustrates this dependency graph.
        </p>
        <p class="text" id="p0790">
         In a simple application, the Controller can effect changes to the Model based upon user input and communicate those changes to the View so that the UI can be updated. However, in real-world applications the View will normally also need to update to reflect additional changes to the underlying Model. This is necessary because changing one aspect of the Model may cause it to update other dependent Model state. This requires Model code to inform the View layer when state changes happen. However, as I've already stated, the Model code cannot statically bind and call the View code. This is where observers come in.
        </p>
        <p class="text" id="p0795">
         The Observer pattern is a specific instance of the Publish/Subscribe, or pub/sub, paradigm. These techniques define a one-to-many dependency between objects such that a publisher object can notify all subscribed objects of any state changes without directly depending upon them. The Observer pattern is therefore an important technique in terms of API design because it can help you to reduce coupling and increase code reuse.
        </p>
       </section>
       <section>
        <a id="s0125">
        </a>
        <h3 class="h2hd" id="cesectitle0135">
         Implementing the Observer pattern
        </h3>
        <p class="textfl" id="p0800">
         The typical way to implement the Observer pattern is to introduce two concepts: the subject and the observer (also referred to as the publisher and subscriber). One or more observers register interest in the subject, and then the subject notifies all registered observers of any state changes. This is illustrated in
         <a href="#f0040" id="Bf0040">
          Fig. 3.7
         </a>
         .
         <a id="p118">
         </a>
        </p>
        <section>
         <a id="sf0035">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0035">
           <img alt="image" height="909" src="../../IMAGES/B9780443222191000192/main.assets/f03-06-9780443222191.jpg" width="1359"/>
           <figcaption class="figleg">
            <a id="cap0035">
            </a>
            <a id="fspara0035">
            </a>
            <span class="fignum">
             <a href="#Bf0035">
              Figure 3.6
             </a>
            </span>
            An overview of dependencies in the Model–View–Controller model. Both the Controller and the View depend upon the Model, but Model code has no dependency on Controller code or View code.
           </figcaption>
          </figure>
         </div>
        </section>
        <div>
         <span aria-label="118" epub:type="pagebreak" id="pagebreak_118" role="doc-pagebreak">
         </span>
        </div>
        <section>
         <a id="sf0040">
         </a>
         <div class="pageavoid">
          <figure class="fig" id="f0040">
           <img alt="image" height="1674" src="../../IMAGES/B9780443222191000192/main.assets/f03-07-9780443222191.jpg" width="2384"/>
           <figcaption class="figleg">
            <a id="cap0040">
            </a>
            <a id="fspara0040">
            </a>
            <span class="fignum">
             <a href="#Bf0040">
              Figure 3.7
             </a>
            </span>
            A UML representation of the Observer pattern.
           </figcaption>
          </figure>
         </div>
        </section>
        <p class="text" id="p0805">
         This can be implemented using base classes to specify the abstract interface for both cases:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0220">
           <img alt="image" height="1668" src="../../IMAGES/B9780443222191000192/main.assets/u03-36-9780443222191.jpg" width="2393"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p119">
         </a>
        </p>
        <section>
         <a id="sf0220">
         </a>
        </section>
        <div>
         <span aria-label="119" epub:type="pagebreak" id="pagebreak_119" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0810">
         In this design, I've added support for the subject to be able to register and emit notifications for multiple different message types. This allows observers to subscribe only to the specific messages in which they're interested. For example, a subject that represents a stack of elements might wish to send out separate notifications when elements are added to or removed from that stack. Using these interfaces, you can define a minimal concrete subject class as:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0225">
           <img alt="image" height="313" src="../../IMAGES/B9780443222191000192/main.assets/u03-37-9780443222191.jpg" width="1144"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0815">
         Finally, you can create observer objects simply by inheriting from the
         <span class="inlinecode">
          IObserver
         </span>
         interface and implementing the
         <span class="inlinecode">
          Update()
         </span>
         method. The following code demonstrates putting all these concepts together:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0230">
           <img alt="image" height="2099" src="../../IMAGES/B9780443222191000192/main.assets/u03-38-9780443222191.jpg" width="1901"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p120">
         </a>
        </p>
        <section>
         <a id="sf0230">
         </a>
        </section>
        <div>
         <span aria-label="120" epub:type="pagebreak" id="pagebreak_120" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0820">
         This example demonstrates creating three separate observer classes and subscribes them for different combinations of the two messages defined by the earlier
         <span class="inlinecode">
          MySubject
         </span>
         class. Finally, the calls to
         <span class="inlinecode">
          subject.Notify()
         </span>
         cause the subject to traverse its list of observers that have been subscribed for the given message and calls the
         <span class="inlinecode">
          Update()
         </span>
         method for each of them. The important point to note is that the
         <span class="inlinecode">
          MySubject
         </span>
         class has no compile-time dependency on the
         <span class="inlinecode">
          MyObserver
         </span>
         class. The relationship between the two classes is dynamically created at run time.
        </p>
        <p class="text" id="p0825">
         Of course, there may be a small performance cost for this flexibility: the cost of iterating through a list of observers before making the (virtual) function call. However, this cost is generally insignificant compared with benefits of reduced coupling and increased code reuse.
        </p>
       </section>
       <section>
        <a id="s0130">
        </a>
        <h3 class="h2hd" id="cesectitle0140">
         Push versus pull observers
        </h3>
        <p class="textfl" id="p0830">
         There are many ways to implement the Observer pattern; the previous example is only one such method. However, I will note two major categories of observers: push-based and pull-based. This categorization determines whether all of the information is pushed to an observer via arguments to the
         <span class="inlinecode">
          Update()
         </span>
         method, or whether the
         <span class="inlinecode">
          Update()
         </span>
         method is simply used to send a notification about the occurrence of an event, and if the observer wishes to discover more details, then the subject object must be queried directly. As an example, a notification that the user has pressed the Return key in a text entry widget may pass the actual text that the user typed as a parameter of the
         <span class="inlinecode">
          Update()
         </span>
         method (push), or it may rely on the observer calling a
         <span class="inlinecode">
          GetText()
         </span>
         method on the subject to discover this information if it needs it (pull).
        </p>
        <p class="text" id="p0835">
         <a href="#f0040">
          Fig. 3.7
         </a>
         illustrates a pull observer pattern because the
         <span class="inlinecode">
          Update()
         </span>
         method has no arguments and the observer can query the subject for its current state. This approach allows you to use the same simple
         <span class="inlinecode">
          IObserver
         </span>
         for all observers in the system. By comparison, a push-based solution would require you to define different abstract interfaces for each
         <span class="inlinecode">
          Update()
         </span>
         method that requires a unique signature. A push-based solution is useful for sending small commonly used pieces of data along with a notification, such as the checkbox on/off state for a checkbox state change. However, it may be inefficient for larger pieces of data, such as sending the entire text every time a user presses a key in a text box widget.
        </p>
        <p class="text" id="p0840">
         I'll finish up the coverage of observers by providing a real-world example, referring again to the open source VTK. This library uses an observer pattern to allow client code to be called when various events happen in the system. The API for managing VTK observers looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0235">
           <img alt="image" height="429" src="../../IMAGES/B9780443222191000192/main.assets/u03-39-9780443222191.jpg" width="2704"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="textfl">
         <a id="p121">
         </a>
        </p>
        <section>
         <a id="sf0235">
         </a>
        </section>
        <div>
         <span aria-label="121" epub:type="pagebreak" id="pagebreak_121" role="doc-pagebreak">
         </span>
        </div>
        <p class="text" id="p0845">
         You can see from this set of functions that VTK observers are keyed on an
         <span class="inlinecode">
          unsigned long
         </span>
         . However, the API includes overloaded versions of these functions that accept a
         <span class="inlinecode">
          const char ∗
         </span>
         as a convenience. There's a
         <span class="inlinecode">
          GetEventIdFromString()
         </span>
         function that's used internally to perform the mapping from a string to an
         <span class="inlinecode">
          unsigned long
         </span>
         to support this.
        </p>
        <p class="text" id="p0850">
         The events themselves are defined in a large enum with values such as
         <span class="inlinecode">
          vtkCommand::DeleteEvent
         </span>
         ,
         <span class="inlinecode">
          vtkCommand::RenderEvent
         </span>
         , and
         <span class="inlinecode">
          vtkCommand::EnterEvent
         </span>
         . The observer object is modeled by a
         <span class="inlinecode">
          vtkCommand
         </span>
         object, which looks like:
        </p>
        <div>
         <div class="pageavoid">
          <figure class="fig" id="f0240">
           <img alt="image" height="660" src="../../IMAGES/B9780443222191000192/main.assets/u03-40-9780443222191.jpg" width="2289"/>
           <figcaption class="figleg">
           </figcaption>
          </figure>
         </div>
        </div>
        <p class="text" id="p0855">
         Observers are therefore expected to override the
         <span class="inlinecode">
          Execute()
         </span>
         function to perform their custom work, and this function receives the object invoking the event, the event identifier, and any optional call data provided by the invoking object.
        </p>
       </section>
      </section>
     </section>
    </section>
   </div>
  </div>
 </body>
</html>
