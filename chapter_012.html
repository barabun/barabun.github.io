<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   3Coding with Style
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_011.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_013.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c03_1" epub:type="chapter" role="doc-chapter">
    <header>
     <h1 id="c03_1">
      <span aria-label="119" epub:type="pagebreak" id="Page_119" role="doc-pagebreak">
      </span>
      <span id="c03">
      </span>
      <span class="chapterNumber">
       3
      </span>
      <br/>
      <span class="chapterTitle">
       Coding with Style
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening">
     <span id="c03-sec-0001">
     </span>
     <section>
      <aside>
       <div class="top hr">
        <hr/>
       </div>
       <section class="feature3">
        <h3>
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check3" id="c03-list-0001">
         <li id="c03-li-0001">
          The importance of documenting your code and what kind of commenting styles you can use
         </li>
         <li id="c03-li-0002">
          What decomposition means and how to use it
         </li>
         <li id="c03-li-0003">
          What naming conventions are
         </li>
         <li id="c03-li-0004">
          What code formatting rules are
         </li>
        </ul>
        <div class="bottom hr">
         <hr/>
        </div>
       </section>
      </aside>
     </section>
     <p id="c03-para-0003">
      If you're going to spend several hours each day in front of a keyboard writing code, you should take some pride in all that work. Writing code that gets the job done is only part of a programmer's work. After all, anybody can learn the fundamentals of coding. It takes a true master to code with style.
     </p>
     <p id="c03-para-0004">
      This chapter explores the question of what makes stylistically good code. Along the way, you'll see several approaches to C++ style. As you will discover, simply changing the style of code can make it appear very different. For example, C++ code written by Windows programmers often has its own style, using Windows conventions. It almost looks like a completely different language than C++ code written by macOS programmers. Exposure to several different styles will help you avoid that sinking feeling you get when opening a C++ source file that barely resembles the C++ you thought you knew.
     </p>
    </section>
    <section aria-labelledby="head-2-64">
     <span id="c03-sec-0003">
     </span>
     <h2 id="head-2-64">
      THE IMPORTANCE OF LOOKING GOOD
     </h2>
     <p id="c03-para-0005">
      Writing code that is stylistically “good” takes time. You probably don't need much time to whip together a quick-and-dirty program to parse an XML file. Writing the same program with functional decomposition, adequate comments, and a clean structure would take you more time. Is it really worth it?
     </p>
     <span aria-label="120" epub:type="pagebreak" id="Page_120" role="doc-pagebreak">
     </span>
     <section>
      <span id="c03-sec-0004">
      </span>
      <h3 id="head-3-114">
       Thinking Ahead
      </h3>
      <p id="c03-para-0006">
       How confident would you be in your code if a new programmer had to work with it a year from now? A friend of mine, faced with a growing mess of web application code, encouraged his team to think about a hypothetical intern who would be starting in a year. How would this poor intern ever get up to speed on the code base if there were no documentation and scary multiple-page functions? When you're writing code, imagine that somebody new or even you yourself will have to maintain it in the future. Will you even still remember how it works? What if you're not available to help? Well-written code avoids these problems because it is easy to read and understand.
      </p>
     </section>
     <section>
      <span id="c03-sec-0005">
      </span>
      <h3 id="head-3-115">
       Elements of Good Style
      </h3>
      <p>
       It is difficult to enumerate the characteristics of code that make it “stylistically good.” Over time, you'll find styles that you like and notice useful techniques in code that others wrote. Perhaps more important, you'll encounter horrible code that teaches you what to avoid. However, good code shares several universal tenets that are explored in this chapter:
      </p>
      <ul class="check1" id="c03-list-0002">
       <li id="c03-li-0005">
        Documentation
       </li>
       <li id="c03-li-0006">
        Decomposition
       </li>
       <li id="c03-li-0007">
        Naming
       </li>
       <li id="c03-li-0008">
        Use of the language
       </li>
       <li id="c03-li-0009">
        Formatting
       </li>
      </ul>
     </section>
    </section>
    <section aria-labelledby="head-2-65">
     <span id="c03-sec-0006">
     </span>
     <h2 id="head-2-65">
      DOCUMENTING YOUR CODE
     </h2>
     <p id="c03-para-0008">
      In the programming context, documentation usually refers to comments contained in the source files. Comments are your opportunity to tell the world what was going through your head when you wrote the accompanying code. They are a place to say anything that isn't obvious from looking at the code itself.
     </p>
     <section>
      <span id="c03-sec-0007">
      </span>
      <h3 id="head-3-116">
       Reasons to Write Comments
      </h3>
      <p id="c03-para-0009">
       It may seem obvious that writing comments is a good idea, but have you ever stopped to think about why you need to comment your code? Sometimes programmers acknowledge the importance of commenting without fully understanding why comments are important. There are several reasons, all of which are explored in this chapter.
      </p>
      <section>
       <span id="c03-sec-0008">
       </span>
       <h4 id="head-4-78">
        Commenting to Explain Usage
       </h4>
       <p id="c03-para-0010">
        One reason to use comments is to explain how clients should interact with the code. Normally, a developer should be able to understand what a function does simply based on the name of the function, the type of the return value, and the name and type of its parameters. However, not everything can be expressed in code. Function pre- and postconditions
        <a aria-describedby="c03-note-0001" epub:type="noteref" href="#c03-note-0001" id="R_c03-note-0001" role="doc-noteref">
         <sup>
          1
         </sup>
        </a>
        and the exceptions a function
        <span aria-label="121" epub:type="pagebreak" id="Page_121" role="doc-pagebreak">
        </span>
        can throw are things that you can only explain in a comment. In my opinion, it is OK to only add a comment if it really adds any useful information, such as pre- and postconditions and exceptions; otherwise, it's acceptable to omit the comment. Nevertheless, it's rare for a function to have no pre- or postconditions. Bottom line, it's up to the developer to decide whether a function needs a comment. Experienced programmers will have no problems deciding about this, but less experienced developers might not always make the right decision. That's why some companies have a rule stating that at least each publicly accessible function or member function in a module or header file should have a comment explaining what it does, what its arguments are, what values it returns, which pre- and postconditions need to be satisfied, and which exceptions it can throw.
       </p>
       <p>
        A comment gives you the opportunity to state, in English, anything that you can't state in code. For example, there's really no way in C++ code to indicate that the
        <code>
         saveRecord
        </code>
        (
        <code>
         )
        </code>
        member function of a database object throws an exception if
        <code>
         openDatabase()
        </code>
        has not been called yet. A comment, however, can be the perfect place to note this restriction, as follows:
       </p>
       <pre id="c03-code-0001"><code><span class="color3">// Throws:</span></code>
<code><span class="color3">//    DatabaseNotOpenedException if openDatabase() has not been called yet.</span></code>
<code>int saveRecord(Record&amp; record);</code></pre>
       <p>
        The
        <code>
         saveRecord()
        </code>
        member function accepts a reference-to-non-
        <code>
         const Record
        </code>
        object. Users might wonder why it's not a reference-to-
        <code>
         const
        </code>
        , so this is something that needs to be explained in a comment:
       </p>
       <pre id="c03-code-0002"><code><span class="color3">// Parameters:</span></code>
<code><span class="color3">//    record: If the given record doesn't yet have a database ID, then saveRecord()</span></code>
<code><span class="color3">//    modifies the record object to store the ID assigned by the database.</span></code>
<code><span class="color3">// Throws:</span></code>
<code><span class="color3">//    DatabaseNotOpenedException if openDatabase() has not been called yet.</span></code>
<code>int saveRecord(Record&amp; record);</code></pre>
       <p>
        The C++ language forces you to specify the return type of a function, but it does not provide a way for you to say what the returned value actually represents. For example, the declaration of
        <code>
         saveRecord()
        </code>
        indicates that it returns an
        <code>
         int
        </code>
        (a bad design decision discussed further in this section), but a client reading that declaration wouldn't know what the
        <code>
         int
        </code>
        means. A comment explains the meaning of it:
       </p>
       <pre id="c03-code-0003"><code><span class="color3">// Saves the given record to the database.</span></code>
<code><span class="color3">//</span></code>
<code><span class="color3">// Parameters:</span></code>
<code><span class="color3">//    record: If the given record doesn't yet have a database ID, then saveRecord()</span></code>
<code><span class="color3">//    modifies the record object to store the ID assigned by the database.</span></code>
<code><span class="color3">// Returns: int</span></code>
<code><span class="color3">//    An integer representing the ID of the saved record.</span></code>
<code><span class="color3">// Throws:</span></code>
<code><span class="color3">//    DatabaseNotOpenedException if openDatabase() has not been called yet.</span></code>
<code>int saveRecord(Record&amp; record);</code></pre>
       <p>
        The previous comment documents everything about
        <code>
         saveRecord()
        </code>
        in a formal way, including a sentence that describes what the member function does. Some companies require such formal and thorough documentation; however, I don't recommend this style of commenting all the time. The first line, for example, is rather useless since the name of the function is self-explanatory. The description of the parameter is important as is the comment about the exception, so these definitely should stay.
        <span aria-label="122" epub:type="pagebreak" id="Page_122" role="doc-pagebreak">
        </span>
        Documenting what exactly the return type represents for this version of
        <code>
         saveRecord()
        </code>
        is required since it returns a generic
        <code>
         int
        </code>
        . However, a much better design would be to return a
        <code>
         RecordID
        </code>
        instead of a plain
        <code>
         int
        </code>
        , which removes the need to add any comments for the return type.
        <code>
         RecordID
        </code>
        could be a simple class with a single
        <code>
         int
        </code>
        data member, but it conveys more information, and it allows you to add more data members in the future if need be. So, the following is a much better
        <code>
         saveRecord()
        </code>
        :
       </p>
       <pre id="c03-code-0004"><code><span class="color3">// Parameters:</span></code>
<code><span class="color3">//    record: If the given record doesn't yet have a database ID, then saveRecord()</span></code>
<code><span class="color3">//    modifies the record object to store the ID assigned by the database.</span></code>
<code><span class="color3">// Throws:</span></code>
<code><span class="color3">//    DatabaseNotOpenedException if openDatabase() has not been called yet.</span></code>
<code>RecordID saveRecord(Record&amp; record);</code></pre>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c03-para-0016">
           <b>
            NOTE
           </b>
           <i>
            If your company’s coding guidelines don’t force you to write formal comments for functions, use common sense when writing them. Only state something in a comment that is not obvious based on the name of the function, the return type, and the name and type of its parameters.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p>
        Sometimes, the parameters to and the return type from a function are generic and can be used to pass all kinds of information. In that case you need to clearly document exactly what type is being passed. For example, message handlers in Windows accept two parameters,
        <code>
         LPARAM
        </code>
        and
        <code>
         WPARAM
        </code>
        , and can return an
        <code>
         LRESULT
        </code>
        . All three can be used to pass almost anything you like, but you cannot change their type. By using type casting, they can, for example, be used to pass simple integers or pointers to some objects. Your documentation could look like this:
       </p>
       <pre id="c03-code-0005"><code><span class="color3">// Parameters:</span></code>
<code><span class="color3">//    WPARAM wParam: (WPARAM)(int): An integer representing…</span></code>
<code><span class="color3">//    LPARAM lParam: (LPARAM)(string*): A string pointer representing…</span></code>
<code><span class="color3">// Returns: (LRESULT)(Record*)</span></code>
<code><span class="color3">//    nullptr in case of an error, otherwise a pointer to a Record object</span></code>
<code><span class="color3">//    representing…</span></code>
<code>LRESULT handleMessage(WPARAM wParam, LPARAM lParam);</code></pre>
       <p id="c03-para-0018">
        Your public documentation should describe the behavior of your code, not the implementation. The behavior includes the inputs, outputs, error conditions and handling, intended uses, and performance guarantees. For example, public documentation describing a call to generate a single random number should specify that it takes no parameters, returns an integer in a previously specified range, and should list all the exceptions that might be thrown when something goes wrong. This public documentation should not explain the details of the linear congruence algorithm for actually generating the number. Providing too much implementation detail in comments targeted for users of your code is probably the single most common mistake in writing public comments.
       </p>
      </section>
      <section>
       <span id="c03-sec-0010">
       </span>
       <h4 id="head-4-79">
        Commenting to Explain Complicated Code
       </h4>
       <p id="c03-para-0019">
        Good comments are also important inside the actual source code. In a simple program that processes input from the user and writes a result to the console, it is probably easy to read through and understand all of the code. In the professional world, however, you will often need to write code that is algorithmically complex or too esoteric to understand simply by inspection.
       </p>
       <p>
        <span aria-label="123" epub:type="pagebreak" id="Page_123" role="doc-pagebreak">
        </span>
        Consider the code that follows. It is well-written, but it may not be immediately apparent what it is doing. You might recognize the algorithm if you have seen it before, but a newcomer probably wouldn't understand the way the code works.
       </p>
       <pre id="c03-code-0006"><code>void sort(int data[], std::size_t size)</code>
<code>{</code>
<code>    for (int i { 1 }; i &lt; size; ++i) {</code>
<code>        int element { data[i] };</code>
<code>        int j { i };</code>
<code>        while (j&gt; 0 &amp;&amp; data[j - 1]&gt; element) {</code>
<code>            data[j] = data[j - 1];</code>
<code>            j--;</code>
<code>        }</code>
<code>        data[j] = element;</code>
<code>    }</code>
<code>}</code></pre>
       <p>
        A better approach would be to include comments that describe the parameters to the function, the algorithm that is being used, and any (loop) invariants. Invariants are conditions that must be true during the execution of a piece of code, for example, a loop iteration. In the modified function that follows, a comment at the top explains the meaning of the two parameters, a thorough comment at the start of the function explains the algorithm at a high level, and inline comments explain specific lines that may be confusing:
       </p>
       <pre id="c03-code-0007"><code><span class="color3">// Implements the "insertion sort" algorithm.</span></code>
<code><span class="color3">// data is an array containing the elements to be sorted.</span></code>
<code><span class="color3">// size contains the number of elements in the data array.</span></code>
<code>void sort(int data[], std::size_t size)</code>
<code>{</code>
<code>    <span class="color3">// The insertion sort algorithm separates the array into two parts--the</span></code>
<code>    <span class="color3">// sorted part and the unsorted part. Each element, starting at position</span></code>
<code>    <span class="color3">// 1, is examined. Everything earlier in the array is in the sorted part,</span></code>
<code>    <span class="color3">// so the algorithm shifts each element over until the correct position</span></code>
<code>    <span class="color3">// is found to insert the current element. When the algorithm finishes</span></code>
<code>    <span class="color3">// with the last element, the entire array is sorted.</span></code>
<code></code>
<code>    <span class="color3">// Start at position 1 and examine each element.</span></code>
<code>    for (int i { 1 }; i &lt; size; ++i) {</code>
<code>        <span class="color3">// Loop invariant:</span></code>
<code>        <span class="color3">//     All elements in the range 0 to i-1 (inclusive) are sorted.</span></code>
<code></code>
<code>        int element { data[i] };</code>
<code>        <span class="color3">// j marks the position in the sorted part where element will be inserted.</span></code>
<code>        int j { i };</code>
<code>        <span class="color3">// As long as the value in the slot before the current slot in the sorted</span></code>
<code>        <span class="color3">// array is higher than element, shift values to the right to make room</span></code>
<code>        <span class="color3">// for inserting element (hence the name, "insertion sort") in the correct</span></code>
<code>        <span class="color3">// position.</span></code>
<code>        while (j&gt; 0 &amp;&amp; data[j - 1]&gt; element) {</code>
<code>            <span class="color3">// invariant: elements in the range j+1 to i are &gt; element.</span></code>
<code>            data[j] = data[j - 1];</code>
<code>            <span class="color3">// invariant: elements in the range j to i are &gt; element.</span></code>
<code>            j--;</code>
<code>        }</code>
<code>        <span class="color3">// At this point the current position in the sorted array</span></code>
<span aria-label="124" epub:type="pagebreak" id="Page_124" role="doc-pagebreak"></span><code>        <span class="color3">// is *not* greater than the element, so this is its new position.</span></code>
<code>        data[j] = element;</code>
<code>    }</code>
<code>}</code></pre>
       <p id="c03-para-0022">
        The new code is certainly more verbose, but a reader unfamiliar with sorting algorithms would be much more likely to understand it with the comments included.
       </p>
      </section>
      <section>
       <span id="c03-sec-0011">
       </span>
       <h4 id="head-4-80">
        Commenting to Convey Meta-information
       </h4>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c03-para-0024">
           WARNING All meta-information mentioned in this section is from practices from the past. Nowadays, such meta-information is highly discouraged, as the use of a version control system, as discussed in
           <a href="c28.xhtml">
            <i>
             Chapter
            </i>
            28
           </a>
           <i>
            , “Maximizing Software Engineering Methods,” is mandatory. Such a solution offers an annotated change history with revision dates, author names, and, if properly used, comments accompanying each modification, including references to change requests and bug reports. You should check in, or commit, each change request or bug fix separately with a descriptive comment. With such a system, you don't need to manually keep track of such meta-information directly in the source code files
           </i>
           .
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
       <p>
        In old legacy code bases, you might come across comments that were used to provide information at a higher level than the code itself. Such
        <i>
         meta-information
        </i>
        provided details about the creation of the code without addressing the specifics of its behavior, such as the original author of each function, the date a piece of code was written, the specific feature a function addresses, the bug number that corresponds to a line of code, a reminder to revisit a possible problem in the code later, a change-log, and more. Here is an example:
       </p>
       <pre id="c03-code-0008"><code><span class="color3">// Date       | Change</span></code>
<code><span class="color3">//------------+--------------------------------------------------</span></code>
<code><span class="color3">// 2001-04-13 | REQ #005: &lt;marcg&gt; Do not normalize values.</span></code>
<code><span class="color3">// 2001-04-17 | REQ #006: &lt;marcg&gt; use nullptr instead of NULL.</span></code>
<code></code>
<code><span class="color3">// Author:  marcg</span></code>
<code><span class="color3">// Date:    110412</span></code>
<code><span class="color3">// Feature: PRD version 3, Feature 5.10</span></code>
<code>RecordID saveRecord(Record&amp; record)</code>
<code>{</code>
<code>    if (!m_databaseOpen) { throw DatabaseNotOpenedException { }; }</code>
<code>    RecordID id { getDB()-&gt;saveRecord(record) };</code>
<code>    if (id != -1) {      <span class="color3">// Added to address bug #142 – jsmith 110428</span></code>
<code>        record.setId(id);</code>
<code>    }</code>
<code>    <span class="color3">// TODO: What if setId() throws an exception? – akshayr 110501</span></code>
<code>    return id;</code>
<code>}</code></pre>
       <p id="c03-para-0026">
        However, it's worth repeating, such legacy meta-information has no place in new code.
       </p>
      </section>
      <span aria-label="125" epub:type="pagebreak" id="Page_125" role="doc-pagebreak">
      </span>
      <section>
       <span id="c03-sec-0013">
       </span>
       <h4 id="head-4-81">
        Copyright Comment
       </h4>
       <p id="c03-para-0027">
        Another type of meta-information is a copyright notice. Some companies require such a copyright notice at the beginning of every source file, even though, since the Berne Convention in 1886, it is not required to explicitly write a copyright statement to actually have copyright on your work.
       </p>
      </section>
     </section>
     <section>
      <span id="c03-sec-0014">
      </span>
      <h3 id="head-3-117">
       Commenting Styles
      </h3>
      <p id="c03-para-0028">
       Every organization has a different approach to commenting code. In some environments, a particular style is mandated to give the code a common standard for documentation. Other times, the quantity and style of commenting are left up to the programmer. The following examples depict several approaches to commenting code.
      </p>
      <section>
       <span id="c03-sec-0015">
       </span>
       <h4 id="head-4-82">
        Commenting Every Line
       </h4>
       <p>
        One way to avoid lack of documentation is to force yourself to over document by including a comment for every line. Commenting every line of code should ensure that there's a specific reason for everything you write. In reality, such heavy commenting on a large scale is unwieldy, messy, and tedious! For example, consider the following useless comments:
       </p>
       <pre id="c03-code-0009"><code>int result;                   <span class="color3">// Declare an integer to hold the result.</span></code>
<code>result = doodad.getResult();  <span class="color3">// Get the doodad's result.</span></code>
<code>if (result % 2 ==  0) {       <span class="color3">// If the result modulo 2 is 0 …</span></code>
<code>   logError();                <span class="color3">// then log an error,</span></code>
<code>} else {                      <span class="color3">// otherwise …</span></code>
<code>   logSuccess();              <span class="color3">// log success.</span></code>
<code>}                             <span class="color3">// End if/else.</span></code>
<code>return result;                <span class="color3">// Return the result.</span></code></pre>
       <p>
        The comments in this code express each line as part of an easily readable English story. This is entirely useless if you assume that the reader has at least basic C++ skills. These comments don't add any additional information to code. Specifically, look at this line:
       </p>
       <pre id="c03-code-0010"><code>if (result % 2 == 0) {        <span class="color3">// If the result modulo 2 is 0 …</span></code></pre>
       <p>
        The comment is just an English translation of the code. It doesn't say
        <i>
         why
        </i>
        the programmer has used the modulo operator on the result with the value 2. The following would be a better comment:
       </p>
       <pre id="c03-code-0011"><code>if (result % 2 == 0) {        <span class="color3">// If the result is even …</span></code></pre>
       <p id="c03-para-0032">
        The modified comment, while still fairly obvious to most programmers, gives additional information about the code. The modulo operator with 2 is used because the code needs to check whether the result is even.
       </p>
       <p>
        Even better, if some expression does something that might not be immediately obvious to everyone, I recommend turning it into a function with a well-chosen name. This makes the code self-documenting, removing the need to write comments where the function is used, and results in a piece of reusable code. For example, you can define a function
        <code>
         isEven()
        </code>
        as follows:
       </p>
       <pre id="c03-code-0012"><code>bool isEven(int value) { return value % 2 == 0; }</code></pre>
       <p>
        <span aria-label="126" epub:type="pagebreak" id="Page_126" role="doc-pagebreak">
        </span>
        And then use it like this, without any comments:
       </p>
       <pre id="c03-code-0013"><code>if (isEven(result)) {</code></pre>
       <p>
        Despite its tendency to be verbose and superfluous, heavy commenting can be useful in cases where the code would otherwise be difficult to comprehend. The following code also comments every line, but these comments are actually helpful:
       </p>
       <pre id="c03-code-0014"><code><span class="color3">// Calculate the doodad. The start, end, and offset values come from the</span></code>
<code><span class="color3">// table on page 96 of the "Doodad API v1.6."</span></code>
<code>result = doodad.calculate(Start, End, Offset);</code>
<code><span class="color3">// To determine success or failure, we need to bitwise AND the result with</span></code>
<code><span class="color3">// the processor-specific mask (see "Doodad API v1.6," page 201).</span></code>
<code>result &amp;= getProcessorMask();</code>
<code><span class="color3">// Set the user field value based on the "Marigold Formula."</span></code>
<code><span class="color3">// (see "Doodad API v1.6", page 136)</span></code>
<code>setUserField((result + MarigoldOffset) / MarigoldConstant + MarigoldConstant);</code></pre>
       <p>
        This code is taken out of context, but the comments give you a good idea of what each line does. Without them, the calculations involving
        <code>
         &amp;
        </code>
        and the mysterious “Marigold Formula” would be difficult to decipher.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c03-para-0037">
           <b>
            NOTE
           </b>
           <i>
            Commenting every line of code is usually not warranted, but if the code is complicated enough to require it, don’t just translate the code to English: explain what’s really going on.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c03-sec-0017">
       </span>
       <h4 id="head-4-83">
        Prefix Comments
       </h4>
       <p>
        Your group may decide to begin all source files with a standard comment. This is an opportunity to document important information about the program and a specific file. Examples of information that could be at the top of every file include the following:
       </p>
       <ul class="check1" id="c03-list-0003">
        <li id="c03-li-0010">
         Copyright information
        </li>
        <li id="c03-li-0011">
         A brief description of the file/class
        </li>
        <li id="c03-li-0012">
         Incomplete features*
        </li>
        <li id="c03-li-0013">
         Known bugs*
        </li>
       </ul>
       <p id="c03-para-0039">
        * These items are usually handled by your bug and feature tracking system (see
        <a href="c30.xhtml">
         Chapter 30
        </a>
        , “Becoming Adept at Testing”).
       </p>
       <p>
        The following lists some examples of information that should never be included in such comments, as these are automatically handled by your version control system (see
        <a href="c28.xhtml">
         Chapter 28
        </a>
        ).
       </p>
       <ul class="check1" id="c03-list-0004">
        <li id="c03-li-0014">
         The last-modified date
        </li>
        <li id="c03-li-0015">
         The original author
        </li>
        <li id="c03-li-0016">
         A change-log (as described earlier)
        </li>
        <li id="c03-li-0017">
         The feature ID addressed by the file
        </li>
       </ul>
       <p>
        <span aria-label="127" epub:type="pagebreak" id="Page_127" role="doc-pagebreak">
        </span>
        Here is an example of a prefix comment:
       </p>
       <pre id="c03-code-0015"><code><span class="color3">// Implements the basic functionality of a watermelon. All units are expressed</span></code>
<code><span class="color3">// in terms of seeds per cubic centimeter. Watermelon theory is based on the</span></code>
<code><span class="color3">// white paper "Algorithms for Watermelon Processing."</span></code>
<code><span class="color3">//</span></code>
<code><span class="color3">// The following code is (c) copyright 2023, FruitSoft, Inc. ALL RIGHTS RESERVED</span></code></pre>
      </section>
      <section>
       <span id="c03-sec-0018">
       </span>
       <h4 id="head-4-84">
        Fixed-Format Comments
       </h4>
       <p>
        Writing comments in a standard format that can be parsed by external document builders is a popular programming practice. In the Java language, programmers can write comments in a standard format that allows a tool called JavaDoc to automatically create hyperlinked documentation for the project. For C++, a free tool called Doxygen (available at
        <code>
         <a href="http://doxygen.org">
          doxygen.org
         </a>
        </code>
        ) parses comments to automatically build HTML documentation, class diagrams, UNIX man pages, and other useful documents. Doxygen even recognizes and parses JavaDoc-style comments in C++ programs. The code that follows shows JavaDoc-style comments that are recognized by Doxygen:
       </p>
       <pre id="c03-code-0016"><code><span class="color3">/**</span></code>
<code> <span class="color3">* Implements the basic functionality of a watermelon</span></code>
<code> <span class="color3">* TODO: Implement updated algorithms!</span></code>
<code> <span class="color3">*/</span></code>
<code>export class Watermelon</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">/**</span></code>
<code>         <span class="color3">* @param initialSeeds The starting number of seeds, must be &gt; 5.</span></code>
<code>         <span class="color3">* @throws invalid_argument if initialSeeds &lt;= 5.</span></code>
<code>         <span class="color3">*/</span></code>
<code>        Watermelon(std::size_t initialSeeds);</code>
<code></code>
<code>        <span class="color3">/**</span></code>
<code>         <span class="color3">* Computes the seed ratio, using the Marigold algorithm.</span></code>
<code>         <span class="color3">* @param slow Whether or not to use long (slow) calculations.</span></code>
<code>         <span class="color3">* @return The marigold ratio.</span></code>
<code>         <span class="color3">*/</span></code>
<code>        double calculateSeedRatio(bool slow);</code>
<code>};</code></pre>
       <p id="c03-para-0043">
        Doxygen recognizes the C++ syntax and special comment directives such as
        <code>
         @param
        </code>
        ,
        <code>
         @return
        </code>
        , and
        <code>
         @throws
        </code>
        to generate customizable output.
        <a href="#c03-fig-0001" id="R_c03-fig-0001">
         Figure 3.1
        </a>
        shows an example of a Doxygen-generated HTML class reference.
       </p>
       <p>
        Note that you should still avoid writing useless comments, even when you use a tool to automatically generate documentation. Take a look at the
        <code>
         Watermelon
        </code>
        constructor in the previous code. Its comment omits a description and only describes the parameter and the exceptions it throws. Adding a description, as in the following example, is redundant:
       </p>
       <pre id="c03-code-0017"><code>        <span class="color3">/**</span></code>
<code>         <span class="color3">* The Watermelon constructor.</span></code>
<code>         <span class="color3">* @param initialSeeds The starting number of seeds, must be &gt; 5.</span></code>
<code>         <span class="color3">* @throws invalid_argument if initialSeeds &lt;= 5.</span></code>
<code>         <span class="color3">*/</span></code>
<code>        Watermelon(std::size_t initialSeeds);</code></pre>
       <figure>
        <img alt="A snapshot of watermelon class reference. It includes a public member function, detailed description, constructor and destructor documentation, watermelon, and calculated seed ratio." class="center" src="../images\images/c03f001.png"/>
        <figcaption>
         <p>
          <span class="figureLabel">
           <a href="#R_c03-fig-0001" id="c03-fig-0001" role="doc-backlink">
            <b>
             FIGURE 3.1
            </b>
           </a>
          </span>
         </p>
        </figcaption>
       </figure>
       <p id="c03-para-0045">
        <span aria-label="128" epub:type="pagebreak" id="Page_128" role="doc-pagebreak">
        </span>
        Automatically generated documentation as shown in
        <a href="#c03-fig-0001">
         Figure 3.1
        </a>
        can be helpful during development because it allows developers to browse through a high-level description of classes and their relationships. Your group can easily customize a tool like Doxygen to work with the style of comments that you have adopted. Ideally, your group would set up a machine that builds documentation on a daily basis.
       </p>
      </section>
      <span aria-label="129" epub:type="pagebreak" id="Page_129" role="doc-pagebreak">
      </span>
      <section>
       <span id="c03-sec-0019">
       </span>
       <h4 id="head-4-85">
        Ad Hoc Comments
       </h4>
       <p>
        Most of the time, you use comments on an as-needed basis. Here are some guidelines for comments that appear within the body of your code:
       </p>
       <ul class="check1" id="c03-list-0005">
        <li id="c03-li-0018">
         Before adding a comment, first consider whether you can rework the code to make the comment redundant—for example, by renaming variables, functions, and classes; by reordering steps in the code; by introducing intermediate well-named variables; and so on.
        </li>
        <li id="c03-li-0019">
         Imagine someone else is reading your code. If there are subtleties that are not immediately obvious, then you should document those.
        </li>
        <li id="c03-li-0020">
         Don't put your initials in the code. Version control systems will track that kind of information automatically for you.
        </li>
        <li id="c03-li-0021">
         If you are doing something with an API that isn't immediately obvious, include a reference to the documentation of that API where it is explained.
        </li>
        <li id="c03-li-0022">
         Remember to update your comments when you update the code. Nothing is more confusing than code that is fully documented with incorrect comments.
        </li>
        <li id="c03-li-0023">
         If you use comments to separate a function into sections, consider whether the function can be broken up into multiple, smaller functions.
        </li>
        <li id="c03-li-0024">
         Avoid offensive or derogatory language. You never know who might look at your code someday.
        </li>
        <li id="c03-li-0025">
         Liberal use of inside jokes is generally considered OK. Check with your manager.
        </li>
       </ul>
      </section>
      <section>
       <span id="c03-sec-0020">
       </span>
       <h4 id="head-4-86">
        Self-Documenting Code
       </h4>
       <p id="c03-para-0047">
        Well-written code often doesn't need abundant commenting. The best code is written to be readable. If you find yourself adding a comment for every line, consider whether the code could be rewritten to better match what you are saying in the comments. For example, use descriptive names for your functions, parameters, variables, classes, and so on. Properly make use of
        <code>
         const
        </code>
        ; that is, if a variable is not supposed to be modified, mark it as
        <code>
         const
        </code>
        . Reorder the steps in a function to make it clearer what it is doing. Introduce intermediate well-named variables to make an algorithm easier to understand. Remember that C++ is a language. Its main purpose is to tell the computer what to do, but the semantics of the language can also be used to explain its meaning to a reader.
       </p>
       <p>
        Another way to write self-documenting code is to break up, or
        <i>
         decompose
        </i>
        , your code into smaller pieces. That is the topic of the next section.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c03-para-0049">
           <b>
            NOTE
           </b>
           <i>
            Good code is naturally readable and only requires comments to provide useful additional information.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-66">
     <span id="c03-sec-0022">
     </span>
     <h2 id="head-2-66">
      DECOMPOSITION
     </h2>
     <p id="c03-para-0050">
      Decomposition is the practice of breaking up code into smaller pieces. There is nothing more daunting in the world of coding than opening up a file of source code to find 300-line functions and
      <span aria-label="130" epub:type="pagebreak" id="Page_130" role="doc-pagebreak">
      </span>
      massive, nested blocks of code. Ideally, each function should accomplish a single task. Any subtasks of significant complexity should be decomposed into separate functions. For example, if somebody asks you what a function does and you answer, “First it does A, then it does B; then, if C, it does D; otherwise, it does E,” you should probably have separate helper functions for A, B, C, D, and E.
     </p>
     <p id="c03-para-0051">
      Decomposition is not an exact science. Some programmers will say that no function should be longer than a page of printed code. That may be a good rule of thumb, but you could certainly find a quarter-page of code that is desperately in need of decomposition. Another rule of thumb is that if you squint your eyes and look at the format of the code without reading the actual content, it shouldn't appear too dense in any one area. For example,
      <a href="#c03-fig-0002" id="R_c03-fig-0002">
       Figures 3.2
      </a>
      and
      <a href="#c03-fig-0003" id="R_c03-fig-0003">
       3.3
      </a>
      show code that has been purposely blurred so that you don't focus on the content. It should be obvious that the code in
      <a href="#c03-fig-0003">
       Figure 3.3
      </a>
      has better decomposition than the code in
      <a href="#c03-fig-0002">
       Figure 3.2
      </a>
      .
     </p>
     <figure>
      <img alt="A snapshot of code that has been purposely blurred so that you do not focus on the content." class="center" src="../images\images/c03f002.png"/>
      <figcaption>
       <p>
        <span class="figureLabel">
         <a href="#R_c03-fig-0002" id="c03-fig-0002" role="doc-backlink">
          <b>
           FIGURE 3.2
          </b>
         </a>
        </span>
       </p>
      </figcaption>
     </figure>
     <figure>
      <img alt="A snapshot of code that has been purposely blurred so that you do not focus on the content. This code has better decomposition." class="center" src="../images\images/c03f003.png"/>
      <figcaption>
       <p>
        <span class="figureLabel">
         <a href="#R_c03-fig-0003" id="c03-fig-0003" role="doc-backlink">
          <b>
           FIGURE 3.3
          </b>
         </a>
        </span>
       </p>
      </figcaption>
     </figure>
     <section>
      <span id="c03-sec-0023">
      </span>
      <h3 id="head-3-118">
       Decomposition through Refactoring
      </h3>
      <p id="c03-para-0052">
       Sometimes, when you've had a few coffees and you're really in the programming zone, you start coding so fast that you end up with code that does exactly what it's supposed to do but is far from pretty. All programmers do this from time to time. Short periods of vigorous coding are sometimes the most productive times in the course of a project. Dense code also arises over the course of time as code is modified. As new requirements and bug fixes emerge, existing code is amended with small modifications. The computing term
       <i>
        cruft
       </i>
       refers to the gradual accumulation of small amounts of code that eventually turns a once-elegant piece of code into a mess of patches and special cases.
      </p>
      <p>
       <i>
        Refactoring
       </i>
       is the act of restructuring your code. The book
       <i>
        Refactoring: Improving the Design of Existing Code
       </i>
       , 2nd edition, by Martin Fowler is
       <span aria-label="131" epub:type="pagebreak" id="Page_131" role="doc-pagebreak">
       </span>
       one of the most influential books about refactoring (see the bibliography in
       <a href="b02.xhtml">
        Appendix B
       </a>
       , “Annotated Bibliography”). The following list contains some example techniques to refactor code:
      </p>
      <ul class="check1" id="c03-list-0006">
       <li id="c03-li-0026">
        Techniques that allow for more abstraction:
        <ul class="check1" id="c03-list-0007">
         <li id="c03-li-0027">
          <b>
           Encapsulate data member:
          </b>
          Make a data member private and give access to it with getter and setter member functions.
         </li>
         <li id="c03-li-0028">
          <b>
           Generalize type:
          </b>
          Create more general types to allow for more code sharing.
         </li>
        </ul>
       </li>
       <li id="c03-li-0029">
        Techniques for breaking code apart into more logical pieces:
        <ul class="check1" id="c03-list-0008">
         <li id="c03-li-0030">
          <b>
           Extract member function:
          </b>
          Turn part of a larger member function into a new member function to make it easier to understand.
         </li>
         <li id="c03-li-0031">
          <b>
           Extract class:
          </b>
          Move part of the code from an existing class into a new class.
         </li>
        </ul>
       </li>
       <li id="c03-li-0032">
        Techniques for improving names and the location of code:
        <ul class="check1" id="c03-list-0009">
         <li id="c03-li-0033">
          <b>
           Move member function or move data member:
          </b>
          Move to a more appropriate class or source file.
         </li>
         <li id="c03-li-0034">
          <b>
           Rename member function or rename data member:
          </b>
          Change the name to better reveal its purpose.
         </li>
         <li id="c03-li-0035">
          <b>
           Pull up:
          </b>
          In object-oriented programming, move to a base class.
         </li>
         <li id="c03-li-0036">
          <b>
           Push down:
          </b>
          In object-oriented programming, move to a derived class.
         </li>
        </ul>
       </li>
      </ul>
      <p id="c03-para-0057">
       Whether your code starts its life as a dense block of unreadable cruft or it just evolves that way, refactoring is necessary to periodically purge the code of accumulated hacks. Through refactoring, you revisit existing code and rewrite it to make it more readable and maintainable. Refactoring is an opportunity to revisit the decomposition of code. If the purpose of the code has changed or if it was never decomposed in the first place, when you refactor the code, squint at it and determine whether it needs to be broken down into smaller parts.
      </p>
      <p id="c03-para-0058">
       When refactoring code, it is important to be able to rely on a testing framework that catches any defects that you might introduce. Unit tests, discussed in
       <a href="c30.xhtml">
        Chapter 30
       </a>
       , are particularly well suited for helping you catch mistakes during refactoring.
      </p>
     </section>
     <section>
      <span id="c03-sec-0024">
      </span>
      <h3 id="head-3-119">
       Decomposition by Design
      </h3>
      <p id="c03-para-0059">
       If you use modular decomposition and approach every module and function by considering what pieces of it you can put off until later, your programs will generally be less dense and more organized than if you implement every feature in its entirety as you code.
      </p>
      <p id="c03-para-0060">
       Of course, you should still design your program
       <i>
        before
       </i>
       jumping into the code.
      </p>
     </section>
     <section>
      <span id="c03-sec-0025">
      </span>
      <h3 id="head-3-120">
       Decomposition in This Book
      </h3>
      <p id="c03-para-0061">
       You will see decomposition in many of the examples in this book. In many cases, functions are referred to for which no implementation is shown because they are not relevant to the example and would take up too much space.
      </p>
     </section>
    </section>
    <span aria-label="132" epub:type="pagebreak" id="Page_132" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-67">
     <span id="c03-sec-0026">
     </span>
     <h2 id="head-2-67">
      NAMING
     </h2>
     <p>
      The C++ compiler has a few naming rules:
     </p>
     <ul class="check1" id="c03-list-0010">
      <li id="c03-li-0037">
       Names can contain uppercase and lowercase letters, digits, and underscores.
      </li>
      <li id="c03-li-0038">
       Letters are not limited to the English alphabet but can be letters from any language, such as Japanese, Arabic, and so on.
      </li>
      <li id="c03-li-0039">
       Names cannot start with a number (for example,
       <code>
        9to5
       </code>
       ).
      </li>
      <li id="c03-li-0040">
       Names that contain a double underscore (such as
       <code>
        my__name
       </code>
       ) are reserved for use by the Standard Library and shall not be used.
      </li>
      <li id="c03-li-0041">
       Names that begin with an underscore followed by an uppercase letter (such as
       <code>
        _Name
       </code>
       ) are always reserved for use by the Standard Library and shall not be used.
      </li>
      <li id="c03-li-0042">
       Names in the global namespace that begin with an underscore (such as
       <code>
        _name
       </code>
       ) are reserved and shall not be used.
      </li>
     </ul>
     <p id="c03-para-0063">
      Other than those rules, names exist only to help you and your fellow programmers work with the individual elements of your program. Given this purpose, it is surprising how often programmers use unspecific or inappropriate names.
     </p>
     <section>
      <span id="c03-sec-0027">
      </span>
      <h3 id="head-3-121">
       Choosing a Good Name
      </h3>
      <p id="c03-para-0064">
       The best name for a variable, member function, function, parameter, class, namespace, and so on, accurately describes the purpose of the item. Names can also imply additional information, such as the type or specific usage. Of course, the real test is whether other programmers understand what you are trying to convey with a particular name.
      </p>
      <p id="c03-para-0065">
       There are no set-in-stone rules for naming other than the rules that work for your organization. However, there are some names that are rarely appropriate. The following table shows some names at both ends of the naming continuum:
      </p>
      <table border="1">
       <thead>
        <tr>
         <th class="left bgcolor2" scope="col">
          GOOD NAMES
         </th>
         <th class="left bgcolor2" scope="col">
          BAD NAMES
         </th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           sourceName
          </code>
          ,
          <code>
           destinationName
          </code>
          <br/>
          Distinguishes two objects
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           thing1
          </code>
          ,
          <code>
           thing2
          </code>
          <br/>
          Too general
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           m_nameCounter
          </code>
          <br/>
          Conveys data member status
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           m_NC
          </code>
          <br/>
          Too obscure, too brief
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           calculateMarigoldOffset()
          </code>
          <br/>
          Simple, accurate
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           doAction()
          </code>
          <br/>
          Too general, imprecise
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           m_typeString
          </code>
          <br/>
          Easy on the eyes
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           typeSTR256
          </code>
          <br/>
          A name only a computer could love
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           g_settings
          </code>
          <br/>
          Conveys global status
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           m_IHateLarry
          </code>
          <br/>
          Unacceptable inside joke
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           errorMessage
          </code>
          <br/>
          Descriptive name
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           string
          </code>
          <br/>
          Nondescriptive name
         </td>
        </tr>
        <tr>
         <td class="left bor1 bgcolor3">
          <code>
           sourceFile
          </code>
          ,
          <code>
           destinationFile
          </code>
          <br/>
          No abbreviations
         </td>
         <td class="left bor1 bgcolor3">
          <code>
           srcFile
          </code>
          ,
          <code>
           dstFile
          </code>
          <br/>
          Abbreviations
          <span aria-label="133" epub:type="pagebreak" id="Page_133" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
     </section>
     <section>
      <span id="c03-sec-0028">
      </span>
      <h3 id="head-3-122">
       Naming Conventions
      </h3>
      <p id="c03-para-0095">
       Selecting a name doesn't always require a lot of thought and creativity. In many cases, you'll want to use standard techniques for naming. The following are some of the types of data for which you can make use of standard names.
      </p>
      <section>
       <span id="c03-sec-0029">
       </span>
       <h4 id="head-4-87">
        Counters
       </h4>
       <p id="c03-para-0096">
        Early in your programming career, you probably saw code that used the variable
        <code>
         i
        </code>
        as a counter. It is customary to use
        <code>
         i
        </code>
        and
        <code>
         j
        </code>
        as counters and inner-loop counters, respectively. Be careful with nested loops, however. It's a common mistake to refer to the “
        <code>
         i
        </code>
        <sup>
         th
        </sup>
        ” element when you really mean the “
        <code>
         j
        </code>
        <sup>
         th
        </sup>
        ” element. When working with 2-D matrices, it's probably easier to use
        <code>
         row
        </code>
        and
        <code>
         column
        </code>
        as indices instead of
        <code>
         i
        </code>
        and
        <code>
         j
        </code>
        . Some programmers prefer using counters
        <code>
         outerLoopIndex
        </code>
        and
        <code>
         innerLoopIndex
        </code>
        , and some even frown upon using
        <code>
         i
        </code>
        and
        <code>
         j
        </code>
        as loop counters.
       </p>
      </section>
      <section>
       <span id="c03-sec-0030">
       </span>
       <h4 id="head-4-88">
        Prefixes
       </h4>
       <p id="c03-para-0097">
        Many programmers begin their variable names with a letter that provides some information about the variable's type or usage. On the other hand, there are as many programmers, or even more, who disapprove of using any kind of prefix because this could make evolving code less maintainable in the future. For example, if a member variable is changed from
        <code>
         static
        </code>
        to non-
        <code>
         static
        </code>
        , you have to rename all the uses of that name. If you don't rename them, your names continue to convey semantics, but now they are the wrong semantics.
       </p>
       <p id="c03-para-0098">
        However, you often don't have a choice, and you need to follow the guidelines of your company. The following table shows some potential prefixes:
       </p>
       <table border="1">
        <thead>
         <tr>
          <th class="left bgcolor2" scope="col">
           PREFIX
          </th>
          <th class="left bgcolor2" scope="col">
           EXAMPLE NAME
          </th>
          <th class="left bgcolor2" scope="col">
           LITERAL PREFIX MEANING
          </th>
          <th class="left bgcolor2" scope="col">
           USAGE
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            m
            <br/>
            m_
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           <code>
            mData
           </code>
           <br/>
           <code>
            m_data
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           “member”
          </td>
          <td class="left bor1 bgcolor3">
           Data member within a class
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            s
            <br/>
            ms
            <br/>
            ms_
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           <code>
            sLookupTable
           </code>
           <br/>
           <code>
            msLookupTable
           </code>
           <br/>
           <code>
            ms_lookupTable
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           “static”
          </td>
          <td class="left bor1 bgcolor3">
           Static variable or data member
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            k
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           <code>
            kMaximumLength
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           “konstant” (German for “constant”)
          </td>
          <td class="left bor1 bgcolor3">
           A constant value. Some programmers omit any prefix to indicate constants.
          </td>
         </tr>
         <tr>
          <td class="left bor1 bgcolor3">
           <code>
            bis
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           <code>
            bCompleted isCompleted
           </code>
          </td>
          <td class="left bor1 bgcolor3">
           “Boolean”
          </td>
          <td class="left bor1 bgcolor3">
           Designates a Boolean value
          </td>
         </tr>
        </tbody>
       </table>
      </section>
      <span aria-label="134" epub:type="pagebreak" id="Page_134" role="doc-pagebreak">
      </span>
      <section>
       <span id="c03-sec-0031">
       </span>
       <h4 id="head-4-89">
        Hungarian Notation
       </h4>
       <p>
        Hungarian notation is a variable and data member-naming convention that is popular with Microsoft Windows programmers. The basic idea is that instead of using single-letter prefixes such as
        <code>
         m
        </code>
        , you should use more verbose prefixes to indicate additional information. The following line of code shows the use of Hungarian notation:
       </p>
       <pre id="c03-code-0018"><code>char* pszName; <span class="color3">// psz means "pointer to string, zero-terminated"</span></code></pre>
       <p>
        The term
        <i>
         Hungarian notation
        </i>
        arose from the fact that its inventor, Charles Simonyi, is Hungarian. Some also say that it accurately reflects the fact that programs using Hungarian notation end up looking as if they were written in a foreign language. For this latter reason, some programmers tend to dislike Hungarian notation. In this book, prefixes are used, but not Hungarian notation. Adequately named variables don't need much additional context information besides the prefix. For example, a data member named
        <code>
         m_name
        </code>
        says it all.
       </p>
       <section>
        <aside>
         <div class="top hr">
          <hr/>
         </div>
         <section class="feature1">
          <p id="c03-para-0107">
           <b>
            NOTE
           </b>
           <i>
            Good names convey information about their purpose without making the code unreadable.
           </i>
          </p>
          <div class="bottom hr">
           <hr/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section>
       <span id="c03-sec-0033">
       </span>
       <h4 id="head-4-90">
        Getters and Setters
       </h4>
       <p id="c03-para-0108">
        If your class contains a data member, such as
        <code>
         m_status
        </code>
        , it is customary to provide access to the member via a getter called
        <code>
         getStatus()
        </code>
        and, optionally, a setter called
        <code>
         setStatus()
        </code>
        . To give access to a Boolean data member, you typically use
        <code>
         is
        </code>
        as a prefix instead of
        <code>
         get
        </code>
        , for example
        <code>
         isRunning()
        </code>
        . The C++ language has no prescribed naming for these functions, but your organization will probably want to adopt this or a similar naming scheme.
       </p>
      </section>
      <section>
       <span id="c03-sec-0034">
       </span>
       <h4 id="head-4-91">
        Capitalization
       </h4>
       <p id="c03-para-0109">
        There are many different ways of capitalizing names in your code. As with most elements of coding style, it is important that your group adopts a standardized approach and that all members adopt that approach. One way to get messy code is to have some programmers naming classes in all lowercase with underscores representing spaces (
        <code>
         priority_queue
        </code>
        ) and others using capitals with each subsequent word capitalized (
        <code>
         PriorityQueue
        </code>
        ). Variables and data members almost always start with a lowercase letter and use either underscores (
        <code>
         my_queue
        </code>
        ) or capitals (
        <code>
         myQueue
        </code>
        ) to indicate word breaks. Functions traditionally start with a capital letter in C++, but, as you've seen, in this book I have adopted the style of using a lowercase first letter for functions to distinguish them from class names.
       </p>
      </section>
      <section>
       <span id="c03-sec-0035">
       </span>
       <h4 id="head-4-92">
        Namespaced Constants
       </h4>
       <p id="c03-para-0110">
        Imagine that you are writing a program with a graphical user interface. The program has several menus, including File, Edit, and Help. To represent the ID of each menu, you may decide to use a constant. A perfectly reasonable name for a constant referring to the Help menu ID is
        <code>
         Help
        </code>
        .
       </p>
       <p id="c03-para-0111">
        The name
        <code>
         Help
        </code>
        will work fine until you add a Help button to the main window. You also need a constant to refer to the ID of the button, but
        <code>
         Help
        </code>
        is already taken.
       </p>
       <p id="c03-para-0112">
        <span aria-label="135" epub:type="pagebreak" id="Page_135" role="doc-pagebreak">
        </span>
        A possible solution for this is to put your constants in different namespaces, which are discussed in
        <a href="c01.xhtml">
         Chapter 1
        </a>
        , “A Crash Course in C++ and the Standard Library.” You create two namespaces:
        <code>
         Menu
        </code>
        and
        <code>
         Button
        </code>
        . Each namespace has a
        <code>
         Help
        </code>
        constant, and you use them as
        <code>
         Menu::Help
        </code>
        and
        <code>
         Button::Help
        </code>
        , although in this case, a more recommended solution is to use enumerations, also introduced in
        <a href="c01.xhtml">
         Chapter 1
        </a>
        .
       </p>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-68">
     <span id="c03-sec-0036">
     </span>
     <h2 id="head-2-68">
      USING LANGUAGE FEATURES WITH STYLE
     </h2>
     <p>
      The C++ language lets you do all sorts of terribly unreadable things. Take a look at this wacky code:
     </p>
     <pre id="c03-code-0019"><code>i++ + ++i;</code></pre>
     <p id="c03-para-0114">
      This is unreadable, but more importantly, its behavior is undefined by the C++ standard. The problem is that
      <code>
       i++
      </code>
      uses the value of
      <code>
       i
      </code>
      but has a side effect of incrementing it. The standard does not say when this incrementing should be done, only that the side effect (increment) should be visible after the sequence point
      <code>
       ;
      </code>
      . However, the compiler can do it at any time during the execution of that statement. It's impossible to know which value of
      <code>
       i
      </code>
      will be used for the
      <code>
       ++i
      </code>
      part. Running this code with different compilers and platforms can result in different values.
     </p>
     <p>
      Expressions such as the following
     </p>
     <pre id="c03-code-0020"><code>a[i] = ++i;</code></pre>
     <p id="c03-para-0116">
      are well-defined since C++17, which guarantees that the evaluation of all operations on the right-hand side of an assignment is finished before evaluating the left-hand side. So, in this case, first
      <code>
       i
      </code>
      is incremented and then used as index in
      <code>
       a[i]
      </code>
      . Even so, for clarity, it remains recommended to avoid such expressions.
     </p>
     <p id="c03-para-0117">
      With all the power that the C++ language offers, it is important to consider how the language features can be used toward stylistic good instead of evil.
     </p>
     <section>
      <span id="c03-sec-0037">
      </span>
      <h3 id="head-3-123">
       Use Constants
      </h3>
      <p>
       Bad code is often littered with “magic numbers.” In some function, the code might be using 2.71828 or 24 or 3600, and so on. Why? What do these values mean? People with a mathematical background might find it obvious that 2.71828 represents an approximation of the transcendental value
       <i>
        e
       </i>
       , but most people don't know this. The C++ language offers constants to give symbolic names to values that don't change, such as 2.71828, 24, 3600, and so on. Here are some examples:
      </p>
      <pre id="c03-code-0021"><code>const double ApproximationForE { 2.71828182845904523536 };</code>
<code>const int HoursPerDay { 24 };</code>
<code>const int SecondsPerHour { 3'600 };</code></pre>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c03-para-0120">
          <b>
           NOTE
          </b>
          <i>
           The Standard Library includes a collection of predefined mathematical constants, all defined in
          </i>
          <code>
           &lt;numbers&gt;
          </code>
          <i>
           <i>
            in the
           </i>
          </i>
          <code>
           std::numbers
          </code>
          <i>
           <i>
            namespace. For example, it defines
           </i>
          </i>
          <code>
           std::numbers::e
          </code>
          <i>
           ,
          </i>
          <code>
           pi
          </code>
          <i>
           ,
          </i>
          <code>
           sqrt2
          </code>
          <i>
           ,
          </i>
          <code>
           phi
          </code>
          <i>
           ,
           <i>
            and many more
           </i>
           .
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <span aria-label="136" epub:type="pagebreak" id="Page_136" role="doc-pagebreak">
     </span>
     <section>
      <span id="c03-sec-0039">
      </span>
      <h3 id="head-3-124">
       Use References Instead of Pointers
      </h3>
      <p id="c03-para-0121">
       In the past, C++ programmers often learned C first. In C, pointers were the only pass-by-reference mechanism, and they certainly worked just fine for many years. Pointers are still required in some cases, but in many situations you can switch to references. If you learned C first, you probably think that references don't really add any new functionality to the language. You might think that they merely introduce a new syntax for functionality that pointers could already provide.
      </p>
      <p id="c03-para-0122">
       There are several advantages to using references rather than pointers. First, references are safer than pointers because they don't deal directly with memory addresses and cannot be
       <code>
        nullptr
       </code>
       . Second, references are stylistically more pleasing than pointers because they use the same syntax as stack variables; i.e., they do not require you to explicitly take the address of them using
       <code>
        &amp;
       </code>
       or to explicitly dereference them using
       <code>
        *
       </code>
       . They're also easy to use, so you should have no problem adopting references into your style palette. Unfortunately, some programmers think that if they see an
       <code>
        &amp;
       </code>
       in a function call, they know the called function is going to change the object, and if they don't see the
       <code>
        &amp;
       </code>
       , it must be pass-by-value. With references, they say they don't know if the function is going to change the object unless they look at the function prototype. This is a wrong way of thinking. Passing in a pointer does not automatically mean that the object will be modified, because the parameter might be
       <code>
        const T*
       </code>
       . Passing both a pointer and a reference can modify the object, or it may not, depending on whether the function parameter uses
       <code>
        const T*
       </code>
       ,
       <code>
        T*
       </code>
       ,
       <code>
        const T&amp;
       </code>
       , or
       <code>
        T&amp;
       </code>
       . So, you need to look at the function prototype anyway to know whether the function might change the object.
      </p>
      <p id="c03-para-0123">
       Another benefit of references is that they clarify ownership of memory. If you are writing a function and another programmer passes you a reference to an object, it is clear that you can read and possibly modify the object, but you have no easy way of freeing its memory. If you are passed a pointer, this might be less clear. Do you need to delete the object to clean up memory? Or will the caller do that? Though in modern C++, the meaning is clear: any raw pointer is non-owning, and handling ownership and ownership transfer is done using smart pointers, discussed in
       <a href="c07.xhtml">
        Chapter 7
       </a>
       , “Memory Management.”
      </p>
     </section>
     <section>
      <span id="c03-sec-0040">
      </span>
      <h3 id="head-3-125">
       Use Custom Exceptions
      </h3>
      <p id="c03-para-0124">
       C++ makes it easy to ignore exceptions. Nothing about the language syntax forces you to deal with exceptions, and you could in theory write error-tolerant programs with traditional mechanisms such as returning special values (for example,
       <code>
        -1
       </code>
       ,
       <code>
        nullptr
       </code>
       , …) or setting error flags. When returning special values to signal errors, the
       <code>
        [[nodiscard]]
       </code>
       attribute, introduced in
       <a href="c01.xhtml">
        Chapter 1
       </a>
       , can be used to force the caller of your function to do something with the returned value.
      </p>
      <p id="c03-para-0125">
       However, exceptions provide a much richer mechanism for error handling, and custom exceptions allow you to tailor this mechanism to your needs. For example, a custom exception type for a web browser could include fields that specify the web page that contained the error, the network state when the error occurred, and additional context information.
      </p>
      <p>
       <a href="c14.xhtml">
        Chapter 14
       </a>
       , “Handling Errors,” contains a wealth of information about exceptions in C++.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c03-para-0127">
          <b>
           NOTE
          </b>
          <i>
           Language features exist to help the programmer. Understand and make use of features that contribute to good programming style.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <span aria-label="137" epub:type="pagebreak" id="Page_137" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-69">
     <span id="c03-sec-0042">
     </span>
     <h2 id="head-2-69">
      FORMATTING
     </h2>
     <p id="c03-para-0128">
      Many programming groups have been torn apart and friendships ruined over code-formatting arguments. In college, a friend of mine got into such a heated debate with a peer over the use of spaces in an
      <code>
       if
      </code>
      statement that people were stopping by to make sure that everything was OK.
     </p>
     <p id="c03-para-0129">
      If your organization has standards in place for code formatting, consider yourself lucky. You may not like the standards they have in place, but at least you won't have to argue about them.
     </p>
     <p id="c03-para-0130">
      If no standards are in place for code formatting, I recommend introducing them in your organization. Standardized coding guidelines make sure that all programmers on your team follow the same naming conventions, formatting rules, and so on, which makes the code more uniform and easier to understand.
     </p>
     <p id="c03-para-0131">
      There are automated tools available that can format your code according to certain rules right before committing the code to your version control system. Some IDEs have such tools built-in and can, for example, automatically format the code when saving a file.
     </p>
     <p id="c03-para-0132">
      If everybody on your team is just writing code their own way, try to be as tolerant as you can. As you'll see, some practices are just a matter of taste, while others actually make it difficult to work in teams.
     </p>
     <section>
      <span id="c03-sec-0043">
      </span>
      <h3 id="head-3-126">
       The Curly Brace Alignment Debate
      </h3>
      <p>
       Perhaps the most frequently debated point is where to put the curly braces that demark a block of code. There are several styles of curly brace use. In this book, the curly brace is put on the same line as the leading statement, except in the case of a class, function, or member function. This style is shown in the code that follows (and throughout this book):
      </p>
      <pre id="c03-code-0022"><code>void someFunction()</code>
<code>{</code>
<code>    if (condition()) {</code>
<code>        println("condition was true");</code>
<code>    } else {</code>
<code>        println("condition was false");</code>
<code>    }</code>
<code>}</code></pre>
      <p>
       This style conserves vertical space while still showing blocks of code by their indentation. Some programmers would argue that preservation of vertical space isn't relevant in real-world coding. A more verbose style is shown here:
      </p>
      <pre id="c03-code-0023"><code>void someFunction()</code>
<code>{</code>
<code>    if (condition())</code>
<code>    {</code>
<code>        println("condition was true");</code>
<code>    }</code>
<code>    else</code>
<code>    {</code>
<code>        println("condition was false");</code>
<code>    }</code>
<code>}</code></pre>
      <p>
       <span aria-label="138" epub:type="pagebreak" id="Page_138" role="doc-pagebreak">
       </span>
       Some programmers are even liberal with the use of horizontal space, yielding code like this:
      </p>
      <pre id="c03-code-0024"><code>void someFunction()</code>
<code>{</code>
<code>    if (condition())</code>
<code>        {</code>
<code>            println("condition was true");</code>
<code>        }</code>
<code>    else</code>
<code>        {</code>
<code>            println("condition was false");</code>
<code>        }</code>
<code>}</code></pre>
      <p>
       Another point of debate is whether to put braces around single statements, for example:
      </p>
      <pre id="c03-code-0025"><code>void someFunction()</code>
<code>{</code>
<code>    if (condition())</code>
<code>        println("condition was true");</code>
<code>    else</code>
<code>        println("condition was false");</code>
<code>}</code></pre>
      <p>
       Obviously, I won't recommend any particular style because I don't want hate mail. Personally, I always use braces, even for single statements, as it protects against certain badly written C-style macros (see
       <a href="c11.xhtml">
        Chapter 11
       </a>
       , “Modules, Header Files, and Miscellaneous Topics”) and is safer against adding statements in the future.
      </p>
      <section>
       <aside>
        <div class="top hr">
         <hr/>
        </div>
        <section class="feature1">
         <p id="c03-para-0138">
          <b>
           NOTE
          </b>
          <i>
           When selecting a style for denoting blocks of code, the important consideration is how well you can see which block falls under which condition simply by looking at the code.
          </i>
         </p>
         <div class="bottom hr">
          <hr/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section>
      <span id="c03-sec-0045">
      </span>
      <h3 id="head-3-127">
       Coming to Blows over Spaces and Parentheses
      </h3>
      <p id="c03-para-0139">
       The formatting of individual lines of code can also be a source of disagreement. Again, I won't advocate a particular approach, but you are likely to encounter a few of the styles shown here.
      </p>
      <p>
       In this book, I use a space after any keyword, a space before and after any operator, a space after every comma in a parameter list or a call, and parentheses to clarify the order of operations, as follows:
      </p>
      <pre id="c03-code-0026"><code>if (i == 2) {</code>
<code>    j = i + (k / m);</code>
<code>}</code></pre>
      <p>
       An alternative, shown next, treats
       <code>
        if
       </code>
       stylistically like a function, with no space between the keyword and the left parenthesis. Also, the parentheses used to clarify the order of operations inside of the
       <code>
        if
       </code>
       statement are omitted because they have no semantic relevance.
      </p>
      <pre id="c03-code-0027"><code>if( i == 2 ) {</code>
<code>    j = i + k / m;</code>
<code>}</code></pre>
      <p id="c03-para-0142">
       <span aria-label="139" epub:type="pagebreak" id="Page_139" role="doc-pagebreak">
       </span>
       The difference is subtle, and the determination of which is better is left to the reader, yet I can't move on from the issue without pointing out that
       <code>
        if
       </code>
       is not a function.
      </p>
     </section>
     <section>
      <span id="c03-sec-0046">
      </span>
      <h3 id="head-3-128">
       Spaces, Tabs, and Line Breaks
      </h3>
      <p id="c03-para-0143">
       The use of spaces and tabs is not merely a stylistic preference. If your group does not agree on a convention for spaces and tabs, there are going to be major problems when programmers work jointly. The most obvious problem occurs when Alice uses four-space tabs to indent code and Bob uses five-space tabs; neither will be able to display code properly when working on the same file. An even worse problem arises when Bob reformats the code to use tabs at the same time that Alice edits the same code; many version control systems won't be able to merge in Alice's changes.
      </p>
      <p id="c03-para-0144">
       Most, but not all, editors have configurable settings for spaces and tabs. Some environments even adapt to the formatting of the code as it is read in or always save using spaces even if the Tab key is used for authoring. If you have a flexible environment, you have a better chance of being able to work with other people's code. Just remember that tabs and spaces are different because a tab can be any length and a space is always a space.
      </p>
      <p id="c03-para-0145">
       Finally, not all platforms represent a line break in the same way. Windows, for example, uses
       <code>
        \r\n
       </code>
       for line breaks, while Linux-based platforms typically use
       <code>
        \n
       </code>
       . If you use multiple platforms in your company, then you need to agree on which line break style to use. Here also, your IDE can most likely be configured to use the line break style you need, or automated tools can be used to automatically fix line breaks, for example, when committing your code to your version control system.
      </p>
     </section>
    </section>
    <section aria-labelledby="head-2-70">
     <span id="c03-sec-0047">
     </span>
     <h2 id="head-2-70">
      STYLISTIC CHALLENGES
     </h2>
     <p id="c03-para-0146">
      Many programmers begin a new project by pledging that this time they will do everything right. Any time a variable or parameter shouldn't be changed, it'll be marked
      <code>
       const
      </code>
      . All variables will have clear, concise, readable names. Every developer will put the left curly brace on the subsequent line and will adopt the standard text editor and its conventions for tabs and spaces.
     </p>
     <p id="c03-para-0147">
      For a number of reasons, it is difficult to sustain this level of stylistic consistency. In the case of
      <code>
       const
      </code>
      , sometimes programmers just aren't educated about how to use it. You will eventually come across old code or a library function that isn't
      <code>
       const
      </code>
      -savvy. For example, suppose you are writing a function accepting a
      <code>
       const
      </code>
      parameter, and you need to call a legacy function accepting a non-
      <code>
       const
      </code>
      parameter. If you cannot modify the legacy code to make it
      <code>
       const
      </code>
      aware, maybe because it's a third-party library, and you are absolutely certain that the legacy function will not modify its non-
      <code>
       const
      </code>
      argument, then a good programmer will use
      <code>
       const_cast()
      </code>
      (see
      <a href="c01.xhtml">
       Chapter 1
      </a>
      ) to temporarily suspend the
      <code>
       const
      </code>
      property of the parameter, but an inexperienced programmer will start to unwind the
      <code>
       const
      </code>
      property back from the calling function, once again ending up with a program that never uses
      <code>
       const
      </code>
      .
     </p>
     <p id="c03-para-0148">
      Other times, standardization of style comes up against programmers’ individual tastes and biases. Perhaps the culture of your team makes it impractical to enforce strict style guidelines. In such situations, you may have to decide which elements you really need to standardize (such as variable names and tabs) and which ones are safe to leave up to individuals (perhaps spacing and commenting style). You can even obtain or write scripts that will automatically correct style “bugs” or flag stylistic problems along with code errors. Some development environments, such as Microsoft Visual C++, support automatic formatting of code according to rules that you specify. This makes it trivial to write code that always follows the guidelines that have been configured.
     </p>
    </section>
    <span aria-label="140" epub:type="pagebreak" id="Page_140" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-71">
     <span id="c03-sec-0048">
     </span>
     <h2 id="head-2-71">
      SUMMARY
     </h2>
     <p id="c03-para-0149">
      The C++ language provides a number of stylistic tools without any formal guidelines on how to use them. Ultimately, any style convention is measured by how widely it is adopted and how much it benefits the readability of the code. When coding as part of a team, you should raise issues of style early in the process as part of the discussion of what language and tools to use.
     </p>
     <p id="c03-para-0150">
      The most important point about style is to appreciate that it is an important aspect of programming. Teach yourself to check over the style of your code before you make it available to others. Recognize good style in the code you interact with, and adopt the conventions that you and your organization find useful.
     </p>
     <p id="c03-para-0151">
      To conclude this chapter, keep the following in mind:
     </p>
     <blockquote class="extract">
      <p id="c03-para-0153">
       <i>
        Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live. Code for readability.
       </i>
      </p>
      <p class="right">
       <i>
        JOHN F. WOODS, SEP 24, 1991, COMP.LANG.c++
       </i>
      </p>
     </blockquote>
     <p id="c03-para-0154">
      This chapter concludes the first part of this book. The next part discusses software design on a high level.
     </p>
    </section>
    <section aria-labelledby="head-2-72">
     <span id="c03-sec-0049">
     </span>
     <h2 id="head-2-72">
      EXERCISES
     </h2>
     <p id="c03-para-0155">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code>
       <a href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <p id="c03-para-0156">
      Code comments and coding style are subjective. The following exercises do not have a single perfect answer. The solutions from the website provide one of many possible correct answers to the exercises.
     </p>
     <section>
      <span id="c03-exsec-0001">
      </span>
      <ol class="none">
       <li id="c03-ex-0001">
        <b>
         Exercise 3-1:
        </b>
        <a href="c01.xhtml">
         Chapter 1
        </a>
        discusses an example of an employee records system. That system has a database, and one of the member functions of the database is
        <code>
         displayCurrent()
        </code>
        . Here is the implementation of that member function with some comments:
        <pre id="c03-code-0028"><code>void Database::displayCurrent() const     <span class="color3">// The displayCurrent() member function</span></code>
<code>{</code>
<code>    for (const auto&amp; employee : m_employees) {  <span class="color3">// For each employee…</span></code>
<code>        if (employee.isHired()) {               <span class="color3">// If the employee is hired</span></code>
<code>            employee.display();                 <span class="color3">// Then display that employee</span></code>
<code>        }</code>
<code>    }</code>
<code>}</code></pre>
        <p class="listPara1" id="c03-para-0159">
         Do you see anything wrong with these comments? Why? Can you come up with better comments?
        </p>
       </li>
       <li id="c03-ex-0002">
        <span aria-label="141" epub:type="pagebreak" id="Page_141" role="doc-pagebreak">
        </span>
        <b>
         Exercise 3-2:
        </b>
        The employee records system from
        <a href="c01.xhtml">
         Chapter 1
        </a>
        contains a
        <code>
         Database
        </code>
        class. The following is a snippet of that class with only three member functions. Add proper JavaDoc-style comments to this code snippet. Consult
        <a href="c01.xhtml">
         Chapter 1
        </a>
        to brush up on what exactly these member functions do.
        <pre id="c03-code-0029"><code>class Database</code>
<code>{</code>
<code>    public:</code>
<code>        Employee&amp; addEmployee(const std::string&amp; firstName,</code>
<code>            const std::string&amp; lastName);</code>
<code>        Employee&amp; getEmployee(int employeeNumber);</code>
<code>        Employee&amp; getEmployee(const std::string&amp; firstName,</code>
<code>            const std::string&amp; lastName);</code>
<code>    <span class="color3">// Remainder omitted…</span></code>
<code>};</code></pre>
       </li>
       <li id="c03-ex-0003">
        <b>
         Exercise 3-3:
        </b>
        The following class has a number of naming issues. Can you spot them all and propose better names?
        <pre id="c03-code-0030"><code>class xrayController</code>
<code>{</code>
<code>    public:</code>
<code>        <span class="color3">// Gets the active X-ray current in μA.</span></code>
<code>        double getCurrent() const;</code>
<code></code>
<code>        <span class="color3">// Sets the current of the X-rays to the given current in μA.</span></code>
<code>        void setIt(double Val);</code>
<code></code>
<code>        <span class="color3">// Sets the current to 0 μA.</span></code>
<code>        void 0Current();</code>
<code></code>
<code>        <span class="color3">// Gets the X-ray source type.</span></code>
<code>        const std::string&amp; getSourceType() const;</code>
<code></code>
<code>        <span class="color3">// Sets the X-ray source type.</span></code>
<code>        void setSourceType(std::string_view _Type);</code>
<code></code>
<code>    private:</code>
<code>        double d; <span class="color3">// The X-ray current in μA.</span></code>
<code>        std::string m_src__type; <span class="color3">// The type of the X-ray source.</span></code>
<code>};</code></pre>
       </li>
       <li id="c03-ex-0004">
        <b>
         Exercise 3-4:
        </b>
        Given the following code snippet, reformat the snippet three times: first put curly braces on their own lines, then indent the curly braces themselves, and finally remove the curly braces for single-statement code blocks. This exercise allows you to get a feeling of different formatting styles and what the impact is on code readability.
        <pre id="c03-code-0031"><code>Employee&amp; Database::getEmployee(int employeeNumber)</code>
<code>{</code>
<code>    for (auto&amp; employee : m_employees) {</code>
<code>        if (employee.getEmployeeNumber() == employeeNumber) {</code>
<code>            return employee;</code>
<code>        }</code>
<code>    }</code>
<code>    throw logic_error { "No employee found." };</code>
<code>}</code></pre>
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c03_2" class="notesSet" role="doc-endnotes">
    <h2 id="c03_2">
     NOTE
    </h2>
    <ol class="notesList">
     <li class="noteEntry">
      <a href="#R_c03-note-0001" id="c03-note-0001" role="doc-backlink">
       1
      </a>
      <i>
       Preconditions
      </i>
      are the conditions that client code must satisfy before calling a function.
      <i>
       Postconditions
      </i>
      are the conditions that must be satisfied by the function when it has finished executing.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
