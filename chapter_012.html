<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   17Understanding Iterators and the Ranges Library
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_011.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_013.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c17_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c17_1">
      <span aria-label="653" class="calibre17" epub:type="pagebreak" id="Page_653" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c17">
      </span>
      <span class="calibre">
       17
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Understanding Iterators and the Ranges Library
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c17-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c17-list-0001">
         <li class="calibre9" id="c17-li-0001">
          Details on iterators
         </li>
         <li class="calibre9" id="c17-li-0002">
          How to use stream iterators
         </li>
         <li class="calibre9" id="c17-li-0003">
          What iterator adapters are, and how to use the standard iterator adapters
         </li>
         <li class="calibre9" id="c17-li-0004">
          What the ranges library is, consisting of ranges, range-based and constrained algorithms, projections, views, and factories
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c17-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-189">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c17-sec-0003">
        </span>
        <p class="calibre25" id="c17-para-0004">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <code class="calibre21">
           <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
            www.wiley.com/go/proc++6e
           </a>
          </code>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c17-para-0005">
      <a class="calibre5" href="c16.xhtml">
       Chapter 16
      </a>
      , “Overview of the C++ Standard Library,” introduces the Standard Library, describes its basic philosophy, and provides an overview of the provided functionality. This chapter begins a more-in-depth tour of the Standard Library by covering the ideas behind iterators used throughout a big part of the library. It also discusses the available stream iterators and iterator adapters. The second part of the chapter discusses the ranges library, a powerful library that allows for more
      <i class="calibre18">
       functional-style programming
      </i>
      : you write code that specifies
      <i class="calibre18">
       what
      </i>
      you want to accomplish instead of
      <i class="calibre18">
       how
      </i>
      .
     </p>
    </section>
    <span aria-label="654" class="calibre20" epub:type="pagebreak" id="Page_654" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-190" class="calibre2">
     <span class="calibre" id="c17-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-190">
      ITERATORS
     </h2>
     <p class="calibre13" id="c17-para-0006">
      The Standard Library uses the iterator pattern to provide a generic abstraction for accessing the elements of a container. Each container provides a container-specific iterator, which is a glorified pointer that knows how to iterate over the elements of that specific container, i.e., an iterator supports traversing the elements of a container. The different iterators for the various containers adhere to standard interfaces defined by the C++ standard. Thus, even though the containers provide different functionality, the iterators present a common interface to code that wants to work with elements of the containers. This results in code that is easier to read and write, less error-prone (e.g., iterators are easier to use correctly compared to pointer arithmetic), more efficient (especially for containers that do not support random access, such as
      <code class="calibre21">
       std::list
      </code>
      and
      <code class="calibre21">
       forward_list
      </code>
      ; see
      <a class="calibre5" href="c16.xhtml">
       Chapter 16
      </a>
      ), and easier to debug (e.g., iterators could perform bounds checking in debug builds of your code). Additionally, when using iterators to iterate over the contents of a container, the underlying implementation of the container could change completely without any impact on your iterator-based code.
     </p>
     <p class="calibre13" id="c17-para-0007">
      You can think of an iterator as a pointer to a specific element of the container. Like pointers to elements in an array, iterators can move to the next element with
      <code class="calibre21">
       operator++
      </code>
      . Similarly, you can usually use
      <code class="calibre21">
       operator*
      </code>
      and
      <code class="calibre21">
       operator-&gt;
      </code>
      on the iterator to access the actual element or field of the element. Some iterators allow comparison with
      <code class="calibre21">
       operator==
      </code>
      and
      <code class="calibre21">
       operator!=
      </code>
      , and support
      <code class="calibre21">
       operator--
      </code>
      for moving to previous elements.
     </p>
     <p class="calibre13" id="c17-para-0008">
      All iterators must be copy constructible, copy assignable, and destructible. Lvalues of iterators must be swappable. Different containers provide iterators with slightly different additional capabilities. The standard defines six categories of iterators, as summarized in the following table:
     </p>
     <table border="1" class="calibre31">
      <thead class="calibre32">
       <tr class="calibre33">
        <th class="left" scope="col">
         ITERATOR CATEGORY
        </th>
        <th class="left" scope="col">
         OPERATIONS REQUIRED
        </th>
        <th class="left" scope="col">
         COMMENTS
        </th>
       </tr>
      </thead>
      <tbody class="calibre34">
       <tr class="calibre33">
        <td class="left1">
         Input (also known as Read)
        </td>
        <td class="left1">
         <code class="calibre21">
          operator++
         </code>
         ,
         <code class="calibre21">
          *
         </code>
         ,
         <code class="calibre21">
          -&gt;
         </code>
         ,
         <code class="calibre21">
          =
         </code>
         ,
         <code class="calibre21">
          ==
         </code>
         ,
         <code class="calibre21">
          !=
         </code>
         <br class="calibre12"/>
         copy constructor
        </td>
        <td class="left1">
         Provides read-only access, forward only (no
         <code class="calibre21">
          operator--
         </code>
         to move backward).
         <br class="calibre12"/>
         Iterators can be assigned, copied, and compared for equality.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         Output (also known as Write)
        </td>
        <td class="left1">
         <code class="calibre21">
          operator++
         </code>
         ,
         <code class="calibre21">
          *
         </code>
         ,
         <code class="calibre21">
          =
         </code>
         <br class="calibre12"/>
         copy constructor
        </td>
        <td class="left1">
         Provides write-only access, forward only.
         <br class="calibre12"/>
         Iterators can be assigned, but cannot be compared for equality.
         <br class="calibre12"/>
         Specific to output iterators is that you can do
         <code class="calibre21">
          *iter = value
         </code>
         .
         <br class="calibre12"/>
         Note the absence of
         <code class="calibre21">
          operator-&gt;
         </code>
         .
         <br class="calibre12"/>
         Provides both prefix and postfix
         <code class="calibre21">
          operator++
         </code>
         .
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         Forward
        </td>
        <td class="left1">
         Capabilities of input iterators, plus default constructor
        </td>
        <td class="left1">
         Provides read access, forward only.
         <br class="calibre12"/>
         Iterators can be assigned, copied, and compared for equality.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         Bidirectional
        </td>
        <td class="left1">
         Capabilities of forward iterators, plus
         <br class="calibre12"/>
         <code class="calibre21">
          operator--
         </code>
        </td>
        <td class="left1">
         Provides everything a forward iterator provides.
         <br class="calibre12"/>
         Iterators can also move backward to a previous element.
         <br class="calibre12"/>
         Provides both prefix and postfix
         <code class="calibre21">
          operator--
         </code>
         .
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         Random access
        </td>
        <td class="left1">
         Bidirectional capability, plus the following:
         <pre class="pre" id="c17-code-0001"><code class="calibre21">operator+, -, +=, -=, &lt;,&gt;, &lt;=,&gt;=, []</code></pre>
        </td>
        <td class="left1">
         Equivalent to raw pointers: support pointer arithmetic, array index syntax, and all forms of comparison.
        </td>
       </tr>
       <tr class="calibre33">
        <td class="left1">
         Contiguous
        </td>
        <td class="left1">
         Random-access capability and logically adjacent elements of the container must be physically adjacent in memory
        </td>
        <td class="left1">
         Examples of this are iterators of
         <code class="calibre21">
          std::array, vector
         </code>
         (not
         <code class="calibre21">
          vector&lt;bool&gt;
         </code>
         ),
         <code class="calibre21">
          string
         </code>
         , and
         <code class="calibre21">
          string_view
         </code>
         .
         <span aria-label="655" class="calibre20" epub:type="pagebreak" id="Page_655" role="doc-pagebreak">
         </span>
        </td>
       </tr>
      </tbody>
     </table>
     <p class="calibre13" id="c17-para-0029">
      According to this table, there are six types of iterators: input, output, forward, bidirectional, random access, and contiguous. There is no formal class hierarchy of these iterators. However, one can deduce a hierarchy based on the functionality they are required to provide. Specifically, every contiguous iterator is also random access, every random-access iterator is also bidirectional, every bidirectional iterator is also forward, and every forward iterator is also input. Iterators that additionally satisfy the requirements for output iterators are called
      <i class="calibre18">
       mutable iterators
      </i>
      ; otherwise, they are called
      <i class="calibre18">
       constant iterators
      </i>
      .
      <a class="calibre5" href="#c17-fig-0001" id="R_c17-fig-0001">
       Figure 17.1
      </a>
      shows such hierarchy. Dotted lines are used because the figure is not a real class hierarchy.
     </p>
     <figure class="calibre36">
      <img alt="A diagram with five boxes arranged vertically. Each box has a term related to data or information processing. From top to bottom, the boxes include input, forward, bidirectional, random access, and contiguous." class="center" src="images/c17f001.png"/>
      <figcaption class="calibre37">
       <p class="calibre13">
        <span class="figurelabel">
         <a class="calibre5" href="#R_c17-fig-0001" id="c17-fig-0001" role="doc-backlink">
          <b class="calibre14">
           FIGURE 17.1
          </b>
         </a>
        </span>
       </p>
      </figcaption>
     </figure>
     <p class="calibre13">
      The standard technique for an algorithm to specify what kind of iterators it requires is to use names similar to the following for its iterator template type parameters:
      <code class="calibre21">
       InputIterator
      </code>
      ,
      <code class="calibre21">
       OutputIterator
      </code>
      ,
      <code class="calibre21">
       ForwardIterator
      </code>
      ,
      <code class="calibre21">
       BidirectionalIterator
      </code>
      ,
      <code class="calibre21">
       RandomAccessIterator
      </code>
      , and
      <code class="calibre21">
       ContiguousIterator
      </code>
      . These names are just names: they don't provide binding type checking. Therefore, you could, for example, try to call an algorithm expecting a
      <code class="calibre21">
       RandomAccessIterator
      </code>
      by passing a bidirectional iterator. The template cannot do type checking, so it would allow this instantiation. However, the code in the function that uses the random-access iterator capabilities would fail to compile on the bidirectional iterator. Thus, the requirement is enforced, just not where you would expect. The error message can therefore be somewhat confusing. For example, attempting to use the generic
      <code class="calibre21">
       sort()
      </code>
      algorithm, which requires a random-access iterator, on a
      <code class="calibre21">
       list
      </code>
      , which provides only a bidirectional iterator, can result in a cryptic error. The following is the error generated by Visual C++ 2022:
     </p>
     <pre class="calibre26" id="c17-code-0002"><code class="calibre21">…\MSVC\14.37.32705\include\algorithm(8061,45): error C2676: binary '-': 'const std::_List_unchecked_iterator&lt;std::_List_val&lt;std::_List_simple_types&lt;_Ty&gt;&gt;&gt;' does not define this operator or a conversion to a type acceptable to the predefined operator</code>
<code class="calibre21">        with</code>
<code class="calibre21">        [</code>
<code class="calibre21">            _Ty=int</code>
<code class="calibre21">        ]</code></pre>
     <p class="calibre13">
      <span aria-label="656" class="calibre20" epub:type="pagebreak" id="Page_656" role="doc-pagebreak">
      </span>
      Later in this chapter, the ranges library is introduced, which comes with range-based and constrained versions of most Standard Library algorithms. These constrained algorithms have proper type constraints (see
      <a class="calibre5" href="c12.xhtml">
       Chapter 12
      </a>
      , “Writing Generic Code with Templates”) for their template type parameters. Hence, the compiler can provide clearer error messages if you try to execute such an algorithm on a container that provides the wrong type of iterators.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c17-para-0032">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Iterators mediate between algorithms and containers. They provide a standard interface to traverse the elements of a container in sequence so that any algorithm can work on any container as long as the container provides the algorithm's required iterator category
         </i>
         .
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c17-para-0033">
      Iterators are implemented similarly to smart pointer classes in that they overload the specific desired operators. Consult
      <a class="calibre5" href="c15.xhtml">
       Chapter 15
      </a>
      , “Overloading C++ Operators,” for details on operator overloading.
     </p>
     <p class="calibre13">
      The basic iterator operations are similar to those supported by raw pointers, so a raw pointer can be a legitimate iterator for certain containers. In fact, the
      <code class="calibre21">
       vector
      </code>
      iterator could technically be implemented as a simple raw pointer. However, as a client of the containers, you need not worry about the implementation details; you can simply use the iterator abstraction.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c17-para-0035">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          Iterators might, or might not, be implemented internally as pointers, so this text uses the term
         </i>
         <b class="calibre14">
          <i class="calibre18">
           refers to
          </i>
         </b>
         <i class="calibre18">
          instead of
         </i>
         <b class="calibre14">
          <i class="calibre18">
           points to
          </i>
         </b>
         <i class="calibre18">
          when discussing the elements accessible via an iterator.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0007">
      </span>
      <h3 class="calibre27" id="head-3-384">
       Getting Iterators for Containers
      </h3>
      <p class="calibre13">
       Every data structure of the Standard Library that supports iterators provides public type aliases for its iterator types, called
       <code class="calibre21">
        iterator
       </code>
       and
       <code class="calibre21">
        const_iterator
       </code>
       . For example, a
       <code class="calibre21">
        const
       </code>
       iterator for a
       <code class="calibre21">
        vector
       </code>
       of
       <code class="calibre21">
        int
       </code>
       s has as type
       <code class="calibre21">
        std::vector&lt;int&gt;::const_iterator
       </code>
       . Containers that allow you to iterate over their elements in reverse order also provide public type aliases called
       <code class="calibre21">
        reverse_iterator
       </code>
       and
       <code class="calibre21">
        const_reverse_iterator
       </code>
       . This way, clients can use the container iterators without worrying about the actual types.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0037">
          <b class="calibre14">
           NOTE
          </b>
          <code class="calibre21">
           const_iterator
          </code>
          <i class="calibre18">
           s and
          </i>
          <code class="calibre21">
           const_reverse_iterator
          </code>
          <i class="calibre18">
           s provide read-only access to elements of a container
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c17-para-0038">
       The containers also provide a member function
       <code class="calibre21">
        begin()
       </code>
       that returns an iterator referring to the first element in the container. The
       <code class="calibre21">
        end()
       </code>
       member function returns an iterator to the “past-the-end” value
       <span aria-label="657" class="calibre20" epub:type="pagebreak" id="Page_657" role="doc-pagebreak">
       </span>
       of the sequence of elements. That is,
       <code class="calibre21">
        end()
       </code>
       returns an iterator that is equal to the result of applying
       <code class="calibre21">
        operator++
       </code>
       to an iterator referring to the last element in the sequence. Together,
       <code class="calibre21">
        begin()
       </code>
       and
       <code class="calibre21">
        end()
       </code>
       provide a
       <i class="calibre18">
        half-open range
       </i>
       that includes the first element but not the last. The reason for this apparent complication is to support empty ranges (containers without any elements), in which case
       <code class="calibre21">
        begin()
       </code>
       is equal to
       <code class="calibre21">
        end()
       </code>
       . The half-open range bounded by iterators
       <code class="calibre21">
        begin()
       </code>
       and
       <code class="calibre21">
        end()
       </code>
       is often written mathematically like this: [begin, end).
      </p>
      <p class="calibre13">
       Additionally, the following member functions are available:
      </p>
      <ul class="check" id="c17-list-0002">
       <li class="calibre9" id="c17-li-0005">
        <code class="calibre21">
         cbegin()
        </code>
        and
        <code class="calibre21">
         cend()
        </code>
        returning
        <code class="calibre21">
         const
        </code>
        iterators
       </li>
       <li class="calibre9" id="c17-li-0006">
        <code class="calibre21">
         rbegin()
        </code>
        and
        <code class="calibre21">
         rend()
        </code>
        returning reverse iterators
       </li>
       <li class="calibre9" id="c17-li-0007">
        <code class="calibre21">
         crbegin()
        </code>
        and
        <code class="calibre21">
         crend()
        </code>
        returning
        <code class="calibre21">
         const
        </code>
        reverse iterators
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0040">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           A sequence specified by two iterators is called a
          </i>
          <b class="calibre14">
           <i class="calibre18">
            common range
           </i>
          </b>
          <i class="calibre18">
           to disambiguate it from ranges defined by the ranges library, discussed later in this chapter.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c17-para-0041">
       <code class="calibre21">
        &lt;iterator&gt;
       </code>
       also provides the following global nonmember functions to retrieve specific iterators for a container:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          FUNCTION NAME
         </th>
         <th class="left" scope="col">
          FUNCTION SYNOPSIS
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           begin()
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           end()
          </code>
         </td>
         <td class="left1">
          Returns a non-
          <code class="calibre21">
           const
          </code>
          iterator to the first, and one past the last, element in a sequence
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           cbegin()
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           cend()
          </code>
         </td>
         <td class="left1">
          Returns a
          <code class="calibre21">
           const
          </code>
          iterator to the first, and one past the last, element in a sequence
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           rbegin()
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           rend()
          </code>
         </td>
         <td class="left1">
          Returns a non-
          <code class="calibre21">
           const
          </code>
          reverse iterator to the last, and one before the first, element in a sequence
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           crbegin()
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           crend()
          </code>
         </td>
         <td class="left1">
          Returns a
          <code class="calibre21">
           const
          </code>
          reverse iterator to the last, and one before the first, element in a sequence
         </td>
        </tr>
       </tbody>
      </table>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0052">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           It's recommended to use these nonmember functions instead of the member versions
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       These nonmember functions are defined in the
       <code class="calibre21">
        std
       </code>
       namespace; however, especially when writing generic code for class and function templates, it is recommended to use these non-member functions as follows:
      </p>
      <pre class="calibre26" id="c17-code-0003"><code class="calibre21">using std::begin;</code>
<code class="calibre21">begin(…);</code></pre>
      <p class="calibre13">
       <span aria-label="658" class="calibre20" epub:type="pagebreak" id="Page_658" role="doc-pagebreak">
       </span>
       Note that
       <code class="calibre21">
        begin()
       </code>
       is called without any namespace qualification, as this enables
       <i class="calibre18">
        argument-dependent lookups
       </i>
       (ADL).
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0055">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           ADL allows you to call unqualified functions. The compiler tries to find those functions first in the namespace of the arguments passed to them. If not found there, the usual name lookup rules apply
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c17-para-0056">
       When you specialize one of these nonmember functions for your own types, you can either put those specializations in the
       <code class="calibre21">
        std
       </code>
       namespace or put them in the same namespace as the type for which you are specializing them. The latter is recommended as this enables ADL. Thanks to ADL, you can then call your specialization without having to qualify it with any namespace, because the compiler is able to find the correct specialization in your namespace based on the types of arguments passed to the specialized function template.
      </p>
      <p class="calibre13" id="c17-para-0057">
       By combining ADL (calling
       <code class="calibre21">
        begin(…
       </code>
       ) without any namespace qualification) with the
       <code class="calibre21">
        using std::begin
       </code>
       declaration, the compiler first looks up the right overload in the namespace of the type of its argument using ADL. If the compiler cannot find an overload using ADL, it tries to find an appropriate overload in the
       <code class="calibre21">
        std
       </code>
       namespace due to the
       <code class="calibre21">
        using
       </code>
       declaration. Just calling
       <code class="calibre21">
        begin()
       </code>
       without the
       <code class="calibre21">
        using
       </code>
       declaration would only call user-defined overloads through ADL, and just calling
       <code class="calibre21">
        std::begin()
       </code>
       would only look in the
       <code class="calibre21">
        std
       </code>
       namespace.
      </p>
      <p class="calibre13">
       Of course, ADL is not limited to the functions discussed in this section but can be used with any function.
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0059">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Normally it is not allowed to add anything to the
          </i>
          <code class="calibre21">
           std
          </code>
          <i class="calibre18">
           namespace; however, it is legal to put specializations of Standard Library templates in the
          </i>
          <code class="calibre21">
           std
          </code>
          <i class="calibre18">
           namespace.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0013">
      </span>
      <h3 class="calibre27" id="head-3-385">
       Iterator Traits
      </h3>
      <p class="calibre13" id="c17-para-0060">
       Some algorithm implementations need additional information about their iterators. For example, they might need to know the type of the elements referred to by the iterator to store temporary values, or perhaps they want to know whether the iterator is bidirectional or random access.
      </p>
      <p class="calibre13">
       C++ provides a class template called
       <code class="calibre21">
        iterator_traits
       </code>
       , defined in
       <code class="calibre21">
        &lt;iterator&gt;
       </code>
       , that allows you to retrieve this information. You instantiate the
       <code class="calibre21">
        iterator_traits
       </code>
       class template with the iterator type of interest, and access one of five type aliases:
      </p>
      <ul class="check" id="c17-list-0003">
       <li class="calibre9" id="c17-li-0008">
        value_type: The type of elements referred to
       </li>
       <li class="calibre9" id="c17-li-0009">
        difference:type: A type capable of representing the distance, i.e., number of elements, between two iterators
       </li>
       <li class="calibre9" id="c17-li-0010">
        iterator_category: The type of iterator:
        <code class="calibre21">
         input_iterator_tag
        </code>
        ,
        <code class="calibre21">
         output_iterator_tag
        </code>
        ,
        <code class="calibre21">
         forward_iterator_tag
        </code>
        ,
        <code class="calibre21">
         bidirectional_iterator_tag
        </code>
        ,
        <code class="calibre21">
         random_access_iterator_tag
        </code>
        , or
        <code class="calibre21">
         contiguous_iterator_tag
        </code>
       </li>
       <li class="calibre9" id="c17-li-0011">
        <span aria-label="659" class="calibre20" epub:type="pagebreak" id="Page_659" role="doc-pagebreak">
        </span>
        pointer: The type of a pointer to an element
       </li>
       <li class="calibre9" id="c17-li-0012">
        reference: The type of a reference to an element
       </li>
      </ul>
      <p class="calibre13">
       For example, the following function template declares a temporary variable of the type that an iterator of type
       <code class="calibre21">
        IteratorType
       </code>
       refers to. Note the use of the
       <code class="calibre21">
        typename
       </code>
       keyword in front of
       <code class="calibre21">
        iterator_traits
       </code>
       . You must specify
       <code class="calibre21">
        typename
       </code>
       explicitly whenever you access a type based on one or more template type parameters. In this case, the template type parameter
       <code class="calibre21">
        IteratorType
       </code>
       is used to access the
       <code class="calibre21">
        value_type
       </code>
       type of
       <code class="calibre21">
        iterator_traits
       </code>
       .
      </p>
      <pre class="calibre26" id="c17-code-0004"><code class="calibre21">template &lt;typename IteratorType&gt;</code>
<code class="calibre21">void iteratorTraitsTest(IteratorType it)</code>
<code class="calibre21">{</code>
<code class="calibre21">   typename iterator_traits&lt;IteratorType&gt;::value_type temp;</code>
<code class="calibre21">   temp = *it;</code>
<code class="calibre21">   println("{}", temp);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This function can be tested with the following code:
      </p>
      <pre class="calibre26" id="c17-code-0005"><code class="calibre21">vector v { 5 };</code>
<code class="calibre21">iteratorTraitsTest(cbegin(v));</code></pre>
      <p class="calibre13" id="c17-para-0064">
       With this code, the variable
       <code class="calibre21">
        temp
       </code>
       in
       <code class="calibre21">
        iteratorTraitsTest()
       </code>
       is of type
       <code class="calibre21">
        int
       </code>
       . The output is
       <code class="calibre21">
        5
       </code>
       .
      </p>
      <p class="calibre13" id="c17-para-0065">
       Of course, the
       <code class="calibre21">
        auto
       </code>
       keyword could be used in this example to simplify the code, but that wouldn't show you how to use
       <code class="calibre21">
        iterator_traits
       </code>
       .
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0014">
      </span>
      <h3 class="calibre27" id="head-3-386">
       Examples
      </h3>
      <p class="calibre13">
       The following example simply uses a
       <code class="calibre21">
        for
       </code>
       loop and iterators to iterate over every element in a
       <code class="calibre21">
        vector
       </code>
       and prints them to standard output:
      </p>
      <pre class="calibre26" id="c17-code-0006"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">for (auto iter { cbegin(values) }; iter != cend(values); ++iter) {</code>
<code class="calibre21">    print("{} ", *iter);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c17-para-0067">
       You might be tempted to test for the end of a common range using
       <code class="calibre21">
        operator&lt;
       </code>
       , as in
       <code class="calibre21">
        iter&lt;cend(values)
       </code>
       . That is not recommended, however. The canonical way to test for the end of a range is to use
       <code class="calibre21">
        !=
       </code>
       , as in
       <code class="calibre21">
        iter!=cend(values)
       </code>
       . The reason is that the
       <code class="calibre21">
        !=
       </code>
       operator works on all types of iterators, while the
       <code class="calibre21">
        &lt;
       </code>
       operator is not supported by bidirectional and forward iterators.
      </p>
      <p class="calibre13">
       A helper function can be implemented that accepts a common range of elements given as a begin and end iterator and prints all elements in that range to standard output. The
       <code class="calibre21">
        input_iterator
       </code>
       concept is used to constrain the template type parameter to input iterators.
      </p>
      <pre class="calibre26" id="c17-code-0007"><code class="calibre21">template &lt;input_iterator Iter&gt;</code>
<code class="calibre21">void myPrint(Iter begin, Iter end)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter) { print("{} ", *iter); }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This helper function can be used as follows:
      </p>
      <pre class="calibre26" id="c17-code-0008"><code class="calibre21">myPrint(cbegin(values), cend(values));</code></pre>
      <p class="calibre13">
       <span aria-label="660" class="calibre20" epub:type="pagebreak" id="Page_660" role="doc-pagebreak">
       </span>
       A second example is a
       <code class="calibre21">
        myFind()
       </code>
       function template that finds a given value in a given common range. If the value is not found, the end iterator of the range is returned. Note the special type of the
       <code class="calibre21">
        value
       </code>
       parameter. It uses
       <code class="calibre21">
        iterator_traits
       </code>
       to get the type of the values to which the given iterators point to.
      </p>
      <pre class="calibre26" id="c17-code-0009"><code class="calibre21">template &lt;input_iterator Iter&gt;</code>
<code class="calibre21">auto myFind(Iter begin, Iter end,</code>
<code class="calibre21">    const typename iterator_traits&lt;Iter&gt;::value_type&amp; value)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter) {</code>
<code class="calibre21">        if (*iter == value) { return iter; }</code>
<code class="calibre21">    }</code>
<code class="calibre21">    return end;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This function template can be used as follows. The
       <code class="calibre21">
        std::distance()
       </code>
       function is used to compute the distance between two iterators of a container.
      </p>
      <pre class="calibre26" id="c17-code-0010"><code class="calibre21">vector values { 11, 22, 33, 44 };</code>
<code class="calibre21">auto result { myFind(cbegin(values), cend(values), 22) };</code>
<code class="calibre21">if (result != cend(values)) {</code>
<code class="calibre21">    println("Found value at position {}", distance(cbegin(values), result));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c17-para-0072">
       More examples of using iterators are given throughout this and subsequent chapters.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0015">
      </span>
      <h3 class="calibre27" id="head-3-387">
       Function Dispatching Using Iterator Traits
      </h3>
      <p class="calibre13">
       The Standard Library provides the
       <code class="calibre21">
        std::advance(iter, n)
       </code>
       function to advance a given iterator,
       <code class="calibre21">
        iter
       </code>
       , by
       <code class="calibre21">
        n
       </code>
       positions. This function works on all types of iterators. For random-access iterators, it simply does
       <code class="calibre21">
        iter += n
       </code>
       . For other iterators, it does
       <code class="calibre21">
        ++iter
       </code>
       or
       <code class="calibre21">
        --iter
       </code>
       in a loop
       <code class="calibre21">
        n
       </code>
       times, depending on whether
       <code class="calibre21">
        n
       </code>
       is positive or negative. You might wonder how such behavior is implemented. It can be implemented using
       <i class="calibre18">
        function dispatching
       </i>
       . Based on the iterator category, the request is dispatched to a specific helper function. Here's a simplified implementation of our own
       <code class="calibre21">
        myAdvance(iter, n)
       </code>
       function demonstrating such function dispatching:
      </p>
      <pre class="calibre26" id="c17-code-0011"><code class="calibre21">template &lt;typename Iter, typename Distance&gt;</code>
<code class="calibre21">void advanceHelper(Iter&amp; iter, Distance n, <b class="calibre14">input_iterator_tag</b>)</code>
<code class="calibre21">{</code>
<code class="calibre21">    while (n &gt; 0) { ++iter; --n; }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename Iter, typename Distance&gt;</code>
<code class="calibre21">void advanceHelper(Iter&amp; iter, Distance n, <b class="calibre14">bidirectional_iterator_tag</b>)</code>
<code class="calibre21">{</code>
<code class="calibre21">    while (n &gt; 0) { ++iter; --n; }</code>
<code class="calibre21">    while (n &lt; 0) { --iter; ++n; }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;typename Iter, typename Distance&gt;</code>
<code class="calibre21">void advanceHelper(Iter&amp; iter, Distance n, <b class="calibre14">random_access_iterator_tag</b>)</code>
<code class="calibre21">{</code>
<code class="calibre21">    iter += n;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<span aria-label="661" class="calibre20" epub:type="pagebreak" id="Page_661" role="doc-pagebreak"></span><code class="calibre21">template &lt;typename Iter, typename Distance&gt;</code>
<code class="calibre21">void myAdvance(Iter&amp; iter, Distance n)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">using category = typename iterator_traits&lt;Iter&gt;::iterator_category;</b></code>
<code class="calibre21">    advanceHelper(iter, n, <b class="calibre14">category {}</b>);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       This implementation of
       <code class="calibre21">
        myAdvance()
       </code>
       can be used on random-access iterators from
       <code class="calibre21">
        vector
       </code>
       s, on bidirectional iterators from
       <code class="calibre21">
        list
       </code>
       s, and so on:
      </p>
      <pre class="calibre26" id="c17-code-0012"><code class="calibre21">template &lt;typename Iter&gt;</code>
<code class="calibre21">void testAdvance(Iter iter)</code>
<code class="calibre21">{</code>
<code class="calibre21">    print("*iter = {} | ", *iter);</code>
<code class="calibre21">    myAdvance(iter, 3); print("3 ahead = {} | ", *iter);</code>
<code class="calibre21">    myAdvance(iter, -2); println("2 back = {}", *iter);</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector vec { 1, 2, 3, 4, 5, 6 };  testAdvance(begin(vec));</code>
<code class="calibre21">    list lst { 1, 2, 3, 4, 5, 6 };    testAdvance(begin(lst));</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c17-code-0013"><code class="calibre21">*iter = 1 | 3 ahead = 4 | 2 back = 2</code>
<code class="calibre21">*iter = 1 | 3 ahead = 4 | 2 back = 2</code></pre>
      <p class="calibre13">
       With concepts (see
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       ), the
       <code class="calibre21">
        myAdvance()
       </code>
       implementation can be simplified. Instead of using helper functions, you can just provide
       <code class="calibre21">
        myAdvance()
       </code>
       overloads with appropriate constraints:
      </p>
      <pre class="calibre26" id="c17-code-0014"><code class="calibre21">template &lt;<b class="calibre14">input_iterator</b> Iter, typename Distance&gt;</code>
<code class="calibre21">void <b class="calibre14">myAdvance</b>(Iter&amp; iter, Distance n)</code>
<code class="calibre21">{</code>
<code class="calibre21">    while (n &gt; 0) { ++iter; --n; }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;<b class="calibre14">bidirectional_iterator</b> Iter, typename Distance&gt;</code>
<code class="calibre21">void <b class="calibre14">myAdvance</b>(Iter&amp; iter, Distance n)</code>
<code class="calibre21">{</code>
<code class="calibre21">    while (n &gt; 0) { ++iter; --n; }</code>
<code class="calibre21">    while (n &lt; 0) { --iter; ++n; }</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">template &lt;<b class="calibre14">random_access_iterator</b> Iter, typename Distance&gt;</code>
<code class="calibre21">void <b class="calibre14">myAdvance</b>(Iter&amp; iter, Distance n)</code>
<code class="calibre21">{</code>
<code class="calibre21">    iter += n;</code>
<code class="calibre21">}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-191" class="calibre2">
     <span class="calibre" id="c17-sec-0016">
     </span>
     <h2 class="calibre6" id="head-2-191">
      STREAM ITERATORS
     </h2>
     <p class="calibre13">
      The Standard Library provides four
      <i class="calibre18">
       stream iterators
      </i>
      . These are iterator-like class templates that allow you to treat input and output streams as input and output iterators. Using these stream iterators, you
      <span aria-label="662" class="calibre20" epub:type="pagebreak" id="Page_662" role="doc-pagebreak">
      </span>
      can adapt input and output streams so that they can serve as sources and destinations, respectively, for various Standard Library algorithms. The following stream iterators are available:
     </p>
     <ul class="check" id="c17-list-0004">
      <li class="calibre9" id="c17-li-0013">
       <code class="calibre21">
        ostream_iterator
       </code>
       : Output iterator writing to a
       <code class="calibre21">
        basic_ostream
       </code>
      </li>
      <li class="calibre9" id="c17-li-0014">
       <code class="calibre21">
        istream_iterator
       </code>
       : Input iterator reading from a
       <code class="calibre21">
        basic_istream
       </code>
      </li>
      <li class="calibre9" id="c17-li-0015">
       <code class="calibre21">
        ostreambuf_iterator
       </code>
       : Output iterator writing to a
       <code class="calibre21">
        basic_streambuf
       </code>
      </li>
      <li class="calibre9" id="c17-li-0016">
       <code class="calibre21">
        istreambuf_iterator
       </code>
       : Input iterator reading from a
       <code class="calibre21">
        basic_streambuf
       </code>
      </li>
     </ul>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0017">
      </span>
      <h3 class="calibre27" id="head-3-388">
       Output Stream Iterator: ostream_iterator
      </h3>
      <p class="calibre13" id="c17-para-0078">
       <code class="calibre21">
        ostream_iterator
       </code>
       is an
       <i class="calibre18">
        output stream iterator
       </i>
       . It is a class template that takes the element type as a template type parameter. The constructor takes an output stream and a delimiter string to write to the stream following each element. The
       <code class="calibre21">
        ostream_iterator
       </code>
       class writes elements using
       <code class="calibre21">
        operator&lt;&lt;
       </code>
       .
      </p>
      <p class="calibre13">
       Let's look at an example. Suppose you have the following
       <code class="calibre21">
        myCopy()
       </code>
       function template that copies a common range given as a begin and end iterator to a target range given as a begin iterator. The second template type parameter is constrained to be an output iterator that accepts values of type
       <code class="calibre21">
        std::iter_reference:t&lt;InputIter&gt;
       </code>
       which is the type of the values referred to by the given
       <code class="calibre21">
        InputIter
       </code>
       .
      </p>
      <pre class="calibre26" id="c17-code-0015"><code class="calibre21">template &lt;input_iterator InputIter,</code>
<code class="calibre21">    output_iterator&lt;iter_reference:t&lt;InputIter&gt;&gt; OutputIter&gt;</code>
<code class="calibre21">void myCopy(InputIter begin, InputIter end, OutputIter target)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (auto iter { begin }; iter != end; ++iter, ++target) { *target = *iter; }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The first two parameters of
       <code class="calibre21">
        myCopy()
       </code>
       are the begin and end iterator of the range to copy, and the third parameter is an iterator to the destination range. You have to make sure the destination range is big enough to hold all the elements from the source range. Using the
       <code class="calibre21">
        myCopy()
       </code>
       function template to copy the elements of one
       <code class="calibre21">
        vector
       </code>
       to another one is straightforward.
      </p>
      <pre class="calibre26" id="c17-code-0016"><code class="calibre21">vector myVector { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21"><span class="color">// Use myCopy() to copy myVector to vectorCopy.</span></code>
<code class="calibre21">vector&lt;int&gt; vectorCopy(myVector.size());</code>
<code class="calibre21"><b class="calibre14">myCopy(cbegin(myVector), cend(myVector), begin(vectorCopy));</b></code></pre>
      <p class="calibre13">
       Now, by using an
       <code class="calibre21">
        ostream_iterator
       </code>
       , the
       <code class="calibre21">
        myCopy()
       </code>
       function template can also be used to print elements of a container with just a single line of code. The following code snippet prints the contents of
       <code class="calibre21">
        myVector
       </code>
       and
       <code class="calibre21">
        vectorCopy
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0017"><code class="calibre21"><span class="color">// Use the same myCopy() to print the contents of both vectors.</span></code>
<code class="calibre21">myCopy(cbegin(myVector), cend(myVector), <b class="calibre14">ostream_iterator&lt;int&gt; { cout, " " }</b>);</code>
<code class="calibre21">println("");</code>
<code class="calibre21">myCopy(cbegin(vectorCopy), cend(vectorCopy), <b class="calibre14">ostream_iterator&lt;int&gt; { cout, " " }</b>);</code>
<code class="calibre21">println("");</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c17-code-0018"><code class="calibre21">1 2 3 4 5 6 7 8 9 10</code>
<code class="calibre21">1 2 3 4 5 6 7 8 9 10</code></pre>
     </section>
     <span aria-label="663" class="calibre20" epub:type="pagebreak" id="Page_663" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0018">
      </span>
      <h3 class="calibre27" id="head-3-389">
       Input Stream Iterator: istream_iterator
      </h3>
      <p class="calibre13" id="c17-para-0083">
       You can use the
       <i class="calibre18">
        input stream iterator
       </i>
       ,
       <code class="calibre21">
        istream_iterator
       </code>
       , to read values from an input stream using the iterator abstraction. It is a class template that takes the element type as a template type parameter. Its constructor takes an input stream as a parameter. Elements are read using
       <code class="calibre21">
        operator&gt;&gt;
       </code>
       . You can use an
       <code class="calibre21">
        istream_iterator
       </code>
       as a source for algorithms and container member functions.
      </p>
      <p class="calibre13">
       Suppose you have the following
       <code class="calibre21">
        sum()
       </code>
       function template that calculates the sum of all the elements in a given common range:
      </p>
      <pre class="calibre26" id="c17-code-0019"><code class="calibre21">template &lt;input_iterator InputIter&gt;</code>
<code class="calibre21">auto sum(InputIter begin, InputIter end)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto sum { *begin };</code>
<code class="calibre21">    for (auto iter { ++begin }; iter != end; ++iter) { sum += *iter; }</code>
<code class="calibre21">    return sum;</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Now, an
       <code class="calibre21">
        istream_iterator
       </code>
       can be used to read integers from the console until the end of the stream is reached. On Windows, this happens when you press Ctrl+Z followed by Enter, while on Linux you press Enter followed by Ctrl+D. The
       <code class="calibre21">
        sum()
       </code>
       function is used to calculate the sum of all the integers. A default constructed
       <code class="calibre21">
        istream_iterator
       </code>
       represents the end iterator.
      </p>
      <pre class="calibre26" id="c17-code-0020"><code class="calibre21">println("Enter numbers separated by whitespace.");</code>
<code class="calibre21">println("Press Ctrl+Z followed by Enter to stop.");</code>
<code class="calibre21"><b class="calibre14">istream_iterator&lt;int&gt; numbersIter { cin };</b></code>
<code class="calibre21"><b class="calibre14">istream_iterator&lt;int&gt; endIter;</b></code>
<code class="calibre21"><b class="calibre14">int result { sum(numbersIter, endIter) };</b></code>
<code class="calibre21">println("Sum: {}", result);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0019">
      </span>
      <h3 class="calibre27" id="head-3-390">
       Input Stream Iterator: istreambuf_iterator
      </h3>
      <p class="calibre13">
       One use case of the
       <code class="calibre21">
        istreambuf_iterator
       </code>
       input stream iterator is to easily read the contents of an entire file with a single statement. A default constructed
       <code class="calibre21">
        istreambuf_iterator
       </code>
       represents the end iterator. Here is an example:
      </p>
      <pre class="calibre26" id="c17-code-0021"><code class="calibre21">ifstream inputFile { "some_data.txt" };</code>
<code class="calibre21">if (inputFile.fail()) {</code>
<code class="calibre21">    println(cerr, "Unable to open file for reading.");</code>
<code class="calibre21">    return 1;</code>
<code class="calibre21">}</code>
<code class="calibre21">string fileContents {</code>
<code class="calibre21">    <b class="calibre14">istreambuf_iterator&lt;char&gt; { inputFile },</b></code>
<code class="calibre21">    <b class="calibre14">istreambuf_iterator&lt;char&gt; { }</b></code>
<code class="calibre21">};</code>
<code class="calibre21">println("{}", fileContents);</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-192" class="calibre2">
     <span class="calibre" id="c17-sec-0020">
     </span>
     <h2 class="calibre6" id="head-2-192">
      ITERATOR ADAPTERS
     </h2>
     <p class="calibre13">
      The Standard Library provides a number of
      <i class="calibre18">
       iterator adapters
      </i>
      , which are special iterators, all defined in
      <code class="calibre21">
       &lt;iterator&gt;
      </code>
      . They are split into two groups. The first group of adapters are created from a container and are usually used as output iterators:
      <span aria-label="664" class="calibre20" epub:type="pagebreak" id="Page_664" role="doc-pagebreak">
      </span>
     </p>
     <ul class="check" id="c17-list-0005">
      <li class="calibre9" id="c17-li-0017">
       back_insert_iterator: Uses
       <code class="calibre21">
        push_back()
       </code>
       to insert elements into a container
      </li>
      <li class="calibre9" id="c17-li-0018">
       front_insert_iterator: Uses
       <code class="calibre21">
        push_front()
       </code>
       to insert elements into a container
      </li>
      <li class="calibre9" id="c17-li-0019">
       insert_iterator: Uses
       <code class="calibre21">
        insert()
       </code>
       to insert elements into a container
      </li>
     </ul>
     <p class="calibre13">
      Other adapters are created from another iterator, not a container, and are usually used as input iterators. Two common adapters are:
     </p>
     <ul class="check" id="c17-list-0006">
      <li class="calibre9" id="c17-li-0020">
       reverse_iterator: Reverse the iteration order of another iterator.
      </li>
      <li class="calibre9" id="c17-li-0021">
       move_iterator: The dereferencing operator for a
       <code class="calibre21">
        move_iterator
       </code>
       automatically converts the value to an rvalue reference, so it can be moved to a new destination.
      </li>
     </ul>
     <p class="calibre13" id="c17-para-0089">
      It's also possible to write your own iterator adapters, but this is not covered in this book. Consult one of the Standard Library references listed in
      <a class="calibre5" href="b02.xhtml">
       Appendix B
      </a>
      , “Annotated Bibliography,” for details.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0021">
      </span>
      <h3 class="calibre27" id="head-3-391">
       Insert Iterators
      </h3>
      <p class="calibre13" id="c17-para-0090">
       The
       <code class="calibre21">
        myCopy()
       </code>
       function template as implemented earlier in this chapter does not insert elements into a container; it simply replaces old elements in a range with new ones. To make such algorithms more useful, the Standard Library provides three
       <i class="calibre18">
        insert iterator adapters
       </i>
       that really insert elements into a container:
       <code class="calibre21">
        insert_iterator
       </code>
       ,
       <code class="calibre21">
        back_insert_iterator
       </code>
       , and
       <code class="calibre21">
        front_insert_iterator
       </code>
       . They are all parametrized on a container type and take an actual container reference in their constructor. Because they supply the necessary iterator interfaces, these adapters can be used as the destination iterators for algorithms like
       <code class="calibre21">
        myCopy()
       </code>
       . However, instead of replacing elements in the container, they make calls on their container to actually insert new elements.
      </p>
      <p class="calibre13" id="c17-para-0091">
       The basic
       <code class="calibre21">
        insert_iterator
       </code>
       calls
       <code class="calibre21">
        insert(position,element)
       </code>
       on the container,
       <code class="calibre21">
        back_insert_iterator
       </code>
       calls
       <code class="calibre21">
        push_back(element)
       </code>
       , and
       <code class="calibre21">
        front_insert_iterator
       </code>
       calls
       <code class="calibre21">
        push_front(element)
       </code>
       .
      </p>
      <p class="calibre13">
       The following example uses a
       <code class="calibre21">
        back_insert_iterator
       </code>
       with
       <code class="calibre21">
        myCopy()
       </code>
       to populate
       <code class="calibre21">
        vectorTwo
       </code>
       with copies of all elements from
       <code class="calibre21">
        vectorOne
       </code>
       . Note that
       <code class="calibre21">
        vectorTwo
       </code>
       is not first resized to have enough elements, the insert iterator takes care of properly inserting new elements.
      </p>
      <pre class="calibre26" id="c17-code-0022"><code class="calibre21">vector vectorOne { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">vector&lt;int&gt; vectorTwo;</code>
<code class="calibre21"> </code>
<code class="calibre21">back_insert_iterator&lt;vector&lt;int&gt;&gt; inserter { vectorTwo };</code>
<code class="calibre21">myCopy(cbegin(vectorOne), cend(vectorOne), inserter);</code>
<code class="calibre21"> </code>
<code class="calibre21">println("{:n}", vectorTwo);</code></pre>
      <p class="calibre13" id="c17-para-0093">
       As you can see, when you use insert iterators, you don't need to size the destination containers ahead of time.
      </p>
      <p class="calibre13">
       You can also use the
       <code class="calibre21">
        std::back_inserter()
       </code>
       utility function to create a
       <code class="calibre21">
        back_insert_iterator
       </code>
       . In the previous example, you can remove the line that defines the
       <code class="calibre21">
        inserter
       </code>
       variable and rewrite the
       <code class="calibre21">
        myCopy()
       </code>
       call as follows. The result remains the same.
      </p>
      <pre class="calibre26" id="c17-code-0023"><code class="calibre21">myCopy(cbegin(vectorOne), cend(vectorOne), back_inserter(vectorTwo));</code></pre>
      <p class="calibre13">
       <span aria-label="665" class="calibre20" epub:type="pagebreak" id="Page_665" role="doc-pagebreak">
       </span>
       With class template argument deduction (CTAD), this can also be written as follows:
      </p>
      <pre class="calibre26" id="c17-code-0024"><code class="calibre21">myCopy(cbegin(vectorOne), cend(vectorOne), back_insert_iterator { vectorTwo });</code></pre>
      <p class="calibre13" id="c17-para-0096">
       The
       <code class="calibre21">
        front_insert_iterator
       </code>
       and
       <code class="calibre21">
        insert_iterator
       </code>
       work similarly, except that the
       <code class="calibre21">
        insert_iterator
       </code>
       also takes an initial iterator position in its constructor, which it passes to the first call to
       <code class="calibre21">
        insert(position,element)
       </code>
       . Subsequent iterator position hints are generated based on the return value from each
       <code class="calibre21">
        insert()
       </code>
       call.
      </p>
      <p class="calibre13" id="c17-para-0097">
       One benefit of using an
       <code class="calibre21">
        insert_iterator
       </code>
       is that it allows you to use associative containers as destinations of modifying algorithms.
       <a class="calibre5" href="c20.xhtml">
        Chapter 20
       </a>
       , “Mastering Standard Library Algorithms,” explains that the problem with associative containers is that you are not allowed to modify the keys over which you iterate. By using an
       <code class="calibre21">
        insert_iterator
       </code>
       , you insert elements instead of modifying existing ones. Associative containers have an
       <code class="calibre21">
        insert()
       </code>
       member function that takes an iterator position and can use the position as a “hint,” which they can ignore. When you use an
       <code class="calibre21">
        insert_iterator
       </code>
       on an associative container, you can pass the
       <code class="calibre21">
        begin()
       </code>
       or
       <code class="calibre21">
        end()
       </code>
       iterator of the container as the hint. The
       <code class="calibre21">
        insert_iterator
       </code>
       modifies the iterator hint that it passes to
       <code class="calibre21">
        insert()
       </code>
       after each call to
       <code class="calibre21">
        insert()
       </code>
       , such that the position is one past the just-inserted element.
      </p>
      <p class="calibre13">
       Here is the previous example modified so that the destination container is a
       <code class="calibre21">
        set
       </code>
       instead of a
       <code class="calibre21">
        vector
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0025"><code class="calibre21">vector vectorOne { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21"><b class="calibre14">set&lt;int&gt; setOne;</b></code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">insert_iterator&lt;set&lt;int&gt;&gt; inserter { setOne, begin(setOne) };</b></code>
<code class="calibre21">myCopy(cbegin(vectorOne), cend(vectorOne), inserter);</code>
<code class="calibre21"> </code>
<code class="calibre21"><b class="calibre14">println("{:n}", setOne);</b></code></pre>
      <p class="calibre13">
       Similar to the
       <code class="calibre21">
        back_insert_iterator
       </code>
       example, you can use the
       <code class="calibre21">
        std::inserter()
       </code>
       utility function to create an
       <code class="calibre21">
        insert_iterator
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0026"><code class="calibre21">myCopy(cbegin(vectorOne), cend(vectorOne), inserter(setOne, begin(setOne)));</code></pre>
      <p class="calibre13">
       Or, use class template argument deduction:
      </p>
      <pre class="calibre26" id="c17-code-0027"><code class="calibre21">myCopy(cbegin(vectorOne), cend(vectorOne),</code>
<code class="calibre21">    insert_iterator { setOne, begin(setOne) });</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0022">
      </span>
      <h3 class="calibre27" id="head-3-392">
       Reverse Iterators
      </h3>
      <p class="calibre13">
       The Standard Library provides an
       <code class="calibre21">
        std::reverse_iterator
       </code>
       class template that iterates through a bidirectional or random-access iterator in a reverse direction. Every reversible container in the Standard Library, which happens to be every container that's part of the standard except
       <code class="calibre21">
        forward_list
       </code>
       and the unordered associative containers, supplies a
       <code class="calibre21">
        reverse_iterator
       </code>
       type alias and member functions called
       <code class="calibre21">
        rbegin()
       </code>
       and
       <code class="calibre21">
        rend()
       </code>
       . These
       <code class="calibre21">
        reverse_iterator
       </code>
       type aliases are of type
       <code class="calibre21">
        std::reverse_iterator&lt;T&gt;
       </code>
       with
       <code class="calibre21">
        T
       </code>
       equal to the
       <code class="calibre21">
        iterator
       </code>
       type alias of the container. The member function
       <code class="calibre21">
        rbegin()
       </code>
       returns a
       <code class="calibre21">
        reverse_iterator
       </code>
       pointing to the last element of the container, and
       <code class="calibre21">
        rend()
       </code>
       returns a
       <code class="calibre21">
        reverse_iterator
       </code>
       pointing to the element before the first element of
       <span aria-label="666" class="calibre20" epub:type="pagebreak" id="Page_666" role="doc-pagebreak">
       </span>
       the container. Applying
       <code class="calibre21">
        operator++
       </code>
       to a
       <code class="calibre21">
        reverse_iterator
       </code>
       calls
       <code class="calibre21">
        operator--
       </code>
       on the underlying container iterator, and vice versa. For example, iterating over a collection from the beginning to the end can be done as follows:
      </p>
      <pre class="calibre26" id="c17-code-0028"><code class="calibre21">for (auto iter { begin(collection) }; iter != end(collection); ++iter) {}</code></pre>
      <p class="calibre13">
       Iterating over the elements in the collection from the end to the beginning can be done using a
       <code class="calibre21">
        reverse_iterator
       </code>
       by calling
       <code class="calibre21">
        rbegin()
       </code>
       and
       <code class="calibre21">
        rend()
       </code>
       . Note that you still call
       <code class="calibre21">
        ++iter
       </code>
       .
      </p>
      <pre class="calibre26" id="c17-code-0029"><code class="calibre21">for (auto iter { rbegin(collection) }; iter != rend(collection); ++iter) {}</code></pre>
      <p class="calibre13" id="c17-para-0103">
       An
       <code class="calibre21">
        std::reverse_iterator
       </code>
       is useful mostly with algorithms in the Standard Library or your own functions that have no equivalents that work in reverse order. The
       <code class="calibre21">
        myFind()
       </code>
       function introduced earlier in this chapter searches for the first element in a sequence. If you want to find the last element in the sequence, you can use a
       <code class="calibre21">
        reverse_iterator
       </code>
       . Note that when you call an algorithm such as
       <code class="calibre21">
        myFind()
       </code>
       with a
       <code class="calibre21">
        reverse_iterator
       </code>
       , it returns a
       <code class="calibre21">
        reverse_iterator
       </code>
       as well. You can always obtain the underlying
       <code class="calibre21">
        iterator
       </code>
       from a
       <code class="calibre21">
        reverse_iterator
       </code>
       by calling its
       <code class="calibre21">
        base()
       </code>
       member function. However, because of how
       <code class="calibre21">
        reverse_iterator
       </code>
       is implemented, the
       <code class="calibre21">
        iterator
       </code>
       returned from
       <code class="calibre21">
        base()
       </code>
       always refers to one element past the element referred to by the
       <code class="calibre21">
        reverse_iterator
       </code>
       on which it's called. To get to the same element, you must subtract one.
      </p>
      <p class="calibre13">
       Here is an example of
       <code class="calibre21">
        myFind()
       </code>
       with a
       <code class="calibre21">
        reverse_iterator
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0030"><code class="calibre21">vector myVector { 11, 22, 33, 22, 11 };</code>
<code class="calibre21"><b class="calibre14">auto it1 { myFind(begin(myVector), end(myVector), 22) };</b></code>
<code class="calibre21"><b class="calibre14">auto it2 { myFind(rbegin(myVector), rend(myVector), 22) };</b></code>
<code class="calibre21">if (it1 != end(myVector) &amp;&amp; it2 != rend(myVector)) {</code>
<code class="calibre21">    println("Found at position {} going forward.",</code>
<code class="calibre21">             distance(begin(myVector), it1));</code>
<code class="calibre21">    println("Found at position {} going backward.",</code>
<code class="calibre21">             distance(begin(myVector), --it2.base()));</code>
<code class="calibre21">} else {</code>
<code class="calibre21">    println("Failed to find.");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output of this program is as follows:
      </p>
      <pre class="calibre26" id="c17-code-0031"><code class="calibre21">Found at position 1 going forward.</code>
<code class="calibre21">Found at position 3 going backward.</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0023">
      </span>
      <h3 class="calibre27" id="head-3-393">
       Move Iterators
      </h3>
      <p class="calibre13">
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       , “Mastering Classes and Objects,” discusses
       <i class="calibre18">
        move semantics
       </i>
       , which can be used to prevent unnecessary copying in cases where you know that the source object will be destroyed after an assignment operation or copy construction, or explicitly when using
       <code class="calibre21">
        std::move()
       </code>
       . The Standard Library provides an iterator adapter called
       <code class="calibre21">
        std::move_iterator
       </code>
       . The dereferencing operator of a
       <code class="calibre21">
        move_iterator
       </code>
       automatically converts the value to an
       <i class="calibre18">
        rvalue reference
       </i>
       , which means that the value can be moved to a new destination without the overhead of copying. Before you can use move semantics, you need to make sure your objects are supporting it. The following
       <code class="calibre21">
        MoveableClass
       </code>
       supports move semantics. For more details, see
       <a class="calibre5" href="c09.xhtml">
        Chapter 9
       </a>
       .
      </p>
      <pre class="calibre26" id="c17-code-0032"><code class="calibre21">class MoveableClass</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<span aria-label="667" class="calibre20" epub:type="pagebreak" id="Page_667" role="doc-pagebreak"></span><code class="calibre21">        MoveableClass() {</code>
<code class="calibre21">            println("Default constructor");</code>
<code class="calibre21">        }</code>
<code class="calibre21">        MoveableClass(const MoveableClass&amp; src) {</code>
<code class="calibre21">            println("Copy constructor");</code>
<code class="calibre21">        }</code>
<code class="calibre21">        MoveableClass(MoveableClass&amp;&amp; src) noexcept {</code>
<code class="calibre21">            println("Move constructor");</code>
<code class="calibre21">        }</code>
<code class="calibre21">        MoveableClass&amp; operator=(const MoveableClass&amp; rhs) {</code>
<code class="calibre21">            println("Copy assignment operator");</code>
<code class="calibre21">            return *this;</code>
<code class="calibre21">        }</code>
<code class="calibre21">        MoveableClass&amp; operator=(MoveableClass&amp;&amp; rhs) noexcept {</code>
<code class="calibre21">            println("Move assignment operator");</code>
<code class="calibre21">            return *this;</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The constructors and assignment operators are not doing anything useful here, except printing a message to make it easy to see which one is being called. Now that you have this class, you can define a
       <code class="calibre21">
        vector
       </code>
       and store a few
       <code class="calibre21">
        MoveableClass
       </code>
       instances in it as follows:
      </p>
      <pre class="calibre26" id="c17-code-0033"><code class="calibre21">vector&lt;MoveableClass&gt; vecSource;</code>
<code class="calibre21">MoveableClass mc;</code>
<code class="calibre21">vecSource.push_back(mc);</code>
<code class="calibre21">vecSource.push_back(mc);</code></pre>
      <p class="calibre13">
       The output could be as follows. The numbers behind each line are not part of the output but are added to make it easier for the upcoming discussion to refer to specific lines.
      </p>
      <pre class="calibre26" id="c17-code-0034"><code class="calibre21">Default constructor  <span class="color">// [1]</span></code>
<code class="calibre21">Copy constructor     <span class="color">// [2]</span></code>
<code class="calibre21">Copy constructor     <span class="color">// [3]</span></code>
<code class="calibre21">Move constructor     <span class="color">// [4]</span></code></pre>
      <p class="calibre13" id="c17-para-0109">
       The second line of the code creates a
       <code class="calibre21">
        MoveableClass
       </code>
       instance by using the default constructor, [1]. The first
       <code class="calibre21">
        push_back()
       </code>
       call triggers the copy constructor to copy
       <code class="calibre21">
        mc
       </code>
       into the
       <code class="calibre21">
        vector
       </code>
       , [2]. After this operation, the vector has space for one element, the first copy of
       <code class="calibre21">
        mc
       </code>
       . Note that this discussion is based on the growth strategy and the initial size of a
       <code class="calibre21">
        vector
       </code>
       as implemented by Microsoft Visual C++ 2022. The C++ standard does not specify the initial capacity of a
       <code class="calibre21">
        vector
       </code>
       or its growth strategy, so the output can be different with different compilers.
      </p>
      <p class="calibre13" id="c17-para-0110">
       The second
       <code class="calibre21">
        push_back()
       </code>
       call triggers the
       <code class="calibre21">
        vector
       </code>
       to resize itself, to allocate space for the second element. This resizing causes the move constructor to be called to move every element from the old
       <code class="calibre21">
        vector
       </code>
       to the new resized
       <code class="calibre21">
        vector
       </code>
       , [4]. The copy constructor is triggered to copy
       <code class="calibre21">
        mc
       </code>
       a second time into the
       <code class="calibre21">
        vector
       </code>
       , [3]. The order of moving and copying is undefined, so [3] and [4] could be reversed.
      </p>
      <p class="calibre13">
       You can create a new
       <code class="calibre21">
        vector
       </code>
       called
       <code class="calibre21">
        vecOne
       </code>
       that contains a copy of the elements from
       <code class="calibre21">
        vecSource
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c17-code-0035"><code class="calibre21">vector&lt;MoveableClass&gt; vecOne { cbegin(vecSource), cend(vecSource) };</code></pre>
      <p class="calibre13">
       <span aria-label="668" class="calibre20" epub:type="pagebreak" id="Page_668" role="doc-pagebreak">
       </span>
       Without using
       <code class="calibre21">
        move_iterator
       </code>
       s, this code triggers the copy constructor two times, once for every element in
       <code class="calibre21">
        vecSource
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0036"><code class="calibre21">Copy constructor</code>
<code class="calibre21">Copy constructor</code></pre>
      <p class="calibre13">
       By using
       <code class="calibre21">
        std::make_move_iterator()
       </code>
       to create
       <code class="calibre21">
        move_iterator
       </code>
       s, the move constructor of
       <code class="calibre21">
        MoveableClass
       </code>
       is called instead of the copy constructor:
      </p>
      <pre class="calibre26" id="c17-code-0037"><code class="calibre21">vector&lt;MoveableClass&gt; vecTwo { make_move_iterator(begin(vecSource)),</code>
<code class="calibre21">                               make_move_iterator(end(vecSource)) };</code></pre>
      <p class="calibre13">
       This generates the following output:
      </p>
      <pre class="calibre26" id="c17-code-0038"><code class="calibre21">Move constructor</code>
<code class="calibre21">Move constructor</code></pre>
      <p class="calibre13">
       You can also use class template argument deduction (CTAD) with
       <code class="calibre21">
        move_iterator
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0039"><code class="calibre21">vector&lt;MoveableClass&gt; vecTwo { move_iterator { begin(vecSource) },</code>
<code class="calibre21">                               move_iterator { end(vecSource) } };</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0117">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Remember that you should no longer use an object once it has been moved to another object
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-193" class="calibre2">
     <span class="calibre" id="c17-sec-0025">
     </span>
     <h2 class="calibre6" id="head-2-193">
      RANGES
     </h2>
     <p class="calibre13">
      The iterator support of the C++ Standard Library allows algorithms to work independently of the actual containers, as they abstract away the mechanism to navigate through the elements of a container. As you've seen in all iterator examples up to now, most algorithms need an iterator pair consisting of a begin iterator that refers to the first element in the sequence, and an end iterator referring to one past the last element in the sequence. This makes it possible for algorithms to work on all kinds of containers, but it's a bit cumbersome to always have to provide two iterators to specify a sequence of elements and to make sure you don't provide mismatching iterators.
      <i class="calibre18">
       Ranges
      </i>
      provided by the
      <i class="calibre18">
       ranges library
      </i>
      are an abstraction layer on top of iterators, eliminating mismatching iterator errors, and adding extra functionality such as allowing range adapters to lazily filter and transform underlying sequences of elements. The ranges library, defined in
      <code class="calibre21">
       &lt;ranges&gt;
      </code>
      , consists of the following major components:
     </p>
     <ul class="check" id="c17-list-0007">
      <li class="calibre9" id="c17-li-0022">
       <b class="calibre14">
        Ranges:
       </b>
       A range is a concept (see
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       ) defining the requirements for a type that allows iteration over its elements. Any data structure that supports
       <code class="calibre21">
        begin()
       </code>
       and
       <code class="calibre21">
        end()
       </code>
       is a valid range. For example,
       <code class="calibre21">
        std::array
       </code>
       ,
       <code class="calibre21">
        vector
       </code>
       ,
       <code class="calibre21">
        string_view
       </code>
       ,
       <code class="calibre21">
        span
       </code>
       , fixed-size C-style arrays, and so on, are all valid ranges.
      </li>
      <li class="calibre9" id="c17-li-0023">
       <b class="calibre14">
        Constrained algorithms:
       </b>
       <a class="calibre5" href="c16.xhtml">
        Chapters 16
       </a>
       and
       <a class="calibre5" href="c20.xhtml">
        20
       </a>
       discuss the available Standard Library algorithms accepting iterator pairs to perform their work. For most of these algorithms there are equivalent range-based and constrained variants that accept iterator pairs or ranges.
      </li>
      <li class="calibre9" id="c17-li-0024">
       <span aria-label="669" class="calibre20" epub:type="pagebreak" id="Page_669" role="doc-pagebreak">
       </span>
       <b class="calibre14">
        Projection:
       </b>
       A lot of the constrained algorithms accept a projection callback. This callback is called for each element in the range and can transform an element to some other value before it is passed to the algorithm.
      </li>
      <li class="calibre9" id="c17-li-0025">
       <b class="calibre14">
        Views:
       </b>
       A view can be used to transform or filter the elements of an underlying range. Views can be composed together to form pipelines of operations to be applied to a range.
      </li>
      <li class="calibre9" id="c17-li-0026">
       <b class="calibre14">
        Factories:
       </b>
       A range factory is used to construct a view that produces values on demand.
      </li>
     </ul>
     <p class="calibre13" id="c17-para-0119">
      Iteration over the elements in a range can be done with iterators that can be retrieved with accessors such as
      <code class="calibre21">
       ranges::begin()
      </code>
      ,
      <code class="calibre21">
       end()
      </code>
      ,
      <code class="calibre21">
       rbegin()
      </code>
      , and so on. Ranges also support
      <code class="calibre21">
       ranges::empty()
      </code>
      ,
      <code class="calibre21">
       data()
      </code>
      ,
      <code class="calibre21">
       cdata()
      </code>
      , and
      <code class="calibre21">
       size()
      </code>
      . The latter returns the number of elements in a range but works only if the size can be retrieved in constant time. Otherwise, use
      <code class="calibre21">
       std::distance()
      </code>
      to calculate the number of elements between a begin and end iterator of a range. All these accessors are not member functions but stand-alone free functions, all requiring a range as argument.
     </p>
     <p class="calibre13" id="c17-para-0120">
      Additionally,
      <code class="calibre21">
       std::format()
      </code>
      ,
      <code class="calibre21">
       print()
      </code>
      , and
      <code class="calibre21">
       println()
      </code>
      have full support for formatting and printing ranges, as is demonstrated by numerous examples throughout this section.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0026">
      </span>
      <h3 class="calibre27" id="head-3-394">
       Constrained Algorithms
      </h3>
      <p class="calibre13">
       The
       <code class="calibre21">
        std::sort()
       </code>
       algorithm is an example of an algorithm that requires a sequence of elements specified as a begin and end iterator. Algorithms are introduced in
       <a class="calibre5" href="c16.xhtml">
        Chapter 16
       </a>
       and discussed in detail in
       <a class="calibre5" href="c20.xhtml">
        Chapter 20
       </a>
       . The
       <code class="calibre21">
        sort()
       </code>
       algorithm is straightforward to use. For example, the following code sorts all the elements of a
       <code class="calibre21">
        vector
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0040"><code class="calibre21">vector data { 33, 11, 22 };</code>
<code class="calibre21">sort(begin(data), end(data));</code></pre>
      <p class="calibre13">
       This code sorts all the elements in the
       <code class="calibre21">
        data
       </code>
       container, but you have to specify the sequence as a begin/end iterator pair. Wouldn't it be nicer to more accurately describe in your code what you really want to do? That's where the
       <i class="calibre18">
        range-based and constrained algorithms
       </i>
       , simply called
       <i class="calibre18">
        constrained algorithms
       </i>
       in this book, come in. These algorithms live in the
       <code class="calibre21">
        std::ranges
       </code>
       namespace and are defined in the same header file as the corresponding unconstrained variants. With those, you can simply write the following:
      </p>
      <pre class="calibre26" id="c17-code-0041"><code class="calibre21">ranges::sort(data);</code></pre>
      <p class="calibre13">
       This code clearly describes your intent, that is, sorting all elements of the
       <code class="calibre21">
        data
       </code>
       container. Since you are not specifying iterators anymore, these constrained algorithms eliminate the possibility of accidentally supplying mismatching begin and end iterators. The constrained algorithms have proper type constraints (see
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       ) for their template type parameters. This allows compilers to provide clearer error messages in case you supply a container to a constrained algorithm that does not provide the type of iterator the algorithm requires. For example, calling the
       <code class="calibre21">
        ranges::sort()
       </code>
       algorithm on an
       <code class="calibre21">
        std::list
       </code>
       will result in a compiler error stating more clearly that
       <code class="calibre21">
        sort()
       </code>
       requires a random-access range, which
       <code class="calibre21">
        list
       </code>
       isn't. Similar to iterators, you have input-, output-, forward-, bidirectional-, random-access-, and contiguous ranges, with corresponding concepts such as
       <code class="calibre21">
        ranges::contiguous_range
       </code>
       ,
       <code class="calibre21">
        ranges::random_access_range
       </code>
       , and so on.
       <span aria-label="670" class="calibre20" epub:type="pagebreak" id="Page_670" role="doc-pagebreak">
       </span>
      </p>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c17-para-0124">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           Most Standard Library algorithms, introduced in
          </i>
          <a class="calibre5" href="c16.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           16
          </a>
          <i class="calibre18">
           and discussed in detail in
          </i>
          <a class="calibre5" href="c20.xhtml">
           <i class="calibre18">
            Chapter
           </i>
           20
          </a>
          <i class="calibre18">
           , have constrained equivalents in the
          </i>
          <code class="calibre21">
           std::ranges
          </code>
          <i class="calibre18">
           namespace. It's recommended to always use these constrained algorithms, if possible, as the compiler can provide better error messages when such algorithms are used with the wrong types, thanks to their type constraints.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c17-sec-0028">
       </span>
       <h4 class="calibre29" id="head-4-275">
        Projection
       </h4>
       <p class="calibre13">
        A lot of the constrained algorithms have a
        <i class="calibre18">
         projection
        </i>
        parameter, a callback used to transform each element before it is handed over to the algorithm. Let's look at an example. Suppose you have a simple class representing a person:
       </p>
       <pre class="calibre26" id="c17-code-0042"><code class="calibre21">class Person</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Person(string first, string last)</code>
<code class="calibre21">            : m_firstName { move(first) }, m_lastName { move(last) } { }</code>
<code class="calibre21">        const string&amp; getFirstName() const { return m_firstName; }</code>
<code class="calibre21">        const string&amp; getLastName() const { return m_lastName; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        string m_firstName;</code>
<code class="calibre21">        string m_lastName;</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        The following code stores a couple of
        <code class="calibre21">
         Person
        </code>
        objects in a
        <code class="calibre21">
         vector
        </code>
        :
       </p>
       <pre class="calibre26" id="c17-code-0043"><code class="calibre21">vector persons { Person {"John", "White"}, Person {"Chris", "Blue"} };</code></pre>
       <p class="calibre13">
        Since the
        <code class="calibre21">
         Person
        </code>
        class does not implement
        <code class="calibre21">
         operator&lt;
        </code>
        , you cannot sort this
        <code class="calibre21">
         vector
        </code>
        using the normal
        <code class="calibre21">
         std::sort()
        </code>
        algorithm, as it compares elements using
        <code class="calibre21">
         operator&lt;
        </code>
        . So, the following does not compile:
       </p>
       <pre class="calibre26" id="c17-code-0044"><code class="calibre21">sort(begin(persons), end(persons)); <span class="color">// Error: does not compile.</span></code></pre>
       <p class="calibre13">
        Switching to the constrained
        <code class="calibre21">
         ranges::sort()
        </code>
        algorithm doesn't help much at first sight. The following still doesn't compile as the algorithm still doesn't know how to compare elements in the range:
       </p>
       <pre class="calibre26" id="c17-code-0045"><code class="calibre21">ranges::sort(persons); <span class="color">// Error: does not compile.</span></code></pre>
       <p class="calibre13">
        However, you can sort
        <code class="calibre21">
         persons
        </code>
        based on their first name, by specifying a projection function for the sort algorithm to project each person to their first name. The projection parameter is the third one, so we have to specify the second parameter as well, which is the comparator to use, by default
        <code class="calibre21">
         std::ranges::less
        </code>
        . In the following call, the
        <code class="calibre21">
         {}
        </code>
        specifies to use the default comparator, and the projection function is specified as a
        <i class="calibre18">
         lambda expression
        </i>
        , see upcoming note.
       </p>
       <pre class="calibre26" id="c17-code-0046"><code class="calibre21">ranges::sort(persons, {},</code>
<code class="calibre21">    [](const Person&amp; person) { return person.getFirstName(); });</code></pre>
       <p class="calibre13">
        Or even shorter:
       </p>
       <pre class="calibre26" id="c17-code-0047"><code class="calibre21">ranges::sort(persons, {}, &amp;Person::getFirstName);</code></pre>
       <p class="calibre13">
        <span aria-label="671" class="calibre20" epub:type="pagebreak" id="Page_671" role="doc-pagebreak">
        </span>
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            The discussion on ranges in this chapter uses a few basic lambda expressions. Lambda expressions are discussed in detail in
           </i>
           <a class="calibre5" href="c19.xhtml">
            <i class="calibre18">
             Chapter
            </i>
            19
           </a>
           <i class="calibre18">
            , “Function Pointers, Function Objects, and Lambda Expressions,” but all those details are not important for the current discussion. For now, it's enough to know only basic use. A lambda expression, as used in this chapter, has the following syntax:
           </i>
          </p>
          <pre class="calibre26" id="c17-code-0048"><code class="calibre21">[](const Person&amp; person) { return person.getFirstName(); }</code></pre>
          <p class="calibre25" id="c17-para-0134">
           <i class="calibre18">
            The
            <code class="calibre21">
             []
            </code>
            denotes the start of a lambda expression. Next is a comma-separated list of parameters, just as for functions. Finally, the body of the lambda expression is between a set of curly brackets
           </i>
           .
          </p>
          <p class="calibre25">
           <i class="calibre18">
            Basically, lambda expressions allow you to write small, unnamed inline functions at the place where you need them. The previous lambda expression could be replaced with the following standalone function:
           </i>
          </p>
          <pre class="calibre26" id="c17-code-0049"><code class="calibre21">auto getFirstName(const Person&amp; person) {</code>
<code class="calibre21">     return person.getFirstName(); }</code></pre>
          <p class="calibre25">
           <i class="calibre18">
            The type of lambda expression parameters can also be
            <code class="calibre21">
             auto
            </code>
            . Here is an example:
           </i>
          </p>
          <pre class="calibre26" id="c17-code-0050"><code class="calibre21">[](const auto&amp; person) { return person.getFirstName(); }</code></pre>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0032">
      </span>
      <h3 class="calibre27" id="head-3-395">
       Views
      </h3>
      <p class="calibre13" id="c17-para-0139">
       A
       <i class="calibre18">
        view
       </i>
       allows you to perform operations on an underlying range's elements, such as filtering and transforming. Views can be chained/composed together to form a
       <i class="calibre18">
        pipeline
       </i>
       performing multiple operations on the elements of a range. Composing views is easy, you just combine different operations using the bitwise OR operator,
       <code class="calibre21">
        operator|
       </code>
       . For example, you can easily filter the elements of a range first and then transform the remaining elements. In contrast, if you want to do something similar, filtering followed by transforming, using the unconstrained algorithms, your code will be much less readable and possibly less performant, as you'll have to create temporary containers to store intermediate results.
      </p>
      <p class="calibre13">
       A view has the following important properties:
      </p>
      <ul class="check" id="c17-list-0008">
       <li class="calibre9" id="c17-li-0027">
        <b class="calibre14">
         Lazily evaluated:
        </b>
        Just constructing a view doesn't perform any operations yet. The operations of a view are applied only at the moment you iterate over the elements of the view and dereference such an iterator.
       </li>
       <li class="calibre9" id="c17-li-0028">
        <b class="calibre14">
         Nonowning
        </b>
        <a aria-describedby="c17-note-0001" class="calibre5" epub:type="noteref" href="#c17-note-0001" id="R_c17-note-0001" role="doc-noteref">
         <sup class="calibre22">
          1
         </sup>
        </a>
        <b class="calibre14">
         :
        </b>
        A view doesn't own any elements. As the name suggests, it's a view over a range's elements that could be stored in some container, and it's that container that's the owner of the data. A view just allows you to view that data in different ways. As such, the number of elements in a view does not influence the cost of copying, moving, or destroying a view. This is similar to
        <code class="calibre21">
         std::string_view
        </code>
        discussed in
        <a class="calibre5" href="c02.xhtml">
         Chapter 2
        </a>
        , “Working with Strings and String Views,” and
        <code class="calibre21">
         std::span
        </code>
        discussed in
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        , “Standard Library Containers.”
       </li>
       <li class="calibre9" id="c17-li-0029">
        <b class="calibre14">
         Nonmutating:
        </b>
        A view never modifies the data in the underlying range.
       </li>
      </ul>
      <p class="calibre13" id="c17-para-0141">
       <span aria-label="672" class="calibre20" epub:type="pagebreak" id="Page_672" role="doc-pagebreak">
       </span>
       A view itself is also a range, but not every range is a view. A container is a range but not a view, as it owns its elements.
      </p>
      <p class="calibre13" id="c17-para-0142">
       Views can be created using
       <i class="calibre18">
        range adapters
       </i>
       . A range adapter accepts an underlying sequence of elements, and optionally some arguments, and creates a new view. The following table lists the range adapters provided by the Standard Library. If none of the Standard Library adapters suits your needs, it's possible to write your own range adapters that properly interoperate with existing adapters. However, writing a full-fledged production-quality range adapter is not trivial and would take us a bit too far for the scope of this book. See your favorite Standard Library reference for more details.
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          RANGE ADAPTER
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           views::all
          </code>
         </td>
         <td class="left1">
          Creates a view that includes all elements of a range.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           filter_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::filter
          </code>
         </td>
         <td class="left1">
          Filters the elements of an underlying sequence based on a given predicate. If the predicate returns
          <code class="calibre21">
           true
          </code>
          , the element is kept, otherwise it is skipped.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           transform_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::transform
          </code>
         </td>
         <td class="left1">
          Applies a callback to each element of an underlying sequence to transform the element to some other value, possibly of a different type.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           take_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::take
          </code>
         </td>
         <td class="left1">
          Creates a view of the first
          <i class="calibre18">
           n
          </i>
          elements of another view.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           take_while_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::take_while
          </code>
         </td>
         <td class="left1">
          Creates a view of the initial elements of an underlying sequence until an element is reached for which a given predicate returns
          <code class="calibre21">
           false
          </code>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           drop_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::drop
          </code>
         </td>
         <td class="left1">
          Creates a view by dropping the first
          <i class="calibre18">
           n
          </i>
          elements of another view.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           drop_while_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::drop_while
          </code>
         </td>
         <td class="left1">
          Creates a view by dropping all initial elements of an underlying sequence until an element is reached for which a given predicate returns
          <code class="calibre21">
           false
          </code>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           join_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::join
          </code>
         </td>
         <td class="left1">
          Flattens a view of ranges into a view. For example, flatten a
          <code class="calibre21">
           vector&lt;vector&lt;int&gt;&gt;
          </code>
          into a
          <code class="calibre21">
           vector&lt;int&gt;
          </code>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           lazy_split_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::lazy_split
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           split_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::split
          </code>
         </td>
         <td class="left1">
          Given a delimiter, splits a given view into subranges on the delimiter. The delimiter can be a single element or a view of elements.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           reverse_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::reverse
          </code>
         </td>
         <td class="left1">
          Creates a view that iterates over the elements of another view in reverse order. The view must be a bidirectional view.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           elements_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::elements
          </code>
         </td>
         <td class="left1">
          Requires a view of tuple-like elements, creates a view of the
          <i class="calibre18">
           n
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          elements of the tuple-like elements.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           keys_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::keys
          </code>
         </td>
         <td class="left1">
          Requires a view of pair-like elements, creates a view of the first element of each pair.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           values_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::values
          </code>
         </td>
         <td class="left1">
          Requires a view of pair-like elements, creates a view of the second element of each pair.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           common_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::common
          </code>
         </td>
         <td class="left1">
          Depending on the type of range,
          <code class="calibre21">
           begin()
          </code>
          and
          <code class="calibre21">
           end()
          </code>
          might return different types, such as a begin iterator and an end
          <i class="calibre18">
           sentinel
          </i>
          . This means that you cannot, for example, pass such an iterator pair to functions that expect them to be of the same type.
          <code class="calibre21">
           common_view
          </code>
          can be used to convert such a range to a
          <i class="calibre18">
           common range
          </i>
          which is a range for which
          <code class="calibre21">
           begin()
          </code>
          and
          <code class="calibre21">
           end()
          </code>
          return the same type. You will use this range adapter in one of the exercises.
          <span aria-label="673" class="calibre20" epub:type="pagebreak" id="Page_673" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c17-para-0176">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       C++23 adds the following range adapters:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          RANGE ADAPTER
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           as_const_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::as_const
          </code>
         </td>
         <td class="left1">
          Creates a view through which the elements of an underlying sequence cannot be modified.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           as_rvalue_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::as_rvalue
          </code>
         </td>
         <td class="left1">
          Creates a view of rvalues of all elements of an underlying sequence.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           enumerate_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::enumerate
          </code>
         </td>
         <td class="left1">
          Creates a view where each element represents the position and value of all elements of an underlying sequence.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           zip_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::zip
          </code>
         </td>
         <td class="left1">
          Creates a view consisting of tuples of reference to corresponding elements of all given views.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           zip_transform_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::zip_transform
          </code>
         </td>
         <td class="left1">
          Creates a view whose
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          element is the result of applying a given callable to the
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          elements of all given views.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           adjacent_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::adjacent
          </code>
         </td>
         <td class="left1">
          For a given
          <i class="calibre18">
           n
          </i>
          , creates a view whose
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          element is a tuple of references to the
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          through (
          <i class="calibre18">
           i
          </i>
          +
          <i class="calibre18">
           n
          </i>
          − 1)
          <sup class="calibre22">
           th
          </sup>
          elements of a given view.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           adjacent_transform_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::adjacent_transform
          </code>
         </td>
         <td class="left1">
          For a given
          <i class="calibre18">
           n
          </i>
          , creates a view whose
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          element is the result of applying a given callable to the
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          through (
          <i class="calibre18">
           i
          </i>
          +
          <i class="calibre18">
           n
          </i>
          − 1)
          <sup class="calibre22">
           th
          </sup>
          elements of a given view.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           views::pairwise
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::pairwise_transform
          </code>
         </td>
         <td class="left1">
          Helper types representing
          <code class="calibre21">
           views::adjacent&lt;2&gt;
          </code>
          and
          <code class="calibre21">
           views::adjacent_transform&lt;2&gt;
          </code>
          respectively.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           join_with_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::join_with
          </code>
         </td>
         <td class="left1">
          Given a delimiter, flattens the elements of a given view, inserting every element of the delimiter in between elements of the view. The delimiter can be a single element or a view of elements.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           stride_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::stride
          </code>
         </td>
         <td class="left1">
          For a given
          <i class="calibre18">
           n
          </i>
          , creates a view of an underlying sequence, advancing over
          <i class="calibre18">
           n
          </i>
          elements at a time, instead of one by one.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           slide_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::slide
          </code>
         </td>
         <td class="left1">
          For a given
          <i class="calibre18">
           n
          </i>
          , creates a view whose
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          element is a view over the
          <i class="calibre18">
           i
          </i>
          <sup class="calibre22">
           <i class="calibre18">
            th
           </i>
          </sup>
          through (
          <i class="calibre18">
           i
          </i>
          +
          <i class="calibre18">
           n
          </i>
          − 1)
          <sup class="calibre22">
           th
          </sup>
          elements of the original view. Similar to
          <code class="calibre21">
           views::adjacent
          </code>
          , but the window size,
          <i class="calibre18">
           n
          </i>
          , is a runtime parameter for
          <code class="calibre21">
           slide
          </code>
          , while it's a template argument for
          <code class="calibre21">
           adjacent
          </code>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           chunk_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::chunk
          </code>
         </td>
         <td class="left1">
          For a given
          <i class="calibre18">
           n
          </i>
          , creates a range of views that are
          <i class="calibre18">
           n
          </i>
          -sized non-overlapping successive chunks of the elements of the original view, in order.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           chunk_by_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::chunk_by
          </code>
         </td>
         <td class="left1">
          Splits a given view into subranges between each pair of adjacent elements for which a given predicate returns
          <code class="calibre21">
           false
          </code>
          .
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           cartesian_product_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           views::cartesian_product
          </code>
         </td>
         <td class="left1">
          Given a number of ranges,
          <i class="calibre18">
           n
          </i>
          , creates a view of tuples calculated by the
          <i class="calibre18">
           n
          </i>
          -ary cartesian product of the provided ranges.
          <span aria-label="674" class="calibre20" epub:type="pagebreak" id="Page_674" role="doc-pagebreak">
          </span>
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13" id="c17-para-0207">
       The range adapters in the first column of both tables show both the class name in the
       <code class="calibre21">
        std::ranges
       </code>
       namespace and a corresponding
       <i class="calibre18">
        range adapter object
       </i>
       from the
       <code class="calibre21">
        std::ranges::views
       </code>
       namespace. The Standard Library provides a namespace alias called
       <code class="calibre21">
        std::views
       </code>
       equal to
       <code class="calibre21">
        std::ranges::views
       </code>
       .
      </p>
      <p class="calibre13">
       Each range adapter can be constructed by calling its constructor and passing any required arguments. The first argument is always the range on which to operate, followed by zero or more additional arguments, as follows:
      </p>
      <pre class="calibre26" id="c17-code-0051"><code class="calibre21">std::ranges::<i class="calibre18">operation</i>_view { range, arguments… }</code></pre>
      <p class="calibre13">
       Usually, you will not create these range adapters using their constructors, but instead use the range adapter objects from the
       <code class="calibre21">
        std::ranges::views
       </code>
       namespace in combination with the bitwise OR operator,
       <code class="calibre21">
        |
       </code>
       , as follows:
      </p>
      <pre class="calibre26" id="c17-code-0052"><code class="calibre21">range | std::ranges::views::<i class="calibre18">operation</i>(arguments…)</code></pre>
      <p class="calibre13">
       Let's see some of these range adapters in action. The following example first defines an abbreviated function template called
       <code class="calibre21">
        printRange()
       </code>
       to print a message followed by all the elements in a given range. Next, the
       <code class="calibre21">
        main()
       </code>
       function starts by creating a
       <code class="calibre21">
        vector
       </code>
       of integers, 1…10, and subsequently applies several range adapters on it, each time calling
       <code class="calibre21">
        printRange()
       </code>
       on the result so you can follow
       <span aria-label="675" class="calibre20" epub:type="pagebreak" id="Page_675" role="doc-pagebreak">
       </span>
       what's happening. Afterward, it demonstrates several of the new C++23 range adapters. The example uses the
       <code class="calibre21">
        myCopy()
       </code>
       function introduced earlier in this chapter.
      </p>
      <pre class="calibre26" id="c17-code-0053"><code class="calibre21">void printRange(string_view msg, auto&amp;&amp; range) { println("{}{:n}", msg, range); }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">    printRange("Original sequence: ", values);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Filter out all odd values, leaving only the even values.</span></code>
<code class="calibre21">    auto result1 { values</code>
<code class="calibre21">        | views::<b class="calibre14">filter</b>([](const auto&amp; value) { return value % 2 == 0; }) };</code>
<code class="calibre21">    printRange("Only even values: ", result1);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Transform all values to their double value.</span></code>
<code class="calibre21">    auto result2 { result1</code>
<code class="calibre21">        | views::<b class="calibre14">transform</b>([](const auto&amp; value) { return value * 2.0; }) };</code>
<code class="calibre21">    printRange("Values doubled: ", result2);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Drop the first 2 elements.</span></code>
<code class="calibre21">    auto result3 { result2 | views::<b class="calibre14">drop</b>(2) };</code>
<code class="calibre21">    printRange("First two dropped: ", result3);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// Reverse the view.</span></code>
<code class="calibre21">    auto result4 { result3 | views::<b class="calibre14">reverse</b> };</code>
<code class="calibre21">    printRange("Sequence reversed: ", result4);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// C++23: views::zip</span></code>
<code class="calibre21">    vector v1 { 1, 2 };</code>
<code class="calibre21">    vector v2 { 'a', 'b', 'c' };</code>
<code class="calibre21">    auto result5 { views::<b class="calibre14">zip</b>(v1, v2) };</code>
<code class="calibre21">    printRange("views::zip: ", result5);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// C++23: views::adjacent</span></code>
<code class="calibre21">    vector v3 { 1, 2, 3, 4, 5 };</code>
<code class="calibre21">    auto result6 { v3 | views::<b class="calibre14">adjacent</b>&lt;2&gt; };</code>
<code class="calibre21">    printRange("views::adjacent: ", result6);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// C++23: views::chunk</span></code>
<code class="calibre21">    auto result7 { v3 | views::<b class="calibre14">chunk</b>(2) };</code>
<code class="calibre21">    printRange("views::chunk: ", result7);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// C++23: views::stride</span></code>
<code class="calibre21">    auto result8 { v3 | views::<b class="calibre14">stride</b>(2) };</code>
<code class="calibre21">    printRange("views::stride: ", result8);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// C++23: views::enumerate + views::split</span></code>
<code class="calibre21">    string lorem { "Lorem ipsum dolor sit amet" };</code>
<code class="calibre21">    for (auto [index, word] : lorem | views::<b class="calibre14">split</b>(' ') | views::<b class="calibre14">enumerate</b>) {</code>
<code class="calibre21">        print("{}:'{}' ", index, string_view { word });</code>
<code class="calibre21">    }</code>
<code class="calibre21">    println("");</code>
<code class="calibre21"> </code>
<span aria-label="676" class="calibre20" epub:type="pagebreak" id="Page_676" role="doc-pagebreak"></span><code class="calibre21">    <span class="color">// C++23: views::as_rvalue</span></code>
<code class="calibre21">    vector&lt;string&gt; words { "Lorem", "ipsum", "dolor", "sit", "amet" };</code>
<code class="calibre21">    vector&lt;string&gt; movedWords;</code>
<code class="calibre21">    auto rvalueView { words | views::<b class="calibre14">as_rvalue</b> };</code>
<code class="calibre21">    myCopy(begin(rvalueView), end(rvalueView), back_inserter(movedWords));</code>
<code class="calibre21">    printRange("movedWords: ", movedWords);</code>
<code class="calibre21"> </code>
<code class="calibre21">    <span class="color">// C++23: Cartesian product of vector v with itself.</span></code>
<code class="calibre21">    vector v { 0, 1, 2 };</code>
<code class="calibre21">    for (auto&amp;&amp;[a, b] : views::<b class="calibre14">cartesian_product</b>(v, v)) {print("({},{}) ", a, b);}</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The output of this program is as follows:
      </p>
      <pre class="calibre26" id="c17-code-0054"><code class="calibre21">Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">Only even values: 2, 4, 6, 8, 10</code>
<code class="calibre21">Values doubled: 4, 8, 12, 16, 20</code>
<code class="calibre21">First two dropped: 12, 16, 20</code>
<code class="calibre21">Sequence reversed: 20, 16, 12</code>
<code class="calibre21">views::zip: (1, 'a'), (2, 'b')</code>
<code class="calibre21">views::adjacent: (1, 2), (2, 3), (3, 4), (4, 5)</code>
<code class="calibre21">views::chunk: (1, 2), (3, 4), (5)</code>
<code class="calibre21">views::stride: 1, 3, 5</code>
<code class="calibre21">0:'Lorem' 1:'ipsum' 2:'dolor' 3:'sit' 4:'amet'</code>
<code class="calibre21">movedWords: Lorem, ipsum, dolor, sit, amet</code>
<code class="calibre21">(0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1) (2,2)</code></pre>
      <p class="calibre13" id="c17-para-0212">
       It's worth repeating that views are lazily evaluated. In this example, the construction of the
       <code class="calibre21">
        result1
       </code>
       view does not do any actual filtering yet. The filtering happens at the time when the
       <code class="calibre21">
        printRange()
       </code>
       function iterates over the elements of
       <code class="calibre21">
        result1
       </code>
       .
      </p>
      <p class="calibre13">
       The code snippet uses the range adapter objects from
       <code class="calibre21">
        std::ranges::views
       </code>
       . You can also construct range adapters using their constructors. For example, the
       <code class="calibre21">
        result1
       </code>
       view can be constructed as follows:
      </p>
      <pre class="calibre26" id="c17-code-0055"><code class="calibre21">auto result1 { ranges::filter_view { values,</code>
<code class="calibre21">    [](const auto&amp; value) { return value % 2 == 0; } } };</code></pre>
      <p class="calibre13">
       This example is creating several intermediate views,
       <code class="calibre21">
        result1
       </code>
       ,
       <code class="calibre21">
        result2
       </code>
       ,
       <code class="calibre21">
        result3
       </code>
       , and
       <code class="calibre21">
        result4
       </code>
       , to be able to output their elements to make it easier to follow what's happening in each step. If you don't need these intermediate views, you can chain them all together in a single pipeline as follows:
      </p>
      <pre class="calibre26" id="c17-code-0056"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">printRange("Original sequence: ", values);</code>
<code class="calibre21"> </code>
<code class="calibre21">auto result { values</code>
<code class="calibre21">    | views::filter([](const auto&amp; value) { return value % 2 == 0; })</code>
<code class="calibre21">    | views::transform([](const auto&amp; value) { return value * 2.0; })</code>
<code class="calibre21">    | views::drop(2)</code>
<code class="calibre21">    | views::reverse };</code>
<code class="calibre21">printRange("Final sequence: ", result);</code></pre>
      <p class="calibre13">
       The output is as follows. The last line shows that the final sequence is the same as the earlier
       <code class="calibre21">
        result4
       </code>
       view.
      </p>
      <pre class="calibre26" id="c17-code-0057"><code class="calibre21">Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">Final sequence: 20, 16, 12</code></pre>
      <span aria-label="677" class="calibre20" epub:type="pagebreak" id="Page_677" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c17-sec-0033">
       </span>
       <h4 class="calibre29" id="head-4-276">
        Modifying Elements Through a View
       </h4>
       <p class="calibre13" id="c17-para-0216">
        Some ranges are read-only. For example, the result of
        <code class="calibre21">
         views::transform
        </code>
        is a read-only view, because it creates a view with transformed elements but without transforming the actual values in the underlying range. If a range is not read-only, then you can modify the elements of that range through a view. Let's look an example.
       </p>
       <p class="calibre13">
        The following example constructs a
        <code class="calibre21">
         vector
        </code>
        of ten elements. It then creates a view over the even values, drops the first two even values, and finally reverses the elements. The range-based
        <code class="calibre21">
         for
        </code>
        loop then multiplies the elements in the resulting view with 10. The last line outputs the elements in the original
        <code class="calibre21">
         values vector
        </code>
        to confirm that some elements have been changed through the view.
       </p>
       <pre class="calibre26" id="c17-code-0058"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">printRange("Original sequence: ", values);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Filter out all odd values, leaving only the even values.</span></code>
<code class="calibre21">auto result1 { values</code>
<code class="calibre21">    | views::filter([](const auto&amp; value) { return value % 2 == 0; }) };</code>
<code class="calibre21">printRange("Only even values: ", result1);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Drop the first 2 elements.</span></code>
<code class="calibre21">auto result2 { result1 | views::drop(2) };</code>
<code class="calibre21">printRange("First two dropped: ", result2);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Reverse the view.</span></code>
<code class="calibre21">auto result3 { result2 | views::reverse };</code>
<code class="calibre21">printRange("Sequence reversed: ", result3);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Modify the elements using a range-based for loop.</span></code>
<code class="calibre21">for (auto&amp; value : result3) { value *= 10; }</code>
<code class="calibre21">printRange("After modifying elements through a view, vector contains:\n", values);</code></pre>
       <p class="calibre13">
        The output of this program is as follows:
       </p>
       <pre class="calibre26" id="c17-code-0059"><code class="calibre21">Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">Only even values: 2, 4, 6, 8, 10</code>
<code class="calibre21">First two dropped: 6, 8, 10</code>
<code class="calibre21">Sequence reversed: 10, 8, 6</code>
<code class="calibre21">After modifying elements through a view, vector contains: 1, 2, 3, 4, 5, 60, 7, 80, 9, 100</code></pre>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c17-sec-0034">
       </span>
       <h4 class="calibre29" id="head-4-277">
        Mapping Elements
       </h4>
       <p class="calibre13">
        Transforming elements of a range doesn't need to result in a range with elements of the same type. Instead, you can
        <i class="calibre18">
         map
        </i>
        elements to another type. The following example starts with a range of integers, filters out all odd elements, keeps only the first three even values, and transforms those to strings using
        <code class="calibre21">
         std::format()
        </code>
        :
       </p>
       <pre class="calibre26" id="c17-code-0060"><code class="calibre21">vector values { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };</code>
<code class="calibre21">printRange("Original sequence: ", values);</code>
<code class="calibre21"> </code>
<code class="calibre21">auto result { values</code>
<code class="calibre21">    | views::filter([](const auto&amp; value) { return value % 2 == 0; })</code>
<code class="calibre21">    | views::take(3)</code>
<code class="calibre21">    | views::transform([](const auto&amp; v) { return format("{}", v); }) };</code>
<code class="calibre21">printRange("Result: ", result);</code></pre>
       <p class="calibre13">
        <span aria-label="678" class="calibre20" epub:type="pagebreak" id="Page_678" role="doc-pagebreak">
        </span>
        The output is as follows:
       </p>
       <pre class="calibre26" id="c17-code-0061"><code class="calibre21">Original sequence: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</code>
<code class="calibre21">Result: "2", "4", "6"</code></pre>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0035">
      </span>
      <h3 class="calibre27" id="head-3-396">
       Range Factories
      </h3>
      <p class="calibre13" id="c17-para-0221">
       The ranges library provides the following
       <i class="calibre18">
        range factories
       </i>
       to construct views that produce elements lazily on demand:
      </p>
      <table border="1" class="calibre31">
       <thead class="calibre32">
        <tr class="calibre33">
         <th class="left" scope="col">
          RANGE FACTORY
         </th>
         <th class="left" scope="col">
          DESCRIPTION
         </th>
        </tr>
       </thead>
       <tbody class="calibre34">
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           empty_view
          </code>
         </td>
         <td class="left1">
          Creates an empty view.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           single_view
          </code>
         </td>
         <td class="left1">
          Creates a view with a single given element.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           iota_view
          </code>
         </td>
         <td class="left1">
          Creates an infinite or a bounded view containing elements starting with an initial value, and where each subsequent element has a value equal to the value of the previous element incremented by one.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <img alt="C++23" class="calibre15" src="images/icon1.png"/>
          <code class="calibre21">
           repeat_view
          </code>
         </td>
         <td class="left1">
          Creates a view that repeats a given value. The resulting view can be unbounded (infinite) or bounded by a given number of values.
         </td>
        </tr>
        <tr class="calibre33">
         <td class="left1">
          <code class="calibre21">
           basic_istream_view
          </code>
          <br class="calibre12"/>
          <code class="calibre21">
           istream_view
          </code>
         </td>
         <td class="left1">
          Creates a view containing elements retrieved by calling the extraction operator,
          <code class="calibre21">
           operator&gt;&gt;
          </code>
          , on an underlying input stream.
         </td>
        </tr>
       </tbody>
      </table>
      <p class="calibre13">
       Just as with the range adapters from the previous section, the names in the range factories table are class names living in the
       <code class="calibre21">
        std::ranges
       </code>
       namespace, which you can directly create using their constructor. Alternatively, you can use the factory functions available in the
       <code class="calibre21">
        std::ranges:views
       </code>
       namespace. For example, the following two statements are equivalent and create an infinite view with elements 10, 11, 12, …:
      </p>
      <pre class="calibre26" id="c17-code-0062"><code class="calibre21">std::ranges::iota_view { 10 }</code>
<code class="calibre21">std::ranges::views::iota(10)</code></pre>
      <p class="calibre13">
       Let's look at a range factory in practice. The following example is loosely based on an earlier example, but instead of constructing a
       <code class="calibre21">
        vector
       </code>
       with 10 elements in it, this code uses the
       <code class="calibre21">
        iota
       </code>
       range factory to create a lazy infinite sequence of numbers starting at 10. It then removes all odd values, doubles the remaining elements, and finally only keeps the first ten elements that are subsequently output to the console using
       <code class="calibre21">
        printRange()
       </code>
       .
      </p>
      <pre class="calibre26" id="c17-code-0063"><code class="calibre21"><span class="color">// Create an infinite sequence of the numbers 10, 11, 12, …</span></code>
<code class="calibre21">auto values { views::iota(10) };</code>
<code class="calibre21"><span class="color">// Filter out all odd values, leaving only the even values.</span></code>
<code class="calibre21">auto result1 { values</code>
<code class="calibre21">    | views::filter([](const auto&amp; value) { return value % 2 == 0; }) };</code>
<code class="calibre21"><span class="color">// Transform all values to their double value.</span></code>
<code class="calibre21">auto result2 { result1</code>
<code class="calibre21">    | views::transform([](const auto&amp; value) { return value * 2.0; }) };</code>
<code class="calibre21"><span class="color">// Take only the first ten elements.</span></code>
<code class="calibre21">auto result3 { result2 | views::take(10) };</code>
<code class="calibre21">printRange("Result: ", result3);</code></pre>
      <p class="calibre13">
       <span aria-label="679" class="calibre20" epub:type="pagebreak" id="Page_679" role="doc-pagebreak">
       </span>
       The output is as follows:
      </p>
      <pre class="calibre26" id="c17-code-0064"><code class="calibre21">Result: 20, 24, 28, 32, 36, 40, 44, 48, 52, 56</code></pre>
      <p class="calibre13" id="c17-para-0231">
       The
       <code class="calibre21">
        values
       </code>
       range represents an infinite range, which is subsequently filtered and transformed. Working with infinite ranges is possible because all these operations are lazily evaluated only at the time when
       <code class="calibre21">
        printRange()
       </code>
       iterates over the elements of the view. This also means that in this example you cannot call
       <code class="calibre21">
        printRange()
       </code>
       to output the contents of
       <code class="calibre21">
        values
       </code>
       ,
       <code class="calibre21">
        result1
       </code>
       , or
       <code class="calibre21">
        result2
       </code>
       because that would trigger an infinite loop in
       <code class="calibre21">
        printRange()
       </code>
       as those are infinite ranges.
      </p>
      <p class="calibre13">
       Of course, you can get rid of those intermediate views and simply construct one big pipeline. The following produces the same output as before:
      </p>
      <pre class="calibre26" id="c17-code-0065"><code class="calibre21">auto result { views::iota(10)</code>
<code class="calibre21">    | views::filter([](const auto&amp; value) { return value % 2 == 0; })</code>
<code class="calibre21">    | views::transform([](const auto&amp; value) { return value * 2.0; })</code>
<code class="calibre21">    | views::take(10) };</code>
<code class="calibre21">printRange("Result: ", result);</code></pre>
      <p class="calibre13">
       Another range factory example demonstrates how to use a
       <code class="calibre21">
        repeat_view
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0066"><code class="calibre21">printRange("Repeating view: ", views::repeat(42, 5));</code></pre>
      <p class="calibre13">
       This outputs the following:
      </p>
      <pre class="calibre26" id="c17-code-0067"><code class="calibre21">Repeating view: 42, 42, 42, 42, 42</code></pre>
      <section class="calibre2">
       <span class="calibre" id="c17-sec-0036">
       </span>
       <h4 class="calibre29" id="head-4-278">
        Input Streams as Views
       </h4>
       <p class="calibre13" id="c17-para-0235">
        The
        <code class="calibre21">
         basic_istream_view
        </code>
        /
        <code class="calibre21">
         istream_view
        </code>
        range factory can be used to construct a view over the elements read from an input stream, such as the standard input. Elements are read using
        <code class="calibre21">
         operator&gt;&gt;
        </code>
        .
       </p>
       <p class="calibre13">
        For example, the following code snippet keeps reading integers from standard input. For each read number that is less than 5, the number is doubled and printed on standard output. Once you enter a number 5 or higher, the loop stops.
       </p>
       <pre class="calibre26" id="c17-code-0068"><code class="calibre21">println("Type integers, an integer&gt;= 5 stops the program.");</code>
<code class="calibre21">for (auto value : ranges::istream_view&lt;int&gt; { cin }</code>
<code class="calibre21">    | views::take_while([](const auto&amp; v) { return v &lt; 5; })</code>
<code class="calibre21">    | views::transform([](const auto&amp; v) { return v * 2; })) {</code>
<code class="calibre21">    println("&gt; {}", value);</code>
<code class="calibre21">}</code>
<code class="calibre21">println("Terminating…");</code></pre>
       <p class="calibre13">
        The following is a possible output sequence:
       </p>
       <pre class="calibre26" id="c17-code-0069"><code class="calibre21">Type integers, an integer&gt;= 5 stops the program.</code>
<code class="calibre21">1 2</code>
<code class="calibre21">&gt; 2</code>
<code class="calibre21">&gt; 4</code>
<code class="calibre21">3</code>
<code class="calibre21">&gt; 6</code>
<code class="calibre21">4</code>
<code class="calibre21">&gt; 8</code>
<code class="calibre21">5</code>
<code class="calibre21">Terminating…</code></pre>
       <span aria-label="680" class="calibre20" epub:type="pagebreak" id="Page_680" role="doc-pagebreak">
       </span>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c17-sec-0037">
      </span>
      <h3 class="calibre27" id="head-3-397">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Converting a Range into a Container
      </h3>
      <p class="calibre13" id="c17-para-0239">
       Before C++23, it was not easy to convert a range into a container. C++23 introduces
       <code class="calibre21">
        std::ranges::to()
       </code>
       to make such conversions straightforward. This can also be used to convert the elements of a view into a container, as a view is a range. Even more, since a container is a range as well, you can use
       <code class="calibre21">
        ranges::to()
       </code>
       to convert one container into a different container, even with different element types.
      </p>
      <p class="calibre13">
       The following code snippet demonstrates several uses of
       <code class="calibre21">
        ranges::to()
       </code>
       . The example also demonstrates special constructors for
       <code class="calibre21">
        set
       </code>
       and
       <code class="calibre21">
        string
       </code>
       , which accept the
       <code class="calibre21">
        std::from_range
       </code>
       tag as the first parameter and convert a given range into a
       <code class="calibre21">
        set
       </code>
       or
       <code class="calibre21">
        string
       </code>
       . All Standard Library containers now include such constructors.
      </p>
      <pre class="calibre26" id="c17-code-0070"><code class="calibre21"><span class="color">// Convert a vector to a set with the same element type.</span></code>
<code class="calibre21">vector vec { 33, 11, 22 };</code>
<code class="calibre21">auto s1 { ranges::to&lt;set&gt;(vec) };</code>
<code class="calibre21">println("{:n}", s1);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Convert a vector of integers to a set of doubles, using the pipe operator.</span></code>
<code class="calibre21">auto s2 { vec | ranges::to&lt;set&lt;double&gt;&gt;() };</code>
<code class="calibre21">println("{:n}", s2);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Convert a vector of integers to a set of doubles, using from_range constructor.</span></code>
<code class="calibre21">set&lt;double&gt; s3 { from_range, vec };</code>
<code class="calibre21">println("{:n}", s3);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Lazily generate the integers from 10 to 14, divide these by 2,</span></code>
<code class="calibre21"><span class="color">// and store the result in a vector of doubles.</span></code>
<code class="calibre21">auto vec2 { views::iota(10, 15)</code>
<code class="calibre21">    | views::transform([](const auto&amp; v) { return v / 2.0; })</code>
<code class="calibre21">    | ranges::to&lt;vector&lt;double&gt;&gt;() };</code>
<code class="calibre21">println("{:n}", vec2);</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// Use views::split() and views::transform() to create a view</span></code>
<code class="calibre21"><span class="color">// containing individual words of a string, and then convert</span></code>
<code class="calibre21"><span class="color">// the resulting view to a vector of strings containing all the words.</span></code>
<code class="calibre21">string lorem { "Lorem ipsum dolor sit amet" };</code>
<code class="calibre21">auto words { lorem | views::split(' ')</code>
<code class="calibre21">    | views::transform([](const auto&amp; v) { return string { from_range, v }; })</code>
<code class="calibre21">    | ranges::to&lt;vector&gt;() };</code>
<code class="calibre21">println("{:n:?}", words);</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c17-code-0071"><code class="calibre21">11, 22, 33</code>
<code class="calibre21">11, 22, 33</code>
<code class="calibre21">11, 22, 33</code>
<code class="calibre21">5, 5.5, 6, 6.5, 7</code>
<code class="calibre21">"Lorem", "ipsum", "dolor", "sit", "amet"</code></pre>
      <p class="calibre13">
       C++23 also introduces a number of new member functions for Standard Library containers, providing for interoperability between containers and ranges. These member functions are of the form
       <code class="calibre21">
        <i class="calibre18">
         xyz
        </i>
        _range(…)
       </code>
       , where
       <i class="calibre18">
        <code class="calibre21">
         xyz
        </code>
       </i>
       can be
       <code class="calibre21">
        insert
       </code>
       ,
       <code class="calibre21">
        append
       </code>
       ,
       <code class="calibre21">
        prepend
       </code>
       ,
       <code class="calibre21">
        assign
       </code>
       ,
       <code class="calibre21">
        replace
       </code>
       ,
       <code class="calibre21">
        push
       </code>
       ,
       <code class="calibre21">
        push_front
       </code>
       ,
       <span aria-label="681" class="calibre20" epub:type="pagebreak" id="Page_681" role="doc-pagebreak">
       </span>
       or
       <code class="calibre21">
        push_back
       </code>
       .
       <a class="calibre5" href="c18_split_000.xhtml">
        Chapter 18
       </a>
       discusses all Standard Library containers in detail, but consult a Standard Library reference to learn exactly which member functions are supported by which container. Here is an example demonstrating the
       <code class="calibre21">
        append_range()
       </code>
       and
       <code class="calibre21">
        insert_range()
       </code>
       member functions of
       <code class="calibre21">
        vector
       </code>
       :
      </p>
      <pre class="calibre26" id="c17-code-0072"><code class="calibre21">vector&lt;int&gt; vec3;</code>
<code class="calibre21">vec3.append_range(views::iota(10, 15));</code>
<code class="calibre21">println("{:n}", vec3);</code>
<code class="calibre21">vec3.insert_range(begin(vec3), views::iota(10, 15) | views::reverse);</code>
<code class="calibre21">println("{:n}", vec3);</code></pre>
      <p class="calibre13">
       The output is:
      </p>
      <pre class="calibre26" id="c17-code-0073"><code class="calibre21">10, 11, 12, 13, 14</code>
<code class="calibre21">14, 13, 12, 11, 10, 10, 11, 12, 13, 14</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-194" class="calibre2">
     <span class="calibre" id="c17-sec-0038">
     </span>
     <h2 class="calibre6" id="head-2-194">
      SUMMARY
     </h2>
     <p class="calibre13" id="c17-para-0244">
      This chapter explained the ideas behind iterators, which are an abstraction that allows you to navigate the elements of a container without the need to know the structure of the container. You have seen that output stream iterators can use standard output as a destination for iterator-based algorithms, and similarly that input stream iterators can use standard input as the source of data for algorithms. The chapter also discussed the insert-, reverse-, and move iterator adapters that can be used to adapt other iterators.
     </p>
     <p class="calibre13" id="c17-para-0245">
      The last part of this chapter discussed the ranges library, part of the C++ Standard Library. It allows you to write more functional-style code, by specifying
      <i class="calibre18">
       what
      </i>
      you want to accomplish instead of
      <i class="calibre18">
       how
      </i>
      . You can construct pipelines consisting of a combination of operations applied to the elements of a range. Such pipelines are executed lazily; that is, they don't do anything until you iterate over the resulting view.
     </p>
    </section>
    <section aria-labelledby="head-2-195" class="calibre2">
     <span class="calibre" id="c17-sec-0039">
     </span>
     <h2 class="calibre6" id="head-2-195">
      EXERCISES
     </h2>
     <p class="calibre13" id="c17-para-0246">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <code class="calibre21">
        <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
         www.wiley.com/go/proc++6e
        </a>
       </code>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c17-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c17-ex-0001">
        <b class="calibre14">
         Exercise 17-1:
        </b>
        Write a program that lazily constructs the sequence of elements 10-100, squares each number, removes all numbers dividable by five, and transforms the remaining values to strings using
        <code class="calibre21">
         std::to_string()
        </code>
        .
       </li>
       <li class="calibre9" id="c17-ex-0002">
        <b class="calibre14">
         Exercise 17-2:
        </b>
        Write a program that creates a
        <code class="calibre21">
         vector
        </code>
        of
        <code class="calibre21">
         pair
        </code>
        s, where each
        <code class="calibre21">
         pair
        </code>
        contains an instance of the
        <code class="calibre21">
         Person
        </code>
        class introduced earlier in this chapter, and their age. Next, use the ranges library to construct a single pipeline that extracts all ages from all persons from the
        <code class="calibre21">
         vector
        </code>
        , and removes all ages below 12 and above 65. Finally, calculate the average of the remaining ages using the
        <code class="calibre21">
         sum()
        </code>
        algorithm from earlier in this chapter. As you'll pass a range to the
        <code class="calibre21">
         sum()
        </code>
        algorithm, you'll have to work with a common range.
       </li>
       <li class="calibre9" id="c17-ex-0003">
        <span aria-label="682" class="calibre20" epub:type="pagebreak" id="Page_682" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         Exercise 17-3:
        </b>
        Building further on the solution for Exercise 17-2, add an implementation for
        <code class="calibre21">
         operator&lt;&lt;
        </code>
        for the
        <code class="calibre21">
         Person
        </code>
        class.
        <p class="listpara" id="c17-para-0250">
         Next, create a pipeline to extract the
         <code class="calibre21">
          Person
         </code>
         of each
         <code class="calibre21">
          pair
         </code>
         from the
         <code class="calibre21">
          vector
         </code>
         of
         <code class="calibre21">
          pair
         </code>
         s, and only keep the first four
         <code class="calibre21">
          Person
         </code>
         s. Use the
         <code class="calibre21">
          myCopy()
         </code>
         algorithm introduced earlier in this chapter to print the names of those four persons to the standard output; one name per line.
        </p>
        <p class="listpara" id="c17-para-0251">
         Finally, create a similar pipeline but one that additionally projects all filtered
         <code class="calibre21">
          Person
         </code>
         s to their last name. This time, use a single
         <code class="calibre21">
          println()
         </code>
         statement to print the last names to the standard output.
        </p>
       </li>
       <li class="calibre9" id="c17-ex-0004">
        <b class="calibre14">
         Exercise 17-4:
        </b>
        Write a program that uses a range-based
        <code class="calibre21">
         for
        </code>
        loop and
        <code class="calibre21">
         ranges::istream_view()
        </code>
        to read integers from the standard input until a -1 is entered. Store the read integers in a
        <code class="calibre21">
         vector
        </code>
        , and afterward, print the content of the
        <code class="calibre21">
         vector
        </code>
        to the console to verify it contains the correct values.
       </li>
       <li class="calibre9" id="c17-ex-0005">
        <b class="calibre14">
         Bonus exercise:
        </b>
        Can you find a couple of ways to change the solution for Exercise 17-4 to not use any explicit loops? Hint: one option could be to use the
        <code class="calibre21">
         std::ranges::copy()
        </code>
        algorithm to copy a range from a source to a target. It can be called with a range as first argument and an output iterator as the second argument.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c17_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c17_2">
     NOTE
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c17-note-0001" id="c17-note-0001" role="doc-backlink">
       1
      </a>
      C++23 slightly modifies the definition of a view. It allows for a view to own its elements, but only if it guarantees that it's either non-copyable, or copyable in constant time, O(1). Most views will be nonowning, so owning views are not further discussed in this text.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
