<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
 <head>
  <link href="style.css" rel="stylesheet" type="text/css"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   19Function Pointers, Function Objects, and Lambda Expressions
  </title>
 </head>
 <body>
  <div class="navigation">
   <a class="nav-button" href="chapter_014.html">
    ← Previous
   </a>
   <a class="nav-button" href="index.html">
    Table of Contents
   </a>
   <a class="nav-button" href="chapter_016.html">
    Next →
   </a>
  </div>
  <div class="chapter-content">
   <section aria-labelledby="c19_1" class="calibre2" epub:type="chapter" role="doc-chapter">
    <header class="calibre10">
     <h1 class="calibre16" id="c19_1">
      <span aria-label="761" class="calibre17" epub:type="pagebreak" id="Page_761" role="doc-pagebreak">
      </span>
      <span class="calibre" id="c19">
      </span>
      <span class="calibre">
       19
      </span>
      <br class="calibre12"/>
      <span class="calibre">
       Function Pointers, Function Objects, and Lambda Expressions
      </span>
     </h1>
    </header>
    <section aria-label="chapter opening" class="calibre2">
     <span class="calibre" id="c19-sec-0001">
     </span>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <h3 class="calibre30">
         WHAT'S IN THIS CHAPTER?
        </h3>
        <ul class="check2" id="c19-list-0001">
         <li class="calibre9" id="c19-li-0001">
          How to use function pointers
         </li>
         <li class="calibre9" id="c19-li-0002">
          How to use pointers to class member functions
         </li>
         <li class="calibre9" id="c19-li-0003">
          What function objects are
         </li>
         <li class="calibre9" id="c19-li-0004">
          Which standard function objects are available and how to write your own
         </li>
         <li class="calibre9" id="c19-li-0005">
          How to use polymorphic function wrappers
         </li>
         <li class="calibre9" id="c19-li-0006">
          What lambda expressions are
         </li>
        </ul>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature1">
        <span class="calibre" id="c19-fea-0001">
        </span>
        <h3 class="calibre30" id="head-2-206">
         WILEY.COM DOWNLOADS FOR THIS CHAPTER
        </h3>
        <span class="calibre" id="c19-sec-0003">
        </span>
        <p class="calibre25" id="c19-para-0003">
         Please note that all the code examples for this chapter are available as part of this chapter's code download on the book's website at
         <code class="calibre21">
          <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
           www.wiley.com/go/proc++6e
          </a>
         </code>
         on the Download Code tab.
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13" id="c19-para-0004">
      Functions in C++ are
      <i class="calibre18">
       first-class functions
      </i>
      , as functions can be used in the same way as normal variables, such as passing them as arguments to other functions, returning them from other functions, and assigning them to variables. A term that often comes up in this context is a
      <i class="calibre18">
       callback
      </i>
      , representing something that can be called. It can be a function pointer or something that behaves like a function pointer, such as an object with an overloaded
      <code class="calibre21">
       operator
      </code>
      (
      <code class="calibre21">
       )
      </code>
      , or an inline lambda expression. A class that overloads
      <code class="calibre21">
       operator()
      </code>
      is called a
      <i class="calibre18">
       function object
      </i>
      , or
      <i class="calibre18">
       functor
      </i>
      for
      <span aria-label="762" class="calibre20" epub:type="pagebreak" id="Page_762" role="doc-pagebreak">
      </span>
      short. Conveniently, the Standard Library provides a set of classes that can be used to create callback objects and to adapt existing callback objects. Lambda expressions allow you to create small inline callbacks right at the place where you need them, which improves the readability and maintainability of your code. It's time to take a closer look at the concept of callbacks, because many of the algorithms explained in the next chapter accept such callbacks to customize their behavior.
     </p>
    </section>
    <section aria-labelledby="head-2-207" class="calibre2">
     <span class="calibre" id="c19-sec-0004">
     </span>
     <h2 class="calibre6" id="head-2-207">
      FUNCTION POINTERS
     </h2>
     <p class="calibre13" id="c19-para-0005">
      You don't normally think about the location of functions in memory, but each function actually lives at a particular address. In C++, you can use
      <i class="calibre18">
       functions as data
      </i>
      ; that is, C++ has first-class functions. In other words, you can take the address of a function and use it like you use a variable.
     </p>
     <p class="calibre13">
      Function pointers are typed according to the parameter types and return type of compatible functions. Here's an example of a definition for a variable called
      <code class="calibre21">
       fun
      </code>
      capable of pointing to functions returning a Boolean and accepting two
      <code class="calibre21">
       int
      </code>
      arguments:
     </p>
     <pre class="calibre26" id="c19-code-0001"><code class="calibre21">bool (*fun)(int, int);</code></pre>
     <p class="calibre13">
      Don't forget the parentheses around
      <code class="calibre21">
       *fun
      </code>
      ; otherwise, this statement would not be a variable but a function prototype for a function named
      <code class="calibre21">
       fun
      </code>
      , accepting two
      <code class="calibre21">
       int
      </code>
      s and returning a pointer to a
      <code class="calibre21">
       bool
      </code>
      . The
      <code class="calibre21">
       fun
      </code>
      function pointer is uninitialized. As you know, uninitialized data should be avoided. You could initialize
      <code class="calibre21">
       fun
      </code>
      to
      <code class="calibre21">
       nullptr
      </code>
      as follows:
     </p>
     <pre class="calibre26" id="c19-code-0002"><code class="calibre21">bool (*fun)(int, int) { nullptr };</code></pre>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0005">
      </span>
      <h3 class="calibre27" id="head-3-419">
       findMatches() Using Function Pointers
      </h3>
      <p class="calibre13">
       Another way to work with function pointers is to use type aliases. A type alias allows you to assign a type name to the family of functions that have the given characteristics. For example, the following defines a type called
       <code class="calibre21">
        Matcher
       </code>
       representing a pointer to any function that has two
       <code class="calibre21">
        int
       </code>
       parameters and returns a
       <code class="calibre21">
        bool
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0003"><code class="calibre21">using Matcher = bool(*)(int, int);</code></pre>
      <p class="calibre13">
       The following type alias defines a type called
       <code class="calibre21">
        MatchHandler
       </code>
       for functions accepting a
       <code class="calibre21">
        size_t
       </code>
       and two
       <code class="calibre21">
        int
       </code>
       s and returning nothing:
      </p>
      <pre class="calibre26" id="c19-code-0004"><code class="calibre21">using MatchHandler = void(*)(size_t, int, int);</code></pre>
      <p class="calibre13">
       Now that these types are defined, you can write a function that takes two callbacks as parameters: a
       <code class="calibre21">
        Matcher
       </code>
       and a
       <code class="calibre21">
        MatchHandler
       </code>
       . Functions that accept other functions as parameters, or functions that return a function are called
       <i class="calibre18">
        higher-order functions
       </i>
       . For example, the following function accepts two
       <code class="calibre21">
        span
       </code>
       s of integers, as well as a
       <code class="calibre21">
        Matcher
       </code>
       and
       <code class="calibre21">
        MatchHandler
       </code>
       . It iterates through the
       <code class="calibre21">
        span
       </code>
       s in parallel and calls the
       <code class="calibre21">
        Matcher
       </code>
       on corresponding elements of both
       <code class="calibre21">
        span
       </code>
       s. If the
       <code class="calibre21">
        Matcher
       </code>
       returns
       <code class="calibre21">
        true
       </code>
       , the
       <code class="calibre21">
        MatchHandler
       </code>
       is called with as first argument the position of the match, and as second and third arguments the values that caused the
       <code class="calibre21">
        Matcher
       </code>
       to return
       <code class="calibre21">
        true
       </code>
       . Notice that even though the
       <code class="calibre21">
        Matcher
       </code>
       and
       <code class="calibre21">
        MatchHandler
       </code>
       are passed in as variables, they can be called just like regular functions:
      </p>
      <pre class="calibre26" id="c19-code-0005"><code class="calibre21">void findMatches(span&lt;const int&gt; values1, span&lt;const int&gt; values2,</code>
<code class="calibre21">    Matcher matcher, MatchHandler handler)</code>
<code class="calibre21">{</code>
<span aria-label="763" class="calibre20" epub:type="pagebreak" id="Page_763" role="doc-pagebreak"></span><code class="calibre21">    if (values1.size() != values2.size()) { return; } <span class="color">// Must be same size.</span></code>
<code class="calibre21"> </code>
<code class="calibre21">    for (size_t i { 0 }; i &lt; values1.size(); ++i) {</code>
<code class="calibre21">        if (matcher(values1[i], values2[i])) {</code>
<code class="calibre21">            handler(i, values1[i], values2[i]);</code>
<code class="calibre21">        }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       Note that this implementation requires that both
       <code class="calibre21">
        span
       </code>
       s have the same number of elements. To call the
       <code class="calibre21">
        findMatches()
       </code>
       function, all you need is any function that adheres to the defined
       <code class="calibre21">
        Matcher
       </code>
       type—that is, any function that takes in two
       <code class="calibre21">
        int
       </code>
       s and returns a
       <code class="calibre21">
        bool
       </code>
       —and a function that adheres to the
       <code class="calibre21">
        MatchHandler
       </code>
       type. Here is an example of a possible
       <code class="calibre21">
        Matcher
       </code>
       , returning
       <code class="calibre21">
        true
       </code>
       if the two parameters are equal:
      </p>
      <pre class="calibre26" id="c19-code-0006"><code class="calibre21">bool intEqual(int value1, int value2) { return value1 == value2; }</code></pre>
      <p class="calibre13">
       The following is an example of a
       <code class="calibre21">
        MatchHandler
       </code>
       that simply prints out the match:
      </p>
      <pre class="calibre26" id="c19-code-0007"><code class="calibre21">void printMatch(size_t position, int value1, int value2)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("Match found at position {} ({}, {})", position, value1, value2);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        intEqual()
       </code>
       and
       <code class="calibre21">
        printMatch()
       </code>
       functions can be passed as arguments to
       <code class="calibre21">
        findMatches()
       </code>
       , as follows:
      </p>
      <pre class="calibre26" id="c19-code-0008"><code class="calibre21">vector values1 { 2, 5, 6, 9, 10, 1, 1 };</code>
<code class="calibre21">vector values2 { 4, 4, 2, 9, 0, 3, 1 };</code>
<code class="calibre21">println("Calling findMatches() using intEqual():");</code>
<code class="calibre21">findMatches(values1, values2, &amp;intEqual, &amp;printMatch);</code></pre>
      <p class="calibre13">
       The callback functions are passed to
       <code class="calibre21">
        findMatches()
       </code>
       by taking their addresses. Technically, the
       <code class="calibre21">
        &amp;
       </code>
       is optional—if you omit it and only put the function name, the compiler will know that you mean to take its address. The output is as follows:
      </p>
      <pre class="calibre26" id="c19-code-0009"><code class="calibre21">Calling findMatches() using intEqual():</code>
<code class="calibre21">Match found at position 3 (9, 9)</code>
<code class="calibre21">Match found at position 6 (1, 1)</code></pre>
      <p class="calibre13">
       The benefit of function pointers lies in the fact that
       <code class="calibre21">
        findMatches()
       </code>
       is a generic function that compares parallel values in two
       <code class="calibre21">
        vector
       </code>
       s. As it is used in the previous example, it compares values based on equality. However, because it takes a function pointer, it could compare values based on other criteria. For example, the following function also adheres to the definition of
       <code class="calibre21">
        Matcher
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0010"><code class="calibre21">bool bothOdd(int value1, int value2) { return value1 % 2 == 1 &amp;&amp; value2 % 2 == 1; }</code></pre>
      <p class="calibre13">
       The following code snippet shows that
       <code class="calibre21">
        bothOdd()
       </code>
       can also be used in a call to
       <code class="calibre21">
        findMatches()
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0011"><code class="calibre21">println("Calling findMatches() using bothOdd():");</code>
<code class="calibre21">findMatches(values1, values2, bothOdd, printMatch);</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c19-code-0012"><code class="calibre21">Calling findMatches() using bothOdd():</code>
<code class="calibre21">Match found at position 3 (9, 9)</code>
<code class="calibre21">Match found at position 5 (1, 3)</code>
<code class="calibre21">Match found at position 6 (1, 1)</code></pre>
      <p class="calibre13" id="c19-para-0018">
       <span aria-label="764" class="calibre20" epub:type="pagebreak" id="Page_764" role="doc-pagebreak">
       </span>
       By using function pointers, a single function,
       <code class="calibre21">
        findMatches()
       </code>
       , can be customized to different uses based on functions/callbacks passed in as arguments.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0006">
      </span>
      <h3 class="calibre27" id="head-3-420">
       findMatches() As a Function Template
      </h3>
      <p class="calibre13">
       You don't need to use explicit function pointer parameters for
       <code class="calibre21">
        findMatches()
       </code>
       to accept callback parameters. Instead, you can convert
       <code class="calibre21">
        findMatches()
       </code>
       to a function template. The only changes needed are to remove the
       <code class="calibre21">
        Matcher
       </code>
       and
       <code class="calibre21">
        MatchHandler
       </code>
       type aliases and to make
       <code class="calibre21">
        findMatches()
       </code>
       a function template. The changes are highlighted:
      </p>
      <pre class="calibre26" id="c19-code-0013"><code class="calibre21"><b class="calibre14">template &lt;typename Matcher, typename MatchHandler&gt;</b></code>
<code class="calibre21">void findMatches(span&lt;const int&gt; values1, span&lt;const int&gt; values2,</code>
<code class="calibre21">    Matcher matcher, MatchHandler handler)</code>
<code class="calibre21">{ <span class="color">/* … */</span> }</code></pre>
      <p class="calibre13">
       Better yet is the following constrained function template. The
       <code class="calibre21">
        Matcher
       </code>
       template type parameter is constrained (see
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       , “Writing Generic Code with Templates”) with
       <code class="calibre21">
        predicate&lt;int,int&gt;
       </code>
       to make sure the user supplies a callback that can be called with two
       <code class="calibre21">
        int
       </code>
       arguments and returns a Boolean. Similarly, the
       <code class="calibre21">
        MatchHandler
       </code>
       template type parameter is constrained to callbacks that can be called with one
       <code class="calibre21">
        size_t
       </code>
       argument and two
       <code class="calibre21">
        int
       </code>
       arguments and returns nothing.
      </p>
      <pre class="calibre26" id="c19-code-0014"><code class="calibre21"><b class="calibre14">template &lt;predicate&lt;int, int&gt; Matcher, invocable&lt;size_t, int, int&gt; MatchHandler&gt;</b></code>
<code class="calibre21">void findMatches(span&lt;const int&gt; values1, span&lt;const int&gt; values2,</code>
<code class="calibre21">    Matcher matcher, MatchHandler handler)</code>
<code class="calibre21">{ <span class="color">/* … */</span> }</code></pre>
      <p class="calibre13" id="c19-para-0021">
       Both these implementations of
       <code class="calibre21">
        findMatches()
       </code>
       require two template type parameters, the type of the
       <code class="calibre21">
        Matcher
       </code>
       and
       <code class="calibre21">
        MatchHandler
       </code>
       callbacks, but thanks to function template argument deduction, calling them is the same as calling the earlier versions.
      </p>
      <p class="calibre13">
       Using the abbreviated function template syntax, the
       <code class="calibre21">
        findMatches()
       </code>
       function template can be written even more elegantly as follows. Notice there is no longer an explicit template header,
       <code class="calibre21">
        template&lt;…&gt;
       </code>
       .
      </p>
      <pre class="calibre26" id="c19-code-0015"><code class="calibre21">void findMatches(span&lt;const int&gt; values1, span&lt;const int&gt; values2,</code>
<code class="calibre21">    <b class="calibre14">auto matcher, auto handler)</b></code>
<code class="calibre21">{ <span class="color">/* … */</span> }</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        matcher
       </code>
       and
       <code class="calibre21">
        handler
       </code>
       parameters can again be constrained:
      </p>
      <pre class="calibre26" id="c19-code-0016"><code class="calibre21">void findMatches(span&lt;const int&gt; values1, span&lt;const int&gt; values2,</code>
<code class="calibre21">    <b class="calibre14">predicate&lt;int, int&gt; auto matcher, invocable&lt;size_t, int, int&gt; auto handler)</b></code>
<code class="calibre21">{ <span class="color">/* … */</span> }</code></pre>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c19-para-0025">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           The
          </i>
          <code class="calibre21">
           findMatches()
          </code>
          <i class="calibre18">
           function template or abbreviated function template is actually the recommended way to implement the function, instead of using explicit function pointer parameters.
          </i>
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13" id="c19-para-0026">
       It should be clear by now that callbacks allow you to write very generic and configurable code. It's exactly such use of callbacks that make many Standard Library algorithms (discussed in
       <a class="calibre5" href="c20.xhtml">
        Chapter 20
       </a>
       , “Mastering Standard Library Algorithms”) so powerful.
      </p>
     </section>
     <span aria-label="765" class="calibre20" epub:type="pagebreak" id="Page_765" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0008">
      </span>
      <h3 class="calibre27" id="head-3-421">
       Windows DLLs and Function Pointers
      </h3>
      <p class="calibre13" id="c19-para-0027">
       One common use case for using function pointers is to obtain a pointer to a function in a dynamic link library. The following example obtains a pointer to a function in a Microsoft Windows Dynamic Link Library (DLL). A DLL is basically a library consisting of code and data that can be used by any program. An example of a specific Windows DLL is the User32 DLL, which provides, among a lot of other functionality, a function to show a message box on the screen. Details of Windows DLLs are outside the scope of this book on platform-independent C++, but it is so important to Windows programmers that it is worth discussing briefly, and it is a good example of function pointers in general.
      </p>
      <p class="calibre13">
       One function in
       <code class="calibre21">
        User32.dll
       </code>
       to show a message box is called
       <code class="calibre21">
        MessageBoxA()
       </code>
       . Suppose you would like to load this library only if you need to show a message box. Loading the library at run time can be done with the Windows
       <code class="calibre21">
        LoadLibraryA()
       </code>
       function (requires &lt;Windows.h&gt;):
      </p>
      <pre class="calibre26" id="c19-code-0017"><code class="calibre21">HMODULE lib { ::LoadLibraryA("User32.dll") };</code></pre>
      <p class="calibre13">
       The result of this call is a
       <i class="calibre18">
        library handle
       </i>
       and will be
       <code class="calibre21">
        NULL
       </code>
       if there is an error. Before you can load the function from the library, you need to know the prototype for the function. The prototype for
       <code class="calibre21">
        MessageBoxA()
       </code>
       is as follows:
      </p>
      <pre class="calibre26" id="c19-code-0018"><code class="calibre21">int MessageBoxA(HWND, LPCSTR, LPCSTR, UINT);</code></pre>
      <p class="calibre13" id="c19-para-0030">
       The first parameter is the window that owns the message box (can be NULL), the second is the string to show as the message, the third is the title of the window, and the fourth is the configuration flags for the message box, such as which buttons and which icon to show.
      </p>
      <p class="calibre13">
       You can now define a type alias
       <code class="calibre21">
        MessageBoxFunction
       </code>
       for a pointer to a function with the required prototype:
      </p>
      <pre class="calibre26" id="c19-code-0019"><code class="calibre21">using MessageBoxFunction = int(*)(HWND, LPCSTR, LPCSTR, UINT);</code></pre>
      <p class="calibre13">
       Having successfully loaded the library and defined a type alias for the function pointer, you can get a pointer to the function in the library as follows:
      </p>
      <pre class="calibre26" id="c19-code-0020"><code class="calibre21">MessageBoxFunction messageBox {</code>
<code class="calibre21">    (MessageBoxFunction)::GetProcAddress(lib, "MessageBoxA") };</code></pre>
      <p class="calibre13">
       If this fails,
       <code class="calibre21">
        messageBox
       </code>
       will be
       <code class="calibre21">
        nullptr
       </code>
       . If it succeeds, you can call the loaded function as follows.
       <code class="calibre21">
        MB_OK
       </code>
       is a flag to show only a single OK button in the message box.
      </p>
      <pre class="calibre26" id="c19-code-0021"><code class="calibre21">messageBox(NULL, "Hello World!", "ProC++", MB_OK);</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-208" class="calibre2">
     <span class="calibre" id="c19-sec-0009">
     </span>
     <h2 class="calibre6" id="head-2-208">
      POINTERS TO MEMBER FUNCTIONS (AND DATA MEMBERS)
     </h2>
     <p class="calibre13">
      As the previous section explains, you can create and use pointers to stand-alone functions. You also know that you can work with pointers to stand-alone variables. Now, consider pointers to class data members and member functions. It's perfectly legitimate in C++ to take the addresses of class data members and member functions in order to obtain pointers to them. However, you can't access a non-
      <code class="calibre21">
       static
      </code>
      data member or call a non-
      <code class="calibre21">
       static
      </code>
      member function without an object. The whole point of class data members and member functions is that they exist on a per-object basis. Thus, when you want to call member functions or access data members via a pointer, you must dereference the pointer
      <span aria-label="766" class="calibre20" epub:type="pagebreak" id="Page_766" role="doc-pagebreak">
      </span>
      in the context of an object. Here is an example using the
      <code class="calibre21">
       Employee
      </code>
      class introduced in
      <a class="calibre5" href="c01_split_000.xhtml">
       Chapter 1
      </a>
      , “A Crash Course in C++ and the Standard Library”:
     </p>
     <pre class="calibre26" id="c19-code-0022"><code class="calibre21">int (Employee::*functionPtr) () const { &amp;Employee::getSalary };</code>
<code class="calibre21">Employee employee { "John", "Doe" };</code>
<code class="calibre21">println("{}", (employee.*functionPtr)());</code></pre>
     <p class="calibre13" id="c19-para-0035">
      Don't panic at the syntax. The first line declares a variable called
      <code class="calibre21">
       functionPtr
      </code>
      of type pointer to a non-
      <code class="calibre21">
       static const
      </code>
      member function of
      <code class="calibre21">
       Employee
      </code>
      that takes no arguments and returns an
      <code class="calibre21">
       int
      </code>
      . At the same time, it initializes this variable to point to the
      <code class="calibre21">
       getSalary()
      </code>
      member function of the
      <code class="calibre21">
       Employee
      </code>
      class. This syntax is quite similar to declaring a simple function pointer, except for the addition of
      <code class="calibre21">
       Employee::
      </code>
      before the
      <code class="calibre21">
       *functionPtr
      </code>
      . Note also that the
      <code class="calibre21">
       &amp;
      </code>
      is required in this case.
     </p>
     <p class="calibre13" id="c19-para-0036">
      The third line calls the
      <code class="calibre21">
       getSalary()
      </code>
      member function (via the
      <code class="calibre21">
       functionPtr
      </code>
      pointer) on the
      <code class="calibre21">
       employee
      </code>
      object. Note the use of parentheses surrounding
      <code class="calibre21">
       employee.*functionPtr
      </code>
      . They are needed because
      <code class="calibre21">
       operator()
      </code>
      has higher precedence than
      <code class="calibre21">
       .*
      </code>
      .
     </p>
     <p class="calibre13">
      If you have a pointer to an object, you can use
      <code class="calibre21">
       -&gt;*
      </code>
      instead of
      <code class="calibre21">
       .*
      </code>
      , as the following code snippet demonstrates:
     </p>
     <pre class="calibre26" id="c19-code-0023"><code class="calibre21">int (Employee::*functionPtr) () const { &amp;Employee::getSalary };</code>
<code class="calibre21"><b class="calibre14">Employee johnD { "John", "Doe" };Employee* employee { &amp;johnD };</b></code>
<code class="calibre21"><b class="calibre14">println("{}", (employee-&gt;*functionPtr)());</b></code></pre>
     <p class="calibre13">
      The definition of
      <code class="calibre21">
       functionPtr
      </code>
      can be made easier to read with a type alias:
     </p>
     <pre class="calibre26" id="c19-code-0024"><code class="calibre21"><b class="calibre14">using PtrToGet = int (Employee::*) () const;</b></code>
<code class="calibre21"><b class="calibre14">PtrToGet functionPtr { &amp;Employee::getSalary };</b></code>
<code class="calibre21">Employee employee { "John", "Doe" };</code>
<code class="calibre21">println("{}", (employee.*functionPtr)());</code></pre>
     <p class="calibre13">
      Finally, it can be simplified even further using
      <code class="calibre21">
       auto
      </code>
      :
     </p>
     <pre class="calibre26" id="c19-code-0025"><code class="calibre21"><b class="calibre14">auto functionPtr { &amp;Employee::getSalary };</b></code>
<code class="calibre21">Employee employee { "John", "Doe" };</code>
<code class="calibre21">println("{}", (employee.*functionPtr)());</code></pre>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c19-para-0041">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          You can get rid of the
          <code class="calibre21">
           .*
          </code>
          or
          <code class="calibre21">
           -&gt;*
          </code>
          syntax by using
         </i>
         <code class="calibre21">
          std::mem_fn()
         </code>
         <i class="calibre18">
          , explained later in this chapter in the context of function objects.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
     <p class="calibre13">
      Pointers to member functions and data members won't come up often during your day-to-day programming. However, it's important to keep in mind that you cannot dereference a pointer to a non-
      <code class="calibre21">
       static
      </code>
      member function or data member without an object. Every so often, you may want to try something like passing a pointer to a non-
      <code class="calibre21">
       static
      </code>
      member function to a function such as
      <code class="calibre21">
       qsort()
      </code>
      that requires a function pointer, which simply won't work.
     </p>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c19-para-0043">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          C++ does permit you to dereference a pointer to a
         </i>
         <code class="calibre21">
          static
         </code>
         <i class="calibre18">
          data member or
         </i>
         <code class="calibre21">
          static
         </code>
         <i class="calibre18">
          member function without an object.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <span aria-label="767" class="calibre20" epub:type="pagebreak" id="Page_767" role="doc-pagebreak">
    </span>
    <section aria-labelledby="head-2-209" class="calibre2">
     <span class="calibre" id="c19-sec-0012">
     </span>
     <h2 class="calibre6" id="head-2-209">
      FUNCTION OBJECTS
     </h2>
     <p class="calibre13" id="c19-para-0044">
      You can overload the function call operator in a class such that objects of the class can be used in place of function pointers. These objects are called
      <i class="calibre18">
       function objects
      </i>
      , or
      <i class="calibre18">
       functors
      </i>
      for short. The benefits of using a function object instead of a simple function is that a function object can keep state between calls to it.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0013">
      </span>
      <h3 class="calibre27" id="head-3-422">
       Writing Your First Function Object
      </h3>
      <p class="calibre13">
       As
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       , “Overloading C++ Operators,” explains, to make any class a function object, you just have to provide an overload for the function call operator. Here is a quick reminder:
      </p>
      <pre class="calibre26" id="c19-code-0026"><code class="calibre21">class IsLargerThan</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit IsLargerThan(int value) : m_value { value } {}</code>
<code class="calibre21">        <b class="calibre14">bool operator()(int value1, int value2) const {</b></code>
<code class="calibre21">            <b class="calibre14">return value1 &gt; m_value &amp;&amp; value2 &gt; m_value;</b></code>
<code class="calibre21">        <b class="calibre14">}</b></code>
<code class="calibre21">    private:</code>
<code class="calibre21">        int m_value;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    vector values1 { 2, 500, 6, 9, 10, 101, 1 };</code>
<code class="calibre21">    vector values2 { 4, 4, 2, 9, 0, 300, 1 };</code>
<code class="calibre21"> </code>
<code class="calibre21">    findMatches(values1, values2, IsLargerThan { 100 }, printMatch);</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13" id="c19-para-0046">
       Note that the overloaded function call operator of the
       <code class="calibre21">
        IsLargerThan
       </code>
       class is marked as
       <code class="calibre21">
        const
       </code>
       . This is not strictly necessary in this example, but as the next chapter explains, for most Standard Library algorithms, the function call operator of predicates must be
       <code class="calibre21">
        const
       </code>
       .
      </p>
      <p class="calibre13" id="c19-para-0048">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Remember also from
       <a class="calibre5" href="c15.xhtml">
        Chapter 15
       </a>
       that, starting with C++23, an overloaded
       <code class="calibre21">
        operator()
       </code>
       can be marked as
       <code class="calibre21">
        static
       </code>
       if it doesn't require access to any non-
       <code class="calibre21">
        static
       </code>
       data members and member functions of the functor. Doing so allows the compiler to better optimize the code.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0014">
      </span>
      <h3 class="calibre27" id="head-3-423">
       Function Objects in the Standard Library
      </h3>
      <p class="calibre13" id="c19-para-0049">
       Many of the Standard Library algorithms discussed in the next chapter, such as
       <code class="calibre21">
        find_if()
       </code>
       ,
       <code class="calibre21">
        accumulate()
       </code>
       , and so on, accept callbacks, for example function pointers and functors, as parameters to customize the algorithm's behavior. C++ provides several predefined functor classes, defined in
       <code class="calibre21">
        &lt;functional&gt;
       </code>
       , that perform the most commonly used callback operations. This section gives an overview of these predefined functors.
      </p>
      <p class="calibre13" id="c19-para-0050">
       Your
       <code class="calibre21">
        &lt;functional&gt;
       </code>
       might also contain functions like
       <code class="calibre21">
        bind1st()
       </code>
       ,
       <code class="calibre21">
        bind2nd()
       </code>
       ,
       <code class="calibre21">
        mem_fun()
       </code>
       ,
       <code class="calibre21">
        mem_fun_ref()
       </code>
       , and
       <code class="calibre21">
        ptr_fun()
       </code>
       . These functions have officially been removed since the C++17 standard and thus are not further discussed in this book. You should avoid using them.
      </p>
      <span aria-label="768" class="calibre20" epub:type="pagebreak" id="Page_768" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c19-sec-0015">
       </span>
       <h4 class="calibre29" id="head-4-307">
        Arithmetic Function Objects
       </h4>
       <p class="calibre13">
        C++ provides functor class templates for the five binary arithmetic operators:
        <code class="calibre21">
         plus
        </code>
        ,
        <code class="calibre21">
         minus
        </code>
        ,
        <code class="calibre21">
         multiplies
        </code>
        ,
        <code class="calibre21">
         divides
        </code>
        , and
        <code class="calibre21">
         modulus
        </code>
        . Additionally, unary
        <code class="calibre21">
         negate
        </code>
        is supplied. These classes are parametrized on the type of the operands and are wrappers for the actual operators. They take one or two parameters of the template type, perform the operation, and return the result. Here is an example using the
        <code class="calibre21">
         plus
        </code>
        class template:
       </p>
       <pre class="calibre26" id="c19-code-0027"><code class="calibre21">plus&lt;int&gt; myPlus;</code>
<code class="calibre21">int res { myPlus(4, 5) };</code>
<code class="calibre21">println("{}", res);</code></pre>
       <p class="calibre13">
        This example is of course silly, because there's no reason to use the
        <code class="calibre21">
         plus
        </code>
        class template when you could just use
        <code class="calibre21">
         operator+
        </code>
        directly. The benefit of the arithmetic function objects is that you can pass them as callbacks to other functions, which you cannot do directly with the arithmetic operators. For example, the following code snippet defines a constrained
        <code class="calibre21">
         accumulateData()
        </code>
        function template accepting an
        <code class="calibre21">
         Operation
        </code>
        as its last parameter. The implementation of
        <code class="calibre21">
         geometricMean()
        </code>
        calls
        <code class="calibre21">
         accumulateData()
        </code>
        with an instance of the predefined
        <code class="calibre21">
         multiplies
        </code>
        function object:
       </p>
       <pre class="calibre26" id="c19-code-0028"><code class="calibre21">template &lt;input_iterator Iter, copy_constructible StartValue,</code>
<code class="calibre21">          invocable&lt;const StartValue&amp;, const StartValue&amp;&gt; Operation&gt;</code>
<code class="calibre21">auto accumulateData(Iter begin, Iter end,</code>
<code class="calibre21">    const StartValue&amp; startValue, <b class="calibre14">Operation op</b>)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto accumulated { startValue };</code>
<code class="calibre21">    for (Iter iter { begin }; iter != end; ++iter) {</code>
<code class="calibre21">        <b class="calibre14">accumulated = op(accumulated, *iter);</b></code>
<code class="calibre21">    }</code>
<code class="calibre21">    return accumulated;</code>
<code class="calibre21">}</code>
<code class="calibre21"> </code>
<code class="calibre21">double geometricMean(span&lt;const int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">auto mult {accumulateData(cbegin(values), cend(values), 1, multiplies&lt;int&gt;{})};</b></code>
<code class="calibre21">    return pow(mult, 1.0 / values.size()); <span class="color">// pow() is defined in &lt;cmath&gt;</span></code>
<code class="calibre21">}</code></pre>
       <p class="calibre13" id="c19-para-0053">
        The expression
        <code class="calibre21">
         multiplies&lt;int&gt;{}
        </code>
        creates a new object of the
        <code class="calibre21">
         multiplies
        </code>
        functor class template, instantiating it with type
        <code class="calibre21">
         int
        </code>
        .
       </p>
       <p class="calibre13">
        The other arithmetic function objects behave similarly.
       </p>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c19-para-0055">
           <b class="calibre14">
            WARNING
           </b>
           <i class="calibre18">
            The arithmetic function objects are just wrappers around the arithmetic operators. To use them on objects of a certain type, you have to make sure that those types implement the appropriate operations, such as
           </i>
           <code class="calibre21">
            operator*
           </code>
           <i class="calibre18">
            or
           </i>
           <code class="calibre21">
            operator+
           </code>
           <i class="calibre18">
            .
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c19-sec-0017">
        </span>
        <h5 class="calibre35" id="head-5-131">
         Transparent Operator Functors
        </h5>
        <p class="calibre13">
         C++ supports
         <i class="calibre18">
          transparent operator functors
         </i>
         , which allow you to omit the template type argument. For example, you can just specify
         <code class="calibre21">
          multiplies&lt;&gt;{}
         </code>
         , short for
         <code class="calibre21">
          multiplies&lt;void&gt;{}
         </code>
         , instead of
         <code class="calibre21">
          multiplies&lt;int&gt;{}
         </code>
         :
        </p>
        <pre class="calibre26" id="c19-code-0029"><span aria-label="769" class="calibre20" epub:type="pagebreak" id="Page_769" role="doc-pagebreak"></span><code class="calibre21">double geometricMeanTransparent(span&lt;const int&gt; values)</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto mult { accumulateData(cbegin(values), cend(values), 1, <b class="calibre14">multiplies&lt;&gt;{}</b>) };</code>
<code class="calibre21">    return pow(mult, 1.0 / values.size());</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         An important feature of these transparent operators is that they are heterogeneous. That is, they are not only more concise than the non-transparent functors, but they also have real functional advantages. For instance, the following code uses a transparent operator functor,
         <code class="calibre21">
          multiplies&lt;&gt;{}
         </code>
         , and uses 1.1, a
         <code class="calibre21">
          double
         </code>
         , as the start value, while the
         <code class="calibre21">
          vector
         </code>
         contains integers.
         <code class="calibre21">
          accumulateData()
         </code>
         calculates the result as a
         <code class="calibre21">
          double
         </code>
         , and
         <code class="calibre21">
          result
         </code>
         will be 6.6.
        </p>
        <pre class="calibre26" id="c19-code-0030"><code class="calibre21">vector&lt;int&gt; values { 1, 2, 3 };</code>
<code class="calibre21">double result {accumulateData(cbegin(values), cend(values), 1.1, <b class="calibre14">multiplies&lt;&gt;{})};</b></code></pre>
        <p class="calibre13">
         If this code uses a non-transparent operator functor,
         <code class="calibre21">
          multiplies&lt;int&gt;{}
         </code>
         , then
         <code class="calibre21">
          accumulateData()
         </code>
         calculates the result as an integer, and
         <code class="calibre21">
          result
         </code>
         will be 6. When you compile this code, the compiler will give you warnings about possible loss of data.
        </p>
        <pre class="calibre26" id="c19-code-0031"><code class="calibre21">vector&lt;int&gt; values { 1, 2, 3 };</code>
<code class="calibre21">double result {</code>
<code class="calibre21">    accumulateData(cbegin(values), cend(values), 1.1, <b class="calibre14">multiplies&lt;int&gt;{}</b>) };</code></pre>
        <p class="calibre13">
         Finally, using transparent operators instead of the non-transparent ones can improve performance, as shown with an example in the next section.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c19-para-0060">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             It's recommended to always use the transparent operator functors
            </i>
            .
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c19-sec-0019">
       </span>
       <h4 class="calibre29" id="head-4-308">
        Comparison Function Objects
       </h4>
       <p class="calibre13">
        In addition to the arithmetic function object classes, all standard comparison operations are also available as functors:
        <code class="calibre21">
         equal_to
        </code>
        ,
        <code class="calibre21">
         not_equal_to
        </code>
        ,
        <code class="calibre21">
         less
        </code>
        ,
        <code class="calibre21">
         greater
        </code>
        ,
        <code class="calibre21">
         less_equal
        </code>
        , and
        <code class="calibre21">
         greater_equal
        </code>
        . You've already seen
        <code class="calibre21">
         less
        </code>
        in
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        , “Standard Library Containers,” as the default comparator for elements in the
        <code class="calibre21">
         priority_queue
        </code>
        , the ordered associative containers, and the flat associative container adapters. Now you can learn how to change that criterion. Here's an example of a
        <code class="calibre21">
         priority_queue
        </code>
        using the default comparator,
        <code class="calibre21">
         std::less
        </code>
        :
       </p>
       <pre class="calibre26" id="c19-code-0032"><code class="calibre21">priority_queue&lt;int&gt; myQueue;</code>
<code class="calibre21">myQueue.push(3);</code>
<code class="calibre21">myQueue.push(4);</code>
<code class="calibre21">myQueue.push(2);</code>
<code class="calibre21">myQueue.push(1);</code>
<code class="calibre21">while (!myQueue.empty()) {</code>
<code class="calibre21">    print("{} ", myQueue.top());</code>
<code class="calibre21">    myQueue.pop();</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Here is the output from the program:
       </p>
       <pre class="calibre26" id="c19-code-0033"><code class="calibre21">4 3 2 1</code></pre>
       <p class="calibre13">
        <span aria-label="770" class="calibre20" epub:type="pagebreak" id="Page_770" role="doc-pagebreak">
        </span>
        As you can see, the elements of the queue are removed in descending order, according to the
        <code class="calibre21">
         less
        </code>
        comparator. You can change the comparator to
        <code class="calibre21">
         greater
        </code>
        by specifying it as the comparator template type argument. The
        <code class="calibre21">
         priority_queue
        </code>
        template definition looks like this:
       </p>
       <pre class="calibre26" id="c19-code-0034"><code class="calibre21">template &lt;typename T, typename Container = vector&lt;T&gt;, typename Compare = less&lt;T&gt;&gt;;</code></pre>
       <p class="calibre13">
        Unfortunately, the
        <code class="calibre21">
         Compare
        </code>
        type parameter is last, which means that to specify it, you must also specify the container type. If you want to use a
        <code class="calibre21">
         priority_queue
        </code>
        that sorts the elements in ascending order using
        <code class="calibre21">
         greater
        </code>
        , then you need to change the definition of the
        <code class="calibre21">
         priority_queue
        </code>
        in the previous example to the following:
       </p>
       <pre class="calibre26" id="c19-code-0035"><code class="calibre21">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; myQueue;</code></pre>
       <p class="calibre13">
        The output now is as follows:
       </p>
       <pre class="calibre26" id="c19-code-0036"><code class="calibre21">1 2 3 4</code></pre>
       <p class="calibre13">
        Note that
        <code class="calibre21">
         myQueue
        </code>
        is defined with a transparent operator,
        <code class="calibre21">
         greater&lt;&gt;
        </code>
        . In fact, it's recommended to always use a transparent operator for Standard Library containers that accept a comparator type. Using a transparent comparator can be more performant compared to using a non-transparent operator. For example, if a
        <code class="calibre21">
         set&lt;string&gt;
        </code>
        uses a non-transparent comparator (which is the default), performing a query for a key given as a string literal causes an unwanted copy to be created, because a
        <code class="calibre21">
         string
        </code>
        instance has to be constructed from the string literal:
       </p>
       <pre class="calibre26" id="c19-code-0037"><code class="calibre21">set&lt;string&gt; mySet;</code>
<code class="calibre21">auto i1 { mySet.find("Key") };      <span class="color">// string constructed, allocates memory!</span></code>
<code class="calibre21"><span class="color">//auto i2 { mySet.find("Key"sv) };  // Compilation error!</span></code></pre>
       <p class="calibre13">
        When using a transparent comparator, this copying is avoided. This is called
        <i class="calibre18">
         heterogeneous lookups
        </i>
        . Here's an example:
       </p>
       <pre class="calibre26" id="c19-code-0038"><code class="calibre21">set&lt;string, <b class="calibre14">less&lt;&gt;</b>&gt; mySet;</code>
<code class="calibre21">auto i1 { mySet.find("Key") };   <span class="color">// No string constructed, no memory allocated.</span></code>
<code class="calibre21">auto i2 { mySet.find("Key"sv) }; <span class="color">// No string constructed, no memory allocated.</span></code></pre>
       <p class="calibre13" id="c19-para-0068">
        Similarly, C++23 adds support for
        <i class="calibre18">
         heterogeneous erasure and extraction
        </i>
        using
        <code class="calibre21">
         erase()
        </code>
        and
        <code class="calibre21">
         extract()
        </code>
        .
       </p>
       <p class="calibre13">
        Unordered associative containers, such as
        <code class="calibre21">
         unordered_map
        </code>
        and
        <code class="calibre21">
         unordered_set
        </code>
        , also support transparent operators. Using a transparent operator with unordered associative containers is a bit more involved compared to using them for ordered associative containers. Basically, a custom hash functor needs to be implemented, containing an
        <code class="calibre21">
         is_transparent
        </code>
        type alias defined as
        <code class="calibre21">
         void
        </code>
        :
       </p>
       <pre class="calibre26" id="c19-code-0039"><code class="calibre21">class Hasher</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        using is_transparent = void;</code>
<code class="calibre21">        size_t operator()(string_view sv) const { return hash&lt;string_view&gt;{}(sv); }</code>
<code class="calibre21">};</code></pre>
       <p class="calibre13">
        When using this custom hasher, you also need to specify the transparent
        <code class="calibre21">
         equal_to&lt;&gt;
        </code>
        functor as the type for the key equality template type parameter. Here is an example:
       </p>
       <pre class="calibre26" id="c19-code-0040"><code class="calibre21">unordered_set&lt;string, <b class="calibre14">Hasher, equal_to&lt;&gt;</b>&gt; mySet;</code>
<code class="calibre21">auto i1 { mySet.find("Key") };   <span class="color">// No string constructed, no memory allocated.</span></code>
<code class="calibre21">auto i2 { mySet.find("Key"sv) }; <span class="color">// No string constructed, no memory allocated.</span></code></pre>
      </section>
      <span aria-label="771" class="calibre20" epub:type="pagebreak" id="Page_771" role="doc-pagebreak">
      </span>
      <section class="calibre2">
       <span class="calibre" id="c19-sec-0020">
       </span>
       <h4 class="calibre29" id="head-4-309">
        Logical Function Objects
       </h4>
       <p class="calibre13" id="c19-para-0071">
        For the three logical operations,
        <code class="calibre21">
         operator!
        </code>
        ,
        <code class="calibre21">
         &amp;&amp;
        </code>
        , and
        <code class="calibre21">
         ||
        </code>
        , C++ provides the following function object classes:
        <code class="calibre21">
         logical_not
        </code>
        ,
        <code class="calibre21">
         logical_and
        </code>
        , and
        <code class="calibre21">
         logical_or
        </code>
        . These logical operations deal only with the values
        <code class="calibre21">
         true
        </code>
        and
        <code class="calibre21">
         false
        </code>
        . Bitwise function objects are covered in the next section.
       </p>
       <p class="calibre13">
        Logical functors can, for example, be used to implement an
        <code class="calibre21">
         allTrue()
        </code>
        function that checks whether all the Boolean flags in a container are
        <code class="calibre21">
         true
        </code>
        :
       </p>
       <pre class="calibre26" id="c19-code-0041"><code class="calibre21">bool allTrue(const vector&lt;bool&gt;&amp; flags)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return accumulateData(begin(flags), end(flags), true, <b class="calibre14">logical_and&lt;&gt;{}</b>);</code>
<code class="calibre21">}</code></pre>
       <p class="calibre13">
        Similarly, the
        <code class="calibre21">
         logical_or
        </code>
        functor can be used to implement an
        <code class="calibre21">
         anyTrue()
        </code>
        function that returns
        <code class="calibre21">
         true
        </code>
        if there is at least one Boolean flag in a container
        <code class="calibre21">
         true
        </code>
        :
       </p>
       <pre class="calibre26" id="c19-code-0042"><code class="calibre21">bool anyTrue(const vector&lt;bool&gt;&amp; flags)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return accumulateData(begin(flags), end(flags), false, <b class="calibre14">logical_or&lt;&gt;{}</b>);</code>
<code class="calibre21">}</code></pre>
       <section class="calibre2">
        <aside class="calibre23">
         <div class="top">
          <hr class="calibre24"/>
         </div>
         <section class="feature">
          <p class="calibre25" id="c19-para-0075">
           <b class="calibre14">
            NOTE
           </b>
           <i class="calibre18">
            The
           </i>
           <code class="calibre21">
            allTrue()
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            anyTrue()
           </code>
           <i class="calibre18">
            functions are just given as examples. In fact, the Standard Library provides the
           </i>
           <code class="calibre21">
            std::all_of()
           </code>
           <i class="calibre18">
            and
           </i>
           <code class="calibre21">
            any_of()
           </code>
           <i class="calibre18">
            algorithms (see
            <a class="calibre5" href="c20.xhtml">
             Chapter 20
            </a>
            ) that perform the same operations but that have the benefit of short-circuiting (see
            <a class="calibre5" href="c01_split_000.xhtml">
             Chapter 1
            </a>
            ), so they are more performant.
           </i>
          </p>
          <div class="top">
           <hr class="calibre24"/>
          </div>
         </section>
        </aside>
       </section>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c19-sec-0022">
       </span>
       <h4 class="calibre29" id="head-4-310">
        Bitwise Function Objects
       </h4>
       <p class="calibre13" id="c19-para-0076">
        C++ has function objects
        <code class="calibre21">
         bit_and
        </code>
        ,
        <code class="calibre21">
         bit_or
        </code>
        ,
        <code class="calibre21">
         bit_xor
        </code>
        , and
        <code class="calibre21">
         bit_not
        </code>
        , corresponding to the bitwise operations
        <code class="calibre21">
         operator&amp;
        </code>
        ,
        <code class="calibre21">
         |
        </code>
        ,
        <code class="calibre21">
         ^
        </code>
        , and
        <code class="calibre21">
         ~
        </code>
        . These bitwise functors can, for example, be used together with the
        <code class="calibre21">
         transform()
        </code>
        algorithm (discussed in
        <a class="calibre5" href="c20.xhtml">
         Chapter 20
        </a>
        ) to perform bitwise operations on all elements in a container.
       </p>
      </section>
      <section class="calibre2">
       <span class="calibre" id="c19-sec-0023">
       </span>
       <h4 class="calibre29" id="head-4-311">
        Adapter Function Objects
       </h4>
       <p class="calibre13" id="c19-para-0077">
        When you try to use the basic function objects provided by the standard, it often feels as if you're trying to put a square peg into a round hole. If you want to use one of the standard function objects, but the signature doesn't quite match your requirements, then you can use
        <i class="calibre18">
         adapter function objects
        </i>
        to attempt to rectify the signature mismatch. They allow you to adapt function objects, function pointers, basically any callable. The adapters provide a modicum of support for
        <i class="calibre18">
         functional composition
        </i>
        , that is, to combine functions together to create the exact behavior you need.
       </p>
       <section class="calibre2">
        <span class="calibre" id="c19-sec-0024">
        </span>
        <h5 class="calibre35" id="head-5-132">
         Binders
        </h5>
        <p class="calibre13">
         <i class="calibre18">
          Binders
         </i>
         can be used to
         <i class="calibre18">
          bind
         </i>
         parameters of callables to certain values. A first binder is
         <code class="calibre21">
          std::bind()
         </code>
         , defined in
         <code class="calibre21">
          &lt;functional&gt;
         </code>
         , which allows you to bind parameters of a callable in a flexible way. You can bind parameters to fixed values, and you can even rearrange parameters in a different order.
         <span aria-label="772" class="calibre20" epub:type="pagebreak" id="Page_772" role="doc-pagebreak">
         </span>
         It is best explained with an example. Suppose you have a function called
         <code class="calibre21">
          func()
         </code>
         accepting two arguments:
        </p>
        <pre class="calibre26" id="c19-code-0043"><code class="calibre21">void func(int num, string_view str)</code>
<code class="calibre21">{</code>
<code class="calibre21">    println("func({}, {})", num, str);</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13">
         The following code demonstrates how you can use
         <code class="calibre21">
          bind()
         </code>
         to bind the second argument of
         <code class="calibre21">
          func()
         </code>
         to a fixed value,
         <code class="calibre21">
          myString
         </code>
         . The result is stored in
         <code class="calibre21">
          f1()
         </code>
         . The
         <code class="calibre21">
          auto
         </code>
         keyword is used because the return type of
         <code class="calibre21">
          bind()
         </code>
         is unspecified by the C++ standard and thus is implementation specific. Arguments that are not bound to specific values should be specified as
         <code class="calibre21">
          _1
         </code>
         ,
         <code class="calibre21">
          _2
         </code>
         ,
         <code class="calibre21">
          _3
         </code>
         , and so on. These are defined in the
         <code class="calibre21">
          std::placeholders
         </code>
         namespace. In the definition of
         <code class="calibre21">
          f1()
         </code>
         , the
         <code class="calibre21">
          _1
         </code>
         specifies where the first argument to
         <code class="calibre21">
          f1()
         </code>
         needs to go when
         <code class="calibre21">
          func()
         </code>
         is called. The result:
         <code class="calibre21">
          f1()
         </code>
         can be called with just a single integer argument:
        </p>
        <pre class="calibre26" id="c19-code-0044"><code class="calibre21">string myString { "abc" };</code>
<code class="calibre21">auto f1 { bind(func, placeholders::_1, myString) };</code>
<code class="calibre21">f1(16);</code></pre>
        <p class="calibre13">
         Here is the output:
        </p>
        <pre class="calibre26" id="c19-code-0045"><code class="calibre21">func(16, abc)</code></pre>
        <p class="calibre13">
         <code class="calibre21">
          bind()
         </code>
         can also be used to rearrange the arguments, as shown in the following code. The
         <code class="calibre21">
          _2
         </code>
         specifies where the second argument to
         <code class="calibre21">
          f2()
         </code>
         needs to go when
         <code class="calibre21">
          func()
         </code>
         is called. In other words, the
         <code class="calibre21">
          f2()
         </code>
         binding means that the first argument to
         <code class="calibre21">
          f2()
         </code>
         will become the second argument to
         <code class="calibre21">
          func()
         </code>
         , and the second argument to
         <code class="calibre21">
          f2()
         </code>
         will become the first argument to
         <code class="calibre21">
          func()
         </code>
         :
        </p>
        <pre class="calibre26" id="c19-code-0046"><code class="calibre21">auto f2 { bind(func, placeholders::_2, placeholders::_1) };</code>
<code class="calibre21">f2("Test", 32);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c19-code-0047"><code class="calibre21">func(32, Test)</code></pre>
        <p class="calibre13">
         As discussed in
         <a class="calibre5" href="c18_split_000.xhtml">
          Chapter 18
         </a>
         ,
         <code class="calibre21">
          &lt;functional&gt;
         </code>
         defines the
         <code class="calibre21">
          std::ref()
         </code>
         and
         <code class="calibre21">
          cref()
         </code>
         helper function templates. These can be used to bind references-to-non-
         <code class="calibre21">
          const
         </code>
         and references-to-
         <code class="calibre21">
          const
         </code>
         , respectively. For example, suppose you have the following function:
        </p>
        <pre class="calibre26" id="c19-code-0048"><code class="calibre21">void increment(int&amp; value) { ++value; }</code></pre>
        <p class="calibre13">
         If you call this function as follows, then the value of
         <code class="calibre21">
          index
         </code>
         becomes 1:
        </p>
        <pre class="calibre26" id="c19-code-0049"><code class="calibre21">int index { 0 };</code>
<code class="calibre21">increment(index);</code></pre>
        <p class="calibre13">
         If you use
         <code class="calibre21">
          bind()
         </code>
         to call it as follows, then the value of
         <code class="calibre21">
          index
         </code>
         is not incremented because a copy of
         <code class="calibre21">
          index
         </code>
         is made, and a reference to this copy is bound to the first parameter of the
         <code class="calibre21">
          increment()
         </code>
         function:
        </p>
        <pre class="calibre26" id="c19-code-0050"><code class="calibre21">auto incr { bind(increment, index) };</code>
<code class="calibre21">incr();</code></pre>
        <p class="calibre13">
         Using
         <code class="calibre21">
          std::ref()
         </code>
         to pass a proper reference correctly increments
         <code class="calibre21">
          index
         </code>
         :
        </p>
        <pre class="calibre26" id="c19-code-0051"><code class="calibre21">auto incr { bind(increment, ref(index)) };</code>
<code class="calibre21">incr();</code></pre>
        <p class="calibre13">
         <span aria-label="773" class="calibre20" epub:type="pagebreak" id="Page_773" role="doc-pagebreak">
         </span>
         There is a small issue with binding parameters in combination with overloaded functions. Suppose you have the following two
         <code class="calibre21">
          overloaded()
         </code>
         functions. One accepts an integer, and the other accepts a floating-point number:
        </p>
        <pre class="calibre26" id="c19-code-0052"><code class="calibre21">void overloaded(int num) {}</code>
<code class="calibre21">void overloaded(float f) {}</code></pre>
        <p class="calibre13">
         If you want to use
         <code class="calibre21">
          bind()
         </code>
         with these overloaded functions, you need to explicitly specify which of the two overloads you want to bind. The following will not compile:
        </p>
        <pre class="calibre26" id="c19-code-0053"><code class="calibre21">auto f3 { bind(overloaded, placeholders::_1) }; <span class="color">// ERROR</span></code></pre>
        <p class="calibre13">
         If you want to bind the parameters of the overloaded function accepting a floating-point argument, you need the following syntax:
        </p>
        <pre class="calibre26" id="c19-code-0054"><code class="calibre21">auto f4 { bind((void(*)(float))overloaded, placeholders::_1) }; <span class="color">// OK</span></code></pre>
        <p class="calibre13">
         Another example of
         <code class="calibre21">
          bind()
         </code>
         is to use
         <code class="calibre21">
          findMatches()
         </code>
         (defined earlier in this chapter) with a member function of a class as
         <code class="calibre21">
          MatchHandler
         </code>
         . For example, suppose you have the following
         <code class="calibre21">
          Handler
         </code>
         class:
        </p>
        <pre class="calibre26" id="c19-code-0055"><code class="calibre21">class Handler</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        void handleMatch(size_t position, int value1, int value2)</code>
<code class="calibre21">        {</code>
<code class="calibre21">            println("Match found at position {} ({}, {})",</code>
<code class="calibre21">                position, value1, value2);</code>
<code class="calibre21">        }</code>
<code class="calibre21">};</code></pre>
        <p class="calibre13">
         How to pass the
         <code class="calibre21">
          handleMatch()
         </code>
         member function as the last argument to
         <code class="calibre21">
          findMatches()
         </code>
         ? The problem here is that a member function must always be called in the context of an object. Technically, every member function of a class has an implicit first parameter, containing a pointer to an object instance and accessible in the member function's body with the name
         <code class="calibre21">
          this
         </code>
         . So, there is a signature mismatch, as our
         <code class="calibre21">
          MatchHandler
         </code>
         type accepts only three arguments: a
         <code class="calibre21">
          size_t
         </code>
         and two
         <code class="calibre21">
          int
         </code>
         s. The solution is to bind this implicit first parameter as follows:
        </p>
        <pre class="calibre26" id="c19-code-0056"><code class="calibre21"><b class="calibre14">Handler handler;</b></code>
<code class="calibre21">findMatches(values1, values2, intEqual, <b class="calibre14">bind(&amp;Handler::handleMatch, &amp;handler,</b></code>
<code class="calibre21">            <b class="calibre14">placeholders::_1, placeholders::_2, placeholders::_3)</b>);</code></pre>
        <p class="calibre13">
         You can also use
         <code class="calibre21">
          bind()
         </code>
         to bind parameters of standard function objects. For example, you can bind the second parameter of
         <code class="calibre21">
          greater_equal
         </code>
         to always compare with a fixed value:
        </p>
        <pre class="calibre26" id="c19-code-0057"><code class="calibre21">auto greaterEqualTo100 { bind(greater_equal&lt;&gt;{}, placeholders::_1, 100) };</code></pre>
        <p class="calibre13">
         The Standard Library provides two more binder function objects:
         <code class="calibre21">
          std::bind_front()
         </code>
         and
         <code class="calibre21">
          bind_back()
         </code>
         . The latter is introduced with C++23. They both wrap a callable
         <code class="calibre21">
          f
         </code>
         . When calling a
         <code class="calibre21">
          bind_front()
         </code>
         wrapper, the first
         <code class="calibre21">
          n
         </code>
         number of arguments for
         <code class="calibre21">
          f
         </code>
         are bound to a given set of values. For
         <code class="calibre21">
          bind_back()
         </code>
         , the last
         <code class="calibre21">
          n
         </code>
         number of arguments for
         <code class="calibre21">
          f
         </code>
         are bound. Here are two examples:
        </p>
        <pre class="calibre26" id="c19-code-0058"><code class="calibre21">auto f5 { <b class="calibre14">bind_front</b>(func, 42) };</code>
<code class="calibre21">f5("Hello");</code>
<code class="calibre21"> </code>
<code class="calibre21">auto f6 { <b class="calibre14">bind_back</b>(func, "Hello")};</code>
<code class="calibre21">f6(42);</code></pre>
        <p class="calibre13">
         <span aria-label="774" class="calibre20" epub:type="pagebreak" id="Page_774" role="doc-pagebreak">
         </span>
         This generates the following output:
        </p>
        <pre class="calibre26" id="c19-code-0059"><code class="calibre21">func(42, Hello)</code>
<code class="calibre21">func(42, Hello)</code></pre>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c19-para-0096">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             Before C++11 there was
            </i>
            <code class="calibre21">
             bind2nd()
            </code>
            <i class="calibre18">
             and
            </i>
            <code class="calibre21">
             bind1st()
            </code>
            <i class="calibre18">
             . Both are removed since the C++17 standard. Use lambda expressions, discussed later in this chapter, or
            </i>
            <code class="calibre21">
             bind()
            </code>
            <i class="calibre18">
             ,
            </i>
            <code class="calibre21">
             bind_front()
            </code>
            <i class="calibre18">
             , or
            </i>
            <code class="calibre21">
             bind_back()
            </code>
            <i class="calibre18">
             instead.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c19-sec-0026">
        </span>
        <h5 class="calibre35" id="head-5-133">
         Negator
        </h5>
        <p class="calibre13">
         <code class="calibre21">
          not_fn()
         </code>
         is a
         <i class="calibre18">
          negator
         </i>
         , similar to a binder, but it complements the result of a callable. For example, if you want to use
         <code class="calibre21">
          findMatches()
         </code>
         to find pairs of non-equal values, you can apply the
         <code class="calibre21">
          not_fn()
         </code>
         negator adapter to the result of
         <code class="calibre21">
          intEqual()
         </code>
         like this:
        </p>
        <pre class="calibre26" id="c19-code-0060"><code class="calibre21">findMatches(values1, values2, <b class="calibre14">not_fn(intEqual)</b>, printMatch);</code></pre>
        <p class="calibre13">
         The
         <code class="calibre21">
          not_fn()
         </code>
         functor complements the result of every call to the callable it takes as a parameter.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c19-para-0099">
            <b class="calibre14">
             NOTE
            </b>
            <i class="calibre18">
             The
            </i>
            <code class="calibre21">
             std::not_fn()
            </code>
            <i class="calibre18">
             adapter is available since C++17. Before C++17 you could use the
            </i>
            <code class="calibre21">
             std::not1()
            </code>
            <i class="calibre18">
             and
            </i>
            <code class="calibre21">
             not2()
            </code>
            <i class="calibre18">
             adapters. However, both
            </i>
            <code class="calibre21">
             not1()
            </code>
            <i class="calibre18">
             and
            </i>
            <code class="calibre21">
             not2()
            </code>
            <i class="calibre18">
             have been deprecated since C++17 and removed from C++20. As such, they are not further discussed, and you should avoid using them.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
       <section class="calibre2">
        <span class="calibre" id="c19-sec-0028">
        </span>
        <h5 class="calibre35" id="head-5-134">
         Calling Member Functions
        </h5>
        <p class="calibre13">
         You might want to pass a pointer to a class member function as the callback to an algorithm. For example, suppose you have the following algorithm that prints
         <code class="calibre21">
          string
         </code>
         s from a container that match a certain condition. The
         <code class="calibre21">
          Matcher
         </code>
         template type parameter is constrained with
         <code class="calibre21">
          predicate&lt;const string&amp;&gt;
         </code>
         to make sure the user supplies a callback that can be called with a
         <code class="calibre21">
          string
         </code>
         parameter and returns a Boolean.
        </p>
        <pre class="calibre26" id="c19-code-0061"><code class="calibre21">template &lt;predicate&lt;const string&amp;&gt; Matcher&gt;</code>
<code class="calibre21">void printMatchingStrings(const vector&lt;string&gt;&amp; strings, Matcher matcher)</code>
<code class="calibre21">{</code>
<code class="calibre21">    for (const auto&amp; string : strings) {</code>
<code class="calibre21">        if (matcher(string)) { print("'{}' ", string); }</code>
<code class="calibre21">    }</code>
<code class="calibre21">}</code></pre>
        <p class="calibre13" id="c19-para-0101">
         You could use this algorithm to print all non-empty
         <code class="calibre21">
          string
         </code>
         s by using the
         <code class="calibre21">
          empty()
         </code>
         member function of
         <code class="calibre21">
          string
         </code>
         . However, if you just pass a pointer to
         <code class="calibre21">
          string::empty()
         </code>
         as the second argument to
         <code class="calibre21">
          printMatchingStrings()
         </code>
         , the algorithm has no way of knowing that it received a pointer to a member function instead of a normal function pointer or functor. The code to call a member function pointer is different from that of calling a normal function pointer, because the former must be called in the context of an object.
        </p>
        <p class="calibre13">
         <span aria-label="775" class="calibre20" epub:type="pagebreak" id="Page_775" role="doc-pagebreak">
         </span>
         C++ provides a conversion function called
         <code class="calibre21">
          mem_fn()
         </code>
         that you can call with a member function pointer before passing it to an algorithm. The following example demonstrates this and combines it with
         <code class="calibre21">
          not_fn()
         </code>
         to invert the result of
         <code class="calibre21">
          mem_fn()
         </code>
         . Note that you have to specify the member function pointer as
         <code class="calibre21">
          &amp;string::empty
         </code>
         . The
         <code class="calibre21">
          &amp;string::
         </code>
         part is not optional.
        </p>
        <pre class="calibre26" id="c19-code-0062"><code class="calibre21">vector&lt;string&gt; values { "Hello", "", "", "World", "!" };</code>
<code class="calibre21">printMatchingStrings(values, <b class="calibre14">not_fn(mem_fn(&amp;string::empty))</b>);</code></pre>
        <p class="calibre13">
         The output is as follows:
        </p>
        <pre class="calibre26" id="c19-code-0063"><code class="calibre21">'Hello' 'World' '!'</code></pre>
        <p class="calibre13">
         <code class="calibre21">
          not_fn(mem_fn())
         </code>
         generates a function object that serves as the callback for
         <code class="calibre21">
          printMatchingStrings()
         </code>
         . Each time it is called, it calls the
         <code class="calibre21">
          empty()
         </code>
         member function on its argument and inverts the result.
        </p>
        <section class="calibre2">
         <aside class="calibre23">
          <div class="top">
           <hr class="calibre24"/>
          </div>
          <section class="feature">
           <p class="calibre25" id="c19-para-0105">
            <b class="calibre14">
             NOTE
            </b>
            <code class="calibre21">
             mem_fn()
            </code>
            <i class="calibre18">
             is not the most intuitive way to implement the desired behavior. I recommend using lambda expressions, discussed later in this chapter, to implement it in a more elegant and more readable way.
            </i>
           </p>
           <div class="top">
            <hr class="calibre24"/>
           </div>
          </section>
         </aside>
        </section>
       </section>
      </section>
     </section>
    </section>
    <section aria-labelledby="head-2-210" class="calibre2">
     <span class="calibre" id="c19-sec-0030">
     </span>
     <h2 class="calibre6" id="head-2-210">
      POLYMORPHIC FUNCTION WRAPPERS
     </h2>
     <p class="calibre13" id="c19-para-0106">
      The C++ Standard Library provides
      <code class="calibre21">
       std::function
      </code>
      and
      <code class="calibre21">
       move_only_function
      </code>
      . Both are
      <i class="calibre18">
       polymorphic function wrappers
      </i>
      , which are function objects capable of wrapping anything that is callable such as a function, a function object, or a lambda expression; the latter is discussed later in this chapter.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0031">
      </span>
      <h3 class="calibre27" id="head-3-424">
       std::function
      </h3>
      <p class="calibre13">
       The
       <code class="calibre21">
        std::function
       </code>
       functor is defined in
       <code class="calibre21">
        &lt;functional&gt;
       </code>
       . An instance of
       <code class="calibre21">
        std::function
       </code>
       can be used as a function pointer, or as a parameter for a function to implement callbacks, and can be stored, copied, moved, and, of course, executed. The template parameters for the
       <code class="calibre21">
        function
       </code>
       template look a bit different than most template parameters. The syntax is as follows:
      </p>
      <pre class="calibre26" id="c19-code-0064"><code class="calibre21">std::function&lt;R(ArgTypes…)&gt;</code></pre>
      <p class="calibre13" id="c19-para-0108">
       <code class="calibre21">
        R
       </code>
       is the return type of the function, and
       <code class="calibre21">
        ArgTypes
       </code>
       is a comma-separated list of parameter types for the function.
      </p>
      <p class="calibre13">
       The following example demonstrates how to use
       <code class="calibre21">
        std::function
       </code>
       to implement a function pointer. It creates a function pointer
       <code class="calibre21">
        f1
       </code>
       to point to the function
       <code class="calibre21">
        func()
       </code>
       . Once
       <code class="calibre21">
        f1
       </code>
       is defined, you can use it to call
       <code class="calibre21">
        func()
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0065"><code class="calibre21">void func(int num, string_view str) { println("func({}, {})", num, str); }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">function&lt;void(int, string_view)&gt; f1 { func };</b></code>
<code class="calibre21">    f1(1, "test");</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       <span aria-label="776" class="calibre20" epub:type="pagebreak" id="Page_776" role="doc-pagebreak">
       </span>
       A
       <code class="calibre21">
        function&lt;R(ArgTypes…)&gt;
       </code>
       can store a function that has a parameter list exactly matching
       <code class="calibre21">
        ArgTypes
       </code>
       and a return type exactly of type
       <code class="calibre21">
        R
       </code>
       . It can also store any other function that has a parameter list allowing it to be called with a set of
       <code class="calibre21">
        ArgTypes
       </code>
       arguments and returning a type that can be converted to
       <code class="calibre21">
        R
       </code>
       . For example, the
       <code class="calibre21">
        func()
       </code>
       function in the previous example could accept its first parameter by
       <code class="calibre21">
        const int&amp;
       </code>
       , while nothing in
       <code class="calibre21">
        main()
       </code>
       needs to change:
      </p>
      <pre class="calibre26" id="c19-code-0066"><code class="calibre21">void func(<b class="calibre14">const int&amp; num</b>, string_view str) { println("func({}, {})", num, str); }</code></pre>
      <p class="calibre13">
       Thanks to class template argument deduction, you can simplify the creation of
       <code class="calibre21">
        f1
       </code>
       as follows:
      </p>
      <pre class="calibre26" id="c19-code-0067"><code class="calibre21">function f1 { func };</code></pre>
      <p class="calibre13">
       Of course, in the preceding example, it is possible to just use the
       <code class="calibre21">
        auto
       </code>
       keyword, which removes the need to specify the type of
       <code class="calibre21">
        f1
       </code>
       . The following definition for
       <code class="calibre21">
        f1
       </code>
       works the same and is much shorter, but the compiler-deduced type of
       <code class="calibre21">
        f1
       </code>
       is a function pointer, that is,
       <code class="calibre21">
        void (*f1)(int, string_view)
       </code>
       instead of an
       <code class="calibre21">
        std::function
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0068"><code class="calibre21">auto f1 { func };</code></pre>
      <p class="calibre13">
       Because
       <code class="calibre21">
        std::function
       </code>
       types behave as function pointers, they can be passed to functions accepting callbacks. The original
       <code class="calibre21">
        findMatches()
       </code>
       implementation from earlier in this chapter defines two type aliases as function pointers. Those type aliases can be rewritten to use
       <code class="calibre21">
        std::function
       </code>
       , while everything else from that example remains the same:
      </p>
      <pre class="calibre26" id="c19-code-0069"><code class="calibre21"><span class="color">// A type alias for a function accepting two integer values,</span></code>
<code class="calibre21"><span class="color">// returning true if both values are matching, false otherwise.</span></code>
<code class="calibre21">using Matcher = function&lt;bool(int, int)&gt;;</code>
<code class="calibre21"> </code>
<code class="calibre21"><span class="color">// A type alias for a function to handle a match. The first</span></code>
<code class="calibre21"><span class="color">// parameter is the position of the match,</span></code>
<code class="calibre21"><span class="color">// the second and third are the values that matched.</span></code>
<code class="calibre21">using MatchHandler = function&lt;void(size_t, int, int)&gt;;</code></pre>
      <p class="calibre13" id="c19-para-0114">
       Still, as mentioned earlier in this chapter, the recommended implementation for
       <code class="calibre21">
        findMatches()
       </code>
       uses a function template, instead of function pointers or
       <code class="calibre21">
        std::function
       </code>
       .
      </p>
      <p class="calibre13" id="c19-para-0115">
       So, with all these examples, it looks like
       <code class="calibre21">
        std::function
       </code>
       is not really that useful; however,
       <code class="calibre21">
        std::function
       </code>
       really shines when you need to store a callback as a data member of a class. That's the topic of one of the exercises at the end of this chapter.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0032">
      </span>
      <h3 class="calibre27" id="head-3-425">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       std::move_only_function
      </h3>
      <p class="calibre13" id="c19-para-0117">
       <code class="calibre21">
        std::function
       </code>
       requires that the callable stored in it is copyable. To alleviate this, C++23 introduces the move-only
       <code class="calibre21">
        std::move_only_function
       </code>
       wrapper, also defined in
       <code class="calibre21">
        &lt;functional&gt;
       </code>
       , that can be used to wrap a move-only callable. Additionally, the
       <code class="calibre21">
        move_only_function
       </code>
       functor allows you to explicitly mark its function call operator as
       <code class="calibre21">
        const
       </code>
       and/or
       <code class="calibre21">
        noexcept
       </code>
       . This is not possible with
       <code class="calibre21">
        std::function
       </code>
       , as its function call operator is always
       <code class="calibre21">
        const
       </code>
       .
      </p>
      <p class="calibre13">
       The following code snippet demonstrates
       <code class="calibre21">
        move_only_function
       </code>
       . Assume the
       <code class="calibre21">
        BigData
       </code>
       class stores a lot of data. The
       <code class="calibre21">
        BigDataProcessor
       </code>
       functor processes the data in an instance of
       <code class="calibre21">
        BigData
       </code>
       . To avoid copying, this functor stores a
       <code class="calibre21">
        unique_ptr
       </code>
       to a
       <code class="calibre21">
        BigData
       </code>
       instance, which it gets through its constructor. The function call operator is marked as
       <code class="calibre21">
        const
       </code>
       for demonstration purposes and simply prints out some text. The
       <code class="calibre21">
        main()
       </code>
       function first creates a
       <code class="calibre21">
        unique_ptr
       </code>
       of a
       <code class="calibre21">
        BigData
       </code>
       instance, creates a
       <span aria-label="777" class="calibre20" epub:type="pagebreak" id="Page_777" role="doc-pagebreak">
       </span>
       <code class="calibre21">
        const processor
       </code>
       , and finally calls the function call operator on
       <code class="calibre21">
        processor
       </code>
       . Using
       <code class="calibre21">
        function
       </code>
       instead of
       <code class="calibre21">
        move_only_function
       </code>
       in this example would not work because
       <code class="calibre21">
        BigDataProcessor
       </code>
       is a move-only type.
      </p>
      <pre class="calibre26" id="c19-code-0070"><code class="calibre21">class BigData {};</code>
<code class="calibre21"> </code>
<code class="calibre21">class BigDataProcessor</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit BigDataProcessor(unique_ptr&lt;BigData&gt; data)</code>
<code class="calibre21">            : m_data { move(data) } { }</code>
<code class="calibre21">        void operator()() const { println("Processing BigData data…"); }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        unique_ptr&lt;BigData&gt; m_data;</code>
<code class="calibre21">};</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto data { make_unique&lt;BigData&gt;() };</code>
<code class="calibre21">    <b class="calibre14">const move_only_function&lt;void() const&gt;</b> processor {</code>
<code class="calibre21">        BigDataProcessor { move(data) } };</code>
<code class="calibre21">    processor();</code>
<code class="calibre21">}</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-211" class="calibre2">
     <span class="calibre" id="c19-sec-0033">
     </span>
     <h2 class="calibre6" id="head-2-211">
      LAMBDA EXPRESSIONS
     </h2>
     <p class="calibre13" id="c19-para-0119">
      The clumsiness of having to create a function or functor class, give it a name that does not conflict with other names, and then use this name is considerable overhead for what is fundamentally a simple concept. In these cases, using anonymous (unnamed) functions represented by
      <i class="calibre18">
       lambda expressions
      </i>
      is a big convenience. Lambda expressions allow you to write anonymous functions inline. Their syntax is easier and can make your code more compact and easier to read. Lambda expressions are useful to define small callbacks passed to other functions inline, instead of having to define a full function object somewhere else with the callback logic implemented in its overloaded function call operator. This way, all the logic remains in a single place, and it is easier to understand and maintain. Lambda expressions can accept parameters, return values, be templated, access variables from its enclosing scope either by value or by reference, and more. There is a lot of flexibility. Let's start with building up the syntax of lambda expressions step-by-step.
     </p>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0034">
      </span>
      <h3 class="calibre27" id="head-3-426">
       Syntax
      </h3>
      <p class="calibre13">
       Let's start with a simple lambda expression. The following example defines a lambda expression that just writes a string to the console. A lambda expression starts with square brackets,
       <code class="calibre21">
        []
       </code>
       , called the
       <i class="calibre18">
        lambda introducer
       </i>
       , followed by curly braces,
       <code class="calibre21">
        {}
       </code>
       , which contain the body of the lambda expression. The lambda expression is assigned to the
       <code class="calibre21">
        basicLambda
       </code>
       auto-typed variable. The second line executes the lambda expression using normal function-call syntax.
      </p>
      <pre class="calibre26" id="c19-code-0071"><code class="calibre21">auto basicLambda { []{ println("Hello from Lambda"); } };</code>
<code class="calibre21">basicLambda();</code></pre>
      <p class="calibre13">
       The output is as follows:
      </p>
      <pre class="calibre26" id="c19-code-0072"><code class="calibre21">Hello from Lambda</code></pre>
      <p class="calibre13">
       <span aria-label="778" class="calibre20" epub:type="pagebreak" id="Page_778" role="doc-pagebreak">
       </span>
       The compiler automatically transforms any lambda expression to a function object, also called
       <i class="calibre18">
        lambda closure
       </i>
       , with a unique, compiler-generated name. For the previous example, the lambda expression is translated to a function object that behaves like the following function object. Note that the function call operator is a
       <code class="calibre21">
        const
       </code>
       member function and has an
       <code class="calibre21">
        auto
       </code>
       return type to let the compiler automatically deduce the return type based on the body of the member function.
      </p>
      <pre class="calibre26" id="c19-code-0073"><code class="calibre21">class CompilerGeneratedName</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">auto operator()() const { println("Hello from Lambda"); }</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c19-para-0123">
       The compiler-generated name of a lambda closure can be something exotic like
       <code class="calibre21">
        __Lambda_17Za
       </code>
       . There is no way for you to figure out this name, but luckily, you don't need to know its name.
      </p>
      <p class="calibre13">
       A lambda expression can accept parameters. Parameters are specified between parentheses and multiple parameters are separated by commas, just as with normal functions. Here is an example using one parameter called
       <code class="calibre21">
        value
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0074"><code class="calibre21">auto parametersLambda { [](int value){ println("The value is {}", value); } };</code>
<code class="calibre21">parametersLambda(42);</code></pre>
      <p class="calibre13" id="c19-para-0125">
       If a lambda expression does not accept any parameters, you can either specify empty parentheses or simply omit them.
      </p>
      <p class="calibre13">
       In the compiler-generated function object for this lambda expression, the parameters are simply translated to parameters for the overloaded function call operator:
      </p>
      <pre class="calibre26" id="c19-code-0075"><code class="calibre21">class CompilerGeneratedName</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">auto operator()(int value) const { println("The value is {}", value); }</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       A lambda expression can return a value. The return type is specified following an arrow, called a
       <i class="calibre18">
        trailing return type
       </i>
       . The following example defines a lambda expression accepting two parameters and returning their sum:
      </p>
      <pre class="calibre26" id="c19-code-0076"><code class="calibre21">auto sumLambda { [](int a, int b) -&gt; int { return a + b; } };</code>
<code class="calibre21">int sum { sumLambda(11, 22) };</code></pre>
      <p class="calibre13">
       The return type can be omitted, in which case the compiler deduces the return type of the lambda expression according to the same rules as for function return type deduction (see
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       ). In the previous example, the return type can be omitted as follows:
      </p>
      <pre class="calibre26" id="c19-code-0077"><code class="calibre21">auto sumLambda { [](int a, int b){ return a + b; } };</code>
<code class="calibre21">int sum { sumLambda(11, 22) };</code></pre>
      <p class="calibre13">
       The closure for this lambda expression behaves as follows:
      </p>
      <pre class="calibre26" id="c19-code-0078"><code class="calibre21">class CompilerGeneratedName</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">auto operator()(int a, int b) const { return a + b; }</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="779" class="calibre20" epub:type="pagebreak" id="Page_779" role="doc-pagebreak">
       </span>
       The return type deduction strips any reference and
       <code class="calibre21">
        const
       </code>
       qualifiers. For example, suppose you have the following
       <code class="calibre21">
        Person
       </code>
       class:
      </p>
      <pre class="calibre26" id="c19-code-0079"><code class="calibre21">class Person</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        explicit Person(std::string name) : m_name { std::move(name) } { }</code>
<code class="calibre21">        const std::string&amp; getName() const { return m_name; }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        std::string m_name;</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       The type of
       <code class="calibre21">
        name1
       </code>
       in the following code snippet is deduced as
       <code class="calibre21">
        string
       </code>
       ; hence, a copy of the person's name is made, even though
       <code class="calibre21">
        getName()
       </code>
       returns a
       <code class="calibre21">
        const string&amp;
       </code>
       . See
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       for a discussion of
       <code class="calibre21">
        decltype(auto)
       </code>
       .
      </p>
      <pre class="calibre26" id="c19-code-0080"><code class="calibre21">Person p { "John Doe" };</code>
<code class="calibre21">decltype(auto) name1 { [] (const Person&amp; person) { return person.getName(); }(p) };</code></pre>
      <p class="calibre13">
       You can use a trailing return type in combination with
       <code class="calibre21">
        decltype(auto)
       </code>
       to make it so that the deduced type matches the return type of
       <code class="calibre21">
        getName()
       </code>
       , that is a
       <code class="calibre21">
        const string&amp;
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0081"><code class="calibre21">decltype(auto) name2 { [](const Person&amp; person) <b class="calibre14">-&gt; decltype(auto)</b> {</code>
<code class="calibre21">    return person.getName(); }(p) };</code></pre>
      <p class="calibre13">
       The lambda expressions up to now in this section are called
       <i class="calibre18">
        stateless
       </i>
       because they don't capture anything from the enclosing scope. A lambda expression can be
       <i class="calibre18">
        stateful
       </i>
       by capturing variables from its enclosing scope. For example, the following lambda expression captures the variable
       <code class="calibre21">
        data
       </code>
       so that it can be used in its body:
      </p>
      <pre class="calibre26" id="c19-code-0082"><code class="calibre21">double data { 1.23 };</code>
<code class="calibre21">auto capturingLambda { [data]{ println("Data = {}", data); } };</code></pre>
      <p class="calibre13" id="c19-para-0134">
       The square brackets part serves as a
       <i class="calibre18">
        capture block
       </i>
       .
       <i class="calibre18">
        Capturing
       </i>
       a variable means that the variable becomes available inside the body of the lambda expression. Specifying an empty capture block,
       <code class="calibre21">
        []
       </code>
       , means that no variables from the enclosing scope are captured. When you just write the name of a variable in the capture block as in the preceding example, then you are capturing that variable by value.
      </p>
      <p class="calibre13">
       Captured variables become data members of the lambda closure. Variables captured by value are copied into data members of the functor. These data members have the same
       <code class="calibre21">
        const
       </code>
       ness as the captured variables. In the preceding
       <code class="calibre21">
        capturingLambda
       </code>
       example, the functor gets a non-
       <code class="calibre21">
        const
       </code>
       data member called
       <code class="calibre21">
        data
       </code>
       , because the captured variable,
       <code class="calibre21">
        data
       </code>
       , is non-
       <code class="calibre21">
        const
       </code>
       . The compiler-generated functor behaves as follows:
      </p>
      <pre class="calibre26" id="c19-code-0083"><code class="calibre21">class CompilerGeneratedName</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        <b class="calibre14">CompilerGeneratedName(const double&amp; d) : data { d } {}</b></code>
<code class="calibre21">        auto operator()() const { println("Data = {}", data); }</code>
<code class="calibre21">    private:</code>
<code class="calibre21">        <b class="calibre14">double data;</b></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       <span aria-label="780" class="calibre20" epub:type="pagebreak" id="Page_780" role="doc-pagebreak">
       </span>
       In the following example, the functor gets a
       <code class="calibre21">
        const
       </code>
       data member called
       <code class="calibre21">
        data
       </code>
       , because the captured variable is
       <code class="calibre21">
        const
       </code>
       :
      </p>
      <pre class="calibre26" id="c19-code-0084"><code class="calibre21">const double data { 1.23 };</code>
<code class="calibre21">auto capturingLambda { [data]{ println("Data = {}", data); } };</code></pre>
      <p class="calibre13">
       As mentioned earlier, a lambda closure has an overloaded function call operator that is marked as
       <code class="calibre21">
        const
       </code>
       by default. That means that even if you capture a non-
       <code class="calibre21">
        const
       </code>
       variable by value in a lambda expression, the lambda expression is not able to modify this copy. You can mark the function call operator as non-
       <code class="calibre21">
        const
       </code>
       by specifying the lambda expression as
       <code class="calibre21">
        mutable
       </code>
       , as follows:
      </p>
      <pre class="calibre26" id="c19-code-0085"><code class="calibre21">double data { 1.23 };</code>
<code class="calibre21">auto capturingLambda {</code>
<code class="calibre21">    [data] () mutable { data *= 2; println("Data = {}", data); } };</code></pre>
      <p class="calibre13" id="c19-para-0138">
       In this example, the non-
       <code class="calibre21">
        const
       </code>
       variable
       <code class="calibre21">
        data
       </code>
       is captured by value; thus, the functor gets a non-
       <code class="calibre21">
        const
       </code>
       data member that is a
       <b class="calibre14">
        copy
       </b>
       of
       <code class="calibre21">
        data
       </code>
       . Because of the
       <code class="calibre21">
        mutable
       </code>
       keyword, the function call operator is marked as non-
       <code class="calibre21">
        const
       </code>
       , and so the body of the lambda expression can modify its
       <b class="calibre14">
        copy
       </b>
       of
       <code class="calibre21">
        data
       </code>
       .
      </p>
      <p class="calibre13">
       You can prefix the name of a variable with
       <code class="calibre21">
        &amp;
       </code>
       to capture it by reference. The following example captures the variable
       <code class="calibre21">
        data
       </code>
       by reference so that the lambda expression can directly change
       <code class="calibre21">
        data
       </code>
       in the enclosing scope:
      </p>
      <pre class="calibre26" id="c19-code-0086"><code class="calibre21">double data { 1.23 };</code>
<code class="calibre21">auto capturingLambda { [&amp;data]{ data *= 2; } };</code></pre>
      <p class="calibre13" id="c19-para-0140">
       With this lambda expression, the compiler-generated functor contains a data member called
       <code class="calibre21">
        data
       </code>
       of type reference-to-
       <code class="calibre21">
        double
       </code>
       . When you capture a variable by reference, you have to make sure that the reference is still valid at the time the lambda expression is executed.
      </p>
      <p class="calibre13">
       There are two ways to capture all variables from the enclosing scope, called
       <i class="calibre18">
        capture defaults
       </i>
       :
      </p>
      <ul class="check" id="c19-list-0002">
       <li class="calibre9" id="c19-li-0007">
        <b class="calibre14">
         <code class="calibre21">
          [=]
         </code>
        </b>
        captures all variables by value.
       </li>
       <li class="calibre9" id="c19-li-0008">
        <b class="calibre14">
         <code class="calibre21">
          [&amp;]
         </code>
        </b>
        captures all variables by reference.
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c19-para-0143">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           When using a capture default, only those variables that are really used in the body of the lambda expression are captured, either by value (
           <code class="calibre21">
            =
           </code>
           ) or by reference (
           <code class="calibre21">
            &amp;
           </code>
           ). Unused variables are not captured
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       It is also possible to selectively decide which variables to capture and how, by specifying a
       <i class="calibre18">
        capture list
       </i>
       with an optional
       <i class="calibre18">
        capture default
       </i>
       . Variables prefixed with
       <code class="calibre21">
        &amp;
       </code>
       are captured by reference. Variables without a prefix are captured by value. If present, the capture default must be the first element in the capture list and be either
       <code class="calibre21">
        &amp;
       </code>
       or
       <code class="calibre21">
        =
       </code>
       . Here are some capture block examples:
      </p>
      <ul class="check" id="c19-list-0003">
       <li class="calibre9" id="c19-li-0009">
        <b class="calibre14">
         <code class="calibre21">
          [&amp;x]
         </code>
        </b>
        captures only
        <code class="calibre21">
         x
        </code>
        by reference and nothing else.
       </li>
       <li class="calibre9" id="c19-li-0010">
        <b class="calibre14">
         <code class="calibre21">
          [x]
         </code>
        </b>
        captures only
        <code class="calibre21">
         x
        </code>
        by value and nothing else.
       </li>
       <li class="calibre9" id="c19-li-0011">
        <b class="calibre14">
         <code class="calibre21">
          [=,&amp;x,&amp;y]
         </code>
        </b>
        captures by value by default, except variables
        <code class="calibre21">
         x
        </code>
        and
        <code class="calibre21">
         y
        </code>
        , which are captured by reference.
       </li>
       <li class="calibre9" id="c19-li-0012">
        <span aria-label="781" class="calibre20" epub:type="pagebreak" id="Page_781" role="doc-pagebreak">
        </span>
        <b class="calibre14">
         <code class="calibre21">
          [&amp;,x]
         </code>
        </b>
        captures by reference by default, except variable
        <code class="calibre21">
         x
        </code>
        , which is captured by value.
       </li>
       <li class="calibre9" id="c19-li-0013">
        [&amp;x,&amp;x] is illegal because identifiers cannot be repeated.
       </li>
      </ul>
      <p class="calibre13">
       When a lambda expression is created in the scope of an object, e.g., inside a member function of a class, then it's possible to capture
       <code class="calibre21">
        this
       </code>
       in several ways:
      </p>
      <ul class="check" id="c19-list-0004">
       <li class="calibre9" id="c19-li-0014">
        <b class="calibre14">
         <code class="calibre21">
          [this]
         </code>
        </b>
        captures the current object. In the body of the lambda expression you can access this object, even without using
        <code class="calibre21">
         this-&gt;
        </code>
        . You need to make sure that the object pointed to stays alive until the last time the lambda expression has been executed.
       </li>
       <li class="calibre9" id="c19-li-0015">
        [*this] captures a copy of the current object. This can be useful in cases where the original object will no longer be alive when the lambda expression is executed.
       </li>
       <li class="calibre9" id="c19-li-0016">
        [=,this] captures everything by value and explicitly captures the
        <code class="calibre21">
         this
        </code>
        pointer. Before C++20,
        <code class="calibre21">
         [=]
        </code>
        would implicitly capture the
        <code class="calibre21">
         this
        </code>
        pointer. In C++20, this has been deprecated, and you need to explicitly capture
        <code class="calibre21">
         this
        </code>
        if you need it.
       </li>
      </ul>
      <p class="calibre13">
       Here are a few notes on capture blocks:
      </p>
      <ul class="check" id="c19-list-0005">
       <li class="calibre9" id="c19-li-0017">
        If a by-value (
        <code class="calibre21">
         =
        </code>
        ) or by-reference (
        <code class="calibre21">
         &amp;
        </code>
        ) capture default is specified, then it is not allowed to additionally capture specific variables by value or by reference respectively. For example,
        <code class="calibre21">
         [=,x]
        </code>
        and
        <code class="calibre21">
         [&amp;,&amp;x]
        </code>
        are both invalid.
       </li>
       <li class="calibre9" id="c19-li-0018">
        Data members of an object cannot be captured, unless by using a lambda capture expression discussed later in this chapter.
       </li>
       <li class="calibre9" id="c19-li-0019">
        When capturing
        <code class="calibre21">
         this
        </code>
        , either by copying the
        <code class="calibre21">
         this
        </code>
        pointer,
        <code class="calibre21">
         [this]
        </code>
        , or by copying the current object,
        <code class="calibre21">
         [*this]
        </code>
        , the lambda expression has access to all
        <code class="calibre21">
         public
        </code>
        ,
        <code class="calibre21">
         protected
        </code>
        , and
        <code class="calibre21">
         private
        </code>
        data members and member functions of the captured object.
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c19-para-0148">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           It is not recommended to use a capture default, even though a capture default only captures those variables that are really used in the body of the lambda expression. By using a
           <code class="calibre21">
            =
           </code>
           capture default, you might accidentally cause an expensive copy. By using an
           <code class="calibre21">
            &amp;
           </code>
           capture default, you might accidentally modify a variable in the enclosing scope. I recommend you explicitly specify which variables you want to capture and how
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c19-para-0149">
          <b class="calibre14">
           WARNING
          </b>
          <i class="calibre18">
           Global variables are always captured by reference, even if asked to capture by value! For example, in the following code snippet, a capture default is used to capture everything by value. Yet, the global variable,
          </i>
          <code class="calibre21">
           global
          </code>
          <i class="calibre18">
           , is captured by reference, and its value is changed after executing the lambda
          </i>
          .
         </p>
         <pre class="calibre26" id="c19-code-0087"><code class="calibre21">    int global { 42 };</code>
<code class="calibre21">    int main()</code>
<code class="calibre21">    {</code>
<code class="calibre21">        auto lambda { [=] { global = 2; } };</code>
<code class="calibre21">        lambda();</code>
<code class="calibre21">        <span class="color">// global now has the value 2!</span></code>
<code class="calibre21">    }</code></pre>
         <p class="calibre25" id="c19-para-0151">
          <i class="calibre18">
           Additionally, capturing a global variable explicitly as follows is not allowed and results in a compilation error:
          </i>
         </p>
         <pre class="calibre26" id="c19-code-0088"><code class="calibre21">    auto lambda { [global] { global = 2; } };</code></pre>
         <p class="calibre25" id="c19-para-0153">
          <i class="calibre18">
           Even besides these problems, global variables are never recommended anyway
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
      <p class="calibre13">
       <span aria-label="782" class="calibre20" epub:type="pagebreak" id="Page_782" role="doc-pagebreak">
       </span>
       The complete syntax of a lambda expression is as follows:
      </p>
      <pre class="calibre26" id="c19-code-0089"><code class="calibre21">[capture_block] attributes1 (parameters) specifiers noexcept_specifier attributes2</code>
<code class="calibre21">    -&gt; return_type requires1 {body}</code></pre>
      <p class="calibre13">
       or
      </p>
      <pre class="calibre26" id="c19-code-0090"><code class="calibre21">[capture_block] &lt;template_params&gt; requires1 attributes1 (parameters) specifiers</code>
<code class="calibre21">    noexcept_specifier attributes2 -&gt; return_type requires2 {body}</code></pre>
      <p class="calibre13">
       Everything is optional except the capture block and the body:
      </p>
      <ul class="check" id="c19-list-0006">
       <li class="calibre9" id="c19-li-0020">
        <b class="calibre14">
         Capture block:
        </b>
        Called the
        <i class="calibre18">
         lambda introducer
        </i>
        and specifies how variables from the enclosing scope are captured and made available in the body of the lambda.
       </li>
       <li class="calibre9" id="c19-li-0021">
        <b class="calibre14">
         Template parameters:
        </b>
        Allows you to write parametrized lambda expressions, discussed later in this chapter.
       </li>
       <li class="calibre9" id="c19-li-0022">
        <b class="calibre14">
         Parameters:
        </b>
        A list of parameters for the lambda expression. If the lambda expression does not require any parameters, you can omit the set of parentheses or specify an empty set,
        <code class="calibre21">
         ()
        </code>
        .
        <a aria-describedby="c19-note-0001" class="calibre5" epub:type="noteref" href="#c19-note-0001" id="R_c19-note-0001" role="doc-noteref">
         <sup class="calibre22">
          1
         </sup>
        </a>
        The parameter list is similar to the parameter list for normal functions.
       </li>
       <li class="calibre9" id="c19-li-0023">
        <b class="calibre14">
         Specifiers:
        </b>
        The following specifiers are available:
        <ul class="check3" id="c19-list-7006">
         <li class="calibre9" id="c19-li-0024">
          <img alt="C++23" class="calibre15" src="images/icon1.png"/>
          <b class="calibre14">
           <code class="calibre21">
            mutable
           </code>
           :
          </b>
          Marks the function call operator of the lambda closure as mutable; see earlier examples.
         </li>
         <li class="calibre9" id="c19-li-0025">
          <b class="calibre14">
           <code class="calibre21">
            constexpr
           </code>
           :
          </b>
          Marks the function call operator of the lambda closure as
          <code class="calibre21">
           constexpr
          </code>
          , so it can be evaluated at compile time. Even if omitted, the function call operator will be
          <code class="calibre21">
           constexpr
          </code>
          implicitly if it satisfies all restrictions for
          <code class="calibre21">
           constexpr
          </code>
          functions.
         </li>
         <li class="calibre9" id="c19-li-0026">
          <b class="calibre14">
           <code class="calibre21">
            consteval:
           </code>
          </b>
          Marks the function call operator of the lambda closure as
          <code class="calibre21">
           consteval
          </code>
          , so it becomes an immediate function that must be evaluated at compile time; see
          <a class="calibre5" href="c09.xhtml">
           Chapter 9
          </a>
          , “Mastering Classes and Objects.”
          <code class="calibre21">
           constexpr
          </code>
          and
          <code class="calibre21">
           consteval
          </code>
          cannot be combined.
          <span aria-label="783" class="calibre20" epub:type="pagebreak" id="Page_783" role="doc-pagebreak">
          </span>
         </li>
         <li class="calibre9" id="c19-li-0027">
          <b class="calibre14">
           <code class="calibre21">
            static
           </code>
           (C++23)
           <code class="calibre21">
            :
           </code>
          </b>
          Marks the function call operator of the lambda closure as
          <code class="calibre21">
           static
          </code>
          . This can be specified only for stateless lambda expression, i.e., lambda expressions with an empty capture block! Adding this specifier allows the compiler to better optimize the generated code, especially if such stateless lambda expressions are stored inside an
          <code class="calibre21">
           std::function
          </code>
          or
          <code class="calibre21">
           move_only_function
          </code>
          wrapper.
         </li>
        </ul>
       </li>
       <li class="calibre9" id="c19-li-0028">
        <code class="calibre21">
         noexcept
        </code>
        <b class="calibre14">
         specifier:
        </b>
        Specifies
        <code class="calibre21">
         noexcept
        </code>
        clauses for the function call operator of the lambda closure, similar to
        <code class="calibre21">
         noexcept
        </code>
        clauses for normal functions.
       </li>
       <li class="calibre9" id="c19-li-0029">
        <img alt="C++23" class="calibre15" src="images/icon1.png"/>
        <b class="calibre14">
         Attributes 1 (C++23):
        </b>
        Specifies attributes for the function call operator of the lambda closure, e.g.,
        <code class="calibre21">
         [[nodiscard]]
        </code>
        . Attributes are discussed in
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        .
       </li>
       <li class="calibre9" id="c19-li-0030">
        <b class="calibre14">
         Attributes 2:
        </b>
        Specifies attributes for the lambda closure itself.
       </li>
       <li class="calibre9" id="c19-li-0031">
        <b class="calibre14">
         Return type:
        </b>
        The type of the returned value. If omitted, the compiler deduces the return type according to the same rules as for function return type deduction; see
        <a class="calibre5" href="c01_split_000.xhtml">
         Chapter 1
        </a>
        .
       </li>
       <li class="calibre9" id="c19-li-0032">
        <b class="calibre14">
         Requires clause 1 and 2:
        </b>
        Specifies template type constraints for the function call operator of the lambda closure.
        <a class="calibre5" href="c12.xhtml">
         Chapter 12
        </a>
        , “Writing Generic Code with Templates,” explains how such constraints can be specified.
       </li>
      </ul>
      <section class="calibre2">
       <aside class="calibre23">
        <div class="top">
         <hr class="calibre24"/>
        </div>
        <section class="feature">
         <p class="calibre25" id="c19-para-0159">
          <b class="calibre14">
           NOTE
          </b>
          <i class="calibre18">
           For lambda expressions that do not capture anything, the compiler automatically provides a conversion operator that converts the lambda expression to a function pointer. Such lambda expressions can then, for example, be used to pass to functions that accept a function pointer as one of their arguments
          </i>
          .
         </p>
         <div class="top">
          <hr class="calibre24"/>
         </div>
        </section>
       </aside>
      </section>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0041">
      </span>
      <h3 class="calibre27" id="head-3-427">
       Lambda Expressions as Parameters
      </h3>
      <p class="calibre13" id="c19-para-0160">
       Lambda expressions can be passed as arguments to functions in two ways. One option is to have a function parameter of type
       <code class="calibre21">
        std::function
       </code>
       that matches the signature of the lambda expression. Another option is to use a template type parameter.
      </p>
      <p class="calibre13">
       For example, a lambda expression can be passed to the
       <code class="calibre21">
        findMatches()
       </code>
       function from earlier in this chapter:
      </p>
      <pre class="calibre26" id="c19-code-0091"><code class="calibre21">vector values1 { 2, 5, 6, 9, 10, 1, 1 };</code>
<code class="calibre21">vector values2 { 4, 4, 2, 9, 0, 3, 1 };</code>
<code class="calibre21">findMatches(values1, values2,</code>
<code class="calibre21">    [](int value1, int value2) { return value1 == value2; },</code>
<code class="calibre21">    printMatch);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0042">
      </span>
      <h3 class="calibre27" id="head-3-428">
       Generic Lambda Expressions
      </h3>
      <p class="calibre13" id="c19-para-0162">
       It is possible to use auto type deduction for parameters of lambda expressions instead of explicitly specifying concrete types for them. To specify auto-type deduction for a parameter, the type is simply specified as
       <code class="calibre21">
        auto
       </code>
       ,
       <code class="calibre21">
        auto&amp;
       </code>
       , or
       <code class="calibre21">
        auto*
       </code>
       . The type deduction rules are the same as for template argument deduction.
      </p>
      <p class="calibre13">
       <span aria-label="784" class="calibre20" epub:type="pagebreak" id="Page_784" role="doc-pagebreak">
       </span>
       The following example defines a generic lambda expression called
       <code class="calibre21">
        areEqual
       </code>
       . This lambda expression is used as callback for the
       <code class="calibre21">
        findMatches()
       </code>
       function from earlier in this chapter:
      </p>
      <pre class="calibre26" id="c19-code-0092"><code class="calibre21"><span class="color">// Define a generic lambda expression to find equal values.</span></code>
<code class="calibre21"><b class="calibre14">auto areEqual { [](const auto&amp; value1, const auto&amp; value2) {</b></code>
<code class="calibre21">    <b class="calibre14">return value1 == value2; } };</b></code>
<code class="calibre21"><span class="color">// Use the generic lambda expression in a call to findMatches().</span></code>
<code class="calibre21">vector values1 { 2, 5, 6, 9, 10, 1, 1 };</code>
<code class="calibre21">vector values2 { 4, 4, 2, 9, 0, 3, 1 };</code>
<code class="calibre21">findMatches(values1, values2, <b class="calibre14">areEqual</b>, printMatch);</code></pre>
      <p class="calibre13">
       The compiler-generated functor for this generic lambda expression behaves like this:
      </p>
      <pre class="calibre26" id="c19-code-0093"><code class="calibre21">class CompilerGeneratedName</code>
<code class="calibre21">{</code>
<code class="calibre21">    public:</code>
<code class="calibre21">        template &lt;typename T1, typename T2&gt;</code>
<code class="calibre21">        auto operator()(const T1&amp; value1, const T2&amp; value2) const {</code>
<code class="calibre21">            return value1 == value2; }</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13" id="c19-para-0165">
       If the
       <code class="calibre21">
        findMatches()
       </code>
       function is modified to support not only
       <code class="calibre21">
        span
       </code>
       s of
       <code class="calibre21">
        int
       </code>
       s, but also other types, then the
       <code class="calibre21">
        areEqual
       </code>
       generic lambda expression can still be used without requiring any changes to it.
      </p>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0043">
      </span>
      <h3 class="calibre27" id="head-3-429">
       Lambda Capture Expressions
      </h3>
      <p class="calibre13">
       <i class="calibre18">
        Lambda capture expressions
       </i>
       allow you to initialize capture variables with any expression. It can be used to introduce variables in the lambda expression that are not captured from the enclosing scope. For example, the following code creates a lambda expression with two variables in its capture block: one called
       <code class="calibre21">
        myCapture
       </code>
       , initialized with the string “Pi: ” using a lambda capture expression, and one called
       <code class="calibre21">
        pi
       </code>
       , which is captured by value from the enclosing scope. Note that non-reference capture variables such as
       <code class="calibre21">
        myCapture
       </code>
       that are initialized with a capture initializer are copy constructed, which means that
       <code class="calibre21">
        const
       </code>
       qualifiers are stripped.
      </p>
      <pre class="calibre26" id="c19-code-0094"><code class="calibre21">double pi { 3.1415 };</code>
<code class="calibre21">auto myLambda { <b class="calibre14">[myCapture = "Pi: ", pi]</b>{ println("{}{}", myCapture, pi); } };</code></pre>
      <p class="calibre13">
       A lambda capture variable can be initialized with any expression and thus also with
       <code class="calibre21">
        std::move()
       </code>
       . This is important for objects that cannot be copied, only moved, such as
       <code class="calibre21">
        unique_ptr
       </code>
       . By default, capturing by value uses copy semantics, so it's impossible to capture a
       <code class="calibre21">
        unique_ptr
       </code>
       by value in a lambda expression. Using a lambda capture expression, it is possible to capture it by moving, as in this example:
      </p>
      <pre class="calibre26" id="c19-code-0095"><code class="calibre21">auto myPtr { make_unique&lt;double&gt;(3.1415) };</code>
<code class="calibre21">auto myLambda { <b class="calibre14">[p = move(myPtr)]</b>{ println("{}", *p); } };</code></pre>
      <p class="calibre13">
       It is allowed, though not recommended, to have the same name for the capture variable as the name in the enclosing scope. The previous example can be written as follows:
      </p>
      <pre class="calibre26" id="c19-code-0096"><code class="calibre21">auto myPtr { make_unique&lt;double&gt;(3.1415) };</code>
<code class="calibre21">auto myLambda { <b class="calibre14">[myPtr = move(myPtr)]</b>{ println("{}", *myPtr); } };</code></pre>
     </section>
     <span aria-label="785" class="calibre20" epub:type="pagebreak" id="Page_785" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0044">
      </span>
      <h3 class="calibre27" id="head-3-430">
       Templated Lambda Expressions
      </h3>
      <p class="calibre13">
       <i class="calibre18">
        Templated lambda expressions
       </i>
       allow you to get easier access to type information of parameters of generic lambda expressions. For example, suppose you have a lambda expression that requires a
       <code class="calibre21">
        vector
       </code>
       to be passed as an argument. However, the type of elements in the
       <code class="calibre21">
        vector
       </code>
       can be anything; hence, it's a generic lambda expression using
       <code class="calibre21">
        auto
       </code>
       for its parameter. The body of the lambda expression wants to figure out what the type of the elements in the
       <code class="calibre21">
        vector
       </code>
       is. Without templated lambda expressions, this could be done using
       <code class="calibre21">
        decltype()
       </code>
       and the
       <code class="calibre21">
        std::decay_t
       </code>
       type trait. Type traits are explained in
       <a class="calibre5" href="c26.xhtml">
        Chapter 26
       </a>
       , “Advanced Templates,” but those details are not important to grasp the benefits of templated lambda expressions. It suffices to know that
       <code class="calibre21">
        decay_t
       </code>
       removes, among other things, any
       <code class="calibre21">
        const
       </code>
       and reference qualifications from a type. Here is the generic lambda expression:
      </p>
      <pre class="calibre26" id="c19-code-0097"><code class="calibre21">auto lambda { [](const auto&amp; values) {</code>
<code class="calibre21">    using V = decay_t&lt;decltype(values)&gt;; <span class="color">// The real type of the vector.</span></code>
<code class="calibre21">    using T = typename V::value_type;    <span class="color">// The type of the elements of the vector.</span></code>
<code class="calibre21">    T someValue { };</code>
<code class="calibre21">} };</code></pre>
      <p class="calibre13">
       You can call this lambda expression as follows:
      </p>
      <pre class="calibre26" id="c19-code-0098"><code class="calibre21">vector values { 1, 2, 100, 5, 6 };</code>
<code class="calibre21">lambda(values);</code></pre>
      <p class="calibre13">
       Using
       <code class="calibre21">
        decltype()
       </code>
       and
       <code class="calibre21">
        decay_t
       </code>
       is rather convoluted. A templated lambda expression makes this much easier. The following lambda expression forces its parameter to be a
       <code class="calibre21">
        vector
       </code>
       but still uses a template type parameter for the
       <code class="calibre21">
        vector
       </code>
       's element type:
      </p>
      <pre class="calibre26" id="c19-code-0099"><code class="calibre21">auto lambda { [] <b class="calibre14">&lt;typename T&gt;</b> (const <b class="calibre14">vector&lt;T&gt;</b> &amp; values) {</code>
<code class="calibre21">    T someValue { };</code>
<code class="calibre21">} };</code></pre>
      <p class="calibre13">
       Another use of templated lambda expressions is if you want to put certain restrictions on generic lambda expressions. For example, suppose you have the following generic lambda expression:
      </p>
      <pre class="calibre26" id="c19-code-0100"><code class="calibre21">[](const auto&amp; value1, const auto&amp; value2) { <span class="color">/* … */</span> }</code></pre>
      <p class="calibre13">
       This lambda expression accepts two parameters, and the compiler deduces the type of each parameter automatically. Since the type of both parameters is deduced separately, the type of
       <code class="calibre21">
        value1
       </code>
       and
       <code class="calibre21">
        value2
       </code>
       could be different. If you want to restrict this and want both parameters to have the same type, you can turn this into a templated lambda expression:
      </p>
      <pre class="calibre26" id="c19-code-0101"><code class="calibre21">[] &lt;typename T&gt; (const T&amp; value1, const T&amp; value2) { <span class="color">/* … */</span> }</code></pre>
      <p class="calibre13">
       You can also put constraints on the template types by adding a
       <code class="calibre21">
        requires
       </code>
       clause, discussed in
       <a class="calibre5" href="c12.xhtml">
        Chapter 12
       </a>
       . Here's an example:
      </p>
      <pre class="calibre26" id="c19-code-0102"><code class="calibre21">[] &lt;typename T&gt; (const T&amp; value1, const T&amp; value2) requires integral&lt;T&gt; {<span class="color">/* … */</span>}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0045">
      </span>
      <h3 class="calibre27" id="head-3-431">
       Lambda Expressions as Return Type
      </h3>
      <p class="calibre13">
       By using
       <code class="calibre21">
        std::function
       </code>
       , discussed earlier in this chapter, lambda expressions can be returned from functions. Take a look at the following definition:
      </p>
      <pre class="calibre26" id="c19-code-0103"><span aria-label="786" class="calibre20" epub:type="pagebreak" id="Page_786" role="doc-pagebreak"></span><code class="calibre21">function&lt;int(void)&gt; multiplyBy2Lambda(int x)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return [x]{ return 2 * x; };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The body of this function creates a lambda expression that captures the variable
       <code class="calibre21">
        x
       </code>
       from the enclosing scope by value and returns an integer that is two times the value passed to
       <code class="calibre21">
        multiplyBy2Lambda()
       </code>
       . The return type of the
       <code class="calibre21">
        multiplyBy2Lambda()
       </code>
       function is
       <code class="calibre21">
        function&lt;int(void)&gt;
       </code>
       , which is a function accepting no arguments and returning an integer. The lambda expression defined in the body of the function exactly matches this prototype. The variable
       <code class="calibre21">
        x
       </code>
       is captured by value, and thus a copy of the value of
       <code class="calibre21">
        x
       </code>
       is bound to the
       <code class="calibre21">
        x
       </code>
       in the lambda expression before the lambda is returned from the function. The function can be called as follows:
      </p>
      <pre class="calibre26" id="c19-code-0104"><code class="calibre21">function&lt;int(void)&gt; fn { multiplyBy2Lambda(5) };</code>
<code class="calibre21">println("{}", fn());</code></pre>
      <p class="calibre13">
       You can use the
       <code class="calibre21">
        auto
       </code>
       keyword to make this easier:
      </p>
      <pre class="calibre26" id="c19-code-0105"><code class="calibre21">auto fn { multiplyBy2Lambda(5) };</code>
<code class="calibre21">println("{}", fn());</code></pre>
      <p class="calibre13" id="c19-para-0178">
       The output is
       <code class="calibre21">
        10
       </code>
       .
      </p>
      <p class="calibre13">
       Function return type deduction (see
       <a class="calibre5" href="c01_split_000.xhtml">
        Chapter 1
       </a>
       ) allows you to write the
       <code class="calibre21">
        multiplyBy2Lambda()
       </code>
       function more elegantly, as follows:
      </p>
      <pre class="calibre26" id="c19-code-0106"><code class="calibre21">auto multiplyBy2Lambda(int x)</code>
<code class="calibre21">{</code>
<code class="calibre21">    return [x]{ return 2 * x; };</code>
<code class="calibre21">}</code></pre>
      <p class="calibre13">
       The
       <code class="calibre21">
        multiplyBy2Lambda()
       </code>
       function captures the variable
       <code class="calibre21">
        x
       </code>
       by value,
       <code class="calibre21">
        [x]
       </code>
       . Suppose the function is rewritten to capture the variable by reference,
       <code class="calibre21">
        [&amp;x]
       </code>
       , as follows. This will not work because the lambda expression will be executed later in the program, no longer in the scope of the
       <code class="calibre21">
        multiplyBy2Lambda()
       </code>
       function, at which point the reference to
       <code class="calibre21">
        x
       </code>
       is not valid anymore.
      </p>
      <pre class="calibre26" id="c19-code-0107"><code class="calibre21">auto multiplyBy2Lambda(int x)</code>
<code class="calibre21">{</code>
<code class="calibre21">    <b class="calibre14">return [&amp;x]{ return 2 * x; };</b> <span class="color">// BUG!</span></code>
<code class="calibre21">}</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0046">
      </span>
      <h3 class="calibre27" id="head-3-432">
       Lambda Expressions in Unevaluated Contexts
      </h3>
      <p class="calibre13">
       Lambda expressions can be used in
       <i class="calibre18">
        unevaluated contexts
       </i>
       . For instance, the argument passed to
       <code class="calibre21">
        decltype()
       </code>
       is used only at compile time and never evaluated. Here is an example of using
       <code class="calibre21">
        decltype()
       </code>
       with a lambda expression:
      </p>
      <pre class="calibre26" id="c19-code-0108"><code class="calibre21">using LambdaType = decltype([](int a, int b) { return a + b; });</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0047">
      </span>
      <h3 class="calibre27" id="head-3-433">
       Default Construction, Copying, and Assigning
      </h3>
      <p class="calibre13">
       Stateless lambda expressions can be default constructed, copied, and assigned to. Here is a quick example:
      </p>
      <pre class="calibre26" id="c19-code-0109"><code class="calibre21">auto lambda { [](int a, int b) { return a + b; } }; <span class="color">// A stateless lambda.</span></code>
<span aria-label="787" class="calibre20" epub:type="pagebreak" id="Page_787" role="doc-pagebreak"></span><code class="calibre21">decltype(lambda) lambda2; <span class="color">// Default construction.</span></code>
<code class="calibre21">auto copy { lambda };     <span class="color">// Copy construction.</span></code>
<code class="calibre21">copy = lambda2;           <span class="color">// Copy assignment.</span></code></pre>
      <p class="calibre13">
       Combined with using lambda expressions in unevaluated contexts, the following kind of code is valid:
      </p>
      <pre class="calibre26" id="c19-code-0110"><code class="calibre21">using LambdaType = decltype([](int a, int b) { return a + b; }); <span class="color">// Unevaluated.</span></code>
<code class="calibre21">LambdaType getLambda() { return LambdaType{}; <span class="color">/* Default construction. */</span> }</code></pre>
      <p class="calibre13">
       You can test this function as follows:
      </p>
      <pre class="calibre26" id="c19-code-0111"><code class="calibre21">println("{}", <b class="calibre14">getLambda()(1, 2)</b>);</code></pre>
     </section>
     <section class="calibre2">
      <span class="calibre" id="c19-sec-0048">
      </span>
      <h3 class="calibre27" id="head-3-434">
       <img alt="C++23" class="calibre15" src="images/icon1.png"/>
       Recursive Lambda Expressions
      </h3>
      <p class="calibre13">
       For a normal lambda expression, it is not trivial for it to call itself from within its body, even when you give a name to the lambda expression. For example, the following lambda expression given the name
       <code class="calibre21">
        fibonacci
       </code>
       tries to call itself twice in the second
       <code class="calibre21">
        return
       </code>
       statement. This lambda expression will not compile.
      </p>
      <pre class="calibre26" id="c19-code-0112"><code class="calibre21">auto fibonacci = [](int n) {</code>
<code class="calibre21">    if (n &lt; 2) { return n; }</code>
<code class="calibre21">    return <b class="calibre14">fibonacci</b>(n - 1) + <b class="calibre14">fibonacci</b>(n - 2);  <span class="color">// Error: does not compile!</span></code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       With C++23's explicit object parameters feature, introduced in
       <a class="calibre5" href="c08.xhtml">
        Chapter 8
       </a>
       , “Gaining Proficiency with Classes and Objects,” it is possible to do exactly that. This allows you to write
       <i class="calibre18">
        recursive lambda expressions
       </i>
       . The following demonstrates such a recursive lambda expression. It uses the explicit object parameter named
       <code class="calibre21">
        self
       </code>
       and calls itself recursively twice in the second
       <code class="calibre21">
        return
       </code>
       statement.
      </p>
      <pre class="calibre26" id="c19-code-0113"><code class="calibre21">auto fibonacci = [](<b class="calibre14">this auto&amp; self</b>, int n) {</code>
<code class="calibre21">    if (n &lt; 2) { return n; }</code>
<code class="calibre21">    return <b class="calibre14">self</b>(n - 1) + <b class="calibre14">self</b>(n - 2);</code>
<code class="calibre21">};</code></pre>
      <p class="calibre13">
       This recursive lambda expression can be tested as follows:
      </p>
      <pre class="calibre26" id="c19-code-0114"><code class="calibre21">println("First 20 Fibonacci numbers:");</code>
<code class="calibre21">for (int i { 0 }; i &lt; 20; ++i) { print("{} ", fibonacci(i)); }</code></pre>
      <p class="calibre13">
       The output is as expected:
      </p>
      <pre class="calibre26" id="c19-code-0115"><code class="calibre21">First 20 Fibonacci numbers:</code>
<code class="calibre21">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</code></pre>
     </section>
    </section>
    <section aria-labelledby="head-2-212" class="calibre2">
     <span class="calibre" id="c19-sec-0049">
     </span>
     <h2 class="calibre6" id="head-2-212">
      INVOKERS
     </h2>
     <p class="calibre13">
      <code class="calibre21">
       std::invoke()
      </code>
      , defined in
      <code class="calibre21">
       &lt;functional&gt;
      </code>
      , can be used to call any callable with a set of arguments. The following example uses
      <code class="calibre21">
       invoke()
      </code>
      three times: once to invoke a normal function, once to invoke a lambda expression, and once to invoke a member function on a
      <code class="calibre21">
       string
      </code>
      instance:
     </p>
     <pre class="calibre26" id="c19-code-0116"><code class="calibre21">void printMessage(string_view message) { println("{}", message); }</code>
<code class="calibre21"> </code>
<span aria-label="788" class="calibre20" epub:type="pagebreak" id="Page_788" role="doc-pagebreak"></span><code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    invoke(printMessage, "Hello invoke.");</code>
<code class="calibre21">    invoke([](const auto&amp; msg) { println("{}", msg); }, "Hello invoke.");</code>
<code class="calibre21">    string msg { "Hello invoke." };</code>
<code class="calibre21">    println("{}", invoke(&amp;string::size, msg));</code>
<code class="calibre21">}</code></pre>
     <p class="calibre13">
      The output of this code is as follows:
     </p>
     <pre class="calibre26" id="c19-code-0117"><code class="calibre21">Hello invoke.</code>
<code class="calibre21">Hello invoke.</code>
<code class="calibre21">13</code></pre>
     <p class="calibre13">
      <img alt="C++23" class="calibre15" src="images/icon1.png"/>
      C++23 adds
      <code class="calibre21">
       std::invoke_r()
      </code>
      , also defined in
      <code class="calibre21">
       &lt;functional&gt;
      </code>
      , allowing you to specify the return type. Here is an example:
     </p>
     <pre class="calibre26" id="c19-code-0118"><code class="calibre21">int sum(int a, int b) { return a + b; }</code>
<code class="calibre21"> </code>
<code class="calibre21">int main()</code>
<code class="calibre21">{</code>
<code class="calibre21">    auto res1 { invoke(sum, 11, 22) };           <span class="color">// Type of res1 is int.</span></code>
<code class="calibre21">    auto res2 { invoke_r&lt;double&gt;(sum, 11, 22) }; <span class="color">// Type of res2 is double.</span></code>
<code class="calibre21">}</code></pre>
     <section class="calibre2">
      <aside class="calibre23">
       <div class="top">
        <hr class="calibre24"/>
       </div>
       <section class="feature">
        <p class="calibre25" id="c19-para-0195">
         <b class="calibre14">
          NOTE
         </b>
         <i class="calibre18">
          By themselves,
         </i>
         <code class="calibre21">
          invoke()
         </code>
         <i class="calibre18">
          and
         </i>
         <code class="calibre21">
          invoke_r()
         </code>
         <i class="calibre18">
          are not that useful because you might as well just call the function or the lambda expression directly. However, they can be very useful when writing generic templated code where you need to invoke some arbitrary callable.
         </i>
        </p>
        <div class="top">
         <hr class="calibre24"/>
        </div>
       </section>
      </aside>
     </section>
    </section>
    <section aria-labelledby="head-2-213" class="calibre2">
     <span class="calibre" id="c19-sec-0051">
     </span>
     <h2 class="calibre6" id="head-2-213">
      SUMMARY
     </h2>
     <p class="calibre13" id="c19-para-0196">
      This chapter explained the concept of callbacks, which are functions that are passed to other functions to customize their behavior. You've seen that callbacks can be function pointers, function objects, or lambda expressions. You also learned that lambda expressions allow you to write more readable code than composing operations using function objects and adapter function objects. Remember, writing readable code is as important, if not more important, than writing code that works. So, even if a lambda expression is a bit longer than an adapted function object, the lambda expression will be more readable and hence more maintainable.
     </p>
     <p class="calibre13" id="c19-para-0197">
      Now that you are fluent in working with callbacks, it's time to delve into the true power of the Standard Library with a discussion of its generic algorithms.
     </p>
    </section>
    <section aria-labelledby="head-2-214" class="calibre2">
     <span class="calibre" id="c19-sec-0052">
     </span>
     <h2 class="calibre6" id="head-2-214">
      EXERCISES
     </h2>
     <p class="calibre13" id="c19-para-0198">
      By solving the following exercises, you can practice the material discussed in this chapter. Solutions to all exercises are available with the code download on the book's website at
      <code class="calibre21">
       <a class="calibre5" href="http://www.wiley.com/go/proc++6e">
        www.wiley.com/go/proc++6e
       </a>
      </code>
      . However, if you are stuck on an exercise, first reread parts of this chapter to try to find an answer yourself before looking at the solution from the website.
     </p>
     <span aria-label="789" class="calibre20" epub:type="pagebreak" id="Page_789" role="doc-pagebreak">
     </span>
     <section class="calibre2">
      <span class="calibre" id="c19-exsec-0001">
      </span>
      <ol class="none1">
       <li class="calibre9" id="c19-ex-0001">
        <b class="calibre14">
         Exercise 19-1:
        </b>
        Rewrite the
        <code class="calibre21">
         IsLargerThan
        </code>
        function object example from this chapter using a lambda expression. You can find the code in the downloadable source code archive in
        <code class="calibre21">
         Ch19\03_FunctionObjects\01_IsLargerThan.cpp
        </code>
        .
       </li>
       <li class="calibre9" id="c19-ex-0002">
        <b class="calibre14">
         Exercise 19-2:
        </b>
        Rewrite the example given for
        <code class="calibre21">
         bind()
        </code>
        using lambda expressions instead. You can find the code in the downloadable source code archive in
        <code class="calibre21">
         Ch19\03_FunctionObjects\07_bind.cpp
        </code>
        .
       </li>
       <li class="calibre9" id="c19-ex-0003">
        <b class="calibre14">
         Exercise 19-3:
        </b>
        Rewrite the example given for binding the class member function
        <code class="calibre21">
         Handler::handleMatch()
        </code>
        using lambda expressions instead. You can find the code in the downloadable source code archive in
        <code class="calibre21">
         Ch19\03_FunctionObjects\10_FindMatchesWithMemberFunctionPointer.cpp
        </code>
        .
       </li>
       <li class="calibre9" id="c19-ex-0004">
        <b class="calibre14">
         Exercise 19-4:
        </b>
        <a class="calibre5" href="c18_split_000.xhtml">
         Chapter 18
        </a>
        introduces the
        <code class="calibre21">
         std::erase_if()
        </code>
        function to remove elements from a container for which a certain predicate returns
        <code class="calibre21">
         true
        </code>
        . Now that you know everything about callbacks, write a small program that creates a
        <code class="calibre21">
         vector
        </code>
        of integers, and then uses
        <code class="calibre21">
         erase_if()
        </code>
        to remove all odd values from the
        <code class="calibre21">
         vector
        </code>
        . The predicate you need to pass to
        <code class="calibre21">
         erase_if()
        </code>
        should accept a single value and return a Boolean.
       </li>
       <li class="calibre9" id="c19-ex-0005">
        <b class="calibre14">
         Exercise 19-5:
        </b>
        Implement a class called
        <code class="calibre21">
         Processor
        </code>
        . The constructor should accept a callback accepting a single integer and returning an integer. Store this callback in a data member of the class. Next, add an overload for the function call operator accepting an integer and returning an integer. The implementation simply forwards the work to the stored callback. Test your class with different callbacks.
       </li>
       <li class="calibre9" id="c19-ex-0006">
        <b class="calibre14">
         Exercise 19-6:
        </b>
        Write a recursive lambda expression to calculate the power of a number. For example, 4 to the power 3, written as 4^3, equals 4×4×4. Make sure it works with negative exponents. To help you, 4^-3 equals 1/(4^3). Any number to the power 0 equals 1. Test your lambda expression by generating all powers of two with exponents between -10 and 10.
       </li>
      </ol>
     </section>
    </section>
   </section>
   <section aria-labelledby="c19_2" class="calibre2" role="doc-endnotes">
    <h2 class="calibre6" id="c19_2">
     NOTE
    </h2>
    <ol class="noteslist">
     <li class="noteentry">
      <a class="calibre5" href="#R_c19-note-0001" id="c19-note-0001" role="doc-backlink">
       1
      </a>
      Prior to C++23, you could only omit the empty set of parentheses if you did not need any parameters and you did not specify
      <code class="calibre21">
       mutable
      </code>
      ,
      <code class="calibre21">
       constexpr
      </code>
      ,
      <code class="calibre21">
       consteval
      </code>
      , a
      <code class="calibre21">
       noexcept
      </code>
      specifier, attributes, a return type, or a requires clause.
     </li>
    </ol>
   </section>
  </div>
 </body>
</html>
